[{"k":"v","n":"&infix:<?&>","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"k":"s","n":"infix:<?&>","s":{"p":[{"t":"Mu","n":"$x?"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"a"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<?&>","m":1,"k":"s"},{"k":"ro","n":"Stringy","b":"C","d":"<p><pre><code>role Stringy { ... }</code></pre></p><p>Common role for string types (such as Str).</p>","mro":[],"t":"Stringy"},{"t":"Sub+{is-pure}","k":"v","n":"&asec"},{"k":"s","m":1,"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"},"n":"asec"},{"s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]},"n":"asec","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"n":"asec","k":"s"},{"d":"<p><pre><code>class HyperWhatever { }</code></pre></p><p>HyperWhatever is very similar in functionality to Whatever. The difference lies in HyperWhatever standing in for multiple values, rather than a single one.</p>","k":"c","t":"HyperWhatever","b":"A","mro":["Any"],"m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"Capture"}],"n":"HyperWhatever"},{"n":"&infix:<^…>","t":"Sub+{Precedence}","k":"v"},{"m":1,"n":"infix:<^…>","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Mu","n":"b"}]}},{"s":{"p":[{"t":"Any","n":"lol"}],"r":"Mu"},"k":"s","n":"infix:<^…>","m":1},{"t":"Sub","n":"&hash","k":"v"},{"n":"hash","k":"s","s":{"p":[{"t":"Associative","n":"*%h"}],"r":"Mu"},"m":1},{"m":1,"n":"hash","k":"s","s":{"p":[{"t":"Positional","n":"*@a"},{"n":"*%h","t":"Associative"}],"r":"Mu"}},{"k":"v","d":"<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise XOR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>","n":"&infix:<~^>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","m":1,"s":{"p":[{"n":"$x?","t":"Any"}],"r":"Mu"},"n":"infix:<~^>"},{"k":"s","n":"infix:<~^>","m":1,"s":{"p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}],"r":"Mu"}},{"k":"s","m":1,"s":{"p":[{"t":"Blob","n":"a"},{"n":"b","t":"Blob"}],"r":"Mu"},"n":"infix:<~^>"},{"m":1,"n":"infix:<~^>","k":"s","s":{"p":[{"t":"Str","n":"a"},{"n":"b","t":"Str"}],"r":"Str:D"}},{"n":"infix:<~^>","m":1,"s":{"r":"str","p":[{"t":"str","n":"$a"},{"n":"$b","t":"str"}]},"k":"s"},{"k":"v","t":"Sub","n":"&atomic-fetch-inc"},{"k":"s","s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"}]},"n":"atomic-fetch-inc","m":1},{"n":"&map","t":"Sub","k":"v"},{"s":{"p":[{"n":"&code","t":"Callable"},{"n":"+values","t":"Any"}],"r":"Mu"},"n":"map","m":1,"k":"s"},{"n":"PF_INET","t":"ProtocolFamily","k":"e"},{"n":"num64","t":"num64","k":"n"},{"n":"&cosech","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"m":1,"k":"s","n":"cosech"},{"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"m":1,"n":"cosech","k":"s"},{"s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"k":"s","n":"cosech","m":1},{"n":"&goto","k":"v","t":"Sub"},{"s":{"p":[{"t":"Label","n":"x"}],"r":"Nil"},"n":"goto","m":1,"k":"s"},{"d":"<p><pre><code>class Duration is Cool does Real { }</code></pre></p><p>A Duration represents a length of time in atomic seconds, with fractions. Like an Instant, it is epoch-agnostic.</p><p>Durations can be subtracted from or added to Instants to yield another, new Instant. Subtracting one Instant from another yields a Duration. A Duration can also result from mathematical operations between two Durations when it makes sense (namely, the addition, subtraction, or modulus of two Durations). It can also be added, subtracted or divided modulo Real numbers.</p><p>The type of object returned for other numeric operations is currently unspecified.</p>","a":[{"t":"Rat","n":"$.tai","k":"v"}],"b":"C","t":"Duration","k":"c","n":"Duration","m":[{"n":"Bridge","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Num:D"}},{"m":0,"k":"m","s":{"r":"Num:D","p":[{"t":"Mu","n":"*%_"}]},"n":"Num"},{"m":0,"k":"m","s":{"r":"Rat:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Rat"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"narrow"},{"m":0,"n":"tai","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"mro":["Real","Numeric","Cool"]},{"t":"X::TooLateForREPR","n":"X::TooLateForREPR","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"type"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s","m":0}],"a":[{"k":"v","n":"$.type","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A","mro":["X::Comp","X::Comp"],"k":"c"},{"m":[{"m":0,"n":"message","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"package-kind","k":"m","m":0},{"m":0,"n":"filename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"k":"m","n":"line","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"post","k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","m":0,"n":"BUILDALL"}],"a":[{"k":"v","n":"$.package-kind","t":"Mu"},{"t":"Mu","k":"v","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Anon::Augment","b":"A","n":"X::Anon::Augment","d":"<p><pre><code>class X::Anon::Augment does X::Comp { }</code></pre></p><p>Compile time error thrown when trying to augment an anonymous package.</p><p>For example</p><p><pre><code>use MONKEY-TYPING;\naugment class { }\n</code></pre></p><p>Dies with</p><p><pre><code>Cannot augment anonymous class\n</code></pre></p>","k":"c","mro":["X::Comp","Exception"]},{"t":"X::Anon::Multi","k":"c","mro":["X::Comp","Exception"],"b":"A","a":[{"n":"$.multiness","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.routine-type"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message"},{"n":"multiness","d":"<p><pre><code>method multiness(--&gt; Str:D)</code></pre></p><p>Returns a string describing the multiness that the original code used, for example \"multi\" or \"proto\".</p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"routine-type","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"pos","k":"m"},{"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BUILDALL"}],"d":"<p><pre><code>class X::Anon::Multi does X::Comp { }</code></pre></p><p>Compile time error thrown when an anonymous multi is being declared.</p><p>For example</p><p><pre><code>multi method () { }\n</code></pre></p><p>dies with</p><p><pre><code>Cannot put multi on anonymous method\n</code></pre></p>","n":"X::Anon::Multi"},{"n":"X::Cannot::New","mro":["Exception"],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"class"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"X::Cannot::New","b":"A","a":[{"k":"v","t":"Mu","n":"$.class"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c"},{"n":"X::Cannot::Empty","t":"X::Cannot::Empty","m":[{"k":"m","n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"action"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"what"},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"k":"c","a":[{"t":"Mu","n":"$.action","k":"v"},{"n":"$.what","k":"v","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"b":"A"},{"a":[{"n":"$.action","k":"v","t":"Mu"},{"k":"v","n":"$.what","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","t":"X::Cannot::Lazy","n":"X::Cannot::Lazy","k":"c","mro":["Exception"],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","n":"action","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"what","k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}]},{"n":"X::Cannot::Capture","a":[{"n":"$.what","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message"},{"m":0,"n":"what","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","m":0}],"b":"A","t":"X::Cannot::Capture","mro":["Exception"],"k":"c"},{"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"k":"m","n":"junction","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"for","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"k":"c","t":"X::Cannot::Junction","b":"A","a":[{"t":"Mu","k":"v","n":"$.junction"},{"n":"$.for","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Cannot::Junction","mro":["Exception"]},{"b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"what"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"using","k":"m"},{"k":"m","m":0,"n":"suggestion","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["Exception"],"a":[{"n":"$.what","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.using"},{"n":"$.suggestion","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"t":"X::Cannot::Map","k":"c","n":"X::Cannot::Map"},{"t":"X::Temporal","d":"<p><pre><code>role X::Temporal is Exception { }</code></pre></p><p>A common exception type for all errors related to DateTime or Date.</p>","n":"X::Temporal","b":"C","k":"ro","mro":["Exception"]},{"n":"X::Temporal::InvalidFormat","d":"<p><pre><code>class X::Temporal::InvalidFormat does X::Temporal is Exception { }\n</code></pre></p><p>This exception is thrown when code tries to create a DateTime or Date object using an invalid format.</p><p><pre><code>my $dt = Date.new(\"12/25/2015\");\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Temporal::InvalidFormat: Invalid Date string '12/25/2015'; use yyyy-mm-dd instead␤»\n</code></pre></p>","b":"A","a":[{"t":"Mu","k":"v","n":"$.invalid-str"},{"t":"Mu","k":"v","n":"$.target"},{"t":"Mu","n":"$.format","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Temporal","Exception"],"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"message"},{"n":"invalid-str","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"d":"<p>Returns the invalid format string (12/25/2015 in the example above)</p>"},{"n":"target","m":0,"d":"<p>Returns the target type (Date in the example above)</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"format","m":0},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"t":"X::Temporal::InvalidFormat"},{"n":"X::Backslash::NonVariableDollar","a":[{"n":"$.filename","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","t":"X::Backslash::NonVariableDollar","m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"n":"filename","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"pos","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","k":"m","m":0},{"n":"column","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time"},{"m":0,"k":"m","n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"post","k":"m"},{"m":0,"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"sequence","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"suggestion"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"pos","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"modules","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"k":"m","m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","k":"m"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"k":"c","n":"X::Backslash::UnrecognizedSequence","a":[{"k":"v","t":"Mu","n":"$.sequence"},{"k":"v","t":"Mu","n":"$.suggestion"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A","t":"X::Backslash::UnrecognizedSequence","mro":["X::Syntax","X::Comp","Exception"]},{"k":"c","t":"X::Pragma::OnlyOne","mro":["Exception"],"m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"name"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"a":[{"k":"v","t":"Mu","n":"$.name"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Pragma::OnlyOne","b":"A"},{"n":"X::Pragma::CannotWhat","t":"X::Pragma::CannotWhat","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"what","m":0,"k":"m"},{"m":0,"n":"name","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"k":"c","mro":["Exception"],"a":[{"t":"Mu","n":"$.what","k":"v"},{"n":"$.name","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A"},{"b":"A","k":"c","a":[{"n":"$.what","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["Exception"],"n":"X::Pragma::CannotPrecomp","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"what"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"t":"X::Pragma::CannotPrecomp"},{"m":[{"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"name","k":"m"},{"k":"m","n":"arg","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0}],"a":[{"k":"v","n":"$.name","t":"Mu"},{"t":"Mu","k":"v","n":"$.arg"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Pragma::UnknownArg","b":"A","t":"X::Pragma::UnknownArg","k":"c","mro":["Exception"]},{"n":"X::Pragma::MustOneOf","a":[{"t":"Mu","k":"v","n":"$.name"},{"k":"v","n":"$.alternatives","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["Exception"],"t":"X::Pragma::MustOneOf","b":"A","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"name","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"alternatives"},{"m":0,"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]}}],"k":"c"},{"b":"A","n":"X::Pragma::NoArgs","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"name","k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","mro":["Exception"],"a":[{"t":"Mu","k":"v","n":"$.name"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Pragma::NoArgs"},{"t":"X::Supply::Combinator","k":"c","n":"X::Supply::Combinator","m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"combinator"},{"k":"s","n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"b":"A","a":[{"n":"$.combinator","k":"v","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"]},{"a":[{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"b":"A","mro":["Exception"],"n":"X::Supply::Migrate::Needs","t":"X::Supply::Migrate::Needs","k":"c"},{"mro":["Exception"],"k":"c","n":"X::Supply::New","m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"}],"a":[{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","t":"X::Supply::New"},{"a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","k":"v","n":"$.symbol"},{"n":"@.suggestions","t":"Positional","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["X::Comp","X::Undeclared"],"n":"X::Attribute::Regex","k":"c","b":"A","m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL"}],"t":"X::Attribute::Regex"},{"k":"c","mro":["X::Comp","Exception"],"b":"A","a":[{"k":"v","n":"$.scope","t":"Mu"},{"t":"Mu","n":"$.allowed","k":"v"},{"n":"$.disallowed","t":"Mu","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"k":"m","m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"scope"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"allowed","k":"m"},{"n":"disallowed","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m"},{"n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"m":0,"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre"},{"m":0,"k":"m","n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"t":"X::Attribute::Scope::Package","n":"X::Attribute::Scope::Package"},{"d":"<p><pre><code>class X::Attribute::Package does X::Comp { }</code></pre></p><p>Compile time error, thrown when the compiler encounters an attribute declaration inside a package that does not support attributes.</p><p>For example</p><p><pre><code>module A { has $.x }\n</code></pre></p><p>dies with</p><p><pre><code>A module cannot have attributes, but you tried to declare '$.x'\n</code></pre></p>","a":[{"t":"Mu","n":"$.package-kind","k":"v"},{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","mro":["X::Comp","Exception"],"t":"X::Attribute::Package","m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"package-kind","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"d":"<p><pre><code>method name(--&gt; Str:D)</code></pre></p><p>Returns the name of the attribute that triggered this error.</p>","n":"name","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"filename","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"line","k":"m"},{"m":0,"n":"column","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"modules","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"post"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"highexpect"},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0}],"n":"X::Attribute::Package","b":"A"},{"t":"X::Attribute::Undeclared","a":[{"n":"$.package-kind","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.package-name"},{"n":"$.what","t":"Mu","k":"v"},{"k":"v","n":"$.symbol","t":"Mu"},{"t":"Positional","k":"v","n":"@.suggestions"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"<p><pre><code>class X::Attribute::Undeclared is X::Undeclared { }</code></pre></p><p>Thrown when code refers to an attribute that has not been declared.</p><p>For example the code</p><p><pre><code>class A { method m { $!notthere } }\n</code></pre></p><p>Produces the error</p><p><pre><code>Attribute $!notthere not declared in class A\n</code></pre></p>","mro":["X::Comp","X::Undeclared"],"n":"X::Attribute::Undeclared","m":[{"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"package-kind","d":"<p>Returns the kind of package the attribute was used in (for example class, grammar)</p>","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"package-name","k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.name"},{"t":"Mu","k":"v","n":"$.why"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Attribute::Required","n":"X::Attribute::Required","k":"c","d":"<p><pre><code>class X::Attribute::NoPackage does X::MOP { }</code></pre></p><p>Compile time error thrown when a required attribute is not assigned when creating an object.</p><p>For example</p><p><pre><code>my class Uses-required {\n    has $.req is required\n};\nmy $object = Uses-required.new()\n</code></pre></p><p>Dies with</p><p><pre><code>OUTPUT: «(exit code 1) The attribute '$!req' is required, but you did not provide a value for it.␤»\n</code></pre></p>","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"name","d":"<p><pre><code>method name(--&gt; Str:D)</code></pre></p><p>Returns the name of the attribute.</p>"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"why"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"mro":["X::MOP","Exception"]},{"n":"X::Attribute::NoPackage","b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"name"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"line"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"k":"m","n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"d":"<p><pre><code>class X::Attribute::NoPackage does X::Comp { }</code></pre></p><p>Compile time error thrown when an attribute is declared where it does not make sense (for example in the mainline).</p><p>For example</p><p><pre><code>has $.x;\n</code></pre></p><p>Dies with</p><p><pre><code>You cannot declare attribute '$.x' here; maybe you'd like a class or a role?\n</code></pre></p>","k":"c","t":"X::Attribute::NoPackage","mro":["X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.name"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","n":"X::Seq::NotIndexable","m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"}],"k":"c","t":"X::Seq::NotIndexable","a":[{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"]},{"n":"X::Seq::Consumed","mro":["Exception"],"t":"X::Seq::Consumed","a":[{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","k":"c","d":"<p><pre><code>class X::Seq::Consumed is Exception { }</code></pre></p><p>This exception is thrown when a piece of code tries to reuse a Seq which has already been iterated.</p>","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"message"}]},{"m":[{"n":"got","d":"<p><pre><code>method got()</code></pre></p><p>Returns the object that failed to type check</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"expected","m":0,"k":"m"},{"n":"gotn","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"expectedn"},{"m":0,"n":"priors","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"d":"<p><pre><code>method operation(--&gt; Str:D)</code></pre></p><p>Returns a string description of the operation that failed, for example \"assignment\", \"binding\", \"return\".</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"operation"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","t":"X::TypeCheck","mro":["Exception"],"d":"<p><pre><code>class X::TypeCheck is Exception { }</code></pre></p><p>Error class thrown when a type check fails.</p>","a":[{"k":"v","t":"Mu","n":"$.operation"},{"t":"Mu","n":"$!got","k":"v"},{"n":"$!expected","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::TypeCheck","b":"A"},{"mro":["X::TypeCheck"],"k":"c","d":"<p><pre><code>class X::TypeCheck::Binding is X::TypeCheck { }</code></pre></p><p>Thrown when the type check of a binding operation fails.</p><p>For example:</p><p><pre><code>my Int $x := \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Binding: Type check failed in binding; expected Int but got Str (\"foo\")␤»</code></pre></p><p>Note that the compiler is free to detect obvious errors at compile time, and complain with a different error at compile time.</p>","b":"A","n":"X::TypeCheck::Binding","t":"X::TypeCheck::Binding","m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"operation","m":0},{"n":"message","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"symbol","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.symbol","k":"v"},{"n":"$.operation","t":"Mu","k":"v"},{"t":"Mu","n":"$!got","k":"v"},{"t":"Mu","k":"v","n":"$!expected"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}]},{"t":"X::TypeCheck::Binding::Parameter","n":"X::TypeCheck::Binding::Parameter","a":[{"k":"v","n":"$.parameter","t":"Parameter"},{"n":"$.constraint","t":"Bool","k":"v"},{"n":"$.symbol","k":"v","t":"Mu"},{"k":"v","n":"$.operation","t":"Mu"},{"k":"v","n":"$!got","t":"Mu"},{"t":"Mu","n":"$!expected","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"n":"expectedn","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"parameter","k":"m","m":0},{"n":"constraint","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"k":"c","b":"A","mro":["X::TypeCheck::Binding"]},{"t":"X::TypeCheck::Attribute::Default","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"message"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"name","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"operation"},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"pos","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"n":"is-compile-time","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"s","n":"BUILDALL"}],"a":[{"k":"v","t":"str","n":"$.name"},{"n":"$.operation","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$.operation","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!got"},{"n":"$!expected","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::Comp","X::TypeCheck","Exception"],"k":"c","n":"X::TypeCheck::Attribute::Default","b":"A"},{"b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"operation","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"message"},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::TypeCheck::Return","d":"<p><pre><code>class X::TypeCheck::Return is X::TypeCheck { }</code></pre></p><p>Thrown when a return type check fails.</p><p>For example</p><p><pre><code>sub f(--&gt; Int) { \"foo\" }\nf();\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Return: Type check failed for return value; expected Int but got Str (\"foo\")␤»</code></pre></p>","t":"X::TypeCheck::Return","mro":["X::TypeCheck"],"k":"c","a":[{"k":"v","t":"Mu","n":"$.operation"},{"k":"v","t":"Mu","n":"$!got"},{"k":"v","t":"Mu","n":"$!expected"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}]},{"mro":["X::Comp","X::TypeCheck","Exception"],"a":[{"n":"$.action","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","n":"$.operation","k":"v"},{"k":"v","t":"Mu","n":"$!got"},{"n":"$!expected","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::TypeCheck::Splice","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"action","m":0},{"n":"filename","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m","m":0},{"n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"is-compile-time"},{"m":0,"n":"pre","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"b":"A","n":"X::TypeCheck::Splice","d":"<p><pre><code>class X::TypeCheck::Splice is X::TypeCheck does X::Comp { }</code></pre></p><p>Compile time error thrown when a Macro or an unquote/hole in a quasi quote does not return an AST.</p><p>For example</p><p><pre><code>use experimental :macros;\nmacro quasi-ast { quasi { {{{'not AST'}}} };};\nsay quasi-ast;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nType check failed in macro application; expected AST but got Str(\"not AST\")\n</code></pre></p><p>This is because you are purposefully creating something that does not evaluate to an abstract syntax tree. To fix, instead write</p><p><pre><code>use experimental :macros;\nmacro an-ast {\n    quasi { 'yes AST' }\n}\nsay an-ast;              # OUTPUT: «yes AST␤»\n</code></pre></p>","k":"c"},{"a":[{"k":"v","t":"Mu","n":"$.symbol"},{"n":"$.operation","k":"v","t":"Mu"},{"t":"Mu","n":"$!got","k":"v"},{"n":"$!expected","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["X::TypeCheck"],"b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"operation","k":"m","m":0},{"k":"m","n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"symbol","m":0,"k":"m"},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"X::TypeCheck::Assignment","d":"<p><pre><code>class X::TypeCheck::Assignment is X::TypeCheck { }</code></pre></p><p>Error class thrown when the type check of an assignment fails.</p><p>For example, this will die</p><p><pre><code>my Int $x = \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (\"foo\")␤»</code></pre></p><p>though compilers are allowed to detect obvious cases like this example and complain at compile time with a different error.</p>","t":"X::TypeCheck::Assignment","k":"c"},{"a":[{"k":"v","t":"Mu","n":"$.protoguilt"},{"n":"@.arguments","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$.objname"},{"k":"v","t":"Mu","n":"$.signature"},{"n":"$.operation","t":"Mu","k":"v"},{"n":"$!got","t":"Mu","k":"v"},{"t":"Mu","n":"$!expected","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","n":"X::TypeCheck::Argument","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"n":"protoguilt","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"arguments","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"objname","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","n":"signature","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"b":"A","t":"X::TypeCheck::Argument","mro":["X::TypeCheck"]},{"a":[{"n":"$.declaration","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"message"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"declaration","k":"m","m":0},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","m":0,"k":"m"},{"n":"line","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column"},{"m":0,"k":"m","n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","k":"m"},{"n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","m":0}],"b":"A","mro":["X::Comp","Exception"],"k":"c","n":"X::Declaration::OurScopeInRole","t":"X::Declaration::OurScopeInRole"},{"b":"A","a":[{"n":"$.scope","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.declaration"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"m":0,"k":"m","n":"scope","d":"<p><pre><code>method scope(--&gt; Str:D)</code></pre></p><p>Returns a string representation of the scope, usually the same keyword that is used for the declaration (\"my\", \"our\", \"has\", ...);</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","n":"declaration","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"filename","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m"},{"n":"modules","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"is-compile-time"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pre"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"post"},{"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"X::Declaration::Scope","k":"c","mro":["X::Comp","Exception"],"d":"<p><pre><code>class X::Declaration::Scope does X::Comp { }\n</code></pre></p><p>Compile time error thrown when a declaration does not harmonize with the declared scope.</p><p>For example</p><p><pre><code>has sub f() { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use 'has' with sub declaration\n</code></pre></p>","n":"X::Declaration::Scope"},{"t":"X::Declaration::Scope::Multi","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message","k":"m"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"k":"c","mro":["X::Comp","X::Declaration::Scope"],"b":"A","d":"<p><pre><code>class X::Declaration::Scope::Multi is X::Declaration::Scope { }</code></pre></p><p>Thrown when a multi is declared with an incompatible scope.</p><p>For example our multi sub foo() { } dies with</p><p><pre><code>===SORRY!===\nCannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead\n</code></pre></p>","a":[{"t":"Mu","n":"$.scope","k":"v"},{"t":"Mu","k":"v","n":"$.declaration"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Declaration::Scope::Multi"},{"t":"X::LibEmpty","a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::LibEmpty","b":"A","mro":["X::Comp","Exception"],"k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"filename","m":0},{"n":"pos","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"column"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m"},{"n":"is-compile-time","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"}]},{"n":"X::HyperOp::NonDWIM","b":"A","a":[{"n":"&.operator","k":"v","t":"Callable"},{"t":"Mu","k":"v","n":"$.left-elems"},{"t":"Mu","n":"$.right-elems","k":"v"},{"k":"v","t":"Mu","n":"$.recursing"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","mro":["Exception"],"t":"X::HyperOp::NonDWIM","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"operator"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"left-elems"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"right-elems"},{"m":0,"n":"recursing","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}]},{"a":[{"t":"Callable","n":"&.operator","k":"v"},{"k":"v","t":"Mu","n":"$.side"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"k":"c","n":"X::HyperOp::Infinite","t":"X::HyperOp::Infinite","mro":["Exception"],"b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"m":0,"k":"m","n":"operator","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"side","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}]},{"m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method package-kind(--&gt; Str:D)</code></pre></p><p>Returns the kind of package (class, grammar) that is being tried to augment</p>","n":"package-kind"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"package","k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"line"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"column"},{"n":"modules","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"post"},{"k":"m","n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::Augment::NoSuchType","mro":["X::Comp","Exception"],"k":"c","d":"<p><pre><code>class X::Augment::NoSuchType does X::Comp { }</code></pre></p><p>Thrown when trying to augment a type which doesn't exist.</p><p>For example</p><p><pre><code>use MONKEY-TYPING;\naugment class NoSuch { }\n</code></pre></p><p>dies with</p><p><pre><code>You tried to augment class NoSuch, but it does not exist\n</code></pre></p>","t":"X::Augment::NoSuchType","b":"A","a":[{"n":"$.package-kind","t":"Mu","k":"v"},{"t":"Mu","n":"$.package","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}]},{"t":"X::Inheritance::NotComposed","b":"A","d":"<p><pre><code>class X::Inheritance::NotComposed is Exception {}</code></pre></p><p>When you try to inherit from a class that hasn't been composed, an exception of type X::Inheritance::NotComposed is thrown.</p><p>Usually this happens because it's not yet fully parsed, or that is stubbed:</p><p>For example</p><p><pre><code>class A { ... };    # literal ... for stubbing\nclass B is A { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n'B' cannot inherit from 'A' because 'A' isn't composed yet (maybe it is stubbed)\n</code></pre></p><p>The second common way to trigger this error is by trying to inherit from a class from within the class body.</p><p>For example</p><p><pre><code>class Outer {\n    class Inner is Outer {\n    }\n}\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n'Outer::Inner' cannot inherit from 'Outer' because 'Outer' isn't composed yet (maybe it is stubbed)\n</code></pre></p>","k":"c","n":"X::Inheritance::NotComposed","m":[{"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"d":"<p><pre><code>method child-name(X::Inheritance::NotComposed:D: --&gt; Str:D)</code></pre></p><p>Returns the name of the type that tries to inherit.</p>","n":"child-name","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"parent-name"},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"mro":["X::MOP","Exception"],"a":[{"n":"$.child-name","t":"Mu","k":"v"},{"n":"$.parent-name","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","a":[{"k":"v","n":"$.child-typename","t":"Mu"},{"n":"$.parent","k":"v","t":"Mu"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"k":"c","m":[{"k":"m","m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>The name of the type that tries to inherit.</p>","k":"m","m":0,"n":"child-typename"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"parent","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"filename"},{"k":"m","m":0,"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0},{"n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"pre","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"post","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"highexpect","k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"d":"<p><pre><code>class X::Inheritance::Unsupported does X::Comp { }</code></pre></p><p>Compile time error thrown when trying to inherit from a type that does not support inheritance (like a package or an enum).</p><p>For example</p><p><pre><code>enum A &lt;Ax Ay&gt;;\nclass B is A { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nA does not support inheritance, so B cannot inherit from it\n</code></pre></p>","n":"X::Inheritance::Unsupported","mro":["X::Comp","Exception"],"t":"X::Inheritance::Unsupported"},{"n":"X::Inheritance::UnknownParent","k":"c","mro":["Exception"],"m":[{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"child","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"parent"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"suggestions","k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"a":[{"t":"Mu","k":"v","n":"$.child"},{"k":"v","t":"Mu","n":"$.parent"},{"n":"@.suggestions","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A","t":"X::Inheritance::UnknownParent"},{"a":[{"k":"v","t":"Mu","n":"$.name"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Inheritance::SelfInherit","mro":["Exception"],"n":"X::Inheritance::SelfInherit","b":"A","k":"c","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m","m":0},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"name"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}]},{"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}}],"k":"c","a":[{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["Exception"],"n":"X::ParametricConstant","b":"A","t":"X::ParametricConstant"},{"t":"X::NoSuchSymbol","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"symbol","k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"k":"c","a":[{"n":"$.symbol","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::NoSuchSymbol","mro":["Exception"],"b":"A"},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"type"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"t":"X::NotParametric","k":"c","a":[{"k":"v","n":"$.type","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"],"b":"A","n":"X::NotParametric"},{"a":[{"n":"$.op","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"n":"X::NQP::NotFound","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"n":"op","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"b":"A","t":"X::NQP::NotFound","k":"c"},{"b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message","k":"m"},{"m":0,"n":"action","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"target-shape","k":"m"},{"m":0,"n":"source-shape","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"t":"X::ArrayShapeMismatch","n":"X::ArrayShapeMismatch","k":"c","a":[{"t":"Mu","n":"$.action","k":"v"},{"n":"$.target-shape","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.source-shape"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"]},{"t":"X::Promise::CauseOnlyValidOnBroken","k":"c","n":"X::Promise::CauseOnlyValidOnBroken","b":"A","d":"<p><pre><code>class X::Promise::CauseOnlyValidOnBroken is Exception { }</code></pre></p><p>This exception is thrown when code expects a Promise to be broken, and asks why it has been broken, but the Promise has in fact, not yet been broken.</p>","mro":["Exception"],"a":[{"n":"$.promise","k":"v","t":"Mu"},{"n":"$.status","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"k":"m","m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method promise()</code></pre></p><p>Returns the Promise that was asked about.</p>","m":0,"n":"promise"},{"n":"status","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL"}]},{"k":"c","a":[{"n":"$.promise","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"message"},{"m":0,"n":"promise","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"mro":["Exception"],"n":"X::Promise::Resolved","t":"X::Promise::Resolved","b":"A"},{"n":"X::Promise::Vowed","d":"<p><pre><code>class X::Promise::Vowed is Exception { }</code></pre></p><p>This exception is thrown when code tries to keep/break an already vowed promise without going through the corresponding Vow object.</p>","a":[{"n":"$.promise","k":"v","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"message"},{"n":"promise","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}],"mro":["Exception"],"t":"X::Promise::Vowed","b":"A","k":"c"},{"mro":["Exception"],"n":"X::Promise::Combinator","b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"combinator","m":0},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"a":[{"t":"Mu","n":"$.combinator","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"k":"c","t":"X::Promise::Combinator"},{"n":"X::Promise::Broken","k":"ro","mro":[],"b":"C","t":"X::Promise::Broken","a":[{"k":"v","t":"Mu","n":"$.result-backtrace"}]},{"k":"c","b":"A","a":[{"n":"$.typename","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.method"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"n":"X::Immutable","m":[{"n":"message","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"typename"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"method","k":"m","m":0},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0}],"t":"X::Immutable"},{"a":[{"t":"Mu","n":"$.react-backtrace","k":"v"}],"mro":[],"t":"X::React::Died","b":"C","n":"X::React::Died","k":"ro"},{"t":"X::Lock::ConditionVariable::New","k":"c","b":"A","n":"X::Lock::ConditionVariable::New","a":[{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"message"}],"mro":["Exception"]},{"a":[{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"k":"c","b":"A","n":"X::Lock::Async::NotLocked","m":[{"n":"message","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"X::Lock::Async::NotLocked"},{"k":"c","mro":["X::ArrayShapeMismatch"],"b":"A","m":[{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"t":"X::Assignment::ArrayShapeMismatch","n":"X::Assignment::ArrayShapeMismatch","a":[{"n":"$.action","t":"Mu","k":"v"},{"n":"$.target-shape","k":"v","t":"Mu"},{"t":"Mu","n":"$.source-shape","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}]},{"b":"A","k":"c","a":[{"n":"$.shape","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"shape","k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::Assignment::ToShaped","t":"X::Assignment::ToShaped"},{"t":"X::Assignment::RO","m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"typename"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"value","k":"m"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"k":"c","a":[{"k":"v","n":"$.value","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["Exception"],"n":"X::Assignment::RO","d":"<p><pre><code>class X::Assignment::RO is Exception {}</code></pre></p><p>Code like</p><p><pre><code>sub f() { 42 };\nf() = 'new value';  # throws an X::Assignment::RO\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»</code></pre></p><p>throws an exception of type X::Assignment::RO.</p>","b":"A"},{"k":"c","b":"A","m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"variable","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m","m":0},{"m":0,"n":"modules","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pre"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"highexpect","k":"m"},{"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0}],"n":"X::Assignment::RO::Comp","a":[{"t":"Mu","n":"$.variable","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Assignment::RO::Comp","mro":["X::Comp","Exception"]},{"n":"X::Placeholder::Mainline","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"b":"A","d":"<p><pre><code>class X::Placeholder::Mainline is X::Placeholder::Block { }</code></pre></p><p>Thrown when a placeholder variable is used in the mainline, i.e. outside of any explicit block.</p><p>For example</p><p><pre><code>$^x;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use placeholder parameter $^x outside of a sub or block\n</code></pre></p><p>Note that this error can also occur when you think something is a block, but it really is a postcircumfix:&lt;{ }&gt;, for example</p><p><pre><code>my %h;\nsay %h{ $^x };\n#     ^^^^^^^  not a block, so $^x is part of the mainline\n</code></pre></p>","k":"c","t":"X::Placeholder::Mainline","a":[{"t":"Mu","k":"v","n":"$.placeholder"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Comp","X::Placeholder::Block"]},{"a":[{"n":"$.placeholder","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","n":"X::Placeholder::Attribute","m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"mro":["X::Comp","X::Placeholder::Block"],"b":"A","t":"X::Placeholder::Attribute"},{"n":"X::Placeholder::NonPlaceholder","k":"c","mro":["X::Comp","Exception"],"b":"A","t":"X::Placeholder::NonPlaceholder","a":[{"n":"$.variable_name","t":"Mu","k":"v"},{"t":"Mu","n":"$.placeholder","k":"v"},{"n":"$.decl","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"variable_name","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"placeholder"},{"k":"m","n":"decl","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"line","k":"m"},{"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"modules","k":"m"},{"m":0,"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post","m":0,"k":"m"},{"n":"highexpect","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"BUILDALL"}]},{"a":[{"n":"$.placeholder","k":"v","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Placeholder::Block","k":"c","mro":["X::Comp","Exception"],"d":"<p><pre><code>class X::Placeholder::Block does X::Comp {}</code></pre></p><p>Thrown when a placeholder variable is used in a block that does not allow a signature.</p><p>For example</p><p><pre><code>class A { $^foo }\n</code></pre></p><p>dies with</p><p><pre><code>Placeholder variable $^foo may not be used here because the surrounding block takes no signature\n</code></pre></p>","b":"A","n":"X::Placeholder::Block","m":[{"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"placeholder"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m","m":0},{"k":"m","n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"column"},{"m":0,"n":"modules","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"}]},{"mro":["Exception"],"t":"X::HyperWhatever::Multiple","b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m","m":0}],"k":"c","a":[{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::HyperWhatever::Multiple"},{"n":"X::EXPORTHOW::NothingToSupersede","k":"c","m":[{"k":"m","m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","n":"declarator","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"filename","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"line"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"modules"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"post","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.declarator"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","k":"v","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::EXPORTHOW::NothingToSupersede","b":"A"},{"t":"X::EXPORTHOW::InvalidDirective","mro":["X::Comp","Exception"],"b":"A","k":"c","a":[{"n":"$.directive","k":"v","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"n":"message","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"directive","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","k":"m"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"line"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"modules"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m","m":0},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"X::EXPORTHOW::InvalidDirective"},{"a":[{"n":"$.declarator","t":"Mu","k":"v"},{"t":"Mu","n":"$.directive","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"declarator","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"directive","m":0,"k":"m"},{"m":0,"n":"filename","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line"},{"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"post"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::EXPORTHOW::Conflict","mro":["X::Comp","Exception"],"t":"X::EXPORTHOW::Conflict","k":"c","b":"A"},{"b":"A","t":"X::SecurityPolicy","mro":["Exception"],"k":"c","a":[{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::SecurityPolicy"},{"n":"X::SecurityPolicy::Eval","b":"A","m":[{"m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"Numeric","k":"m"},{"m":0,"k":"m","n":"from-slurpy","s":{"r":"Mu","p":[{"n":"cap","t":"Any"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"payload"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s"}],"mro":["X::SecurityPolicy"],"a":[{"t":"Mu","n":"$.payload","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::SecurityPolicy::Eval","k":"c"},{"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"directive","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"k":"c","mro":["Exception"],"a":[{"k":"v","t":"Mu","n":"$.directive"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::Buf::Pack","t":"X::Buf::Pack","b":"A"},{"k":"c","t":"X::Buf::Pack::NonASCII","a":[{"t":"Mu","n":"$.char","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["Exception"],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"char"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::Buf::Pack::NonASCII","b":"A"},{"t":"X::Buf::AsStr","n":"X::Buf::AsStr","mro":["Exception"],"k":"c","b":"A","a":[{"n":"$.object","k":"v","t":"Mu"},{"n":"$.method","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"object","m":0,"k":"m"},{"k":"m","n":"method","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}]},{"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","d":"<p>The name of the offensive parameter ($=foo in the example above)</p>","n":"parameter","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"twigil","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"filename","m":0},{"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"line","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m","m":0},{"m":0,"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"k":"m","n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"t":"X::Parameter::Twigil","b":"A","n":"X::Parameter::Twigil","a":[{"n":"$.parameter","k":"v","t":"Mu"},{"t":"Mu","n":"$.twigil","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","d":"<p><pre><code>class X::Parameter::Twigil does X::Comp { }</code></pre></p><p>Thrown when a parameter in a signature has a twigil that it may not have. Only !, . and * as twigils are allowed.</p><p>Example:</p><p><pre><code>sub f($=foo) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nIn signature parameter $=foo, it is illegal to use the = twigil\n</code></pre></p>","mro":["X::Comp","Exception"]},{"mro":["X::Comp","Exception"],"n":"X::Parameter::MultipleTypeConstraints","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"parameter","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"filename"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"column"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"post","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","k":"m"},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL"}],"a":[{"n":"$.parameter","k":"v","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"t":"X::Parameter::MultipleTypeConstraints","b":"A","d":"<p><pre><code>class X::Parameter::MultipleTypeConstraints does X::Comp { }</code></pre></p><p>Compile time error thrown when a parameter has multiple type constraints. This is not allowed in Raku.0.</p><p>Example:</p><p><pre><code>sub f(Cool Real $x) { }\n</code></pre></p><p>dies with</p><p><pre><code>Parameter $x may only have one prefix type constraint\n</code></pre></p>","k":"c"},{"n":"X::Parameter::AfterDefault","b":"A","k":"c","m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"type"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modifier"},{"m":0,"k":"m","n":"default","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"n":"line","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre"},{"m":0,"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Parameter::AfterDefault","a":[{"t":"Mu","k":"v","n":"$.type"},{"n":"$.modifier","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.default"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}]},{"a":[{"k":"v","t":"Mu","n":"$.misplaced"},{"n":"$.parameter","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.after"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Parameter::WrongOrder","mro":["X::Comp","Exception"],"b":"A","n":"X::Parameter::WrongOrder","k":"c","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"d":"<p>Returns the kind of misplaced parameter (for example \"mandatory\", \"positional\").</p>","n":"misplaced","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"parameter","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p>Returns the name of the (first) misplaced parameter</p>"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"after"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line","k":"m"},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"modules","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"is-compile-time","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre"},{"n":"post","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","m":0,"k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"d":"<p><pre><code>class X::Parameter::WrongOrder does X::Comp { }</code></pre></p><p>Compile time error that is thrown when parameters in a signature in the wrong order (for example if an optional parameter comes before a mandatory parameter).</p><p>For example</p><p><pre><code>sub f($a?, $b) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put required parameter $b after optional parameters\n</code></pre></p>"},{"b":"A","k":"c","d":"<p><pre><code>class X::Parameter::Placeholder does X::Comp { }</code></pre></p><p>Thrown when a placeholder parameter is used inside a signature where a normal parameter is expected. The reason is often that a named parameter :$param was misspelled as $:param.</p><p>For example</p><p><pre><code>sub f($:param) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nIn signature parameter, placeholder variables like $:param are illegal\nyou probably meant a named parameter: ':$param'\n</code></pre></p>","mro":["X::Comp","Exception"],"t":"X::Parameter::Placeholder","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"type"},{"k":"m","d":"<p>The text of the offensive parameter declaration ($:param in the example above).</p>","m":0,"n":"parameter","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"right","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"n":"filename","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"pos","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"modules","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"post","m":0},{"m":0,"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"a":[{"k":"v","n":"$.type","t":"Mu"},{"n":"$.parameter","k":"v","t":"Mu"},{"n":"$.right","k":"v","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Parameter::Placeholder"},{"b":"A","a":[{"n":"$.got","k":"v","t":"Mu"},{"n":"$.symbol","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","mro":["Exception"],"t":"X::Parameter::RW","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"got","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"symbol","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0,"n":"BUILDALL"}],"n":"X::Parameter::RW"},{"a":[{"n":"$.kind","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","k":"v","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Parameter::TypedSlurpy","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"kind"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"line"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"column"},{"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"post","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}],"mro":["X::Comp","Exception"],"k":"c","t":"X::Parameter::TypedSlurpy","b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.expected"},{"t":"Mu","n":"$.got","k":"v"},{"k":"v","t":"Mu","n":"$.routine"},{"t":"Mu","k":"v","n":"$.param"},{"n":"$.should-be-concrete","t":"Bool","k":"v"},{"t":"Bool","n":"$.param-is-invocant","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"expected"},{"k":"m","m":0,"n":"got","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"routine","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"param"},{"m":0,"n":"should-be-concrete","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"param-is-invocant"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s","m":0}],"t":"X::Parameter::InvalidConcreteness","mro":["Exception"],"n":"X::Parameter::InvalidConcreteness","b":"A"},{"a":[{"k":"v","n":"$.how","t":"Mu"},{"n":"$.parameter","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0,"k":"m"},{"d":"<p>Returns a string describing how the parameter is qualified that makes it disallow default values, for example \"slurpy\" or \"mandatory\".</p>","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"how"},{"k":"m","n":"parameter","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"column"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"highexpect","k":"m"},{"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s"}],"mro":["X::Comp","Exception"],"b":"A","n":"X::Parameter::Default","d":"<p><pre><code>class X::Parameter::Default does X::Comp { }</code></pre></p><p>Compile-time error thrown when a parameter in a signature has default value, but isn't allowed to have one. That is the case with slurpy parameters (because a slurpy always binds successfully, even to zero arguments) and with mandatory parameters.</p><p>Example:</p><p><pre><code>sub f($x! = 3) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put default on required parameter $x\n</code></pre></p><p>And</p><p><pre><code>sub f(*@ = 3) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put default on anonymous slurpy parameter\n</code></pre></p>","t":"X::Parameter::Default","k":"c"},{"k":"c","t":"X::Parameter::Default::TypeCheck","a":[{"t":"Mu","k":"v","n":"$.what"},{"t":"Mu","n":"$.got","k":"v"},{"t":"Mu","n":"$.expected","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Parameter::Default::TypeCheck","m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"what","k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"got"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"expected","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"m":0,"n":"pos","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"line","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"modules"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre"},{"n":"post","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"b":"A","mro":["X::Comp","Exception"]},{"t":"X::Parameter::InvalidType","mro":["X::Comp","Exception"],"k":"c","a":[{"n":"$.typename","t":"Mu","k":"v"},{"t":"Positional","n":"@.suggestions","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"typename"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"suggestions"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0},{"n":"column","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"post","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}],"b":"A","n":"X::Parameter::InvalidType"},{"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m"},{"m":0,"n":"type","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","k":"m","m":0},{"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"modules"},{"m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","k":"m"},{"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"b":"A","mro":["X::Comp","Exception"],"k":"c","a":[{"t":"Mu","k":"v","n":"$.type"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::Parameter::BadType","t":"X::Parameter::BadType"},{"t":"X::InvalidType","a":[{"n":"$.typename","k":"v","t":"Mu"},{"t":"Positional","n":"@.suggestions","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"m":0,"n":"typename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"suggestions","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename","k":"m"},{"m":0,"n":"pos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m"},{"n":"modules","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"highexpect","m":0},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"mro":["X::Comp","Exception"],"n":"X::InvalidType","k":"c"},{"a":[{"n":"$.message","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"b":"A","n":"X::StubCode","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m","m":0},{"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"s"}],"mro":["Exception"],"k":"c","t":"X::StubCode","d":"<p><pre><code>class X::StubCode is Exception { }</code></pre></p><p>Thrown when a piece of stub code (created via !!! or ...) is executed.</p>"},{"k":"ro","d":"<p><pre><code>role X::Syntax does X::Comp { }</code></pre></p><p>Common role for syntax errors thrown by the compiler.</p>","mro":["X::Comp"],"b":"C","n":"X::Syntax","t":"X::Syntax"},{"t":"X::Syntax::Extension::TooComplex","b":"A","a":[{"k":"v","t":"Mu","n":"$.name"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Extension::TooComplex","m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"name","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","m":0},{"k":"m","m":0,"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","n":"column","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"is-compile-time","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"pre"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect","k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}]},{"m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"category"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"opname"},{"n":"hint","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"filename","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"m":0,"n":"line","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"modules","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"post","k":"m"},{"k":"m","n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::Syntax::Extension::SpecialForm","mro":["X::Syntax","X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.category"},{"n":"$.opname","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.hint"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","t":"X::Syntax::Extension::SpecialForm","k":"c"},{"t":"X::Syntax::Extension::Category","a":[{"t":"Mu","n":"$.category","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::Extension::Category","k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","n":"category","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"is-compile-time"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"pre","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"post"},{"m":0,"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","m":0}]},{"b":"A","k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"k":"m","n":"filename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"line"},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","k":"m"},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"}],"a":[{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Extension::Null","n":"X::Syntax::Extension::Null"},{"t":"X::Syntax::ParentAsHash","mro":["X::Syntax","X::Comp","Exception"],"b":"A","n":"X::Syntax::ParentAsHash","k":"c","a":[{"t":"Mu","k":"v","n":"$.type"},{"n":"$.parent","t":"Mu","k":"v"},{"n":"$.what","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"type"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"parent","k":"m"},{"m":0,"n":"what","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"filename","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"column","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"k":"m","m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}]},{"d":"<p><pre><code>class X::Syntax::UnlessElse does X::Syntax { }</code></pre></p><p>Syntax error thrown when an unless clause is followed by an else clause.</p><p>For example</p><p><pre><code>unless 1 { } else { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n\"unless\" does not take \"else\", please rewrite using \"if\"\n</code></pre></p>","a":[{"t":"Mu","n":"$.keyword","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"keyword","k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","m":0,"k":"m"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post","k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"n":"X::Syntax::UnlessElse","k":"c","t":"X::Syntax::UnlessElse"},{"mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"category","k":"m"},{"n":"needs","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"filename"},{"k":"m","n":"pos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"column"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"pre"},{"n":"post","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"highexpect"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","m":0,"k":"s"}],"k":"c","b":"A","n":"X::Syntax::AddCategorical::TooManyParts","a":[{"n":"$.category","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.needs"},{"t":"Mu","k":"v","n":"$.filename"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::AddCategorical::TooManyParts"},{"mro":["X::Syntax","X::Comp","Exception"],"a":[{"n":"$.category","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.needs"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::AddCategorical::TooFewParts","b":"A","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m"},{"n":"category","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"needs","k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename","m":0},{"k":"m","n":"pos","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","n":"modules","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre"},{"m":0,"n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"k":"c","n":"X::Syntax::AddCategorical::TooFewParts"},{"b":"A","d":"<p><pre><code>class X::Syntax::InfixInTermPosition does X::Syntax { }</code></pre></p><p>Syntax error thrown when the parser expects a term, but finds an infix operator instead.</p><p>For example</p><p><pre><code>1, =&gt; 2;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPreceding context expects a term, but found infix =&gt; instead\n</code></pre></p>","t":"X::Syntax::InfixInTermPosition","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.infix","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Syntax::InfixInTermPosition","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"n":"infix","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column"},{"m":0,"n":"modules","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time"},{"m":0,"k":"m","n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c"},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"filename"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos"},{"m":0,"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"n":"pre","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"n":"X::Syntax::P5","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"<p><pre><code>class X::Syntax::P5 does X::Syntax { }</code></pre></p><p>Syntax error thrown when some piece of code is clearly Perl 5, not Raku.</p><p>For example</p><p><pre><code>for my $a (1, 2) { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThis appears to be Perl 5 code\n</code></pre></p>","b":"A","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::P5","k":"c"},{"b":"A","t":"X::Syntax::DuplicatedPrefix","n":"X::Syntax::DuplicatedPrefix","mro":["X::Syntax","X::Comp","Exception"],"a":[{"n":"$.prefixes","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"prefixes","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"filename"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m"},{"n":"column","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"k":"m","n":"is-compile-time","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}]},{"m":[{"m":0,"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"filename","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"pos","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"line"},{"n":"column","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"modules","k":"m"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"pre","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post","m":0,"k":"m"},{"n":"highexpect","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"t":"X::Syntax::Pod::DeclaratorLeading","a":[{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Pod::DeclaratorLeading","b":"A","k":"c","mro":["X::Syntax","X::Comp","Exception"]},{"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Pod::DeclaratorTrailing","a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"m":0,"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"k":"m","n":"pos","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"column","k":"m"},{"m":0,"n":"modules","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre","k":"m"},{"m":0,"n":"post","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"k":"c","t":"X::Syntax::Pod::DeclaratorTrailing"},{"k":"c","a":[{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"t":"X::Syntax::Pod::BeginWithoutIdentifier","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"message"},{"k":"m","m":0,"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos"},{"m":0,"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"column","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","m":0,"k":"m"},{"n":"pre","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"mro":["X::Pod","X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Pod::BeginWithoutIdentifier","b":"A"},{"a":[{"t":"Mu","k":"v","n":"$.type"},{"t":"Mu","k":"v","n":"$.spaces"},{"n":"$.instead","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::Pod::BeginWithoutEnd","b":"A","m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"n":"type","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"spaces"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"instead"},{"n":"filename","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"pos","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"line"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"modules","m":0},{"n":"is-compile-time","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"highexpect","k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::Pod::BeginWithoutEnd","mro":["X::Pod","X::Syntax","X::Comp","Exception"]},{"k":"c","m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"word","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"needparens","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"m":0,"n":"pos","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m","m":0},{"n":"modules","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pre"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"post","k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"b":"A","a":[{"n":"$.word","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.needparens"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::KeywordAsFunction","t":"X::Syntax::KeywordAsFunction"},{"d":"<p><pre><code>class X::Syntax::Confused does X::Syntax { }\n</code></pre></p><p>The most general syntax error, if no more specific error message can be given.</p><p>For example</p><p><pre><code>1∞\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nConfused\n</code></pre></p>","a":[{"t":"Mu","k":"v","n":"$.reason"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::Syntax::Confused","b":"A","k":"c","n":"X::Syntax::Confused","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"reason"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","m":0,"k":"m"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"k":"m","n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"highexpect"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","a":[{"t":"Mu","n":"$.what","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"what"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"m":0,"k":"m","n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"line","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pre"},{"m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"highexpect","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"X::Syntax::Adverb","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Adverb","k":"c"},{"mro":["X::Syntax","X::Comp","Exception"],"d":"<p><pre><code>class X::Syntax::Reserved does X::Syntax { }</code></pre></p><p>Syntax error thrown when a syntax is used which is reserved for future expansion.</p><p>For example</p><p><pre><code>my @a();\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThe () shape syntax in array declarations is reserved\n</code></pre></p>","t":"X::Syntax::Reserved","a":[{"t":"Mu","n":"$.reserved","k":"v"},{"t":"Mu","n":"$.instead","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"reserved","d":"<p><pre><code>method reserved(--&gt; Str:D)</code></pre></p><p>Returns a text description of the reserved syntax.</p>"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"instead"},{"n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"pos","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"modules"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time"},{"m":0,"n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"k":"c","n":"X::Syntax::Reserved","b":"A"},{"k":"c","b":"A","a":[{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Name::Null","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","k":"m"},{"m":0,"k":"m","n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","k":"m"},{"m":0,"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"}],"t":"X::Syntax::Name::Null"},{"a":[{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Regex::NullRegex","t":"X::Syntax::Regex::NullRegex","b":"A","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"pos","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"k":"m","n":"modules","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre","k":"m","m":0},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect","k":"m"},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0}],"k":"c"},{"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::SolitaryBacktrackControl","b":"A","m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"column"},{"k":"m","m":0,"n":"modules","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-compile-time","m":0},{"m":0,"n":"pre","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0}],"a":[{"t":"Mu","k":"v","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::Regex::SolitaryBacktrackControl","k":"c"},{"t":"X::Syntax::Regex::Alias::LongName","k":"c","n":"X::Syntax::Regex::Alias::LongName","b":"A","a":[{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"line"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"modules"},{"n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}]},{"k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m","m":0},{"n":"metachar","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename"},{"n":"pos","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"n":"line","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"modules","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"is-compile-time"},{"m":0,"n":"pre","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"m":0,"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]}}],"t":"X::Syntax::Regex::UnrecognizedMetachar","a":[{"k":"v","n":"$.metachar","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Regex::UnrecognizedMetachar","b":"A"},{"b":"A","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"m":0,"k":"m","n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-compile-time"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"pre","m":0},{"k":"m","n":"post","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","t":"X::Syntax::Regex::MalformedRange","a":[{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Regex::MalformedRange"},{"a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"column"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre","k":"m"},{"n":"post","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","t":"X::Syntax::Regex::SolitaryQuantifier","d":"<p><pre><code>class X::Syntax::Regex::SolitaryQuantifier does X::Syntax { }</code></pre></p><p>Syntax error when a stand alone quantifier (without a preceding atom to quantify) is encountered in a regular expression.</p><p>For example</p><p><pre><code>/ * /;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nQuantifier quantifies nothing\n</code></pre></p>","mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Regex::SolitaryQuantifier","b":"A"},{"m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"d":"<p><pre><code>method adverb(--&gt; Str:D)</code></pre></p><p>Returns the illegally used adverb</p>","n":"adverb","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"construct","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","m":0,"k":"m"},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"pre","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"post","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"highexpect","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}],"d":"<p><pre><code>class X::Syntax::Regex::Adverb does X::Syntax { }</code></pre></p><p>Syntax error thrown when an unrecognized or illegal regex adverb is encountered.</p><p>For example</p><p><pre><code>rx:g/a/\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nAdverb g not allowed on rx\n</code></pre></p><p>because :g belongs to a match operation, not a regex itself.</p>","a":[{"k":"v","n":"$.adverb","t":"Mu"},{"t":"Mu","n":"$.construct","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","k":"c","n":"X::Syntax::Regex::Adverb","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::Adverb"},{"n":"X::Syntax::Regex::Unterminated","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"filename"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","m":0},{"n":"line","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"modules","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"pre","k":"m"},{"k":"m","n":"post","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"b":"A","a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::Unterminated","k":"c"},{"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::NonQuantifiable","b":"A","m":[{"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","k":"m"},{"k":"m","m":0,"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"column","m":0},{"m":0,"k":"m","n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"is-compile-time"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","m":0},{"m":0,"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","m":0},{"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0}],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Syntax::Regex::NonQuantifiable"},{"t":"X::Syntax::Regex::UnrecognizedModifier","mro":["X::Syntax","X::Comp","Exception"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message"},{"k":"m","m":0,"n":"modifier","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"filename","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","k":"m"},{"k":"m","n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"highexpect","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::Regex::UnrecognizedModifier","a":[{"k":"v","t":"Mu","n":"$.modifier"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A"},{"a":[{"k":"v","n":"$.char","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","n":"X::Syntax::Regex::Unspace","b":"A","t":"X::Syntax::Regex::Unspace","mro":["X::Syntax","X::Comp","Exception"],"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"char","m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"line","m":0},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"modules","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"is-compile-time"},{"k":"m","m":0,"n":"pre","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"k":"m","n":"highexpect","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}]},{"b":"A","n":"X::Syntax::Regex::SpacesInBareRange","t":"X::Syntax::Regex::SpacesInBareRange","a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message"},{"m":0,"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line"},{"n":"column","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"]},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","a":[{"t":"Mu","k":"v","n":"$.inf"},{"k":"v","t":"Mu","n":"$.non-numeric"},{"t":"Mu","n":"$.non-numeric-range","k":"v"},{"k":"v","n":"$.empty-range","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"t":"X::Syntax::Regex::QuantifierValue","b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"inf"},{"k":"m","m":0,"n":"non-numeric","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"non-numeric-range"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"empty-range"},{"n":"filename","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"column"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","k":"m"},{"n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"X::Syntax::Regex::QuantifierValue"},{"n":"X::Syntax::Variable::BadType","k":"c","a":[{"t":"Mu","n":"$.type","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"n":"message","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","n":"type","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"n":"pos","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"line","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m"},{"m":0,"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"is-compile-time"},{"k":"m","n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"post","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"mro":["X::Comp","Exception"],"b":"A","t":"X::Syntax::Variable::BadType"},{"n":"X::Syntax::Variable::IndirectDeclaration","t":"X::Syntax::Variable::IndirectDeclaration","b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"filename","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line"},{"k":"m","m":0,"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"modules"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c"},{"a":[{"t":"Mu","k":"v","n":"$.what"},{"k":"v","t":"Mu","n":"$.type"},{"k":"v","t":"Mu","n":"$.implicit"},{"t":"Mu","n":"$.maybe","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Variable::MissingInitializer","t":"X::Syntax::Variable::MissingInitializer","b":"A","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"what","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"type","k":"m"},{"n":"implicit","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"maybe","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"column","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"pre","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"post"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}]},{"b":"A","a":[{"t":"Mu","n":"$.outer","k":"v"},{"t":"Mu","n":"$.inner","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Comp","Exception"],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"outer","k":"m"},{"n":"inner","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"line"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"is-compile-time"},{"m":0,"n":"pre","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"k":"c","t":"X::Syntax::Variable::ConflictingTypes","n":"X::Syntax::Variable::ConflictingTypes"},{"d":"<p><pre><code>class X::Syntax::Variable::Numeric does X::Syntax { }</code></pre></p><p>Syntax error thrown when trying to declare numeric symbols.</p><p>For example</p><p><pre><code>my @101;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot declare a numeric variable\n</code></pre></p>","b":"A","a":[{"n":"$.what","k":"v","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Variable::Numeric","t":"X::Syntax::Variable::Numeric","k":"c","m":[{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"what"},{"m":0,"n":"filename","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column"},{"n":"modules","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"k":"m","n":"post","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"highexpect"},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s","n":"BUILDALL"}]},{"n":"X::Syntax::Variable::Twigil","t":"X::Syntax::Variable::Twigil","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"what"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"name","k":"m"},{"m":0,"n":"twigil","d":"<p><pre><code>method twigil(--&gt; Str:D)</code></pre></p><p>Returns the twigil that was illegally used</p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"scope","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"additional"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","m":0,"k":"m"},{"n":"pos","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"line"},{"k":"m","n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"modules","m":0},{"m":0,"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre"},{"n":"post","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"n":"$.what","k":"v","t":"Mu"},{"n":"$.name","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.twigil"},{"k":"v","t":"Mu","n":"$.scope"},{"n":"$.additional","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"<p><pre><code>class X::Syntax::Variable::Twigil does X::Syntax { }</code></pre></p><p>Syntax error thrown when a variable with a twigil is used in an incompatible declaration.</p><p>For example</p><p><pre><code>my $!foo;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use ! twigil on my variable\n</code></pre></p>","b":"A","k":"c"},{"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"name","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"filename"},{"k":"m","m":0,"n":"pos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"line","k":"m"},{"n":"column","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre","m":0},{"n":"post","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"a":[{"k":"v","n":"$.name","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"b":"A","t":"X::Syntax::Variable::Initializer","n":"X::Syntax::Variable::Initializer","mro":["X::Syntax","X::Comp","Exception"]},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Variable::Match","d":"<p><pre><code>class X::Syntax::Variable::Match does X::Syntax { }</code></pre></p><p>Syntax error thrown when a match variable like $&lt;thing&gt;  was declared.</p><p>For example</p><p><pre><code>my $&lt;thing&gt;;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot declare a match variable\n</code></pre></p>","b":"A","m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"k":"m","m":0,"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"line","k":"m"},{"m":0,"k":"m","n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"modules","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"pre","k":"m"},{"m":0,"n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"highexpect","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"X::Syntax::Variable::Match"},{"m":[{"k":"m","n":"message","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"meta","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"operator"},{"m":0,"n":"reason","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"dba"},{"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0,"k":"m"},{"k":"m","m":0,"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"post","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"b":"A","n":"X::Syntax::CannotMeta","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.meta","k":"v"},{"k":"v","t":"Mu","n":"$.operator"},{"k":"v","n":"$.reason","t":"Mu"},{"t":"Mu","n":"$.dba","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","t":"X::Syntax::CannotMeta"},{"t":"X::Syntax::Self::WithoutObject","m":[{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"message"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m"},{"n":"pos","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"column","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m"},{"k":"m","m":0,"n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"pre"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"b":"A","a":[{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"<p><pre><code>class X::Syntax::Self::WithoutObject does X::Syntax { }</code></pre></p><p>Syntax error thrown when self is referenced in a place where no invocant is available.</p><p>For example</p><p><pre><code>self;\n</code></pre></p><p>outside a class or role declaration dies with</p><p><pre><code>===SORRY!===\n'self' used where no object is available\n</code></pre></p>","n":"X::Syntax::Self::WithoutObject","mro":["X::Syntax","X::Comp","Exception"],"k":"c"},{"k":"c","d":"<p><pre><code>class X::Syntax::Perl5Var does X::Syntax { }</code></pre></p><p>Syntax error thrown when some piece of code tries to use one of the old Perl 5 variables (and it does not error for some other reason).</p><p><pre><code>say $];\n</code></pre></p><p>dies with</p><p><pre><code>Unsupported use of $] variable; in Raku please use $*PERL.version or $*PERL.compiler.version\n</code></pre></p><p>For every unsupported variable (which include most $^'letter' constructs, as well as others like $\", the error message will mention that the variable is unsupported and the equivalent commands you could use.</p>","m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","n":"name","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"identifier-name"},{"n":"filename","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"line","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"highexpect","m":0},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0,"n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.name","k":"v"},{"n":"$.identifier-name","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.filename"},{"n":"$.pos","k":"v","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","n":"X::Syntax::Perl5Var","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Perl5Var"},{"a":[{"t":"Mu","k":"v","n":"$.what"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::Malformed","b":"A","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0},{"n":"what","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"line"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","k":"m"},{"m":0,"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"d":"<p><pre><code>class X::Syntax::Malformed does X::Syntax {}</code></pre></p><p>The Raku compiler throws errors of type X::Syntax::Malformed when it knows what kind of declaration it is parsing, and encounters a syntax error, but can't give a more specific error message.</p><p><pre><code>my Int a;   # throws an X::Syntax::Malformed\n</code></pre></p><p>produces</p><p><pre><code>===SORRY!===\nMalformed my\nat -e:1\n------&gt; my Int ⏏a\n</code></pre></p>","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Malformed","k":"c"},{"a":[{"t":"Mu","k":"v","n":"$.what"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"b":"A","k":"c","n":"X::Syntax::Malformed::Elsif","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"what","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","m":0},{"k":"m","n":"modules","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"is-compile-time"},{"m":0,"k":"m","n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"post","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"highexpect","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Malformed::Elsif"},{"a":[{"t":"Mu","n":"$.macro","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"macro","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"column","k":"m"},{"m":0,"n":"modules","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre"},{"k":"m","m":0,"n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"highexpect","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0,"k":"s"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A","t":"X::Syntax::Argument::MOPMacro","n":"X::Syntax::Argument::MOPMacro"},{"n":"X::Syntax::NonAssociative","b":"A","t":"X::Syntax::NonAssociative","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"n":"left","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"right","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"m":0,"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"column","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","k":"m","m":0},{"m":0,"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"post","m":0},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"a":[{"n":"$.left","t":"Mu","k":"v"},{"t":"Mu","n":"$.right","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"d":"<p><pre><code>class X::Syntax::NoSelf does X::Syntax { }</code></pre></p><p>Compile time error thrown when $.foo style calls are used where no invocant is available.</p><p>For example the code</p><p><pre><code>$.meth;\n</code></pre></p><p>in the program body throws the error</p><p><pre><code>===SORRY!===\nVariable $.meth used where no 'self' is available\n</code></pre></p><p>because $.meth is short for $(self.meth), and there is no self available in mainline.</p>","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"n":"variable","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","k":"m"},{"k":"m","n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"n":"pre","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s"}],"k":"c","a":[{"t":"Mu","n":"$.variable","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::Syntax::NoSelf","t":"X::Syntax::NoSelf","b":"A"},{"k":"c","m":[{"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"filename","k":"m"},{"k":"m","n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","m":0,"k":"m"},{"k":"m","n":"post","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"highexpect"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"n":"X::Syntax::Term::MissingInitializer","d":"<p><pre><code>class X::Syntax::Term::MissingInitializer does X::Syntax { }</code></pre></p><p>Syntax error when a term (a backslash variable) is declared without initialization assignment.</p><p>For example</p><p><pre><code>my \\foo;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nTerm definition requires an initializer\n</code></pre></p><p>Valid code would be</p><p><pre><code>my \\foo = 42;\n</code></pre></p>","a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Term::MissingInitializer"},{"a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::Syntax::Missing","m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"what"},{"n":"filename","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"pos","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","m":0},{"n":"modules","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre"},{"m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"X::Syntax::Missing","k":"c","d":"<p><pre><code>class X::Syntax::Missing does X::Syntax { }</code></pre></p><p>Syntax error thrown when the previous piece of syntax requires the existence of another piece of syntax, and that second piece is missing.</p><p>For example</p><p><pre><code>for 1, 2, 3;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nMissing block\n</code></pre></p><p>because a for that is not a statement modifier must be followed by a block.</p>","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"t":"X::Syntax::BlockGobbled","mro":["X::Syntax","X::Comp","Exception"],"k":"c","b":"A","n":"X::Syntax::BlockGobbled","a":[{"n":"$.what","k":"v","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"what"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"filename","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m","m":0},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column"},{"m":0,"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0}]},{"a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"message","m":0},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line","m":0,"k":"m"},{"n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"n":"modules","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"is-compile-time","k":"m"},{"k":"m","n":"pre","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL"}],"t":"X::Syntax::Coercer::TooComplex","b":"A","k":"c","mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Coercer::TooComplex"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.keyword","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::WithoutElse","k":"c","t":"X::Syntax::WithoutElse","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"keyword"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"filename"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"line"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column"},{"m":0,"n":"modules","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"post"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}]},{"b":"A","k":"c","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.operator","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::Syntax::ConditionalOperator::PrecedenceTooLoose","m":[{"k":"m","m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"operator","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"pos","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"line","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"pre","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"n":"X::Syntax::ConditionalOperator::PrecedenceTooLoose"},{"mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"k":"c","m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"n":"line","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"modules","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"is-compile-time","k":"m"},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"b":"A","n":"X::Syntax::ConditionalOperator::SecondPartGobbled","t":"X::Syntax::ConditionalOperator::SecondPartGobbled"},{"t":"X::Syntax::ConditionalOperator::SecondPartInvalid","n":"X::Syntax::ConditionalOperator::SecondPartInvalid","b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message","m":0},{"m":0,"n":"second-part","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"filename"},{"m":0,"n":"pos","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"line"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","m":0,"k":"m"},{"m":0,"k":"m","n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"post"},{"m":0,"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"s","n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"mro":["X::Syntax","X::Comp","Exception"],"k":"c","a":[{"t":"Mu","k":"v","n":"$.second-part"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"n":"X::Syntax::NonListAssociative","k":"c","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.left","k":"v"},{"n":"$.right","k":"v","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","t":"X::Syntax::NonListAssociative","mro":["X::Syntax","X::Comp","X::Syntax::NonAssociative"]},{"mro":["X::Syntax","X::Comp","Exception"],"d":"<p><pre><code>class X::Syntax::Comment::Embedded does X::Syntax { }</code></pre></p><p>Syntax error thrown when #` is encountered and it is not followed by an opening curly brace.</p><p>For example</p><p><pre><code>#`\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nOpening bracket is required for #` comment\n</code></pre></p>","a":[{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::Comment::Embedded","b":"A","k":"c","n":"X::Syntax::Comment::Embedded","m":[{"m":0,"n":"message","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"filename"},{"m":0,"k":"m","n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"line","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column"},{"k":"m","n":"modules","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"pre"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]}}]},{"t":"X::Syntax::NegatedPair","b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m","m":0},{"k":"m","n":"key","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"line"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"column","k":"m"},{"n":"modules","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"pre","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"post"},{"m":0,"k":"m","n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"a":[{"t":"Mu","k":"v","n":"$.key"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::NegatedPair","k":"c","d":"<p><pre><code>class X::Syntax::NegatedPair does X::Syntax { }</code></pre></p><p>Thrown if a colonpair illegally has a value, for example :!a(1). This is an error because the ! negation implies that the value is False.</p><p>A typical error message from this class is Argument not allowed on negated pair with key 'a'.</p>","mro":["X::Syntax","X::Comp","Exception"]},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"adverb","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"k":"m","m":0,"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"line","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"column","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"modules"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-compile-time"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre"},{"m":0,"n":"post","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"highexpect"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"mro":["X::Syntax","X::Comp","Exception"],"k":"c","n":"X::Syntax::Type::Adverb","b":"A","a":[{"t":"Mu","n":"$.adverb","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Type::Adverb"},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"n":"call","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"column"},{"m":0,"k":"m","n":"modules","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"pre"},{"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"highexpect","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"k":"c","a":[{"k":"v","t":"Mu","n":"$.call"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A","t":"X::Syntax::VirtualCall","n":"X::Syntax::VirtualCall","mro":["X::Syntax","X::Comp","Exception"]},{"n":"X::Syntax::Signature::InvocantMarker","k":"c","d":"<p><pre><code>class X::Syntax::Signature::InvocantMarker does X::Syntax { }</code></pre></p><p>Syntax error when the invocant in a signature is anywhere else than after the first parameter.</p><p>For example</p><p><pre><code>:($a, $b: $c);\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCan only use : as invocant marker in a signature after the first parameter\n</code></pre></p><p>See also: Signature.</p>","t":"X::Syntax::Signature::InvocantMarker","b":"A","m":[{"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"line"},{"m":0,"n":"column","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","n":"modules","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"a":[{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"]},{"t":"X::Syntax::Signature::InvocantNotAllowed","mro":["X::Syntax","X::Comp","Exception"],"k":"c","b":"A","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"line"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"modules","k":"m"},{"m":0,"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Syntax::Signature::InvocantNotAllowed"},{"b":"A","m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"radix","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"filename","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"modules"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre","k":"m"},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","k":"m"},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"k":"c","t":"X::Syntax::Number::RadixOutOfRange","a":[{"t":"Mu","n":"$.radix","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"<p><pre><code>class X::Syntax::Number::RadixOutOfRange does X::Syntax { }</code></pre></p><p>Syntax error that is thrown when the radix of a radix number is not allowed, like :1&lt;1&gt;  or :42&lt;ouch&gt; .</p>","n":"X::Syntax::Number::RadixOutOfRange","mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","k":"c","n":"X::Syntax::Number::LiteralType","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.varname","k":"v"},{"k":"v","t":"Mu","n":"$.vartype"},{"t":"Mu","n":"$.value","k":"v"},{"n":"$.valuetype","t":"Mu","k":"v"},{"t":"Mu","n":"$.suggestiontype","k":"v"},{"t":"Mu","k":"v","n":"$.native"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"k":"m","n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"varname"},{"n":"vartype","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"value","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"valuetype","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"suggestiontype","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"native","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"filename"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"line"},{"k":"m","n":"column","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-compile-time","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"t":"X::Syntax::Number::LiteralType"},{"a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Number::IllegalDecimal","t":"X::Syntax::Number::IllegalDecimal","b":"A","k":"c","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message","m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename"},{"k":"m","n":"pos","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m"},{"n":"is-compile-time","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre","k":"m","m":0},{"m":0,"n":"post","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"highexpect"},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}]},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"m":0,"n":"filename","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"column","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","m":0,"k":"m"},{"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre","k":"m","m":0},{"m":0,"n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"highexpect","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","n":"BUILDALL"}],"b":"A","a":[{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Augment::Adverb","k":"c","n":"X::Syntax::Augment::Adverb"},{"t":"X::Syntax::Augment::Illegal","a":[{"k":"v","t":"Mu","n":"$.package"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","k":"v","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"k":"m","n":"message","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"package"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"line"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"column"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"modules"},{"k":"m","n":"is-compile-time","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pre","k":"m"},{"n":"post","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"],"n":"X::Syntax::Augment::Illegal","b":"A","k":"c"},{"b":"A","a":[{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Augment::WithoutMonkeyTyping","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message"},{"n":"filename","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"pos","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","k":"m"},{"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"modules"},{"k":"m","m":0,"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"post","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","m":0,"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"n":"X::Syntax::Augment::WithoutMonkeyTyping","d":"<p><pre><code>class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax { }</code></pre></p><p>Compile time error thrown when augment is used without use MONKEY-TYPING.</p><p>Since augment is considered a rather unsafe and impolite action, you have to pre-declare your intent with the use MONKEY-TYPING; pragma.</p><p>If you don't do that, like here</p><p><pre><code>augment class Int { };\n</code></pre></p><p>you get the error</p><p><pre><code>===SORRY!===\naugment not allowed without 'use MONKEY-TYPING'\n</code></pre></p>"},{"a":[{"k":"v","t":"Mu","n":"$.operation"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m"},{"k":"m","m":0,"n":"operation","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"b":"A","n":"X::IllegalOnFixedDimensionArray","mro":["Exception"],"k":"c","t":"X::IllegalOnFixedDimensionArray"},{"mro":["X::Comp","Exception"],"a":[{"n":"$.symbol","k":"v","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","k":"c","n":"X::Dynamic::Postdeclaration","m":[{"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"symbol","k":"m"},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pos","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"line","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column"},{"m":0,"n":"modules","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"m":0,"n":"pre","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"s"}],"t":"X::Dynamic::Postdeclaration"},{"mro":["X::Comp","Exception"],"t":"X::Dynamic::Package","k":"c","a":[{"t":"Mu","n":"$.symbol","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"symbol","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"filename"},{"m":0,"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"line","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"pre","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"n":"X::Dynamic::Package"},{"k":"c","n":"X::Dynamic::NotFound","a":[{"n":"$.name","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"d":"<p><pre><code>class X::Dynamic::NotFound is Exception {}</code></pre></p><p>This exception is raised when a dynamic variable that has not been declared is used.</p><p><pre><code>$*dynamic-not-found = 33;\n# OUTPUT: «Dynamic variable $*dynamic-not-found not found␤»\n</code></pre></p>","t":"X::Dynamic::NotFound","mro":["Exception"],"b":"A","m":[{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"name","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}]},{"n":"X::MustBeParametric","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"type","k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"}],"b":"A","mro":["Exception"],"t":"X::MustBeParametric","a":[{"k":"v","n":"$.type","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c"},{"n":"X::Worry","a":[{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","t":"X::Worry","mro":["Exception"],"k":"c"},{"a":[{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Worry::P5","mro":["X::Worry"],"b":"A","k":"c","n":"X::Worry::P5"},{"b":"A","t":"X::Worry::P5::BackReference","a":[{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Worry::P5::BackReference","mro":["X::Worry::P5"],"k":"c","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message","k":"m"}]},{"t":"X::Worry::P5::Reference","k":"c","n":"X::Worry::P5::Reference","b":"A","a":[{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"mro":["X::Worry::P5"],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"message"}]},{"n":"X::Worry::P5::LeadingZero","k":"c","t":"X::Worry::P5::LeadingZero","b":"A","m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"value","m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"a":[{"k":"v","t":"Mu","n":"$.value"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::Worry::P5"]},{"mro":["X::Worry"],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"action","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"b":"A","n":"X::Worry::Precedence::Range","k":"c","a":[{"t":"Mu","n":"$.action","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Worry::Precedence::Range"},{"t":"X::Adverb","mro":["Exception"],"a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.source","k":"v"},{"t":"Positional","k":"v","n":"@.unexpected"},{"n":"@.nogo","k":"v","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0,"k":"m"},{"n":"unexpected","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"n":"nogo","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"m","n":"what","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"m","n":"source","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"n":"X::Adverb","k":"c","b":"A"},{"t":"X::NoDispatcher","k":"c","mro":["Exception"],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m","m":0},{"n":"redispatcher","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"X::NoDispatcher","a":[{"t":"Mu","n":"$.redispatcher","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"d":"<p><pre><code>class X::NoDispatcher is Exception { }</code></pre></p><p>When a redispatcher like nextsame is called without being in the dynamic scope of a call where a redispatch is possible, an X::NoDispatcher is thrown.</p><p>For example</p><p><pre><code>nextsame; # In the mainline\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::NoDispatcher: nextsame is not in the dynamic scope of a dispatcher␤»</code></pre></p>","b":"A"},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"filename","m":0},{"k":"m","n":"pos","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"line","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"is-compile-time"},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"post"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"}],"b":"A","a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","t":"X::LibNone","n":"X::LibNone","mro":["X::Comp","Exception"]},{"t":"X::ControlFlow","k":"c","d":"<p><pre><code>class X::ControlFlow is Exception { }</code></pre></p><p>Thrown when a control flow construct (such as next or redo) is called outside the dynamic scope of an enclosing construct that is supposed to catch them.</p><p>For example</p><p><pre><code>last;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::ControlFlow: last without loop construct␤»</code></pre></p>","m":[{"k":"m","m":0,"n":"backtrace","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"message","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"illegal","d":"<p><pre><code>method illegal returns Str:D</code></pre></p><p>Returns the name of the control flow command that was called.</p>"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"enclosing"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"n":"X::ControlFlow","a":[{"n":"$.illegal","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.enclosing"},{"t":"Mu","n":"$.backtrace","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"b":"A"},{"m":[{"m":0,"n":"BUILD","s":{"r":"Mu","p":[{"n":":$!out-of-dynamic-scope","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"illegal","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"enclosing","k":"m"},{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"out-of-dynamic-scope","k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BUILDALL","k":"s"}],"d":"<p><pre><code>class X::ControlFlow::Return is X::ControlFlow { }</code></pre></p><p>Thrown when a return is called from outside a routine.</p><p><pre><code>return;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»</code></pre></p>","a":[{"k":"v","n":"$.out-of-dynamic-scope","t":"Bool"},{"n":"$.illegal","t":"Mu","k":"v"},{"t":"Mu","n":"$.enclosing","k":"v"},{"n":"$.backtrace","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::ControlFlow"],"t":"X::ControlFlow::Return","n":"X::ControlFlow::Return","b":"A","k":"c"},{"m":[{"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"what","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"column","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m","m":0},{"n":"is-compile-time","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"post"},{"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"n":"X::UnitScope::TooLate","mro":["X::Syntax","X::Comp","Exception"],"b":"A","a":[{"n":"$.what","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"t":"X::UnitScope::TooLate","k":"c"},{"b":"A","t":"X::UnitScope::Invalid","n":"X::UnitScope::Invalid","m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"what"},{"n":"where","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"suggestion","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"filename"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"pos","k":"m"},{"k":"m","m":0,"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","m":0},{"k":"m","n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.what"},{"k":"v","t":"Mu","n":"$.where"},{"k":"v","t":"Str:D","n":"$.suggestion"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c"},{"a":[{"t":"Mu","k":"v","n":"$.target"},{"t":"Mu","k":"v","n":"$.reason"},{"n":"$.source","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","t":"X::Numeric::CannotConvert","b":"A","m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"target","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"reason","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"source"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"n":"X::Numeric::CannotConvert","mro":["Exception"]},{"n":"X::Numeric::Real","k":"c","d":"<p><pre><code>class X::Numeric::Real is Exception { }</code></pre></p><p>Occurs when an attempt to coerce a Numeric to a Real, Num, Int or Rat fails (due to a number with a nonzero imaginary part, for instance).</p><p>For example</p><p><pre><code>say (1+2i).Int;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Numeric::Real: Can not convert 1+2i to Int: imaginary part not zero␤»</code></pre></p>","m":[{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"b":"A","t":"X::Numeric::Real","a":[{"n":"$.target","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.reason"},{"t":"Mu","k":"v","n":"$.source"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::Numeric::CannotConvert"]},{"t":"X::Numeric::Underflow","n":"X::Numeric::Underflow","a":[{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"}],"k":"c","mro":["Exception"]},{"a":[{"k":"v","n":"$.num","t":"Mu"},{"k":"v","t":"Mu","n":"$.base"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Numeric::Confused","k":"c","b":"A","mro":["Exception"],"t":"X::Numeric::Confused","m":[{"k":"m","m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"num","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"base"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}]},{"k":"c","a":[{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"message"}],"t":"X::Numeric::Overflow","n":"X::Numeric::Overflow","b":"A"},{"mro":["Exception"],"b":"A","a":[{"n":"$.using","t":"Mu","k":"v"},{"t":"Mu","n":"$.details","k":"v"},{"t":"Mu","n":"$.numerator","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Numeric::DivideByZero","k":"c","n":"X::Numeric::DivideByZero","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"m":0,"n":"using","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"details","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"numerator","k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"}]},{"mro":[],"k":"ro","b":"C","a":[{"n":"$.await-backtrace","k":"v","t":"Mu"}],"t":"X::Await::Died","n":"X::Await::Died"},{"k":"c","b":"A","mro":["Exception"],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"m":0,"k":"m","n":"version","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"a":[{"k":"v","n":"$.version","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Language::Unsupported","n":"X::Language::Unsupported"},{"t":"X::Language::ModRequired","a":[{"n":"$.version","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.modifier"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::Language::ModRequired","b":"A","mro":["Exception"],"m":[{"m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"version","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"modifier","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"k":"c"},{"t":"X::Language::TooLate","mro":["Exception"],"a":[{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0,"k":"m"}],"n":"X::Language::TooLate","k":"c"},{"k":"c","t":"X::Scheduler::CueInNaNSeconds","a":[{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","d":"<p><pre><code>class X::Scheduler::CueInNaNSeconds is Exception { }</code></pre></p><p>When calling ThreadPoolScheduler.cue or CurrentThreadScheduler.cue with :at, :in, or :every as NaN, this exception gets thrown. For example, the following code:</p><p><pre><code>my Cancellation $c = $*SCHEDULER.cue({\n    say 'This will never output :(';\n}, at =&gt; NaN);\n</code></pre></p><p>Throws with:</p><p><pre><code>Cannot pass NaN as a number of seconds to Scheduler.cue\n</code></pre></p><p>This class only exists in releases 2019.05 and later.</p>","m":[{"s":{"r":"Str","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"message"}],"n":"X::Scheduler::CueInNaNSeconds","mro":["Exception"]},{"m":[{"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"lang-rev"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"k":"c","t":"X::NoCoreRevision","a":[{"n":"$.lang-rev","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"],"n":"X::NoCoreRevision","b":"A"},{"m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"got","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"t":"X::Range::InvalidArg","b":"A","a":[{"t":"Mu","k":"v","n":"$.got"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Range::InvalidArg","mro":["Exception"],"k":"c"},{"a":[{"t":"Mu","n":"$.operation","k":"v"},{"k":"v","n":"$.got-dimensions","t":"Mu"},{"k":"v","t":"Mu","n":"$.needed-dimensions"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","n":"X::NotEnoughDimensions","k":"c","mro":["Exception"],"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"operation","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"got-dimensions","k":"m"},{"k":"m","m":0,"n":"needed-dimensions","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"t":"X::NotEnoughDimensions"},{"mro":["Exception"],"a":[{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Pairup::OddNumber","b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","m":0,"k":"m"}],"k":"c","t":"X::Pairup::OddNumber"},{"t":"X::Export::NameClash","k":"c","n":"X::Export::NameClash","d":"<p><pre><code>class X::Export::NameClash does X::Comp { }</code></pre></p><p>Compile time error thrown when a symbol is exported twice.</p><p>For example</p><p><pre><code>sub f() is export { };\n{\n    sub f() is export { }\n}\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nA symbol '&amp;f' has already been exported\n</code></pre></p>","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"message"},{"m":0,"n":"symbol","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pos","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"column","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"mro":["X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.symbol"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.source"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.reason","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"k":"c","d":"<p><pre><code>class X::Str::Numeric is Exception { }</code></pre></p><p>Error thrown (or wrapped in a Failure) when a conversion from string to a number fails.</p><p>For example</p><p><pre><code>say +\"42 answers\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Str::Numeric: Cannot convert string to number: trailing characters after number in '42⏏ answers' (indicated by ⏏)␤»</code></pre></p>","n":"X::Str::Numeric","mro":["Exception"],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"source-indicator","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method source(--&gt; Str:D)</code></pre></p><p>Returns the string that was attempted to convert to a number</p>","n":"source","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>method pos(--&gt; Int:D)</code></pre></p><p>Gives the position into the string where the parsing failed.</p>","n":"pos","m":0},{"n":"reason","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"t":"X::Str::Numeric","b":"A"},{"b":"A","n":"X::Str::Subst::Adverb","m":[{"n":"message","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"name"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"got","m":0},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.name","k":"v"},{"n":"$.got","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","t":"X::Str::Subst::Adverb","mro":["Exception"]},{"b":"A","a":[{"n":"$.got","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"got","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s"}],"k":"c","t":"X::Str::Trans::InvalidArg","mro":["Exception"],"n":"X::Str::Trans::InvalidArg"},{"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"key","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0}],"b":"A","mro":["Exception"],"n":"X::Str::Trans::IllegalKey","t":"X::Str::Trans::IllegalKey","a":[{"t":"Mu","k":"v","n":"$.key"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}]},{"t":"X::Str::Match::x","a":[{"k":"v","t":"Mu","n":"$.got"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"got","k":"m"},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"k":"c","b":"A","n":"X::Str::Match::x","mro":["Exception"]},{"a":[{"n":"$.directive","k":"v","t":"str"},{"t":"str","n":"$.sequence","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","m":[{"m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"directive","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"sequence","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0}],"t":"X::Str::Sprintf::Directives::Unsupported","b":"A","mro":["Exception"],"n":"X::Str::Sprintf::Directives::Unsupported"},{"n":"X::Str::Sprintf::Directives::Count","m":[{"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"n":"args-used","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"args-have"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"b":"A","k":"c","mro":["Exception"],"t":"X::Str::Sprintf::Directives::Count","a":[{"n":"$.args-used","t":"int","k":"v"},{"n":"$.args-have","k":"v","t":"int"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}]},{"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"type","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"directive"},{"n":"expected","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"value","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"t":"X::Str::Sprintf::Directives::BadType","a":[{"t":"str","n":"$.type","k":"v"},{"n":"$.directive","k":"v","t":"str"},{"t":"str","n":"$.expected","k":"v"},{"t":"Mu","n":"$.value","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"k":"c","mro":["Exception"],"n":"X::Str::Sprintf::Directives::BadType","b":"A"},{"m":[{"m":0,"n":"message","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","n":"name","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"n":"X::Str::InvalidCharName","b":"A","a":[{"n":"$.name","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Str::InvalidCharName","k":"c","mro":["Exception"]},{"m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"symbol","k":"m","m":0},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"n":"X::Caller::NotDynamic","mro":["Exception"],"d":"<p><pre><code>class X::Caller::NotDynamic is Exception { }</code></pre></p><p>Thrown when trying to access a non dynamic variable through CALLER</p><p>A typical error message is</p><p><pre><code>Cannot access '$x' through CALLER, because it is not declared as dynamic\n</code></pre></p>","k":"c","a":[{"n":"$.symbol","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","t":"X::Caller::NotDynamic"},{"b":"A","m":[{"k":"m","m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"feature","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"use","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0,"k":"m"},{"k":"m","m":0,"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"column","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"modules"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.feature","t":"Mu"},{"k":"v","n":"$.use","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Experimental","t":"X::Experimental"},{"mro":["Exception"],"a":[{"k":"v","n":"$.role","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Role::Parametric::NoSuchCandidate","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"role","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"b":"A","k":"c","n":"X::Role::Parametric::NoSuchCandidate"},{"k":"c","d":"<p><pre><code>class X::Role::Initialization is Exception { }</code></pre></p><p>Thrown when the SomeRole($init) syntax is used, but SomeRole does not have exactly one public attribute.</p><p>For example:</p><p><pre><code>role R { }; \"D2\" but R(2)\nCATCH { default { put .^name, ': ', .Str } }\n# OUTPUT: «X::Role::Initialization: Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'R'␤»\n</code></pre></p>","n":"X::Role::Initialization","b":"A","mro":["Exception"],"m":[{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0},{"m":0,"n":"role","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"X::Role::Initialization","a":[{"k":"v","n":"$.role","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}]},{"m":[{"n":"message","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"found"},{"m":0,"n":"last","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"mro":["Exception"],"t":"X::Hash::Store::OddNumber","n":"X::Hash::Store::OddNumber","b":"A","a":[{"t":"Mu","k":"v","n":"$.found"},{"t":"Mu","k":"v","n":"$.last"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c"},{"m":[{"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"n":"pseudo-package","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"action","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"filename","m":0},{"k":"m","n":"pos","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"column","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","k":"m","m":0},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0}],"a":[{"t":"Mu","n":"$.pseudo-package","k":"v"},{"n":"$.action","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::Comp","Exception"],"b":"A","n":"X::PseudoPackage::InDeclaration","k":"c","t":"X::PseudoPackage::InDeclaration"},{"t":"X::InvalidTypeSmiley","k":"c","mro":["X::Comp","Exception"],"b":"A","n":"X::InvalidTypeSmiley","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"name"},{"n":"filename","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","k":"m"},{"k":"m","m":0,"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","k":"m"},{"k":"m","n":"is-compile-time","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pre","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","n":"post","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"highexpect","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"a":[{"k":"v","t":"Mu","n":"$.name"},{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}]},{"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"what","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"filename"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"column","k":"m"},{"m":0,"n":"modules","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"pre","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Package::UseLib","b":"A","mro":["X::Comp","Exception"],"t":"X::Package::UseLib"},{"a":[{"n":"@.packages","k":"v","t":"Positional"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Package::Stubbed","d":"<p><pre><code>class X::Package::Stubbed does X::Comp { }</code></pre></p><p>Thrown at CHECK time when there are packages stubbed but not later defined.</p><p>For example</p><p><pre><code>class A { ... }     # literal ...\nclass B { ... }     # literal ...\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThe following packages were stubbed but not defined:\n    A\n    B\n</code></pre></p>","n":"X::Package::Stubbed","m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message"},{"n":"packages","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","n":"filename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"column","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m","m":0},{"n":"is-compile-time","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"pre","k":"m"},{"n":"post","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0}],"k":"c","mro":["X::Comp","Exception"],"b":"A"},{"a":[{"n":"$.lang","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Eval::NoSuchLang","b":"A","mro":["Exception"],"n":"X::Eval::NoSuchLang","d":"<p><pre><code>class X::Eval::NoSuchLang is Exception { }</code></pre></p><p>Error thrown when EVAL($str, :$lang) specifies a language that the compiler does not know how to handle.</p><p>For example</p><p><pre><code>EVAL 'boo', lang =&gt; \"bar\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Eval::NoSuchLang: No compiler available for language 'bar'␤»</code></pre></p>","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"lang","m":0},{"k":"s","n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}]},{"d":"<p><pre><code>role X::IO does X::OS {}</code></pre></p><p>Common role for IO related errors.</p><p>This role does not provide any additional methods.</p>","mro":["X::OS"],"t":"X::IO","n":"X::IO","b":"C","k":"ro"},{"mro":["X::IO","X::OS","Exception"],"a":[{"t":"Mu","n":"$.path","k":"v"},{"n":"$.os-error","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"b":"A","k":"c","n":"X::IO::Dir","d":"<p><pre><code>class X::IO::Dir does X::IO is Exception { }\n</code></pre></p><p>Error class that is thrown when a dir call fails.</p><p>A typical error message is</p><p><pre><code>Failed to get the directory contents of '/tmp/': No such file or directory\n</code></pre></p>","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"path","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"os-error","k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"t":"X::IO::Dir"},{"n":"X::IO::Unlink","mro":["X::IO","X::OS","Exception"],"b":"A","a":[{"t":"Mu","n":"$.path","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::IO::Unlink","m":[{"m":0,"k":"m","n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"n":"path","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"os-error","m":0},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"k":"c","d":"<p><pre><code>class X::IO::Unlink does X::IO is Exception { }\n</code></pre></p><p>Error class for failed unlink operation.</p><p>A typical error message is</p><p><pre><code>Failed to remove the file 'secret': Permission defined\n</code></pre></p>"},{"mro":["X::IO","X::OS","Exception"],"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"message"},{"k":"m","m":0,"n":"target","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Returns the path that symlink failed to create.</p>","m":0,"n":"name","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"os-error","k":"m"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"n":"X::IO::Symlink","t":"X::IO::Symlink","d":"<p><pre><code>class X::IO::Symlink does X::IO is Exception { }\n</code></pre></p><p>Error class for failed symlink creation.</p><p>A typical error message is</p><p><pre><code>Failed to create symlink called 'euler' on target '/home/myhome/euler-1.p6': Failed to symlink file: file already exist\n</code></pre></p>","b":"A","k":"c","a":[{"k":"v","t":"Mu","n":"$.target"},{"t":"Mu","n":"$.name","k":"v"},{"n":"$.os-error","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}]},{"b":"A","a":[{"n":"$.path","t":"Mu","k":"v"},{"k":"v","n":"$.mode","t":"Mu"},{"n":"$.os-error","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"path","k":"m","d":"<p>Returns the path that the mkdir operation failed to create.</p>"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"mode","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"os-error","m":0},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"t":"X::IO::Mkdir","d":"<p><pre><code>class X::IO::Mkdir does X::IO is Exception { }\n</code></pre></p><p>Error class for failed mkdir operations.</p><p>A typical error message is</p><p><pre><code>Failed to create directory 'destination' with mode '0o755': File exists\n</code></pre></p>","n":"X::IO::Mkdir","mro":["X::IO","X::OS","Exception"],"k":"c"},{"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"path","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"child"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"os-error"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}}],"k":"c","t":"X::IO::NotAChild","n":"X::IO::NotAChild","b":"A","a":[{"t":"Mu","k":"v","n":"$.path"},{"k":"v","t":"Mu","n":"$.child"},{"t":"Mu","n":"$.os-error","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::IO","X::OS","Exception"]},{"n":"X::IO::BinaryAndEncoding","k":"c","mro":["X::IO","X::OS","Exception"],"t":"X::IO::BinaryAndEncoding","a":[{"k":"v","t":"Mu","n":"$.os-error"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"os-error","k":"m","m":0},{"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0}]},{"m":[{"k":"m","n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"path","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"mode","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"os-error"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"k":"c","t":"X::IO::Chmod","b":"A","a":[{"t":"Mu","n":"$.path","k":"v"},{"t":"Mu","n":"$.mode","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::IO::Chmod","d":"<p><pre><code>class X::IO::Chmod does X::IO is Exception { }\n</code></pre></p><p>Error class for failed chmod calls.</p><p>A typical error message is</p><p><pre><code>Failed to set the mode of '/home/other' to '0o777': Permission denied\n</code></pre></p>","mro":["X::IO","X::OS","Exception"]},{"t":"X::IO::Directory","b":"A","k":"c","mro":["X::IO","X::OS","Exception"],"n":"X::IO::Directory","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"path","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"trying","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"use","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"os-error"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"a":[{"k":"v","t":"Mu","n":"$.path"},{"k":"v","t":"Mu","n":"$.trying"},{"n":"$.use","t":"Mu","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","mro":["X::IO","X::OS","Exception"],"n":"X::IO::BinaryMode","t":"X::IO::BinaryMode","k":"c","m":[{"m":0,"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"trying"},{"n":"os-error","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"a":[{"t":"Mu","k":"v","n":"$.trying"},{"t":"Mu","n":"$.os-error","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}]},{"mro":["X::IO","X::OS","Exception"],"b":"A","k":"c","t":"X::IO::Lock","n":"X::IO::Lock","a":[{"n":"$.lock-type","t":"Mu","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"n":"lock-type","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"os-error","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL","m":0}]},{"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"m":0,"k":"m","n":"from","d":"<p>Returns the source of the failed copy operation</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"to","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"os-error","k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","m":0}],"b":"A","a":[{"t":"Mu","k":"v","n":"$.from"},{"t":"Mu","n":"$.to","k":"v"},{"t":"Mu","n":"$.os-error","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::IO::Copy","t":"X::IO::Copy","mro":["X::IO","X::OS","Exception"],"d":"<p><pre><code>class X::IO::Copy does X::IO is Exception { }\n</code></pre></p><p>Error class for failed file copy operations. A typical error message is</p><p><pre><code>Failed to copy 'source' to 'destination': permission denied\n</code></pre></p>"},{"t":"X::IO::Move","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"d":"<p>Returns the source of the failed move operation</p>","n":"from"},{"k":"m","m":0,"n":"to","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"os-error","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"a":[{"k":"v","t":"Mu","n":"$.from"},{"t":"Mu","n":"$.to","k":"v"},{"t":"Mu","n":"$.os-error","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"d":"<p><pre><code>class X::IO::Move does X::IO is Exception { }\n</code></pre></p><p>Error class for a failed file move operation. A typical error message is</p><p><pre><code>Failed to move '/tmp/alpha.p6' to 'test.p6': :createonly specified and destination exists\n</code></pre></p>","mro":["X::IO","X::OS","Exception"],"n":"X::IO::Move","k":"c","b":"A"},{"a":[{"n":"$.path","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.os-error"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::IO::Chdir","t":"X::IO::Chdir","k":"c","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m"},{"k":"m","m":0,"n":"path","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"os-error"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"b":"A","mro":["X::IO","X::OS","Exception"],"d":"<p><pre><code>class X::IO::Chdir does X::IO is Exception { }\n</code></pre></p><p>Error class when a chdir call failed.</p><p>For example</p><p><pre><code>chdir '/home/other'\n</code></pre></p><p>throws</p><p><pre><code>Failed to change the working directory to '/home/other': permission denied\n</code></pre></p>"},{"mro":["X::IO","X::OS","Exception"],"b":"A","a":[{"t":"Mu","k":"v","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::IO::Cwd","m":[{"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"n":"os-error","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"t":"X::IO::Cwd","d":"<p><pre><code>class X::IO::Cwd does X::IO is Exception { }\n</code></pre></p><p>Error class when the runtime fails to determine the current directory.</p><p>A typical error message is</p><p><pre><code>Failed to get the working directory: permission denied\n</code></pre></p>","k":"c"},{"mro":["X::IO","X::OS","Exception"],"t":"X::IO::Flush","n":"X::IO::Flush","b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"os-error"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s"}],"k":"c","a":[{"n":"$.os-error","k":"v","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}]},{"t":"X::IO::Rename","a":[{"n":"$.from","k":"v","t":"Mu"},{"k":"v","n":"$.to","t":"Mu"},{"t":"Mu","k":"v","n":"$.os-error"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message","k":"m"},{"d":"<p>Returns the source of the failed rename operation</p>","m":0,"k":"m","n":"from","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"to","k":"m","m":0},{"n":"os-error","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"}],"n":"X::IO::Rename","b":"A","k":"c","mro":["X::IO","X::OS","Exception"],"d":"<p><pre><code>class X::IO::Rename does X::IO is Exception { }\n</code></pre></p><p>Error class for failed file or directory rename operations. A typical error message is</p><p><pre><code>Failed to rename 'source' to 'destination': is a directory\n</code></pre></p>"},{"a":[{"n":"$.trying","k":"v","t":"Mu"},{"t":"Mu","n":"$.os-error","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","mro":["X::IO","X::OS","Exception"],"b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"trying"},{"n":"os-error","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"t":"X::IO::Unknown","n":"X::IO::Unknown"},{"t":"X::IO::Link","k":"c","mro":["X::IO","X::OS","Exception"],"a":[{"k":"v","t":"Mu","n":"$.target"},{"n":"$.name","k":"v","t":"Mu"},{"n":"$.os-error","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"<p><pre><code>class X::IO::Link does X::IO is Exception { }\n</code></pre></p><p>Error class for failed link operation.</p><p>A typical error message is</p><p><pre><code>Failed to create link called 'my-link' on target 'does-not exist': Failed to link file\n</code></pre></p>","m":[{"k":"m","m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"target","d":"<p>Returns the name of the link target, i.e. the existing file.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"name","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"os-error"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"b":"A","n":"X::IO::Link"},{"a":[{"n":"$.path","t":"Mu","k":"v"},{"n":"$.trying","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::IO","X::OS","Exception"],"b":"A","m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"path","m":0},{"n":"trying","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"os-error","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BUILDALL","k":"s"}],"t":"X::IO::NotAFile","k":"c","n":"X::IO::NotAFile"},{"b":"A","d":"<p><pre><code>class X::IO::DoesNotExist does X::IO is Exception { }\n</code></pre></p><p>Thrown when doing file test operations on a non existing path.</p><p>A typical error message is</p><p><pre><code>Failed to find 'euler-5.p6' while trying to do '.f'\n</code></pre></p>","mro":["X::IO","X::OS","Exception"],"m":[{"m":0,"n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"d":"<p>Returns the path that was passed to the failed call.</p>","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"path"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"trying"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"os-error","m":0},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"a":[{"k":"v","t":"Mu","n":"$.path"},{"k":"v","n":"$.trying","t":"Mu"},{"k":"v","t":"Mu","n":"$.os-error"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","t":"X::IO::DoesNotExist","n":"X::IO::DoesNotExist"},{"mro":["X::IO","X::OS","Exception"],"n":"X::IO::Resolve","k":"c","t":"X::IO::Resolve","a":[{"n":"$.path","k":"v","t":"Mu"},{"n":"$.os-error","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"path"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"os-error","m":0},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"b":"A"},{"a":[{"n":"$.os-error","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::IO","X::OS","Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"os-error","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"k":"c","t":"X::IO::Null","b":"A","n":"X::IO::Null"},{"b":"A","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"path"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"os-error","m":0,"k":"m"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"d":"<p><pre><code>my class X::IO::Rmdir does X::IO is Exception { }\n</code></pre></p><p>Error class for failed rmdir operations.</p><p>A typical error message is</p><p><pre><code>Failed to remove the directory 'lib': Directory not empty\n</code></pre></p>","k":"c","a":[{"n":"$.path","k":"v","t":"Mu"},{"k":"v","n":"$.os-error","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::IO::Rmdir","mro":["X::IO","X::OS","Exception"],"n":"X::IO::Rmdir"},{"k":"c","b":"A","a":[{"k":"v","t":"Mu","n":"$.type"},{"n":"%.nameds","k":"v","t":"Associative"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"<p><pre><code>class X::Does::TypeObject is Exception {}</code></pre></p><p>When you try to add one or more roles to a type object with does after it has been composed, an error of type X::Does::TypeObject is thrown:</p><p><pre><code>Mu does Numeric;    # Cannot use 'does' operator with a type object.\n</code></pre></p><p>The correct way to apply roles to a type is at declaration time:</p><p><pre><code>class GrassmannNumber does Numeric { ... };\nrole AlgebraDebugger does IO { ... };\ngrammar IntegralParser does AlgebraParser { ... };\n</code></pre></p><p>Roles may only be runtime-mixed into defined object instances:</p><p><pre><code>GrassmannNumber.new does AlgebraDebugger;\n</code></pre></p><p>(This restriction may be worked around by using augment or supersede, or with dark Metamodel magics, but this will likely result in a significant performance penalty.)</p>","n":"X::Does::TypeObject","m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"type","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","n":"nameds","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"t":"X::Does::TypeObject","mro":["Exception"]},{"m":[{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"m":0,"n":"localizer","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"k":"c","n":"X::Localizer::NoContainer","b":"A","t":"X::Localizer::NoContainer","mro":["Exception"],"a":[{"t":"Mu","n":"$.localizer","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}]},{"k":"c","b":"A","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"message"},{"k":"m","n":"method","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"n":"name","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"value"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.method","k":"v"},{"n":"$.name","k":"v","t":"Mu"},{"n":"$.value","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"X::Invalid::Value","mro":["Exception"],"n":"X::Invalid::Value"},{"b":"A","m":[{"k":"m","n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"method","k":"m","m":0},{"m":0,"n":"name","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"n":"value","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"reason","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0}],"mro":["Exception"],"k":"c","n":"X::Invalid::ComputedValue","t":"X::Invalid::ComputedValue","a":[{"n":"$.method","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.name"},{"k":"v","t":"Mu","n":"$.value"},{"t":"Mu","k":"v","n":"$.reason"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}]},{"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"what"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"reason","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s"}],"a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.reason","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Exhausted","k":"c","b":"A","t":"X::Exhausted","mro":["Exception"]},{"b":"A","a":[{"k":"v","n":"$.name","t":"Mu"},{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","n":"X::Signature::NameClash","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"name"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"filename","k":"m"},{"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"line"},{"m":0,"k":"m","n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"modules","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","k":"m","m":0},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"post","m":0},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"t":"X::Signature::NameClash","d":"<p><pre><code>my class X::Signature::NameClash does X::Comp { }</code></pre></p><p>Compile time error thrown when two named parameters have the same name, potentially through aliases.</p><p>For example</p><p><pre><code>sub f(:$a, :a(:@b)) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nName a used for more than one named parameter\n</code></pre></p>","mro":["X::Comp","Exception"]},{"b":"A","t":"X::Signature::Placeholder","d":"<p><pre><code>class X::Signature::Placeholder does X::Comp { }\n</code></pre></p><p>Compile time error thrown when a block has both an explicit signature and placeholder parameters.</p><p>For example</p><p><pre><code>sub f() { $^x }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPlaceholder variable '$^x' cannot override existing signature\n</code></pre></p>","n":"X::Signature::Placeholder","m":[{"n":"message","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"placeholder","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"filename","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"pos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"line"},{"m":0,"n":"column","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"modules","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"pre"},{"n":"post","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"mro":["X::Comp","Exception"],"k":"c","a":[{"k":"v","t":"Mu","n":"$.placeholder"},{"t":"Mu","k":"v","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","k":"v","t":"Positional"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}]},{"n":"X::Routine::Unwrap","mro":["Exception"],"t":"X::Routine::Unwrap","k":"c","a":[{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A","m":[{"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0}]},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0,"k":"m"},{"d":"<p><pre><code>method phaser(--&gt; Str:D)</code></pre></p><p>Returns the name of the failed phaser, \"PRE\" or \"POST\".</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"phaser"},{"m":0,"n":"condition","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"k":"c","b":"A","n":"X::Phaser::PrePost","a":[{"n":"$.phaser","k":"v","t":"Mu"},{"t":"Mu","n":"$.condition","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"d":"<p><pre><code>class X::Phaser::PrePost is Exception { }\n</code></pre></p><p>Thrown when the condition inside a PRE or POST phaser evaluate to a false value.</p><p>For example</p><p><pre><code>sub f($x) { PRE { $x ~~ Int } };\nf \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: X::Phaser::PrePost: Precondition '{ $x ~~ Int }' failed«␤»</code></pre></p>","mro":["Exception"],"t":"X::Phaser::PrePost"},{"b":"A","mro":["X::Comp","Exception"],"a":[{"t":"Mu","k":"v","n":"$.block"},{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::Phaser::Multiple","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"k":"m","n":"block","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"filename","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column","m":0},{"m":0,"n":"modules","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"is-compile-time","k":"m"},{"m":0,"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"highexpect","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0}],"t":"X::Phaser::Multiple","k":"c","d":"<p><pre><code>class X::Phaser::Multiple does X::Comp { }</code></pre></p><p>Thrown when multiple phasers of the same type occur in a block, but only one is allowed (for example CATCH or CONTROL).</p><p>For example</p><p><pre><code>CATCH { }; CATCH { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nOnly one CATCH block is allowed\n</code></pre></p>"},{"d":"<p><pre><code>class X::Undeclared does X::Comp {}</code></pre></p><p>Thrown when the compiler encounters a symbol that has not been declared, but needs to be.</p><p>Example</p><p><pre><code>$x;\n</code></pre></p><p>results in</p><p><pre><code>===SORRY!===\nVariable $x is not declared\n</code></pre></p>","mro":["X::Comp","Exception"],"k":"c","m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"what"},{"d":"<p>Returns the name of the undeclared symbol</p>","n":"symbol","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"suggestions"},{"m":0,"n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","m":0,"k":"m"},{"n":"column","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"pre"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"post"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"highexpect"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"b":"A","a":[{"k":"v","t":"Mu","n":"$.what"},{"n":"$.symbol","t":"Mu","k":"v"},{"n":"@.suggestions","k":"v","t":"Positional"},{"n":"$.filename","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Undeclared","n":"X::Undeclared"},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"post_types","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"unk_types"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"unk_routines","k":"m","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"routine_suggestion","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"type_suggestion"},{"k":"m","n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"pos"},{"m":0,"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"column","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"modules","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"is-compile-time"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","k":"m"},{"n":"highexpect","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"k":"c","mro":["X::Comp","Exception"],"b":"A","a":[{"t":"Associative","n":"%.post_types","k":"v"},{"t":"Associative","n":"%.unk_types","k":"v"},{"t":"Associative","k":"v","n":"%.unk_routines"},{"n":"%.routine_suggestion","t":"Associative","k":"v"},{"k":"v","t":"Associative","n":"%.type_suggestion"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Undeclared::Symbols","t":"X::Undeclared::Symbols"},{"mro":["Exception"],"m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0},{"n":"specification","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!is-missing-from-meta-file"}],"b":"A","n":"X::CompUnit::UnsatisfiedDependency","a":[{"n":"$.specification","t":"CompUnit::DependencySpecification","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","t":"X::CompUnit::UnsatisfiedDependency"},{"t":"X::Channel::SendOnClosed","d":"<p><pre><code>class X::Channel::SendOnClosed {}</code></pre></p><p>This exception is thrown when a calling send on a Channel that has been closed:</p><p><pre><code>my $s = Channel.new;\n$s.close;\n$s.send(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»</code></pre></p>","b":"A","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"channel"},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0}],"mro":["Exception"],"n":"X::Channel::SendOnClosed","a":[{"t":"Mu","k":"v","n":"$.channel"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c"},{"k":"c","a":[{"n":"$.channel","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"],"b":"A","d":"<p><pre><code>class X::Channel::ReceiveOnClosed {}</code></pre></p><p>This exception is thrown when a calling receive on a Channel that has been closed:</p><p><pre><code>my $s = Channel.new;\n$s.close;\n$s.receive;     # Cannot receive a message on a closed channel\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::ReceiveOnClosed: Cannot receive a message on a closed channel␤»</code></pre></p>","n":"X::Channel::ReceiveOnClosed","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"channel"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"t":"X::Channel::ReceiveOnClosed"},{"mro":["Exception"],"b":"A","n":"X::IllegalDimensionInShape","t":"X::IllegalDimensionInShape","k":"c","a":[{"n":"$.dim","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"n":"dim","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"s","n":"BUILDALL"}]},{"k":"c","n":"X::Import::Positional","b":"A","t":"X::Import::Positional","a":[{"k":"v","t":"Mu","n":"$.source-package"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"m":0,"n":"source-package","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["Exception"]},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"from"},{"k":"m","m":0,"n":"missing","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"X::Import::MissingSymbols","n":"X::Import::MissingSymbols","k":"c","b":"A","a":[{"t":"Mu","n":"$.from","k":"v"},{"t":"Positional","n":"@.missing","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"]},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"message"},{"n":"source-package","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"tag","k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"n":"X::Import::NoSuchTag","mro":["Exception"],"a":[{"t":"Mu","n":"$.source-package","k":"v"},{"t":"Mu","k":"v","n":"$.tag"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","t":"X::Import::NoSuchTag","k":"c"},{"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"symbols"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"source-package-name","k":"m"},{"n":"filename","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"modules"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-compile-time","m":0},{"n":"pre","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"post"},{"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"a":[{"t":"Positional","n":"@.symbols","k":"v"},{"t":"Mu","k":"v","n":"$.source-package-name"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Comp","Exception"],"k":"c","n":"X::Import::Redeclaration","t":"X::Import::Redeclaration","b":"A"},{"b":"A","mro":["X::Comp","Exception"],"a":[{"k":"v","n":"@.symbols","t":"Positional"},{"k":"v","n":"$.source-package-name","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"m":0,"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","n":"symbols","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"source-package-name"},{"n":"filename","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"k":"m","n":"pos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"modules","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"pre","k":"m"},{"m":0,"k":"m","n":"post","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"highexpect","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"t":"X::Import::OnlystarProto","n":"X::Import::OnlystarProto","k":"c"},{"t":"X::Set::Coerce","k":"c","b":"A","n":"X::Set::Coerce","a":[{"t":"Mu","k":"v","n":"$.thing"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"thing"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["Exception"]},{"b":"A","t":"X::DateTime::TimezoneClash","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message","k":"m"}],"k":"c","d":"<p><pre><code>class X::DateTime::TimezoneClash does X::Temporal is Exception { }\n</code></pre></p><p>This exception is thrown when code tries to create a DateTime object specifying both a time zone offset and the named argument :timezone.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200');                   # works\nsay DateTime.new('2015-12-24T12:23:00', timezone =&gt; 7200);      # works\nsay DateTime.new('2015-12-24T12:23:00+0200', timezone =&gt; 7200); # exception\n</code></pre></p>","n":"X::DateTime::TimezoneClash","mro":["X::Temporal","Exception"],"a":[{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}]},{"t":"X::DateTime::InvalidDeltaUnit","m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"unit"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::DateTime::InvalidDeltaUnit","b":"A","a":[{"n":"$.unit","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","mro":["X::Temporal","Exception"]},{"t":"X::Match::Bool","k":"c","m":[{"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"type","m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"mro":["Exception"],"a":[{"t":"Mu","k":"v","n":"$.type"},{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Match::Bool","b":"A"},{"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"sorry_heading","k":"m"}],"a":[{"n":"$.filename","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"}],"d":"<p><pre><code>role X::Comp is Exception { }</code></pre></p><p>Common role for compile-time errors.</p><p>Note that since the backtrace of a compile time error generally shows routines from the compiler, not from user-space programs, the Backtrace returned from the backtrace method is not very informative. Instead the exception carries its own filename, line and column attributes and public accessors.</p><p>If an error occurs while creating an object (like a class or routine) at compile time, generally the exception associated with it does not hold a reference to the object (for example a class would not be fully composed, and thus not usable). In those cases the name of the would-be-created object is included in the error message instead.</p>","mro":["Exception"],"k":"ro","b":"C","n":"X::Comp","t":"X::Comp"},{"b":"A","a":[{"n":"$.panic","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.sorrows"},{"t":"Positional","k":"v","n":"@.worries"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Comp::Group","k":"c","mro":["Exception"],"m":[{"m":0,"k":"m","n":"is-compile-time","s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","m":0},{"k":"m","n":"panic","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"sorrows","m":0,"k":"m"},{"n":"worries","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]}}],"n":"X::Comp::Group"},{"t":"X::Comp::BeginTime","a":[{"n":"$.use-case","k":"v","t":"str"},{"t":"Mu","k":"v","n":"$.exception"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","mro":["X::Comp","Exception"],"n":"X::Comp::BeginTime","m":[{"n":"message","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"use-case","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"exception","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"line"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","k":"m"},{"n":"modules","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"is-compile-time"},{"m":0,"n":"pre","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"highexpect","k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL"}],"k":"c"},{"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"k":"m","n":"is-compile-time"},{"n":"message","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"dba","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"goal","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"line-real","k":"m","m":0},{"n":"filename","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","n":"pos","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"column"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"post","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"n":"X::Comp::FailGoal","t":"X::Comp::FailGoal","k":"c","b":"A","mro":["X::Comp","Exception"],"a":[{"n":"$.dba","k":"v","t":"Mu"},{"n":"$.goal","k":"v","t":"Mu"},{"n":"$.line-real","t":"Mu","k":"v"},{"n":"$.filename","k":"v","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}]},{"k":"c","b":"A","a":[{"t":"Mu","k":"v","n":"$.filename"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","k":"v","n":"$.is-compile-time"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","n":"$.feature","t":"Mu"},{"t":"Mu","n":"$.did-you-mean","k":"v"},{"n":"$.workaround","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"n":"filename","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"n":"pos","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","k":"m","m":0},{"n":"modules","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"is-compile-time","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pre"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"X::Comp::NYI","t":"X::Comp::NYI","mro":["X::Comp","X::NYI","Exception"]},{"b":"A","t":"X::Comp::Trait::NotOnNative","mro":["X::Comp","X::Trait::NotOnNative","Exception"],"a":[{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$.type","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.subtype"},{"n":"$.native","k":"v","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$!bt"}],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"m":0,"n":"pos","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"column"},{"m":0,"n":"modules","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"is-compile-time","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect","k":"m"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"k":"c","n":"X::Comp::Trait::NotOnNative"},{"n":"X::Comp::Trait::Scope","m":[{"n":"filename","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"line"},{"n":"column","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"modules","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"post","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","X::Trait::Scope","Exception"],"k":"c","b":"A","a":[{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"n":"$.line","k":"v","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$.type","t":"Mu","k":"v"},{"n":"$.subtype","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.declaring"},{"n":"$.scope","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.supported"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Comp::Trait::Scope"},{"b":"A","n":"X::Comp::Trait::Unknown","t":"X::Comp::Trait::Unknown","mro":["X::Comp","X::Trait::Unknown","Exception"],"a":[{"t":"Mu","k":"v","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","k":"v","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$.type","k":"v"},{"t":"Mu","n":"$.subtype","k":"v"},{"n":"$.declaring","k":"v","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"filename","k":"m"},{"m":0,"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"line"},{"m":0,"n":"column","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"modules","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"is-compile-time","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"pre","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","k":"m","m":0},{"m":0,"n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}]},{"t":"X::Comp::WheneverOutOfScope","m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"n":"pos","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"column","k":"m"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pre"},{"m":0,"n":"post","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","n":"highexpect","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"k":"c","a":[{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","k":"v","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::Comp","Exception"],"b":"A","n":"X::Comp::WheneverOutOfScope"},{"mro":["X::Comp","X::AdHoc","Exception"],"a":[{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$.payload","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"k":"c","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"k":"m","m":0,"n":"is-compile-time"},{"m":0,"k":"m","n":"filename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"pos","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"line"},{"k":"m","n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"modules","m":0},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post","m":0},{"n":"highexpect","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"b":"A","t":"X::Comp::AdHoc","n":"X::Comp::AdHoc"},{"a":[{"t":"Positional","k":"v","n":"@.exceptions"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"message"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"exceptions"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"n":"X::PhaserExceptions","t":"X::PhaserExceptions","mro":["Exception"],"b":"A","k":"c"},{"m":[{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"type"},{"n":"subtype","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"declaring","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"name"},{"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0}],"n":"X::Trait::Invalid","b":"A","t":"X::Trait::Invalid","k":"c","mro":["Exception"],"a":[{"n":"$.type","k":"v","t":"Mu"},{"n":"$.subtype","t":"Mu","k":"v"},{"n":"$.declaring","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.name"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"type"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"subtype"},{"k":"m","n":"native","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["Exception"],"k":"c","t":"X::Trait::NotOnNative","n":"X::Trait::NotOnNative","b":"A","a":[{"t":"Mu","n":"$.type","k":"v"},{"t":"Mu","n":"$.subtype","k":"v"},{"t":"Mu","k":"v","n":"$.native"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}]},{"n":"X::Trait::Scope","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"type","k":"m"},{"n":"subtype","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"declaring"},{"n":"scope","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"supported"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"k":"c","b":"A","a":[{"k":"v","n":"$.type","t":"Mu"},{"t":"Mu","n":"$.subtype","k":"v"},{"k":"v","t":"Mu","n":"$.declaring"},{"k":"v","n":"$.scope","t":"Mu"},{"n":"$.supported","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["Exception"],"t":"X::Trait::Scope"},{"a":[{"n":"$.type","t":"Mu","k":"v"},{"t":"Mu","n":"$.subtype","k":"v"},{"k":"v","n":"$.declaring","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"type","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"subtype","k":"m","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"declaring","k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"n":"X::Trait::Unknown","b":"A","t":"X::Trait::Unknown","k":"c","mro":["Exception"]},{"k":"c","t":"X::WheneverOutOfScope","a":[{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"}],"n":"X::WheneverOutOfScope","b":"A","mro":["Exception"]},{"b":"A","t":"X::Subscript::Negative","a":[{"t":"Mu","n":"$.index","k":"v"},{"n":"$.type","k":"v","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"n":"X::Subscript::Negative","m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"index","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"type","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"k":"c"},{"d":"<p><pre><code>class X::Mixin::NotComposable is Exception { }</code></pre></p><p>Thrown when a mixin with infix does or but is done with a composer that cannot be used for mixin.</p><p>For example</p><p><pre><code>class A { };\n1 but A;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Mixin::NotComposable: Cannot mix in non-composable type A into object of type Int␤»</code></pre></p><p>The compile-time equivalent of this error is X::Composition::NotComposable</p>","n":"X::Mixin::NotComposable","k":"c","b":"A","a":[{"k":"v","t":"Mu","n":"$.target"},{"n":"$.rolish","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method target()</code></pre></p><p>Returns the target of the failed mixin operation.</p>","m":0,"n":"target"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"rolish","k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"mro":["Exception"],"t":"X::Mixin::NotComposable"},{"t":"X::MultipleTypeSmiley","n":"X::MultipleTypeSmiley","mro":["X::Comp","Exception"],"k":"c","b":"A","a":[{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"m":[{"n":"message","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"filename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"pos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"line","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"column","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"pre","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}]},{"d":"<p><pre><code>class X::Obsolete does X::Comp { }</code></pre></p><p>Syntax error thrown when the user is attempting to use constructs from other languages.</p><p>For example</p><p><pre><code>m/abc/i\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nUnsupported use of /i; in Raku please use :i\n</code></pre></p>","n":"X::Obsolete","a":[{"t":"Mu","k":"v","n":"$.old"},{"n":"$.replacement","t":"Mu","k":"v"},{"n":"$.when","k":"v","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","k":"v","t":"Positional"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Obsolete","mro":["X::Comp","Exception"],"k":"c","b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"old","d":"<p><pre><code>method old(--&gt; Str:D)</code></pre></p><p>Returns a textual description of the obsolete syntax construct</p>"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"replacement","d":"<p><pre><code>method replacement(--&gt; Str:D)</code></pre></p><p>Describes what to use instead of the obsolete syntax.</p>","k":"m"},{"n":"when","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"filename"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pos","k":"m"},{"n":"line","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"modules","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-compile-time","k":"m"},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"post","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"highexpect","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}]},{"n":"X::PoisonedAlias","b":"A","mro":["X::Comp","Exception"],"k":"c","t":"X::PoisonedAlias","a":[{"k":"v","n":"$.alias","t":"str"},{"k":"v","n":"$.package-type","t":"str"},{"n":"$.package-name","k":"v","t":"str"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","k":"v","n":"$.line"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","k":"v","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"alias","k":"m"},{"n":"package-type","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"package-name","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"modules"},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"pre"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"post"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}]},{"k":"ro","a":[{"n":"$.proc","t":"Proc::Async","k":"v"}],"d":"<p><pre><code>role X::Proc::Async is Exception { ... }</code></pre></p><p>All exceptions thrown by Proc::Async do this common role.</p>","b":"C","t":"X::Proc::Async","n":"X::Proc::Async","mro":["Exception"]},{"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"handle","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"proc"},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"d":"<p><pre><code>class X::Proc::Async::CharsOrBytes is Exception {}</code></pre></p><p>A Proc::Async object allows subscription to the output or error stream either for bytes (Blob) or for text data (Str), but not for both. If you do try both, it throws an exception of type X::Proc::Async::CharsOrBytes.</p><p><pre><code>my $proc = Proc::Async.new('echo');\n$proc.stdout.tap(&amp;print);\n$proc.stdout(:bin).tap(&amp;print);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::CharsOrBytes: Can only tap one of chars or bytes supply for stdout␤»</code></pre></p>","n":"X::Proc::Async::CharsOrBytes","b":"A","t":"X::Proc::Async::CharsOrBytes","mro":["X::Proc::Async","Exception"],"k":"c","a":[{"n":"$.handle","t":"Mu","k":"v"},{"t":"Proc::Async","n":"$.proc","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}]},{"n":"X::Proc::Async::OpenForWriting","b":"A","k":"c","a":[{"k":"v","t":"Mu","n":"$.method"},{"k":"v","n":"$.proc","t":"Proc::Async"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"method","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"proc","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"t":"X::Proc::Async::OpenForWriting","mro":["X::Proc::Async","Exception"],"d":"<p><pre><code>class X::Proc::Async::OpenForWriting is Exception {}</code></pre></p><p>When a Proc::Async object is opened only for reading from the external program (no :w passed to open), and a write operation such as write, print and say is performed, an exception of type X::Proc::Async::OpenForWriting is thrown:</p><p><pre><code>my $proc = Proc::Async.new(\"echo\");\n$proc.start;\n$proc.say(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::OpenForWriting: Process must be opened for writing with :w to call 'say'␤»</code></pre></p><p>To fix that you can use writable commands with :w flag:</p><p><pre><code>my $prog = Proc::Async.new(:w, 'cat');\n$prog.stdout.tap( -&gt; $str {\n    print $str;\n});\nmy $promise = $prog.start;\nawait $prog.say('foo');\n$prog.close-stdin;\nawait $promise;</code></pre></p>"},{"a":[{"k":"v","n":"$.proc","t":"Proc::Async"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A","n":"X::Proc::Async::SupplyOrStd","m":[{"k":"m","n":"message","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"proc","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"k":"c","mro":["X::Proc::Async","Exception"],"t":"X::Proc::Async::SupplyOrStd"},{"a":[{"t":"Proc::Async","k":"v","n":"$.proc"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"n":"message","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"proc","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s"}],"b":"A","d":"<p><pre><code>class X::Proc::Async::AlreadyStarted is Exception {}</code></pre></p><p>When you call start twice on the same Proc::Async object, the second invocation will die with an X::Proc::Async::AlreadyStarted exception.</p><p><pre><code>my $proc = Proc::Async.new(\"echo\");\n$proc.start;\n$proc.start;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::AlreadyStarted: Process has already been started␤»</code></pre></p>","k":"c","mro":["X::Proc::Async","Exception"],"t":"X::Proc::Async::AlreadyStarted","n":"X::Proc::Async::AlreadyStarted"},{"n":"X::Proc::Async::BindOrUse","m":[{"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"handle","k":"m","m":0},{"n":"use","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"proc","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"k":"c","mro":["X::Proc::Async","Exception"],"a":[{"k":"v","t":"Mu","n":"$.handle"},{"n":"$.use","k":"v","t":"Mu"},{"t":"Proc::Async","k":"v","n":"$.proc"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"<p><pre><code>    class X::Proc::Async::BindOrUse does X::Proc::Async {}\n</code></pre></p><p>In general, it occurs when there's some mistake in the direction the stream flows, for instance:</p><p><pre><code>my $p = Proc::Async.new(\"ls\", :w);\nmy $h = \"ls.out\".IO.open(:w);\n$p.bind-stdin($h);\n# Fails with OUTPUT: «Cannot both bind stdin to a handle and also use :w␤»\n</code></pre></p><p>In this case, stdin is already bound and cannot be used again; one of them should flow :out and the other one :w to work correctly.</p>","b":"A","t":"X::Proc::Async::BindOrUse"},{"a":[{"k":"v","t":"Mu","n":"$.handle"},{"t":"Proc::Async","k":"v","n":"$.proc"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","k":"c","d":"<p><pre><code>class X::Proc::Async::TapBeforeSpawn is Exception {}</code></pre></p><p>If the stdout or stderr methods of Proc::Async are called after the program has been started, an exception of type X::Proc::Async::TapBeforeSpawn is thrown.</p><p><pre><code>my $proc = Proc::Async.new(\"echo\", \"foo\");\n$proc.start;\n$proc.stdout.tap(&amp;print);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::TapBeforeSpawn: To avoid data races, you must tap stdout before running the process␤»</code></pre></p><p>The right way is the reverse order</p><p><pre><code>my $proc = Proc::Async.new(\"echo\", \"foo\");\n$proc.stdout.tap(&amp;print);\nawait $proc.start;</code></pre></p>","mro":["X::Proc::Async","Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"handle","k":"m","m":0},{"n":"proc","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"t":"X::Proc::Async::TapBeforeSpawn","n":"X::Proc::Async::TapBeforeSpawn"},{"k":"c","d":"<p><pre><code>class X::Proc::Async::MustBeStarted is Exception {}</code></pre></p><p>Several methods from Proc::Async expect that the external program has been spawned (by calling .start on it), including say, write, print and close-stdin. If one of those methods is called before .start was called, they throw an exception of type X::Proc::Async::MustBeStarted.</p><p><pre><code>Proc::Async.new('echo', :w).say(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::MustBeStarted: Process must be started first before calling 'say'␤»</code></pre></p>","n":"X::Proc::Async::MustBeStarted","t":"X::Proc::Async::MustBeStarted","b":"A","a":[{"n":"$.method","t":"Mu","k":"v"},{"t":"Proc::Async","n":"$.proc","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message"},{"n":"method","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","m":0,"n":"proc","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0}],"mro":["X::Proc::Async","Exception"]},{"a":[{"n":"$.proc","k":"v","t":"Mu"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"m":0,"n":"proc","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"d":"<p><pre><code>class X::Proc::Unsuccessful is Exception {}</code></pre></p>","k":"c","mro":["Exception"],"t":"X::Proc::Unsuccessful","n":"X::Proc::Unsuccessful"},{"t":"X::OS","n":"X::OS","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"message"}],"a":[{"n":"$.os-error","k":"v","t":"Mu"}],"mro":["Exception"],"b":"C","d":"<p><pre><code>role X::OS { has $.os-error }</code></pre></p><p>Common role for all exceptions that are triggered by some error reported by the operating system (failed IO, system calls, fork, memory allocation).</p>","k":"ro"},{"b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"dispatcher"},{"m":0,"n":"ambiguous","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"capture","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"k":"c","mro":["Exception"],"t":"X::Multi::Ambiguous","a":[{"n":"$.dispatcher","k":"v","t":"Mu"},{"n":"@.ambiguous","k":"v","t":"Positional"},{"t":"Mu","n":"$.capture","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"n":"X::Multi::Ambiguous"},{"b":"A","mro":["Exception"],"a":[{"n":"$.dispatcher","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.capture"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","t":"X::Multi::NoMatch","n":"X::Multi::NoMatch","m":[{"n":"message","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"dispatcher"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"capture"},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0}]},{"d":"<p><pre><code>class X::Composition::NotComposable is Exception { }</code></pre></p><p>Thrown when trying to compose a type into a target type, but the composer type cannot be used for composition (roles and enums are generally OK).</p><p>For example</p><p><pre><code>class A { }\nclass B does A { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n␤A is not composable, so B cannot compose it\n</code></pre></p><p>because does is reserved for role composition, and A is not a role, nor something that knows how to turn into a role.</p><p>The fix is to either make A a role, or use inheritance (class B is A { }) instead.</p>","mro":["X::Comp","Exception"],"n":"X::Composition::NotComposable","b":"A","t":"X::Composition::NotComposable","k":"c","a":[{"k":"v","t":"Mu","n":"$.target-name"},{"k":"v","t":"Mu","n":"$.composer"},{"n":"$.filename","k":"v","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"t":"Mu","k":"v","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message","m":0},{"d":"<p><pre><code>method target-name(--&gt; Str:D)</code></pre></p><p>Returns the name of the type that should be composed, but failed.</p>","n":"target-name","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"composer"},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"line","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"column","k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-compile-time","m":0,"k":"m"},{"m":0,"n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"highexpect"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0,"n":"BUILDALL"}]},{"b":"C","n":"X::HyperRace::Died","k":"ro","t":"X::HyperRace::Died","mro":[],"a":[{"t":"Mu","k":"v","n":"$.start-backtrace"}]},{"b":"A","m":[{"k":"m","n":"message","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Returns the name of the symbol that was redeclared.</p>","n":"symbol","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"postfix","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","d":"<p>Returns the kind of symbol that was redeclared. Usually symbol, but can also be routine, type etc.</p>","n":"what"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"pos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"line","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m"},{"n":"is-compile-time","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","m":0,"n":"pre","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"post"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"highexpect","k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.symbol","k":"v"},{"n":"$.postfix","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.what"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","k":"v","n":"$.column"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Comp","Exception"],"k":"c","n":"X::Redeclaration","d":"<p><pre><code>class X::Redeclaration does X::Comp { }</code></pre></p><p>Thrown when a symbol (variable, routine, type, parameter, ...) is redeclared. Note that redeclarations are generally fine in an inner scope, but if the redeclaration appears in the same scope as the original declaration, it usually indicates an error and is treated as one.</p><p>Examples</p><p><pre><code>my $x; my $x;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nRedeclaration of symbol $x\n</code></pre></p><p>It works with routines too:</p><p><pre><code>sub f() { }\nsub f() { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nRedeclaration of routine f\n</code></pre></p><p>But those are fine</p><p><pre><code>my $x;\nsub f() {\n    my $x;          # not a redeclaration,\n                    # because it's in an inner scope\n    sub f() { };    # same\n}\n</code></pre></p>","t":"X::Redeclaration"},{"mro":["X::Comp","Exception"],"t":"X::Redeclaration::Outer","b":"A","a":[{"t":"Mu","n":"$.symbol","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","k":"v","n":"$.column"},{"n":"@.modules","k":"v","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","k":"v","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","n":"symbol","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"filename","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pos","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"line"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"column","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"modules","m":0,"k":"m"},{"n":"is-compile-time","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","n":"pre","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"post","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"n":"X::Redeclaration::Outer"},{"mro":["Exception"],"k":"ro","b":"C","n":"X::Encoding","t":"X::Encoding"},{"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0,"k":"m"},{"m":0,"k":"m","n":"name","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"n":"X::Encoding::Unknown","b":"A","t":"X::Encoding::Unknown","k":"c","mro":["X::Encoding","Exception"],"a":[{"n":"$.name","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.name"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["X::Encoding","Exception"],"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"message"},{"n":"name","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"n":"X::Encoding::AlreadyRegistered","t":"X::Encoding::AlreadyRegistered"},{"d":"<p><pre><code>role X::Pod { }</code></pre></p><p>Common role for Pod related errors.</p>","t":"X::Pod","n":"X::Pod","mro":[],"k":"ro","b":"C"},{"m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"from"},{"n":"endpoint","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s","m":0}],"a":[{"t":"Mu","n":"$.from","k":"v"},{"n":"$.endpoint","t":"Mu","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Sequence::Endpoint","mro":["Exception"],"n":"X::Sequence::Endpoint","b":"A","k":"c"},{"m":[{"n":"message","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"from","k":"m"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"t":"X::Sequence::Deduction","k":"c","b":"A","mro":["Exception"],"d":"<p><pre><code>class X::Sequence::Deduction is Exception { }</code></pre></p><p>Exception type thrown when the ... sequence operator is being called without an explicit closure, and the sequence cannot be deduced.</p>","n":"X::Sequence::Deduction","a":[{"n":"$.from","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}]},{"n":"X::AdHoc","k":"c","m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Numeric","d":"<p>Defined as</p><p><pre><code>method Numeric()</code></pre></p><p>Converts the payload to Numeric and returns it</p>","k":"m"},{"n":"from-slurpy","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"cap"}]},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Returns the original object which was passed to die.</p>","m":0,"n":"payload","k":"m"},{"m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"mro":["Exception"],"t":"X::AdHoc","b":"A","d":"<p><pre><code>class X::AdHoc is Exception { }\n</code></pre></p><p>X::AdHoc is the type into which objects are wrapped if they are thrown as exceptions, but don't inherit from Exception.</p><p>Its benefit over returning non-Exception objects is that it gives access to all the methods from class Exception, like backtrace and rethrow.</p><p>You can obtain the original object with the payload method.</p><p><pre><code>try {\n    die [404, 'File not found']; # throw non-exception object\n}\nprint \"Got HTTP code \",\n    $!.payload[0],          # 404\n    \" and backtrace \",\n    $!.backtrace.Str;</code></pre></p><p>Note that young code will often be prototyped using X::AdHoc and then later be revised to use more specific subtypes of Exception. As such it is usually best not to explicitly rely on receiving an X::AdHoc – in many cases using the string returned by the .message method, which all Exceptions must have, is preferable. Please note that we need to explicitly call .Str to stringify the backtrace correctly.</p>","a":[{"n":"$.payload","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}]},{"a":[{"n":"$.operation","t":"Mu","k":"v"},{"t":"Mu","n":"$.got-dimensions","k":"v"},{"k":"v","t":"Mu","n":"$.needed-dimensions"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::TooManyDimensions","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"operation"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"got-dimensions"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"needed-dimensions","k":"m","m":0},{"n":"BUILDALL","k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0}],"b":"A","mro":["Exception"],"t":"X::TooManyDimensions","k":"c"},{"m":[{"n":"message","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"target","m":0,"k":"m"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"d":"<p><pre><code>class X::Bind is Exception {}</code></pre></p><p>If you write code like this:</p><p><pre><code>floor(1.1) := 42;\n</code></pre></p><p>it dies with an X::Bind exception:</p><p><pre><code>Cannot use bind operator with this left-hand side\n</code></pre></p>","mro":["Exception"],"a":[{"k":"v","n":"$.target","t":"Mu"},{"t":"Mu","k":"v","n":"$!ex"},{"n":"$!bt","k":"v","t":"Mu"}],"k":"c","b":"A","n":"X::Bind","t":"X::Bind"},{"a":[{"n":"$.type","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"type"},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"mro":["Exception"],"t":"X::Bind::Slice","d":"<p><pre><code>class X::Bind::Slice is Exception {}</code></pre></p><p>When you try to bind to an array or hash slice:</p><p><pre><code>my @a; @a[0, 1] := [42];\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Bind::Slice: Cannot bind to Array slice␤»</code></pre></p><p>and</p><p><pre><code>my %h; %h&lt;a b&gt; := {};\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Bind::Slice: Cannot bind to Hash slice␤»</code></pre></p><p>you get an exception of type ::Bind::Slice</p>","n":"X::Bind::Slice","b":"A","k":"c"},{"t":"X::Bind::ZenSlice","m":[{"k":"m","m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"k":"c","mro":["X::Bind::Slice"],"n":"X::Bind::ZenSlice","a":[{"t":"Mu","n":"$.type","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A"},{"t":"X::Bind::NativeType","b":"A","d":"<p><pre><code>class X::Bind::NativeType does X::Comp { }</code></pre></p><p>Compile-time error thrown when trying to bind to a natively typed variable.</p><p>Since native variables explicitly don't have the concept of a container at runtime, it does not make sense to support both binding and assignment; Raku supports only assignment (which makes more sense, because native types are value types).</p><p>For example the code</p><p><pre><code>my int $x := 3;\n</code></pre></p><p>dies with</p><p><pre><code>Cannot bind to natively typed variable '$x'; use assignment instead\n</code></pre></p><p>and can be fixed by writing it as</p><p><pre><code>my int $x = 3;</code></pre></p>","a":[{"t":"Mu","n":"$.name","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.modules"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::Comp","Exception"],"k":"c","n":"X::Bind::NativeType","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","k":"m","m":0},{"m":0,"k":"m","n":"name","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"filename"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"pos"},{"m":0,"n":"line","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"modules","k":"m"},{"m":0,"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pre","k":"m"},{"n":"post","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}]},{"b":"A","mro":["Exception"],"a":[{"t":"Mu","n":"$.aggregate","k":"v"},{"t":"Mu","k":"v","n":"$.index"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"aggregate","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"index"},{"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0}],"t":"X::Item","n":"X::Item","k":"c"},{"d":"<p><pre><code>role X::Control is Exception { }</code></pre></p><p>This role turns an exception into a control exception, such as CX::Next or CX::Take. It has got no code other than the definition.</p><p>Since Rakudo 2019.03, throwing an object that mixes in this role X::Control can raise a control exception which is caught by the CONTROL phaser instead of CATCH. This allows to define custom control exceptions.</p><p>For example, the custom CX::Oops control exception we define below:</p><p><pre><code>class CX::Vaya does X::Control {\n    has $.message\n}\n\nsub ea {\n    CONTROL {\n        default {\n            say \"Controlled { .^name }: { .message }\"\n        }\n    }\n    CX::Vaya.new( message =&gt; \"I messed up!\" ).throw;\n\n}\nea;\n# OUTPUT: «Controlled CX::Vaya: I messed up!␤»\n</code></pre></p>","n":"X::Control","k":"ro","t":"X::Control","mro":["Exception"],"b":"C"},{"mro":["Exception"],"d":"<p><pre><code>class X::NYI is Exception { }</code></pre></p><p>Error class for unimplemented features. NYI stands for Not Yet Implemented.</p><p>If a Raku compiler is not yet feature complete, it may throw an X::NYI exception when a program uses a feature that it can detect and is somehow specified is not yet implemented.</p><p>A full-featured Raku compiler must not throw such exceptions, but still provide the X::NYI class for compatibility reasons.</p><p>A typical error message is</p><p><pre><code>HyperWhatever is not yet implemented. Sorry.\n</code></pre></p>","k":"c","n":"X::NYI","a":[{"t":"Mu","n":"$.feature","k":"v"},{"k":"v","t":"Mu","n":"$.did-you-mean"},{"t":"Mu","k":"v","n":"$.workaround"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::NYI","b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","k":"m","m":0},{"d":"<p>Returns a Str describing the missing feature.</p>","n":"feature","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Returns a Str indicating the optional feature that is already implemented.</p>","n":"did-you-mean","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>It helpfully shows a possible workaround for the missing feature, if it's been declared.</p>","n":"workaround","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s"}]},{"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"message"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"op","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"big","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"side","m":0,"k":"m"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"a":[{"k":"v","t":"Mu","n":"$.op"},{"n":"$.big","k":"v","t":"Mu"},{"n":"$.side","k":"v","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::NYI::BigInt","b":"A","t":"X::NYI::BigInt","mro":["Exception"],"k":"c"},{"mro":["X::NYI"],"b":"A","a":[{"t":"Positional","n":"@.available","k":"v"},{"n":"$.feature","k":"v","t":"Mu"},{"t":"Mu","n":"$.did-you-mean","k":"v"},{"t":"Mu","n":"$.workaround","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::NYI::Available","t":"X::NYI::Available","k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"available-str","m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"message","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"available"},{"k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}]},{"d":"<p><pre><code>class X::Method::InvalidQualifier is Exception { }</code></pre></p><p>Thrown when a method is call in the form $invocant.TheClass::method if &lt;$invocant&gt; does not conform to TheClass.</p><p>For example</p><p><pre><code>1.Str::split(/a/);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Method::InvalidQualifier: Cannot dispatch to method split on Str because it is not inherited or done by Int␤»</code></pre></p>","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"message","k":"m"},{"d":"<p><pre><code>method method(--&gt; Str:D)</code></pre></p><p>Returns the name of the (unqualified) method.</p>","m":0,"n":"method","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"invocant","d":"<p>Returns the invocant of the failed, qualified method call</p>","m":0},{"n":"qualifier-type","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"X::Method::InvalidQualifier","mro":["Exception"],"b":"A","t":"X::Method::InvalidQualifier","k":"c","a":[{"k":"v","t":"Mu","n":"$.method"},{"t":"Mu","n":"$.invocant","k":"v"},{"k":"v","n":"$.qualifier-type","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}]},{"t":"X::Method::NotFound","a":[{"t":"Mu","n":"$.invocant","k":"v"},{"k":"v","t":"Mu","n":"$.method"},{"t":"Mu","k":"v","n":"$.typename"},{"t":"Bool","n":"$.private","k":"v"},{"n":"$.addendum","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@!suggestions"},{"k":"v","t":"Positional","n":"@!tips"},{"t":"Mu","n":"$!message","k":"v"},{"n":"$.in-class-call","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"of-type","k":"m"},{"m":0,"n":"message","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"suggestions","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"tips","k":"m"},{"m":0,"n":"invocant","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"method","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method method(--&gt; Str:D)</code></pre></p><p>Returns the method name that was invoked.</p>","k":"m"},{"n":"typename","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"d":"<p><pre><code>method typename(--&gt; Str:D)</code></pre></p><p>Returns the name of the invocant type.</p>"},{"k":"m","n":"private","d":"<p><pre><code>method private(--&gt; Bool:D)</code></pre></p><p>Returns True for private methods, and False for public methods.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"addendum"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"in-class-call","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!create-message"}],"b":"A","n":"X::Method::NotFound","d":"<p><pre><code>class X::Method::NotFound is Exception {}</code></pre></p><p>Thrown when the user tries to call a method that isn't there.</p><p>For example</p><p><pre><code>1.no-such\n</code></pre></p><p>throws</p><p><pre><code>No such method 'no-such' for invocant of type 'Int'\n</code></pre></p>","mro":["Exception"]},{"t":"X::Method::Private::Unqualified","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"method","k":"m","m":0},{"k":"m","n":"filename","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pos","m":0},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"column","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"modules","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"is-compile-time","k":"m"},{"m":0,"n":"pre","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"b":"A","n":"X::Method::Private::Unqualified","d":"<p><pre><code>class X::Method::Private::Unqualified does X::Comp { }</code></pre></p><p>Compile time error thrown when a private method call on anything but self is not fully qualified.</p><p>For example</p><p><pre><code>1!priv\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPrivate method call to priv must be fully qualified with the package containing the method\n</code></pre></p>","a":[{"n":"$.method","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","k":"v","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c"},{"d":"<p><pre><code>class X::Method::Private::Permission does X::Comp { }</code></pre></p><p>Compile time error thrown when the code contains a call to a private method that isn't defined in the current class, and when no appropriate trusts relation is defined that permits the private method call.</p><p>For example</p><p><pre><code>1!Int::foo\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot call private method 'foo' on package Int because it does not trust GLOBAL\n</code></pre></p>","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"d":"<p><pre><code>method method(--&gt; Str:D)</code></pre></p><p>The name of the private method</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"method"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"source-package","d":"<p><pre><code>method source-package(--&gt; Mu:D)</code></pre></p><p>Returns the type object that (supposedly) contains the private method.</p>","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"calling-package","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pos","m":0},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"column","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"modules","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"is-compile-time","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"n":"pre","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"post","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"highexpect","k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s"}],"mro":["X::Comp","Exception"],"t":"X::Method::Private::Permission","n":"X::Method::Private::Permission","a":[{"n":"$.method","t":"Mu","k":"v"},{"k":"v","n":"$.source-package","t":"Mu"},{"k":"v","t":"Mu","n":"$.calling-package"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","k":"v","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A","k":"c"},{"m":[{"k":"m","m":0,"n":"message","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p><pre><code>method what(--&gt; Str:D)</code></pre></p><p>Verbal description of the thing that was out of range (e.g. \"array index\", \"month\").</p>","m":0,"n":"what","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method got()</code></pre></p><p>Returns the object that was considered out of range (often an integer)</p>","m":0,"n":"got"},{"d":"<p><pre><code>method range(--&gt; Range:D)</code></pre></p><p>Returns a Range object describing the permissible range for the object returned from .got.</p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"range","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"comment"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","n":"BUILDALL","m":0}],"b":"A","t":"X::OutOfRange","k":"c","a":[{"k":"v","t":"Mu","n":"$.what"},{"n":"$.got","t":"Mu","k":"v"},{"t":"Mu","n":"$.range","k":"v"},{"t":"Mu","k":"v","n":"$.comment"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"n":"X::OutOfRange","d":"<p><pre><code>class X::OutOfRange is Exception { }</code></pre></p><p>General error when something (for example an array index) is out of an allowed range.</p><p>For example</p><p><pre><code>say 42[2];\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::OutOfRange: Index out of range. Is: 2, should be in 0..0␤»</code></pre></p><p>since scalars generally act as a one-element list.</p>","mro":["Exception"]},{"t":"X::MOP","n":"X::MOP","b":"C","mro":["Exception"],"k":"ro"},{"k":"c","mro":["X::Comp","Exception"],"b":"A","n":"X::Value::Dynamic","a":[{"n":"$.what","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"m":[{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","m":0},{"n":"what","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"filename"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"pos"},{"m":0,"n":"line","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"column","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"n":"modules","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"post","k":"m"},{"k":"m","m":0,"n":"highexpect","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s","n":"BUILDALL"}],"t":"X::Value::Dynamic"},{"m":[{"m":0,"n":"message","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"type","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"d":"<p><pre><code>class X::Constructor::Positional is Exception { }</code></pre></p><p>Thrown from Mu.new when positional arguments are passed to it.</p><p>For example</p><p><pre><code>class A { };\nA.new(2, 3);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Constructor::Positional: Default constructor for 'A' only takes named arguments␤»</code></pre></p>","b":"A","k":"c","mro":["Exception"],"n":"X::Constructor::Positional","t":"X::Constructor::Positional","a":[{"k":"v","t":"Mu","n":"$.type"},{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}]},{"t":"Sub","k":"v","n":"&circumfix:<:{ }>"},{"s":{"r":"Mu","p":[{"n":"*@e","t":"Positional"}]},"m":0,"n":"circumfix:<:{ }>","k":"s"},{"k":"e","n":"SIGXFSZ","t":"Signal"},{"t":"ProtocolType","n":"PROTO_UDP","k":"e"},{"d":"<p><pre><code>multi sub prefix:&lt;+&gt;(Any --&gt; Numeric:D)</code></pre></p><p>Numeric context operator.</p><p>Coerces the argument to Numeric by calling the Numeric method on it.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<+>","k":"v"},{"s":{"p":[{"t":"Any","n":"a"}],"r":"Mu"},"m":1,"k":"s","n":"prefix:<+>"},{"d":"<p><pre><code>multi sub prefix:&lt;-&gt;(Any --&gt; Numeric:D)</code></pre></p><p>Negative numeric context operator.</p><p>Coerces the argument to Numeric by calling the Numeric method on it, and then negates the result.</p>","k":"v","n":"&prefix:<->","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"s":{"p":[{"t":"Any","n":"a"}],"r":"Mu"},"n":"prefix:<->","k":"s"},{"k":"s","m":1,"n":"prefix:<->","s":{"p":[{"t":"Real","n":"a"}],"r":"Mu"}},{"n":"prefix:<->","m":1,"s":{"p":[{"n":"a","t":"Int"}],"r":"Int:D"},"k":"s"},{"s":{"r":"int","p":[{"n":"$a","t":"int"}]},"n":"prefix:<->","m":1,"k":"s"},{"s":{"r":"Mu","p":[{"n":"a","t":"Num"}]},"n":"prefix:<->","m":1,"k":"s"},{"k":"s","m":1,"n":"prefix:<->","s":{"p":[{"n":"$a","t":"num"}],"r":"num"}},{"n":"prefix:<->","s":{"r":"Rat:D","p":[{"t":"Rat","n":"a"}]},"m":1,"k":"s"},{"n":"prefix:<->","m":1,"k":"s","s":{"p":[{"t":"FatRat","n":"a"}],"r":"FatRat:D"}},{"k":"s","m":1,"n":"prefix:<->","s":{"p":[{"t":"Complex","n":"a"}],"r":"Complex:D"}},{"m":1,"n":"prefix:<->","s":{"p":[{"t":"Duration","n":"$a"}],"r":"Duration:D"},"k":"s"},{"k":"v","t":"Sub+{is-pure}","n":"&tan"},{"n":"tan","k":"s","m":1,"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]},"m":1,"k":"s","n":"tan"},{"s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"n":"tan","k":"s","m":1},{"n":"&chomp","t":"Sub","k":"v"},{"k":"s","m":1,"n":"chomp","s":{"p":[{"n":"$s","t":"Cool"}],"r":"Str:D"}},{"t":"Sub","n":"&duckmap","k":"v"},{"m":1,"k":"s","n":"duckmap","s":{"r":"Mu","p":[{"n":"op","t":"Any"},{"n":"obj","t":"Any"}]}},{"m":1,"n":"duckmap","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"op"},{"n":"h","t":"Associative"}]}},{"t":"Sub","n":"&await","k":"v"},{"n":"await","k":"s","m":1,"s":{"r":"Mu","p":[]}},{"s":{"p":[{"t":"Any","n":"$x"}],"r":"Mu"},"n":"await","k":"s","m":1},{"k":"s","n":"await","s":{"r":"Mu","p":[{"t":"Any","n":"$x"}]},"m":1},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"$p","t":"Promise"}]},"n":"await"},{"k":"s","m":1,"n":"await","s":{"p":[{"n":"$c","t":"Channel"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Supply","n":"$s"}],"r":"Mu"},"n":"await","k":"s"},{"n":"await","s":{"p":[{"n":"$i","t":"Iterable"}],"r":"Mu"},"k":"s","m":1},{"m":1,"s":{"p":[{"n":"*@awaitables","t":"Positional"}],"r":"Mu"},"n":"await","k":"s"},{"k":"v","t":"Sub","n":"&make"},{"n":"make","k":"s","m":0,"s":{"p":[{"t":"Mu","n":"made"}],"r":"Mu"}},{"k":"e","t":"Signal","n":"Signal"},{"n":"Signal::SIGBUS","k":"e","t":"Signal"},{"n":"Signal::SIGSYS","t":"Signal","k":"e"},{"t":"Signal","n":"Signal::SIGSTOP","k":"e"},{"k":"e","n":"Signal::SIGSTKFLT","t":"Signal"},{"t":"Signal","k":"e","n":"Signal::SIGPROF"},{"t":"Signal","k":"e","n":"Signal::SIGHUP"},{"k":"e","t":"Signal","n":"Signal::SIGILL"},{"n":"Signal::SIGURG","k":"e","t":"Signal"},{"n":"Signal::SIGALRM","k":"e","t":"Signal"},{"k":"e","n":"Signal::SIGTSTP","t":"Signal"},{"k":"e","t":"Signal","n":"Signal::SIGTTIN"},{"k":"e","n":"Signal::SIGCHLD","t":"Signal"},{"t":"Signal","n":"Signal::SIGABRT","k":"e"},{"t":"Signal","n":"Signal::SIGIO","k":"e"},{"k":"e","n":"Signal::SIGPIPE","t":"Signal"},{"k":"e","n":"Signal::SIGINT","t":"Signal"},{"t":"Signal","k":"e","n":"Signal::SIGQUIT"},{"k":"e","n":"Signal::SIGEMT","t":"Signal"},{"t":"Signal","n":"Signal::SIGXCPU","k":"e"},{"n":"Signal::SIGXFSZ","k":"e","t":"Signal"},{"k":"e","t":"Signal","n":"Signal::SIGTERM"},{"k":"e","n":"Signal::SIGBREAK","t":"Signal"},{"n":"Signal::SIGTHR","t":"Signal","k":"e"},{"n":"Signal::SIGVTALRM","k":"e","t":"Signal"},{"t":"Signal","n":"Signal::SIGUSR1","k":"e"},{"t":"Signal","k":"e","n":"Signal::SIGKILL"},{"n":"Signal::SIGTTOU","k":"e","t":"Signal"},{"n":"Signal::SIGCONT","k":"e","t":"Signal"},{"n":"Signal::SIGSEGV","t":"Signal","k":"e"},{"t":"Signal","k":"e","n":"Signal::SIGWINCH"},{"t":"Signal","k":"e","n":"Signal::SIGTRAP"},{"k":"e","t":"Signal","n":"Signal::SIGFPE"},{"t":"Signal","n":"Signal::SIGINFO","k":"e"},{"n":"Signal::SIGPWR","t":"Signal","k":"e"},{"n":"Signal::SIGUSR2","t":"Signal","k":"e"},{"k":"v","n":"&infix:<+&>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":[]},"k":"s","n":"infix:<+&>","m":1},{"m":1,"s":{"p":[{"t":"Any","n":"$x"}],"r":"Mu"},"n":"infix:<+&>","k":"s"},{"n":"infix:<+&>","k":"s","s":{"p":[{"n":"$x","t":"Any"},{"n":"$y","t":"Any"}],"r":"Mu"},"m":1},{"m":1,"s":{"r":"Int:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"n":"infix:<+&>","k":"s"},{"m":1,"k":"s","s":{"r":"int","p":[{"n":"$a","t":"int"},{"t":"int","n":"$b"}]},"n":"infix:<+&>"},{"n":"&cas","t":"Sub","k":"v"},{"n":"cas","m":1,"k":"s","s":{"p":[{"n":"$target","t":"Any"},{"n":"expected","t":"Any"},{"t":"Any","n":"value"}],"r":"Mu"}},{"k":"s","n":"cas","s":{"r":"Mu","p":[{"t":"Any","n":"$target"},{"t":"Callable","n":"&code"}]},"m":1},{"k":"s","m":1,"s":{"p":[{"t":"atomicint","n":"$target"},{"t":"int","n":"$expected"},{"n":"$value","t":"int"}],"r":"Mu"},"n":"cas"},{"s":{"r":"Mu","p":[{"n":"$target","t":"atomicint"},{"t":"Int","n":"$expected"},{"t":"Int","n":"$value"}]},"k":"s","n":"cas","m":1},{"s":{"p":[{"n":"$target","t":"atomicint"},{"n":"$expected","t":"Any"},{"t":"Any","n":"$value"}],"r":"Mu"},"k":"s","m":1,"n":"cas"},{"m":1,"k":"s","n":"cas","s":{"r":"Mu","p":[{"n":"$target","t":"atomicint"},{"n":"&code","t":"Callable"}]}},{"k":"v","t":"Sub+{is-pure}","n":"&infix:<∋>"},{"m":1,"k":"s","n":"infix:<∋>","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]}},{"d":"<p><pre><code>multi sub infix:&lt;⊄&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Not a subset of operator.</p><p>Returns True if $a is not a strict subset of $b. Equivalent to !(&lt;).</p><p><pre><code>say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»\nsay (2,3) ⊄ (2,3,1); # OUTPUT: «False␤»\nsay 4 !(&lt;) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊄ is codepoint U+2284 (NOT A SUBSET OF).</p>","k":"v","n":"&infix:<⊄>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<⊄>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]}},{"d":"<p><pre><code>class Cool is Any { }</code></pre></p><p>Cool, also known as the Convenient OO Loop, is a base class employed by a number of built-in classes whose instances can be meaningfully coerced to a string and a number. For example, an Array can be used in mathematical operations, where its numerical representation is the number of elements it contains. At the same time, it can be concatenated to a string, where its stringy representation is all of its elements joined by a space. Because Array is Cool, the appropriate coercion happens automatically.</p><p>Methods in Cool coerce the invocant to a more specific type, and then call the same method on that type. For example both Int and Str inherit from Cool, and calling method substr on an Int converts the integer to Str first.</p><p><pre><code>123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)</code></pre></p><p>The following built-in types inherit from Cool: Array Bool Complex Cool Duration Map FatRat Hash Instant Int List Match Nil Num Range Seq Stash Str.</p><p>The following table summarizes the methods that Cool provides, and what type they coerce to:</p><table class='sections'><tr><th>method</th><th>coercion type</th></tr>\n<tr><td>abs</tr><td>Numeric</tr></tr>\n<tr><td>conj</tr><td>Numeric</tr></tr>\n<tr><td>sqrt</tr><td>Numeric</tr></tr>\n<tr><td>sign</tr><td>Real</tr></tr>\n<tr><td>rand</tr><td>Numeric</tr></tr>\n<tr><td>sin</tr><td>Numeric</tr></tr>\n<tr><td>asin</tr><td>Numeric</tr></tr>\n<tr><td>cos</tr><td>Numeric</tr></tr>\n<tr><td>acos</tr><td>Numeric</tr></tr>\n<tr><td>tan</tr><td>Numeric</tr></tr>\n<tr><td>tanh</tr><td>Numeric</tr></tr>\n<tr><td>atan</tr><td>Numeric</tr></tr>\n<tr><td>atan2</tr><td>Numeric</tr></tr>\n<tr><td>atanh</tr><td>Numeric</tr></tr>\n<tr><td>sec</tr><td>Numeric</tr></tr>\n<tr><td>asec</tr><td>Numeric</tr></tr>\n<tr><td>cosec</tr><td>Numeric</tr></tr>\n<tr><td>acosec</tr><td>Numeric</tr></tr>\n<tr><td>cotan</tr><td>Numeric</tr></tr>\n<tr><td>cotanh</tr><td>Numeric</tr></tr>\n<tr><td>acotan</tr><td>Numeric</tr></tr>\n<tr><td>sinh</tr><td>Numeric</tr></tr>\n<tr><td>asinh</tr><td>Numeric</tr></tr>\n<tr><td>cosh</tr><td>Numeric</tr></tr>\n<tr><td>acosh</tr><td>Numeric</tr></tr>\n<tr><td>sech</tr><td>Numeric</tr></tr>\n<tr><td>asech</tr><td>Numeric</tr></tr>\n<tr><td>cosech</tr><td>Numeric</tr></tr>\n<tr><td>acosech</tr><td>Numeric</tr></tr>\n<tr><td>acotanh</tr><td>Numeric</tr></tr>\n<tr><td>cis</tr><td>Numeric</tr></tr>\n<tr><td>log</tr><td>Numeric</tr></tr>\n<tr><td>exp</tr><td>Numeric</tr></tr>\n<tr><td>roots</tr><td>Numeric</tr></tr>\n<tr><td>log10</tr><td>Numeric</tr></tr>\n<tr><td>unpolar</tr><td>Numeric</tr></tr>\n<tr><td>round</tr><td>Numeric</tr></tr>\n<tr><td>floor</tr><td>Numeric</tr></tr>\n<tr><td>ceiling</tr><td>Numeric</tr></tr>\n<tr><td>truncate</tr><td>Numeric</tr></tr>\n<tr><td>chr</tr><td>Int</tr></tr>\n<tr><td>ord</tr><td>Str</tr></tr>\n<tr><td>chars</tr><td>Str</tr></tr>\n<tr><td>fmt</tr><td>Str</tr></tr>\n<tr><td>uniname</tr><td>Str</tr></tr>\n<tr><td>uninames</tr><td>Seq</tr></tr>\n<tr><td>unival</tr><td>Str</tr></tr>\n<tr><td>univals</tr><td>Str</tr></tr>\n<tr><td>uniprop</tr><td>Str</tr></tr>\n<tr><td>unimatch</tr><td>Str</tr></tr>\n<tr><td>uc</tr><td>Str</tr></tr>\n<tr><td>lc</tr><td>Str</tr></tr>\n<tr><td>fc</tr><td>Str</tr></tr>\n<tr><td>tc</tr><td>Str</tr></tr>\n<tr><td>tclc</tr><td>Str</tr></tr>\n<tr><td>flip</tr><td>Str</tr></tr>\n<tr><td>trans</tr><td>Str</tr></tr>\n<tr><td>contains</tr><td>Str</tr></tr>\n<tr><td>index</tr><td>Str</tr></tr>\n<tr><td>rindex</tr><td>Str</tr></tr>\n<tr><td>ords</tr><td>Str</tr></tr>\n<tr><td>split</tr><td>Str</tr></tr>\n<tr><td>match</tr><td>Str</tr></tr>\n<tr><td>comb</tr><td>Str</tr></tr>\n<tr><td>subst</tr><td>Str</tr></tr>\n<tr><td>sprintf</tr><td>Str</tr></tr>\n<tr><td>printf</tr><td>Str</tr></tr>\n<tr><td>samecase</tr><td>Str</tr></tr>\n<tr><td>trim</tr><td>Str</tr></tr>\n<tr><td>trim-leading</tr><td>Str</tr></tr>\n<tr><td>trim-trailing</tr><td>Str</tr></tr>\n<tr><td>EVAL</tr><td>Str</tr></tr>\n<tr><td>chomp</tr><td>Str</tr></tr>\n<tr><td>chop</tr><td>Str</tr></tr>\n<tr><td>codes</tr><td>Str</tr></tr>\n</table>","mro":["Any"],"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub abs(Numeric() $x)\nmethod abs()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric and returns the absolute value (that is, a non-negative number).</p><p><pre><code>say (-2).abs;       # OUTPUT: «2␤»\nsay abs \"6+8i\";     # OUTPUT: «10␤»</code></pre></p>","m":0,"n":"abs","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"conj","d":"<p>Defined as:</p><p><pre><code>method conj()</code></pre></p><p>Coerces the invocant to Numeric and returns the complex conjugate (that is, the number with the sign of the imaginary part negated).</p><p><pre><code>say (1+2i).conj;        # OUTPUT: «1-2i␤»</code></pre></p>","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"sqrt","d":"<p>Defined as:</p><p><pre><code>sub sqrt(Numeric(Cool) $x)\nmethod sqrt()</code></pre></p><p>Coerces the invocant to Numeric (or in the sub form, the argument) and returns the square root, that is, a non-negative number that, when multiplied with itself, produces the original number.</p><p><pre><code>say 4.sqrt;             # OUTPUT: «2␤»\nsay sqrt(2);            # OUTPUT: «1.4142135623731␤»</code></pre></p>","k":"m"},{"m":0,"k":"m","n":"sign","d":"<p>Defined as:</p><p><pre><code>method sign()</code></pre></p><p>Coerces the invocant to Numeric and returns its sign, that is, 0 if the number is 0, 1 for positive and -1 for negative values.</p><p><pre><code>say 6.sign;             # OUTPUT: «1␤»\nsay (-6).sign;          # OUTPUT: «-1␤»\nsay \"0\".sign;           # OUTPUT: «0␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"rand","d":"<p>Defined as:</p><p><pre><code>method rand()</code></pre></p><p>Coerces the invocant to Num and returns a pseudo-random value between zero and the number.</p><p><pre><code>say 1e5.rand;           # OUTPUT: «33128.495184283␤»</code></pre></p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>sub sin(Numeric(Cool))\nmethod sin()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric, interprets it as radians, returns its sine.</p><p><pre><code>say sin(0);             # OUTPUT: «0␤»\nsay sin(pi/4);          # OUTPUT: «0.707106781186547␤»\nsay sin(pi/2);          # OUTPUT: «1␤»</code></pre></p><p>Note that Raku is no computer algebra system, so sin(pi) typically does not produce an exact 0, but rather a very small floating-point number.</p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"sin"},{"d":"<p>Defined as:</p><p><pre><code>sub asin(Numeric(Cool))\nmethod asin()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric, and returns its arc-sine in radians.</p><p><pre><code>say 0.1.asin;               # OUTPUT: «0.10016742116156␤»\nsay asin(0.1);              # OUTPUT: «0.10016742116156␤»</code></pre></p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"asin"},{"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>sub cos(Numeric(Cool))\nmethod cos()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, interprets it as radians, returns its cosine.</p><p><pre><code>say 0.cos;                  # OUTPUT: «1␤»\nsay pi.cos;                 # OUTPUT: «-1␤»\nsay cos(pi/2);              # OUTPUT: «6.12323399573677e-17␤»</code></pre></p>","n":"cos","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"acos","d":"<p>Defined as:</p><p><pre><code>sub acos(Numeric(Cool))\nmethod acos()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, and returns its arc-cosine in radians.</p><p><pre><code>say 1.acos;                 # OUTPUT: «0␤»\nsay acos(-1);               # OUTPUT: «3.14159265358979␤»</code></pre></p>"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>sub tan(Numeric(Cool))\nmethod tan()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, interprets it as radians, returns its tangent.</p><p><pre><code>say tan(3);                 # OUTPUT: «-0.142546543074278␤»\nsay 3.tan;                  # OUTPUT: «-0.142546543074278␤»</code></pre></p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"tan"},{"n":"atan","d":"<p>Defined as:</p><p><pre><code>sub atan(Numeric(Cool))\nmethod atan()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, and returns its arc-tangent in radians.</p><p><pre><code>say atan(3);                # OUTPUT: «1.24904577239825␤»\nsay 3.atan;                 # OUTPUT: «1.24904577239825␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"m":0,"s":{"p":[{"n":"$y?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method atan2($y = 1e0)</code></pre></p><p>Coerces self and argument to Numeric, using them to compute the two-argument arc-tangent in radians.</p><p><pre><code>say 3.atan2;                # OUTPUT: «1.24904577239825␤»\nsay ⅔.atan2(⅓);             # OUTPUT: «1.1071487177940904␤»</code></pre></p><p>The first argument defaults to 1, so in the first case the function will return the angle θ in radians between a vector that goes from origin to the point (3, 1) and the x axis.</p>","k":"m","n":"atan2"},{"n":"sec","m":0,"d":"<p>Defined as:</p><p><pre><code>sub sec(Numeric(Cool))\nmethod sec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its secant, that is, the reciprocal of its cosine.</p><p><pre><code>say 45.sec;                 # OUTPUT: «1.90359440740442␤»\nsay sec(45);                # OUTPUT: «1.90359440740442␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"asec","d":"<p>Defined as:</p><p><pre><code>sub asec(Numeric(Cool))\nmethod asec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-secant in radians.</p><p><pre><code>say 1.asec;                 # OUTPUT: «0␤»\nsay sqrt(2).asec;           # OUTPUT: «0.785398163397448␤»</code></pre></p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>sub cosec(Numeric(Cool))\nmethod cosec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its cosecant, that is, the reciprocal of its sine.</p><p><pre><code>say 0.45.cosec;             # OUTPUT: «2.29903273150897␤»\nsay cosec(0.45);            # OUTPUT: «2.29903273150897␤»</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"cosec","k":"m","m":0},{"n":"acosec","d":"<p>Defined as:</p><p><pre><code>sub acosec(Numeric(Cool))\nmethod acosec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-cosecant in radians.</p><p><pre><code>say 45.acosec;              # OUTPUT: «0.0222240516182672␤»\nsay acosec(45)              # OUTPUT: «0.0222240516182672␤»</code></pre></p>","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"d":"<p>Defined as:</p><p><pre><code>sub cotan(Numeric(Cool))\nmethod cotan()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its cotangent, that is, the reciprocal of its tangent.</p><p><pre><code>say 45.cotan;               # OUTPUT: «0.617369623783555␤»\nsay cotan(45);              # OUTPUT: «0.617369623783555␤»</code></pre></p>","k":"m","n":"cotan"},{"m":0,"n":"acotan","d":"<p>Defined as:</p><p><pre><code>sub acotan(Numeric(Cool))\nmethod acotan()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-cotangent in radians.</p><p><pre><code>say 45.acotan;              # OUTPUT: «0.0222185653267191␤»\nsay acotan(45)              # OUTPUT: «0.0222185653267191␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>sub sinh(Numeric(Cool))\nmethod sinh()</code></pre></p><p>Coerces the invocant (or in method form, its argument) to Numeric, and returns its Sine hyperbolicus.</p><p><pre><code>say 1.sinh;                 # OUTPUT: «1.1752011936438␤»\nsay sinh(1);                # OUTPUT: «1.1752011936438␤»</code></pre></p>","n":"sinh","k":"m","m":0},{"n":"asinh","d":"<p>Defined as:</p><p><pre><code>sub asinh(Numeric(Cool))\nmethod asinh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse Sine hyperbolicus.</p><p><pre><code>say 1.asinh;                # OUTPUT: «0.881373587019543␤»\nsay asinh(1);               # OUTPUT: «0.881373587019543␤»</code></pre></p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"cosh","k":"m","d":"<p>Defined as:</p><p><pre><code>sub cosh(Numeric(Cool))\nmethod cosh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Cosine hyperbolicus.</p><p><pre><code>say cosh(0.5);              # OUTPUT: «1.12762596520638␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>sub acosh(Numeric(Cool))\nmethod acosh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse Cosine hyperbolicus.</p><p><pre><code>say acosh(45);              # OUTPUT: «4.4996861906715␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"acosh"},{"d":"<p>Defined as:</p><p><pre><code>sub tanh(Numeric(Cool))\nmethod tanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians and returns its Tangent hyperbolicus.</p><p><pre><code>say tanh(0.5);              # OUTPUT: «0.46211715726001␤»\nsay tanh(atanh(0.5));       # OUTPUT: «0.5␤»</code></pre></p>","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"tanh"},{"n":"atanh","m":0,"d":"<p>Defined as:</p><p><pre><code>sub atanh(Numeric(Cool))\nmethod atanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse tangent hyperbolicus.</p><p><pre><code>say atanh(0.5);             # OUTPUT: «0.549306144334055␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"sech","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>sub sech(Numeric(Cool))\nmethod sech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Secant hyperbolicus.</p><p><pre><code>say 0.sech;                 # OUTPUT: «1␤»</code></pre></p>"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub asech(Numeric(Cool))\nmethod asech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic secant.</p><p><pre><code>say 0.8.asech;              # OUTPUT: «0.693147180559945␤»</code></pre></p>","m":0,"n":"asech","k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>sub cosech(Numeric(Cool))\nmethod cosech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Hyperbolic cosecant.</p><p><pre><code>say cosech(pi/2);           # OUTPUT: «0.434537208094696␤»</code></pre></p>","m":0,"n":"cosech","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>sub acosech(Numeric(Cool))\nmethod acosech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic cosecant.</p><p><pre><code>say acosech(4.5);           # OUTPUT: «0.220432720979802␤»</code></pre></p>","m":0,"n":"acosech","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","n":"cotanh","d":"<p>Defined as:</p><p><pre><code>sub cotanh(Numeric(Cool))\nmethod cotanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Hyperbolic cotangent.</p><p><pre><code>say cotanh(pi);             # OUTPUT: «1.00374187319732␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"acotanh","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>sub acotanh(Numeric(Cool))\nmethod acotanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic cotangent.</p><p><pre><code>say acotanh(2.5);           # OUTPUT: «0.423648930193602␤»</code></pre></p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>sub cis(Numeric(Cool))\nmethod cis()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns cos(argument) + i*sin(argument).</p><p><pre><code>say cis(pi/4);              # OUTPUT: «0.707106781186548+0.707106781186547i␤»</code></pre></p>","n":"cis","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Bool:D","p":[{"t":"Mu","n":"*%_"}]},"n":"is-prime","m":0,"k":"m"},{"m":1,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)\nmulti method log(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method form) to Numeric, and returns its Logarithm to base $base, or to base e (Euler's Number) if no base was supplied (Natural logarithm). Returns NaN if $base is negative. Throws an exception if $base is 1.</p><p><pre><code>say (e*e).log;              # OUTPUT: «2␤»</code></pre></p>","n":"log"},{"k":"m","n":"log","d":"<p>Defined as:</p><p><pre><code>multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)\nmulti method log(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method form) to Numeric, and returns its Logarithm to base $base, or to base e (Euler's Number) if no base was supplied (Natural logarithm). Returns NaN if $base is negative. Throws an exception if $base is 1.</p><p><pre><code>say (e*e).log;              # OUTPUT: «2␤»</code></pre></p>","m":1,"s":{"p":[{"t":"Any","n":"$base"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi sub exp(Cool:D $pow, Cool:D $base?)\nmulti method exp(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method from) to Numeric, and returns $base raised to the power of the first number. If no $base is supplied, e (Euler's Number) is used.</p><p><pre><code>say 0.exp;      # OUTPUT: «1␤»\nsay 1.exp;      # OUTPUT: «2.71828182845905␤»\nsay 10.exp;     # OUTPUT: «22026.4657948067␤»</code></pre></p>","n":"exp"},{"m":1,"s":{"p":[{"t":"Any","n":"$base"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub exp(Cool:D $pow, Cool:D $base?)\nmulti method exp(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method from) to Numeric, and returns $base raised to the power of the first number. If no $base is supplied, e (Euler's Number) is used.</p><p><pre><code>say 0.exp;      # OUTPUT: «1␤»\nsay 1.exp;      # OUTPUT: «2.71828182845905␤»\nsay 10.exp;     # OUTPUT: «22026.4657948067␤»</code></pre></p>","n":"exp"},{"m":1,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"round","d":"<p>Defined as:</p><p><pre><code>multi sub round(Numeric(Cool))\nmulti method round(Cool:D: $unit = 1)</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it to the unit of $unit. If $unit is 1, rounds to the nearest integer.</p><p><pre><code>say 1.7.round;          # OUTPUT: «2␤»\nsay 1.07.round(0.1);    # OUTPUT: «1.1␤»\nsay 21.round(10);       # OUTPUT: «20␤»</code></pre></p><p>Always rounds up if the number is at mid-point:</p><p><pre><code>say (−.5 ).round;       # OUTPUT: «0␤»\nsay ( .5 ).round;       # OUTPUT: «1␤»\nsay (−.55).round(.1);   # OUTPUT: «-0.5␤»\nsay ( .55).round(.1);   # OUTPUT: «0.6␤»</code></pre></p><p>Pay attention to types when using this method, as ending up with the wrong type may affect the precision you seek to achieve. For Real types, the type of the result is the type of the argument (Complex argument gets coerced to Real, ending up a Num). If rounding a Complex, the result is Complex as well, regardless of the type of the argument.</p><p><pre><code>9930972392403501.round(1)      .perl.say; # OUTPUT: «9930972392403501␤»\n9930972392403501.round(1e0)    .perl.say; # OUTPUT: «9.9309723924035e+15␤»\n9930972392403501.round(1e0).Int.perl.say; # OUTPUT: «9930972392403500␤»</code></pre></p>"},{"k":"m","n":"round","d":"<p>Defined as:</p><p><pre><code>multi sub round(Numeric(Cool))\nmulti method round(Cool:D: $unit = 1)</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it to the unit of $unit. If $unit is 1, rounds to the nearest integer.</p><p><pre><code>say 1.7.round;          # OUTPUT: «2␤»\nsay 1.07.round(0.1);    # OUTPUT: «1.1␤»\nsay 21.round(10);       # OUTPUT: «20␤»</code></pre></p><p>Always rounds up if the number is at mid-point:</p><p><pre><code>say (−.5 ).round;       # OUTPUT: «0␤»\nsay ( .5 ).round;       # OUTPUT: «1␤»\nsay (−.55).round(.1);   # OUTPUT: «-0.5␤»\nsay ( .55).round(.1);   # OUTPUT: «0.6␤»</code></pre></p><p>Pay attention to types when using this method, as ending up with the wrong type may affect the precision you seek to achieve. For Real types, the type of the result is the type of the argument (Complex argument gets coerced to Real, ending up a Num). If rounding a Complex, the result is Complex as well, regardless of the type of the argument.</p><p><pre><code>9930972392403501.round(1)      .perl.say; # OUTPUT: «9930972392403501␤»\n9930972392403501.round(1e0)    .perl.say; # OUTPUT: «9.9309723924035e+15␤»\n9930972392403501.round(1e0).Int.perl.say; # OUTPUT: «9930972392403500␤»</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"n":"$base","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"n":"roots","k":"m","m":0,"s":{"p":[{"t":"Cool","n":"$n"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi sub roots(Numeric(Cool) $x, Int(Cool) $n)\nmulti method roots(Int(Cool) $n)</code></pre></p><p>Coerces the first argument (and in method form, the invocant) to Numeric and the second ($n) to Int, and produces a list of $n Complex $n-roots, which means numbers that, raised to the $nth power, approximately produce the original number.</p><p>For example</p><p><pre><code>my $original = 16;\nmy @roots = $original.roots(4);\nsay @roots;\n\nfor @roots -&gt; $r {\n    say abs($r ** 4 - $original);\n}\n\n# OUTPUT:«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2i␤»\n# OUTPUT:«1.77635683940025e-15␤»\n# OUTPUT:«4.30267170434156e-15␤»\n# OUTPUT:«8.03651692704705e-15␤»\n# OUTPUT:«1.04441561648202e-14␤»\n</code></pre></p>"},{"k":"m","n":"log2","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"log10","d":"<p>Defined as:</p><p><pre><code>multi sub log10(Cool(Numeric))\nmulti method log10()</code></pre></p><p>Coerces the invocant (or in the sub form, the invocant) to Numeric, and returns its Logarithm to base 10, that is, a number that approximately produces the original number when raised to the power of 10. Returns NaN for negative arguments and -Inf for 0.</p><p><pre><code>say log10(1001);            # OUTPUT: «3.00043407747932␤»</code></pre></p>","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"$n","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"unpolar","d":"<p>Defined as:</p><p><pre><code>method unpolar(Numeric(Cool))</code></pre></p><p>Coerces the arguments (including the invocant in the method form) to Numeric, and returns a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.</p><p><pre><code>say sqrt(2).unpolar(pi/4);      # OUTPUT: «1+1i␤»</code></pre></p>","m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi sub floor(Numeric(Cool))\nmulti method floor</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it downwards to the nearest integer.</p><p><pre><code>say \"1.99\".floor;       # OUTPUT: «1␤»\nsay \"-1.9\".floor;       # OUTPUT: «-2␤»\nsay 0.floor;            # OUTPUT: «0␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"floor","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub ceiling(Numeric(Cool))\nmulti method ceiling</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it upwards to the nearest integer.</p><p><pre><code>say \"1\".ceiling;        # OUTPUT: «1␤»\nsay \"-0.9\".ceiling;     # OUTPUT: «0␤»\nsay \"42.1\".ceiling;     # OUTPUT: «43␤»</code></pre></p>","n":"ceiling"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"truncate","d":"<p>Defined as:</p><p><pre><code>multi sub truncate(Numeric(Cool))\nmulti method truncate()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it towards zero.</p><p><pre><code>say 1.2.truncate;       # OUTPUT: «1␤»\nsay truncate -1.2;      # OUTPUT: «-1␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi sub chars(Cool $x)\nmulti sub chars(Str:D $x)\nmulti sub chars(str $x --&gt; int)\nmethod chars(--&gt; Int:D)</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the number of characters in the string. Please note that on the JVM, you currently get codepoints instead of graphemes.</p><p><pre><code>say 'møp'.chars;    # OUTPUT: «3␤»\nsay 'ã̷̠̬̊'.chars;     # OUTPUT: «1␤»\nsay '\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF'.chars;    # OUTPUT: «1␤»</code></pre></p><p>If the string is native, the number of chars will be also returned as a native int.</p><p></p><p>Graphemes are user visible characters. That is, this is what the user thinks of as a “character”.</p><p>Graphemes can contain more than one codepoint. Typically the number of graphemes and codepoints differs when Prepend or Extend characters are involved (also known as Combining characters), but there are many other cases when this may happen. Another example is \\c[ZWJ] (Zero-width joiner).</p><p>You can check Grapheme_Cluster_Break property of a character in order to see how it is going to behave:</p><p><pre><code>say ‘ã̷̠̬̊’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(Other Extend Extend Extend Extend)␤»\nsay ‘\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)␤»</code></pre></p><p>You can read more about graphemes in the Unicode Standard, which Raku tightly follows, using a method called NFG, normal form graphemes for efficiently representing them.</p>","n":"chars","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"d":"<p>Defined as:</p><p><pre><code>sub codes(Str(Cool))\nmethod codes()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the number of Unicode code points.</p><p><pre><code>say 'møp'.codes;    # OUTPUT: «3␤»</code></pre></p><p>The same result will be obtained with</p><p><pre><code>say +'møp'.ords;    # OUTPUT: «3␤»</code></pre></p><p>ords first obtains the actual codepoints, so there might be a difference in speed.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"codes","m":0},{"m":0,"s":{"p":[{"n":"$format?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s')</code></pre></p><p>Uses $format to return a formatted representation of the invocant; equivalent to calling sprintf with $format as format and the invocant as the second argument. The $format will be coerced to Stringy and defaults to '%s'.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>say 11.fmt('This Int equals %03d');         # OUTPUT: «This Int equals 011␤»\nsay '16'.fmt('Hexadecimal %x');             # OUTPUT: «Hexadecimal 10␤»</code></pre></p>","n":"fmt"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub uc(Str(Cool))\nmethod uc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it case-folded to upper case (capital letters).</p><p><pre><code>say \"Abc\".uc;       # OUTPUT: «ABC␤»</code></pre></p>","m":0,"k":"m","n":"uc"},{"n":"lc","m":0,"d":"<p>Defined as:</p><p><pre><code>sub lc(Str(Cool))\nmethod lc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it case-folded to lower case.</p><p><pre><code>say \"ABC\".lc;       # OUTPUT: «abc␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>sub tc(Str(Cool))\nmethod tc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the first letter case-folded to title case (or where not available, upper case).</p><p><pre><code>say \"abC\".tc;       # OUTPUT: «AbC␤»</code></pre></p>","n":"tc","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"fc","k":"m","d":"<p>Defined as:</p><p><pre><code>sub fc(Str(Cool))\nmethod fc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the result a Unicode \"case fold\" operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p><p><pre><code>say \"groß\".fc;       # OUTPUT: «gross␤»</code></pre></p>","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"tclc","d":"<p>Defined as:</p><p><pre><code>sub tclc(Str(Cool))\nmethod tclc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the first letter case-folded to title case (or where not available, upper case), and the rest of the string case-folded to lower case.</p><p><pre><code>say 'abC'.tclc;     # OUTPUT: «Abc␤»</code></pre></p>"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"wordcase","k":"m","d":"<p>Defined as:</p><p><pre><code>sub wordcase(Str(Cool) $input, :&amp;filter = &amp;tclc, Mu :$where = True)\nmethod wordcase(:&amp;filter = &amp;tclc, Mu :$where = True)</code></pre></p><p>Coerces the invocant (or in sub form, the first argument) to Str, and filters each word that smartmatches against $where through the &amp;filter. With the default filter (first character to upper case, rest to lower) and matcher (which accepts everything), this title-cases each word:</p><p><pre><code>say \"raku programming\".wordcase;        # OUTPUT: «Raku Programming␤»</code></pre></p><p>With a matcher:</p><p><pre><code>say \"have fun working on perl\".wordcase(:where({ .chars &gt; 3 }));\n                                        # Have fun Working on Perl</code></pre></p><p>With a customer filter too:</p><p><pre><code>say \"have fun working on perl\".wordcase(:filter(&amp;uc), :where({ .chars &gt; 3 }));\n                                        # HAVE fun WORKING on PERL</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>sub uniname(Str(Cool) --&gt; Str)\nmethod uniname(--&gt; Str)</code></pre></p><p>Interprets the invocant or first argument as a Str, and returns the Unicode codepoint name of the first codepoint of the first character. See uninames for a routine that works with multiple codepoints, and uniparse for the opposite direction.</p><p><pre><code># Camelia in Unicode\nsay ‘»ö«’.uniname;\n# OUTPUT: «\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\"␤»\nsay \"Ḍ̇\".uniname; # Note, doesn't show \"COMBINING DOT ABOVE\"\n# OUTPUT: «\"LATIN CAPITAL LETTER D WITH DOT BELOW\"␤»\n\n# Find the char with the longest Unicode name.\nsay (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;\n# OUTPUT: ««ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM␤»␤»</code></pre></p>","k":"m","m":0,"n":"uniname","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub uninames(Str:D)\nmethod uninames()</code></pre></p><p>Returns of a Seq of Unicode names for the all the codepoints in the Str provided.</p><p><pre><code>say ‘»ö«’.uninames.perl;\n# OUTPUT: «(\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\", \"LATIN SMALL LETTER O WITH DIAERESIS\", \"LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\").Seq␤»</code></pre></p><p>Note this example, which gets a Seq where each element is a Seq of all the codepoints in that character.</p><p><pre><code>say \"Ḍ̇'oh\".comb&gt;&gt;.uninames.perl;\n# OUTPUT: «((\"LATIN CAPITAL LETTER D WITH DOT BELOW\", \"COMBINING DOT ABOVE\").Seq, (\"APOSTROPHE\",).Seq, (\"LATIN SMALL LETTER O\",).Seq, (\"LATIN SMALL LETTER H\",).Seq)␤»</code></pre></p><p>See uniparse for the opposite direction.</p>","n":"uninames","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"unival","k":"m"},{"n":"univals","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"n":"uniprop","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"m":0,"d":"<p>Defined as:</p><p><pre><code>multi sub uniprop(Str:D, |c)\nmulti sub uniprop(Int:D $code)\nmulti sub uniprop(Int:D $code, Stringy:D $propname)\nmulti method uniprop(|c)</code></pre></p><p>Returns the unicode property of the first character. If no property is specified returns the General Category. Returns a Bool for Boolean properties. A uniprops routine can be used to get the property for every character in a string.</p><p><pre><code>say 'a'.uniprop;               # OUTPUT: «Ll␤»\nsay '1'.uniprop;               # OUTPUT: «Nd␤»\nsay 'a'.uniprop('Alphabetic'); # OUTPUT: «True␤»\nsay '1'.uniprop('Alphabetic'); # OUTPUT: «False␤»</code></pre></p>","k":"m"},{"n":"uniprop-int","m":0,"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"uniprop-bool"},{"k":"m","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"m":0,"n":"uniprop-str"},{"n":"uniprops","k":"m","m":0,"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"d":"<p>Defined as:</p><p><pre><code>multi sub unimatch(Str:D $str, |c)\nmulti unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)</code></pre></p><p>Checks if the given integer codepoint or the first letter of the string given have a unicode property equal to the value you give. If you supply the Unicode property to be checked it will only return True if that property matches the given value.</p><p><pre><code>say unimatch 'A', 'Latin';           # OUTPUT: «True␤»\nsay unimatch 'A', 'Latin', 'Script'; # OUTPUT: «True␤»\nsay unimatch 'A', 'Ll';              # OUTPUT: «True␤»</code></pre></p>","k":"m","n":"unimatch"},{"d":"<p>Defined as:</p><p><pre><code>sub chomp(Str(Cool))\nmethod chomp()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the last character removed, if it is a logical newline.</p><p><pre><code>say 'ab'.chomp.chars;                   # OUTPUT: «2␤»\nsay \"a\\n\".chomp.chars;                  # OUTPUT: «1␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"chomp"},{"k":"m","n":"chop","d":"<p>Defined as:</p><p><pre><code>sub chop(Str(Cool))\nmethod chop()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the last character removed.</p><p><pre><code>say 'perl'.chop;                        # OUTPUT: «per␤»</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"$n","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"d":"<p>Defined as:</p><p><pre><code>sub chop(Str(Cool))\nmethod chop()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the last character removed.</p><p><pre><code>say 'perl'.chop;                        # OUTPUT: «per␤»</code></pre></p>","n":"chop","k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>sub ord(Str(Cool))\nmethod ord()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the Unicode code point number of the first code point.</p><p><pre><code>say 'a'.ord;            # OUTPUT: «97␤»</code></pre></p><p>The inverse operation is chr.</p><p>Mnemonic: returns an ordinal number</p>","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"ord"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"chr","k":"m","d":"<p>Defined as:</p><p><pre><code>sub chr(Int(Cool))\nmethod chr()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Int, interprets it as a Unicode code points, and returns a string made of that code point.</p><p><pre><code>say '65'.chr;       # OUTPUT: «A␤»</code></pre></p><p>The inverse operation is ord.</p><p>Mnemonic: turns an integer into a character.</p>"},{"d":"<p>Defined as:</p><p><pre><code>sub chrs(*@codepoints --&gt; Str:D)\nmethod chrs()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument list) to a list of integers, and returns the string created by interpreting each integer as a Unicode codepoint, and joining the characters.</p><p><pre><code>say &lt;67 97 109 101 108 105 97&gt;.chrs;   # OUTPUT: «Camelia␤»</code></pre></p><p>This is the list-input version of chr. The inverse operation is ords.</p>","k":"m","m":1,"n":"chrs","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>sub ords(Str(Cool) $str)\nmethod ords()</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and returns a list of Unicode codepoints for each character.</p><p><pre><code>say \"Camelia\".ords;              # OUTPUT: «67 97 109 101 108 105 97␤»\nsay ords 10;                     # OUTPUT: «49 48␤»</code></pre></p><p>This is the list-returning version of ord. The inverse operation in chrs. If you are only interested in the number of codepoints, codes is a possibly faster option.</p>","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"ords"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>sub flip(Cool $s --&gt; Str:D)\nmethod flip()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns a reversed version.</p><p><pre><code>say 421.flip;       # OUTPUT: «124␤»</code></pre></p>","m":0,"n":"flip"},{"m":0,"n":"trans","d":"<p>Defined as:</p><p><pre><code>method trans(|)</code></pre></p><p>Coerces the invocant to Str and calls Str.trans</p>","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]}},{"m":1,"k":"m","s":{"r":"Bool:D","p":[{"n":"$needle","t":"Cool"},{"n":":$ignorecase!","t":"Any"},{"t":"Any","n":":$ignoremark"},{"n":"*%_","t":"Mu"}]},"n":"starts-with"},{"s":{"p":[{"n":"$needle","t":"Cool"},{"n":":$ignoremark!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","n":"starts-with","m":1},{"n":"starts-with","s":{"p":[{"n":"$needle","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":1,"k":"m"},{"n":"ends-with","s":{"p":[{"n":"$suffix","t":"Cool"},{"t":"Any","n":":$ignorecase!"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","m":1},{"s":{"r":"Bool:D","p":[{"t":"Cool","n":"$suffix"},{"n":":$ignoremark!","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"ends-with","k":"m"},{"n":"ends-with","m":1,"k":"m","s":{"r":"Bool:D","p":[{"n":"$suffix","t":"Cool"},{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"t":"Any","n":"from"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1,"n":"substr","d":"<p>Defined as:</p><p><pre><code>sub substr(Str(Cool) $str, |c)\nmethod substr(|c)</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr with the arguments.</p>"},{"k":"m","s":{"p":[{"n":"from","t":"Any"},{"n":"chars","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub substr(Str(Cool) $str, |c)\nmethod substr(|c)</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr with the arguments.</p>","n":"substr","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi method substr-rw(|) is rw\nmulti sub substr-rw(|) is rw</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr-rw with the arguments.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"substr-rw"},{"s":{"r":"Mu","p":[{"n":"from","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"substr-rw","d":"<p>Defined as:</p><p><pre><code>multi method substr-rw(|) is rw\nmulti sub substr-rw(|) is rw</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr-rw with the arguments.</p>","k":"m","m":1},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method substr-rw(|) is rw\nmulti sub substr-rw(|) is rw</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr-rw with the arguments.</p>","s":{"r":"Mu","p":[{"n":"from","t":"Any"},{"t":"Any","n":"chars"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"substr-rw"},{"n":"substr-eq","s":{"p":[{"n":"$needle","t":"Cool"},{"t":"Any","n":":$ignorecase!"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","m":1},{"n":"substr-eq","k":"m","s":{"p":[{"t":"Cool","n":"$needle"},{"t":"Any","n":":$ignoremark"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"m":1},{"n":"substr-eq","s":{"p":[{"n":"$needle","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"k":"m","m":1},{"m":1,"n":"substr-eq","k":"m","s":{"p":[{"n":"$needle","t":"Cool"},{"t":"Cool","n":"$pos"},{"n":":$ignorecase!","t":"Any"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"n":"substr-eq","k":"m","m":1,"s":{"r":"Bool:D","p":[{"t":"Cool","n":"$needle"},{"n":"$pos","t":"Cool"},{"n":":$ignoremark!","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":1,"n":"substr-eq"},{"n":"contains","m":1,"k":"m","s":{"p":[{"t":"Cool","n":"needle"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>"},{"n":"contains","d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","s":{"p":[{"n":"$needle","t":"Cool"},{"n":":$ignorecase!","t":"Any"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","m":1},{"d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","n":"contains","m":1,"k":"m","s":{"p":[{"n":"$needle","t":"Cool"},{"n":":$ignoremark!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":[{"t":"Cool","n":"$needle"},{"t":"Mu","n":"*%_"}]},"n":"contains","d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","m":1,"k":"m"},{"s":{"p":[{"n":"$needle","t":"Regex"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":1,"d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","n":"contains","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","s":{"p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"n":":$ignorecase!","t":"Any"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"contains","k":"m","m":1},{"s":{"p":[{"n":"$needle","t":"Cool"},{"t":"Cool","n":"$pos"},{"n":":$ignoremark!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"k":"m","m":1,"n":"contains","d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>"},{"s":{"p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"contains","d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","m":1,"k":"m"},{"s":{"r":"Bool:D","p":[{"t":"Regex","n":"$needle"},{"t":"Cool","n":"$pos"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * &gt; 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","m":1,"k":"m","n":"contains"},{"m":1,"k":"m","n":"indices","s":{"p":[{"t":"Cool","n":"needle"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"$needle","t":"Cool"},{"n":":$ignorecase!","t":"Any"},{"t":"Any","n":":$ignoremark"},{"n":":$overlap","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"indices","k":"m"},{"s":{"r":"Mu","p":[{"t":"Cool","n":"$needle"},{"t":"Any","n":":$ignoremark!"},{"n":":$overlap","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"indices","k":"m","m":1},{"n":"indices","m":1,"s":{"p":[{"n":"$needle","t":"Cool"},{"n":":$overlap","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","n":"indices","s":{"p":[{"n":"$needle","t":"Cool"},{"t":"Cool","n":"$pos"},{"t":"Any","n":":$ignorecase"},{"t":"Any","n":":$ignoremark"},{"t":"Any","n":":$overlap"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1},{"k":"m","n":"indices","s":{"r":"Mu","p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"t":"Any","n":":$ignoremark!"},{"t":"Any","n":":$overlap"},{"n":"*%_","t":"Mu"}]},"m":1},{"m":1,"s":{"p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"n":":$overlap","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"indices","k":"m"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","n":"index","s":{"r":"Mu","p":[{"t":"Cool","n":"$needle"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"index","m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","k":"m","s":{"r":"Int:D","p":[{"t":"Cool","n":"$needle"},{"n":":$ignorecase!","t":"Any"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","s":{"p":[{"t":"Cool","n":"$needle"},{"t":"Any","n":":$ignoremark!"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"index","k":"m","m":1},{"m":1,"k":"m","s":{"r":"Int:D","p":[{"n":"$needle","t":"Cool"},{"n":"*%_","t":"Mu"}]},"n":"index","d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>"},{"s":{"r":"Int:D","p":[{"n":"$needle","t":"Cool"},{"n":"$pos","t":"Cool"},{"t":"Any","n":":$ignorecase!"},{"n":":$ignoremark","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"index","m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>"},{"d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","n":"index","m":1,"s":{"r":"Int:D","p":[{"t":"Cool","n":"$needle"},{"t":"Cool","n":"$pos"},{"n":":$ignoremark!","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"index","d":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","m":1,"s":{"r":"Int:D","p":[{"t":"Cool","n":"$needle"},{"t":"Cool","n":"$pos"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\nmulti method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)</code></pre></p><p>Coerces the first two arguments (including the invocant in method form) to Str and $startpos to Int, and returns the last position of $needle in $haystack not after $startpos. Returns an undefined value if $needle wasn't found.</p><p>See the documentation in type Str for examples.</p>","n":"rindex","m":1,"s":{"r":"Mu","p":[{"t":"Cool","n":"$needle"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\nmulti method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)</code></pre></p><p>Coerces the first two arguments (including the invocant in method form) to Str and $startpos to Int, and returns the last position of $needle in $haystack not after $startpos. Returns an undefined value if $needle wasn't found.</p><p>See the documentation in type Str for examples.</p>","n":"rindex","s":{"p":[{"n":"$needle","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"m":1,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\nmulti method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)</code></pre></p><p>Coerces the first two arguments (including the invocant in method form) to Str and $startpos to Int, and returns the last position of $needle in $haystack not after $startpos. Returns an undefined value if $needle wasn't found.</p><p>See the documentation in type Str for examples.</p>","m":1,"k":"m","s":{"r":"Int:D","p":[{"t":"Cool","n":"$needle"},{"n":"$pos","t":"Cool"},{"n":"*%_","t":"Mu"}]},"n":"rindex"},{"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)</code></pre></p><p>the comb routine is a much better choice for many tasks that in other languages are handled by the split.</p><p>Coerces the invocant (or in the sub form, the second argument) to Str, and splits it into pieces based on delimiters found in the string.</p><p>If $delimiter is a string, it is searched for literally and not treated as a regex. You can also provide multiple delimiters by specifying them as a list; mixing Cool and Regex objects is OK.</p><p><pre><code>say split(';', \"a;b;c\").perl;               # OUTPUT: «(\"a\", \"b\", \"c\")␤»\nsay split(';', \"a;b;c\", 2).perl;            # OUTPUT: «(\"a\", \"b;c\").Seq␤»\n\nsay split(';', \"a;b;c,d\").perl;             # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\nsay split(/\\;/, \"a;b;c,d\").perl;            # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\nsay split(/&lt;[;,]&gt;/, \"a;b;c,d\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\", \"d\")␤»\n\nsay split(['a', /b+/, 4], '1a2bb345').perl; # OUTPUT: «(\"1\", \"2\", \"3\", \"5\")␤»</code></pre></p><p>By default, split omits the matches, and returns a list of only those parts of the string that did not match. Specifying one of the :k, :v, :kv, :p adverbs changes that. Think of the matches as a list that is interleaved with the non-matching parts.</p><p>The :v interleaves the values of that list, which will be either Match objects, if a Regex was used as a matcher in the split, or Str objects, if a Cool was used as matcher. If multiple delimiters are specified, Match objects will be generated for all of them, unless all of the delimiters are Cool.</p><p><pre><code>say 'abc'.split(/b/, :v);               # OUTPUT: «(a ｢b｣ c)␤»\nsay 'abc'.split('b', :v);               # OUTPUT: «(a b c)␤»</code></pre></p><p>:k interleaves the keys, that is, the indexes:</p><p><pre><code>say 'abc'.split(/b/, :k);               # OUTPUT: «(a 0 c)␤»</code></pre></p><p>:kv adds both indexes and matches:</p><p><pre><code>say 'abc'.split(/b/, :kv);               # OUTPUT: «(a 0 ｢b｣ c)␤»</code></pre></p><p>and :p adds them as Pairs, using the same types for values as :v does:</p><p><pre><code>say 'abc'.split(/b/, :p);               # OUTPUT: «(a 0 =&gt; ｢b｣ c)␤»\nsay 'abc'.split('b', :p);               # OUTPUT: «(a 0 =&gt; b c)␤»</code></pre></p><p>You can only use one of the :k, :v, :kv, :p adverbs in a single call to split.</p><p>Note that empty chunks are not removed from the result list. For that behavior, use the :skip-empty named argument:</p><p><pre><code>say (\"f,,b,c,d\".split: /\",\"/             ).perl;  # OUTPUT: «(\"f\", \"\", \"b\", \"c\", \"d\")␤»\nsay (\"f,,b,c,d\".split: /\",\"/, :skip-empty).perl;  # OUTPUT: «(\"f\", \"b\", \"c\", \"d\")␤»</code></pre></p>","n":"split"},{"m":0,"n":"match","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method match(|)</code></pre></p><p>Coerces the invocant to Stringy and calls Str.match.</p>","k":"m"},{"n":"comb","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"m":1},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","s":{"r":"Seq:D","p":[{"t":"Cool","n":"$size"},{"n":"$limit?","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"comb"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","n":"comb","s":{"r":"Seq:D","p":[{"n":"$size","t":"Int"},{"t":"Any","n":"$limit?"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Seq:D","p":[{"t":"Cool","n":"$pat"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"comb","k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>"},{"n":"comb","m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","k":"m","s":{"p":[{"n":"$pat","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"}},{"k":"m","m":1,"n":"comb","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","s":{"p":[{"n":"$pat","t":"Cool"},{"n":"$limit","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"}},{"n":"comb","k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","m":1,"s":{"p":[{"n":"$pat","t":"Str"},{"t":"Any","n":"$limit"},{"t":"Mu","n":"*%_"}],"r":"Seq:D"}},{"s":{"r":"Seq:D","p":[{"n":"$pattern","t":"Regex"},{"n":":$match","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1,"n":"comb","d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>"},{"d":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d &lt;[1..9]&gt; /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","s":{"r":"Seq:D","p":[{"t":"Regex","n":"$pattern"},{"n":"$limit","t":"Any"},{"t":"Any","n":":$match"},{"t":"Mu","n":"*%_"}]},"n":"comb","k":"m","m":1},{"m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub lines(Str(Cool))\nmethod lines()</code></pre></p><p>Coerces the invocant (and in sub form, the argument) to Str, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p><p><pre><code>say lines(\"a\\nb\\n\").join('|');          # OUTPUT: «a|b␤»\nsay \"some\\nmore\\nlines\".lines.elems;    # OUTPUT: «3␤»</code></pre></p><p>This method can be used as part of an IO::Path to process a file line-by-line, since IO::Path objects inherit from Cool, e.g.:</p><p><pre><code>for 'huge-csv'.IO.lines -&gt; $line {\n    # Do something with $line\n}\n\n# or if you'll be processing later\nmy @lines = 'huge-csv'.IO.lines;\n</code></pre></p><p>Without any arguments, sub lines operates on $*ARGFILES, which defaults to $*IN in the absence of any filenames.</p><p>To modify values in place use is copy to force a writable container.</p><p><pre><code>for $*IN.lines -&gt; $_ is copy { s/(\\w+)/{$0 ~ $0}/; .say }\n</code></pre></p>","n":"lines"},{"n":"lines","k":"m","m":1,"s":{"p":[{"n":":$count!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub lines(Str(Cool))\nmethod lines()</code></pre></p><p>Coerces the invocant (and in sub form, the argument) to Str, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p><p><pre><code>say lines(\"a\\nb\\n\").join('|');          # OUTPUT: «a|b␤»\nsay \"some\\nmore\\nlines\".lines.elems;    # OUTPUT: «3␤»</code></pre></p><p>This method can be used as part of an IO::Path to process a file line-by-line, since IO::Path objects inherit from Cool, e.g.:</p><p><pre><code>for 'huge-csv'.IO.lines -&gt; $line {\n    # Do something with $line\n}\n\n# or if you'll be processing later\nmy @lines = 'huge-csv'.IO.lines;\n</code></pre></p><p>Without any arguments, sub lines operates on $*ARGFILES, which defaults to $*IN in the absence of any filenames.</p><p>To modify values in place use is copy to force a writable container.</p><p><pre><code>for $*IN.lines -&gt; $_ is copy { s/(\\w+)/{$0 ~ $0}/; .say }\n</code></pre></p>"},{"m":1,"s":{"p":[{"t":"Any","n":"$limit"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>sub lines(Str(Cool))\nmethod lines()</code></pre></p><p>Coerces the invocant (and in sub form, the argument) to Str, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p><p><pre><code>say lines(\"a\\nb\\n\").join('|');          # OUTPUT: «a|b␤»\nsay \"some\\nmore\\nlines\".lines.elems;    # OUTPUT: «3␤»</code></pre></p><p>This method can be used as part of an IO::Path to process a file line-by-line, since IO::Path objects inherit from Cool, e.g.:</p><p><pre><code>for 'huge-csv'.IO.lines -&gt; $line {\n    # Do something with $line\n}\n\n# or if you'll be processing later\nmy @lines = 'huge-csv'.IO.lines;\n</code></pre></p><p>Without any arguments, sub lines operates on $*ARGFILES, which defaults to $*IN in the absence of any filenames.</p><p>To modify values in place use is copy to force a writable container.</p><p><pre><code>for $*IN.lines -&gt; $_ is copy { s/(\\w+)/{$0 ~ $0}/; .say }\n</code></pre></p>","n":"lines"},{"k":"m","n":"words","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method words(Cool:D: |c)</code></pre></p><p>Coerces the invocant (or first argument, if it is called as a subroutine) to Str, and returns a list of words that make up the string. Check Str.words for additional arguments and its meaning.</p><p><pre><code>say &lt;The quick brown fox&gt;.words.join('|');     # OUTPUT: «The|quick|brown|fox␤»\nsay &lt;The quick brown fox&gt;.words(2).join('|');  # OUTPUT: «The|quick␤»\n</code></pre></p><p>Cool is the base class for many other classes, and some of them, like Match, can be converted to a string. This is what happens in this case:</p><p><pre><code>say ( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/).words(Inf);\n# OUTPUT: «(easy easy)␤»\nsay words( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/ , ∞);\n# OUTPUT: «(easy easy)␤»</code></pre></p><p>The example above illustrates two of the ways words can be invoked, with the first argument turned into invocant by its signature. Of course, Inf is the default value of the second argument, so in both cases (and forms) it can be simply omitted.</p><p>Only whitespace (including no-break space) counts as word boundaries</p><p><pre><code>say &lt;Flying on a Boeing 747&gt;.words.join('|');  # OUTPUT: «Flying|on|a|Boeing|747␤»</code></pre></p><p>In this case, \"Boeing 747\" includes a (visible only in the source) no-break space; words still splits the (resulting) Str on it, even if the original array only had 4 elements:</p><p><pre><code>say &lt;Flying on a Boeing 747&gt;.join('|');        # OUTPUT: «Flying|on|a|Boeing 747␤»</code></pre></p><p>Please see Str.words for more examples and ways to invoke it.</p>","m":1},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>method words(Cool:D: |c)</code></pre></p><p>Coerces the invocant (or first argument, if it is called as a subroutine) to Str, and returns a list of words that make up the string. Check Str.words for additional arguments and its meaning.</p><p><pre><code>say &lt;The quick brown fox&gt;.words.join('|');     # OUTPUT: «The|quick|brown|fox␤»\nsay &lt;The quick brown fox&gt;.words(2).join('|');  # OUTPUT: «The|quick␤»\n</code></pre></p><p>Cool is the base class for many other classes, and some of them, like Match, can be converted to a string. This is what happens in this case:</p><p><pre><code>say ( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/).words(Inf);\n# OUTPUT: «(easy easy)␤»\nsay words( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/ , ∞);\n# OUTPUT: «(easy easy)␤»</code></pre></p><p>The example above illustrates two of the ways words can be invoked, with the first argument turned into invocant by its signature. Of course, Inf is the default value of the second argument, so in both cases (and forms) it can be simply omitted.</p><p>Only whitespace (including no-break space) counts as word boundaries</p><p><pre><code>say &lt;Flying on a Boeing 747&gt;.words.join('|');  # OUTPUT: «Flying|on|a|Boeing|747␤»</code></pre></p><p>In this case, \"Boeing 747\" includes a (visible only in the source) no-break space; words still splits the (resulting) Str on it, even if the original array only had 4 elements:</p><p><pre><code>say &lt;Flying on a Boeing 747&gt;.join('|');        # OUTPUT: «Flying|on|a|Boeing 747␤»</code></pre></p><p>Please see Str.words for more examples and ways to invoke it.</p>","n":"words","s":{"p":[{"n":"$limit","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method subst(|)</code></pre></p><p>Coerces the invocant to Stringy and calls Str.subst.</p>","n":"subst","s":{"p":[{"t":"Any","n":"$original"},{"t":"Any","n":"$replacement?"},{"n":"*%options","t":"Associative"}],"r":"Mu"},"m":1,"k":"m"},{"n":"subst-mutate","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]}},{"m":1,"n":"IO","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"IO","k":"m"},{"m":0,"k":"m","n":"sprintf","s":{"p":[{"t":"Positional","n":"*@args"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"printf","k":"m","m":0,"s":{"p":[{"t":"Positional","n":"*@args"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Cool","n":"$pattern"},{"n":"*%_","t":"Mu"}]},"n":"samecase","k":"m","d":"<p>Defined as:</p><p><pre><code>sub samecase(Cool $string, Cool $pattern)\nmethod samecase(Cool:D: Cool $pattern)</code></pre></p><p>Coerces the invocant (or in sub form, the first argument) to Str, and returns a copy of $string with case information for each individual character changed according to $pattern.</p><p>Note: The pattern string can contain three types of characters, i.e. uppercase, lowercase and caseless. For a given character in $pattern its case information determines the case of the corresponding character in the result.</p><p>If $string is longer than $pattern, the case information from the last character of $pattern is applied to the remaining characters of $string.</p><p><pre><code>say \"raKu\".samecase(\"A_a_\"); # OUTPUT: «Raku␤»\nsay \"rAKU\".samecase(\"Ab\");   # OUTPUT: «Raku␤»</code></pre></p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method path()</code></pre></p><p>DEPRECATED. It's been deprecated as of the 6.d version. Will be removed in the next ones.</p><p>Stringifies the invocant and converts it to IO::Path object. Use the .IO method instead.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"path","k":"m","m":0},{"m":0,"n":"trim","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub trim(Str(Cool))\nmethod trim()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with both leading and trailing whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim;\nsay \"&lt;$stripped&gt;\";          # OUTPUT: «&lt;abc&gt;␤»</code></pre></p>"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>sub trim-leading(Str(Cool))\nmethod trim-leading()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with leading whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim-leading;\nsay \"&lt;$stripped&gt;\";          # OUTPUT: «&lt;abc &gt;␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"trim-leading","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>sub trim-trailing(Str(Cool))\nmethod trim-trailing()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with trailing whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim-trailing;\nsay \"&lt;$stripped&gt;\";          # OUTPUT: «&lt;  abc&gt;␤»</code></pre></p>","m":0,"n":"trim-trailing"},{"m":0,"s":{"p":[{"n":"*%opts","t":"Associative"}],"r":"Mu"},"n":"EVAL","d":"<p>Defined as:</p><p><pre><code>method EVAL(*%_)\n</code></pre></p><p>It calls the subroutine form with the invocant as the first argument, $code, passing along named args, if any.</p>","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"k":"m","n":"Int"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"UInt","k":"m","m":1},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Num"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Rat","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"FatRat"},{"m":0,"n":"Complex","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"p":[{"n":"$suggestion","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!list-as-string"}],"b":"C","t":"Cool","n":"Cool","k":"c"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(+)>","d":"<p><pre><code>multi sub infix:&lt;(+)&gt;(**@p)\nmulti sub infix:&lt;⊎&gt;(**@p)</code></pre></p><p>Baggy addition operator.</p><p>Returns the Baggy addition of its arguments. This creates a new Bag from each element of the arguments with the weights of the element added together to get the new weight, if none of the arguments are a Mix or MixHash.</p><p><pre><code>say &lt;a a b c a d&gt; (+) &lt;a a b c c&gt;; # OUTPUT: «Bag(a(5), b(2), c(3), d)␤»\n</code></pre></p><p>If any of the arguments is a Mixy, the result is a new Mix.</p><p><pre><code>say &lt;a b c&gt; (+) (a =&gt; 2.5, b =&gt; 3.14).Mix; # OUTPUT: «Mix(a(3.5), b(4.14), c)␤»\n</code></pre></p><p>⊎ is equivalent to (+), at codepoint U+228E (MULTISET UNION).</p>"},{"s":{"r":"Mu","p":[]},"n":"infix:<(+)>","m":1,"k":"s"},{"m":1,"n":"infix:<(+)>","k":"s","s":{"r":"Mu","p":[{"t":"Bag","n":"a"}]}},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mix"}]},"n":"infix:<(+)>"},{"s":{"r":"Mu","p":[{"t":"MixHash","n":"a"}]},"k":"s","n":"infix:<(+)>","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"t":"QuantHash","n":"b"}]},"k":"s","n":"infix:<(+)>"},{"m":1,"n":"infix:<(+)>","k":"s","s":{"p":[{"n":"a","t":"Setty"},{"n":"b","t":"Map"}],"r":"Mu"}},{"m":1,"k":"s","n":"infix:<(+)>","s":{"p":[{"t":"Mixy","n":"a"},{"n":"b","t":"QuantHash"}],"r":"Mu"}},{"m":1,"n":"infix:<(+)>","k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"t":"QuantHash","n":"b"}],"r":"Mu"}},{"k":"s","n":"infix:<(+)>","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}]}},{"n":"infix:<(+)>","s":{"r":"Mu","p":[{"t":"Iterable","n":"a"},{"t":"Iterable","n":"b"}]},"m":1,"k":"s"},{"k":"s","m":1,"n":"infix:<(+)>","s":{"r":"Mu","p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}]}},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}]},"m":1,"n":"infix:<(+)>"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]},"n":"infix:<(+)>"},{"s":{"r":"Mu","p":[{"n":"+@p","t":"Positional"}]},"k":"s","m":1,"n":"infix:<(+)>"},{"n":"&infix:<≤>","k":"v","d":"<p>Numeric less than or equal to operator.</p><p>Equivalent to &lt;=, at codepoint U+2264 (LESS-THAN OR EQUAL TO).</p>","t":"Sub+{is-pure}"},{"k":"s","n":"infix:<≤>","m":1,"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s","n":"infix:<≤>","m":1},{"n":"infix:<≤>","s":{"p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}],"r":"Mu"},"k":"s","m":1},{"n":"infix:<≤>","m":1,"s":{"r":"Bool:D","p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}]},"k":"s"},{"n":"infix:<≤>","m":1,"s":{"r":"Bool:D","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]},"k":"s"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Num"},{"t":"Num","n":"b"}]},"n":"infix:<≤>","k":"s"},{"k":"s","s":{"p":[{"n":"$a","t":"num"},{"t":"num","n":"$b"}],"r":"Bool:D"},"n":"infix:<≤>","m":1},{"m":1,"s":{"r":"Bool:D","p":[{"t":"Rational","n":"a"},{"n":"b","t":"Rational"}]},"k":"s","n":"infix:<≤>"},{"s":{"r":"Bool:D","p":[{"t":"Rational","n":"a"},{"t":"Int","n":"b"}]},"m":1,"k":"s","n":"infix:<≤>"},{"n":"infix:<≤>","m":1,"s":{"p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}],"r":"Bool:D"},"k":"s"},{"n":"infix:<≤>","k":"s","s":{"r":"Bool:D","p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}]},"m":1},{"s":{"r":"Bool:D","p":[{"n":"a","t":"DateTime"},{"n":"b","t":"DateTime"}]},"n":"infix:<≤>","k":"s","m":1},{"s":{"p":[{"t":"Date","n":"$a"},{"t":"Date","n":"$b"}],"r":"Bool:D"},"m":1,"n":"infix:<≤>","k":"s"},{"n":"infix:<≤>","s":{"r":"Mu","p":[{"t":"Version","n":"a"},{"t":"Version","n":"b"}]},"k":"s","m":1},{"t":"Set","a":[{"n":"$!WHICH","k":"v","t":"ValueObjAt"},{"n":"$!elems","t":"Rakudo::Internals::IterationSet","k":"v"}],"m":[{"n":"iterator","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"n":"type","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Mu","n":"*%_"}],"r":"Setty:D"},"k":"m","m":0,"n":"!create-from-iterator"},{"n":"!WHICH","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"t":"Any","n":"type"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!HASHIFY"}],"d":"<p><pre><code>class Set does Setty { }</code></pre></p><p>A Set is an immutable set, meaning a collection of distinct elements in no particular order. (For mutable sets, see SetHash instead.)</p><p>Objects/values of any type are allowed as set elements. Within a Set, every element is guaranteed to be unique (in the sense that no two elements would compare positively with the === operator):</p><p><pre><code>my $fruits = set &lt;peach apple orange apple apple&gt;;\n\nsay $fruits.elems;      # OUTPUT: «3␤»\nsay $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n</code></pre></p><p>Sets can be treated as object hashes using the { } postcircumfix operator, which returns the value True for keys that are elements of the set, and False for keys that aren't:</p><p><pre><code>my $fruits = set &lt;peach apple orange apple apple&gt;;\nsay $fruits&lt;apple&gt;;  # OUTPUT: «True␤»\nsay $fruits&lt;kiwi&gt;;   # OUTPUT: «False␤»</code></pre></p>","mro":["Setty","QuantHash","Associative","Any"],"k":"c","b":"A","n":"Set"},{"t":"PromiseStatus","n":"PromiseStatus","k":"e"},{"t":"PromiseStatus","n":"PromiseStatus::Kept","k":"e"},{"k":"e","t":"PromiseStatus","n":"PromiseStatus::Broken"},{"t":"PromiseStatus","n":"PromiseStatus::Planned","k":"e"},{"d":"<p><pre><code>my class Cancellation {}</code></pre></p><p>A low level part of the Raku concurrency system. Some Scheduler objects return a Cancellation with the .cue method which can be used to cancel the scheduled execution before normal completion. Cancellation.cancelled is a boolean that is true after #cancel is called.</p>","t":"Cancellation","b":"A","n":"Cancellation","m":[{"s":{"p":[{"n":":@!async_handles","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"BUILD","k":"s","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"cancel"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"cancelled"},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"a":[{"t":"Mu","n":"$.cancelled","k":"v"},{"n":"$!lock","t":"Mu","k":"v"},{"n":"@!async_handles","t":"Positional","k":"v"}],"mro":["Any"],"k":"c"},{"n":"SIGILL","k":"e","t":"Signal"},{"mro":[],"b":"C","t":"Enumeration","k":"ro","d":"<p><pre><code>role Enumeration { }</code></pre></p><p>This is the role implemented by the enum-pairs in the enum type. In general, it is used to create constant sets, the elements of which become also constant symbols in the current namespace and to establish a relationship between the symbols belonging to the same set. In general, you will find Enumeration in enum types:</p><p><pre><code>enum norse-gods &lt;Þor Oðin Loki&gt;;\nmy $one-of-them = norse-gods.pick;\nsay $one-of-them ~~ Enumeration; # OUTPUT: «True␤»</code></pre></p><p>but nothing prevents you from using it in your own programs if you want to restrict somehow the relationship between the key and the value:</p><p><pre><code>class DNA does Enumeration {\n    my %pairings = %( A =&gt; \"T\",\n                      T =&gt; \"A\",\n                      C =&gt; \"G\",\n                      G =&gt; \"C\" );\n\n    method new( $base-pair where \"A\" | \"C\" | \"G\" | \"T\" )  {\n        self.bless( key =&gt; $base-pair,\n                    value =&gt; %pairings{$base-pair});\n    }\n\n    multi method gist(::?CLASS:D:) {\n        return \"$!key → $!value\";\n    }\n\n}\n\nenum Chain ();\nconstant length = 16;\nfor &lt;A C G T&gt;.roll( length ) -&gt; $letter {\n    my DNA $base = DNA.new( $letter );\n    Chain.HOW.add_enum_value( Chain, $base );\n}\n\nfor ^length {\n    my $base = Chain.pick;\n    say \"{$base.key} and {$base.value}\";\n}\n</code></pre></p><p>In this code, DNA consumes the Enumeration role, which is from this point of view a pair of key and value; we can use the generated DNA objects to compose an enum type from which elements can be picked one by one, with the output shown below.</p><p><pre><code>T and A\nC and G\nT and A\n# and so on...\n</code></pre></p>","a":[{"t":"Mu","k":"v","n":"$.key"},{"n":"$.value","t":"Mu","k":"v"},{"t":"int","n":"$!index","k":"v"}],"m":[{"n":"enums","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method enums()</code></pre></p><p>Returns a Map of enum values. Works both on the enum type and any key.</p><p><pre><code>enum Mass ( mg =&gt; 1/1000, g =&gt; 1/1, kg =&gt; 1000/1 );\nsay Mass.enums; # OUTPUT: «Map.new((g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001))␤»\nsay g.enums;    # OUTPUT: «Map.new((g =&gt; 1, kg =&gt; 1000, mg =&gt; 0.001))␤»</code></pre></p>","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"pair","d":"<p>Defined as:</p><p><pre><code>method pair(::?CLASS:D:)</code></pre></p><p>Returns it as a Pair.</p><p><pre><code>say g.pair; # OUTPUT: «g =&gt; 1␤»\n</code></pre></p>","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pred","m":0,"d":"<p>Defined as:</p><p><pre><code>method pred(::?CLASS:D:)</code></pre></p><p><pre><code>say Freija.pred;  # OUTPUT: «Oðin␤»\n</code></pre></p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method succ(::?CLASS:D:)</code></pre></p><p><pre><code>say Oðin.succ;  # OUTPUT: «Freija␤»\n</code></pre></p>","n":"succ","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"}],"n":"Enumeration"},{"t":"Signal","n":"SIGXCPU","k":"e"},{"n":"&prefix:<~>","t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub prefix:&lt;~&gt;(Any --&gt; Str:D)</code></pre></p><p>String context operator.</p><p>Coerces the argument to Str by calling the Str method on it.</p>"},{"m":1,"s":{"p":[{"n":"a","t":"Any"}],"r":"Mu"},"n":"prefix:<~>","k":"s"},{"n":"prefix:<~>","k":"s","m":1,"s":{"p":[{"t":"int","n":"$a"}],"r":"Mu"}},{"m":1,"n":"prefix:<~>","s":{"p":[{"n":"$a","t":"num"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"n":"a","t":"Blob"}],"r":"Mu"},"k":"s","m":1,"n":"prefix:<~>"},{"m":1,"n":"prefix:<~>","s":{"p":[{"n":"a","t":"Str"}],"r":"Str:D"},"k":"s"},{"s":{"p":[{"n":"$a","t":"str"}],"r":"str"},"m":1,"n":"prefix:<~>","k":"s"},{"k":"v","n":"&prefix:<?^>","d":"<p><pre><code>multi sub prefix:&lt;?^&gt;(Mu --&gt; Bool:D)</code></pre></p><p>Boolean bitwise negation operator: Coerces the argument to Bool and then does a bit flip, which makes it the same as prefix:&lt;!&gt; .</p>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":[{"n":"a","t":"Mu"}]},"k":"s","n":"prefix:<?^>","m":1},{"k":"v","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:<∈>"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Str"},{"n":"b","t":"Map"}]},"n":"infix:<∈>","k":"s","m":1},{"s":{"p":[{"n":"a","t":"Any"},{"t":"Map","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<∈>","m":1},{"n":"infix:<∈>","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Int"},{"t":"Range","n":"b"}]},"k":"s"},{"n":"infix:<∈>","k":"s","m":1,"s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"t":"Iterable","n":"b"}]}},{"m":1,"n":"infix:<∈>","k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Iterator"}]}},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"QuantHash"}]},"m":1,"n":"infix:<∈>","k":"s"},{"k":"s","s":{"p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}],"r":"Mu"},"m":1,"n":"infix:<∈>"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}],"r":"Mu"},"n":"infix:<∈>"},{"k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"m":1,"n":"infix:<∈>"},{"t":"Sub","n":"&prefix:<++⚛>","k":"v"},{"m":1,"s":{"p":[{"n":"$target","t":"atomicint"}],"r":"atomicint"},"n":"prefix:<++⚛>","k":"s"},{"d":"<p><pre><code>class Date { }</code></pre></p><p>A Date is an immutable object identifying a day in the Gregorian calendar.</p><p>Date objects support addition and subtraction of integers, where an integer is interpreted as the number of days. You can compare Date objects with the numeric comparison operators ==, &lt;, &lt;=, &gt;, &gt;=, != . Their stringification in YYYY-MM-DD format means that comparing them with the string operators eq, lt, le etc. also gives the right result.</p><p>Date.today creates an object the current day according to the system clock.</p><p><pre><code>my $d = Date.new(2015, 12, 24); # Christmas Eve!\nsay $d;                         # OUTPUT: «2015-12-24␤»\nsay $d.year;                    # OUTPUT: «2015␤»\nsay $d.month;                   # OUTPUT: «12␤»\nsay $d.day;                     # OUTPUT: «24␤»\nsay $d.day-of-week;             # OUTPUT: «4␤» (Thursday)\nsay $d.later(days =&gt; 20);       # OUTPUT: «2016-01-13␤»\nmy $n = Date.new('2015-12-31'); # New Year's Eve\nsay $n - $d;                    # OUTPUT: «7␤», 7 days between New Years/Christmas Eve\nsay $n + 1;                     # OUTPUT: «2016-01-01␤»</code></pre></p><p>Note since version 6.d, .perl can be called on Date.</p>","t":"Date","n":"Date","m":[{"k":"m","s":{"r":"Date:D","p":[{"t":"Any","n":"$year"},{"n":"$month","t":"Any"},{"n":"$day","t":"Any"},{"t":"Callable","n":":&formatter"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>","m":1,"n":"new"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>","s":{"r":"Date:D","p":[{"n":":$year!","t":"Any"},{"n":":$month?","t":"Any"},{"t":"Any","n":":$day?"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"new"},{"m":1,"n":"new","s":{"p":[{"t":"Str","n":"$date"},{"n":":&formatter","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Date:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>"},{"s":{"r":"Date:D","p":[{"n":"$d","t":"Dateish"},{"t":"Callable","n":":&formatter"},{"t":"Associative","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>","n":"new","m":1},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>","m":1,"s":{"r":"Date:D","p":[{"n":"$i","t":"Instant"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Associative"}]},"n":"new"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m","n":"new","d":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&amp;formatter --&gt; Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --&gt; Date:D)\nmulti method new(Str $date                        --&gt; Date:D)\nmulti method new(Instant:D $dt                    --&gt; Date:D)\nmulti method new(DateTime:D $dt                   --&gt; Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year =&gt; 2042, month =&gt; 1, day =&gt; 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>"},{"m":1,"n":"new-from-daycount","k":"m","d":"<p>Defined as:</p><p><pre><code>method new-from-daycount($daycount,:&amp;formatter --&gt; Date:D)</code></pre></p><p>Creates a new Date object given $daycount which is the number of days from epoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a formatter as a named parameter.</p><p><pre><code>say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»</code></pre></p>","s":{"p":[{"n":"$daycount","t":"Any"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Date:D"}},{"d":"<p>Defined as:</p><p><pre><code>method new-from-daycount($daycount,:&amp;formatter --&gt; Date:D)</code></pre></p><p>Creates a new Date object given $daycount which is the number of days from epoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a formatter as a named parameter.</p><p><pre><code>say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»</code></pre></p>","n":"new-from-daycount","k":"m","s":{"r":"Date:D","p":[{"t":"Any","n":"$daycount"},{"n":":&formatter?","t":"Callable"},{"t":"Mu","n":"*%_"}]},"m":1},{"n":"today","m":0,"d":"<p>Defined as:</p><p><pre><code>method today(:&amp;formatter --&gt; Date:D)</code></pre></p><p>Returns a Date object for the current day. Optionally accepts a formatter named parameter.</p><p><pre><code>say Date.today;</code></pre></p>","s":{"p":[{"t":"Callable","n":":&formatter"},{"n":"*%_","t":"Mu"}],"r":"Date:D"},"k":"m"},{"m":0,"n":"first-date-in-month","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Date:D"}},{"m":0,"k":"m","s":{"r":"Date:D","p":[{"t":"Mu","n":"*%_"}]},"n":"last-date-in-month"},{"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method truncated-to(Date:D: Cool $unit)</code></pre></p><p>Returns a Date truncated to the first day of its year, month or week. For example</p><p><pre><code>my $c = Date.new('2012-12-24');\nsay $c.truncated-to('year');     # OUTPUT: «2012-01-01␤»\nsay $c.truncated-to('month');    # OUTPUT: «2012-12-01␤»\nsay $c.truncated-to('week');     # OUTPUT: «2012-12-24␤», because it's Monday already</code></pre></p>","n":"truncated-to","s":{"p":[{"t":"Cool","n":"$unit"},{"t":"Mu","n":"*%_"}],"r":"Date:D"}},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method earlier(Date:D: *%unit)</code></pre></p><p>Returns a Date object based on the current one, but with a date delta towards the past applied. See #method later for usage.</p><p><pre><code>my $d = Date.new('2015-02-27');\nsay $d.earlier(month =&gt; 5).earlier(:2days);  # OUTPUT: «2014-09-25␤»</code></pre></p>","m":0,"s":{"r":"Date:D","p":[{"t":"Associative","n":"*%unit"}]},"n":"earlier"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method later(Date:D: *%unit)</code></pre></p><p>Returns a Date object based on the current one, but with a date delta applied. The date delta can be passed as a named argument where the argument name is the unit.</p><p>Allowed units are day, days, week, weeks, month, months, year, years. Please note that the plural forms can only be used with the later method.</p><p>Please note that the special \":2nd\" named parameter syntax can be a compact and self-documenting way of specifying the delta</p><p><pre><code>say Date.new('2015-12-24').later(:2years);  # OUTPUT: «2017-12-24␤»</code></pre></p><p>Since addition of several different time units is not commutative, only one unit may be passed.</p><p><pre><code>my $d = Date.new('2015-02-27');\nsay $d.later(month =&gt; 1).later(:2days);  # OUTPUT: «2015-03-29␤»\nsay $d.later(days =&gt; 2).later(:1month);  # OUTPUT: «2015-04-01␤»\nsay $d.later(days =&gt; 2).later(:month);   # same, as +True === 1</code></pre></p><p>Negative offsets are allowed, though #method earlier is more idiomatic for that.</p>","s":{"r":"Date:D","p":[{"n":"*%unit","t":"Associative"}]},"k":"m","n":"later"},{"s":{"r":"Date:D","p":[{"n":"*%_","t":"Associative"}]},"k":"m","n":"clone","d":"<p>Defined as:</p><p><pre><code>method clone(:$year, :$month, :$day, :&amp;formatter)</code></pre></p><p>Creates a new Date object based on the invocant, but with the given arguments overriding the values from the invocant.</p><p><pre><code>say Date.new('2015-11-24').clone(month =&gt; 12);    # OUTPUT: «2015-12-24␤»</code></pre></p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method succ(Date:D: --&gt; Date:D)</code></pre></p><p>Returns a Date of the following day. \"succ\" is short for \"successor\".</p><p><pre><code>say Date.new(\"2016-02-28\").succ;   # OUTPUT: «2016-02-29␤»</code></pre></p>","s":{"r":"Date:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"succ"},{"s":{"r":"Date:D","p":[{"n":"*%_","t":"Mu"}]},"n":"pred","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method pred(Date:D: --&gt; Date:D)</code></pre></p><p>Returns a Date of the previous day. \"pred\" is short for \"predecessor\".</p><p><pre><code>say Date.new(\"2016-01-01\").pred;   # OUTPUT: «2015-12-31␤»</code></pre></p>"},{"n":"DateTime","s":{"r":"DateTime:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method DateTime(Date:U --&gt; DateTime:U)\nmulti method DateTime(Date:D --&gt; DateTime:D)</code></pre></p><p>Converts the invocant to DateTime</p><p><pre><code>say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\nsay Date.DateTime;                   # OUTPUT: «(DateTime)␤»</code></pre></p>","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi method DateTime(Date:U --&gt; DateTime:U)\nmulti method DateTime(Date:D --&gt; DateTime:D)</code></pre></p><p>Converts the invocant to DateTime</p><p><pre><code>say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\nsay Date.DateTime;                   # OUTPUT: «(DateTime)␤»</code></pre></p>","n":"DateTime","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"DateTime:U"},"k":"m","m":1},{"n":"Date","d":"<p>Defined as:</p><p><pre><code>method Date(--&gt; Date)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say Date.new('2015-12-24').Date;  # OUTPUT: «2015-12-24␤»\nsay Date.Date;                    # OUTPUT: «(Date)␤»</code></pre></p>","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"year"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"month"},{"n":"day","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"formatter","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"},{"m":0,"n":"!truncate-ymd","s":{"p":[{"n":"$unit","t":"Cool"},{"n":"%parts?","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"$invalid-str"},{"n":"$target","t":"Any"},{"t":"Any","n":"$format"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!tif","k":"m"},{"s":{"p":[{"n":"$days","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Date:D"},"n":"!move-days","m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"$elems","t":"int"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"!move-die"},{"n":"!SET-DAYCOUNT","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"$year","t":"int"},{"n":"$month","t":"int"},{"n":"$day","t":"int"},{"t":"Mu","n":"*%_"}]},"n":"!clip-day","m":0},{"m":0,"n":"!new-from-daycount","k":"m","s":{"p":[{"n":"$daycount","t":"int"},{"t":"Callable","n":"&formatter"},{"n":"%nameds","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Date:D"}},{"m":0,"s":{"r":"Int:D","p":[{"n":"year","t":"Any"},{"n":"month","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!DAYS-IN-MONTH"},{"s":{"r":"Date:D","p":[{"n":"$days","t":"int"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!move-days-within-month"},{"s":{"p":[{"n":"$unit","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!VALID-UNIT","m":0,"k":"m"},{"n":"!clone-without-validating","m":0,"k":"m","s":{"r":"Date:D","p":[{"t":"Associative","n":"*%_"}]}},{"s":{"p":[{"t":"str","n":"$unit"},{"n":"$amount","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!move","k":"m","m":0},{"n":"!calculate-daycount","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","n":"!ymd-from-daycount","m":0,"s":{"p":[{"t":"int","n":"$daycount"},{"n":"year","t":"Any"},{"t":"Any","n":"month"},{"n":"day","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"s":{"r":"Date:D","p":[{"n":"year","t":"Any"},{"t":"Any","n":"month"},{"n":"day","t":"Any"},{"n":"formatter","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!SET-SELF"},{"n":"!year-Str","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"!formatter"},{"m":0,"k":"m","s":{"p":[{"n":"$year","t":"Any"},{"t":"Any","n":"$month"},{"n":"$day","t":"Any"},{"t":"Callable","n":"&formatter"},{"n":"%nameds","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!bless"},{"n":"!oor","m":0,"s":{"p":[{"t":"Any","n":"$what"},{"n":"$got","t":"Any"},{"t":"Any","n":"$range"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"}],"k":"c","b":"A","mro":["Dateish","Any"],"a":[{"t":"int","n":"$.year","k":"v"},{"k":"v","n":"$.month","t":"int"},{"n":"$.day","t":"int","k":"v"},{"k":"v","t":"int","n":"$.daycount"},{"t":"Callable","n":"&.formatter","k":"v"}]},{"n":"&atomic-dec-fetch","k":"v","t":"Sub"},{"k":"s","s":{"p":[{"t":"atomicint","n":"$target"}],"r":"atomicint"},"n":"atomic-dec-fetch","m":1},{"n":"&succeed","k":"v","t":"Sub"},{"n":"succeed","m":1,"k":"s","s":{"r":"Nil","p":[]}},{"m":1,"s":{"p":[{"t":"Any","n":"x"}],"r":"Nil"},"n":"succeed","k":"s"},{"s":{"p":[{"t":"Any","n":"|"}],"r":"Nil"},"n":"succeed","k":"s","m":1},{"k":"v","n":"&infix:<Z>","d":"<p><pre><code>sub infix:&lt;Z&gt;(**@lists --&gt; Seq:D) is assoc&lt;chain&gt;</code></pre></p><p>The Zip operator interleaves the lists passed to Z like a zipper, taking index-corresponding elements from each operand. The returned Seq contains nested lists, each with a value from every operand in the chain. If one of the operands runs out of elements prematurely, the zip operator will stop.</p><p><pre><code>say (1, 2 Z &lt;a b c&gt; Z &lt;+ -&gt;).perl;\n# OUTPUT: «((1, \"a\", \"+\"), (2, \"b\", \"-\")).Seq␤»\nfor &lt;a b c&gt; Z &lt;1 2 3 4&gt; -&gt; [$l, $r] {\n    say \"$l:$r\"\n}\n# OUTPUT: «a:1␤b:2␤c:3␤»\n</code></pre></p><p>The Z operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p><p><pre><code>say 100, 200 Z+ 42, 23;             # OUTPUT: «(142 223)␤»\nsay 1..3 Z~ &lt;a b c&gt; Z~ 'x' xx 3;    # OUTPUT: «(1ax 2bx 3cx)␤»</code></pre></p><p> </p>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<Z>","s":{"r":"Seq:D","p":[{"t":"Any","n":"+lol"},{"n":":&with!","t":"Callable"}]},"k":"s","m":1},{"s":{"p":[{"t":"Any","n":"+lol"}],"r":"Seq:D"},"m":1,"n":"infix:<Z>","k":"s"},{"t":"Sub+{is-pure}","n":"&none","k":"v"},{"n":"none","s":{"p":[{"t":"Positional","n":"@values"}],"r":"Mu"},"m":1,"k":"s"},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"+values"}]},"m":1,"n":"none"},{"n":"&atanh","t":"Sub+{is-pure}","k":"v"},{"m":1,"k":"s","s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"},"n":"atanh"},{"s":{"r":"Mu","p":[{"t":"Cool","n":"x"}]},"m":1,"n":"atanh","k":"s"},{"m":1,"k":"s","n":"atanh","s":{"r":"num","p":[{"n":"$x","t":"num"}]}},{"k":"v","t":"Sub+{Precedence}","n":"&infix:<^^>","d":"<p>Short-circuit exclusive-or. Returns the true argument if there is one (and only one). Returns the last argument if all arguments are false. Returns Nil when more than one argument is true.</p><p>This operator short-circuits in the sense that it does not evaluate any arguments after a 2nd true result.</p><p><pre><code>say 0 ^^ 42;                             # OUTPUT: «42␤»\nsay '' ^^ 0;                             # OUTPUT: «0␤»\nsay 0 ^^ 42 ^^ 1 ^^ die \"never called\";  # OUTPUT: «Nil␤»</code></pre></p><p>Note that the semantics of this operator may not be what you assume: infix ^^ flips to the first true value it finds and then flips to Nil forever after the second, no matter how many more true values there are. (In other words, it has \"find the one true value\" semantics, not \"boolean parity\" semantics.)</p>"},{"m":1,"s":{"p":[{"n":"$x?","t":"Mu"}],"r":"Mu"},"n":"infix:<^^>","k":"s"},{"m":1,"n":"infix:<^^>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"n":"&b","t":"Callable"}]}},{"n":"infix:<^^>","k":"s","s":{"p":[{"n":"a","t":"Mu"},{"t":"Mu","n":"b"}],"r":"Mu"},"m":1},{"s":{"r":"Mu","p":[{"n":"+@a","t":"Positional"}]},"n":"infix:<^^>","m":1,"k":"s"},{"n":"&uniname","k":"v","t":"Sub"},{"s":{"p":[{"t":"Str","n":"$str"}],"r":"Mu"},"m":1,"k":"s","n":"uniname"},{"n":"uniname","m":1,"k":"s","s":{"p":[{"t":"Int","n":"$code"}],"r":"Mu"}},{"t":"Sub+{Precedence}","n":"&infix:<^...>","k":"v"},{"k":"s","n":"infix:<^...>","m":1,"s":{"p":[{"n":"a","t":"Any"},{"t":"Mu","n":"b"}],"r":"Mu"}},{"n":"infix:<^...>","m":1,"s":{"p":[{"n":"lol","t":"Any"}],"r":"Mu"},"k":"s"},{"a":[{"n":"$!elems","k":"v","t":"Rakudo::Internals::IterationSet"}],"k":"c","t":"BagHash","m":[{"n":"total","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"clone","k":"m","m":0},{"n":"add","s":{"p":[{"t":"Any","n":"to-add"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m","m":0},{"m":0,"n":"remove","k":"m","s":{"r":"Nil","p":[{"t":"Any","n":"to-remove"},{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Baggy:D","p":[{"t":"Any","n":"type"},{"n":"iterator","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!create-from-iterator","k":"m"},{"k":"m","m":0,"n":"!HASHIFY","s":{"p":[{"t":"Any","n":"type"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"mro":["Baggy","QuantHash","Associative","Any"],"b":"A","d":"<p><pre><code>class BagHash does Baggy { }</code></pre></p><p>A BagHash is a mutable bag/multiset, meaning a collection of distinct elements in no particular order that each have an integer weight assigned to them signifying how many copies of that element are considered \"in the bag\". (For immutable bags, see Bag instead.)</p><p>Objects/values of any type are allowed as bag elements. Within a BagHash, items that would compare positively with the === operator are considered the same element, with the number of how many there were as its weight. But of course you can also easily get back the expanded list of items (without the order):</p><p><pre><code>my $breakfast = &lt;spam eggs spam spam bacon spam&gt;.BagHash;\n\nsay $breakfast.elems;      # OUTPUT: «3␤»\nsay $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\nsay $breakfast.total;      # OUTPUT: «6␤»\nsay $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n</code></pre></p><p>BagHashes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding integer weight for keys that are elements of the bag, and 0 for keys that aren't. It can also be used to modify weights; setting a weight to 0 automatically removes that element from the bag, and setting a weight to a positive number adds that element if it didn't already exist:</p><p><pre><code>my $breakfast = &lt;spam eggs spam spam bacon spam&gt;.BagHash;\nsay $breakfast&lt;bacon&gt;;     # OUTPUT: «1␤»\nsay $breakfast&lt;spam&gt;;      # OUTPUT: «4␤»\nsay $breakfast&lt;sausage&gt;;   # OUTPUT: «0␤»\n\n$breakfast&lt;sausage&gt; = 2;\n$breakfast&lt;bacon&gt;--;\nsay $breakfast.kxxv.sort;  # OUTPUT: «eggs sausage sausage spam spam spam spam␤»\n</code></pre></p>","n":"BagHash"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;%&gt;($x, $y --&gt; Numeric:D)</code></pre></p><p>Modulo operator. Coerces to Numeric first.</p><p>Generally the following identity holds:</p><p><pre><code>my ($x, $y) = 1,2;\n$x % $y == $x - floor($x / $y) * $y</code></pre></p>","n":"&infix:<%>"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<%>"},{"k":"s","s":{"p":[{"n":"$x","t":"Any"}],"r":"Mu"},"m":1,"n":"infix:<%>"},{"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<%>"},{"k":"s","n":"infix:<%>","m":1,"s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Real"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}],"r":"Int:D"},"m":1,"k":"s","n":"infix:<%>"},{"m":1,"n":"infix:<%>","k":"s","s":{"p":[{"n":"$a","t":"int"},{"t":"int","n":"$b"}],"r":"int"}},{"m":1,"n":"infix:<%>","s":{"p":[{"t":"Num","n":"a"},{"n":"b","t":"Num"}],"r":"Mu"},"k":"s"},{"k":"s","n":"infix:<%>","s":{"p":[{"t":"num","n":"$a"},{"t":"num","n":"$b"}],"r":"num"},"m":1},{"m":1,"n":"infix:<%>","s":{"r":"Mu","p":[{"t":"Rational","n":"a"},{"t":"Int","n":"b"}]},"k":"s"},{"m":1,"n":"infix:<%>","k":"s","s":{"p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}]},"n":"infix:<%>","m":1,"k":"s"},{"n":"infix:<%>","k":"s","m":1,"s":{"r":"Duration:D","p":[{"n":"$a","t":"Duration"},{"n":"$b","t":"Real"}]}},{"t":"Sub+{is-pure}","n":"&item","k":"v"},{"k":"s","n":"item","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"x"}]}},{"n":"item","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"m":1},{"s":{"p":[{"t":"Mu","n":"$a"}],"r":"Mu"},"n":"item","k":"s","m":1},{"m":[{"n":"ast","d":"<p>Alias for #method made.</p>","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Returns the payload that was set with make.</p>","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"made"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method Int(Match:D: --&gt; Int:D)</code></pre></p><p>Tries to convert stringified result of the matched text into Int.</p><p><pre><code>say ('12345' ~~ /234/).Int;       # OUTPUT: «234␤»\nsay ('12345' ~~ /234/).Int.^name; # OUTPUT: «Int␤»\n# the next line produces a warning about using Nil (result of a no match) in numeric context\nsay ('one-two' ~~ /234/).Int;     # OUTPUT: «0␤» # because Nil.Int returns 0</code></pre></p>","k":"m","n":"Int","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"m":0,"n":"BUILD","k":"s","s":{"r":"Mu","p":[{"n":":$orig?","t":"Any"},{"t":"Any","n":":$from?"},{"n":":$pos","t":"Any"},{"n":":$made","t":"Any"},{"n":":$shared","t":"Any"},{"n":":$braid","t":"Any"},{"t":"Any","n":":$list"},{"t":"Any","n":":$hash"},{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"clone","d":"<p>Defined as:</p><p><pre><code>method clone()</code></pre></p><p>Clones the Match object.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"d":"<p>Defined as:</p><p><pre><code>method Bool(Capture:D: --&gt; Bool:D)</code></pre></p><p>Returns True on successful and False on unsuccessful matches. Please note that any zero-width match can also be successful.</p><p><pre><code>say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\nsay $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»</code></pre></p>","m":1,"n":"Bool"},{"d":"<p>Defined as:</p><p><pre><code>method Bool(Capture:D: --&gt; Bool:D)</code></pre></p><p>Returns True on successful and False on unsuccessful matches. Please note that any zero-width match can also be successful.</p><p><pre><code>say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\nsay $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»</code></pre></p>","k":"m","m":1,"n":"Bool","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method prematch(Match:D: --&gt; Str:D)</code></pre></p><p>Returns the part of the original string leading up to the match.</p><p><pre><code>'abcdefg' ~~ /cd/;\nsay $/.prematch;          # OUTPUT: «ab␤»\n\n# will return a list of three match objects\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.[1].prematch;      # OUTPUT: «abc1␤»</code></pre></p>","n":"prematch"},{"d":"<p>Defined as:</p><p><pre><code>method postmatch(Match:D: --&gt; Str:D)</code></pre></p><p>Returns the part of the original string following the match.</p><p><pre><code>'abcdefg' ~~ /cd/;\nsay $/.postmatch;         # OUTPUT: «efg␤»\n\n# will return a list of three match objects\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.[1].postmatch;     # OUTPUT: «3def␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"postmatch","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"caps","k":"m","d":"<p>Returns a list of pairs, with the index or submatch name as key and the submatches as values. The list is ordered by starting position of the submatches.</p>","m":0},{"n":"chunks","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Returns a list of pairs, with the index or submatch name as key and the submatches as values. The list is ordered by starting position of the submatches.</p><p>Those parts of the string that were not matched by submatches are interleaved with the other pairs, with the string ~ as key.</p>","m":0,"k":"m"},{"m":0,"k":"m","n":"replace-with","s":{"p":[{"n":"$replacement","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL","k":"s"},{"n":"!sort-on-from-pos","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"$captures"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"!MATCH-CAPTURES"}],"b":"C","k":"c","a":[{"k":"v","n":"@!list","t":"List"},{"k":"v","n":"%!hash","t":"Hash"}],"mro":["NQPMatchRole","Capture","Cool"],"n":"Match","t":"Match","d":"<p><pre><code>class Match is Capture is Cool does NQPMatchRole {}</code></pre></p><p>Match objects are the result of a successful regex match, this does include any zero-width match. They store a reference to the original string (.orig), positional and named captures, the positions of the start and end of the match in the original string, and a payload referred to as AST (abstract syntax tree), which can be used to build data structures from complex regexes and grammars.</p><p>The last match is also stored in the $¢ Match object, which is lexically scoped to the regex, that is, only available from within the regular expression, as shown here:</p><p><pre><code>my $c;\n'abc' ~~ /.$${ $c = $¢ }/;\nsay $c; # OUTPUT: «｢c｣␤»</code></pre></p><p>In this case, we are running the code among curly braces when the match occurs, in this case the last letter in the string (actually, the last, indicated by the double $, character); $c gets the value of the cursor $¢, which contains the Match; when used with say, the Match is stringified by calling .Str on it. This $¢ offers a way of capturing the Match inside a regular expression; outside, you need to use $/</p><p><pre><code>my $c; 'camelia' ~~ /&lt;[ l m ]&gt; {$c = $¢}/;\nsay $c; # OUTPUT: «｢m｣␤»\nsay $/; # OUTPUT: «｢m｣␤»</code></pre></p><p>Note: This feature works only from Raku version 2018.02. It would have returned Nil with any previous version. Alternatively and prior to that version, you could use $/ which, inside the regex, has the same value:</p><p><pre><code>'123' ~~ / (\\d) { say $0; say $/; } \\d+ /; # OUTPUT: «｢1｣␤｢1｣␤ 0 =&gt; ｢1｣␤»</code></pre></p><p>The main difference between $/ and $¢ is scope: the latter only has a value inside the regex:</p><p><pre><code>'123' ~~ / (\\d) { say $/; say $¢; } \\d+ /; # OUTPUT: «｢1｣␤ 0 =&gt; ｢1｣␤｢1｣␤ 0 =&gt; ｢1｣␤»\nsay \"¢ → \", $¢, \"/ is $/\"; ; # OUTPUT: «¢ → Nil/ is 123␤»\n</code></pre></p><p>Submatches are also Match objects (or lists of Match objects, if the corresponding regex was quantified), so each match object can be seen as the root of a tree of match objects.</p><p>A Match object can also hold the result of a match in progress (while the grammar engine is running), in which case the pos method returns the current position. This view on Match objects is only visible if you call code from within a regex.</p><p>Note (deprecated): There is a synonym for this class, Cursor, defined as:</p><p><pre><code>my constant Cursor = Match</code></pre></p><p>Initially, it was used to keep track of initial position in regex matches. In current versions, it's an alias for Match.</p>"},{"d":"<p><pre><code>multi sub infix:&lt;-&gt;($a, $b --&gt; Numeric:D)</code></pre></p><p>Subtraction operator.</p><p>Coerces both arguments to Numeric and subtracts the second from the first.</p>","k":"v","n":"&infix:<->","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<->","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]}},{"k":"s","m":1,"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"},"n":"infix:<->"},{"n":"infix:<->","k":"s","s":{"p":[{"t":"Real","n":"a"},{"n":"b","t":"Real"}],"r":"Mu"},"m":1},{"n":"infix:<->","k":"s","m":1,"s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}]}},{"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"},"m":1,"k":"s","n":"infix:<->"},{"n":"infix:<->","s":{"p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"n":"infix:<->","s":{"p":[{"n":"$a","t":"num"},{"t":"num","n":"$b"}],"r":"num"},"k":"s"},{"n":"infix:<->","k":"s","m":1,"s":{"p":[{"t":"Range","n":"r"},{"n":"v","t":"Real"}],"r":"Mu"}},{"n":"infix:<->","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}]}},{"m":1,"k":"s","n":"infix:<->","s":{"p":[{"t":"Rational","n":"a"},{"t":"Int","n":"b"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Int","n":"a"},{"t":"Rational","n":"b"}],"r":"Mu"},"k":"s","n":"infix:<->"},{"m":1,"n":"infix:<->","k":"s","s":{"p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}],"r":"Complex:D"}},{"m":1,"s":{"p":[{"t":"Complex","n":"a"},{"t":"Real","n":"b"}],"r":"Complex:D"},"n":"infix:<->","k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Real","n":"a"},{"n":"b","t":"Complex"}],"r":"Complex:D"},"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}],"r":"Duration:D"}},{"m":1,"k":"s","n":"infix:<->","s":{"r":"Instant:D","p":[{"n":"$a","t":"Instant"},{"t":"Real","n":"$b"}]}},{"m":1,"n":"infix:<->","k":"s","s":{"p":[{"n":"$a","t":"Duration"},{"n":"$b","t":"Real"}],"r":"Duration:D"}},{"k":"s","s":{"p":[{"t":"Duration","n":"$a"},{"n":"$b","t":"Duration"}],"r":"Duration:D"},"n":"infix:<->","m":1},{"m":1,"k":"s","s":{"r":"Duration:D","p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}]},"n":"infix:<->"},{"n":"infix:<->","s":{"p":[{"n":"a","t":"DateTime"},{"n":"b","t":"Duration"}],"r":"DateTime:D"},"k":"s","m":1},{"s":{"p":[{"t":"Date","n":"date"},{"t":"Int","n":"$x"}],"r":"Date:D"},"k":"s","n":"infix:<->","m":1},{"s":{"p":[{"n":"$a","t":"Date"},{"n":"$b","t":"Date"}],"r":"Int:D"},"m":1,"n":"infix:<->","k":"s"},{"n":"&infix:<..>","d":"<p><pre><code>multi sub infix:&lt;..&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</code></pre></p><p>Range operator</p><p>Constructs a Range from the arguments.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","n":"infix:<..>","s":{"p":[{"n":"$min","t":"Any"},{"n":"$max","t":"Any"}],"r":"Mu"}},{"n":"&postfix:<-->","k":"v","d":"<p><pre><code>multi sub postfix:&lt;--&gt;($x is rw) is assoc&lt;non&gt;</code></pre></p><p>Decrements its argument by one and returns the original value.</p><p><pre><code>my $x = 3;\nsay $x--;   # OUTPUT: «3␤»\nsay $x;     # OUTPUT: «2␤»</code></pre></p><p>It works by calling the pred method (for predecessor) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p><p>Note that this does not necessarily return its argument;e.g., for undefined values, it returns 0:</p><p><pre><code>my $x;\nsay $x--;   # OUTPUT: «0␤»\nsay $x;     # OUTPUT: «-1␤»</code></pre></p><p>Decrement on Str will decrement the number part of a string and assign the resulting string to the container. A is rw-container is required. Crossing 0 is prohibited and throws X::AdHoc.</p><p><pre><code>my $filename = \"somefile-003.txt\";\nsay $filename-- for 1..3;\n# OUTPUT: «somefile-003.txt␤somefile-002.txt␤somefile-001.txt␤»</code></pre></p>","t":"Sub+{Precedence}"},{"k":"s","m":1,"n":"postfix:<-->","s":{"r":"Mu","p":[{"n":"$a","t":"Mu"}]}},{"n":"postfix:<-->","s":{"p":[{"n":"$a","t":"Mu"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"n":"postfix:<-->","s":{"p":[{"t":"Int","n":"$a"}],"r":"Int:D"},"k":"s"},{"s":{"r":"int","p":[{"n":"$a","t":"int"}]},"k":"s","m":1,"n":"postfix:<-->"},{"n":"postfix:<-->","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"$a","t":"Bool"}]}},{"n":"postfix:<-->","m":1,"s":{"r":"Mu","p":[{"n":"$a","t":"Bool"}]},"k":"s"},{"s":{"p":[{"n":"$a","t":"Num"}],"r":"Mu"},"m":1,"n":"postfix:<-->","k":"s"},{"n":"postfix:<-->","m":1,"s":{"r":"Num","p":[{"t":"Num","n":"$a"}]},"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"num","n":"$a"}],"r":"num"},"n":"postfix:<-->"},{"n":"&ord","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[{"n":"$s","t":"Cool"}]},"m":1,"k":"s","n":"ord"},{"n":"&lastcall","t":"Sub+{Callable[Bool]}","k":"v"},{"s":{"p":[],"r":"Bool"},"k":"s","m":0,"n":"lastcall"},{"k":"v","n":"&infix:<≼>","t":"Sub+{is-pure}"},{"s":{"p":[{"n":"$a","t":"Any"},{"n":"$b","t":"Any"}],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<≼>"},{"n":"&next","t":"Sub","k":"v"},{"m":1,"s":{"r":"Nil","p":[]},"n":"next","k":"s"},{"m":1,"n":"next","k":"s","s":{"r":"Nil","p":[{"t":"Label","n":"x"}]}},{"n":"&sign","t":"Sub+{is-pure}","k":"v"},{"s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"},"n":"sign","m":1,"k":"s"},{"k":"s","s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"},"n":"sign","m":1},{"t":"Sub","n":"&end","k":"v"},{"s":{"p":[{"n":"$a","t":"Any"}],"r":"Mu"},"n":"end","m":1,"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub infix:&lt;⊈&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Not a subset of nor equal to operator.</p><p>Returns True if $a is not a subset of $b. Equivalent to !(&lt;=).</p><p><pre><code>say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»\nsay (2,3) ⊄ (2,3,1); # OUTPUT: «False␤»\nsay 4 !(&lt;=) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊈ is codepoint U+2288 (NEITHER A SUBSET OF NOR EQUAL TO).</p>","n":"&infix:<⊈>"},{"k":"s","n":"infix:<⊈>","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Bool:D"}},{"n":"&term:<time>","k":"v","t":"Sub+{Callable[Int:D]}"},{"m":0,"n":"term:<time>","s":{"p":[],"r":"Int:D"},"k":"s"},{"k":"v","n":"&getc","t":"Sub"},{"m":1,"s":{"p":[{"t":"IO::Handle","n":"$fh?"}],"r":"Mu"},"k":"s","n":"getc"},{"n":"&infix:<but>","d":"<p><pre><code>multi sub infix:&lt;but&gt;(Mu $obj1, Mu   $role) is assoc&lt;non&gt;\nmulti sub infix:&lt;but&gt;(Mu $obj1, Mu:D $obj2) is assoc&lt;non&gt;</code></pre></p><p>Creates a copy of $obj with $role mixed in. Since $obj is not modified, but can be used to created immutable values with mixins.</p><p>Instead of a role, you can provide an instantiated object. In this case, the operator will create a role for you automatically. The role will contain a single method named the same as $obj.^name and that returns $obj:</p><p><pre><code>my $forty-two = 42 but 'forty two';\nsay $forty-two+33;    # OUTPUT: «75␤»\nsay $forty-two.^name; # OUTPUT: «Int+{&lt;anon|1&gt;}␤»\nsay $forty-two.Str;   # OUTPUT: «forty two␤»\n</code></pre></p><p>Calling ^name shows that the variable is an Int with an anonymous object mixed in. However, that object is of type Str, so the variable, through the mixin, is endowed with a method with that name, which is what we use in the last sentence.</p><p>We can also mixin classes, even created on the fly.</p><p><pre><code>my $s = 12 but class Warbles { method hi { 'hello' } }.new;\nsay $s.Warbles.hi;    # OUTPUT: «hello␤»\nsay $s + 42;          # OUTPUT: «54␤»\n</code></pre></p><p>To access the mixed-in class, as above, we use the class name as is shown in the second sentence. If methods of the same name are present already, the last mixed in role takes precedence. A list of methods can be provided in parentheses separated by comma. In this case conflicts will be reported at runtime.</p>","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"obj"},{"t":"Mu","n":"rolish"}]},"n":"infix:<but>","k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"obj"},{"n":"rolish","t":"Mu"},{"n":":$value!","t":"Any"}]},"n":"infix:<but>"},{"m":1,"k":"s","s":{"p":[{"n":"obj","t":"Mu"},{"t":"Mu","n":"rolish"}],"r":"Mu"},"n":"infix:<but>"},{"s":{"p":[{"n":"obj","t":"Mu"},{"t":"Mu","n":"$val"}],"r":"Mu"},"m":1,"n":"infix:<but>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"obj"},{"t":"Positional","n":"**@roles"}]},"k":"s","m":1,"n":"infix:<but>"},{"s":{"p":[{"n":"obj","t":"Mu"},{"t":"Positional","n":"**@roles"}],"r":"Mu"},"n":"infix:<but>","k":"s","m":1},{"n":"&full-barrier","k":"v","t":"Sub"},{"k":"s","m":1,"n":"full-barrier","s":{"r":"Nil","p":[]}},{"t":"Sub","n":"&grep","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$test","t":"Mu"},{"n":"+values","t":"Any"},{"t":"Associative","n":"*%a"}]},"n":"grep"},{"m":1,"s":{"r":"Mu","p":[{"n":"$t","t":"Bool"},{"t":"Any","n":"|"}]},"k":"s","n":"grep"},{"n":"&link","t":"Sub","k":"v"},{"k":"s","n":"link","m":1,"s":{"p":[{"t":"Any","n":"$target"},{"t":"Any","n":"$name"}],"r":"Mu"}},{"n":"&kv","t":"Sub","k":"v"},{"m":1,"s":{"p":[{"n":"$x","t":"Any"}],"r":"Mu"},"k":"s","n":"kv"},{"t":"Sub","k":"v","n":"&return"},{"s":{"p":[],"r":"Nil"},"k":"s","m":1,"n":"return"},{"n":"return","s":{"p":[{"n":"x","t":"Mu"}],"r":"Nil"},"k":"s","m":1},{"s":{"p":[{"n":"**@x","t":"Positional"}],"r":"Nil"},"m":1,"n":"return","k":"s"},{"t":"Sub","n":"&nextwith","k":"v"},{"n":"nextwith","k":"s","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0},{"n":"&pick","t":"Sub","k":"v"},{"m":1,"s":{"p":[{"n":"$n","t":"Any"},{"t":"Any","n":"+values"}],"r":"Mu"},"n":"pick","k":"s"},{"k":"v","t":"Sub+{is-pure}","n":"&roots"},{"m":1,"n":"roots","s":{"r":"Mu","p":[{"n":"$x","t":"Any"},{"t":"Cool","n":"$n"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"$x","t":"Any"},{"n":"$n","t":"Numeric"}]},"n":"roots","k":"s"},{"n":"&cos","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"m":1,"k":"s","n":"cos"},{"s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]},"k":"s","n":"cos","m":1},{"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"m":1,"n":"cos","k":"s"},{"n":"&combinations","t":"Sub","k":"v"},{"m":1,"s":{"p":[{"t":"Any","n":"n"},{"n":"k","t":"Any"}],"r":"Seq:D"},"n":"combinations","k":"s"},{"m":1,"n":"combinations","k":"s","s":{"r":"Seq:D","p":[{"n":"n","t":"Any"},{"t":"Range","n":"k"}]}},{"m":1,"s":{"p":[{"n":"n","t":"Iterable"},{"t":"Any","n":"k"}],"r":"Seq:D"},"n":"combinations","k":"s"},{"n":"combinations","s":{"p":[{"t":"Any","n":"n"}],"r":"Seq:D"},"m":1,"k":"s"},{"t":"HyperSeq","mro":["Sequence","PositionalBindFailover","Iterable","Any"],"k":"c","b":"A","m":[{"k":"s","s":{"p":[{"t":"Any","n":":$!configuration!"},{"t":"Any","n":":$!work-stage-head!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILD","m":0},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Iterator"},"d":"<p><pre><code>method iterator(HyperSeq:D: --&gt; Iterator:D)</code></pre></p><p>Returns the underlying iterator.</p>","n":"iterator"},{"s":{"p":[{"n":"$matcher","t":"Any"},{"t":"Associative","n":"*%options"}],"r":"Mu"},"d":"<p><pre><code>method grep(HyperSeq:D: $matcher, *%options)</code></pre></p><p>Applies grep to the HyperSeq similarly to how it would do it on a Seq.</p><p><pre><code>my @hyped = (^10000).map(*²).hyper;\n@hyped.grep( * %% 3 ).say;\n# OUTPUT: «(0 9 36 81 144…»\n</code></pre></p><p>When you use hyper on a Seq, this is the method that is actually called.</p>","k":"m","m":0,"n":"grep"},{"s":{"p":[{"n":"$matcher","t":"Any"},{"n":"*%options","t":"Associative"}],"r":"Mu"},"n":"map","d":"<p><pre><code>method map(HyperSeq:D: $matcher, *%options)</code></pre></p><p>Uses maps on the HyperSeq, generally created by application of hyper to a preexisting Seq.</p>","m":0,"k":"m"},{"n":"invert","d":"<p><pre><code>method invert(HyperSeq:D:)</code></pre></p><p>Inverts the HyperSeq created from a Seq by .hyper.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"hyper","k":"m","m":0,"d":"<p><pre><code>method hyper(HyperSeq:D:)</code></pre></p><p>Returns the object.</p>"},{"k":"m","d":"<p><pre><code>method race(HyperSeq:D:)</code></pre></p><p>Creates a RaceSeq object out of the current one.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"race"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"d":"<p><pre><code>method is-lazy(--&gt; False )</code></pre></p><p>Returns False.</p>","m":0,"n":"is-lazy","k":"m"},{"m":0,"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"sink"},{"n":"configuration","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"}],"a":[{"t":"HyperConfiguration","n":"$.configuration","k":"v"},{"n":"$!work-stage-head","k":"v","t":"Rakudo::Internals::HyperWorkStage"},{"t":"Mu","k":"v","n":"$!list"}],"d":"<p><pre><code>class HyperSeq does Iterable does Sequence { }</code></pre></p><p>An HyperSeq is the intermediate object used when the operator hyper is invoked on a Seq. In general, it's not intended for direct consumption by the developer.</p>","n":"HyperSeq"},{"t":"FatRat","n":"FatRat","a":[{"n":"$.numerator","k":"v","t":"Int"},{"n":"$.denominator","k":"v","t":"Int"}],"b":"C","mro":["Rational[Int,Int]","Real","Numeric","Cool"],"k":"c","m":[{"k":"m","m":0,"s":{"p":[{"n":"$?","t":"Real"},{"n":"*%_","t":"Mu"}],"r":"FatRat"},"n":"FatRat"},{"n":"Rat","m":0,"s":{"p":[{"n":"$?","t":"Real"},{"t":"Mu","n":"*%_"}],"r":"Rat:D"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"numerator","k":"m","m":0},{"m":0,"k":"m","n":"denominator","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL"},{"m":0,"k":"m","s":{"r":"Str:D","p":[{"n":"$base","t":"Int"},{"t":"int","n":"$digits"},{"t":"int","n":"$trailing-zeroes"},{"n":"*%_","t":"Mu"}]},"n":"!base"},{"m":0,"n":"!STRINGIFY","s":{"r":"Mu","p":[{"n":"whole","t":"Any"},{"t":"Any","n":"fract"},{"n":"$digits","t":"int"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"d":"<p><pre><code>class FatRat is Cool does Rational[Int, Int] {}</code></pre></p><p>A FatRat is a rational number stored with arbitrary size numerator and denominator. Arithmetic operations involving a FatRat and optionally Int or Rat objects return a FatRat, avoiding loss of precision.</p><p>Since, unlike Rat, FatRat arithmetics do not fall back Num at some point, there is a risk that repeated arithmetic operations generate pathologically large numerators and denominators.</p><p>There are two common ways to generate FatRat objects: through the FatRat.new(Int, Int) constructor, which generates them from numerator and denominator, or by calling the .FatRat method on an Int or Rat object.</p>"},{"b":"A","n":"Uni","t":"Uni","k":"c","m":[{"n":"list","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"n":"Uni","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p><pre><code>method NFC(Uni:D: --&gt; NFC:D)</code></pre></p><p>Returns a NFC (Normal Form Composed)-converted version of the invocant.</p>","n":"NFC","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"NFD","k":"m","d":"<p><pre><code>method NFD(Uni:D: --&gt; NFD:D)</code></pre></p><p>Returns a NFD (Normal Form Decomposed)-converted version of the invocant.</p>","m":0},{"m":0,"n":"NFKC","d":"<p><pre><code>method NFKC(Uni:D: --&gt; NFKC:D)</code></pre></p><p>Returns a NFKC (Normal Form Compatibility Composed)-converted version of the invocant.</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method NFKD(Uni:D: --&gt; NFKD:D)</code></pre></p><p>Returns a NFKD (Normal Form Compatibility Decomposed)-converted version of the invocant.</p>","n":"NFKD"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"codes","k":"m","d":"<p><pre><code>method codes(Uni:D: --&gt; Int:D)</code></pre></p><p>Returns the number of codepoints in the invocant.</p>","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"elems"},{"k":"m","n":"Numeric","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"Int","m":0}],"mro":["Stringy","Positional[uint32]","Any"],"d":"<p><pre><code>class Uni does Positional[uint32] does Stringy { }</code></pre></p><p>Unlike Str, which is made of Grapheme clusters, Uni is string strictly made of Unicode codepoints. That is, base characters and combining characters are separate elements of a Uni instance.</p><p>Uni presents itself with a list-like interface of integer Codepoints.</p><p>Typical usage of Uni is through one of its subclasses, NFC, NFD, NFKD and NFKC, which represent strings in one of the Unicode Normalization Forms of the same name.</p>"},{"n":"&asech","k":"v","t":"Sub+{is-pure}"},{"k":"s","n":"asech","m":1,"s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"}},{"n":"asech","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]}},{"s":{"r":"num","p":[{"t":"num","n":"$x"}]},"n":"asech","k":"s","m":1},{"n":"&postcircumfix:<[; ]>","k":"v","t":"Sub+{is-nodal}"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"@indices","t":"Positional"}],"r":"Mu"},"n":"postcircumfix:<[; ]>","k":"s"},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"@indices","t":"Positional"},{"n":"assignee","t":"Mu"}],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[; ]>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Positional","n":"@indices"},{"n":":$BIND!","t":"Any"}]},"k":"s","n":"postcircumfix:<[; ]>","m":1},{"k":"s","n":"postcircumfix:<[; ]>","m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"n":"@indices","t":"Positional"},{"n":":$delete!","t":"Any"}],"r":"Mu"}},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"@indices","t":"Positional"},{"t":"Any","n":":$exists!"}]},"n":"postcircumfix:<[; ]>","m":1},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Positional","n":"@indices"},{"n":":$kv!","t":"Any"}],"r":"Mu"},"n":"postcircumfix:<[; ]>"},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Positional","n":"@indices"},{"t":"Any","n":":$p!"}]},"n":"postcircumfix:<[; ]>","k":"s","m":1},{"k":"s","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"@indices","t":"Positional"},{"n":":$k!","t":"Any"}],"r":"Mu"},"n":"postcircumfix:<[; ]>"},{"n":"postcircumfix:<[; ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"@indices","t":"Positional"},{"n":":$v!","t":"Any"}]},"m":1,"k":"s"},{"n":"&infix:<=~>","t":"Sub","k":"v"},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"n":"infix:<=~>","m":0},{"k":"v","t":"Sub","n":"&infix:<∘>","d":"<p><pre><code>multi sub infix:&lt;∘&gt;()\nmulti sub infix:&lt;∘&gt;(&amp;f)\nmulti sub infix:&lt;∘&gt;(&amp;f, &amp;g --&gt; Block:D)</code></pre></p><p>The function composition operator infix:&lt;∘&gt; or infix:&lt;o&gt; combines two functions, so that the left function is called with the return value of the right function. If the .count of the left function is greater than 1, the return value of the right function will be slipped into the left function.</p><p>Both .count and .arity of the right-hand side will be maintained.</p><p><pre><code>sub f($p){ say 'f'; $p / 2 }\nsub g($p){ say 'g'; $p * 2 }\n\nmy &amp;composed = &amp;f ∘ &amp;g;\nsay composed 2; # OUTPUT: «g␤f␤2␤»\n# equivalent to:\nsay 2.&amp;g.&amp;f;\n# or to:\nsay f g 2;</code></pre></p><p><pre><code>sub f($a, $b, $c) { [~] $c, $b, $a }\nsub g($str){ $str.comb }\nmy &amp;composed = &amp;f ∘ &amp;g;\nsay composed 'abc'; # OUTPUT: «cba␤»\n# equivalent to:\nsay f |g 'abc';\n</code></pre></p><p>The single-arg candidate returns the given argument as is. The zero-arg candidate returns an identity routine that simply returns its argument.</p><p><pre><code>my &amp;composed = [∘] &amp;uc;\nsay composed 'foo'; # OUTPUT: «FOO␤»\n\nmy &amp;composed = [∘];\nsay composed 'foo'; # OUTPUT: «foo␤»</code></pre></p>"},{"n":"infix:<∘>","m":1,"k":"s","s":{"p":[],"r":"Mu"}},{"s":{"p":[{"n":"&f","t":"Callable"}],"r":"Mu"},"n":"infix:<∘>","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"Callable","n":"&f"},{"t":"Callable","n":"&g"}],"r":"Block:D"},"n":"infix:<∘>","k":"s"},{"n":"&unlink","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[{"n":"*@filenames","t":"Positional"}]},"n":"unlink","k":"s","m":1},{"t":"Signal","n":"SIGTHR","k":"e"},{"k":"v","t":"Sub","n":"&trait_mod:<hides>"},{"n":"trait_mod:<hides>","k":"s","s":{"p":[{"n":"$child","t":"Mu"},{"n":"$parent","t":"Mu"}],"r":"Mu"},"m":1},{"n":"Compiler","mro":["Systemic","Any"],"b":"A","a":[{"t":"Mu","k":"v","n":"$.id"},{"n":"$.release","t":"Mu","k":"v"},{"t":"Mu","n":"$.codename","k":"v"},{"n":"$.name","t":"Str","k":"v"},{"k":"v","t":"Str","n":"$.auth"},{"t":"Version","n":"$.version","k":"v"},{"t":"Blob","n":"$.signature","k":"v"},{"t":"Str","n":"$.desc","k":"v"}],"t":"Compiler","d":"<p><pre><code>class Compiler does Systemic {}</code></pre></p><p>Built-in class for providing compiler related information. Usually accessed through the compiler attribute of the $*PERL dynamic variable.</p><p><pre><code>say $*PERL.compiler; # OUTPUT: «rakudo (2019.03.1.385.ga.643.b.8.be.1)␤»</code></pre></p>","k":"c","m":[{"n":"TWEAK","m":0,"k":"s","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"m":0,"k":"m","n":"backend","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":1,"d":"<p>Returns an unique identifier, a long hexadecimal string</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"id"},{"n":"id","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Returns an unique identifier, a long hexadecimal string</p>","k":"m","m":1},{"s":{"r":"Mu","p":[{"n":":$say","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"verbose-config","m":0},{"d":"<p>It's empty, but it might contain the release number for specific releases.</p>","n":"release","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"codename","d":"<p>It's empty, but it might contain the codename for specific releases.</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"name","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"auth","m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"version"},{"n":"signature","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"desc"},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}]},{"n":"utf8","b":"A","mro":["Blob[uint8]","Positional[uint8]","Stringy","Any"],"m":[{"m":0,"k":"m","s":{"r":"Str","p":[{"n":"*%_","t":"Mu"}]},"n":"encoding"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$action"},{"n":"$got","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!fail-typecheck"},{"m":0,"s":{"p":[{"t":"Any","n":"action"},{"n":"to","t":"Any"},{"n":"from","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!unshift-list","k":"m"},{"s":{"p":[{"n":"to","t":"Any"},{"n":"from","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!spread","m":0,"k":"m"},{"m":0,"n":"!fail-range","k":"m","s":{"r":"Mu","p":[{"n":"$got","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"!push-list","s":{"r":"Mu","p":[{"n":"action","t":"Any"},{"n":"to","t":"Any"},{"t":"Any","n":"from"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"!fail-typecheck-element","m":0,"s":{"r":"Mu","p":[{"n":"action","t":"Any"},{"t":"Any","n":"i"},{"n":"got","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"t":"utf8","k":"c","d":"<p><pre><code>class utf8 does Blob[uint8] is repr('VMArray') {}</code></pre></p><p>A utf8 is a subtype of Blob which is specifically uint8 data for holding UTF-8 encoded text.</p><p><pre><code>my utf8 $b = \"hello\".encode;\nsay $b[1].fmt(\"0x%X\"); # OUTPUT: «0x65␤»</code></pre></p>"},{"k":"e","t":"SocketType","n":"SOCK_STREAM"},{"t":"Signal","k":"e","n":"SIGPWR"},{"k":"ro","b":"C","n":"IO","t":"IO","d":"<p>The role provides no methods, but exists so that IO() coercers, which coerce to IO::Path, correctly type-check the resultant value. The role is implemented by IO::Path and IO::Special.</p><p>See also the related classes IO::Handle and IO::Path.</p>","mro":[]},{"b":"A","mro":["Any"],"k":"c","d":"<p><pre><code>enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));\n</code></pre></p><p><pre><code>class IO::Notification  {\n    class Change {\n        has $.path;\n        has $.event;\n    }\n    ...\n}\n</code></pre></p><p>IO::Notification.watch-path($path) produces a Supply of IO::Notification::Change events for a file or directory.</p><p>Here is a small example that prints the first ten FileChanged-notifications for the current working directory:</p><p><pre><code>my $finish = Promise.new;\nmy $count = 0;\nIO::Notification.watch-path($*CWD).act( -&gt; $change {\n    $count++ if $change.event ~~ FileChanged;\n    say \"($count) $change.path(): $change.event()\";\n    $finish.keep if $count &gt;= 10;\n});\nawait $finish;\n</code></pre></p><p>The type of the change is very much dependent both on the platform and on specific system calls that were used initiate the change. At this point in time you should not rely on the type of change in general, and test your particular situation.</p>","t":"IO::Notification","m":[{"m":0,"s":{"p":[{"n":"$path","t":"Any"},{"n":":$scheduler?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"watch-path","k":"m"}],"n":"IO::Notification"},{"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"IO","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"path"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"event","m":0,"k":"m"},{"m":0,"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"a":[{"k":"v","t":"Mu","n":"$.path"},{"k":"v","t":"Mu","n":"$.event"}],"mro":["Any"],"t":"IO::Notification::Change","k":"c","n":"IO::Notification::Change","b":"A"},{"mro":["IO::Handle"],"k":"c","t":"IO::CatHandle","n":"IO::CatHandle","d":"<p><pre><code>class IO::CatHandle is IO::Handle { }</code></pre></p><p>This class has been available in Rakudo since version 2017.06.</p><p>The IO::CatHandle|/type/IO::CatHandle class provides a means to create an IO::Handle that seamlessly gathers input from multiple IO::Handle and IO::Pipe sources.</p><p>All of the IO::Handle's methods are implemented, and while attempt to use write methods will (currently) throw and exception, an IO::CatHandle is usable anywhere a read-only IO::Handle can be used.</p>","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*@handles","t":"Positional"},{"n":":&on-switch","t":"Callable"},{"t":"Any","n":":$chomp?"},{"n":":$nl-in?","t":"Any"},{"n":":$encoding","t":"Str"},{"n":":$bin","t":"Bool"},{"n":"*%_","t":"Mu"}]},"n":"new","k":"m","d":"<p>Defined as:</p><p><pre><code>method new(*@handles, :&amp;on-switch, :$chomp = True,\n           :$nl-in = [\"\\n\", \"\\r\\n\"], Str :$encoding, Bool :$bin)\n</code></pre></p><p>Creates a new IO::CatHandle object.</p><p>The @handles positional argument indicates a source of handles for the IO::CatHandle to read from and can deal with a mixed collection of Cool, IO::Path, and IO::Handle (including IO::Pipe) objects. As input from IO::CatHandle is processed (so operations won't happen during .new call, but only when @handles' data is needed), it will walk through the @handles list, processing each argument as follows:</p>* <p>the Cool objects will be coerced to IO::Path;</p><br>* <p>IO::Path objects will be opened for reading using the IO::CatHandle's (invocant's) attributes for open calls;</p><br>* <p>un-opened IO::Handle objects will be opened in the same fashion as IO::Path objects;</p><br>* <p>and already opened IO::Handle objects will have all of their attributes set to the attributes of the invocant IO::CatHandle.</p><br><p>In short, all the @handles end up as IO::Handle objects opened in the same mode and with the same attributes as the invocant IO::CatHandle.</p><p>See .on-switch method for details on the :&amp;on-switch named argument, which by default is not set.</p><p>The :$encoding named argument specifies the handle's encoding and accepts the same values as IO::Handle.encoding. Set :$bin named argument to True if you wish the handle to be in binary mode. Attempting to specify both a defined :$encoding and a True :$bin is a fatal error resulting in X::IO::BinaryAndEncoding exception thrown. If neither :$encoding is set nor :$bin set to a true value, the handle will default to utf8 encoding.</p><p>The :$chomp and :$nl-in arguments have the same meaning as in IO::Handle and take and default to the same values.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method next-handle(IO::CatHandle:D: --&gt; IO::Handle:D)</code></pre></p><p>Switches the active source handle to the next handle in the source handle queue, which is the sources given in @handles attribute to .new. The return value is the currently active source handle or Nil if the source handle queue has been exhausted.</p><p>Coerces Cool source \"handles\" to IO::Path; opens IO::Path and unopened IO::Handle source handles for reading using the invocant's $.nl-in, $.chomp, and $.encoding attributes; those same attributes of already-opened IO::Handle objects will be changed to the values of the invocant's attributes.</p><p>This method is called automatically whenever CatHandle's methods require a switch to the next source handle, triggers .on-switch Callable to be called, and is called once during .new call. The .on-switch will continue to be triggered each time this method is called, even after the source handle queue has been exhausted. Note that generally reaching the EOF of the currently active source handle does not trigger the .next-handle call, but rather further read operations that need more data do.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"a\\nb\";\n(my $f2 = 'bar'.IO).spurt: \"c\\nd\";\nwith IO::CatHandle.new: :on-switch{ say '▸ Switching' }, $f1, $f2 {\n    say 'one';\n    .next-handle.^name.say;\n    say 'two';\n    .next-handle.^name.say;\n    say 'three';\n    .next-handle.^name.say;\n    # OUTPUT:\n    # ▸ Switching\n    # one\n    # ▸ Switching\n    # IO::Handle\n    # two\n    # ▸ Switching\n    # Nil\n    # three\n    # ▸ Switching\n    # Nil\n}\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"next-handle","m":0,"k":"m"},{"m":0,"n":"handles","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Seq:D"},"k":"m","d":"<p>Defines as:</p><p><pre><code>method handles(IO::CatHandle:D: --&gt; Seq:D)</code></pre></p><p>Returns a Seq containing the currently-active handle, as well as all the remaining source handles produced by calling next-handle. If the invocant has already been fully-consumed, returns an empty Seq.</p><p>This method is especially handy when working with IO::ArgFiles, where you want to treat each filehandle separately:</p><p><pre><code># print at most the first 2 lines of each file in $*ARGFILES:\n.say for flat $*ARGFILES.handles.map: *.lines: 2</code></pre></p><p>It is acceptable to call this method multiple times; .handles.head is a valid idiom for obtaining the currently-active handle. If, between reification of the elements of the returned Seq the handles get switched by some other means, the next element produced by the Seq would be the next handle of the invocant, not the handle that would've been produced if no switching occurred:</p><p><pre><code>(my $file1 := 'file1'.IO).spurt: \"1a\\n1b\\n1c\";\n(my $file2 := 'file2'.IO).spurt: \"2a\\n2b\\n2c\";\n(my $file3 := 'file3'.IO).spurt: \"3a\\n3b\\n3c\";\nmy $cat := IO::CatHandle.new: $file1, $file2, $file3;\nfor $cat.handles {\n    say .lines: 2;\n    $cat.next-handle;\n}\n# OUTPUT: «(1a 1b)␤(3a 3b)␤»</code></pre></p><p>Likewise, reifying the returned Seq consumes the invocant's source handles and once it is fully reified the invocant becomes fully-consumed.</p>"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method chomp(IO::CatHandle:D:) is rw</code></pre></p><p>Sets the invocant's $.chomp attribute to the assigned value. All source handles, including the active one will use the provided $.chomp value.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\\n\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\\n\";\nwith IO::CatHandle.new: $f1, $f2 {\n    # .chomp is True by default:\n    (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n    .chomp = False;\n    (.get xx 3).perl.say; # OUTPUT: «(\"C\\n\", \"D\\n\", \"E\\n\").Seq␤»\n    .close\n}\n</code></pre></p>","n":"chomp"},{"d":"<p>Defined as:</p><p><pre><code>method comb(IO::CatHandle:D: |args --&gt; Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.comb does, taking the same arguments. Implementations may slurp the contents of all the source handles in their entirety when this method is called.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nIO::CatHandle.new($f1, $f2).comb(2).perl.say;\n# OUTPUT: «(\"fo\", \"ob\", \"ar\").Seq␤»\n</code></pre></p>","k":"m","m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"comb"},{"d":"<p>Defined as:</p><p><pre><code>method split(IO::CatHandle:D: |args --&gt; Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.split does, taking the same arguments. Implementations may slurp the contents of all the source handles in their entirety when this method is called.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nIO::CatHandle.new($f1, $f2).split(/o+/).perl.say;\n# OUTPUT: «(\"f\", \"bar\").Seq␤»\n</code></pre></p>","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"k":"m","n":"split","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method get(IO::CatHandle:D: --&gt; Bool:D)</code></pre></p><p>Returns a single line of input from the handle, with the new line string defined by the value(s) of $.nl-in attribute, which will be removed from the line if $.chomp attribute is set to True. Returns Nil when there is no more input. It is an error to call this method when the handle is in binary mode, resulting in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"a\\nb\\nc\";\n(my $f2 = 'bar'.IO).spurt: \"d\\ne\";\nmy $cat = IO::CatHandle.new: $f1, $f2;\n.say while $_ = $cat.get; # OUTPUT: «a␤b␤c␤d␤e␤»\n</code></pre></p>","n":"get","m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method getc(IO::CatHandle:D: --&gt; Bool:D)</code></pre></p><p>Returns a single character of input from the handle. All the caveats described in IO::Handle.getc apply. Returns Nil when there is no more input. It is an error to call this method when the handle is in binary mode, resulting in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nmy $cat = IO::CatHandle.new: $f1, $f2;\n.say while $_ = $cat.getc; # OUTPUT: «I␤ ␤♥␤ ␤P␤e␤r␤l␤m␤e␤o␤w␤»\n</code></pre></p>","n":"getc","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"read","k":"m","s":{"p":[{"n":"$bytes?","t":"Cool:D"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method read(IO::CatHandle:D: Int(Cool:D) $bytes = 65536 --&gt; Buf:D)</code></pre></p><p>Reads up to $bytes bytes from the handle and returns them in a Buf. $bytes defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). It is permitted to call this method on handles that are not in binary mode.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'meow';\n(my $f2 = 'bar'.IO).spurt: Blob.new: 4, 5, 6;\nwith IO::CatHandle.new: :bin, $f1, $f2 {\n    say .read: 2;    # OUTPUT: «Buf[uint8]:0x&lt;6d 65&gt;␤»\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x&lt;6f 77 04 05 06&gt;␤»\n}\n\n# Non-binary mode is OK too:\nwith IO::CatHandle.new: $f1, $f2 {\n    say .get;        # OUTPUT: «meow␤»\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x&lt;04 05 06&gt;␤»\n}\n</code></pre></p>","m":0},{"s":{"r":"Mu","p":[{"n":"$chars?","t":"Cool:D"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method readchars(IO::CatHandle:D: Int(Cool:D) $chars = 65536 --&gt; Str:D)</code></pre></p><p>Returns a Str of up to $chars characters read from the handle. $chars defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). It is NOT permitted to call this method on handles opened in binary mode and doing so will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'Perl loves to';\n(my $f2 = 'bar'.IO).spurt: ' meow';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    say .readchars: 11;   # OUTPUT: «Perl loves ␤»\n    say .readchars: 1000; # OUTPUT: «to meow␤»\n}\n</code></pre></p>","m":0,"n":"readchars","k":"m"},{"s":{"p":[{"t":"Any","n":":$bin"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method slurp(IO::CatHandle:D:)</code></pre></p><p>Reads all of the available input from all the source handles and returns it as a Buf if the handle is in binary mode or as a Str otherwise. Returns Nil if the source handle queue has been exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nIO::CatHandle.new(      $f1, $f2).slurp.say; # OUTPUT: «foobar␤»\nIO::CatHandle.new(:bin, $f1, $f2).slurp.say; # OUTPUT: «Buf[uint8]:0x&lt;66 6f 6f 62 61 72&gt;␤»\nIO::CatHandle.new                .slurp.say; # OUTPUT: «Nil␤»\n</code></pre></p>","n":"slurp","m":0},{"m":0,"n":"slurp-rest","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method DESTROY(IO::CatHandle:D:)</code></pre></p><p>Calls .close. This method isn't to be used directly, but is something that's called during garbage collection.</p>","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"DESTROY"},{"d":"<p>Defined as:</p><p><pre><code>method close(IO::CatHandle:D: --&gt; True)</code></pre></p><p>Closes the currently active source handle, as well as any already-open source handles, and empties the source handle queue. Unlike a regular IO::Handle, an explicit call to .close is often not necessary on a CatHandle, as merely exhausting all the input closes all the handles that need to be closed.</p><p><pre><code>with IO::CatHandle.new: @bunch-of-handles {\n    say .readchars: 42;\n    .close; # we are done; close all the open handles\n}\n</code></pre></p>","s":{"r":"Bool","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"close"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"encoding","d":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::CatHandle:D:)\nmulti method encoding(IO::CatHandle:D: $new-encoding)</code></pre></p><p>Sets the invocant's $.encoding attribute to the provided value. Valid values are the same as those accepted by IO::Handle.encoding (use value Nil to switch to binary mode). All source handles, including the active one will use the provided $.encoding value.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nwith IO::CatHandle.new: $f1, $f2 {\n    # .encoding is 'utf8' by default:\n    .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n    .encoding: Nil; # switch to binary mode\n    .slurp.say; # OUTPUT: «Buf[uint8]:0x&lt;72 6c 6d 65 6f 77&gt;␤»\n}\n</code></pre></p>","k":"m","m":1},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::CatHandle:D:)\nmulti method encoding(IO::CatHandle:D: $new-encoding)</code></pre></p><p>Sets the invocant's $.encoding attribute to the provided value. Valid values are the same as those accepted by IO::Handle.encoding (use value Nil to switch to binary mode). All source handles, including the active one will use the provided $.encoding value.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nwith IO::CatHandle.new: $f1, $f2 {\n    # .encoding is 'utf8' by default:\n    .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n    .encoding: Nil; # switch to binary mode\n    .slurp.say; # OUTPUT: «Buf[uint8]:0x&lt;72 6c 6d 65 6f 77&gt;␤»\n}\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"$enc","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"encoding","m":1},{"d":"<p>Defined as:</p><p><pre><code>method eof(IO::CatHandle:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the read operations have exhausted the source handle queue, including the contents of the last handle. Note: calling this method may cause one or more .on-switch calls, while the source handle queue is examined, and the source handle queue may get exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nwith IO::CatHandle.new: :on-switch{ print 'SWITCH! ' }, $f1, $f2 {\n                   # OUTPUT: «SWITCH! »\n    .eof.say;      # OUTPUT: «False␤»\n    .readchars(3);\n    .eof.say;      # OUTPUT: «SWITCH! False␤»\n\n    .slurp;        # OUTPUT: «SWITCH! »\n    .eof.say;      # OUTPUT: «True␤»\n}\n</code></pre></p><p>The same caveats for non-seekable handles and empty files that apply to IO::Handle.eof apply here.</p>","n":"eof","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"m":0,"n":"IO","d":"<p>Defined as:</p><p><pre><code>method IO(IO::CatHandle:D:)</code></pre></p><p>Alias for .path</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"path","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method path(IO::CatHandle:D:)</code></pre></p><p>Returns the value of .path attribute of the currently active source handle, or Nil if the source handle queue has been exhausted. Basically, if your CatHandle is based on files, this is the way to get the path of the file the CatHandle is currently reading from.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\nmy $line;\nmy $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\nsay \"{$cat.path}:{$line++} $_\" for $cat.lines;\n# OUTPUT:\n# foo:1 A\n# foo:2 B\n# foo:3 C\n# bar:1 D\n# bar:2 E\n</code></pre></p>"},{"s":{"r":"Bool:D","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method opened(IO::CatHandle:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the invocant has any source handles, False otherwise.</p><p><pre><code>say IO::CatHandle.new      .opened; # OUTPUT: «False␤»\nsay IO::CatHandle.new($*IN).opened; # OUTPUT: «True␤»\n\n(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\nwith IO::CatHandle.new: $f1 {\n    .opened.say; # OUTPUT: «True␤»\n    .slurp;\n    .opened.say; # OUTPUT: «False␤»\n}\n</code></pre></p>","m":0,"n":"opened","k":"m"},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method lock(IO::CatHandle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --&gt; True)</code></pre></p><p>Same as IO::Handle.lock. Returns Nil if the source handle queue has been exhausted.</p><p>Locks only the currently active source handle. The .on-switch Callable can be used to conveniently lock/unlock the handles as they're being processed by the CatHandle.</p>","m":0,"n":"lock"},{"m":0,"n":"nl-in","k":"m","d":"<p>Defined as:</p><p><pre><code>method nl-in(IO::CatHandle:D:) is rw</code></pre></p><p>Sets the invocant's $.nl-in attribute to the assigned value, which can be a Str or a List of Str, where each Str object represents the end-of-line string. All source handles, including the active one will use the provided $.nl-in value. Note that source handle boundary is always counted as a new line break.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"DxEx\";\nwith IO::CatHandle.new: $f1, $f2 {\n    # .nl-in is [\"\\n\", \"\\r\\n\"] by default:\n    (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n    .nl-in = 'x';\n    (.get xx 3).perl.say; # OUTPUT: «(\"C\", \"D\", \"E\").Seq␤»\n    .close\n}\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method seek(IO::CatHandle:D: |c)</code></pre></p><p>Calls .seek on the currently active source handle, forwarding it all the arguments, and returns the result. Returns Nil if the source handle queue has been exhausted. NOTE: this method does NOT perform any source handle switching, so seeking past the end of the current source handle will NOT seek to the next source handle in the queue and seeking past the beginning of the current source handle is a fatal error. Also see .next-handle, to learn the details on when source handles are switched.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    .get.say;                     # OUTPUT: «foo␤»\n    .seek: -2, SeekFromCurrent;\n    .readchars(2).say;            # OUTPUT: «oo␤»\n    .seek: 1000, SeekFromCurrent; # this doesn't switch to second handle!\n    .readchars(3).say;            # OUTPUT: «bar␤»\n    try .seek: -4;                # this won't seek to previous handle!\n    say ~$!;                      # OUTPUT: «Failed to seek in filehandle: 22␤»\n}\n</code></pre></p>","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"m":0,"k":"m","n":"seek"},{"n":"tell","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"},"d":"<p>Defined as:</p><p><pre><code>method tell(IO::CatHandle:D: --&gt; Int:D)</code></pre></p><p>Calls .tell on the currently active source handle and returns the result. Returns Nil if the source handle queue has been exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    .get.say;                   # OUTPUT: «foo␤»\n    .tell.say;                  # OUTPUT: «3␤»\n    .seek: -2, SeekFromCurrent;\n    .tell.say;                  # OUTPUT: «1␤»\n    say .readchars: 3;          # OUTPUT: «oob␤»\n    .tell.say;                  # OUTPUT: «2␤»\n    }\n</code></pre></p>","m":0,"k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method t(IO::CatHandle:D: --&gt; Bool:D)</code></pre></p><p>Calls .t, which tells if the handle is a TTY, on the currently active source handle and returns the result. If the source handle queue has been exhausted, returns False.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\nwith IO::CatHandle.new: $f1, $*IN {\n    repeat { .t.say } while .next-handle; # OUTPUT: «False␤True␤»\n}\n</code></pre></p>","m":0,"n":"t","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"n":"unlock","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method unlock(IO::CatHandle:D:)</code></pre></p><p>Same as IO::Handle.unlock. Returns Nil if the source handle queue has been exhausted.</p><p>Unlocks only the currently active source handle. The .on-switch Callable can be used to conveniently lock/unlock the handles as they're being processed by the CatHandle.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method native-descriptor(IO::CatHandle:D: --&gt; Int:D)</code></pre></p><p>Returns the native-descriptor of the currently active source handle or Nil if the source handle queue has been exhausted.</p><p>Since the CatHandle closes a source handle, once it's done with it, it's possible for successive source handles to have the same native descriptor, if they were passed to .new as Cool or IO::Path objects.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nwith IO::CatHandle.new: $f1, $f2, $*IN {\n    repeat { .native-descriptor.say } while .next-handle;\n    # OUTPUT: «13␤13␤9␤»\n}\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"native-descriptor","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method open(IO::CatHandle:D: --&gt; IO::CatHandle:D)</code></pre></p><p>Returns the invocant. The intent of this method is to merely make CatHandle workable with things that open IO::Handle. You never have to call this method intentionally.</p>","m":0,"n":"open","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"IO::CatHandle"}},{"m":1,"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"k":"m","n":"flush","d":"<p>Defined as:</p><p><pre><code>multi method flush(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>"},{"n":"out-buffer","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method out-buffer(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","m":1,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"}},{"m":1,"n":"printf","d":"<p>Defined as:</p><p><pre><code>multi method printf(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method print-nl(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","n":"print-nl","s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"k":"m","m":1},{"m":1,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"write","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method write(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>"},{"n":"WRITE","d":"<p>Defined as:</p><p><pre><code>multi method WRITE(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"m":1,"k":"m"},{"n":"READ","d":"<p>Defined as:</p><p><pre><code>multi method EOF(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"k":"m","m":1},{"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"m":1,"k":"m","n":"EOF"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>has &amp;.on-switch is rw</code></pre></p><p>One of the attributes that can be set during .new call and changed later by assigning to. By default is not specified. Takes a Callable with .count of 0, 1, 2, or Inf. Gets called every time .next-handle is, which happens once during .new call and then each time a source handle is switched to the next one in the queue, or when the .next-handle method is called manually.</p><p>If the .count of &amp;.on-switch is 0, it receives no arguments; if it's 1, it receives the currently active handle, and if it's 2 or Inf, it receives the currently active handle, and the last active handle as positional arguments (in that order). On the very first &amp;.on-switch execution, the \"last active handle\" argument is Nil. Upon source handle queue exhaustion the \"currently active handle\" argument is Nil, and all the executions made afterwards have both arguments as Nil.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\nmy $line;\nmy $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\nsay \"{$cat.path}:{$line++} $_\" for $cat.lines;\n# OUTPUT:\n# foo:1 A\n# foo:2 B\n# foo:3 C\n# bar:1 D\n# bar:2 E\n</code></pre></p><p><pre><code>my @old-stuff;\nsub on-switch ($new, $old) {\n    $new and $new.seek: 1, SeekFromBeginning;\n    $old and @old-stuff.push: $old.open.slurp: :close;\n}\n\n(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\nmy $cat = IO::CatHandle.new: :&amp;on-switch, $f1, $f2;\n$cat.lines.perl.say; # OUTPUT: «(\"\", \"B\", \"C\", \"\", \"E\").Seq␤»\n@old-stuff.perl.say; # OUTPUT: «[\"A\\nB\\nC\", \"D\\nE\"]␤»\n</code></pre></p>","n":"on-switch"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"s","n":"BUILDALL"},{"m":0,"k":"m","n":"!WORDS","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"!LINES","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"@handles","t":"Positional"},{"t":"Callable","n":"&!on-switch"},{"t":"Any","n":"$!chomp"},{"n":"$!nl-in","t":"Any"},{"n":"$encoding","t":"Any"},{"t":"Any","n":"$bin"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"!SET-SELF","m":0}],"b":"A","a":[{"t":"Mu","n":"$!handles","k":"v"},{"t":"Mu","n":"$!active-handle","k":"v"},{"n":"$.chomp","k":"v","t":"Mu"},{"n":"$.nl-in","t":"Mu","k":"v"},{"n":"$.encoding","t":"Str","k":"v"},{"n":"&.on-switch","k":"v","t":"Callable"},{"n":"$.path","k":"v","t":"Mu"},{"t":"Mu","n":"$!PIO","k":"v"},{"t":"Mu","n":"$.chomp","k":"v"},{"n":"$.nl-in","t":"Mu","k":"v"},{"n":"$.nl-out","t":"Str:D","k":"v"},{"t":"Str","n":"$.encoding","k":"v"},{"n":"$!decoder","k":"v","t":"Encoding::Decoder"},{"k":"v","t":"Encoding::Encoder","n":"$!encoder"},{"t":"int","n":"$!out-buffer","k":"v"}]},{"t":"IO::ArgFiles","b":"A","a":[{"k":"v","n":"$!handles","t":"Mu"},{"n":"$!active-handle","t":"Mu","k":"v"},{"n":"$.chomp","t":"Mu","k":"v"},{"n":"$.nl-in","k":"v","t":"Mu"},{"n":"$.encoding","t":"Str","k":"v"},{"n":"&.on-switch","k":"v","t":"Callable"},{"t":"Mu","n":"$.path","k":"v"},{"k":"v","t":"Mu","n":"$!PIO"},{"n":"$.chomp","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.nl-in"},{"t":"Str:D","n":"$.nl-out","k":"v"},{"k":"v","t":"Str","n":"$.encoding"},{"k":"v","n":"$!decoder","t":"Encoding::Decoder"},{"k":"v","t":"Encoding::Encoder","n":"$!encoder"},{"k":"v","t":"int","n":"$!out-buffer"}],"d":"<p><pre><code>class IO::ArgFiles is IO::CatHandle { }</code></pre></p><p>This class exists for backwards compatibility reasons and provides no additional methods to IO::CatHandle, so it can be used in the same way as it, for instance, in this way:</p><p><pre><code>my $argfiles = IO::ArgFiles.new(@*ARGS);\n.say for $argfiles.lines;\n</code></pre></p><p>If invoked with perl6 io-argfiles.p6 *.p6 it will print the contents of all the files with that extension in the directory. However, that is totally equivalent to:</p><p><pre><code>my $argfiles = IO::CatHandle.new(@*ARGS);\n.say for $argfiles.lines;\n</code></pre></p>","m":[{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"n":"IO::ArgFiles","mro":["IO::CatHandle"],"k":"c"},{"mro":["IO::Handle"],"n":"IO::Pipe","k":"c","b":"A","a":[{"t":"Mu","k":"v","n":"$.proc"},{"k":"v","t":"Mu","n":"$!on-read"},{"n":"$!on-write","k":"v","t":"Mu"},{"t":"Mu","n":"$!on-close","k":"v"},{"t":"Mu","n":"$!on-native-descriptor","k":"v"},{"t":"Mu","k":"v","n":"$!eof"},{"n":"$!closed","k":"v","t":"Mu"},{"t":"Mu","k":"v","n":"$.path"},{"k":"v","t":"Mu","n":"$!PIO"},{"t":"Mu","n":"$.chomp","k":"v"},{"n":"$.nl-in","t":"Mu","k":"v"},{"n":"$.nl-out","k":"v","t":"Str:D"},{"n":"$.encoding","k":"v","t":"Str"},{"n":"$!decoder","t":"Encoding::Decoder","k":"v"},{"t":"Encoding::Encoder","n":"$!encoder","k":"v"},{"k":"v","n":"$!out-buffer","t":"int"}],"t":"IO::Pipe","d":"<p><pre><code>class IO::Pipe is IO::Handle {}</code></pre></p><p>An IO::Pipe object closely corresponds to a UNIX pipe. It has one end where it consumes string or binary data, and another where it reproduces the same data. It is buffered, so that a write without a read doesn't immediately block.</p><p>Pipes can be easily constructed with sub run and Proc::Async.new.</p>","m":[{"k":"m","s":{"p":[{"t":"Any","n":":$!on-close!"},{"n":":$enc","t":"Any"},{"n":":$bin","t":"Any"},{"n":":$!on-read","t":"Any"},{"n":":$!on-write","t":"Any"},{"n":":$!on-native-descriptor","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"TWEAK"},{"s":{"p":[{"t":"Any","n":"$"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"READ"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"EOF"},{"n":"WRITE","s":{"p":[{"t":"Any","n":"$data"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"flush"},{"d":"<p>Defined as:</p><p><pre><code>method close(IO::Pipe: --&gt; Proc:D)</code></pre></p><p>Closes the pipe and returns Proc object from which the pipe originates.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"close","k":"m"},{"n":"opened","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","n":"t","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"native-descriptor","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method IO(IO::Pipe: --&gt; IO::Path:U)</code></pre></p><p>Returns an IO::Path type object.</p>","k":"m","n":"IO","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"path","d":"<p>Defined as:</p><p><pre><code>method path(IO::Pipe: --&gt; IO::Path:U)</code></pre></p><p>Returns an IO::Path type object.</p>"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"proc","k":"m"},{"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL"}]},{"a":[{"t":"Str","n":"$.what","k":"v"}],"d":"<p><pre><code>class IO::Special does IO { }\n</code></pre></p><p>Used as a $.path attribute in filehandles for special standard input $*IN and output $*OUT and $*ERR. Provides a bridged interface of IO::Handle, mostly file tests and stringification.</p>","t":"IO::Special","b":"A","mro":["IO","Any"],"n":"IO::Special","m":[{"k":"m","n":"new","d":"<p><pre><code>method new(:$!what!)\n</code></pre></p><p>Takes a single required attribute what. It is unlikely that you will ever need to construct one of these objects yourself.</p>","s":{"p":[{"t":"Str","n":"what"},{"t":"Mu","n":"*%_"}],"r":"IO::Special:D"},"m":0},{"n":"IO","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method IO(IO::Special:D: --&gt; IO::Special)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say $*IN.path.IO.what;  # OUTPUT: «&lt;STDIN&gt;␤»\nsay $*IN.path.what;     # OUTPUT: «&lt;STDIN&gt;␤»</code></pre></p>","k":"m"},{"n":"e","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"d":"<p><pre><code>method e(IO::Special:D: --&gt; True)</code></pre></p><p>The 'exists' file test operator, always returns True.</p>"},{"k":"m","d":"<p><pre><code>method d(IO::Special:D: --&gt; False)</code></pre></p><p>The 'directory' file test operator, always returns False.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"d","m":0},{"m":0,"d":"<p><pre><code>method f(IO::Special:D: --&gt; False)</code></pre></p><p>The 'file' file test operator, always returns False.</p>","n":"f","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"}},{"s":{"r":"Int","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>method s(IO::Special:D: --&gt; 0)</code></pre></p><p>The 'size' file test operator, always returns 0.</p>","m":0,"n":"s"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"m":0,"k":"m","n":"l","d":"<p><pre><code>method l(IO::Special:D: --&gt; False)</code></pre></p><p>The 'symbolic links' file test operator, always returns False.</p>"},{"d":"<p><pre><code>method r(IO::Special:D: --&gt; Bool)</code></pre></p><p>The 'read access' file test operator, returns True if and only if this instance represents the standard input handle(&lt;STDIN&gt;).</p>","n":"r","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"m":0,"k":"m","d":"<p><pre><code>method w(IO::Special:D: --&gt; Bool)</code></pre></p><p>The 'write access' file test operator, returns True only if this instance represents either the standard output (&lt;STOUT&gt;) or the standard error (&lt;STDERR&gt;) handle.</p>","s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"n":"w"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"x","d":"<p><pre><code>method x(IO::Special:D: --&gt; False)</code></pre></p><p>The 'execute access' file test operator, always returns False.</p>","k":"m"},{"n":"modified","d":"<p><pre><code>method modified(IO::Special:D: --&gt; Instant)</code></pre></p><p>The last modified time for the filehandle. It always returns an Instant type object.</p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Instant"}},{"n":"accessed","m":0,"d":"<p><pre><code>method accessed(IO::Special:D: --&gt; Instant)</code></pre></p><p>The last accessed time for the filehandle. It always returns an Instant type object.</p>","k":"m","s":{"r":"Instant","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p><pre><code>method changed(IO::Special:D: --&gt; Instant)</code></pre></p><p>The last changed time for the filehandle. It always returns an Instant type object.</p>","m":0,"s":{"r":"Instant","p":[{"n":"*%_","t":"Mu"}]},"n":"changed","k":"m"},{"n":"mode","k":"m","m":0,"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]}},{"n":"what","d":"<p><pre><code>say $*IN.path.what;  # OUTPUT: «&lt;STDIN&gt;␤»\nsay $*OUT.path.what; # OUTPUT: «&lt;STDOUT&gt;␤»\nsay $*ERR.path.what; # OUTPUT: «&lt;STDERR&gt;␤»</code></pre></p><p>Returns one of the strings '&lt;STDIN&gt;', '&lt;STDOUT&gt;', or '&lt;STDERR&gt;', specifying the type of the special IO device.</p>","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0}],"k":"c"},{"m":[{"m":0,"n":"recv","k":"m","d":"<p><pre><code>method recv(IO::Socket:D: Cool $elems = Inf, :$bin)</code></pre></p><p>Receive a packet and return it, either as a Blob if :bin was passed, or a Str if not. Receives up to $elems or 65535 (whichever is smaller) bytes or characters.</p><p>Fails if the socket is not connected.</p>","s":{"p":[{"t":"Cool","n":"$limit?"},{"n":":$bin","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"d":"<p><pre><code>method read(IO::Socket:D: Int(Cool) $bytes)</code></pre></p><p>Reads $bytes bytes from the socket and returns them in a Blob.</p><p>Fails if the socket is not connected.</p>","n":"read","k":"m","s":{"r":"Mu","p":[{"t":"Cool","n":"$bufsize"},{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"nl-in","k":"m"},{"n":"get","d":"<p>Defined as:</p><p><pre><code>method get(IO::Socket:D: --&gt; Str:D)</code></pre></p><p>Reads a single line of input from the socket, removing the trailing newline characters (as set by .nl-in). Returns Nil, if no more input is available.</p><p>Fails if the socket is not connected.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"lines","m":0},{"d":"<p><pre><code>method print(IO::Socket:D: Str(Cool) $string)</code></pre></p><p>Writes the supplied string to the socket, thus sending it to other end of the connection. The binary version is #method write.</p><p>Fails if the socket is not connected.</p>","m":0,"s":{"r":"Bool","p":[{"t":"Cool","n":"$string"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"print"},{"m":0,"k":"m","d":"<p><pre><code>method put(IO::Socket:D: Str(Cool) $string)</code></pre></p><p>Writes the supplied string, with a \\n appended to it, to the socket, thus sending it to other end of the connection.</p><p>Fails if the socket is not connected.</p>","s":{"p":[{"n":"$string","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"put"},{"k":"m","d":"<p><pre><code>method write(IO::Socket:D: Blob:D $buf)</code></pre></p><p>Writes the supplied buffer to the socket, thus sending it to other end of the connection. The string version is #method print.</p><p>Fails if the socket is not connected.</p>","m":0,"s":{"r":"Bool","p":[{"n":"$buf","t":"Blob"},{"n":"*%_","t":"Mu"}]},"n":"write"},{"n":"close","m":0,"k":"m","d":"<p><pre><code>method close(IO::Socket:D)</code></pre></p><p>Closes the socket.</p><p>Fails if the socket is not connected.</p>","s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"native-descriptor","m":0},{"m":0,"n":"!ensure-coders","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"}],"k":"ro","t":"IO::Socket","b":"C","a":[{"k":"v","t":"Mu","n":"$!PIO"},{"t":"Str","n":"$.encoding","k":"v"},{"t":"Mu","n":"$.nl-in","k":"v"},{"t":"Str:D","k":"v","n":"$.nl-out"},{"k":"v","n":"$!decoder","t":"Encoding::Decoder"},{"t":"Encoding::Encoder","n":"$!encoder","k":"v"}],"d":"<p><pre><code>role IO::Socket { ... }</code></pre></p><p>IO::Socket contains read and write methods for sockets. It is usually used through IO::Socket::INET.</p>","mro":[],"n":"IO::Socket"},{"a":[{"k":"v","n":"$.host","t":"Str"},{"t":"Int","k":"v","n":"$.port"},{"n":"$.localhost","k":"v","t":"Str"},{"k":"v","t":"Int","n":"$.localport"},{"n":"$.backlog","t":"Int","k":"v"},{"t":"Bool","n":"$.listening","k":"v"},{"k":"v","n":"$.family","t":"Mu"},{"n":"$.proto","k":"v","t":"Mu"},{"t":"Mu","n":"$.type","k":"v"},{"t":"Mu","n":"$!PIO","k":"v"},{"t":"Str","k":"v","n":"$.encoding"},{"n":"$.nl-in","t":"Mu","k":"v"},{"k":"v","n":"$.nl-out","t":"Str:D"},{"t":"Encoding::Decoder","n":"$!decoder","k":"v"},{"k":"v","n":"$!encoder","t":"Encoding::Encoder"}],"mro":["IO::Socket","Any"],"d":"<p><pre><code>class IO::Socket::INET does IO::Socket {}\n</code></pre></p><p>IO::Socket::INET provides TCP sockets, both the server and the client side.</p><p>For UDP support, please see IO::Socket::Async.</p><p>Here is an example of a very simplistic \"echo\" server that listens on localhost, port 3333:</p><p><pre><code>my $listen = IO::Socket::INET.new( :listen,\n                                   :localhost&lt;localhost&gt;,\n                                   :localport(3333) );\nloop {\n    my $conn = $listen.accept;\n    try {\n        while my $buf = $conn.recv(:bin) {\n            $conn.write: $buf;\n        }\n    }\n    $conn.close;\n\n    CATCH {\n          default { .payload.say;      }\n    }\n\n}\n</code></pre></p><p>And a client that connects to it, and prints out what the server answers:</p><p><pre><code>my $conn = IO::Socket::INET.new( :host&lt;localhost&gt;,\n                                 :port(3333) );\n$conn.print: 'Hello, Raku';\nsay $conn.recv;\n$conn.close;\n</code></pre></p><p>Please bear in mind that this is a synchronous connection; an attempt by any of the nodes to write without the other reading will produce an Could not receive data from socket: Connection reset by peer error.</p>","n":"IO::Socket::INET","m":[{"s":{"p":[{"n":"$host","t":"Any"},{"t":"Any","n":"$port"},{"t":"ProtocolFamily","n":":$family?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"connect","k":"m"},{"m":0,"n":"listen","k":"m","s":{"p":[{"t":"Any","n":"$localhost"},{"t":"Any","n":"$localport"},{"n":":$family?","t":"ProtocolFamily"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"accept"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"host","m":0},{"n":"port","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"localhost"},{"n":"localport","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"n":"backlog","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"listening","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"family"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"proto"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"type","m":0},{"m":0,"k":"m","n":"encoding","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"nl-out","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0},{"n":"!initialize","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m","n":"!ensure-coders","m":0}],"b":"A","t":"IO::Socket::INET","k":"c"},{"b":"A","t":"IO::Socket::Async","mro":["Any"],"n":"IO::Socket::Async","m":[{"n":"new","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"$str","t":"Any"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method print(Str $str --&gt; Promise)</code></pre></p><p>Attempt to send $str on the IO::Socket::Async that will have been obtained indirectly via connect or listen, returning a Promise that will be kept with the number of bytes sent or broken if there was an error sending.</p>","m":0,"n":"print"},{"d":"<p><pre><code>method write(Blob $b --&gt; Promise)</code></pre></p><p>This method will attempt to send the bytes in $b on the IO::Socket::Async that will have been obtained indirectly via connect or listen, returning a Promise that will be kept with the number of bytes sent or broken if there was an error sending.</p>","s":{"r":"Mu","p":[{"t":"Blob","n":"$b"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"write","m":0},{"d":"<p><pre><code>method close()</code></pre></p><p>Close the connected client IO::Socket::Async which will have been obtained from the listen Supply or the connect Promise.</p><p>In order to close the underlying listening socket created by listen you can close the Tap. See listen for examples.</p>","m":0,"k":"m","s":{"r":"Bool","p":[{"t":"Mu","n":"*%_"}]},"n":"close"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$host"},{"t":"Any","n":"$port"},{"t":"Any","n":":$enc?"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}]},"n":"connect","d":"<p><pre><code>method connect(Str $host, Int $port --&gt; Promise)</code></pre></p><p>Attempts to connect to the TCP server specified by $host and $port, returning a Promise that will either be kept with a connected IO::Socket::Async or broken if the connection cannot be made.</p>"},{"s":{"p":[{"n":"$host","t":"Any"},{"t":"Any","n":"$port"},{"t":"Any","n":"$backlog?"},{"n":":$enc?","t":"Any"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method listen(Str $host, Int $port --&gt; Supply)</code></pre></p><p>Creates a listening socket on the specified $host and $port, returning a Supply to which the accepted client IO::Socket::Asyncs will be emitted. This Supply should be tapped start listening for client connections. You can use $port = 0 if you want the operating system to find one for you.</p><p>To close the underlying listening socket, the Tap returned by tapping the listener should be closed.</p><p>For example, when using tap:</p><p><pre><code>my $listener = IO::Socket::Async.listen('127.0.0.1', 8080);\nmy $tap = $listener.tap({ ... });\n\n# When you want to close the listener\n$tap.close;\n</code></pre></p><p>Or when using whenever:</p><p><pre><code>my $listener = IO::Socket::Async.listen('127.0.0.1', 5000);\nmy $tap;\nreact {\n    $tap = do whenever $listener -&gt; $conn { ... }\n}\n\n# When you want to close the listener, you can still use:\n$tap.close;\n</code></pre></p>","n":"listen","k":"m"},{"m":0,"k":"m","n":"native-descriptor","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int"}},{"d":"<p><pre><code>method udp(IO::Socket::Async:U: :$broadcast --&gt; IO::Socket::Async)</code></pre></p><p>Returns an initialized IO::Socket::Async client object that is configured to send UDP messages using print-to or write-to. The :broadcast adverb will set the SO_BROADCAST option which will allow the socket to send packets to a broadcast address.</p>","m":0,"n":"udp","s":{"r":"Mu","p":[{"n":":$broadcast","t":"Any"},{"t":"Any","n":":$enc?"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"$host","t":"Any"},{"t":"Any","n":"$port"},{"n":":$broadcast","t":"Any"},{"t":"Any","n":":$enc?"},{"n":":$scheduler?","t":"Any"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method bind-udp(IO::Socket::Async:U: Str() $host, Int() $port, :$broadcast --&gt; IO::Socket::Async)</code></pre></p><p>This returns an initialized IO::Socket::Async server object that is configured to receive UDP messages sent to the specified $host and $port and is equivalent to listen for a TCP socket. The :broadcast adverb can be specified to allow the receipt of messages sent to the broadcast address.</p>","n":"bind-udp","k":"m"},{"d":"<p><pre><code>method print-to(IO::Socket::Async:D: Str() $host, Int() $port, Str() $str --&gt; Promise)</code></pre></p><p>This is the equivalent of print for UDP sockets that have been created with the udp method, it will try send a UDP message of $str to the specified $host and $port returning a Promise that will be kept when the data is successfully sent or broken if it was unable to send the data. In order to send to a broadcast address the :broadcast flag must have been specified when the socket was created.</p>","s":{"p":[{"n":"$host","t":"Any"},{"n":"$port","t":"Any"},{"n":"$str","t":"Any"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"print-to","k":"m","m":0},{"k":"m","d":"<p><pre><code>method write-to(IO::Socket::Async:D: Str() $host, Int() $port, Blob $b --&gt; Promise)</code></pre></p><p>This is the equivalent of write for UDP sockets that have been created with the udp method. It will try send a UDP message comprised of the bytes in the Blob $b to the specified $host and $port returning a Promise that will be kept when the data is successfully sent or broken if it was unable to send the data. In order to send to a broadcast address the :broadcast flag must have been specified when the socket was created.</p>","s":{"r":"Mu","p":[{"t":"Any","n":"$host"},{"t":"Any","n":"$port"},{"t":"Blob","n":"$b"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"write-to"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"enc","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"peer-host","d":"<p><pre><code>method peer-host(--&gt; Str)</code></pre></p><p>Returns the IP address of the remote end of this socket.</p>"},{"k":"m","n":"peer-port","d":"<p><pre><code>method peer-port(--&gt; Int)</code></pre></p><p>Returns the port of the remote end of this socket.</p>","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p><pre><code>method socket-host(--&gt; Str)</code></pre></p><p>Returns the IP address of the local end of this socket.</p>","m":0,"n":"socket-host","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"socket-port","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method socket-port(--&gt; Int)</code></pre></p><p>Returns the port of the local end of this socket.</p>","m":0},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0}],"k":"c","a":[{"k":"v","n":"$!VMIO","t":"Mu"},{"t":"int","n":"$!udp","k":"v"},{"k":"v","n":"$.enc","t":"Mu"},{"t":"Mu","n":"$!encoder","k":"v"},{"t":"Mu","k":"v","n":"$!close-promise"},{"t":"Mu","k":"v","n":"$!close-vow"},{"t":"Str","k":"v","n":"$.peer-host"},{"k":"v","t":"IO::Socket::Async::Port-Number","n":"$.peer-port"},{"k":"v","t":"Str","n":"$.socket-host"},{"n":"$.socket-port","t":"IO::Socket::Async::Port-Number","k":"v"}],"d":"<p><pre><code>class IO::Socket::Async {}</code></pre></p><p>IO::Socket::Async|/type/IO::Socket::Async provides asynchronous sockets, for both the server and the client side.</p><p>Here is a simple example of a simple \"hello world\" HTTP server that listens on port 3333:</p><p><pre><code>react {\n    whenever IO::Socket::Async.listen('0.0.0.0', 3333) -&gt; $conn {\n        whenever $conn.Supply.lines -&gt; $line {\n            $conn.print: qq:heredoc/END/;\n                HTTP/1.1 200 OK\n                Content-Type: text/html; charset=UTF-8\n                Content-Encoding: UTF-8\n\n                &lt;html&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;Hello World!&lt;/h1&gt;\n                    &lt;p&gt;{ $line }&lt;/p&gt;\n                &lt;/body&gt;\n                &lt;/html&gt;\n                END\n            $conn.close;\n        }\n    }\n    CATCH {\n        default {\n            say .^name, ': ', .Str;\n            say \"handled in $?LINE\";\n        }\n    }\n}\n</code></pre></p><p>And a client that connects to it, and prints out what the server answers:</p><p><pre><code>await IO::Socket::Async.connect('127.0.0.1', 3333).then( -&gt; $promise {\n    given $promise.result {\n        .print(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\");\n        react {\n            whenever .Supply() -&gt; $v {\n                $v.print;\n                done;\n            }\n        }\n        .close;\n    }\n});\n</code></pre></p><p>IO::Socket::Async can also send and receive UDP messages An example server that outputs all the data it receives would be:</p><p><pre><code>my $socket = IO::Socket::Async.bind-udp('localhost', 3333);\n\nreact {\n    whenever $socket.Supply -&gt; $v {\n        if $v.chars &gt; 0 {\n            say $v;\n        }\n    }\n}\n</code></pre></p><p>And an associated client might be:</p><p><pre><code>my $socket = IO::Socket::Async.udp();\nawait $socket.print-to('localhost', 3333, \"Hello, Raku!\");\n</code></pre></p><p>The CATCH phaser can be included to deal specifically with problems that might occur in this kind of sockets, such as a port being already taken:</p><p><pre><code>react {\n    whenever IO::Socket::Async.listen('0.0.0.0', 3000) -&gt; $conn {\n        whenever $conn.Supply.lines -&gt; $line {\n            $conn.print: qq:heredoc/END/;\n                HTTP/1.1 200 OK\n                Content-Type: text/html; charset=UTF-8\n                Content-Encoding: UTF-8\n\n                &lt;html&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;Hello World!&lt;/h1&gt;\n                    &lt;p&gt;{ $line }&lt;/p&gt;\n                &lt;/body&gt;\n                &lt;/html&gt;\n                END\n            $conn.close;\n        }\n        QUIT {\n            default {\n                say .^name, '→ ', .Str;\n                say \"handled in line $?LINE\";\n            }\n        }\n    }\n\n}\n# Will print this, if address 3000 is already in use:\n# X::AdHoc→ address already in use\n# handled in 23\n</code></pre></p><p>Main difference with using other phasers such as CATCH is that this kind of exception will be caught within the whenever block and will put exiting the program, or not, under your control.</p>"},{"t":"Int","k":"ss","n":"IO::Socket::Async::Port-Number"},{"mro":["Tap"],"t":"IO::Socket::Async::ListenSocket","b":"A","k":"c","n":"IO::Socket::Async::ListenSocket","m":[{"n":"TWEAK","m":0,"k":"s","s":{"r":"Mu","p":[{"n":":$!VMIO-tobe","t":"Promise"},{"t":"Promise","n":":$!socket-host"},{"t":"Promise","n":":$!socket-port"},{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"n":"&on-close","t":"Callable"},{"t":"Promise","n":":$VMIO-tobe"},{"n":":$socket-host","t":"Promise"},{"n":":$socket-port","t":"Promise"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"new"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int"},"n":"native-descriptor"},{"n":"socket-host","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"socket-port","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]}}],"a":[{"n":"$!VMIO-tobe","k":"v","t":"Promise"},{"k":"v","n":"$.socket-host","t":"Promise"},{"t":"Promise","k":"v","n":"$.socket-port"},{"n":"&!on-close","k":"v","t":"Callable"}]},{"t":"IO::Handle","n":"IO::Handle","m":[{"s":{"p":[{"n":":$encoding","t":"Any"},{"t":"Any","n":":$bin"},{"n":":$!path?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"TWEAK","k":"s"},{"n":"do-not-close-automatically","s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"t":"Any","n":":$r"},{"n":":$w","t":"Any"},{"n":":$x","t":"Any"},{"n":":$a","t":"Any"},{"t":"Any","n":":$update"},{"n":":$rw","t":"Any"},{"t":"Any","n":":$rx"},{"n":":$ra","t":"Any"},{"n":":$mode","t":"Any"},{"n":":$create","t":"Any"},{"t":"Any","n":":$append"},{"t":"Any","n":":$truncate"},{"t":"Any","n":":$exclusive"},{"n":":$bin","t":"Any"},{"n":":$enc","t":"Any"},{"n":":$chomp?","t":"Any"},{"t":"Any","n":":$nl-in?"},{"n":":$nl-out?","t":"Str"},{"t":"Any","n":":$out-buffer"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"open","k":"m","d":"<p>Defined as:</p><p><pre><code>method open(IO::Handle:D:\n    :$bin, :$enc, :$chomp, :$nl-in, Str:D :$nl-out,\n    Str :$mode,\n    :$r, :$w, :$a, :$x, :$update, :$rw, :$rx, :$ra,\n    :$create, :$append, :$truncate, :$exclusive,\n    :$out-buffer,\n    --&gt; IO::Handle:D\n)\n</code></pre></p><p>Opens the handle in one of the modes. Fails with appropriate exception if the open fails.</p><p>See description of individual methods for the accepted values and behavior of :$chomp, :$nl-in, :$nl-out, and :$enc. The values for parameters default to the invocant's attributes and if any of them are provided, the attributes will be updated to the new values. Specify :$bin set to True instead of :$enc to indicate the handle should be opened in binary mode. Specifying undefined value as :$enc is equivalent to not specifying :$enc at all. Specifying both a defined encoding as :$enc and :$bin set to true will cause X::IO::BinaryAndEncoding exception to be thrown.</p><p>The open mode defaults to non-exclusive, read only (same as specifying :r) and can be controlled by a mix of the following arguments:</p><p><pre><code>:r      same as specifying   :mode&lt;ro&gt;  same as specifying nothing\n\n:w      same as specifying   :mode&lt;wo&gt;, :create, :truncate\n:a      same as specifying   :mode&lt;wo&gt;, :create, :append\n:x      same as specifying   :mode&lt;wo&gt;, :create, :exclusive\n\n:update same as specifying   :mode&lt;rw&gt;\n:rw     same as specifying   :mode&lt;rw&gt;, :create\n:ra     same as specifying   :mode&lt;rw&gt;, :create, :append\n:rx     same as specifying   :mode&lt;rw&gt;, :create, :exclusive\n</code></pre></p><p>Support for combinations of modes other than what is listed above is implementation-dependent and should be assumed unsupported. That is, specifying, for example, .open(:r :create) or .open(:mode&lt;wo&gt; :append :truncate) might work or might cause the Universe to implode, depending on a particular implementation. This applies to reads/writes to a handle opened in such unsupported modes as well.</p><p>The mode details are:</p><p><pre><code>:mode&lt;ro&gt;  means \"read only\"\n:mode&lt;wo&gt;  means \"write only\"\n:mode&lt;rw&gt;  means \"read and write\"\n\n:create    means the file will be created, if it does not exist\n:truncate  means the file will be emptied, if it exists\n:exclusive means .open will fail if the file already exists\n:append    means writes will be done at the end of file's current contents\n</code></pre></p><p>Attempts to open a directory, write to a handle opened in read-only mode or read from a handle opened in write-only mode, or using text-reading methods on a handle opened in binary mode will fail or throw.</p><p>In 6.c language, it's possible to open path '-', which will cause open to open (if closed) the $*IN handle if opening in read-only mode or to open the $*OUT handle if opening in write-only mode. All other modes in this case will result in exception being thrown.</p><p>As of 6.d language version, use path '-' is deprecated and it will be removed in future language versions entirely.</p><p>The :out-buffer controls output buffering and by default behaves as if it were Nil. See method out-buffer for details.</p><p>Note (Rakudo versions before 2017.09): Filehandles are NOT flushed or closed when they go out of scope. While they will get closed when garbage collected, garbage collection isn't guaranteed to get run. This means you should use an explicit close on handles opened for writing, to avoid data loss, and an explicit close is recommended on handles opened for reading as well, so that your program does not open too many files at the same time, triggering exceptions on further open calls.</p><p>Note (Rakudo versions 2017.09 and after): Open filehandles are automatically closed on program exit, but it is still highly recommended that you close opened handles explicitly.</p>","m":0},{"n":"out-buffer","d":"<p>Defined as:</p><p><pre><code>method out-buffer(--&gt; Int:D) is rw</code></pre></p><p>Controls output buffering and can be set via an argument to open. Takes an int as the size of the buffer to use (zero is acceptable). Can take a Bool: True means to use default, implementation-defined buffer size; False means to disable buffering (equivalent to using 0 as buffer size).</p><p>Lastly, can take a Nil to enable TTY-based buffering control: if the handle is a TTY, the buffering is disabled, otherwise, default, implementation-defined buffer size is used.</p><p>See flush to write out data currently in the buffer. Changing buffer size flushes the filehandle.</p><p><pre><code>given 'foo'.IO.open: :w, :1000out-buffer {\n    .say: 'Hello world!'; # buffered\n    .out-buffer = 42;       # buffer resized; previous print flushed\n    .say: 'And goodbye';\n    .close; # closing the handle flushes the buffer\n}\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","m":0,"n":"nl-in","d":"<p>Defined as:</p><p><pre><code>method nl-in(--&gt; Str:D) is rw</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to [\"\\x0A\", \"\\r\\n\"]. Takes either a Str or Array of Str specifying input line ending(s) for this handle. If .chomp attribute is set to True, will strip these endings in routines that chomp, such as get and lines.</p><p><pre><code>with 'test'.IO {\n    .spurt: '1foo2bar3foo'; # write some data into our test file\n    my $fh will leave {.close} = .open; # can also set .nl-in via .open arg\n    $fh.nl-in = [&lt;foo bar&gt;]; # set two possible line endings to use;\n    $fh.lines.say; # OUTPUT: (\"1\", \"2\", \"3\").Seq\n}\n</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"d":"<p>Defined as:</p><p><pre><code>method close(IO::Handle:D: --&gt; Bool:D)\nmulti sub close(IO::Handle $fh)</code></pre></p><p>Closes an open filehandle. It's not an error to call close on an already-closed filehandle. Returns True on success. If you close one of the standard filehandles (by default: $*IN, $*OUT, or $*ERR), that is any handle with native-descriptor 2 or lower, you won't be able to re-open such a handle.</p><p>It's a common idiom to use LEAVE phaser for closing the handles, which ensures the handle is closed regardless of how the block is left.</p><p><pre><code>if $do-stuff-with-the-file {\n    my $fh = open \"path-to-file\";\n    LEAVE close $fh;\n    # ... do stuff with the file\n}\n\nsub do-stuff-with-the-file (IO $path-to-file)\n  my $fh = $path-to-file.open;\n\n  # stick a `try` on it, since this will get run even when the sub is\n  # called with wrong arguments, in which case the `$fh` will be an `Any`\n  LEAVE try close $fh;\n\n  # ... do stuff with the file\n}\n\ngiven \"foo/bar\".IO.open(:w) {\n    .spurt: \"I ♥ Raku!\";\n    .close;\n}\n</code></pre></p><p>Note: unlike some other languages, Raku does not use reference counting, and so the filehandles are NOT closed when they go out of scope. While they will get closed when garbage collected, garbage collection isn't guaranteed to get run. This means you must use an explicit close on handles opened for writing, to avoid data loss, and an explicit close is recommended on handles opened for reading as well, so that your program does not open too many files at the same time, triggering exceptions on further open calls.</p><p>Note several methods allow for providing :close argument, to close the handle after the operation invoked by the method completes. As a simpler alternative, the IO::Path type provides many reading and writing methods that let you work with files without dealing with filehandles directly.</p>","m":0,"k":"m","n":"close"},{"n":"eof","d":"<p>Defined as:</p><p><pre><code>method eof(IO::Handle:D: --&gt; Bool:D)</code></pre></p><p>Non-blocking. Returns True if the read operations have exhausted the contents of the handle. For seekable handles, this means current position is at or beyond the end of file and seeking an exhausted handle back into the file's contents will result in eof returning False again.</p><p>On non-seekable handles and handles opened to zero-size files (including special files in /proc/), EOF won't be set until a read operation fails to read any bytes. For example, in this code, the first read consumes all of the data, but it's only until the second read that reads nothing would the EOF on a TTY handle be set:</p><p><pre><code>$ echo \"x\" | perl6 -e 'with $*IN { .read: 10000; .eof.say; .read: 10; .eof.say }'\nFalse\nTrue\n</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method EOF(IO::Handle:D: --&gt; Bool:D)</code></pre></p><p>Indicates whether \"end of file\" has been reached for the data source of the handle; i.e. no more data can be obtained by calling .READ method. Note that this is not the same as eof method, which will return True only if .EOF returns True and all the decoder buffers, if any were used by the handle, are also empty. See .READ for an example implementation.</p>","k":"m","m":0,"n":"EOF"},{"d":"<p>Defined as:</p><p><pre><code>method READ(IO::Handle:D: Int:D \\bytes --&gt; Buf:D)</code></pre></p><p>Called whenever a read operation is performed on the handle. Receives the number of bytes requested to read. Returns a Buf with those bytes which can be used to either fill the decoder buffer or returned from reading methods directly. The result is allowed to have fewer than the requested number of bytes, including no bytes at all.</p><p>If you provide your own .READ, you very likely need to provide your own .EOF as well, for all the features to behave correctly.</p><p>The compiler may call .EOF method any number of times during a read operation to ascertain whether a call to .READ should be made. More bytes than necessary to satisfy a read operation may be requested from .READ, in which case the extra data may be buffered by the IO::Handle or the decoder it's using, to fulfill any subsequent reading operations, without necessarily having to make another .READ call.</p><p><pre><code>class IO::Store is IO::Handle {\n    has @.lines = [];\n\n    submethod TWEAK {\n      self.encoding: 'utf8'; # set up encoder/decoder\n    }\n\n    method WRITE(IO::Handle:D: Blob:D \\data --&gt; Bool:D) {\n      @!lines.push: data;\n      True;\n    }\n\n    method whole() {\n      my Buf $everything = Buf.new();\n      for @!lines -&gt; $b {\n        $everything ~= $b;\n      }\n      return $everything;\n    }\n\n    method READ(IO::Handle:D: Int:D \\bytes --&gt; Buf:D) {\n      my Buf $everything := self.whole();\n      return $everything;\n    }\n\n    method EOF {\n      my $everything = self.whole();\n      !$everything;\n    }\n}\n\nmy $store := IO::Store.new();\n\n$store.print( $_ ) for &lt;one two three&gt;;\nsay $store.read(3).decode; # OUTPUT «one␤»\nsay $store.read(3).decode; # OUTPUT «two␤»\n</code></pre></p><p>In this case, we have programmed the two READ and EOF methods, as well as WRITE, which stores every line in an element in an array. The read method actually calls READ, returning 3 bytes, which correspond to the three characters in the first two elements. Please note that it's the IO::Handle base class the one that is taking care of cursor, since READ just provides a handle into the whole content of the object; the base class will READ 1024 * 1024 bytes at a time. If your object is planned to hold an amount of bytes bigger than that, you will have to handle an internal cursor yourself. That is why in this example we don't actually use the bytes argument.</p>","s":{"p":[{"n":"$bytes","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"READ","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"get","k":"m","d":"<p>Defined as:</p><p><pre><code>method get(IO::Handle:D: --&gt; Str:D)\nmulti sub get (IO::Handle $fh = $*ARGFILES --&gt; Str:D)</code></pre></p><p>Reads a single line of input from the handle, removing the trailing newline characters (as set by .nl-in) if the handle's .chomp attribute is set to True. Returns Nil, if no more input is available. The subroutine form defaults to $*ARGFILES if no handle is given.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>$*IN.get.say;              # Read one line from the standard input\n\nmy $fh = open 'filename';\n$fh.get.say;               # Read one line from a file\n$fh.close;\n\nsay get;                   # Read one line from $*ARGFILES\n</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method getc(IO::Handle:D: --&gt; Str:D)\nmulti sub getc (IO::Handle $fh = $*ARGFILES --&gt; Str:D)</code></pre></p><p>Reads a single character from the input stream. Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown. The subroutine form defaults to $*ARGFILES if no handle is given. Returns Nil, if no more input is available, otherwise operation will block, waiting for at least one character to be available; these caveats apply:</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"getc","k":"m"},{"s":{"r":"Mu","p":[{"n":":$close","t":"Any"},{"t":"Any","n":"c"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method comb(IO::Handle:D: Bool :$close, |args --&gt; Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.comb does, taking the same arguments, closing the handle when done if $close is set to a true value. Implementations may slurp the file in its entirety when this method is called.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open;\nsay \"The file has {+$fh.comb: '♥', :close} ♥s in it\";\n</code></pre></p>","m":0,"n":"comb"},{"s":{"r":"Mu","p":[{"t":"Any","n":":$close"},{"n":"c","t":"Any"}]},"d":"<p>Defined as:</p><p><pre><code>method split(IO::Handle:D: :$close, |c)</code></pre></p><p>Slurps the handle's content and calls Str.split on it, forwarding any of the given arguments. If :$close named parameter is set to True, will close the invocant after slurping.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open;\n$fh.split: '♥', :close; # Returns file content split on ♥\n</code></pre></p>","m":0,"k":"m","n":"split"},{"k":"m","m":1,"n":"words","d":"<p>Defined as:</p><p><pre><code>multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --&gt; Seq:D)\nmulti method words(IO::Handle:D: $limit = Inf, :$close --&gt; Seq:D)</code></pre></p><p>Similar to Str.words, separates the handle's stream on contiguous chunks of whitespace (as defined by Unicode) and returns a Seq of the resultant \"words.\" Takes an optional $limit argument that can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf), to indicate only up-to $limit words must be returned. If Bool :$close named argument is set to True, will automatically close the handle when the returned Seq is exhausted. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my %dict := bag $*IN.words;\nsay \"Most common words: \", %dict.sort(-*.value).head: 5;\n</code></pre></p><p>NOTE: implementations may read more data than necessary when a call to .words is made. That is, $handle.words(2) may read more data than two \"words\" worth of data and subsequent calls to read methods might not read from the place right after the two fetched words. After a call to .words, the file position should be treated as undefined.</p>","s":{"r":"Mu","p":[{"n":"$limit","t":"Any"},{"t":"Any","n":":$close"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":":$close","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"n":"words","k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --&gt; Seq:D)\nmulti method words(IO::Handle:D: $limit = Inf, :$close --&gt; Seq:D)</code></pre></p><p>Similar to Str.words, separates the handle's stream on contiguous chunks of whitespace (as defined by Unicode) and returns a Seq of the resultant \"words.\" Takes an optional $limit argument that can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf), to indicate only up-to $limit words must be returned. If Bool :$close named argument is set to True, will automatically close the handle when the returned Seq is exhausted. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my %dict := bag $*IN.words;\nsay \"Most common words: \", %dict.sort(-*.value).head: 5;\n</code></pre></p><p>NOTE: implementations may read more data than necessary when a call to .words is made. That is, $handle.words(2) may read more data than two \"words\" worth of data and subsequent calls to read methods might not read from the place right after the two fetched words. After a call to .words, the file position should be treated as undefined.</p>"},{"d":"<p>Defined as:</p><p><pre><code>sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --&gt; Seq:D)\nmethod lines(IO::Handle:D:               $limit = Inf, :$close --&gt; Seq:D)</code></pre></p><p>Return a Seq each element of which is a line from the handle (that is chunks delineated by .nl-in). If the handle's .chomp attribute is set to True, then characters specified by .nl-in will be stripped from each line.</p><p>Reads up to $limit lines, where $limit can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf). If :$close is set to True, will close the handle when the file ends or $limit is reached. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p>NOTE: the lines are read lazily, so ensure the returned Seq is either fully reified or is no longer needed when you close the handle or attempt to use any other method that changes the file position.</p><p><pre><code>say \"The file contains \",\n  '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n  \" lines that mention Perl\";\n# OUTPUT: «The file contains 72 lines that mention Perl␤»\n</code></pre></p>","n":"lines","m":1,"s":{"p":[{"n":"$limit","t":"Any"},{"n":":$close","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --&gt; Seq:D)\nmethod lines(IO::Handle:D:               $limit = Inf, :$close --&gt; Seq:D)</code></pre></p><p>Return a Seq each element of which is a line from the handle (that is chunks delineated by .nl-in). If the handle's .chomp attribute is set to True, then characters specified by .nl-in will be stripped from each line.</p><p>Reads up to $limit lines, where $limit can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf). If :$close is set to True, will close the handle when the file ends or $limit is reached. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p>NOTE: the lines are read lazily, so ensure the returned Seq is either fully reified or is no longer needed when you close the handle or attempt to use any other method that changes the file position.</p><p><pre><code>say \"The file contains \",\n  '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n  \" lines that mention Perl\";\n# OUTPUT: «The file contains 72 lines that mention Perl␤»\n</code></pre></p>","s":{"p":[{"t":"Any","n":":$close"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"lines","k":"m","m":1},{"s":{"p":[{"t":"Cool:D","n":"$bytes?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"read","m":0,"d":"<p>Defined as:</p><p><pre><code>method read(IO::Handle:D: Int(Cool:D) $bytes = 65536 --&gt; Buf:D)</code></pre></p><p>Binary reading; reads and returns up to $bytes bytes from the filehandle. $bytes defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). This method can be called even when the handle is not in binary mode.</p><p><pre><code>(my $file = 'foo'.IO).spurt: 'I ♥ Perl';\ngiven $file.open {\n    say .read: 6; # OUTPUT: «Buf[uint8]:0x&lt;49 20 e2 99 a5 20&gt;␤»\n    .close;\n}\n</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method readchars(IO::Handle:D: Int(Cool:D) $chars = 65536 --&gt; Str:D)</code></pre></p><p>Reading chars; reads and returns up to $chars chars (graphemes) from the filehandle. $chars defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $file = 'foo'.IO).spurt: 'I ♥ Perl';\ngiven $file.open {\n    say .readchars: 5; # OUTPUT: «I ♥ P␤»\n    .close;\n}\n</code></pre></p>","n":"readchars","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$chars?","t":"Cool:D"},{"n":"*%_","t":"Mu"}]}},{"m":1,"s":{"r":"Bool","p":[{"n":"$offset","t":"Int"},{"n":"$whence?","t":"SeekType"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"seek","d":"<p>Defined as:</p><p><pre><code>method seek(IO::Handle:D: Int:D $offset, SeekType:D $whence --&gt; True)</code></pre></p><p>Move the file pointer (that is, the position at which any subsequent read or write operations will begin) to the byte position specified by $offset relative to the location specified by $whence which may be one of:</p>* <p>SeekFromBeginning: The beginning of the file.</p><br>* <p>SeekFromCurrent: The current position in the file.</p><br>* <p>SeekFromEnd: The end of the file. Please note that you need to specify a negative offset if you want to position before the end of the file.</p><br>"},{"n":"tell","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method tell(IO::Handle:D: --&gt; Int:D)</code></pre></p><p>Return the current position of the file pointer in bytes.</p>","m":0},{"n":"write","d":"<p>Defined as:</p><p><pre><code>method write(IO::Handle:D: Blob:D $buf --&gt; True)</code></pre></p><p>Writes $buf to the filehandle. This method can be called even when the handle is not in binary mode.</p><p>  </p>","m":0,"k":"m","s":{"p":[{"t":"Blob","n":"$buf"},{"t":"Mu","n":"*%_"}],"r":"Bool"}},{"s":{"p":[{"n":"$buf","t":"Blob"},{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"WRITE","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method WRITE(IO::Handle:D: Blob:D \\data --&gt; Bool:D)</code></pre></p><p>Called whenever a write operation is performed on the handle. Always receives the data as a Blob, even if a textual writing method has been called.</p><p><pre><code>class IO::Store is IO::Handle {\n    has @.lines = [];\n\n    submethod TWEAK {\n        self.encoding: 'utf8'; # set up encoder/decoder\n    }\n\n    method WRITE(IO::Handle:D: Blob:D \\data --&gt; Bool:D) {\n        @!lines.push: data.decode();\n        True;\n    }\n\n    method gist() {\n        return @!lines.join(\"\\n\" );\n    }\n}\nmy $store = IO::Store.new();\nmy $output = $PROCESS::OUT;\n$PROCESS::OUT = $store;\n.say for &lt;one two three&gt;;\n$PROCESS::OUT = $output;\nsay $store.lines(); # OUTPUT «[one␤ two␤ three␤]»\n</code></pre></p><p>In this example we are creating a simple WRITE redirection which stores anything written to the filehandle to an array. Se need to save the standard output first, which we do in $output, and then everything that is printed or said (through say) gets stored in the defined IO::Store class. Two things should be taken into account in this class. By default, IO::Handles are in binary mode, so we need to TWEAK the objects if we want them to work with text. Second, a WRITE operation should return True if successful. It will fail if it does not.</p>"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"opened","d":"<p>Defined as:</p><p><pre><code>method opened(IO::Handle:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the handle is open, False otherwise.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method t(IO::Handle:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the handle is opened to a TTY, False otherwise.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"t"},{"s":{"r":"Bool","p":[{"t":"Bool","n":":$non-blocking?"},{"t":"Bool","n":":$shared?"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method lock(IO::Handle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --&gt; True)</code></pre></p><p>Places an advisory lock on the filehandle. If :$non-blocking is True will fail with X::IO::Lock if lock could not be obtained, otherwise will block until the lock can be placed. If :$shared is True will place a shared (read) lock, otherwise will place an exclusive (write) lock. On success, returns True; fails with X::IO::Lock if lock cannot be placed (e.g. when trying to place a shared lock on a filehandle opened in write mode or trying to place an exclusive lock on a filehandle opened in read mode).</p><p>You can use lock again to replace an existing lock with another one. To remove a lock, close the filehandle or use unlock.</p><p><pre><code># One program writes, the other reads, and thanks to locks either\n# will wait for the other to finish before proceeding to read/write\n\n# Writer\ngiven \"foo\".IO.open(:w) {\n    .lock;\n    .spurt: \"I ♥ Raku!\";\n    .close; # closing the handle unlocks it; we could also use `unlock` method for that\n}\n\n# Reader\ngiven \"foo\".IO.open {\n    .lock: :shared;\n    .slurp.say; # OUTPUT: «I ♥ Raku!␤»\n    .close;\n}\n</code></pre></p>","k":"m","m":0,"n":"lock"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method unlock(IO::Handle:D: --&gt; True)</code></pre></p><p>Removes a lock from the filehandle.</p>","m":0,"n":"unlock"},{"d":"<p>Defined as:</p><p><pre><code>multi method printf(IO::Handle:D: Cool $format, *@args)</code></pre></p><p>Formats a string based on the given format and arguments and .prints the result into the filehandle. See sub sprintf for details on acceptable format directives.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = open 'path/to/file', :w;\n$fh.printf: \"The value is %d\\n\", 32;\n$fh.close;\n</code></pre></p>","m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","n":"printf"},{"d":"<p>Defined as:</p><p><pre><code>method print-nl(IO::Handle:D: --&gt; True)</code></pre></p><p>Writes the value of $.nl-out attribute into the handle. This attribute, by default, is ␤, but see the page on newline for the rules it follows in different platforms and environments.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open: :w, :nl-out(\"\\r\\n\");\n$fh.print: \"some text\";\n$fh.print-nl; # prints \\r\\n\n$fh.close;\n</code></pre></p>","n":"print-nl","m":0,"s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method slurp-rest(IO::Handle:D: :$bin! --&gt; Buf)\nmulti method slurp-rest(IO::Handle:D: :$enc --&gt; Str)</code></pre></p><p>DEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not use it for new code, use .slurp method instead.</p><p>Returns the remaining content of the file from the current file position (which may have been set by previous reads or by seek.) If the adverb :bin is provided a Buf will be returned; otherwise the return will be a Str with the optional encoding :enc.</p>","s":{"p":[{"n":":$bin!","t":"Any"},{"t":"Any","n":":$close"},{"t":"Mu","n":"*%_"}],"r":"Buf:D"},"m":1,"n":"slurp-rest","k":"m"},{"s":{"p":[{"t":"Any","n":":$enc"},{"n":":$bin","t":"Any"},{"t":"Any","n":":$close"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"d":"<p>Defined as:</p><p><pre><code>multi method slurp-rest(IO::Handle:D: :$bin! --&gt; Buf)\nmulti method slurp-rest(IO::Handle:D: :$enc --&gt; Str)</code></pre></p><p>DEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not use it for new code, use .slurp method instead.</p><p>Returns the remaining content of the file from the current file position (which may have been set by previous reads or by seek.) If the adverb :bin is provided a Buf will be returned; otherwise the return will be a Str with the optional encoding :enc.</p>","k":"m","m":1,"n":"slurp-rest"},{"n":"slurp","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method slurp(IO::Handle:D: :$close, :$bin)</code></pre></p><p>Returns all the content from the current file pointer to the end. If the invocant is in binary mode or if $bin is set to True, will return a Buf, otherwise will decode the content using invocant's current .encoding and return a Str.</p><p>If :$close is set to True, will close the handle when finished reading.</p><p>Note: On Rakudo this method was introduced with release 2017.04; $bin arg was added in 2017.10.</p>","s":{"p":[{"n":":$close","t":"Any"},{"t":"Any","n":":$bin"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method spurt(IO::Handle:D: Blob $data, :$close = False)\nmulti method spurt(IO::Handle:D: Cool $data, :$close = False)</code></pre></p><p>Writes all of the $data into the filehandle, closing it when finished, if $close is True. For Cool $data, will use the encoding the handle is set to use (IO::Handle.open or IO::Handle.encoding).</p><p>Behavior for spurting a Cool when the handle is in binary mode or spurting a Blob when the handle is NOT in binary mode is undefined.</p>","n":"spurt","s":{"p":[{"n":"$data","t":"Blob"},{"n":":$close","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"$data","t":"Cool"},{"n":":$close","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"spurt","d":"<p>Defined as:</p><p><pre><code>multi method spurt(IO::Handle:D: Blob $data, :$close = False)\nmulti method spurt(IO::Handle:D: Cool $data, :$close = False)</code></pre></p><p>Writes all of the $data into the filehandle, closing it when finished, if $close is True. For Cool $data, will use the encoding the handle is set to use (IO::Handle.open or IO::Handle.encoding).</p><p>Behavior for spurting a Cool when the handle is in binary mode or spurting a Blob when the handle is NOT in binary mode is undefined.</p>","m":1,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method path(IO::Handle:D:)</code></pre></p><p>For a handle opened on a file this returns the IO::Path that represents the file. For the standard I/O handles $*IN, $*OUT, and $*ERR it returns an IO::Special object.</p>","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"path"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method IO(IO::Handle:D:)</code></pre></p><p>Alias for .path</p>","n":"IO"},{"s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"n":"flush","k":"m","d":"<p>Defined as:</p><p><pre><code>method flush(IO::Handle:D: --&gt; True)</code></pre></p><p>Will flush the handle, writing any of the buffered data. Returns True on success; otherwise, fails with X::IO::Flush.</p><p><pre><code>given \"foo\".IO.open: :w {\n    LEAVE .close;\n    .print: 'something';\n    'foo'.IO.slurp.say; # (if the data got buffered) OUTPUT: «␤»\n    .flush;             # flush the handle\n    'foo'.IO.slurp.say; # OUTPUT: «something␤»\n}\n</code></pre></p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::Handle:D: --&gt; Str:D)\nmulti method encoding(IO::Handle:D: $enc --&gt; Str:D)</code></pre></p><p>Returns a Str representing the encoding currently used by the handle, defaulting to \"utf8\". Nil indicates the filehandle is currently in binary mode. Specifying an optional positional $enc argument switches the encoding used by the handle; specify Nil as encoding to put the handle into binary mode.</p><p>The accepted values for encoding are case-insensitive. The available encodings vary by implementation and backend. On Rakudo MoarVM the following are supported:</p><p></p><p><pre><code>utf8\nutf16\nutf16le\nutf16be\nutf8-c8\niso-8859-1\nwindows-1251\nwindows-1252\nwindows-932\nascii\n</code></pre></p><p>The default encoding is utf8, which undergoes normalization into Unicode NFC (normalization form canonical). In some cases you may want to ensure no normalization is done; for this you can use utf8-c8. Before using utf8-c8 please read Unicode: Filehandles and I/O for more information on utf8-c8 and NFC.</p><p>As of Rakudo 2018.04 windows-932 is also supported which is a variant of ShiftJIS.</p><p>Implementation may choose to also provide support for aliases, e.g. Rakudo allows aliases latin-1 for iso-8859-1 encoding and dashed utf versions: utf-8 and utf-16.</p>","m":1,"n":"encoding","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::Handle:D: --&gt; Str:D)\nmulti method encoding(IO::Handle:D: $enc --&gt; Str:D)</code></pre></p><p>Returns a Str representing the encoding currently used by the handle, defaulting to \"utf8\". Nil indicates the filehandle is currently in binary mode. Specifying an optional positional $enc argument switches the encoding used by the handle; specify Nil as encoding to put the handle into binary mode.</p><p>The accepted values for encoding are case-insensitive. The available encodings vary by implementation and backend. On Rakudo MoarVM the following are supported:</p><p></p><p><pre><code>utf8\nutf16\nutf16le\nutf16be\nutf8-c8\niso-8859-1\nwindows-1251\nwindows-1252\nwindows-932\nascii\n</code></pre></p><p>The default encoding is utf8, which undergoes normalization into Unicode NFC (normalization form canonical). In some cases you may want to ensure no normalization is done; for this you can use utf8-c8. Before using utf8-c8 please read Unicode: Filehandles and I/O for more information on utf8-c8 and NFC.</p><p>As of Rakudo 2018.04 windows-932 is also supported which is a variant of ShiftJIS.</p><p>Implementation may choose to also provide support for aliases, e.g. Rakudo allows aliases latin-1 for iso-8859-1 encoding and dashed utf versions: utf-8 and utf-16.</p>","n":"encoding","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$new-encoding"},{"n":":$replacement","t":"Any"},{"t":"Any","n":":$strict"},{"t":"Bool","n":":$translate-nl?"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"DESTROY","k":"s","m":0,"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]}},{"n":"native-descriptor","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method native-descriptor()</code></pre></p><p>This returns a value that the operating system would understand as a \"file descriptor\" and is suitable for passing to a native function that requires a file descriptor as an argument such as fcntl or ioctl.</p>"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>has $.chomp is rw = True</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to True. Takes a Bool specifying whether the line separators (as defined by .nl-in) should be removed from content when using .get or .lines methods.</p>","n":"chomp","m":0,"k":"m"},{"n":"nl-out","k":"m","d":"<p>Defined as:</p><p><pre><code>has Str:D $.nl-out is rw = \"\\n\";</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to \"\\n\". Takes a Str specifying output line ending for this handle, to be used by methods .put and .say.</p><p><pre><code>with 'test'.IO {\n    given .open: :w {\n        .put: 42;\n        .nl-out = 'foo';\n        .put: 42;\n        .close;\n    }\n    .slurp.perl.say; # OUTPUT: «\"42\\n42foo\"»\n}\n</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0},{"m":0,"k":"m","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"n":"!remember-to-close"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!slurp-all-chars","k":"m","m":0},{"s":{"p":[{"n":"$chars","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"!readchars-slow-path"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$buffer"},{"n":"*%_","t":"Mu"}]},"n":"!set-out-buffer-size","m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!get-line-slow-path"},{"m":0,"n":"!read-slow-path","k":"m","s":{"r":"Mu","p":[{"n":"$bytes","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"!close-all-open-handles","m":0},{"k":"m","n":"!LINES-ITERATOR","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$close"},{"n":"*%_","t":"Mu"}]}},{"n":"!forget-about-closing","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"}],"d":"<p><pre><code>class IO::Handle { }</code></pre></p><p>Instances of IO::Handle encapsulate an handle to manipulate input/output resources. Usually there is no need to create directly an IO::Handle instance, since it will be done by other roles and methods. For instance, an IO::Path object provides an open method that returns an IO::Handle:</p><p><pre><code>my $fh = '/tmp/log.txt'.IO.open;\nsay $fh.^name; # OUTPUT: IO::Handle</code></pre></p><p>The first line is pretty much equivalent to the following piece of code:</p><p><pre><code>my $fh = IO::Handle.new( :path( '/tmp/log.txt'.IO.path ) ).open;</code></pre></p>","a":[{"t":"Mu","n":"$.path","k":"v"},{"t":"Mu","k":"v","n":"$!PIO"},{"n":"$.chomp","k":"v","t":"Mu"},{"n":"$.nl-in","k":"v","t":"Mu"},{"n":"$.nl-out","k":"v","t":"Str:D"},{"t":"Str","k":"v","n":"$.encoding"},{"t":"Encoding::Decoder","n":"$!decoder","k":"v"},{"t":"Encoding::Encoder","k":"v","n":"$!encoder"},{"n":"$!out-buffer","t":"int","k":"v"}],"b":"A","k":"c","mro":["Any"]},{"mro":["Any"],"k":"c","b":"A","m":[{"k":"m","m":1,"n":"select","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":1,"n":"select","s":{"p":[{"n":"$token","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"IO::Spec","d":"<p><pre><code>class IO::Spec { }</code></pre></p><p>Objects of this class are not used directly but as a sub-class specific to the platform perl is running on via the $*SPEC variable which will contain an object of the appropriate type.</p><p>The sub-classes are documented separately, with the platform-specific differences documented in IO::Spec::Cygwin, IO::Spec::QNX, IO::Spec::Unix and IO::Spec::Win32.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","t":"IO::Spec"},{"d":"<p><pre><code>class IO::Spec::Unix is IO::Spec  { }</code></pre></p><p>On object of this type is available via the variable $*SPEC if the Raku interpreter is running on a Unix-like platform.</p><p>The IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>Beware that no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","b":"A","mro":["IO::Spec"],"n":"IO::Spec::Unix","k":"c","m":[{"d":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --&gt; Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem, so no symlinks are followed.</p><p><pre><code>IO::Spec::Unix.canonpath(\"foo//../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Unix.canonpath(\"foo///./../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Unix.canonpath(\"foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «ber␤»</code></pre></p>","m":0,"s":{"p":[{"n":"$patharg","t":"Any"},{"t":"Any","n":":$parent"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m","n":"canonpath"},{"d":"<p>Defined as:</p><p><pre><code>method dir-sep(--&gt; Str:D)</code></pre></p><p>Returns the string \"/\" representing canonical directory separator character.</p><p><pre><code>IO::Spec::Unix.dir-sep.say; # OUTPUT: «/␤»\n</code></pre></p>","n":"dir-sep","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"curdir","k":"m","d":"<p>Defined as:</p><p><pre><code>method curdir()</code></pre></p><p>Returns a string representing the current directory:</p><p><pre><code>say '.' eq $*SPEC.curdir; # OUTPUT: «True␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"n":"updir","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method rootdir(--&gt; Str:D)</code></pre></p><p>Returns string '/', representing root directory.</p>","m":0,"n":"rootdir","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method devnull(--&gt; Str:D)</code></pre></p><p>Returns the string \"/dev/null\" representing the \"Null device\":</p><p><pre><code>$*SPEC.devnull.IO.spurt: \"foo bar baz\";\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"devnull","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method curupdir()</code></pre></p><p>Returns a none Junction of strings representing the current directory and the \"one directory up\":</p><p><pre><code>say $*SPEC.curupdir;                  # OUTPUT: «none(., ..)␤»\nmy @dirs = &lt;. foo .. bar&gt;;\nsay @dirs.grep(* eq $*SPEC.curupdir); # OUTPUT: «(foo bar)␤»\n</code></pre></p><p>Neither foo nor bar are equal to the representation of the current or parent directory, that is why they are returned by grep.</p>","n":"curupdir"},{"d":"<p>Defined as:</p><p><pre><code>method basename(Str:D $path --&gt; Str:D)</code></pre></p><p>Takes a path as a string and returns a possibly-empty portion after the last slash:</p><p><pre><code>IO::Spec::Unix.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Unix.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\nIO::Spec::Unix.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"str","n":"path"},{"n":"*%_","t":"Mu"}]},"n":"basename","k":"m"},{"s":{"r":"Mu","p":[{"t":"str","n":"path"},{"n":"*%_","t":"Mu"}]},"d":"<p>NOTE: Most users would want to use the higher-level routine IO::Path.extension instead of this lower-level version.</p><p>Defined as:</p><p><pre><code>method extension(Str:D $path --&gt; Str:D)</code></pre></p><p>Takes a string representing a base name and returns the characters after the last dot (\".\"), or empty string if no dots are present. The routine makes no attempt to detect path separators and will return everything after the last dot.</p><p><pre><code>$*SPEC.extension('foo.'      ).perl.say;  # OUTPUT: «\"\"␤»\n$*SPEC.extension('foo.txt'   ).perl.say;  # OUTPUT: «\"txt\"␤»\n$*SPEC.extension('foo.tar.gz').perl.say;  # OUTPUT: «\"gz\"␤»\n$*SPEC.extension('foo'       ).perl.say;  # OUTPUT: «\"\"␤»\n$*SPEC.extension('bar.foo/foo').perl.say; # OUTPUT: «\"foo/foo\"␤»</code></pre></p>","m":0,"n":"extension","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method tmpdir(--&gt; IO::Path:D)</code></pre></p><p>Attempts to locate a system's temporary directory by checking several typical directories and environmental variables. Uses current directory if no suitable directories are found.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"tmpdir"},{"m":0,"n":"is-absolute","d":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --&gt; Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\"), even if it has combining character on it:</p><p><pre><code>say IO::Spec::Unix.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Unix.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Unix.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","k":"m","s":{"p":[{"n":"path","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"path","k":"m","d":"<p>Defined as:</p><p><pre><code>method path(--&gt; Seq:D)</code></pre></p><p>Splits the value of %*ENV&lt;PATH&gt; on colons (\":\"), replaces empty parts with \".\", and returns a Seq with each of the resultant parts. Returns an empty Seq if %*ENV&lt;PATH&gt; is not set or is an empty string.</p><p><pre><code>%*ENV&lt;PATH&gt; = 'foo:bar/ber::foo:';\nIO::Spec::Unix.path.perl.say;\n# OUTPUT: «(\"foo\", \"bar/ber\", \".\", \"foo\", \".\").Seq␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$path"},{"n":":$nofile?","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"splitpath","d":"<p>Defined as:</p><p><pre><code>method splitpath(Cool:D $path, :$nofile --&gt; List:D)</code></pre></p><p>Splits the given $path into a list of 3 strings: volume, dirname, and file. The volume is always an empty string, returned for API compatibility with other IO::Spec types. If :$nofile named argument is set to True, the content of the file string is undefined and should be ignored; this is a means to get a performance boost, as implementations may use faster code path when file is not needed.</p><p><pre><code>IO::Spec::Unix.splitpath('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"\", \"C:\\\\foo/\", \"bar.txt\")␤»\n\nIO::Spec::Unix.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n# OUTPUT: «(\"\", \"C:\\\\foo/bar.txt\", \"\")␤»\n\nIO::Spec::Unix.splitpath('/foo/').perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Unix.splitpath('/foo/', :nofile).perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Unix.splitpath('///').perl.say;\n# OUTPUT: «(\"\", \"///\", \"\")␤»\n\nIO::Spec::Unix.splitpath('./').perl.say;\n# OUTPUT: «(\"\", \"./\", \"\")␤»\n\nIO::Spec::Unix.splitpath('.').perl.say;\n# OUTPUT: «(\"\", \"\", \".\")␤»\n\nIO::Spec::Unix.splitpath('').perl.say;\n# OUTPUT: «(\"\", \"\", \"\")␤»\n</code></pre></p>"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Cool","n":"$path"},{"t":"Mu","n":"*%_"}]},"n":"split","d":"<p>Defined as:</p><p><pre><code>method split(Cool:D $path --&gt; List:D)</code></pre></p><p>Splits the given $path into \"volume\", \"dirname\", and \"basename\" and returns the result as a List of three Pairs, in that order. The \"volume\" is always an empty string and exists for consistency with other IO::Spec classes.</p><p><pre><code>IO::Spec::Unix.split('C:/foo/bar.txt').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"C:/foo\"), :basename(\"bar.txt\"))␤»\n\nIO::Spec::Unix.split('/foo/').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\nIO::Spec::Unix.split('///').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"/\"))␤»\n\nIO::Spec::Unix.split('./').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Unix.split('.').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Unix.split('').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»\n</code></pre></p>"},{"m":0,"n":"join","s":{"p":[{"t":"Any","n":"$"},{"n":"dir","t":"Any"},{"n":"file","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method join ($, Str:D $dir, Str:D $file --&gt; Str:D)</code></pre></p><p>Similar to catpath, takes two path fragments and concatenates them, adding or removing a path separator, if necessary, except it will return just $file if both $dir and $file are string '/' or if $dir is the string '.'. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Unix.join($, 'foo', 'bar').say; # OUTPUT: «foo/bar␤»\nIO::Spec::Unix.join($, '/', '/').say;     # OUTPUT: «/␤»\nIO::Spec::Unix.join($, '.', 'foo').say;   # OUTPUT: «foo␤»\nsay $*SPEC.join(True,\".\",\"/foo\");         # OUTPUT: «/foo␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method catpath ($, Str:D $part1, Str:D $part2 --&gt; Str:D)</code></pre></p><p>Takes two path fragments and concatenates them, adding or removing a path separator, if necessary. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec|/type/IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Unix.catpath($, 'some/dir', 'and/more').say;\n# OUTPUT: «some/dir/and/more␤»</code></pre></p>","m":0,"s":{"p":[{"n":"$","t":"Any"},{"n":"dirname","t":"Any"},{"n":"file","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"catpath","k":"m"},{"n":"catdir","d":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --&gt; Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Unix.catdir(&lt;foo/bar ber perl&gt;).say; # OUTPUT: «foo/bar/ber/perl␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*@parts","t":"Positional"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method splitdir(Cool:D $path --&gt; List:D)</code></pre></p><p>Splits the given $path on slashes.</p><p><pre><code>IO::Spec::Unix.splitdir('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\\\\foo\", \"bar.txt\")␤»\n\nIO::Spec::Unix.splitdir('/foo/').perl.say;\n# OUTPUT: «(\"\", \"foo\", \"\")␤»\n\nIO::Spec::Unix.splitdir('///').perl.say;\n# OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\nIO::Spec::Unix.splitdir('./').perl.say;\n# OUTPUT: «(\".\", \"\")␤»\n\nIO::Spec::Unix.splitdir('.').perl.say;\n# OUTPUT: «(\".\",)␤»\n\nIO::Spec::Unix.splitdir('').perl.say;\n# OUTPUT: «(\"\",)␤»\n</code></pre></p>","n":"splitdir","m":0,"s":{"p":[{"t":"Cool","n":"$path"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"catfile","k":"m","d":"<p>Alias for catdir.</p>","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]}},{"d":"<p>Defined as:</p><p><pre><code>method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --&gt; Str:D)</code></pre></p><p>Returns a string that represents $path, but relative to $base path. Both $path and $base may be relative paths. $base defaults to $*CWD.</p>","m":0,"n":"abs2rel","k":"m","s":{"p":[{"n":"$path","t":"Any"},{"n":"$base?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"path","t":"Any"},{"n":"$base?","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method rel2abs(Str() $path, $base = $*CWD --&gt; Str:D)</code></pre></p><p>Returns a string representing $path converted to absolute path, based at $base, which defaults to $*CWD. If $base is not an absolute path, it will be made absolute relative to $*CWD, unless $*CWD and $base are the same.</p><p><pre><code>say $*CWD;                                  # OUTPUT: «\"/home/camelia\".IO␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo';          # OUTPUT: «/home/camelia/foo␤»\nsay IO::Spec::Unix.rel2abs: './';           # OUTPUT: «/home/camelia␤»\nsay IO::Spec::Unix.rel2abs: 'foo/../../';   # OUTPUT: «/home/camelia/foo/../..␤»\nsay IO::Spec::Unix.rel2abs: '/foo/';        # OUTPUT: «/foo␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo', 'bar';   # OUTPUT: «/home/camelia/bar/foo␤»\nsay IO::Spec::Unix.rel2abs: './', '/bar';   # OUTPUT: «/bar␤»\nsay IO::Spec::Unix.rel2abs: '/foo/', 'bar'; # OUTPUT: «/foo␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo/../../', 'bar';\n# OUTPUT: «/home/camelia/bar/foo/../..␤»\n</code></pre></p>","m":0,"n":"rel2abs"}],"t":"IO::Spec::Unix"},{"mro":["IO::Spec::Unix"],"n":"IO::Spec::Win32","m":[{"m":0,"d":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --&gt; Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem.</p><p><pre><code>IO::Spec::Win32.canonpath(\"C:/foo//../bar/../ber\").say;\n# OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\nIO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\").say;\n# OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\nIO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «C:\\ber␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Any","n":"$patharg"},{"n":":$parent","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"canonpath","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --&gt; Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Win32.catdir(&lt;foo/bar ber perl&gt;).say;\n# OUTPUT: «foo\\bar\\ber\\perl␤»</code></pre></p>","s":{"p":[{"t":"Positional","n":"*@dirs"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"catdir"},{"d":"<p>Defined as:</p><p><pre><code>method dir-sep(--&gt; Str:D)</code></pre></p><p>Returns the string ｢\\｣ representing canonical directory separator character.</p><p><pre><code>IO::Spec::Win32.dir-sep.say; # OUTPUT: «\\␤»\n</code></pre></p>","m":0,"n":"dir-sep","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method devnull(--&gt; Str:D)</code></pre></p><p>Returns the string \"nul\" representing the \"Null device\":</p><p><pre><code>$*SPEC.devnull.IO.spurt: \"foo bar baz\";\n</code></pre></p>","n":"devnull","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method rootdir(--&gt; Str:D)</code></pre></p><p>Returns string ｢\\｣, representing root directory.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"rootdir","k":"m"},{"s":{"p":[{"t":"Cool","n":"$path"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method splitdir(Cool:D $path --&gt; List:D)</code></pre></p><p>Splits the given $path on slashes and backslashes.</p><p><pre><code>IO::Spec::Win32.splitdir('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\", \"foo\", \"bar.txt\")␤»\n\nIO::Spec::Win32.splitdir('/foo/').perl.say;\n# OUTPUT: «(\"\", \"foo\", \"\")␤»\n\nIO::Spec::Win32.splitdir('///').perl.say;\n# OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\nIO::Spec::Win32.splitdir('./').perl.say;\n# OUTPUT: «(\".\", \"\")␤»\n\nIO::Spec::Win32.splitdir('.').perl.say;\n# OUTPUT: «(\".\",)␤»\n\nIO::Spec::Win32.splitdir('').perl.say;\n# OUTPUT: «(\"\",)␤»\n</code></pre></p>","k":"m","m":0,"n":"splitdir"},{"s":{"p":[{"n":"path","t":"str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method basename(Str:D $path --&gt; Str:D)</code></pre></p><p>Takes a path as a string and returns a possibly-empty portion after the last slash or backslash:</p><p><pre><code>IO::Spec::Win32.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Win32.basename(\"foo/bar\\\\\").perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Win32.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\nIO::Spec::Win32.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»</code></pre></p>","n":"basename"},{"k":"m","n":"tmpdir","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"path","k":"m","d":"<p>Defined as:</p><p><pre><code>method path(--&gt; Seq:D)</code></pre></p><p>Splits the value of %*ENV&lt;PATH&gt; (or %*ENV&lt;Path&gt; if the former is not set) on semicolons (\";\") and returns a Seq with each of the resultant parts, always adding element \".\" to the head. Removes all double quotes (\") it finds.</p><p><pre><code>%*ENV&lt;PATH&gt; = 'foo;\"bar\"/\"ber\"';\nIO::Spec::Win32.path.perl.say; # OUTPUT: «(\".\", \"foo\", \"bar/ber\").Seq␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"d":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --&gt; Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\") or backslash (\"\\\"), even if they have combining character on them, optionally preceded by a volume:</p><p><pre><code>say IO::Spec::Win32.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","k":"m","n":"is-absolute","m":0,"s":{"r":"Mu","p":[{"n":"$path","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method split(Cool:D $path --&gt; List:D)</code></pre></p><p>Splits the given $path into \"volume\", \"dirname\", and \"basename\" and returns the result as a List of three Pairs, in that order. The \"volume\" is always an empty string and exists for consistency with other IO::Spec classes.</p><p><pre><code>IO::Spec::Win32.split('C:/foo/bar.txt').perl.say;\n# OUTPUT: «(:volume(\"C:\"), :dirname(\"/foo\"), :basename(\"bar.txt\"))␤»\n\nIO::Spec::Win32.split('/foo/').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\nIO::Spec::Win32.split('///').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"\\\\\"))␤»\n\nIO::Spec::Win32.split('./').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Win32.split('.').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Win32.split('').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»\n</code></pre></p>","m":0,"n":"split","s":{"p":[{"t":"Cool","n":"$path"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"vol","t":"Str"},{"n":"$dir","t":"Str"},{"n":"$file","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"join","m":0,"d":"<p>Defined as:</p><p><pre><code>method join (Str:D $volume, Str:D $dir, Str:D $file --&gt; Str:D)</code></pre></p><p>Similar to catpath, takes two path fragments and concatenates them, adding or removing a path separator, if necessary, except it will return just $file if both $dir and $file are string '/' or if $dir is the string '.'. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Win32.join('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir\\and/more␤»\n\nIO::Spec::Win32.join('C:', '.', 'foo.txt').say;\n# OUTPUT: «C:foo.txt␤»\n\nIO::Spec::Win32.join('C:', ｢\\｣, '/').say;\n# OUTPUT: «C:\\␤»\n\nIO::Spec::Win32.join('//server/share', ｢\\｣, '/').say;\n# OUTPUT: «//server/share␤»\n\nIO::Spec::Win32.join('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method splitpath(Cool:D $path, :$nofile --&gt; List:D)</code></pre></p><p>Splits the given $path into a list of 3 strings: volume, dirname, and file. The volume is always an empty string, returned for API compatibility with other IO::Spec types. If :$nofile named argument is set to True, the content of the file string is undefined and should be ignored; this is a means to get a performance boost, as implementations may use faster code path when file is not needed.</p><p><pre><code>IO::Spec::Win32.splitpath('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\", \"\\\\foo/\", \"bar.txt\")␤»\n\nIO::Spec::Win32.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n# OUTPUT: «(\"C:\", \"\\\\foo/bar.txt\", \"\")␤»\n\nIO::Spec::Win32.splitpath('/foo/').perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Win32.splitpath('/foo/', :nofile).perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Win32.splitpath('///').perl.say;\n# OUTPUT: «(\"\", \"///\", \"\")␤»\n\nIO::Spec::Win32.splitpath('./').perl.say;\n# OUTPUT: «(\"\", \"./\", \"\")␤»\n\nIO::Spec::Win32.splitpath('.').perl.say;\n# OUTPUT: «(\"\", \"\", \".\")␤»\n\nIO::Spec::Win32.splitpath('').perl.say;\n# OUTPUT: «(\"\", \"\", \"\")␤»\n</code></pre></p>","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$path"},{"n":":$nofile?","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"splitpath"},{"d":"<p>Defined as:</p><p><pre><code>method catpath (Str:D $volume, Str:D $dir, Str:D $file --&gt; Str:D)</code></pre></p><p>Concatenates a path from given volume, a chain of directories, and file. An empty string can be given for any of the three arguments. No attempt to make the path canonical is made. Use canonpath for that purpose.</p><p><pre><code>IO::Spec::Win32.catpath('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir\\foo.txt␤»\n\nIO::Spec::Win32.catpath('C:', '/some/dir', '').say;\n# OUTPUT: «C:/some/dir␤»\n\nIO::Spec::Win32.catpath('', '/some/dir', 'foo.txt').say;\n# OUTPUT: «/some/dir\\foo.txt␤»\n\nIO::Spec::Win32.catpath('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>","k":"m","m":0,"s":{"p":[{"t":"Str","n":"$vol"},{"n":"dir","t":"Str"},{"t":"Str","n":"file"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"catpath"},{"m":0,"n":"rel2abs","k":"m","d":"<p>Defined as:</p><p><pre><code>method rel2abs(Str() $path, $base = $*CWD --&gt; Str:D)</code></pre></p><p>Returns a string representing $path converted to absolute path, based at $base, which defaults to $*CWD. If $base is not an absolute path, it will be made absolute relative to $*CWD, unless $*CWD and $base are the same.</p><p><pre><code>say $*CWD;                                   # OUTPUT: «\"C:\\Users\\camelia\".IO␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo';          # OUTPUT: «C:\\Users\\camelia\\foo␤»\nsay IO::Spec::Win32.rel2abs: './';           # OUTPUT: «C:\\Users\\camelia␤»\nsay IO::Spec::Win32.rel2abs: 'foo/../../';   # OUTPUT: «C:\\Users\\camelia\\foo\\..\\..␤»\nsay IO::Spec::Win32.rel2abs: '/foo/';        # OUTPUT: «C:\\foo␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo', 'bar';   # OUTPUT: «C:\\Users\\camelia\\bar\\foo␤»\nsay IO::Spec::Win32.rel2abs: './', '/bar';   # OUTPUT: «\\bar␤»\nsay IO::Spec::Win32.rel2abs: '/foo/', 'bar'; # OUTPUT: «C:\\foo␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo/../../', 'bar';\n# OUTPUT: «C:\\Users\\camelia\\bar\\foo\\..\\..␤»\n</code></pre></p>","s":{"p":[{"t":"Any","n":"$path"},{"n":"$base?","t":"Any"},{"n":":$omit-volume","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"$first","t":"Any"},{"n":"*@rest","t":"Positional"},{"t":"Any","n":":$parent"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"n":"!canon-cat"}],"t":"IO::Spec::Win32","k":"c","b":"A","d":"<p><pre><code>class IO::Spec::Win32 is IO::Spec { }</code></pre></p><p>Objects of this class are used not directly but as a sub-class specific to the platform Raku is running on via the $*SPEC variable, which will contain an object of the appropriate type.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>"},{"mro":["IO::Spec::Unix"],"t":"IO::Spec::Cygwin","b":"A","n":"IO::Spec::Cygwin","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$patharg"},{"n":":$parent","t":"Any"},{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --&gt; Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem.</p><p><pre><code>IO::Spec::Cygwin.canonpath(｢C:\\foo\\\\..\\bar\\..\\ber｣).say;\n# OUTPUT: «C:/foo/../bar/../ber␤»\n\nIO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «ber␤»</code></pre></p>","n":"canonpath"},{"s":{"r":"Mu","p":[{"n":"*@paths","t":"Positional"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --&gt; Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Cygwin.catdir(&lt;foo/bar ber perl&gt;).say;\n# OUTPUT: «foo/bar/ber/perl␤»</code></pre></p>","n":"catdir"},{"d":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --&gt; Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\") or backslash (\"\\\"), even if they have combining character on them, optionally preceded by a volume:</p><p><pre><code>say IO::Spec::Cygwin.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","s":{"p":[{"n":"$path","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"is-absolute","m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"tmpdir"},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"abs2rel","m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --&gt; Str:D)</code></pre></p><p>Returns a string that represents $path, but relative to $base path. Both $path and $base may be relative paths. $base defaults to $*CWD. Uses IO::Spec::Win32's semantics.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method rel2abs(|c --&gt; List:D)</code></pre></p><p>Same as IO::Spec::Win32.rel2abs, except replaces backslashes with slashes in the final result.</p>","n":"rel2abs","s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method splitpath(|c --&gt; List:D)</code></pre></p><p>Same as IO::Spec::Win32.splitpath, except replaces backslashes with slashes in all the values of the final result.</p>","m":0,"k":"m","n":"splitpath"},{"m":0,"n":"catpath","d":"<p>Defined as:</p><p><pre><code>method catpath (Str:D $volume, Str:D $dir, Str:D $file --&gt; Str:D)</code></pre></p><p>Same as IO::Spec::Win32.catpath, except will also change all backslashes to slashes at the end:</p><p><pre><code>IO::Spec::Cygwin.catpath('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir/foo.txt␤»\n\nIO::Spec::Cygwin.catpath('C:', '/some/dir', '').say;\n# OUTPUT: «C:/some/dir␤»\n\nIO::Spec::Cygwin.catpath('', '/some/dir', 'foo.txt').say;\n# OUTPUT: «/some/dir/foo.txt␤»\n\nIO::Spec::Cygwin.catpath('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>","s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"$path","t":"Cool"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method split(|c --&gt; List:D)</code></pre></p><p>Same as IO::Spec::Win32.split, except replaces backslashes with slashes in all the values of the final result.</p>","m":0,"n":"split"},{"n":"join","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method join(|c)</code></pre></p><p>Same as IO::Spec::Win32.join, except replaces backslashes with slashes in the final result.</p>"}],"k":"c","d":"<p><pre><code>class IO::Spec::QNX is IO::Spec { }</code></pre></p><p>This sub-class of IO::Spec will be available from the $*SPEC variable for a perl running on Cygwin .</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>"},{"b":"A","n":"IO::Spec::QNX","t":"IO::Spec::QNX","m":[{"s":{"p":[{"t":"Any","n":"$patharg"},{"n":":$parent","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"canonpath","m":0,"k":"m"}],"d":"<p><pre><code>class IO::Spec::QNX is IO::Spec { }</code></pre></p><p>This sub-class of IO::Spec specific to QNX will be available via $*SPEC if the perl is running on QNX.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","mro":["IO::Spec::Unix"],"k":"c"},{"t":"IO::Path","d":"<p><pre><code>class IO::Path is Cool does IO { }\n</code></pre></p><p>IO::Path is the workhorse of IO operations.</p><p>Conceptually, an IO::Path object consists of a volume, a directory, and a basename. It supports both purely textual operations, and operations that access the filesystem, e.g. to resolve a path, or to read all content of a file.</p><p>At creation, each IO::Path object is given information about the current working directory the path might be relative to using the $.CWD attribute (defaults to $*CWD), as well as what operating system semantics should be used for path manipulation using the special IO::Spec type given in the $.SPEC attribute.</p><p>The $.SPEC defaults to the value of $*SPEC, which uses the object suitable for the operating system the code is currently running on. This is the default most code will be comfortable with.</p><p>In certain situations, e.g. testing, you may wish to force $*SPEC to use one of the specific SPEC modules: IO::Spec::Unix, IO::Spec::Win32, IO::Spec::Cygwin, and IO::Spec::QNX, or to create IO::Path objects via shortcut subclasses IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin, and IO::Path::QNX that pre-set the $.SPEC attribute for you.</p><p>The rest of this document silently assumes Unix semantics in its examples, unless stated otherwise.</p>","a":[{"k":"v","t":"IO::Spec","n":"$.SPEC"},{"t":"Str","k":"v","n":"$.CWD"},{"t":"Str","n":"$.path","k":"v"},{"t":"Mu","n":"$!is-absolute","k":"v"},{"t":"Mu","k":"v","n":"$!os-path"},{"t":"Mu","n":"$!parts","k":"v"}],"m":[{"m":1,"s":{"p":[{"n":"$path","t":"Str"},{"n":":$CWD!","t":"Any"},{"n":":$SPEC?","t":"IO::Spec"},{"n":"*%_","t":"Mu"}],"r":"IO::Path:D"},"d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","n":"new","k":"m"},{"m":1,"s":{"p":[{"n":"$path","t":"Str"},{"n":":$SPEC!","t":"IO::Spec"},{"t":"Mu","n":"*%_"}],"r":"IO::Path:D"},"n":"new","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>"},{"s":{"r":"IO::Path:D","p":[{"t":"Str","n":"$path"},{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","k":"m","n":"new","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","m":1,"s":{"p":[{"n":"$path","t":"Cool"},{"n":":$SPEC?","t":"IO::Spec"},{"n":":$CWD?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"IO::Path:D"},"n":"new","k":"m"},{"s":{"p":[{"n":":$basename!","t":"Any"},{"n":":$dirname?","t":"Any"},{"t":"Any","n":":$volume?"},{"n":":$SPEC?","t":"Any"},{"t":"Any","n":":$CWD?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","n":"new","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"new"},{"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method is-absolute(IO::Path:D: --&gt; Bool)</code></pre></p><p>Returns True if the path is an absolute path, and False otherwise.</p><p><pre><code>\"/foo\".IO.is-absolute.say; # OUTPUT: «True␤»\n\"bars\".IO.is-absolute.say; # OUTPUT: «False␤»</code></pre></p><p>Note that on Windows a path that starts with a slash or backslash is still considered absolute even if no volume was given, as it is absolute for that particular volume:</p><p><pre><code>IO::Path::Win32.new(\"/foo\"  ).is-absolute.say; # OUTPUT: «True␤»\nIO::Path::Win32.new(\"C:/foo\").is-absolute.say; # OUTPUT: «True␤»\nIO::Path::Win32.new(\"C:foo\" ).is-absolute.say; # OUTPUT: «False␤»</code></pre></p>","m":0,"n":"is-absolute"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"d":"<p>Defined as:</p><p><pre><code>method is-relative(IO::Path:D: --&gt; Bool)</code></pre></p><p>Returns True if the path is a relative path, and False otherwise. Windows caveats for .is-absolute apply.</p>","k":"m","m":0,"n":"is-relative"},{"n":"parts","k":"m","d":"<p>Defined as:</p><p><pre><code>method parts(IO::Path:D: --&gt; Map:D)</code></pre></p><p>Returns a Map with the keys volume, dirname, basename whose values are the same as available via methods .volume, .dirname, and .basename respectively.</p><p><pre><code>say IO::Path::Win32.new(\"C:/rakudo/perl6.bat\").parts.perl;\n# OUTPUT: «Map.new((:basename(\"perl6.bat\"),:dirname(\"/rakudo\"),:volume(\"C:\")))␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Defined as:</p><p><pre><code>method volume(IO::Path:D:)</code></pre></p><p>Returns the volume portion of the path object. On Unix system, this is always the empty string.</p><p><pre><code>say IO::Path::Win32.new(\"C:\\\\Windows\\\\registry.ini\").volume;    # OUTPUT: «C:␤»</code></pre></p>","n":"volume","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method dirname(IO::Path:D:)</code></pre></p><p>Returns the directory name portion of the path object. That is, it returns the path excluding the volume and the base name. Unless the dirname consist of only the directory separator (i.e. it's the top directory), the trailing directory separator will not be included in the return value.</p><p><pre><code>say IO::Path.new(\"/home/camelia/myfile.p6\").dirname; # OUTPUT: «/home/camelia␤»\nsay IO::Path::Win32.new(\"C:/home/camelia\").dirname;  # OUTPUT: «/home␤»\nsay IO::Path.new(\"/home\").dirname;                   # OUTPUT: «/␤»</code></pre></p>","m":0,"n":"dirname","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"basename","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method basename(IO::Path:D:)</code></pre></p><p>Returns the basename part of the path object, which is the name of the filesystem object itself that is referenced by the path.</p><p><pre><code>\"docs/README.pod\".IO.basename.say; # OUTPUT: «README.pod␤»\n\"/tmp/\".IO.basename.say;           # OUTPUT: «tmp␤»</code></pre></p><p>Note that in IO::Spec::Win32 semantics, the basename of a Windows share is \\, not the name of the share itself:</p><p><pre><code>IO::Path::Win32.new('//server/share').basename.say; # OUTPUT: «\\␤»</code></pre></p>"},{"m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --&gt; Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","n":"extension"},{"d":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --&gt; Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","n":"extension","k":"m","m":1,"s":{"p":[{"t":"Int","n":":$parts!"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"extension","s":{"r":"Mu","p":[{"n":":$parts!","t":"Range"},{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --&gt; Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","m":1},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --&gt; Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"$subst","t":"Str"},{"n":":$parts?","t":"Int"},{"t":"Str","n":":$joiner?"},{"t":"Mu","n":"*%_"}]},"n":"extension"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --&gt; Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --&gt; Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --&gt; IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --&gt; IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner&lt;_&gt;,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","k":"m","n":"extension","s":{"r":"Mu","p":[{"n":"$subst","t":"Str"},{"t":"Range","n":":$parts"},{"n":":$joiner?","t":"Str"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Numeric","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method Numeric(IO::Path:D: --&gt; Numeric:D)</code></pre></p><p>Coerces .basename to Numeric. Fails with X::Str::Numeric if base name is not numerical.</p>"},{"k":"m","s":{"p":[{"n":"sibling","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method sibling(IO::Path:D: Str() $sibling --&gt; IO::Path:D)</code></pre></p><p>Allows to reference a sibling file or directory. Returns a new IO::Path based on the invocant, with the .basename changed to $sibling. The $sibling is allowed to be a multi-part path fragment; see also .add.</p><p><pre><code>say '.bashrc'.IO.sibling: '.bash_aliases'; # OUTPUT: «.bash_aliases\".IO␤»\nsay '/home/camelia/.bashrc'.IO.sibling: '.bash_aliases';\n# OUTPUT: «/home/camelia/.bash_aliases\".IO␤»\n\nsay '/foo/' .IO.sibling: 'bar';  # OUTPUT: «/bar\".IO␤»\nsay '/foo/.'.IO.sibling: 'bar';  # OUTPUT: «/foo/bar\".IO␤»</code></pre></p>","n":"sibling","m":0},{"d":"<p>Defined as:</p><p><pre><code>method succ(IO::Path:D: --&gt; IO::Path:D)</code></pre></p><p>Returns a new IO::Path constructed from the invocant, with .basename changed by calling Str.succ on it.</p><p><pre><code>\"foo/file02.txt\".IO.succ.say; # OUTPUT: «\"foo/file03.txt\".IO␤»</code></pre></p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"succ"},{"m":0,"n":"pred","d":"<p>Defined as:</p><p><pre><code>method pred(IO::Path:D: --&gt; IO::Path:D)</code></pre></p><p>Returns a new IO::Path constructed from the invocant, with .basename changed by calling Str.pred on it.</p><p><pre><code>\"foo/file02.txt\".IO.pred.say; # OUTPUT: «\"foo/file01.txt\".IO␤»</code></pre></p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"open","k":"m","d":"<p>Defined as:</p><p><pre><code>method open(IO::Path:D: *%opts)</code></pre></p><p>Opens the path as a file; the named options control the mode, and are the same as the open function accepts.</p>","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]}},{"n":"watch","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method watch(IO::Path:D: --&gt; Supply:D)</code></pre></p><p>Equivalent to calling IO::Notification.watch-path with the invocant as the argument.</p>"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method absolute(IO::Path:D: --&gt; Str)\nmulti method absolute(IO::Path:D: $base --&gt; Str)</code></pre></p><p>Returns a new Str object that is an absolute path. If the invocant is not already an absolute path, it is first made absolute using $base as base, if it is provided, or the .CWD attribute the object was created with if it is not.</p>","n":"absolute","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method absolute(IO::Path:D: --&gt; Str)\nmulti method absolute(IO::Path:D: $base --&gt; Str)</code></pre></p><p>Returns a new Str object that is an absolute path. If the invocant is not already an absolute path, it is first made absolute using $base as base, if it is provided, or the .CWD attribute the object was created with if it is not.</p>","n":"absolute","s":{"r":"Str:D","p":[{"n":"$CWD","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"$CWD?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method relative(IO::Path:D: $base = $*CWD --&gt; Str)</code></pre></p><p>Returns a new Str object with the path relative to the $base. If $base is not provided, $*CWD is used in its place. If the invocant is not an absolute path, it's first made to be absolute using the .CWD attribute the object was created with, and then is made relative to $base.</p>","m":0,"n":"relative"},{"d":"<p>Defined as:</p><p><pre><code>method cleanup(IO::Path:D: --&gt; IO::Path:D)</code></pre></p><p>Returns a new path that is a canonical representation of the invocant path, cleaning up any extraneous path parts:</p><p><pre><code>\"foo/./././..////bar\".IO.cleanup.say;      # OUTPUT: «\"foo/../bar\".IO␤»\nIO::Path::Win32.new(\"foo/./././..////bar\")\n    .cleanup.say; \"foo\\..\\bar\".IO;         # OUTPUT: «\"foo\\..\\bar\".IO␤»</code></pre></p><p>Note that no filesystem access is made. See also resolve.</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"cleanup"},{"s":{"r":"Mu","p":[{"t":"Any","n":":$completely"},{"t":"Mu","n":"*%_"}]},"n":"resolve","d":"<p>Defined as:</p><p><pre><code>method resolve(IO::Path:D: :$completely --&gt; IO::Path)</code></pre></p><p>Returns a new IO::Path object with all symbolic links and references to the parent directory (..) resolved. This means that the filesystem is examined for each directory in the path, and any symlinks found are followed.</p><p><pre><code># bar is a symlink pointing to \"/baz\"\nmy $io = \"foo/./bar/..\".IO.resolve;      # now \"/\" (the parent of \"/baz\")</code></pre></p><p>If :$completely, which defaults to False, is set to a true value, the method will fail with X::IO::Resolve if it cannot completely resolve the path, otherwise, it will resolve as much as possible, and will merely perform cleanup of the rest of the path. The last part of the path does NOT have to exist to :$completely resolve the path.</p><p>NOTE: Currently (April 2017) this method doesn't work correctly on all platforms, e.g. Windows, since it assumes POSIX semantics.</p>","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>multi method parent(IO::Path:D:)\nmulti method parent(IO::Path:D: UInt:D $level)</code></pre></p><p>Returns the parent path of the invocant. Note that no actual filesystem access is made, so the returned parent is physical and not the logical parent of symlinked directories.</p><p><pre><code>'/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'./'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n'/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\nIO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»</code></pre></p><p>If $level is specified, the call is equivalent to calling .parent() $level times:</p><p><pre><code>say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»\n</code></pre></p>","n":"parent","m":1,"s":{"r":"Mu","p":[{"t":"Int","n":"$depth"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method parent(IO::Path:D:)\nmulti method parent(IO::Path:D: UInt:D $level)</code></pre></p><p>Returns the parent path of the invocant. Note that no actual filesystem access is made, so the returned parent is physical and not the logical parent of symlinked directories.</p><p><pre><code>'/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'./'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n'/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\nIO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»</code></pre></p><p>If $level is specified, the call is equivalent to calling .parent() $level times:</p><p><pre><code>say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»\n</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"parent"},{"s":{"r":"Mu","p":[{"n":"child","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"child","d":"<p>Defined as:</p><p><pre><code>method child(IO::Path:D: Str() $childname --&gt; IO::Path:D)</code></pre></p><p>Alias for .add. NOTE: This method has been deprecated as of the 6.d version, and will be removed in the future. For any new code, please use .add</p>","m":0,"k":"m"},{"n":"add","s":{"p":[{"n":"child","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method add(IO::Path:D: Str() $what --&gt; IO::Path:D)</code></pre></p><p>Concatenates a path fragment to the invocant and returns the resultant IO::Path. If adding ../ to paths that end with a file, you may need to call resolve for the resultant path to be accessible by other IO::Path methods like dir or open. See also sibling and parent.</p><p><pre><code>\"foo/bar\".IO.mkdir;\n\"foo/bar\".IO.add(\"meow\")    .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n\"foo/bar\".IO.add(\"/meow\")   .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n\"foo/bar\".IO.add(\"meow.txt\").resolve.relative.say; # OUTPUT: «foo/bar/meow.txt␤»\n\"foo/bar\".IO.add(\"../meow\") .resolve.relative.say; # OUTPUT: «foo/meow␤»\n\"foo/bar\".IO.add(\"../../\")  .resolve.relative.say; # OUTPUT: «.␤»</code></pre></p>","m":0},{"n":"chdir","k":"m","s":{"r":"Mu","p":[{"n":"$path","t":"Any"},{"n":":$test!","t":"Any"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)</code></pre></p><p>DEPRECATION NOTICE: this method will be deprecated in 6.d language and removed in 6.e. Do not use it for new code. Instead, create a new path or use add method. For altering current working directory see &amp;chdir and &amp;*chdir subroutines.</p><p>Contrary to the name, the .chdir method does not change any directories, but merely concatenates the given $path to the invocant and returns the resultant IO::Path. Optional file tests can be performed by providing :d, :r, :w, or :x Bool named arguments; when set to True, they'll perform .d, .r, .w, and .x tests respectively. By default, only :d is set to True.</p>","m":1},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)</code></pre></p><p>DEPRECATION NOTICE: this method will be deprecated in 6.d language and removed in 6.e. Do not use it for new code. Instead, create a new path or use add method. For altering current working directory see &amp;chdir and &amp;*chdir subroutines.</p><p>Contrary to the name, the .chdir method does not change any directories, but merely concatenates the given $path to the invocant and returns the resultant IO::Path. Optional file tests can be performed by providing :d, :r, :w, or :x Bool named arguments; when set to True, they'll perform .d, .r, .w, and .x tests respectively. By default, only :d is set to True.</p>","s":{"p":[{"t":"IO","n":"$path"},{"t":"Any","n":"c"}],"r":"Mu"},"k":"m","n":"chdir"},{"s":{"p":[{"n":"$path","t":"Any"},{"t":"Any","n":":$d?"},{"n":":$r","t":"Any"},{"n":":$w","t":"Any"},{"t":"Any","n":":$x"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)</code></pre></p><p>DEPRECATION NOTICE: this method will be deprecated in 6.d language and removed in 6.e. Do not use it for new code. Instead, create a new path or use add method. For altering current working directory see &amp;chdir and &amp;*chdir subroutines.</p><p>Contrary to the name, the .chdir method does not change any directories, but merely concatenates the given $path to the invocant and returns the resultant IO::Path. Optional file tests can be performed by providing :d, :r, :w, or :x Bool named arguments; when set to True, they'll perform .d, .r, .w, and .x tests respectively. By default, only :d is set to True.</p>","n":"chdir"},{"d":"<p>Defined as:</p><p><pre><code>method rename(IO::Path:D: IO() $to, :$createonly = False --&gt; Bool:D)\nsub    rename(IO() $from, IO() $to, :$createonly = False --&gt; Bool:D)</code></pre></p><p>Renames a file or directory. Returns True on success; fails with X::IO::Rename if :$createonly is True and the $to path already exists or if the operation failed for some other reason.</p><p>Note: some renames will always fail, such as when the new name is on a different storage device. See also: move.</p>","n":"rename","m":0,"k":"m","s":{"p":[{"t":"Any","n":"$to"},{"t":"Any","n":":$createonly"},{"n":"*%_","t":"Mu"}],"r":"Bool"}},{"s":{"r":"Bool","p":[{"t":"Any","n":"$to"},{"t":"Any","n":":$createonly"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method copy(IO::Path:D: IO() $to, :$createonly --&gt; Bool:D)\nsub    copy(IO() $from, IO() $to, :$createonly --&gt; Bool:D)</code></pre></p><p>Copies a file. Returns True on success; fails with X::IO::Copy if :$createonly is True and the $to path already exists or if the operation failed for some other reason, such as when $to and $from are the same file.</p>","k":"m","n":"copy","m":0},{"m":0,"n":"move","k":"m","s":{"r":"Bool","p":[{"n":"c","t":"Any"}]},"d":"<p>Defined as:</p><p><pre><code>method move(IO::Path:D: IO() $to, :$createonly --&gt; Bool:D)\nsub    move(IO() $from, IO() $to, :$createonly --&gt; Bool:D)</code></pre></p><p>Copies a file and then removes the original. If removal fails, it's possible to end up with two copies of the file. Returns True on success; fails with X::IO::Move if :$createonly is True and the $to path already exists or if the operation failed for some other reason, such as when $to and $from are the same file.</p><p>To avoid copying, you can use rename, if the files are on the same storage device. It also works with directories, while move does not.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method chmod(IO::Path:D: Int() $mode --&gt; Bool)</code></pre></p><p>Changes the POSIX permissions of a file or directory to $mode. Returns True on success; on failure, fails with X::IO::Chmod.</p><p>The mode is expected as an integer following the standard numeric notation, and is best written as an octal number:</p><p><pre><code>'myfile'.IO.chmod(0o444);          # make a file read-only\n'somedir'.IO.chmod(0o777);         # set 0777 permissions on a directory\n</code></pre></p><p>Make sure you don't accidentally pass the intended octal digits as a decimal number (or string containing a decimal number):</p><p><pre><code>'myfile'.IO.chmod:  '0444';        # BAD!!! (interpreted as mode 0o674)\n'myfile'.IO.chmod: '0o444';        # OK (an octal in a string)\n'myfile'.IO.chmod:  0o444;         # Also OK (an octal literal)\n</code></pre></p>","k":"m","m":0,"s":{"p":[{"t":"Any","n":"$mode"},{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"chmod"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"unlink","m":0,"d":"<p>Defined as:</p><p><pre><code>method unlink(IO::Path:D: --&gt; True)\nsub    unlink(*@filenames --&gt; List:D)</code></pre></p><p>Delete all specified ordinary files, links, or symbolic links for which there are privileges to do so. See rmdir to delete directories.</p><p>The subroutine form returns the names of all the files in the list, excluding those for which the filesystem raised some error; since trying to delete a file that does not exist does not raise any error at that level, this list will include the names of the files in the list that do not exist.</p><p>The method form returns True on success, or fails with X::IO::Unlink if the operation could not be completed. If the file to be deleted does not exist, the routine treats it as success.</p><p><pre><code>'foo.txt'.IO.open(:w).close;\n'bar'.IO.mkdir;\nsay unlink &lt;foo.txt  bar  not-there.txt&gt;; # OUTPUT: «[foo.txt not-there.txt]␤»\n# `bar` is not in output because it failed to delete (it's a directory)\n# `not-there.txt` is present. It never existed, so that's deemed a success.\n\n# Method form `fail`s:\nsay .exception.message without 'bar'.IO.unlink;\n# OUTPUT: «Failed to remove the file […] illegal operation on a directory␤»\n</code></pre></p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method symlink(IO::Path:D $target: IO() $link --&gt; Bool:D)\nsub    symlink(      IO() $target, IO() $link --&gt; Bool:D)</code></pre></p><p>Create a new symbolic link $link to existing $target. Returns True on success; fails with X::IO::Symlink if the symbolic link could not be created. If $target does not exist, creates a dangling symbolic link. To create a hard link, see link.</p><p>Note: on Windows, creation of symbolic links may require escalated privileges.</p><p> </p>","s":{"r":"Bool","p":[{"n":"$name","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"symlink"},{"m":0,"k":"m","n":"link","s":{"r":"Bool","p":[{"t":"Any","n":"$name"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method link(IO::Path:D $target: IO() $link --&gt; Bool:D)\nsub    link(      IO() $target, IO() $link --&gt; Bool:D)</code></pre></p><p>Create a new hard link $link to existing $target. Returns True on success; fails with X::IO::Link if the hard link could not be created. To create a symbolic link, see symlink.</p>"},{"m":0,"k":"m","n":"mkdir","s":{"p":[{"t":"Any","n":"$mode?"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>sub    rmdir(*@dirs --&gt; List:D)\nmethod rmdir(IO::Path:D: --&gt; True)</code></pre></p><p>Remove the invocant, or in sub form, all of the provided directories in the given list, which can contain any Cool object. Only works on empty directories.</p><p>Method form returns True on success and returns a Failure of type X::IO::Rmdir if the directory cannot be removed (e.g. the directory is not empty, or the path is not a directory). Subroutine form returns a list of directories that were successfully deleted.</p><p>To delete non-empty directory, see rmtree in File::Directory::Tree module.</p>","m":0,"k":"m","n":"rmdir","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"}},{"s":{"r":"Mu","p":[{"n":":$test!","t":"Mu"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"dir","d":"<p>Defined as:</p><p><pre><code>sub    dir(Cool $path = '.', Mu :$test = none('.', '..'))\nmethod dir(IO::Path:D: Mu :$test = none('.', '..'))</code></pre></p><p>Returns the contents of a directory as a lazy list of IO::Path objects representing relative paths, filtered by smartmatching their names (as strings) against the :test parameter.</p><p>Since the tests are performed against Str arguments, not IO, the tests are executed in the $*CWD, instead of the target directory. When testing against file test operators, this won't work:</p><p><pre><code>dir('mydir', test =&gt; { .IO.d })</code></pre></p><p>while this will:</p><p><pre><code>dir('mydir', test =&gt; { \"mydir/$_\".IO.d })</code></pre></p><p>NOTE: a dir call opens a directory for reading, which counts towards maximum per-process open files for your program. Be sure to exhaust returned Seq before doing something like recursively performing more dir calls. You can exhaust it by assigning to a @-sigiled variable or simply looping over it. Note how examples below push further dirs to look through into an Array, rather than immediately calling dir on them. See also IO::Dir module that gives you finer control over closing dir handles.</p><p>Examples:</p><p><pre><code># To iterate over the contents of the current directory:\nfor dir() -&gt; $file {\n    say $file;\n}\n\n# As before, but include even '.' and '..' which are filtered out by\n# the default :test matcher:\nfor dir(test =&gt; *) -&gt; $file {\n    say $file;\n}\n\n# To get the names of all .jpg and .jpeg files in ~/Downloads:\nmy @jpegs = $*HOME.dir: test =&gt; /:i '.' jpe?g $/;</code></pre></p><p>An example program that lists all files and directories recursively:</p><p><pre><code>sub MAIN($dir = '.') {\n    my @todo = $dir.IO;\n    while @todo {\n        for @todo.pop.dir -&gt; $path {\n            say $path.Str;\n            @todo.push: $path if $path.d;\n        }\n    }\n}</code></pre></p><p>A lazy way to find the first three files ending in \".p6\" recursively starting from the current directory:</p><p><pre><code>my @stack = '.'.IO;\nmy $perl-files = gather while @stack {\n    with @stack.pop {\n        when :d { @stack.append: .dir }\n        .take when .extension.lc eq 'p6'\n    }\n}\n.put for $perl-files[^3];\n</code></pre></p>","m":1},{"n":"dir","m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>sub    dir(Cool $path = '.', Mu :$test = none('.', '..'))\nmethod dir(IO::Path:D: Mu :$test = none('.', '..'))</code></pre></p><p>Returns the contents of a directory as a lazy list of IO::Path objects representing relative paths, filtered by smartmatching their names (as strings) against the :test parameter.</p><p>Since the tests are performed against Str arguments, not IO, the tests are executed in the $*CWD, instead of the target directory. When testing against file test operators, this won't work:</p><p><pre><code>dir('mydir', test =&gt; { .IO.d })</code></pre></p><p>while this will:</p><p><pre><code>dir('mydir', test =&gt; { \"mydir/$_\".IO.d })</code></pre></p><p>NOTE: a dir call opens a directory for reading, which counts towards maximum per-process open files for your program. Be sure to exhaust returned Seq before doing something like recursively performing more dir calls. You can exhaust it by assigning to a @-sigiled variable or simply looping over it. Note how examples below push further dirs to look through into an Array, rather than immediately calling dir on them. See also IO::Dir module that gives you finer control over closing dir handles.</p><p>Examples:</p><p><pre><code># To iterate over the contents of the current directory:\nfor dir() -&gt; $file {\n    say $file;\n}\n\n# As before, but include even '.' and '..' which are filtered out by\n# the default :test matcher:\nfor dir(test =&gt; *) -&gt; $file {\n    say $file;\n}\n\n# To get the names of all .jpg and .jpeg files in ~/Downloads:\nmy @jpegs = $*HOME.dir: test =&gt; /:i '.' jpe?g $/;</code></pre></p><p>An example program that lists all files and directories recursively:</p><p><pre><code>sub MAIN($dir = '.') {\n    my @todo = $dir.IO;\n    while @todo {\n        for @todo.pop.dir -&gt; $path {\n            say $path.Str;\n            @todo.push: $path if $path.d;\n        }\n    }\n}</code></pre></p><p>A lazy way to find the first three files ending in \".p6\" recursively starting from the current directory:</p><p><pre><code>my @stack = '.'.IO;\nmy $perl-files = gather while @stack {\n    with @stack.pop {\n        when :d { @stack.append: .dir }\n        .take when .extension.lc eq 'p6'\n    }\n}\n.put for $perl-files[^3];\n</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi method slurp(IO::Path:D: :$bin, :$enc)</code></pre></p><p>Read all of the file's content and return it as either Buf, if :$bin is True, or if not, as Str decoded with :$enc encoding, which defaults to utf8. File will be closed afterwards. See &amp;open for valid values for :$enc.</p>","k":"m","n":"slurp","m":1,"s":{"p":[{"t":"Any","n":":$bin!"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method slurp(IO::Path:D: :$bin, :$enc)</code></pre></p><p>Read all of the file's content and return it as either Buf, if :$bin is True, or if not, as Str decoded with :$enc encoding, which defaults to utf8. File will be closed afterwards. See &amp;open for valid values for :$enc.</p>","s":{"p":[{"t":"Any","n":":$enc!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"n":"slurp","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method slurp(IO::Path:D: :$bin, :$enc)</code></pre></p><p>Read all of the file's content and return it as either Buf, if :$bin is True, or if not, as Str decoded with :$enc encoding, which defaults to utf8. File will be closed afterwards. See &amp;open for valid values for :$enc.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"slurp"},{"d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>","s":{"r":"Bool:D","p":[{"n":"data","t":"Blob"},{"n":":$append!","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"spurt"},{"d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>","m":1,"n":"spurt","k":"m","s":{"p":[{"n":"data","t":"Blob"},{"n":":$createonly!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"n":"spurt","d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>","m":1,"k":"m","s":{"p":[{"t":"Blob","n":"data"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"n":"spurt","m":1,"k":"m","s":{"r":"Bool:D","p":[{"t":"Any","n":"text"},{"n":":$append!","t":"Any"},{"t":"Any","n":":$enc"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>"},{"s":{"p":[{"n":"text","t":"Any"},{"n":":$createonly!","t":"Any"},{"n":":$enc","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>","m":1,"n":"spurt"},{"n":"spurt","m":1,"s":{"p":[{"n":"text","t":"Any"},{"n":":$enc","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>"},{"k":"m","s":{"p":[{"n":":$chomp?","t":"Any"},{"n":":$enc?","t":"Any"},{"t":"Any","n":":$nl-in?"},{"n":"c","t":"Any"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method lines(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --&gt; Seq:D)</code></pre></p><p>Opens the invocant and returns its lines.</p><p>The behavior is equivalent to opening the file specified by the invocant, forwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open, then calling IO::Handle.lines on that handle, forwarding any of the remaining arguments to that method, and returning the resultant Seq.</p><p>NOTE: the lines are ready lazily and the handle used under the hood won't get closed until the returned Seq is fully reified, so ensure it is, or you'll be leaking open filehandles. (TIP: use the $limit argument)</p><p><pre><code>say \"The file contains \",\n  '50GB-file'.IO.lines.grep(*.contains: 'Perl').elems,\n  \" lines that mention Perl\";\n# OUTPUT: «The file contains 72 lines that mention Perl␤»\n</code></pre></p>","m":0,"n":"lines"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":":$chomp?"},{"n":":$enc?","t":"Any"},{"t":"Any","n":":$nl-in?"},{"n":"c","t":"Any"}]},"n":"comb","d":"<p>Defined as:</p><p><pre><code>method comb(IO::Path:D: |args --&gt; Seq:D)</code></pre></p><p>Opens the file and processes its contents the same way Str.comb does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method split(IO::Path:D: |args --&gt; Seq:D)</code></pre></p><p>Opens the file and processes its contents the same way Str.split does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>","n":"split","k":"m","s":{"p":[{"n":":$chomp?","t":"Any"},{"t":"Any","n":":$enc?"},{"t":"Any","n":":$nl-in?"},{"t":"Any","n":"c"}],"r":"Mu"},"m":0},{"n":"words","k":"m","d":"<p>Defined as:</p><p><pre><code>method words(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --&gt; Seq:D)</code></pre></p><p>Opens the invocant and returns its words.</p><p>The behavior is equivalent to opening the file specified by the invocant, forwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open, then calling IO::Handle.words on that handle, forwarding any of the remaining arguments to that method, and returning the resultant Seq.</p><p>NOTE: words are lazily read. The handle used under the hood is not closed until the returned Seq is fully reified, and this could lead to leaking open filehandles. It is possible to avoid leaking open filehandles using the $limit argument to cut down the Seq of words to be generated.</p><p><pre><code>my %dict := bag 'my-file.txt'.IO.words;\nsay \"Most common words: \", %dict.sort(-*.value).head: 5;\n</code></pre></p>","m":0,"s":{"p":[{"t":"Any","n":":$chomp?"},{"n":":$enc?","t":"Any"},{"t":"Any","n":":$nl-in?"},{"n":"c","t":"Any"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method e(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists.</p>","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"n":"e"},{"d":"<p>Defined as:</p><p><pre><code>method d(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a directory. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"d"},{"m":0,"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"n":"f","d":"<p>Defined as:</p><p><pre><code>method f(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a file. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","k":"m"},{"n":"s","k":"m","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method s(--&gt; Int:D)</code></pre></p><p>Returns the file size in bytes. May be called on paths that are directories, in which case the reported size is dependent on the operating system. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p><p><pre><code>say $*EXECUTABLE.IO.s; # OUTPUT : «467␤»</code></pre></p>","m":0},{"n":"l","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"d":"<p>Defined as:</p><p><pre><code>method l(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a symlink. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","m":0},{"n":"r","k":"m","d":"<p>Defined as:</p><p><pre><code>method r(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is accessible. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","m":0,"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"w","m":0,"d":"<p>Defined as:</p><p><pre><code>method w(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"n":"rw","k":"m","d":"<p>Defined as:</p><p><pre><code>method rw(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is readable and writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","m":0,"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method x(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is executable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"m":0,"n":"x"},{"d":"<p>Defined as:</p><p><pre><code>method rwx(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is executable, readable, and writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","k":"m","m":0,"n":"rwx","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method z(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and has size of 0. May be called on paths that are directories, in which case the reported file size (and thus the result of this method) is dependent on the operating system. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","n":"z","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"s":{"r":"Instant:D","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Returns an Instant object indicating when the content of the file was last modified. Compare with changed.</p><p><pre><code>say \"path/to/file\".IO.modified;          # Instant:1424089165\nsay \"path/to/file\".IO.modified.DateTime; # 2015-02-16T12:18:50Z\n</code></pre></p>","n":"modified","m":0,"k":"m"},{"k":"m","d":"<p>Return an Instant object representing the timestamp when the file was last accessed. Note: depending on how the filesystem was mounted, the last accessed time may not update on each access to the file, but only on the first access after modifications.</p><p><pre><code>say \"path/to/file\".IO.accessed;          # Instant:1424353577\nsay \"path/to/file\".IO.accessed.DateTime; # 2015-02-19T13:45:42Z\n</code></pre></p>","s":{"r":"Instant:D","p":[{"t":"Mu","n":"*%_"}]},"n":"accessed","m":0},{"m":0,"n":"changed","d":"<p>Returns an Instant object indicating the metadata of the file or directory was last changed (e.g. permissions, or files created/deleted in directory). Compare with modified.</p><p><pre><code>say \"path/to/file\".IO.changed;           # Instant:1424089165\nsay \"path/to/file\".IO.changed.DateTime;  # 2015-02-16T12:18:50Z\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Instant:D"},"k":"m"},{"n":"mode","m":0,"k":"m","s":{"r":"IntStr:D","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method SPEC(IO::Path:D: --&gt; IO::Spec)</code></pre></p><p>Returns the IO::Spec object that was (implicitly) specified at object creation time.</p><p><pre><code>my $io = IO::Path.new(\"/bin/bash\");\nsay $io.SPEC;                            # OUTPUT: «(Unix)␤»\nsay $io.SPEC.dir-sep;                    # OUTPUT: «/␤»</code></pre></p>","m":0,"n":"SPEC","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"CWD","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"path"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"},{"k":"m","m":0,"s":{"p":[{"n":"path","t":"Str"},{"t":"IO::Spec","n":"SPEC"},{"n":"CWD","t":"Str"},{"n":"absolute","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!SET-SELF"},{"s":{"p":[{"n":"$trying","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Failure"},"n":"!does-not-exist","k":"m","m":0}],"b":"C","n":"IO::Path","mro":["IO","Cool"],"k":"c"},{"m":[{"m":0,"n":"new","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"k":"m"}],"t":"IO::Path::Spec","k":"ro","b":"C","n":"IO::Path::Spec","mro":["IO::Path"]},{"d":"<p><pre><code>class IO::Path::Cygwin is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Cygwin in the $.SPEC attribute.</p>","k":"c","n":"IO::Path::Cygwin","m":[{"k":"s","n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"m":0}],"mro":["IO::Path::Spec[IO::Spec::Cygwin]","IO","IO::Path"],"b":"C","a":[{"n":"$.SPEC","t":"IO::Spec","k":"v"},{"t":"Str","k":"v","n":"$.CWD"},{"n":"$.path","t":"Str","k":"v"},{"t":"Mu","n":"$!is-absolute","k":"v"},{"t":"Mu","n":"$!os-path","k":"v"},{"t":"Mu","n":"$!parts","k":"v"}],"t":"IO::Path::Cygwin"},{"m":[{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","m":0,"k":"s"}],"n":"IO::Path::Win32","t":"IO::Path::Win32","mro":["IO::Path::Spec[IO::Spec::Win32]","IO","IO::Path"],"b":"C","a":[{"t":"IO::Spec","n":"$.SPEC","k":"v"},{"t":"Str","n":"$.CWD","k":"v"},{"n":"$.path","k":"v","t":"Str"},{"t":"Mu","k":"v","n":"$!is-absolute"},{"t":"Mu","n":"$!os-path","k":"v"},{"n":"$!parts","t":"Mu","k":"v"}],"d":"<p><pre><code>class IO::Path::Win32 is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Win32 in the $.SPEC attribute.</p>","k":"c"},{"t":"Int","mro":["Real","Numeric","Cool"],"b":"C","m":[{"m":0,"n":"!eggify","s":{"r":"Str:D","p":[{"t":"Any","n":"$egg"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"n":"IO::Path::slurp-size","k":"c"},{"a":[{"t":"str","k":"v","n":"$.volume"},{"k":"v","n":"$.dirname","t":"str"},{"n":"$.basename","t":"str","k":"v"}],"k":"c","b":"A","t":"IO::Path::Parts","n":"IO::Path::Parts","mro":["Iterable","Associative","Positional","Any"],"m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"volume"},{"n":"dirname","t":"Any"},{"n":"basename","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"new"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"raku"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"of","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"iterator","k":"m"},{"n":"AT-POS","s":{"r":"Mu","p":[{"n":"$pos","t":"int"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"n":"AT-KEY","s":{"p":[{"n":"$key","t":"str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"volume","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"dirname","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"basename","k":"m","m":0},{"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"!SET-SELF","s":{"p":[{"n":"$!volume","t":"Any"},{"n":"$!dirname","t":"Any"},{"n":"$!basename","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0}]},{"d":"<p><pre><code>class IO::Path::Unix is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Unix in the $.SPEC attribute.</p>","k":"c","t":"IO::Path::Unix","mro":["IO::Path::Spec[IO::Spec::Unix]","IO","IO::Path"],"a":[{"t":"IO::Spec","n":"$.SPEC","k":"v"},{"k":"v","t":"Str","n":"$.CWD"},{"n":"$.path","t":"Str","k":"v"},{"k":"v","t":"Mu","n":"$!is-absolute"},{"n":"$!os-path","k":"v","t":"Mu"},{"t":"Mu","n":"$!parts","k":"v"}],"b":"C","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"n":"IO::Path::Unix"},{"b":"C","t":"IO::Path::QNX","mro":["IO::Path::Spec[IO::Spec::QNX]","IO","IO::Path"],"d":"<p><pre><code>class IO::Path::QNX is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::QNX in the $.SPEC attribute.</p>","m":[{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"IO::Path::QNX","a":[{"n":"$.SPEC","t":"IO::Spec","k":"v"},{"t":"Str","n":"$.CWD","k":"v"},{"k":"v","n":"$.path","t":"Str"},{"t":"Mu","k":"v","n":"$!is-absolute"},{"t":"Mu","k":"v","n":"$!os-path"},{"t":"Mu","n":"$!parts","k":"v"}]},{"d":"<p><pre><code>multi sub infix:&lt;(cont)&gt;($a,$b --&gt; Bool:D)\nmulti sub infix:&lt;∋&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Membership operator.</p><p>Returns True if $a is an element of $b.</p><p><pre><code>say (1,2,3) (cont) 2; # OUTPUT: «True␤»\nsay (1, 2, 3) ∋ 4; # OUTPUT: «False␤»\n</code></pre></p><p>∋ is equivalent to (cont), at codepoint U+220B (CONTAINS AS MEMBER).</p>","k":"v","n":"&infix:<(cont)>","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"n":"infix:<(cont)>","s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Bool:D"},"k":"s"},{"b":"A","t":"RaceSeq","m":[{"k":"s","n":"BUILD","s":{"p":[{"t":"Any","n":":$!configuration!"},{"t":"Any","n":":$!work-stage-head!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"r":"Iterator","p":[{"t":"Mu","n":"*%_"}]},"n":"iterator","k":"m","m":0,"d":"<p><pre><code>method iterator(RaceSeq:D: --&gt; Iterator:D)</code></pre></p><p>Returns the underlying iterator.</p>"},{"m":0,"s":{"r":"Mu","p":[{"n":"$matcher","t":"Any"},{"t":"Associative","n":"*%options"}]},"k":"m","n":"grep","d":"<p><pre><code>method grep(RaceSeq:D: $matcher, *%options)</code></pre></p><p>Applies grep to the RaceSeq similarly to how it would do it on a Seq.</p><p><pre><code>my @raced = (^10000).map(*²).race;\n@raced.grep( * %% 3 ).say;\n# OUTPUT: «(0 9 36 81 144 …»\n</code></pre></p><p>When you use race on a Seq, this is the method that is actually called.</p>"},{"d":"<p><pre><code>method map(RaceSeq:D: $matcher, *%options)</code></pre></p><p>Uses maps on the RaceSeq, generally created by application of .race to a preexisting Seq.</p>","s":{"r":"Mu","p":[{"n":"$matcher","t":"Any"},{"n":"*%options","t":"Associative"}]},"m":0,"n":"map","k":"m"},{"m":0,"n":"invert","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method invert(RaceSeq:D:)</code></pre></p><p>Inverts the RaceSeq created from a Seq by .race.</p>"},{"n":"hyper","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method hyper(RaceSeq:D:)</code></pre></p><p>Creates a HyperSeq object out of the current one.</p>","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"race","d":"<p><pre><code>method race(RaceSeq:D:)</code></pre></p><p>Returns the object.</p>","k":"m","m":0},{"k":"m","m":0,"d":"<p><pre><code>method is-lazy(--&gt; False )</code></pre></p><p>Returns False.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"is-lazy"},{"k":"m","n":"sink","m":0,"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]}},{"n":"configuration","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"}],"d":"<p><pre><code>class RaceSeq does Iterable does Sequence { }</code></pre></p><p>An RaceSeq is the intermediate object used when the operator race is invoked on a Seq. In general, it's not intended for direct consumption by the developer.</p>","k":"c","mro":["Sequence","PositionalBindFailover","Iterable","Any"],"n":"RaceSeq","a":[{"k":"v","t":"HyperConfiguration","n":"$.configuration"},{"n":"$!work-stage-head","k":"v","t":"Rakudo::Internals::HyperWorkStage"},{"t":"Mu","k":"v","n":"$!list"}]},{"n":"&open","t":"Sub","k":"v"},{"k":"s","n":"open","m":1,"s":{"p":[{"n":"$path","t":"Any"},{"n":"c","t":"Any"}],"r":"Mu"}},{"m":[{"m":0,"n":"unit","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"from","d":"<p><pre><code>method from(--&gt; Str:D)</code></pre></p><p>Returns the name of the language with which the CompUnit object was created (if any). It will be Perl6 by default.</p>","k":"m"},{"d":"<p><pre><code>method short-name(--&gt; Str:D)</code></pre></p><p>Returns The short name with which the CompUnit object was created (if any).</p>","n":"short-name","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"version","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p><pre><code>method auth(--&gt; Str:D)</code></pre></p><p>Returns the authority information with which the CompUnit object was created (if any).</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"auth"},{"k":"m","d":"<p><pre><code>method repo(--&gt; CompUnit::Repository:D)</code></pre></p><p>Returns the CompUnit::Repository object with which the CompUnit object was created.</p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"repo"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"repo-id","k":"m","d":"<p><pre><code>method repo-id(--&gt; Str:D)</code></pre></p><p>Returns the identification string with which the CompUnit object can be identified in the associated repo.</p>","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"handle","k":"m"},{"n":"precompiled","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method precompiled(--&gt; Bool:D)</code></pre></p><p>Returns whether the CompUnit object originated from a precompiled source.</p>"},{"d":"<p><pre><code>method distribution(--&gt; Distribution:D)</code></pre></p><p>Returns the Distribution object with which the CompUnit object was created (if any).</p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"distribution","m":0},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"!WHICH","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"}],"k":"c","a":[{"t":"Str:D","n":"$.from","k":"v"},{"t":"Str:D","k":"v","n":"$.short-name"},{"n":"$.version","t":"Version","k":"v"},{"k":"v","t":"Str","n":"$.auth"},{"k":"v","n":"$.repo","t":"CompUnit::Repository:D"},{"t":"Str:D","n":"$.repo-id","k":"v"},{"k":"v","t":"CompUnit::Handle","n":"$.handle"},{"n":"$.precompiled","t":"Bool:D","k":"v"},{"n":"$.distribution","t":"Distribution","k":"v"},{"n":"$!WHICH","k":"v","t":"ValueObjAt"}],"mro":["Any"],"t":"CompUnit","n":"CompUnit","b":"A","d":"<p><pre><code>class CompUnit {}</code></pre></p><p>The CompUnit represents the metainformation about a compilation unit. This usually relates to source code that resides in a file on a filesystem, rather than code that is executed using an EVAL statement.</p>"},{"d":"<p>This class provides stubs for each of the following methods. The methods are provided by sub-classes, such as PrecompilationRepository::File. Sub-classes are implementation dependent.</p>","t":"CompUnit::PrecompilationRepository","b":"C","k":"ro","mro":[],"n":"CompUnit::PrecompilationRepository","m":[{"k":"m","m":0,"s":{"p":[{"t":"CompUnit::PrecompilationDependency::File","n":"$dependency"},{"t":"IO::Path","n":":$source"},{"n":":@precomp-stores","t":"Positional[CompUnit::PrecompilationStore]"},{"n":"*%_","t":"Mu"}],"r":"CompUnit::Handle:D"},"n":"try-load"},{"m":0,"k":"m","s":{"r":"Nil","p":[{"n":"$id","t":"CompUnit::PrecompilationId"},{"n":"*%_","t":"Mu"}]},"n":"load"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"k":"m","m":0,"n":"may-precomp"}]},{"mro":["CompUnit::PrecompilationRepository","Any"],"b":"A","k":"c","n":"CompUnit::PrecompilationRepository::None","t":"CompUnit::PrecompilationRepository"},{"n":"CompUnit::PrecompilationRepository::Default","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"TWEAK","k":"m"},{"n":"try-load","k":"m","m":0,"s":{"r":"CompUnit::Handle:D","p":[{"n":"$dependency","t":"CompUnit::PrecompilationDependency::File"},{"t":"IO::Path","n":":$source?"},{"n":":@precomp-stores?","t":"Positional[CompUnit::PrecompilationStore]"},{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"$id","t":"Str"},{"t":"Instant","n":":$since"},{"t":"IO::Path","n":":$source"},{"n":":@precomp-stores?","t":"Positional[CompUnit::PrecompilationStore]"},{"n":"*%_","t":"Mu"}]},"n":"load","m":1},{"s":{"p":[{"t":"CompUnit::PrecompilationId","n":"$id"},{"t":"IO::Path","n":":$source"},{"t":"Str","n":":$checksum"},{"n":":$since","t":"Instant"},{"n":":@precomp-stores?","t":"Positional[CompUnit::PrecompilationStore]"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"load","k":"m","m":1},{"m":1,"s":{"r":"Bool:D","p":[{"n":"$path","t":"IO::Path"},{"n":"$id","t":"Str"},{"n":":$force","t":"Bool"},{"n":":$source-name?","t":"Str"},{"n":"*%_","t":"Mu"}]},"n":"precompile","k":"m"},{"s":{"p":[{"n":"$path","t":"IO::Path"},{"n":"$id","t":"CompUnit::PrecompilationId"},{"n":":$force","t":"Bool"},{"n":":$source-name?","t":"Str"},{"t":"Any","n":":$precomp-stores"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"n":"precompile","m":1,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"store"},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"},{"s":{"r":"Bool:D","p":[{"n":"$precomp-unit","t":"CompUnit::PrecompilationUnit"},{"n":"@precomp-stores","t":"Positional"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!load-dependencies"},{"s":{"p":[{"n":"@precomp-stores","t":"Positional[CompUnit::PrecompilationStore]"},{"t":"CompUnit::PrecompilationId","n":"$id"},{"t":"Bool","n":":$repo-id"},{"n":":$refresh","t":"Bool"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"!load-file"},{"m":0,"s":{"p":[{"t":"Any","n":"$path"},{"n":"$source","t":"Any"},{"t":"Any","n":"$destination"},{"t":"Any","n":"$bap"},{"t":"Mu","n":"*%_"}],"r":"Bool"},"k":"m","n":"!already-precompiled"},{"k":"m","s":{"r":"Mu","p":[{"n":"$unit","t":"CompUnit::PrecompilationUnit"},{"t":"Mu","n":"*%_"}]},"n":"!load-handle-for-path","m":0}],"mro":["CompUnit::PrecompilationRepository","Any"],"t":"CompUnit::PrecompilationRepository::Default","a":[{"k":"v","t":"CompUnit::PrecompilationStore:D","n":"$.store"},{"k":"v","t":"Mu","n":"$!RMD"},{"n":"$!RRD","k":"v","t":"Mu"}],"b":"A","k":"c"},{"n":"CompUnit::RepositoryRegistry","mro":["Any"],"t":"CompUnit::RepositoryRegistry","m":[{"s":{"p":[{"n":"$spec","t":"Str"},{"n":":$next-repo","t":"CompUnit::Repository"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"repository-for-spec"},{"m":1,"n":"repository-for-spec","s":{"p":[{"n":"$spec","t":"CompUnit::Repository::Spec"},{"n":":$next-repo","t":"CompUnit::Repository"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"setup-repositories"},{"m":0,"s":{"p":[{"t":"CompUnit::Repository","n":"$repo"},{"n":":$current?","t":"CompUnit::Repository"},{"t":"Mu","n":"*%_"}],"r":"CompUnit::Repository:D"},"k":"m","n":"use-repository"},{"n":"repository-for-name","m":0,"s":{"r":"Mu","p":[{"t":"Str","n":"name"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"$name","t":"Any"},{"t":"CompUnit::Repository","n":"$repo"},{"t":"Mu","n":"*%_"}]},"n":"register-name"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"CompUnit::Repository","n":"$repo"},{"n":"*%_","t":"Mu"}]},"n":"name-for-repository"},{"s":{"p":[{"t":"Str","n":"$spec"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"file-for-spec","k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$script"},{"n":":$name","t":"Any"},{"t":"Any","n":":$auth"},{"n":":$ver","t":"Any"},{"t":"Any","n":":$api"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"run-script","k":"m"},{"n":"head","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"resolve-unknown-repos","k":"m","s":{"p":[{"n":"$first-repo","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0},{"s":{"p":[{"n":"@conflicts","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"resolve_repossession_conflicts","k":"m","m":0},{"s":{"p":[{"n":"$repo","t":"CompUnit::Repository"},{"n":"$current","t":"CompUnit::Repository"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"!remove-from-chain","m":0,"k":"m"},{"m":0,"n":"!register-repository","s":{"r":"Mu","p":[{"t":"str","n":"$id"},{"t":"CompUnit::Repository","n":"$repo"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"b":"A","k":"c"},{"m":[{"m":0,"n":"load-source-file","s":{"r":"CompUnit::Handle","p":[{"n":"$path","t":"IO::Path"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"load-source","s":{"p":[{"n":"$bytes","t":"Blob"},{"n":"*%_","t":"Mu"}],"r":"CompUnit::Handle:D"},"k":"m"},{"k":"m","s":{"r":"CompUnit::Handle:D","p":[{"n":"$path","t":"IO::Path"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"load-precompilation-file"},{"k":"m","n":"load-precompilation-file","s":{"p":[{"t":"IO::Handle","n":"$file"},{"t":"Mu","n":"*%_"}],"r":"CompUnit::Handle:D"},"m":1},{"k":"m","m":0,"n":"load-precompilation","s":{"r":"CompUnit::Handle:D","p":[{"n":"$bytes","t":"Blob"},{"n":"*%_","t":"Mu"}]}}],"b":"A","n":"CompUnit::Loader","k":"c","mro":["Any"],"t":"CompUnit::Loader"},{"d":"<p>The CompUnit::Repository role defines the interface of the implementation of CompUnit::Repositories such as CompUnit::Repository::Installation and CompUnit::Repository::FileSystem.</p>","t":"CompUnit::Repository","b":"C","k":"ro","a":[{"k":"v","t":"CompUnit::Repository","n":"$.next-repo"}],"n":"CompUnit::Repository","m":[{"k":"m","d":"<p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","m":0,"s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"$precomp?","t":"CompUnit::PrecompilationRepository"},{"t":"Positional[CompUnit::PrecompilationStore]","n":":@precomp-stores?"},{"n":"*%_","t":"Mu"}],"r":"CompUnit:D"},"n":"need"},{"d":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --&gt; CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","m":0,"n":"resolve","k":"m","s":{"r":"CompUnit:D","p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"*%_","t":"Mu"}]}},{"k":"m","d":"<p><pre><code>method load(IO::Path:D $file --&gt; CompUnit:D)</code></pre></p><p>Load the $file and return a CompUnit object representing it.</p>","s":{"r":"CompUnit:D","p":[{"t":"IO::Path","n":"$file"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"load"},{"m":0,"n":"loaded","s":{"r":"Iterable:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"id","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"n":"precomp-store","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::PrecompilationStore"}},{"k":"m","n":"precomp-repository","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::PrecompilationRepository"},"m":0},{"k":"m","m":0,"n":"repo-chain","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}}],"mro":[]},{"b":"A","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"writeable-path"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"can-install","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"name","k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"upgrade-repository"},{"k":"m","n":"install","s":{"r":"Mu","p":[{"t":"Distribution","n":"$distribution"},{"t":"Bool","n":":$force"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method install(Distribution $distribution, Bool :$force)</code></pre></p><p>Copies modules into a special location so that they can be loaded afterwards.</p><p>:$force will allow installing over an existing distribution that has the same name, auth, api, and ver. Otherwise such a situation will result in Failure.</p><p><pre><code>my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\nmy $dist = Distribution::Path.new(...);\n$inst-repo.install($dist);</code></pre></p>","m":0},{"n":"uninstall","d":"<p><pre><code>method uninstall(Distribution $distribution)</code></pre></p><p>Removes the $distribution from the repository. $distribution should be obtained from the repository it is being removed from:</p><p><pre><code>my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\nmy $dist = $inst-repo.candidates(\"Acme::Unused\").head;\n$inst-repo.uninstall($dist);</code></pre></p>","m":0,"k":"m","s":{"p":[{"n":"$distribution","t":"Distribution"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"files","s":{"p":[{"t":"Any","n":"$file"},{"n":":$name!","t":"Str"},{"t":"Any","n":":$auth"},{"t":"Any","n":":$ver"},{"n":":$api","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming Zef is installed to the default location...\nmy $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\nsay $repo.files('bin/zef', :ver&lt;419.0+&gt;).head.&lt;name&gt;              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver&lt;419.0+&gt;).head.&lt;name&gt; // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;           # OUTPUT: «zef␤»</code></pre></p>","m":1},{"k":"m","d":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming Zef is installed to the default location...\nmy $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\nsay $repo.files('bin/zef', :ver&lt;419.0+&gt;).head.&lt;name&gt;              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver&lt;419.0+&gt;).head.&lt;name&gt; // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;           # OUTPUT: «zef␤»</code></pre></p>","n":"files","m":1,"s":{"p":[{"t":"Any","n":"$file"},{"t":"Any","n":":$auth"},{"n":":$ver","t":"Any"},{"n":":$api","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code>my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\nmy $inst-repo = CompUnit::Repository::Installation.new(prefix =&gt; $inst-repo-path);\nmy $dist = $inst-repo.candidates(\"Test\").head;\nsay \"Test version: \" ~ $dist.meta&lt;ver&gt;; # OUTPUT: «6.d␤»</code></pre></p>","m":1,"n":"candidates","s":{"p":[{"t":"Str","n":"$name"},{"n":":$auth","t":"Any"},{"n":":$ver","t":"Any"},{"n":":$api","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","d":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code>my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\nmy $inst-repo = CompUnit::Repository::Installation.new(prefix =&gt; $inst-repo-path);\nmy $dist = $inst-repo.candidates(\"Test\").head;\nsay \"Test version: \" ~ $dist.meta&lt;ver&gt;; # OUTPUT: «6.d␤»</code></pre></p>","s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"candidates"},{"d":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --&gt; CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","s":{"r":"CompUnit:D","p":[{"n":"$spec","t":"CompUnit::DependencySpecification"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"resolve","k":"m"},{"d":"<p><pre><code>method need(\n    CompUnit::DependencySpecification $spec,\n    CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n    CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n    --&gt; CompUnit:D)\n</code></pre></p><p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","k":"m","m":0,"s":{"r":"CompUnit:D","p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"t":"CompUnit::PrecompilationRepository","n":"$precomp?"},{"n":":@precomp-stores?","t":"Positional[CompUnit::PrecompilationStore]"},{"n":"*%_","t":"Mu"}]},"n":"need"},{"n":"resource","k":"m","s":{"r":"Mu","p":[{"n":"$dist-id","t":"Any"},{"t":"Any","n":"$key"},{"n":"*%_","t":"Mu"}]},"m":0},{"n":"id","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"short-id","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Iterable:D"},"k":"m","m":0,"d":"<p><pre><code>method loaded(--&gt; Iterable:D)</code></pre></p><p>Returns all CompUnits this repository has loaded.</p>","n":"loaded"},{"s":{"r":"Distribution","p":[{"n":"$id","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"distribution","m":0},{"n":"installed","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Iterable:D"}},{"m":0,"n":"precomp-store","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::PrecompilationStore:D"},"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"CompUnit::PrecompilationRepository:D"},"n":"precomp-repository","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"next-repo"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"abspath"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"prefix","m":0},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"!short-dir"},{"k":"m","s":{"p":[{"n":"$id","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!read-dist","m":0},{"m":0,"n":"!writeable-path","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"!repo-prefix","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"$dist-id","t":"Any"},{"n":":$meta","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!lazy-distribution","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!dist-dir"},{"k":"m","m":0,"n":"!precomp-stores","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"!file-id","s":{"p":[{"n":"$name","t":"Str"},{"t":"Str","n":"$dist-id"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"$spec","t":"CompUnit::DependencySpecification"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!matching-dist"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!bin-dir","k":"m"},{"s":{"p":[{"n":"$name","t":"Any"},{"t":"Any","n":"$dist"},{"t":"Any","n":"$source?"},{"t":"Any","n":"$checksum?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"!add-short-name"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!sources-dir","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"!resources-dir","m":0},{"k":"m","n":"!remove-dist-from-short-name-lookup-files","m":0,"s":{"p":[{"t":"Any","n":"$dist"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"!repository-version","m":0}],"t":"CompUnit::Repository::Installation","d":"<p><pre><code>class CompUnit::Repository::Installation\n    does CompUnit::Repository::Locally\n    does CompUnit::Repository::Installable\n    { }\n</code></pre></p><p>A CompUnit::Repository implementation backed by the filesystem, but uses an internal storage format to:</p>* <p>Handle case sensitivity issues on filesystems that may conflict as a CompUnit::Repository::FileSystem.</p><br>* <p>Handle allowable filename issues (e.g. unicode) on filesystems that don't support them.</p><br>* <p>Allow multiple distributions with the same name, but with different ver and/or auth and/or api values, to be installed and separately accessible in a single repository.</p><br>* <p>Enable faster module loading by providing module precompilation.</p><br><p>Because of the internal storage format the usual way to add a distribution is not by copying files but by calling CompUnit::Repository::Installation#method_install.</p>","k":"c","a":[{"k":"v","t":"Mu","n":"$!lock"},{"t":"Mu","n":"$!cver","k":"v"},{"t":"Associative","n":"%!loaded","k":"v"},{"t":"Associative","n":"%!seen","k":"v"},{"t":"Mu","k":"v","n":"$!precomp"},{"n":"$!id","t":"Mu","k":"v"},{"t":"Int","n":"$!version","k":"v"},{"t":"Associative","k":"v","n":"%!dist-metas"},{"n":"$!precomp-stores","k":"v","t":"Mu"},{"k":"v","n":"$!precomp-store","t":"Mu"},{"n":"$.next-repo","k":"v","t":"CompUnit::Repository"},{"k":"v","n":"$.abspath","t":"Str"},{"t":"IO::Path","k":"v","n":"$.prefix"},{"t":"ValueObjAt","n":"$.WHICH","k":"v"}],"mro":["CompUnit::Repository::Installable","CompUnit::Repository","CompUnit::Repository::Locally","Any"],"n":"CompUnit::Repository::Installation"},{"k":"c","a":[{"k":"v","t":"Associative","n":"%!loaded"},{"t":"CompUnit::Repository","n":"$.next-repo","k":"v"}],"n":"CompUnit::Repository::AbsolutePath","b":"A","t":"CompUnit::Repository::AbsolutePath","mro":["CompUnit::Repository","Any"],"m":[{"m":0,"s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"t":"CompUnit::PrecompilationRepository","n":"$precomp?"},{"n":"*%_","t":"Mu"}],"r":"CompUnit:D"},"n":"need","k":"m"},{"n":"load","m":0,"s":{"p":[{"t":"IO::Path","n":"$file"},{"n":"*%_","t":"Mu"}],"r":"CompUnit:D"},"k":"m"},{"k":"m","s":{"r":"Iterable:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"loaded"},{"k":"m","n":"id","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"path-spec","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"next-repo"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}]},{"a":[{"t":"Str","k":"v","n":"$.abspath"},{"n":"$.prefix","t":"IO::Path","k":"v"},{"n":"$.WHICH","t":"ValueObjAt","k":"v"}],"t":"CompUnit::Repository::Locally","n":"CompUnit::Repository::Locally","b":"C","k":"ro","m":[{"m":0,"n":"new","s":{"p":[{"t":"Any","n":":$prefix"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"n":"path-spec","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"$name","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"IO::Path:D"},"n":"source-file","m":0},{"m":0,"n":"id","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","n":"short-id","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}}],"mro":[]},{"m":[{"m":0,"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"TWEAK","k":"s"},{"m":0,"n":"BUILD","s":{"r":"Nil","p":[{"n":":$!dist","t":"Any"},{"t":"Any","n":":$!repo"},{"t":"Any","n":":$!dist-id"},{"n":":$!repo-name","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"},{"s":{"p":[{"n":"$dist","t":"Distribution"},{"n":"*%_","t":"Associative"}],"r":"Mu"},"k":"m","n":"new","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"meta","k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Str"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"id"},{"n":"from-precomp","s":{"r":"CompUnit::Repository::Distribution","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"serialize","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"raku","m":0},{"n":"repo","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"dist-id"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"repo-name","k":"m"},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL"}],"a":[{"n":"$!dist","k":"v","t":"Distribution"},{"t":"Mu","k":"v","n":"$!meta"},{"n":"$.repo","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.dist-id"},{"t":"Mu","k":"v","n":"$.repo-name"}],"n":"CompUnit::Repository::Distribution","mro":["Distribution","Any"],"b":"A","t":"CompUnit::Repository::Distribution","k":"c"},{"k":"c","b":"A","t":"CompUnit::Repository::FileSystem","a":[{"k":"v","t":"Associative","n":"%!loaded"},{"t":"Associative","k":"v","n":"%!seen"},{"t":"Mu","n":"$!precomp","k":"v"},{"n":"$!id","k":"v","t":"Mu"},{"t":"Mu","n":"$!precomp-stores","k":"v"},{"t":"Mu","n":"$!precomp-store","k":"v"},{"t":"Mu","n":"$!distribution","k":"v"},{"n":"$!files-prefix","k":"v","t":"Mu"},{"t":"CompUnit::Repository","k":"v","n":"$.next-repo"},{"t":"Str","n":"$.abspath","k":"v"},{"k":"v","t":"IO::Path","n":"$.prefix"},{"k":"v","n":"$.WHICH","t":"ValueObjAt"}],"d":"<p><pre><code>class CompUnit::Repository::FileSystem\n    does CompUnit::Repository::Locally\n    does CompUnit::Repository\n    { }\n</code></pre></p><p>A CompUnit::Repository implementation backed by the filesystem typically used in development situations. This is what is used by -I . / -I lib (which are actually -I file#. and -I file#lib) or use lib \".\" / use lib \"lib\". Unlike CompUnit::Repository::Installation, this represents a single distribution.</p>","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"id","k":"m","m":0},{"s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"*%_","t":"Mu"}],"r":"CompUnit:D"},"d":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --&gt; CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","m":0,"k":"m","n":"resolve"},{"m":0,"k":"m","d":"<p><pre><code>    method need(\n        CompUnit::DependencySpecification $spec,\n        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n        --&gt; CompUnit:D)\n</code></pre></p><p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"$precomp?","t":"CompUnit::PrecompilationRepository"},{"t":"Positional[CompUnit::PrecompilationStore]","n":":@precomp-stores?"},{"t":"Mu","n":"*%_"}],"r":"CompUnit:D"},"n":"need"},{"s":{"p":[{"n":"$file","t":"IO::Path"},{"t":"Mu","n":"*%_"}],"r":"CompUnit:D"},"n":"load","d":"<p><pre><code>method load(IO::Path:D $file --&gt; CompUnit:D)</code></pre></p><p>Load the $file and return a CompUnit object representing it.</p>","k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"short-id"},{"m":0,"s":{"r":"Iterable:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method loaded(--&gt; Iterable:D)</code></pre></p><p>Returns all CompUnits this repository has loaded.</p>","k":"m","n":"loaded"},{"k":"m","m":1,"d":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix =&gt; $*CWD);\nwith $repo.candidates(\"Zef\").head -&gt; $dist {\n    say \"Zef version: \" ~ $dist.meta&lt;version&gt;;\n}\nelse {\n    say \"No candidates for 'Zef' found\";\n}</code></pre></p>","s":{"p":[{"t":"Str","n":"$name"},{"t":"Any","n":":$auth"},{"t":"Any","n":":$ver"},{"t":"Any","n":":$api"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"candidates"},{"s":{"r":"Mu","p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix =&gt; $*CWD);\nwith $repo.candidates(\"Zef\").head -&gt; $dist {\n    say \"Zef version: \" ~ $dist.meta&lt;version&gt;;\n}\nelse {\n    say \"No candidates for 'Zef' found\";\n}</code></pre></p>","k":"m","n":"candidates","m":1},{"n":"files","m":1,"d":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix =&gt; $*CWD);\nsay $repo.files('bin/zef', :ver&lt;419.0+&gt;).head.&lt;name&gt;              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver&lt;419.0+&gt;).head.&lt;name&gt; // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;           # OUTPUT: «zef␤»</code></pre></p>","k":"m","s":{"p":[{"n":"$file","t":"Any"},{"t":"Str","n":":$name!"},{"t":"Any","n":":$auth"},{"t":"Any","n":":$ver"},{"n":":$api","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Any","n":"$file"},{"t":"Any","n":":$auth"},{"t":"Any","n":":$ver"},{"t":"Any","n":":$api"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix =&gt; $*CWD);\nsay $repo.files('bin/zef', :ver&lt;419.0+&gt;).head.&lt;name&gt;              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver&lt;419.0+&gt;).head.&lt;name&gt; // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver&lt;0.4.0+&gt;).head.&lt;name&gt;;           # OUTPUT: «zef␤»</code></pre></p>","n":"files"},{"n":"resource","s":{"p":[{"t":"Any","n":"$dist-id"},{"n":"$key","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"distribution","k":"m","m":0,"s":{"r":"Distribution","p":[{"t":"Str","n":"$id?"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::PrecompilationStore:D"},"m":0,"n":"precomp-store","k":"m"},{"k":"m","m":0,"s":{"r":"CompUnit::PrecompilationRepository:D","p":[{"n":"*%_","t":"Mu"}]},"n":"precomp-repository"},{"n":"next-repo","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"abspath","m":0,"k":"m"},{"k":"m","m":0,"n":"prefix","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!dist-from-ls"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"!precomp-stores","k":"m"},{"n":"!files-prefix","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"!comp-unit-id","k":"m","s":{"r":"Mu","p":[{"n":"$name","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"n":"!matching-dist","s":{"r":"Mu","p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!distribution","k":"m"}],"n":"CompUnit::Repository::FileSystem","mro":["CompUnit::Repository","CompUnit::Repository::Locally","Any"]},{"k":"c","b":"A","mro":["Any"],"t":"CompUnit::Repository::Spec","m":[{"s":{"r":"Mu","p":[{"t":"Str","n":"$spec"},{"t":"Any","n":":$default-short-id?"},{"n":"*%_","t":"Mu"}]},"n":"from-string","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"short-id","k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"options"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"path","k":"m","m":0},{"n":"Str","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","m":0,"k":"s"}],"a":[{"n":"$.short-id","t":"Mu","k":"v"},{"n":"%.options","k":"v","t":"Associative"},{"t":"Mu","n":"$.path","k":"v"},{"t":"Mu","n":"$.Str","k":"v"}],"n":"CompUnit::Repository::Spec"},{"b":"A","m":[{"n":"need","k":"m","m":0,"s":{"p":[{"t":"CompUnit::DependencySpecification","n":"$spec"},{"t":"CompUnit::PrecompilationRepository","n":"$precomp?"},{"t":"Positional[CompUnit::PrecompilationStore]","n":":@precomp-stores?"},{"t":"Mu","n":"*%_"}],"r":"CompUnit:D"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"loaded"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"id"},{"n":"Str","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"path-spec","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"short-name","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"next-repo","k":"m"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"CompUnit::Repository::Unknown","t":"CompUnit::Repository::Unknown","a":[{"t":"Mu","n":"$.path-spec","k":"v"},{"t":"Mu","k":"v","n":"$.short-name"},{"k":"v","n":"$.next-repo","t":"CompUnit::Repository"}],"mro":["CompUnit::Repository","Any"],"k":"c"},{"n":"CompUnit::Repository::NQP","k":"c","t":"CompUnit::Repository::NQP","m":[{"n":"need","m":0,"k":"m","s":{"r":"CompUnit:D","p":[{"n":"$spec","t":"CompUnit::DependencySpecification"},{"n":"$precomp?","t":"CompUnit::PrecompilationRepository"},{"n":"*%_","t":"Mu"}]}},{"n":"loaded","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"id","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"path-spec"},{"n":"next-repo","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"b":"A","mro":["CompUnit::Repository","Any"],"a":[{"t":"CompUnit::Repository","k":"v","n":"$.next-repo"}]},{"m":[{"s":{"r":"Mu","p":[{"t":"Distribution","n":"$dist"},{"n":"*%_","t":"Mu"}]},"n":"install","k":"m","m":0},{"k":"m","s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"can-install"},{"n":"installed","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Iterable:D"}}],"b":"C","t":"CompUnit::Repository::Installable","mro":["CompUnit::Repository"],"k":"ro","n":"CompUnit::Repository::Installable"},{"n":"CompUnit::Repository::Perl5","t":"CompUnit::Repository::Perl5","b":"A","a":[{"t":"CompUnit::Repository","k":"v","n":"$.next-repo"}],"mro":["CompUnit::Repository","Any"],"k":"c","m":[{"m":0,"n":"need","s":{"p":[{"n":"$spec","t":"CompUnit::DependencySpecification"},{"t":"CompUnit::PrecompilationRepository","n":"$precomp?"},{"n":"*%_","t":"Mu"}],"r":"CompUnit:D"},"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"loaded","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"id"},{"m":0,"n":"path-spec","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"next-repo","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}]},{"t":"CompUnit::PrecompilationUnit","mro":[],"m":[{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::PrecompilationId:D"},"n":"id","m":0},{"m":0,"k":"m","s":{"r":"IO::Path:D","p":[{"t":"Mu","n":"*%_"}]},"n":"path"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Instant:D"},"n":"modified"},{"s":{"r":"Array[CompUnit::PrecompilationDependency]","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"dependencies","k":"m"},{"k":"m","m":0,"s":{"r":"Buf:D","p":[{"n":"*%_","t":"Mu"}]},"n":"bytecode"},{"n":"checksum","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":0,"k":"m"},{"m":0,"n":"source-checksum","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"m":0,"s":{"r":"IO::Handle:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"bytecode-handle"},{"m":0,"n":"close","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"},{"m":0,"k":"m","n":"is-up-to-date","s":{"r":"Bool:D","p":[{"n":"$dependency","t":"CompUnit::PrecompilationDependency"},{"t":"Bool","n":":$check-source"},{"n":"*%_","t":"Mu"}]}}],"b":"C","k":"ro","n":"CompUnit::PrecompilationUnit"},{"mro":["CompUnit::PrecompilationUnit","Any"],"t":"CompUnit::PrecompilationStore::File::CompUnit::PrecompilationUnit::File","k":"c","a":[{"n":"$.id","k":"v","t":"CompUnit::PrecompilationId:D"},{"n":"$.path","k":"v","t":"IO::Path"},{"t":"Str","k":"v","n":"$!checksum"},{"t":"Str","n":"$!source-checksum","k":"v"},{"t":"Positional[CompUnit::PrecompilationDependency]","k":"v","n":"@!dependencies"},{"n":"$!bytecode","t":"Mu","k":"v"},{"n":"$!store","t":"Mu","k":"v"},{"k":"v","n":"$!initialized","t":"Bool"},{"t":"IO::Handle","k":"v","n":"$!handle"},{"t":"Lock","k":"v","n":"$!update-lock"}],"m":[{"n":"TWEAK","k":"s","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0},{"k":"m","s":{"r":"Instant:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"modified"},{"s":{"r":"Array[CompUnit::PrecompilationDependency]","p":[{"t":"Mu","n":"*%_"}]},"n":"dependencies","m":0,"k":"m"},{"n":"bytecode","s":{"r":"Buf:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"IO::Handle:D"},"n":"bytecode-handle"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"source-checksum"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"checksum"},{"m":0,"n":"Str","k":"m","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"close","k":"m"},{"s":{"r":"Mu","p":[{"n":"$precomp-file","t":"IO::Path"},{"t":"Mu","n":"*%_"}]},"n":"save-to","k":"m","m":0},{"s":{"r":"Bool:D","p":[{"t":"CompUnit::PrecompilationDependency","n":"$dependency"},{"t":"Bool","n":":$check-source"},{"t":"Mu","n":"*%_"}]},"n":"is-up-to-date","m":0,"k":"m"},{"n":"id","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"path","m":0},{"k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"},{"n":"!read-dependencies","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0}],"b":"A","n":"CompUnit::PrecompilationUnit::File"},{"m":[{"m":0,"s":{"p":[{"t":"Any","n":"|"}],"r":"CompUnit::PrecompilationUnit:D"},"k":"m","n":"new-unit"},{"m":0,"s":{"r":"Mu","p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":"*%_","t":"Mu"}]},"n":"load-unit","k":"m"},{"m":0,"n":"load-repo-id","k":"m","s":{"p":[{"t":"CompUnit::PrecompilationId","n":"$compiler-id"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"store-file","k":"m","s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"t":"CompUnit::PrecompilationId","n":"$precomp-id"},{"t":"IO::Path","n":"$path"},{"t":"Any","n":":$extension?"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"CompUnit::PrecompilationUnit","n":"$unit"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"store-unit","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"t":"CompUnit::PrecompilationId","n":"$precomp-id"},{"t":"Any","n":":$repo-id!"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"store-repo-id"},{"m":0,"n":"delete","s":{"r":"Mu","p":[{"t":"CompUnit::PrecompilationId","n":"$compiler-id"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"m","n":"delete-by-compiler","s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"mro":[],"b":"C","k":"ro","n":"CompUnit::PrecompilationStore","t":"CompUnit::PrecompilationStore"},{"mro":["CompUnit::PrecompilationStore","Any"],"a":[{"n":"$.prefix","k":"v","t":"IO::Path:D"},{"k":"v","t":"IO::Handle","n":"$!lock"},{"k":"v","t":"atomicint","n":"$!lock-count"},{"k":"v","n":"$!loaded","t":"Mu"},{"k":"v","t":"Mu","n":"$!dir-cache"},{"n":"$!compiler-cache","t":"Mu","k":"v"},{"n":"$!update-lock","k":"v","t":"Lock"}],"b":"A","m":[{"k":"s","n":"TWEAK","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"k":"m","n":"new-unit"},{"m":0,"n":"path","s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":":$extension?","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"unlock","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"CompUnit::PrecompilationId","n":"$compiler-id"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":"*%_","t":"Mu"}]},"n":"load-unit","k":"m"},{"s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"t":"CompUnit::PrecompilationId","n":"$precomp-id"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"load-repo-id"},{"m":0,"k":"m","s":{"p":[{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"remove-from-cache"},{"k":"m","m":0,"n":"destination","s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"t":"CompUnit::PrecompilationId","n":"$precomp-id"},{"t":"Str","n":":$extension?"},{"n":"*%_","t":"Mu"}],"r":"IO::Path:D"}},{"s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":"$path","t":"IO::Path"},{"t":"Str","n":":$extension?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"store-file","m":0,"k":"m"},{"s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":"$unit","t":"CompUnit::PrecompilationUnit"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"store-unit","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"Str","n":":$repo-id!"},{"t":"Mu","n":"*%_"}]},"n":"store-repo-id","m":0,"k":"m"},{"n":"delete","k":"m","s":{"r":"Mu","p":[{"t":"CompUnit::PrecompilationId","n":"$compiler-id"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":":$extension?","t":"Str"},{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"t":"Mu","n":"*%_"}]},"n":"delete-by-compiler","k":"m"},{"m":0,"n":"prefix","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL"},{"s":{"r":"Mu","p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"!dir","k":"m"},{"n":"!lock","m":0,"s":{"r":"Nil","p":[{"n":"$path","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"!file","k":"m","s":{"p":[{"n":"$compiler-id","t":"CompUnit::PrecompilationId"},{"n":"$precomp-id","t":"CompUnit::PrecompilationId"},{"n":":$extension?","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"IO::Path:D"}}],"k":"c","n":"CompUnit::PrecompilationStore::File","t":"CompUnit::PrecompilationStore::File"},{"t":"CompUnit::Handle","k":"c","a":[{"n":"$!module_ctx","k":"v","t":"Mu"},{"t":"Mu","n":"$!unit","k":"v"}],"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"new","m":1,"k":"s"},{"m":1,"n":"new","s":{"p":[{"n":"module_ctx","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"},{"m":0,"n":"ctxsave","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"from-unit","k":"s","s":{"p":[{"t":"Stash","n":"$unit"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"export-sub","s":{"r":"Callable:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"export-package","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Stash:D"},"k":"m"},{"m":0,"n":"export-how-package","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Stash:D"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"globalish-package","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"unit","m":0}],"b":"A","mro":["Any"],"n":"CompUnit::Handle"},{"t":"CompUnit::PrecompilationDependency","n":"CompUnit::PrecompilationDependency","mro":[],"m":[{"m":0,"s":{"r":"CompUnit::PrecompilationId:D","p":[{"t":"Mu","n":"*%_"}]},"n":"id","k":"m"},{"m":0,"n":"src","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"n":"spec","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"CompUnit::DependencySpecification:D"},"m":0},{"k":"m","n":"checksum","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"Str"},{"n":"serialize","k":"m","m":0,"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]}},{"n":"deserialize","k":"m","m":0,"s":{"r":"CompUnit::PrecompilationDependency:D","p":[{"n":"$","t":"Str"},{"t":"Mu","n":"*%_"}]}}],"b":"C","k":"ro"},{"mro":["CompUnit::PrecompilationDependency","Any"],"n":"CompUnit::PrecompilationDependency::File","b":"A","t":"CompUnit::PrecompilationDependency::File","k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"source-name","k":"m","m":0},{"n":"deserialize","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$str","t":"str"},{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"CompUnit::DependencySpecification:D","p":[{"t":"Mu","n":"*%_"}]},"n":"spec","k":"m"},{"k":"m","m":0,"n":"serialize","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Str","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"id","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"src","k":"m"},{"k":"m","n":"checksum","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"a":[{"t":"CompUnit::PrecompilationId","n":"$.id","k":"v"},{"t":"CompUnit::DependencySpecification","n":"$.spec","k":"v"},{"t":"Str","n":"$.src","k":"v"},{"n":"$.checksum","t":"Str","k":"v"},{"t":"Str","n":"$!serialized-spec","k":"v"}]},{"k":"c","a":[{"t":"str","n":"$.short-name","k":"v"},{"t":"str","n":"$.from","k":"v"},{"n":"$.version-matcher","t":"Mu","k":"v"},{"n":"$.auth-matcher","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$.api-matcher"}],"mro":["Any"],"b":"A","m":[{"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"n":"Str","m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"short-name","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"from","k":"m"},{"k":"m","n":"version-matcher","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"auth-matcher","k":"m"},{"k":"m","n":"api-matcher","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"CompUnit::DependencySpecification","t":"CompUnit::DependencySpecification"},{"b":"A","k":"c","t":"CompUnit::PrecompilationId","m":[{"m":0,"s":{"p":[{"n":"$id","t":"str"},{"t":"Mu","n":"*%_"}],"r":"CompUnit::PrecompilationId:D"},"k":"m","n":"new"},{"k":"m","s":{"r":"CompUnit::PrecompilationId:D","p":[{"t":"str","n":"$id"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"new-from-string"},{"n":"new-without-check","m":0,"s":{"r":"CompUnit::PrecompilationId:D","p":[{"t":"str","n":"$id"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"Str"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"IO","k":"m"},{"k":"m","n":"substr","m":0,"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"id"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"}],"n":"CompUnit::PrecompilationId","mro":["Any"],"a":[{"k":"v","n":"$.id","t":"Mu"}]},{"n":"&unimatch","k":"v","t":"Sub"},{"m":1,"k":"s","s":{"p":[{"n":"$str","t":"Str"},{"n":"c","t":"Any"}],"r":"Mu"},"n":"unimatch"},{"s":{"r":"Mu","p":[{"t":"Int","n":"$code"},{"t":"Stringy","n":"$pvalname"},{"t":"Stringy","n":"$propname"}]},"m":1,"n":"unimatch","k":"s"},{"s":{"r":"Mu","p":[{"n":"$code","t":"Int"},{"t":"Stringy","n":"$pvalname"},{"t":"Stringy","n":"$propname?"}]},"m":1,"n":"unimatch","k":"s"},{"t":"Int","m":[{"m":0,"s":{"p":[{"n":"$egg","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"n":"!eggify","k":"m"}],"mro":["Real","Numeric","Cool"],"b":"C","k":"c","n":"UINT64_UPPER"},{"t":"Real","m":[{"d":"<p><pre><code>method Rat(Real:D: Real $epsilon = 1e-6)</code></pre></p><p>Converts the number to a Rat with the precision $epsilon.</p>","k":"m","s":{"p":[{"n":"$epsilon?","t":"Real"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Rat","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"abs","k":"m"},{"n":"sign","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"d":"<p><pre><code>method sign(Real:D:)</code></pre></p><p>Returns -1 if the number is negative, 0 if it is zero and 1 otherwise.</p>"},{"n":"conj","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"sqrt","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"rand","d":"<p><pre><code>sub term:&lt;rand&gt; (--&gt; Num:D)\nmethod rand(Real:D: --&gt; Real:D)</code></pre></p><p>Returns a pseudo-random number between zero (inclusive) and the number (non-inclusive). The Bridge method is used to coerce the Real to a numeric that supports rand method.</p><p>The term form returns a pseudo-random Num between 0e0 (inclusive) and 1e0 (non-inclusive.)</p>"},{"m":0,"n":"sin","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","n":"asin","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"cos","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"acos"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"tan","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"atan","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"sec","k":"m","m":0},{"m":0,"n":"asec","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"cosec","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"acosec","k":"m"},{"m":0,"k":"m","n":"cotan","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"acotan","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"sinh","m":0},{"m":0,"n":"asinh","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"cosh"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"acosh","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"tanh"},{"m":0,"n":"atanh","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"sech","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"asech","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"cosech"},{"n":"acosech","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"cotanh","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"acotanh"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"d":"<p><pre><code>method floor(Real:D --&gt; Int:D)</code></pre></p><p>Return the largest integer not greater than the number.</p>","n":"floor"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"ceiling","m":0,"k":"m","d":"<p><pre><code>method ceiling(Real:D --&gt; Int:D)</code></pre></p><p>Returns the smallest integer not less than the number.</p>"},{"n":"unpolar","m":0,"s":{"p":[{"t":"Real","n":"$angle"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"cis","m":0,"k":"m"},{"m":0,"n":"Complex","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>method Complex(Real:D: --&gt; Complex:D)</code></pre></p><p>Converts the number to a Complex with the number converted to a Num as its real part and 0e0 as the imaginary part.</p>"},{"m":0,"d":"<p><pre><code>method truncate(Real:D --&gt; Int:D)</code></pre></p><p>Rounds the number towards zero.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"truncate"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"isNaN","m":0},{"d":"<p><pre><code>method polymod(Real:D: +@mods)</code></pre></p><p>Returns the remainders after applying sequentially all divisors in the @mods argument; the last element of the array will be the last remainder.</p><p><pre><code>say (1e8+1).polymod(10 xx 8);  # OUTPUT: «(1 0 0 0 0 0 0 0 1)␤»</code></pre></p><p>10 xx 8 is simply an array with eight number 10s; the first division by 10 will return 1 as a remainder, while the rest, up to the last, will return 0. With 8 divisors, as above, the result will have one more elements, in this case for the last remainder.</p>","m":0,"s":{"p":[{"t":"Positional","n":"+@mods"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"polymod","k":"m"},{"n":"base","m":0,"k":"m","s":{"p":[{"n":"$base","t":"Int"},{"t":"Any","n":"$digits?"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method Bridge(Real:D:)</code></pre></p><p>Default implementation coerces the invocant to Num and that's the behavior of this method in core Real types. This method primarily exist to make it easy to implement custom Real types by users, with the Bridge method returning one of the core Real types (NOT necessarily a Num) that best represent the custom Real type. In turn, this lets all the core operators and methods obtain a usable value they can work with.</p><p>As an example, we can implement a custom Temperature type. It has a unit of measure and the value, which are given during instantiation. We can implement custom operators or conversion methods that work with this type. When it comes to regular mathematical operators, however, we can simply use the .Bridge method to convert the Temperature to Kelvin expressed in one of the core numeric types:</p><p><pre><code>class Temperature is Real {\n    has Str:D  $.unit  is required where any &lt;K F C&gt;;\n    has Real:D $.value is required;\n    method new ($value, :$unit = 'K') { self.bless :$value :$unit }\n    # Note: implementing .new() that handles $value of type Temperature is left as an exercise\n\n    method Bridge {\n        when $!unit eq 'F' { ($!value + 459.67) × 5/9 }\n        when $!unit eq 'C' {  $!value + 273.15 }\n        $!value\n    }\n    method gist { self.Str }\n    method Str  { \"$!value degrees $!unit\" }\n}\n\nsub postfix:&lt;℃&gt; { Temperature.new: $^value, :unit&lt;C&gt; }\nsub postfix:&lt;℉&gt; { Temperature.new: $^value, :unit&lt;F&gt; }\nsub postfix:&lt;K&gt; { Temperature.new: $^value, :unit&lt;K&gt; }\n\nmy $human := 36.6℃;\nmy $book  := 451℉;\nmy $sun   := 5778K;\nsay $human;                # OUTPUT: «36.6 degrees C␤»\nsay $human + $book + $sun; # OUTPUT: «6593.677777777778␤»\nsay 123K + 456K;           # OUTPUT: «579␤»</code></pre></p><p>As we can see from the last two lines of the output, the type of the bridged result is not forced to be any particular core type. It is a Rat, when we instantiated Temperature with a Rat or when conversion was involved, and it is an Int when we instantiated Temperature with an Int.</p>","k":"m","n":"Bridge","m":0},{"n":"Int","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Num","m":0}],"d":"<p><pre><code>role Real does Numeric { ... }</code></pre></p><p>Common role for non-Complex numbers.</p>","k":"ro","b":"C","mro":["Numeric"],"n":"Real"},{"k":"v","t":"Sub+{is-nodal}","n":"&postcircumfix:<{; }>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"@indices","t":"Positional"}]},"k":"s","m":1,"n":"postcircumfix:<{; }>"},{"n":"postcircumfix:<{; }>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Positional","n":"@indices"},{"n":":$exists!","t":"Any"}]}},{"k":"v","d":"<p><pre><code>multi sub infix:&lt;^..^&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</code></pre></p><p>Open range operator</p><p>Constructs a Range from the arguments, excluding both start and end point.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<^..^>"},{"m":1,"n":"infix:<^..^>","k":"s","s":{"p":[{"n":"$min","t":"Any"},{"t":"Any","n":"$max"}],"r":"Mu"}},{"t":"Sub+{is-pure}","n":"&infix:<≥>","d":"<p>Numeric greater than or equal to operator.</p><p>Equivalent to &gt;=, at codepoint U+2265 (GREATER-THAN OR EQUAL TO).</p>","k":"v"},{"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"n":"infix:<≥>","m":1,"k":"s"},{"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"n":"infix:<≥>","m":1,"k":"s"},{"n":"infix:<≥>","m":1,"k":"s","s":{"p":[{"t":"Real","n":"a"},{"n":"b","t":"Real"}],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"n":"infix:<≥>"},{"m":1,"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"Bool:D"},"n":"infix:<≥>","k":"s"},{"n":"infix:<≥>","s":{"r":"Bool:D","p":[{"n":"a","t":"Num"},{"t":"Num","n":"b"}]},"k":"s","m":1},{"k":"s","n":"infix:<≥>","s":{"p":[{"t":"num","n":"$a"},{"t":"num","n":"$b"}],"r":"Bool:D"},"m":1},{"n":"infix:<≥>","s":{"p":[{"n":"a","t":"Rational"},{"t":"Rational","n":"b"}],"r":"Bool:D"},"k":"s","m":1},{"m":1,"n":"infix:<≥>","s":{"r":"Bool:D","p":[{"n":"a","t":"Rational"},{"t":"Int","n":"b"}]},"k":"s"},{"m":1,"n":"infix:<≥>","k":"s","s":{"p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}],"r":"Bool:D"}},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}]},"n":"infix:<≥>"},{"s":{"p":[{"n":"a","t":"DateTime"},{"n":"b","t":"DateTime"}],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<≥>"},{"n":"infix:<≥>","m":1,"s":{"r":"Bool:D","p":[{"t":"Date","n":"$a"},{"t":"Date","n":"$b"}]},"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Version","n":"a"},{"n":"b","t":"Version"}]},"n":"infix:<≥>"},{"k":"ro","d":"<p>A PredictiveIterator is a special kind of Iterator that can know how many values it will (still) generate without actually needing to generate those values.</p><p>The main addition to the API of the Iterator role, is the count-only method, which should return the number of values the Iterator is still able to generate.</p><p>The other addition is the bool-only method, that should return a Bool indicating whether the Iterator is still capable of producing values (aka, is not exhausted yet). By default, this is the Booleanification of the result of the call to the count-only method.</p>","t":"PredictiveIterator","b":"C","m":[{"n":"count-only","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method count-only(--&gt; Int:D) { ... }</code></pre></p><p>It is expected to return the number of values the iterator can still produce without actually producing them. The returned number must adjust itself for items already pulled, so that the method can be called on a partially consumed Iterator.</p><p>It will be used in situations where only the number of values of an iterator is needed, e.g. when the .elems method is called.</p><p>Important: it's expected the Iterators that implement this method can return that number without producing any values. In other words, it's expected the user of the class will be able to still pull-one after calling this method, and eventually receive as many values as the return value of this method indicated.</p>","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]}},{"n":"bool-only","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":0,"k":"m"}],"mro":["Iterator"],"n":"PredictiveIterator"},{"t":"Sub","k":"v","n":"&substr-rw"},{"m":1,"n":"substr-rw","s":{"r":"Mu","p":[{"n":"what","t":"Any"}]},"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"what"},{"n":"from","t":"Any"}]},"n":"substr-rw"},{"m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"what"},{"n":"from","t":"Any"},{"n":"chars","t":"Any"}]},"k":"s","n":"substr-rw"},{"n":"&infix:<⚛=>","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[{"n":"$target","t":"Any"},{"n":"value","t":"Any"}]},"k":"s","m":1,"n":"infix:<⚛=>"},{"m":1,"s":{"r":"Mu","p":[{"t":"atomicint","n":"$target"},{"t":"int","n":"$value"}]},"n":"infix:<⚛=>","k":"s"},{"k":"s","s":{"p":[{"n":"$target","t":"atomicint"},{"n":"$value","t":"Int"}],"r":"Mu"},"m":1,"n":"infix:<⚛=>"},{"n":"infix:<⚛=>","s":{"p":[{"t":"atomicint","n":"$target"},{"n":"$value","t":"Any"}],"r":"Mu"},"k":"s","m":1},{"t":"Endian","n":"LittleEndian","k":"e"},{"t":"Sub+{is-pure}","n":"&all","k":"v"},{"s":{"p":[{"n":"@values","t":"Positional"}],"r":"Mu"},"k":"s","n":"all","m":1},{"n":"all","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"+values"}]}},{"n":"&substr","t":"Sub","k":"v"},{"m":1,"k":"s","n":"substr","s":{"r":"Str:D","p":[{"t":"Any","n":"what"}]}},{"m":1,"n":"substr","k":"s","s":{"p":[{"t":"Any","n":"what"},{"t":"Any","n":"from"}],"r":"Str:D"}},{"m":1,"s":{"p":[{"t":"Any","n":"what"},{"n":"from","t":"Any"},{"n":"chars","t":"Any"}],"r":"Str:D"},"k":"s","n":"substr"},{"k":"v","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:«(<=)»"},{"s":{"r":"Bool:D","p":[{"t":"Setty","n":"a"},{"n":"b","t":"Setty"}]},"n":"infix:«(<=)»","m":1,"k":"s"},{"k":"s","s":{"p":[{"t":"Setty","n":"a"},{"t":"Mixy","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:«(<=)»"},{"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"n":"infix:«(<=)»","k":"s","m":1},{"n":"infix:«(<=)»","k":"s","s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"m":1},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}]},"k":"s","n":"infix:«(<=)»"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}]},"n":"infix:«(<=)»","k":"s"},{"k":"s","m":1,"n":"infix:«(<=)»","s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"t":"Setty","n":"b"}]}},{"m":1,"n":"infix:«(<=)»","s":{"r":"Bool:D","p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Any"}]},"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}],"r":"Bool:D"},"n":"infix:«(<=)»","k":"s"},{"m":1,"k":"s","n":"infix:«(<=)»","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}],"r":"Bool:D"}},{"m":1,"n":"infix:«(<=)»","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Setty","n":"b"}],"r":"Bool:D"},"k":"s"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":[{"t":"Baggy","n":"a"},{"t":"Any","n":"b"}]},"k":"s","m":1},{"k":"s","n":"infix:«(<=)»","s":{"p":[{"t":"Map","n":"a"},{"t":"Map","n":"b"}],"r":"Bool:D"},"m":1},{"m":1,"s":{"p":[{"n":"a","t":"Iterable"},{"n":"b","t":"Map"}],"r":"Bool:D"},"n":"infix:«(<=)»","k":"s"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"t":"Mixy","n":"b"}]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Any"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"n":"infix:«(<=)»"},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Setty"}],"r":"Bool:D"},"n":"infix:«(<=)»","k":"s"},{"k":"s","m":1,"n":"infix:«(<=)»","s":{"p":[{"n":"a","t":"Failure"},{"t":"Any","n":"$"}],"r":"Mu"}},{"k":"s","m":1,"n":"infix:«(<=)»","s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"t":"Failure","n":"b"}]}},{"n":"infix:«(<=)»","k":"s","m":1,"s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]}},{"t":"FileChangeEvent","k":"e","n":"FileRenamed"},{"n":"&callwith","t":"Sub","k":"v"},{"n":"callwith","s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"m":0,"k":"s"},{"mro":["Real","Numeric","Cool"],"k":"c","t":"Num","n":"pi","b":"C"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub infix:&lt;ne&gt;(Mu,    Mu)\nmulti sub infix:&lt;ne&gt;(Str:D, Str:D)</code></pre></p><p>String inequality operator.</p><p>Coerces both arguments to Str (if necessary); returns False if both are equal.</p><p>Mnemonic: not equal</p>","n":"&infix:<ne>"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"$x?"}],"r":"Mu"},"n":"infix:<ne>"},{"n":"infix:<ne>","m":1,"s":{"p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"b"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<ne>"},{"k":"s","m":1,"n":"infix:<ne>","s":{"r":"Bool:D","p":[{"t":"Blob","n":"a"},{"n":"b","t":"Blob"}]}},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Str"},{"t":"Str","n":"b"}]},"k":"s","m":1,"n":"infix:<ne>"},{"n":"infix:<ne>","k":"s","m":1,"s":{"r":"Bool:D","p":[{"n":"$a","t":"str"},{"n":"$b","t":"str"}]}},{"b":"A","n":"JSONException","a":[{"k":"v","t":"Mu","n":"$.text"},{"t":"Mu","k":"v","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Exception"],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"message","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"text","k":"m","m":0},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"k":"c","t":"JSONException"},{"k":"v","n":"&trim","t":"Sub"},{"m":1,"k":"s","n":"trim","s":{"p":[{"t":"Cool","n":"$s"}],"r":"Str:D"}},{"d":"<p><pre><code>multi sub prefix:&lt;!&gt;(Mu --&gt; Bool:D)</code></pre></p><p>Negated boolean context operator.</p><p>Coerces the argument to Bool by calling the Bool method on it, and returns the negation of the result. Note that this collapses Junctions.</p>","n":"&prefix:<!>","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":[{"n":"a","t":"Bool"}],"r":"Mu"},"k":"s","n":"prefix:<!>","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mu"}]},"n":"prefix:<!>","k":"s"},{"s":{"p":[{"n":"a","t":"Mu"},{"n":":$exists!","t":"Any"}],"r":"Mu"},"m":1,"k":"s","n":"prefix:<!>"},{"t":"Sub+{Precedence}","n":"&infix:<…>","k":"v"},{"n":"infix:<…>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Mu"}]},"m":1},{"s":{"r":"Mu","p":[{"t":"Any","n":"lol"}]},"k":"s","m":1,"n":"infix:<…>"},{"n":"&infix:<or>","k":"v","d":"<p>Same as infix ||, except with looser precedence.</p><p>Returns the first argument that evaluates to True in boolean context, or otherwise the last argument, it short-circuits. Please note that or is easy to misuse. See traps.</p><p></p>","t":"Sub+{Precedence}"},{"k":"s","m":1,"s":{"p":[{"n":"$x?","t":"Mu"}],"r":"Mu"},"n":"infix:<or>"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Mu"},{"t":"Callable","n":"&b"}],"r":"Mu"},"n":"infix:<or>"},{"n":"infix:<or>","s":{"p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"b"}],"r":"Mu"},"k":"s","m":1},{"n":"&mkdir","k":"v","t":"Sub"},{"k":"s","m":1,"n":"mkdir","s":{"p":[{"n":"$path","t":"Any"},{"n":"$mode?","t":"Any"}],"r":"Mu"}},{"t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub infix:&lt;(-)&gt;(**@p)\nmulti sub infix:&lt;∖&gt;(**@p)</code></pre></p><p>Set difference operator.</p><p>Returns the set difference of all its arguments. This creates a new Set that contains all the elements the first argument has but the rest of the arguments don't, i.e., of all the elements of the first argument, minus the elements from the other arguments. But only if none of the arguments are a Bag, BagHash, Mix or MixHash.</p><p><pre><code>say &lt;a a b c a d&gt; (-) &lt;a a b c c&gt;; # OUTPUT: «set(d)␤»\nsay &lt;a b c d e&gt; (-) &lt;a b c&gt; (-) &lt;a b d&gt;; # OUTPUT: «set(e)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy&gt;, the result is a new Bag (or Mix) containing all the elements remaining after the first argument with its weight subtracted by the weight of that element in each of the other arguments.</p><p><pre><code>say &lt;a a b c a d&gt; (-) bag(&lt;a b c c&gt;); # OUTPUT: «Bag(a(2), d)␤»\nsay &lt;a a b c a d&gt;  ∖  mix(&lt;a b c c&gt;); # OUTPUT: «Mix(a(2), c(-1), d)␤»\n</code></pre></p><p>∖ is equivalent to (-), at codepoint U+2216 (SET MINUS).</p>","n":"&infix:<(-)>"},{"n":"infix:<(-)>","k":"s","s":{"p":[],"r":"Mu"},"m":1},{"k":"s","m":1,"n":"infix:<(-)>","s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"SetHash"}],"r":"Mu"},"n":"infix:<(-)>"},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"BagHash"}]},"k":"s","n":"infix:<(-)>"},{"m":1,"s":{"p":[{"t":"MixHash","n":"a"}],"r":"Mu"},"n":"infix:<(-)>","k":"s"},{"m":1,"n":"infix:<(-)>","s":{"p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}],"r":"Mu"},"k":"s"},{"m":1,"n":"infix:<(-)>","k":"s","s":{"r":"Mu","p":[{"t":"Setty","n":"a"},{"t":"Map","n":"b"}]}},{"m":1,"n":"infix:<(-)>","s":{"p":[{"t":"Setty","n":"a"},{"t":"Iterable","n":"b"}],"r":"Mu"},"k":"s"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Mixy","n":"b"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Mixy","n":"a"},{"n":"b","t":"QuantHash"}],"r":"Mu"},"n":"infix:<(-)>","k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"QuantHash","n":"a"},{"t":"Mixy","n":"b"}],"r":"Mu"},"n":"infix:<(-)>"},{"k":"s","n":"infix:<(-)>","m":1,"s":{"p":[{"t":"Mixy","n":"a"},{"t":"Map","n":"b"}],"r":"Mu"}},{"n":"infix:<(-)>","s":{"p":[{"n":"a","t":"Mixy"},{"t":"Any","n":"b"}],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(-)>","k":"s","s":{"p":[{"n":"a","t":"Any"},{"t":"Mixy","n":"b"}],"r":"Mu"},"m":1},{"m":1,"n":"infix:<(-)>","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"t":"Mixy","n":"b"}]},"k":"s"},{"s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"t":"Baggy","n":"b"}]},"n":"infix:<(-)>","m":1,"k":"s"},{"k":"s","m":1,"n":"infix:<(-)>","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"t":"QuantHash","n":"b"}]}},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"QuantHash"},{"t":"Baggy","n":"b"}]},"m":1,"n":"infix:<(-)>"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Map"}],"r":"Mu"}},{"m":1,"n":"infix:<(-)>","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Any"}]},"k":"s"},{"m":1,"n":"infix:<(-)>","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Baggy"}]},"k":"s"},{"n":"infix:<(-)>","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Map"}],"r":"Mu"},"k":"s"},{"m":1,"n":"infix:<(-)>","k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Iterable"}],"r":"Mu"}},{"n":"infix:<(-)>","k":"s","s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}]},"m":1},{"n":"infix:<(-)>","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"t":"Any","n":"$"}]}},{"k":"s","n":"infix:<(-)>","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]}},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Positional","n":"+@p"}]}},{"k":"v","t":"Sub","n":"&pairs"},{"m":1,"s":{"r":"Mu","p":[{"n":"$x","t":"Any"}]},"n":"pairs","k":"s"},{"t":"Sub","n":"&sum","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"sum"},{"m":1,"n":"sum","s":{"p":[{"t":"Any","n":"SELF"}],"r":"Mu"},"k":"s"},{"n":"sum","k":"s","m":1,"s":{"p":[{"t":"Any","n":"+SELF"}],"r":"Mu"}},{"k":"v","t":"Sub","n":"&squish"},{"s":{"p":[{"n":"+values","t":"Any"},{"n":"c","t":"Any"}],"r":"Mu"},"m":1,"n":"squish","k":"s"},{"t":"Regex","mro":["Callable","Method"],"d":"<p><pre><code>class Regex is Method { }</code></pre></p><p>A regex is a kind of pattern that describes a set of strings. The process of finding out whether a given string is in the set is called matching. The result of such a matching is a Match object, which evaluates to True in boolean context if the string is in the set.</p><p>A regex is typically constructed by a regex literal</p><p><pre><code>rx/ ^ab /;      # describes all strings starting with 'ab'\n/ ^ ab /;       # same\nrx/ \\d ** 2/;   # describes all strings containing at least two digits</code></pre></p><p> A named regex can be defined with the regex declarator followed by its definition in curly braces. Since any regex does Callable introspection requires referencing via &amp;-sigil.</p><p><pre><code>my regex R { \\N };\nsay &amp;R.^name; # OUTPUT: «Regex␤»</code></pre></p><p>To match a string against a regex, you can use the smartmatch operator:</p><p><pre><code>my $match = 'abc' ~~ rx/ ^ab /;\nsay $match.Bool;                # OUTPUT: «True␤»\nsay $match.orig;                # OUTPUT: «abc␤»\nsay $match.Str;                 # OUTPUT: «ab␤»\nsay $match.from;                # OUTPUT: «0␤»\nsay $match.to;                  # OUTPUT: «2␤»</code></pre></p><p>Or you can evaluate the regex in boolean context, in which case it matches against the $_ variable</p><p><pre><code>$_ = 'abc';\nif / ^ab / {\n    say '\"abc\" begins with \"ab\"';\n}\nelse {\n    say 'This is a weird alternative Universe';\n}</code></pre></p>","a":[{"t":"Mu","n":"$!caps","k":"v"},{"t":"Mu","n":"$!nfa","k":"v"},{"n":"%!alt_nfas","k":"v","t":"Hash"},{"n":"$!source","t":"str","k":"v"},{"t":"Mu","k":"v","n":"$!topic"},{"k":"v","t":"Mu","n":"$!slash"},{"n":"@!dispatchees","t":"List","k":"v"},{"k":"v","n":"$!dispatcher_cache","t":"Mu"},{"k":"v","t":"Mu","n":"$!dispatcher"},{"t":"int","k":"v","n":"$!flags"},{"k":"v","n":"$!inline_info","t":"Mu"},{"k":"v","n":"$!package","t":"Mu"},{"t":"int","n":"$!onlystar","k":"v"},{"n":"@!dispatch_order","k":"v","t":"List"},{"n":"$!dispatch_cache","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!why"},{"t":"Code","n":"$!do","k":"v"},{"n":"$!signature","k":"v","t":"Signature"},{"t":"List","k":"v","n":"@!compstuff"}],"b":"A","m":[{"d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>","n":"ACCEPTS","m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"*%_"}]}},{"k":"m","m":1,"s":{"p":[{"t":"Any","n":"topic"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"ACCEPTS","d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>"},{"k":"m","m":1,"n":"ACCEPTS","d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>","s":{"p":[{"n":"topic","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>","s":{"p":[{"n":"uni","t":"Uni"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"ACCEPTS","k":"m"},{"s":{"p":[{"t":"Positional","n":"@a"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>","n":"ACCEPTS","m":1,"k":"m"},{"d":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --&gt; Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>","n":"ACCEPTS","k":"m","m":1,"s":{"p":[{"t":"Associative","n":"%h"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Regex","p":[{"n":":$topic","t":"Mu"},{"t":"Mu","n":":$slash"},{"t":"Mu","n":"*%_"}]},"n":"clone"},{"n":"!Bool6c","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"t":"Any","n":"topic"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!ACCEPTS-Any","m":0,"k":"m"},{"n":"!ACCEPT-ITERATOR","s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"iter","t":"Iterator"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0}],"n":"Regex","k":"c"},{"n":"&infix:<//>","t":"Sub+{Precedence}","k":"v","d":"<p>The defined-or operator or infix // returns the first defined operand, or else the last operand. Short-circuits.</p><p><pre><code>say Any // 0 // 42;         # OUTPUT: «0␤»</code></pre></p>"},{"m":1,"n":"infix:<//>","k":"s","s":{"p":[{"n":"$x?","t":"Mu"}],"r":"Mu"}},{"n":"infix:<//>","m":1,"s":{"p":[{"t":"Mu","n":"a"},{"t":"Callable","n":"&b"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Mu"},{"t":"Mu","n":"b"}],"r":"Mu"},"k":"s","n":"infix:<//>"},{"t":"Sub","k":"v","n":"&print"},{"m":1,"s":{"r":"Bool","p":[]},"n":"print","k":"s"},{"k":"s","s":{"r":"Mu","p":[{"t":"Junction","n":"j"}]},"m":1,"n":"print"},{"m":1,"s":{"p":[{"n":"x","t":"Str"}],"r":"Mu"},"n":"print","k":"s"},{"n":"print","k":"s","s":{"p":[{"t":"Any","n":"x"}],"r":"Mu"},"m":1},{"n":"print","k":"s","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"m":1},{"t":"Sub","k":"v","n":"&pop"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"@a","t":"Positional"}]},"n":"pop"},{"k":"v","t":"Sub","n":"&not"},{"m":1,"s":{"p":[{"n":"$","t":"Bool"}],"r":"Bool"},"k":"s","n":"not"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"x"}]},"m":1,"n":"not","k":"s"},{"n":"&infix:«(>=)»","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"n":"infix:«(>=)»","m":1,"k":"s"},{"n":"DateTime","b":"A","m":[{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","n":"new","s":{"r":"DateTime:D","p":[{"t":"Any","n":"y"},{"t":"Any","n":"mo"},{"t":"Any","n":"d"},{"t":"Any","n":"h"},{"t":"Any","n":"mi"},{"n":"s","t":"Any"},{"t":"Any","n":":$timezone?"},{"n":":&formatter","t":"Callable"},{"t":"Associative","n":"*%_"}]}},{"m":1,"k":"m","s":{"p":[{"n":":$year!","t":"Any"},{"n":":$month?","t":"Any"},{"t":"Any","n":":$day?"},{"n":":$hour?","t":"Any"},{"n":":$minute?","t":"Any"},{"n":":$second?","t":"Any"},{"n":":$timezone?","t":"Any"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Associative"}],"r":"DateTime:D"},"d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","n":"new"},{"m":1,"s":{"p":[{"t":"Date","n":":$date!"},{"n":"*%_","t":"Associative"}],"r":"DateTime:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","n":"new"},{"m":1,"s":{"r":"DateTime:D","p":[{"t":"Instant","n":"$i"},{"n":":$timezone?","t":"Any"},{"t":"Associative","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","n":"new"},{"d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","m":1,"s":{"r":"DateTime:D","p":[{"t":"Numeric","n":"$epoch"},{"n":":$timezone?","t":"Any"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Associative"}]},"k":"m","n":"new"},{"n":"new","s":{"p":[{"n":"$datetime","t":"Str"},{"n":":$timezone","t":"Any"},{"t":"Callable","n":":&formatter"},{"n":"*%_","t":"Associative"}],"r":"DateTime:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","m":1},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&amp;formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&amp;formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&amp;formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&amp;formatter)\nmulti method new(Str:D $format, :$timezone=0, :&amp;formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year =&gt; 2015,\n                            month =&gt; 1,\n                            day =&gt; 1,\n                            hour =&gt; 1,\n                            minute =&gt; 1,\n                            second =&gt; 1,\n                            timezone =&gt; 1);\n$datetime = DateTime.new(date =&gt; Date.new('2015-12-24'),\n                         hour =&gt; 1,\n                         minute =&gt; 1,\n                         second =&gt; 1,\n                         timezone =&gt; 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","n":"new","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"now","k":"m","d":"<p>Defined as:</p><p><pre><code>method now(:$timezone = $*TZ, :&amp;formatter --&gt; DateTime:D)</code></pre></p><p>Creates a new DateTime object from the current system time. A custom formatter and timezone can be provided. The :$timezone is the offset in seconds from GMT and defaults to the value of $*TZ variable.</p><p><pre><code>say DateTime.now; # OUTPUT: «2018-01-08T13:05:32.703292-06:00␤»</code></pre></p><p>Note that one may use the methods shown below chained to the .now to easily express current values, e.g.,</p><p><pre><code>say DateTime.now.year; # OUTPUT: «2018␤»</code></pre></p>","s":{"r":"DateTime:D","p":[{"t":"Any","n":":$timezone?"},{"n":":&formatter","t":"Callable"},{"n":"*%_","t":"Mu"}]}},{"n":"clone","d":"<p>Defined as:</p><p><pre><code>method clone(:$year, :$month, :$day, :$hour, :$minute, :$second, :$timezone, :&amp;formatter)</code></pre></p><p>Creates a new DateTime object based on the invocant, but with the given arguments overriding the values from the invocant.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').clone(hour =&gt; 0);\n# OUTPUT: «2015-12-24T00:23:00Z␤»</code></pre></p><p>Note that this can lead to invalid dates in some circumstances:</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56Z\").clone(year =&gt; 2015);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::OutOfRange: Day out of range. Is: 29, should be in 1..28␤»</code></pre></p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Associative"}],"r":"DateTime:D"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Instant:D"},"n":"Instant","m":0,"d":"<p>Defined as:</p><p><pre><code>method Instant(DateTime:D: --&gt; Instant:D)</code></pre></p><p>Returns an Instant object based on the invocant.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').Instant; # OUTPUT: «Instant:1450952616␤»</code></pre></p>","k":"m"},{"m":0,"n":"posix","k":"m","d":"<p>Defined as:</p><p><pre><code>method posix(Bool:D: $ignore-timezone = False --&gt; Int:D)</code></pre></p><p>Returns the date and time as a POSIX/UNIX timestamp (seconds since the Epoch, 1st January 1970 UTC).</p><p>If $ignore-timezone is True, the DateTime object will be treated as if the time zone offset is zero.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').posix;       # OUTPUT: «1450959780␤»\n</code></pre></p>","s":{"r":"Int:D","p":[{"n":"$ignore-timezone?","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method offset(DateTime:D: --&gt; Int:D)</code></pre></p><p>Returns the time zone in seconds as an offset from UTC. This is an alias for #method timezone.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset;            # OUTPUT: «7200␤»</code></pre></p>","n":"offset","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]}},{"n":"offset-in-minutes","k":"m","d":"<p>Defined as:</p><p><pre><code>method offset-in-minutes(DateTime:D: --&gt; Real:D)</code></pre></p><p>Returns the time zone in minutes as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset-in-minutes; # OUTPUT: «120␤»</code></pre></p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Rat:D"}},{"d":"<p>Defined as:</p><p><pre><code>method offset-in-hours(DateTime:D: --&gt; Real:D)</code></pre></p><p>Returns the time zone in hours as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset-in-hours;   # OUTPUT: «2␤»\n</code></pre></p>","k":"m","m":0,"n":"offset-in-hours","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Rat:D"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method hh-mm-ss(DateTime:D: --&gt; Str:D)</code></pre></p><p>Returns the time represented by the object as a string in 24-hour HH:MM:SS format:</p><p><pre><code>say DateTime.new(\"2052-02-29T22:34:56Z\").hh-mm-ss;\n# OUTPUT: «22:34:56␤»</code></pre></p>","n":"hh-mm-ss"},{"d":"<p>Defined as:</p><p><pre><code>method later(DateTime:D: *%unit)</code></pre></p><p>Returns a DateTime object based on the current one, but with a time delta applied. The time delta can be passed as a named argument where the argument name is the unit.</p><p>Unless the given unit is second or seconds, the given value will be converted to an Int.</p><p>Allowed units are second, seconds, minute, minutes, hour, hours, day, days, week, weeks, month, months, year, years. Please note that the plural forms can only be used with the later and earlier methods.</p><p>The :2nd form of colonpairs can be used as a compact and self-documenting way of specifying the delta:</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').later(:2years);\n# OUTPUT: «2017-12-24T12:23:00Z␤»</code></pre></p><p>Since addition of several different time units is not commutative, only one unit may be passed.</p><p><pre><code>my $d = DateTime.new(date =&gt; Date.new('2015-02-27'));\nsay $d.later(month =&gt; 1).later(:2days);  # OUTPUT: «2015-03-29T00:00:00Z␤»\nsay $d.later(days =&gt; 2).later(:1month);  # OUTPUT: «2015-04-01T00:00:00Z␤»\nsay $d.later(days =&gt; 2).later(:month);   # same, as +True === 1</code></pre></p><p>If the resultant time has value 60 for seconds, yet no leap second actually exists for that time, seconds will be set to 59:</p><p><pre><code>say DateTime.new('2008-12-31T23:59:60Z').later: :1day;\n# OUTPUT: «2009-01-01T23:59:59Z␤»</code></pre></p><p>Negative offsets are allowed, though earlier is more idiomatic for that.</p>","s":{"r":"DateTime:D","p":[{"n":":$earlier","t":"Any"},{"n":"*%unit","t":"Associative"}]},"n":"later","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method truncated-to(DateTime:D: Cool $unit)</code></pre></p><p>Returns a copy of the invocant, with everything smaller than the specified unit truncated to the smallest possible value.</p><p><pre><code>my $d = DateTime.new(\"2012-02-29T12:34:56.946314Z\");\nsay $d.truncated-to('second');      # OUTPUT: «2012-02-29T12:34:56Z␤»\nsay $d.truncated-to('minute');      # OUTPUT: «2012-02-29T12:34:00Z␤»\nsay $d.truncated-to('hour');        # OUTPUT: «2012-02-29T12:00:00Z␤»\nsay $d.truncated-to('day');         # OUTPUT: «2012-02-29T00:00:00Z␤»\nsay $d.truncated-to('month');       # OUTPUT: «2012-02-01T00:00:00Z␤»\nsay $d.truncated-to('year');        # OUTPUT: «2012-01-01T00:00:00Z␤»</code></pre></p><p>DateTimes with fractional seconds can be truncated to whole seconds with .truncated-to('second').</p>","m":0,"s":{"r":"DateTime:D","p":[{"t":"Cool","n":"$unit"},{"t":"Mu","n":"*%_"}]},"n":"truncated-to","k":"m"},{"k":"m","m":0,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method whole-second(DateTime:D:)</code></pre></p><p>Returns the second component, rounded down to an Int.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56.789Z').whole-second;      # OUTPUT: «56␤»</code></pre></p>","n":"whole-second"},{"d":"<p>Defined as:</p><p><pre><code>method in-timezone(DateTime:D: Int(Cool) $timezone = 0 --&gt; DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in the specified $timezone, which is the offset in seconds from GMT.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').in-timezone(3600 + 1800); # OUTPUT: «2015-12-24T13:53:00+0130␤»</code></pre></p><p>Per RFC 7164, leap seconds do not respect local time and always occur at the end of the UTC day:</p><p><pre><code>say DateTime.new: '2017-01-01T00:59:60+01:00'\n# OUTPUT: «2017-01-01T00:59:60+01:00␤»</code></pre></p>","n":"in-timezone","s":{"p":[{"t":"Cool","n":"$timezone"},{"t":"Mu","n":"*%_"}],"r":"DateTime:D"},"m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"DateTime:D"},"k":"m","n":"utc","d":"<p>Defined as:</p><p><pre><code>method utc(DateTime:D: --&gt; DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in time zone UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').utc;\n# OUTPUT: «2015-12-24T10:23:00Z␤»</code></pre></p>"},{"n":"local","d":"<p>Defined as:</p><p><pre><code>method local(DateTime:D: --&gt; DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in the local time zone ($*TZ).</p><p><pre><code>my $*TZ = -3600;\nsay DateTime.new('2015-12-24T12:23:00+0200').local; # OUTPUT: «2015-12-24T09:23:00-0100␤»</code></pre></p>","m":0,"s":{"r":"DateTime:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"Date","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Date:D"},"d":"<p>Defined as:</p><p><pre><code>multi method Date(DateTime:U --&gt; Date:U)\nmulti method Date(DateTime:D --&gt; Date:D)</code></pre></p><p>Converts the invocant to Date.</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\nsay DateTime.Date;                                    # OUTPUT: «(Date)␤»\n</code></pre></p>","m":1},{"m":1,"s":{"r":"Date:U","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi method Date(DateTime:U --&gt; Date:U)\nmulti method Date(DateTime:D --&gt; Date:D)</code></pre></p><p>Converts the invocant to Date.</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\nsay DateTime.Date;                                    # OUTPUT: «(Date)␤»\n</code></pre></p>","k":"m","n":"Date"},{"d":"<p>Defined as:</p><p><pre><code>method DateTime(--&gt; DateTime)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56.946314Z\").DateTime;\n# OUTPUT: «2012-02-29T12:34:56.946314Z␤»\nsay DateTime.DateTime;\n# OUTPUT: «(DateTime)␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"DateTime","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method hour(DateTime:D: --&gt; Int:D)</code></pre></p><p>Returns the hour component.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').hour;      # OUTPUT: «12␤»</code></pre></p>","n":"hour"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method minute(DateTime:D: --&gt; Int:D)</code></pre></p><p>Returns the minute component.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').minute;     # OUTPUT: «34␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"minute"},{"d":"<p>Defined as:</p><p><pre><code>method second(DateTime:D:)</code></pre></p><p>Returns the second component, including potentially fractional seconds.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').second;     # OUTPUT: «56␤»\nsay DateTime.new('2012-02-29T12:34:56.789Z').second; # OUTPUT: «56.789␤»\nsay DateTime.new('2012-02-29T12:34:56,789Z').second; # comma also ok</code></pre></p>","n":"second","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"timezone","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method timezone(DateTime:D: --&gt; Int:D)</code></pre></p><p>Returns the time zone in seconds as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').timezone;          # OUTPUT: «7200␤»</code></pre></p>","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"year","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"month","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"day"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"formatter"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"},{"m":0,"n":"!DAYS-IN-MONTH","k":"m","s":{"p":[{"t":"Any","n":"year"},{"t":"Any","n":"month"},{"t":"Mu","n":"*%_"}],"r":"Int:D"}},{"k":"m","n":"!VALID-UNIT","s":{"r":"Mu","p":[{"n":"$unit","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"!SET-DAYCOUNT"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!calculate-daycount","m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"$invalid-str"},{"n":"$target","t":"Any"},{"t":"Any","n":"$format"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!tif"},{"s":{"r":"DateTime:D","p":[{"n":"$year","t":"Any"},{"t":"Any","n":"$month"},{"n":"$day","t":"Any"},{"t":"Any","n":"$hour"},{"n":"$minute","t":"Any"},{"n":"$second","t":"Any"},{"n":"$timezone","t":"Any"},{"n":"&formatter","t":"Callable"},{"n":"%extra","t":"Associative"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"!new-from-positional","k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"$what","t":"Any"},{"n":"$got","t":"Any"},{"n":"$range","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!oor"},{"n":"!check-leap-second","k":"m","s":{"r":"DateTime:D","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"n":"!formatter","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","n":"!year-Str","m":0,"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]}},{"n":"!SET-SELF","k":"m","s":{"p":[{"t":"int","n":"year"},{"t":"int","n":"month"},{"n":"day","t":"int"},{"n":"hour","t":"int"},{"t":"int","n":"minute"},{"n":"second","t":"Any"},{"n":"timezone","t":"int"},{"t":"Callable","n":"&formatter"},{"t":"Mu","n":"*%_"}],"r":"DateTime:D"},"m":0},{"m":0,"n":"!ymd-from-daycount","k":"m","s":{"p":[{"n":"$daycount","t":"int"},{"n":"year","t":"Any"},{"n":"month","t":"Any"},{"t":"Any","n":"day"},{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"s":{"p":[{"n":"$unit","t":"Cool"},{"n":"%parts?","t":"Associative"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"!truncate-ymd"},{"s":{"r":"DateTime:D","p":[{"t":"Associative","n":"*%_"}]},"n":"!clone-without-validating","m":0,"k":"m"}],"mro":["Dateish","Any"],"d":"<p><pre><code>class DateTime does Dateish {}</code></pre></p><p>For handling points in civil time, a DateTime object stores year, month, day, hour, minute (all Int), second (potentially fractional) and a time zone.</p><p>It provides methods for calculating with date and time.</p><p>DateTime methods are immutable; if you are tempted to modify one, create a modified copy instead.</p><p>Time zones are handled as Integers in seconds offset from UTC, not by time zone name.</p><p><pre><code>my $dt = DateTime.new(\n    year    =&gt; 2015,\n    month   =&gt; 11,\n    day     =&gt; 21,\n    hour    =&gt; 16,\n    minute  =&gt; 1,\n);\n\nsay $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»\nsay $dt.later(days =&gt; 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»\nsay $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»\nsay $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»\n\nmy $now = DateTime.now(formatter =&gt; { sprintf \"%02d:%02d\", .hour, .minute });\nsay $now;                           # 12:45 (or something like that)\n</code></pre></p>","t":"DateTime","a":[{"t":"int","k":"v","n":"$.hour"},{"k":"v","t":"int","n":"$.minute"},{"t":"Mu","k":"v","n":"$.second"},{"t":"int","n":"$.timezone","k":"v"},{"t":"int","k":"v","n":"$.year"},{"n":"$.month","k":"v","t":"int"},{"t":"int","n":"$.day","k":"v"},{"t":"int","k":"v","n":"$.daycount"},{"t":"Callable","n":"&.formatter","k":"v"}],"k":"c"},{"t":"Sub+{is-pure}","k":"v","n":"&infix:<⊇>"},{"m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"n":"infix:<⊇>","k":"s"},{"t":"SeekType","n":"SeekFromEnd","k":"e"},{"n":"&infix:<∖>","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<∖>"},{"s":{"p":[{"t":"QuantHash","n":"a"}],"r":"Mu"},"n":"infix:<∖>","m":1,"k":"s"},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"SetHash"}]},"m":1,"n":"infix:<∖>"},{"k":"s","s":{"p":[{"n":"a","t":"BagHash"}],"r":"Mu"},"m":1,"n":"infix:<∖>"},{"m":1,"k":"s","n":"infix:<∖>","s":{"p":[{"t":"MixHash","n":"a"}],"r":"Mu"}},{"s":{"p":[{"t":"Setty","n":"a"},{"t":"Setty","n":"b"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<∖>"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Setty"},{"t":"Map","n":"b"}],"r":"Mu"},"n":"infix:<∖>"},{"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Iterable"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<∖>"},{"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<∖>"},{"m":1,"n":"infix:<∖>","k":"s","s":{"r":"Mu","p":[{"t":"Mixy","n":"a"},{"t":"QuantHash","n":"b"}]}},{"n":"infix:<∖>","s":{"r":"Mu","p":[{"n":"a","t":"QuantHash"},{"n":"b","t":"Mixy"}]},"k":"s","m":1},{"m":1,"n":"infix:<∖>","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"t":"Map","n":"b"}]},"k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Any","n":"b"}],"r":"Mu"},"n":"infix:<∖>"},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Mixy","n":"b"}],"r":"Mu"},"n":"infix:<∖>","m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}]},"n":"infix:<∖>"},{"m":1,"n":"infix:<∖>","s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}]},"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"QuantHash"}]},"n":"infix:<∖>"},{"n":"infix:<∖>","m":1,"s":{"p":[{"t":"QuantHash","n":"a"},{"n":"b","t":"Baggy"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Map"}],"r":"Mu"},"n":"infix:<∖>","m":1,"k":"s"},{"n":"infix:<∖>","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Any"}]},"k":"s"},{"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Baggy"}]},"k":"s","m":1,"n":"infix:<∖>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Map","n":"b"}]},"n":"infix:<∖>","k":"s","m":1},{"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Iterable"}],"r":"Mu"},"n":"infix:<∖>","m":1,"k":"s"},{"n":"infix:<∖>","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"t":"Failure","n":"b"}]}},{"n":"infix:<∖>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"t":"Any","n":"$"}]}},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"n":"infix:<∖>","k":"s","m":1},{"n":"infix:<∖>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Positional","n":"+@p"}]}},{"n":"&prefix:<^>","d":"<p><pre><code>multi sub prefix:&lt;^&gt;(Any --&gt; Range:D)</code></pre></p><p>upto operator.</p><p>Coerces the argument to Numeric, and generates a range from 0 up to (but excluding) the argument.</p><p><pre><code>say ^5;         # OUTPUT: «0..^5␤»\nfor ^5 { }      # 5 iterations</code></pre></p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"prefix:<^>","m":1,"s":{"p":[{"t":"Any","n":"$max"}],"r":"Mu"},"k":"s"},{"k":"v","n":"&repeated","t":"Sub"},{"m":1,"k":"s","n":"repeated","s":{"p":[{"n":"+values","t":"Any"},{"n":"c","t":"Any"}],"r":"Mu"}},{"t":"Num","b":"C","m":[{"d":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","n":"Capture","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Num","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"Bridge","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"Range","k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"Int"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"sign"},{"s":{"r":"Mu","p":[{"n":"epsilon?","t":"Real"},{"n":"RAT?","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"Rat","k":"m"},{"n":"FatRat","s":{"p":[{"n":"$epsilon?","t":"Real"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"succ","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"pred"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"isNaN"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"abs"},{"n":"log","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":1,"k":"m"},{"n":"log","k":"m","s":{"r":"Mu","p":[{"t":"Num","n":"base"},{"n":"*%_","t":"Mu"}]},"m":1},{"m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"log","k":"m"},{"n":"log","k":"m","s":{"r":"Mu","p":[{"n":"$base","t":"Real"},{"n":"*%_","t":"Mu"}]},"m":1},{"m":1,"n":"log","s":{"p":[{"n":"$base","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"$base","t":"Numeric"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"log","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"sqrt"},{"d":"<p><pre><code>method rand(Num:D: --&gt; Num)</code></pre></p><p>Returns a pseudo random number between 0 and the invocant.</p>","n":"rand","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"ceiling","m":0},{"n":"floor","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"sin","k":"m"},{"m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"asin"},{"m":1,"k":"m","n":"cos","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1,"n":"acos"},{"m":1,"n":"tan","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","m":1,"n":"atan","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"sec","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"asec"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"cosec","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"acosec"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"cotan"},{"n":"acotan","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":1,"n":"sinh"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"asinh","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"cosh","k":"m"},{"n":"acosh","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"tanh","k":"m"},{"m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"atanh","k":"m"},{"m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"atanh"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"sech","k":"m"},{"k":"m","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"asech"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"cosech","k":"m"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"acosech","k":"m"},{"m":1,"n":"cotanh","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"acotanh","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":1},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"is-prime"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"narrow","k":"m"}],"d":"<p><pre><code>class Num is Cool does Real { }</code></pre></p><p>A Num object stores a floating-point number. It is immutable. On most platforms, it's an IEEE 754 64-bit floating point numbers, aka \"double precision\".</p><p> </p>","mro":["Real","Numeric","Cool"],"n":"Num","k":"c"},{"t":"Str","n":"Str","b":"C","m":[{"n":"BUILD","m":0,"k":"s","s":{"p":[{"n":":$value?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"Capture","d":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","m":0},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method Int(Str:D: --&gt; Int:D)</code></pre></p><p>Coerces the string to Int, using the same rules as Str.Numeric.</p>","m":0,"n":"Int","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"}},{"k":"m","n":"Num","s":{"r":"Num:D","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"r":"Version:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Version","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"d":"<p>Defined as:</p><p><pre><code>multi sub    chomp(Str:D  --&gt; Str:D)\nmulti method chomp(Str:D: --&gt; Str:D)</code></pre></p><p>Returns the string with a logical newline (any codepoint that has the NEWLINE property) removed from the end.</p><p>Examples:</p><p><pre><code>say chomp(\"abc\\n\");       # OUTPUT: «abc␤»\nsay \"def\\r\\n\".chomp;      # OUTPUT: «def␤» NOTE: \\r\\n is a single grapheme!\nsay \"foo\\r\".chomp;        # OUTPUT: «foo␤»</code></pre></p>","k":"m","m":0,"n":"chomp"},{"m":0,"n":"pred","k":"m","d":"<p><pre><code>method pred(Str:D: --&gt; Str:D)</code></pre></p><p>Returns the string decremented by one.</p><p>String decrementing is \"magical\" just like string increment (see succ). It fails on underflow</p><p><pre><code>'b0'.pred;           # RESULT: «a9»\n'a0'.pred;           # Failure\n'img002.png'.pred;   # RESULT: «img001.png»\n</code></pre></p>","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]}},{"n":"succ","d":"<p><pre><code>method succ(Str:D --&gt; Str:D)</code></pre></p><p>Returns the string incremented by one.</p><p>String increment is \"magical\". It searches for the last alphanumeric sequence that is not preceded by a dot, and increments it.</p><p><pre><code>'12.34'.succ;      # RESULT: «13.34»\n'img001.png'.succ; # RESULT: «img002.png»</code></pre></p><p>The actual increment step works by mapping the last alphanumeric character to a character range it belongs to, and choosing the next character in that range, carrying to the previous letter on overflow.</p><p><pre><code>'aa'.succ;   # RESULT: «ab»\n'az'.succ;   # RESULT: «ba»\n'109'.succ;  # RESULT: «110»\n'α'.succ;    # RESULT: «β»\n'a9'.succ;   # RESULT: «b0»</code></pre></p><p>String increment is Unicode-aware, and generally works for scripts where a character can be uniquely classified as belonging to one range of characters.</p>","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":1,"n":"match","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","s":{"p":[{"n":"$pattern","t":"Cool"},{"n":"c","t":"Any"}],"r":"Mu"},"k":"m"},{"k":"m","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","m":1,"s":{"p":[{"n":"$pattern","t":"Regex"},{"n":":$c!","t":"Any"},{"n":"*%_","t":"Associative"}],"r":"Mu"},"n":"match"},{"m":1,"k":"m","n":"match","s":{"r":"Mu","p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$p!"},{"n":"*%_","t":"Associative"}]},"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>"},{"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","n":"match","k":"m","m":1,"s":{"p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$g!"},{"t":"Associative","n":"*%_"}],"r":"Mu"}},{"k":"m","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","m":1,"s":{"p":[{"n":"$pattern","t":"Regex"},{"t":"Any","n":":$ov!"},{"n":"*%_","t":"Associative"}],"r":"Mu"},"n":"match"},{"n":"match","m":1,"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"$pattern","t":"Regex"},{"t":"Any","n":":$ex!"},{"n":"*%_","t":"Associative"}]},"k":"m"},{"m":1,"n":"match","k":"m","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","s":{"p":[{"n":"$pattern","t":"Regex"},{"t":"Any","n":":$x!"},{"t":"Associative","n":"*%_"}],"r":"Mu"}},{"m":1,"n":"match","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","s":{"p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$st!"},{"n":"*%_","t":"Associative"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$nd!"},{"t":"Associative","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","m":1,"n":"match","k":"m"},{"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","m":1,"n":"match","k":"m","s":{"p":[{"n":"$pattern","t":"Regex"},{"n":":$rd!","t":"Any"},{"t":"Associative","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$th!"},{"t":"Associative","n":"*%_"}]},"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","n":"match","k":"m","m":1},{"d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","s":{"p":[{"t":"Regex","n":"$pattern"},{"t":"Any","n":":$nth!"},{"t":"Associative","n":"*%_"}],"r":"Mu"},"n":"match","m":1,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"$pattern","t":"Regex"},{"t":"Any","n":":$as!"},{"n":"*%_","t":"Associative"}]},"m":1,"n":"match","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>"},{"s":{"r":"Mu","p":[{"n":"$pattern","t":"Regex"},{"n":"*%_","t":"Associative"}]},"k":"m","n":"match","d":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --&gt; Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>","m":1},{"n":"subst-mutate","k":"m","m":1,"d":"<p>NOTE: .subst-mutate is deprecated in the 6.d version, and will be removed in future ones. You can use subst with .= method call assignment operator or s/// substitution operator instead. </p><p>Where subst returns the modified string and leaves the original unchanged, it is possible to mutate the original string by using subst-mutate. If the match is successful, the method returns a Match object representing the successful match, otherwise returns Nil. If :nth (or one of its aliases) with Iterable value, :g, :global, or :x arguments are used, returns a List of Match objects, or an empty List if no matches occurred.</p><p><pre><code>my $some-string = \"Some foo\";\nmy $match = $some-string.subst-mutate(/foo/, \"string\");\nsay $some-string;  # OUTPUT: «Some string␤»\nsay $match;        # OUTPUT: «｢foo｣␤»\n$some-string.subst-mutate(/&lt;[oe]&gt;/, '', :g); # remove every o and e, notice the :g named argument from .subst</code></pre></p><p>If a Regex $matcher is used, the $/ special variable will be set to Nil (if no matches occurred), a Match object, or a List of Match objects (if multi-match options like :g are used).</p>","s":{"p":[{"n":"$matcher","t":"Any"},{"t":"Any","n":"$replacement"},{"n":":$samecase","t":"Any"},{"n":":$samespace","t":"Any"},{"n":":$samemark","t":"Any"},{"n":"*%options","t":"Associative"}],"r":"Mu"}},{"m":1,"k":"m","s":{"p":[{"n":"$radix","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Numeric:D"},"d":"<p><pre><code>multi sub    parse-base(Str:D $num, Int:D $radix --&gt; Numeric)\nmulti method parse-base(Str:D $num: Int:D $radix --&gt; Numeric)</code></pre></p><p>Performs the reverse of base by converting a string with a base-$radix number to its Numeric equivalent. Will fail if radix is not in range 2..36 or if the string being parsed contains characters that are not valid for the specified base.</p><p><pre><code>1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n'Raku'.parse-base(36).say;        # OUTPUT: «1273422␤»\n'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»</code></pre></p><p>See also: :16&lt;FF&gt; syntax for number literals</p>","n":"parse-base"},{"n":"parse-base","s":{"r":"Int:D","p":[{"n":"$","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1,"d":"<p><pre><code>multi sub    parse-base(Str:D $num, Int:D $radix --&gt; Numeric)\nmulti method parse-base(Str:D $num: Int:D $radix --&gt; Numeric)</code></pre></p><p>Performs the reverse of base by converting a string with a base-$radix number to its Numeric equivalent. Will fail if radix is not in range 2..36 or if the string being parsed contains characters that are not valid for the specified base.</p><p><pre><code>1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n'Raku'.parse-base(36).say;        # OUTPUT: «1273422␤»\n'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»</code></pre></p><p>See also: :16&lt;FF&gt; syntax for number literals</p>"},{"s":{"p":[{"n":"$","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"parse-base","d":"<p><pre><code>multi sub    parse-base(Str:D $num, Int:D $radix --&gt; Numeric)\nmulti method parse-base(Str:D $num: Int:D $radix --&gt; Numeric)</code></pre></p><p>Performs the reverse of base by converting a string with a base-$radix number to its Numeric equivalent. Will fail if radix is not in range 2..36 or if the string being parsed contains characters that are not valid for the specified base.</p><p><pre><code>1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n'Raku'.parse-base(36).say;        # OUTPUT: «1273422␤»\n'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»</code></pre></p><p>See also: :16&lt;FF&gt; syntax for number literals</p>","m":1,"k":"m"},{"n":"samecase","m":0,"k":"m","s":{"p":[{"n":"$pattern","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"d":"<p><pre><code>multi sub samemark(Str:D $string, Str:D $pattern --&gt; Str:D)\nmethod    samemark(Str:D: Str:D $pattern --&gt; Str:D)</code></pre></p><p>Returns a copy of $string with the mark/accent information for each character changed such that it matches the mark/accent of the corresponding character in $pattern. If $string is longer than $pattern, the remaining characters in $string receive the same mark/accent as the last character in $pattern. If $pattern is empty no changes will be made.</p><p>Examples:</p><p><pre><code>say 'åäö'.samemark('aäo');                        # OUTPUT: «aäo␤»\nsay 'åäö'.samemark('a');                          # OUTPUT: «aao␤»\n\nsay samemark('Pêrl', 'a');                        # OUTPUT: «Perl␤»\nsay samemark('aöä', '');                          # OUTPUT: «aöä␤»</code></pre></p>","m":0,"s":{"p":[{"t":"Str","n":"$pattern"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"samemark","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Str","n":"$pattern"},{"n":"*%_","t":"Mu"}]},"n":"samespace"},{"s":{"p":[{"n":"$pattern","t":"Str"},{"t":"Callable","n":"&filter?"},{"t":"Bool","n":":$samespace"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"word-by-word","k":"m","m":0},{"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"n":"trim-leading","d":"<p><pre><code>method trim-leading(Str:D: --&gt; Str)</code></pre></p><p>Removes the whitespace characters from the beginning of a string. See also trim.</p>","k":"m","m":0},{"k":"m","m":0,"n":"trim-trailing","d":"<p><pre><code>method trim-trailing(Str:D: --&gt; Str)</code></pre></p><p>Removes the whitespace characters from the end of a string. See also trim.</p>","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p><pre><code>method trim(Str:D: --&gt; Str)</code></pre></p><p>Remove leading and trailing whitespace. It can be used both as a method on strings and as a function. When used as a method it will return the trimmed string. In order to do in-place trimming, one needs to write .=trim</p><p><pre><code>my $line = '   hello world    ';\nsay '&lt;' ~ $line.trim ~ '&gt;';        # OUTPUT: «&lt;hello world&gt;␤»\nsay '&lt;' ~ trim($line) ~ '&gt;';       # OUTPUT: «&lt;hello world&gt;␤»\n$line.trim;\nsay '&lt;' ~ $line ~ '&gt;';             # OUTPUT: «&lt;   hello world    &gt;␤»\n$line.=trim;\nsay '&lt;' ~ $line ~ '&gt;';             # OUTPUT: «&lt;hello world&gt;␤»</code></pre></p><p>See also trim-trailing and trim-leading.</p>","n":"trim","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m"},{"d":"<p><pre><code>multi method encode(Str:D $encoding = 'utf8', :$replacement, Bool() :$translate-nl = False, :$strict)</code></pre></p><p>Returns a Blob which represents the original string in the given encoding and normal form. The actual return type is as specific as possible, so $str.encode('UTF-8') returns a utf8 object, $str.encode('ISO-8859-1') a buf8. If :translate-nl is set to True, it will translate newlines from \\n to \\r\\n, but only in Windows. $replacement indicates how characters are going to be replaced in the case they are not available in the current encoding, while $strict indicates whether unmapped codepoints will still decode; for instance, codepoint 129 which does not exist in windows-1252.</p><p><pre><code>my $str = \"Þor is mighty\";\nsay $str.encode(\"ascii\", :replacement( 'Th') ).decode(\"ascii\");\n# OUTPUT: «Thor is mighty␤»</code></pre></p><p>In this case, any unknown character is going to be substituted by Th. We know in advance that the character that is not known in the ascii encoding is Þ, so we substitute it by its latin equivalent, Th. In the absence of any replacement set of characters, :replacement is understood as a Bool:</p><p><pre><code>say $str.encode(\"ascii\", :replacement).decode(\"ascii\"); # OUTPUT: «?or is mighty␤»\n</code></pre></p><p>If :replacement is not set or assigned a value, the error Error encoding ASCII string: could not encode codepoint 222 will be issued (in this case, since þ is codepoint 222).</p><p>Since the Blob returned by encode is the original string in normal form, and every element of a Blob is a byte, you can obtain the length in bytes of a string by calling a method that returns the size of the Blob on it:</p><p><pre><code>say \"þor\".encode.bytes; # OUTPUT: «4␤»\nsay \"þor\".encode.elems; # OUTPUT: «4␤»\n</code></pre></p>","s":{"r":"Blob:D","p":[{"t":"Str","n":"$encoding?"},{"n":":$replacement","t":"Any"},{"t":"Any","n":":$translate-nl?"},{"t":"Any","n":":$strict"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"encode","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"NFC:D"},"m":0,"k":"m","d":"<p><pre><code>method NFC(Str:D: --&gt; NFC:D)</code></pre></p><p>Returns a codepoint string in NFC format (Unicode Normalization Form C / Composed).</p>","n":"NFC"},{"m":0,"k":"m","d":"<p><pre><code>method NFD(Str:D: --&gt; NFD:D)</code></pre></p><p>Returns a codepoint string in NFD format (Unicode Normalization Form D / Decomposed).</p>","n":"NFD","s":{"r":"NFD:D","p":[{"n":"*%_","t":"Mu"}]}},{"n":"NFKC","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"NFKC:D"},"m":0,"d":"<p><pre><code>method NFKC(Str:D: --&gt; NFKC:D)</code></pre></p><p>Returns a codepoint string in NFKC format (Unicode Normalization Form KC / Compatibility Composed).</p>"},{"d":"<p><pre><code>method NFKD(Str:D: --&gt; NFKD:D)</code></pre></p><p>Returns a codepoint string in NFKD format (Unicode Normalization Form KD / Compatibility Decomposed).</p>","n":"NFKD","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"NFKD:D"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"unival","d":"<p><pre><code>multi method unival(Str:D --&gt; Numeric)</code></pre></p><p>Returns the numeric value that the first codepoint in the invocant represents, or NaN if it's not numeric.</p><p><pre><code>say '4'.unival;     # OUTPUT: «4␤»\nsay '¾'.unival;     # OUTPUT: «0.75␤»\nsay 'a'.unival;     # OUTPUT: «NaN␤»</code></pre></p>","k":"m"},{"d":"<p><pre><code>multi method univals(Str:D --&gt; List)</code></pre></p><p>Returns a list of numeric values represented by each codepoint in the invocant string, and NaN for non-numeric characters.</p><p><pre><code>say \"4a¾\".univals;  # OUTPUT: «(4 NaN 0.75)␤»</code></pre></p>","k":"m","n":"univals","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"t":"Callable","n":":&filter?"},{"n":":$where?","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"d":"<p><pre><code>multi sub    wordcase(Cool $x  --&gt; Str)\nmulti sub    wordcase(Str:D $x --&gt; Str)\nmulti method wordcase(Str:D: :&amp;filter = &amp;tclc, Mu :$where = True --&gt; Str)\n</code></pre></p><p>Returns a string in which &amp;filter has been applied to all the words that match $where. By default, this means that the first letter of every word is capitalized, and all the other letters lowercased.</p>","k":"m","n":"wordcase","m":0},{"s":{"r":"Str:D","p":[{"n":"what","t":"Pair"},{"n":"*%n","t":"Associative"}]},"n":"trans","k":"m","d":"<p><pre><code>multi method trans(Str:D: Pair:D \\what, *%n --&gt; Str)\nmulti method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --&gt; Str)</code></pre></p><p>Replaces one or many characters with one or many characters. Ranges are supported, both for keys and values. Regexes work as keys. In case a list of keys and values is used, substrings can be replaced as well. When called with :complement anything but the matched value or range is replaced with a single value; with :delete the matched characters without corresponding replacement are removed. Combining :complement and :delete will remove anything but the matched values, unless replacement characters have been specified, in which case, :delete would be ignored. The adverb :squash will reduce repeated matched characters to a single character.</p><p>Example:</p><p><pre><code>my $str = 'say $x&lt;b&gt; &amp;&amp; $y&lt;a&gt;';\n$str.=trans( '&lt;' =&gt; '«' );\n$str.=trans( '&lt;' =&gt; '«', '&gt;' =&gt; '»' );\n\n$str.=trans( [ '&lt;'   , '&gt;'   , '&amp;' ] =&gt;\n             [ '&amp;lt;', '&amp;gt;', '&amp;amp;' ]);\n\n$str.=trans( ['a'..'y'] =&gt; ['A'..'z'] );\n\n\"abcdefghij\".trans(/&lt;[aeiou]&gt; \\w/ =&gt; '');                     # RESULT: «cdgh»\n\n\"a123b123c\".trans(['a'..'z'] =&gt; 'x', :complement);            # RESULT: «axxxbxxxc»\n\"aaa1123bb123c\".trans('a'..'z' =&gt; 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n\"aaa1123bb123c\".trans('a'..'z' =&gt; 'x', :complement, :squash); # RESULT: «aaaxbbxc»</code></pre></p><p>In general, the strings will have the same length after the substitution:</p><p><pre><code>say \"a123b123c\".trans('23' =&gt; '4');   # OUTPUT: «a144b144c␤»\nsay \"a123b123c\".trans('123' =&gt; 'þð'); # OUTPUT: «aþðþbþðþc␤»</code></pre></p><p>:squash and :delete will have the same effect in this case making it a strict substitution:</p><p><pre><code>say \"a123b123c\".trans('123' =&gt; 'þð', :squash); # OUTPUT: «aþðbþðc␤»\nsay \"a123b123c\".trans('123' =&gt; 'þð', :delete); # OUTPUT: «aþðbþðc␤»</code></pre></p><p>:delete will also remove non-matched characters from the original string:</p><p><pre><code>say \"abc\".trans(\"abc\".comb =&gt; 1..2, :delete);  # OUTPUT: «12␤»</code></pre></p><p>Please note that the behavior of the two versions of the multi method is slightly different. The first form will transpose only one character if the origin is also one character:</p><p><pre><code>say \"abcd\".trans( \"a\" =&gt; \"zz\" );  # OUTPUT: «zbcd␤»\nsay \"abcd\".trans( \"ba\" =&gt; \"yz\" ); # OUTPUT: «zycd␤»\n</code></pre></p><p>In the second case, behavior is as expected, since the origin is more than one char long. However, if the Pair in the multi method does not have a Str as an origin or target, it is handled to the second multi method, and behavior changes:</p><p><pre><code>say \"abcd\".trans: [\"a\"] =&gt; [\"zz\"]; # OUTPUT: «zzbcd␤»</code></pre></p><p>In this case, neither origin nor target in the Pair are Str; the method with the Pair signature then calls the second, making this call above equivalent to \"abcd\".trans: [\"a\"] =&gt; [\"zz\"],  (with the comma behind, making it a Positional, instead of a Pair), resulting in the behavior shown as output.</p>","m":1},{"d":"<p><pre><code>multi method trans(Str:D: Pair:D \\what, *%n --&gt; Str)\nmulti method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --&gt; Str)</code></pre></p><p>Replaces one or many characters with one or many characters. Ranges are supported, both for keys and values. Regexes work as keys. In case a list of keys and values is used, substrings can be replaced as well. When called with :complement anything but the matched value or range is replaced with a single value; with :delete the matched characters without corresponding replacement are removed. Combining :complement and :delete will remove anything but the matched values, unless replacement characters have been specified, in which case, :delete would be ignored. The adverb :squash will reduce repeated matched characters to a single character.</p><p>Example:</p><p><pre><code>my $str = 'say $x&lt;b&gt; &amp;&amp; $y&lt;a&gt;';\n$str.=trans( '&lt;' =&gt; '«' );\n$str.=trans( '&lt;' =&gt; '«', '&gt;' =&gt; '»' );\n\n$str.=trans( [ '&lt;'   , '&gt;'   , '&amp;' ] =&gt;\n             [ '&amp;lt;', '&amp;gt;', '&amp;amp;' ]);\n\n$str.=trans( ['a'..'y'] =&gt; ['A'..'z'] );\n\n\"abcdefghij\".trans(/&lt;[aeiou]&gt; \\w/ =&gt; '');                     # RESULT: «cdgh»\n\n\"a123b123c\".trans(['a'..'z'] =&gt; 'x', :complement);            # RESULT: «axxxbxxxc»\n\"aaa1123bb123c\".trans('a'..'z' =&gt; 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n\"aaa1123bb123c\".trans('a'..'z' =&gt; 'x', :complement, :squash); # RESULT: «aaaxbbxc»</code></pre></p><p>In general, the strings will have the same length after the substitution:</p><p><pre><code>say \"a123b123c\".trans('23' =&gt; '4');   # OUTPUT: «a144b144c␤»\nsay \"a123b123c\".trans('123' =&gt; 'þð'); # OUTPUT: «aþðþbþðþc␤»</code></pre></p><p>:squash and :delete will have the same effect in this case making it a strict substitution:</p><p><pre><code>say \"a123b123c\".trans('123' =&gt; 'þð', :squash); # OUTPUT: «aþðbþðc␤»\nsay \"a123b123c\".trans('123' =&gt; 'þð', :delete); # OUTPUT: «aþðbþðc␤»</code></pre></p><p>:delete will also remove non-matched characters from the original string:</p><p><pre><code>say \"abc\".trans(\"abc\".comb =&gt; 1..2, :delete);  # OUTPUT: «12␤»</code></pre></p><p>Please note that the behavior of the two versions of the multi method is slightly different. The first form will transpose only one character if the origin is also one character:</p><p><pre><code>say \"abcd\".trans( \"a\" =&gt; \"zz\" );  # OUTPUT: «zbcd␤»\nsay \"abcd\".trans( \"ba\" =&gt; \"yz\" ); # OUTPUT: «zycd␤»\n</code></pre></p><p>In the second case, behavior is as expected, since the origin is more than one char long. However, if the Pair in the multi method does not have a Str as an origin or target, it is handled to the second multi method, and behavior changes:</p><p><pre><code>say \"abcd\".trans: [\"a\"] =&gt; [\"zz\"]; # OUTPUT: «zzbcd␤»</code></pre></p><p>In this case, neither origin nor target in the Pair are Str; the method with the Pair signature then calls the second, making this call above equivalent to \"abcd\".trans: [\"a\"] =&gt; [\"zz\"],  (with the comma behind, making it a Positional, instead of a Pair), resulting in the behavior shown as output.</p>","n":"trans","m":1,"s":{"p":[{"t":"Positional","n":"*@changes"},{"t":"Any","n":":$complement"},{"n":":$squash","t":"Any"},{"n":":$delete","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"m":0,"n":"parse-names","k":"m","d":"<p><pre><code>sub    parse-names(Str:D $names  --&gt; Str:D)\nmethod parse-names(Str:D $names: --&gt; Str:D)</code></pre></p><p>DEPRECATED. Use uniparse instead. Existed in Rakudo implementation as a proof of viability implementation before being renamed and will be removed when 6.e language is released.</p>"},{"d":"<p><pre><code>sub    uniparse(Str:D $names  --&gt; Str:D)\nmethod uniparse(Str:D $names: --&gt; Str:D)</code></pre></p><p>Takes string with comma-separated Unicode names of characters and returns a string composed of those characters. Will fail if any of the characters' names are empty or not recognized. Whitespace around character names is ignored.</p><p><pre><code>say \"I {uniparse 'TWO HEARTS'} Raku\"; # OUTPUT: «I \uD83D\uDC95 Raku␤»\n'TWO HEARTS, BUTTERFLY'.uniparse.say; # OUTPUT: «\uD83D\uDC95\uD83E\uDD8B␤»</code></pre></p><p>Note that unlike \\c[...] construct available in string interpolation, uniparse does not accept decimal numerical values. Use chr routine to convert those:</p><p><pre><code>say \"\\c[1337]\"; # OUTPUT: «Թ␤»\nsay '1337'.chr; # OUTPUT: «Թ␤»</code></pre></p><p>Note: before being standardized in 2017.12, this routine was known under its working name of parse-names. This denomination will be removed in the 6.e version.</p>","m":0,"n":"uniparse","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"k":"m","m":1,"s":{"p":[{"t":"Any","n":"$steps"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>multi method indent(Int $steps where { $_ == 0 } )\nmulti method indent(Int $steps where { $_ &gt; 0  } )\nmulti method indent($steps where { .isa(Whatever) || .isa(Int) &amp;&amp; $_ &lt; 0 } )</code></pre></p><p>Indents each line of the string by $steps. If $steps is negative, it outdents instead. If $steps is *, then the string is outdented to the margin:</p><p><pre><code>\"  indented by 2 spaces\\n    indented even more\".indent(*)\n    eq \"indented by 2 spaces\\n  indented even more\"</code></pre></p>","n":"indent"},{"d":"<p><pre><code>multi method indent(Int $steps where { $_ == 0 } )\nmulti method indent(Int $steps where { $_ &gt; 0  } )\nmulti method indent($steps where { .isa(Whatever) || .isa(Int) &amp;&amp; $_ &lt; 0 } )</code></pre></p><p>Indents each line of the string by $steps. If $steps is negative, it outdents instead. If $steps is *, then the string is outdented to the margin:</p><p><pre><code>\"  indented by 2 spaces\\n    indented even more\".indent(*)\n    eq \"indented by 2 spaces\\n  indented even more\"</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"n":"$steps","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"indent"},{"k":"m","d":"<p><pre><code>multi method indent(Int $steps where { $_ == 0 } )\nmulti method indent(Int $steps where { $_ &gt; 0  } )\nmulti method indent($steps where { .isa(Whatever) || .isa(Int) &amp;&amp; $_ &lt; 0 } )</code></pre></p><p>Indents each line of the string by $steps. If $steps is negative, it outdents instead. If $steps is *, then the string is outdented to the margin:</p><p><pre><code>\"  indented by 2 spaces\\n    indented even more\".indent(*)\n    eq \"indented by 2 spaces\\n  indented even more\"</code></pre></p>","m":1,"s":{"p":[{"n":"$steps","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"indent"},{"m":1,"k":"m","d":"<p><pre><code>multi method indent(Int $steps where { $_ == 0 } )\nmulti method indent(Int $steps where { $_ &gt; 0  } )\nmulti method indent($steps where { .isa(Whatever) || .isa(Int) &amp;&amp; $_ &lt; 0 } )</code></pre></p><p>Indents each line of the string by $steps. If $steps is negative, it outdents instead. If $steps is *, then the string is outdented to the margin:</p><p><pre><code>\"  indented by 2 spaces\\n    indented even more\".indent(*)\n    eq \"indented by 2 spaces\\n  indented even more\"</code></pre></p>","n":"indent","s":{"p":[{"t":"Whatever","n":"$steps"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":1,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"codes"},{"k":"m","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"codes"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"m":1,"n":"chars","d":"<p><pre><code>multi sub    chars(Cool  $x --&gt; Int:D)\nmulti sub    chars(Str:D $x --&gt; Int:D)\nmulti sub    chars(str   $x --&gt; int)\nmulti method chars(Str:D:   --&gt; Int:D)</code></pre></p><p>Returns the number of characters in the string in graphemes. On the JVM, this currently erroneously returns the number of codepoints instead.</p>","k":"m"},{"k":"m","n":"chars","m":1,"d":"<p><pre><code>multi sub    chars(Cool  $x --&gt; Int:D)\nmulti sub    chars(Str:D $x --&gt; Int:D)\nmulti sub    chars(str   $x --&gt; int)\nmulti method chars(Str:D:   --&gt; Int:D)</code></pre></p><p>Returns the number of characters in the string in graphemes. On the JVM, this currently erroneously returns the number of codepoints instead.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"d":"<p><pre><code>multi sub    uc(Str:D  --&gt; Str:D)\nmulti method uc(Str:D: --&gt; Str:D)</code></pre></p><p>Returns an uppercase version of the string.</p>","n":"uc","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":1},{"d":"<p><pre><code>multi sub    uc(Str:D  --&gt; Str:D)\nmulti method uc(Str:D: --&gt; Str:D)</code></pre></p><p>Returns an uppercase version of the string.</p>","n":"uc","m":1,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"m":1,"k":"m","n":"lc","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi sub    lc(Str:D  --&gt; Str:D)\nmulti method lc(Str:D: --&gt; Str:D)</code></pre></p><p>Returns a lower-case version of the string.</p><p>Examples:</p><p><pre><code>lc(\"A\"); # RESULT: «\"a\"»\n\"A\".lc;  # RESULT: «\"a\"»</code></pre></p>"},{"k":"m","n":"lc","d":"<p>Defined as:</p><p><pre><code>multi sub    lc(Str:D  --&gt; Str:D)\nmulti method lc(Str:D: --&gt; Str:D)</code></pre></p><p>Returns a lower-case version of the string.</p><p>Examples:</p><p><pre><code>lc(\"A\"); # RESULT: «\"a\"»\n\"A\".lc;  # RESULT: «\"a\"»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"m":1},{"d":"<p><pre><code>multi sub    tc(Str:D  --&gt; Str:D)\nmulti method tc(Str:D: --&gt; Str:D)</code></pre></p><p>Does a Unicode \"titlecase\" operation, that is changes the first character in the string to title case, or to upper case if the character has no title case mapping</p>","m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"tc"},{"n":"tc","k":"m","d":"<p><pre><code>multi sub    tc(Str:D  --&gt; Str:D)\nmulti method tc(Str:D: --&gt; Str:D)</code></pre></p><p>Does a Unicode \"titlecase\" operation, that is changes the first character in the string to title case, or to upper case if the character has no title case mapping</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"m":1},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"k":"m","m":1,"n":"fc","d":"<p><pre><code>multi sub    fc(Str:D  --&gt; Str:D)\nmulti method fc(Str:D: --&gt; Str:D)</code></pre></p><p>Does a Unicode \"fold case\" operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>"},{"m":1,"k":"m","d":"<p><pre><code>multi sub    fc(Str:D  --&gt; Str:D)\nmulti method fc(Str:D: --&gt; Str:D)</code></pre></p><p>Does a Unicode \"fold case\" operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"fc"},{"k":"m","d":"<p><pre><code>multi sub    tclc(Str:D  --&gt; Str:D)\nmulti method tclc(Str:D: --&gt; Str:D)</code></pre></p><p>Turns the first character to title case, and all other characters to lower case</p>","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"n":"tclc","m":1},{"n":"tclc","m":1,"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p><pre><code>multi sub    tclc(Str:D  --&gt; Str:D)\nmulti method tclc(Str:D: --&gt; Str:D)</code></pre></p><p>Turns the first character to title case, and all other characters to lower case</p>"},{"k":"m","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"flip","d":"<p><pre><code>multi sub    flip(Str:D  --&gt; Str:D)\nmulti method flip(Str:D: --&gt; Str:D)</code></pre></p><p>Returns the string reversed character by character.</p><p>Examples:</p><p><pre><code>\"Perl\".flip;  # RESULT: «lreP»\n\"ABBA\".flip;  # RESULT: «ABBA»</code></pre></p>"},{"d":"<p><pre><code>multi sub    flip(Str:D  --&gt; Str:D)\nmulti method flip(Str:D: --&gt; Str:D)</code></pre></p><p>Returns the string reversed character by character.</p><p>Examples:</p><p><pre><code>\"Perl\".flip;  # RESULT: «lreP»\n\"ABBA\".flip;  # RESULT: «ABBA»</code></pre></p>","k":"m","m":1,"n":"flip","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"d":"<p><pre><code>multi sub    ord(Str:D  --&gt; Int:D)\nmulti method ord(Str:D: --&gt; Int:D)</code></pre></p><p>Returns the codepoint number of the base characters of the first grapheme in the string.</p><p>Example:</p><p><pre><code>ord(\"A\"); # 65\n\"«\".ord;  # 171</code></pre></p>","s":{"r":"Int:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"ord","m":1},{"m":1,"d":"<p><pre><code>multi sub    ord(Str:D  --&gt; Int:D)\nmulti method ord(Str:D: --&gt; Int:D)</code></pre></p><p>Returns the codepoint number of the base characters of the first grapheme in the string.</p><p>Example:</p><p><pre><code>ord(\"A\"); # 65\n\"«\".ord;  # 171</code></pre></p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"ord"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"Date","k":"m"},{"n":"DateTime","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BUILDALL","k":"s"},{"m":0,"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"n":"$name","t":"str"},{"n":"$value","t":"Any"},{"t":"Any","n":"opts"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"!match-cursor"},{"s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"cursor"},{"n":"move","t":"Any"},{"n":"post","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!match-list","m":0,"k":"m"},{"k":"m","n":"!indicesicim","s":{"r":"Mu","p":[{"n":"$needle","t":"str"},{"t":"Any","n":"overlap"},{"n":"$start","t":"int"},{"n":"*%_","t":"Mu"}]},"m":0},{"k":"m","m":0,"n":"!match-last","s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"n":"move","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"cursor"},{"t":"Any","n":"move"},{"t":"int","n":"$tail"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!match-nth-tail","k":"m","m":0},{"s":{"p":[{"n":"slash","t":"Any"},{"t":"Any","n":"cursor"},{"n":"move","t":"Any"},{"n":"post","t":"Any"},{"n":"$nth","t":"Any"},{"n":"%opts","t":"Associative"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"!match-nth","m":0},{"s":{"r":"Nil","p":[{"t":"Any","n":"limit"},{"t":"Mu","n":"*%_"}]},"n":"!ensure-limit-sanity","m":0,"k":"m"},{"n":"!parse-fail","k":"m","m":0,"s":{"p":[{"t":"Any","n":"$radix"},{"t":"Any","n":"$pos"},{"n":"*%_","t":"Mu"}],"r":"Failure"}},{"m":0,"s":{"r":"Numeric:D","p":[{"n":"$radix","t":"int"},{"n":"$whole","t":"Int"},{"n":"$offset","t":"int"},{"n":"*%_","t":"Mu"}]},"n":"!parse-rat","k":"m"},{"n":"!ensure-split-sanity","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"v","t":"Any"},{"n":"k","t":"Any"},{"n":"kv","t":"Any"},{"n":"p","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"$egg","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"!eggify","k":"m"},{"m":0,"n":"!match-nth-int","s":{"p":[{"n":"slash","t":"Any"},{"t":"Any","n":"cursor"},{"t":"Any","n":"move"},{"t":"Any","n":"post"},{"t":"int","n":"$nth"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"!SUBSTR-START-OOR","s":{"p":[{"t":"Any","n":"$from"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"$needle","t":"str"},{"n":"overlap","t":"Any"},{"n":"$start","t":"int"},{"t":"Mu","n":"*%_"}]},"n":"!indicesim","k":"m"},{"m":0,"s":{"p":[{"t":"int","n":"$radix"},{"n":"whole","t":"Any"},{"n":"$failed-at","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Numeric:D"},"k":"m","n":"!slow-parse-base"},{"k":"m","s":{"r":"Mu","p":[{"t":"int","n":"$i"},{"n":"*%_","t":"Mu"}]},"n":"!hexify-at","m":0},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!rakufy"},{"n":"!match-one","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"iterator","t":"Any"},{"n":"$min","t":"Any"},{"n":"$max","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!match-x-range","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"iterator"},{"t":"Any","n":"$min"},{"n":"$max","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!match-nth-range"},{"n":"!indices","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"str","n":"$needle"},{"n":"overlap","t":"Any"},{"t":"int","n":"$start"},{"n":"*%_","t":"Mu"}]}},{"n":"!match-as-one","s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"t":"Any","n":"cursor"},{"t":"Any","n":"as"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"t":"Any","n":"iterator"},{"t":"Any","n":"$x"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"!match-x"},{"m":0,"n":"!fail-oor","s":{"r":"Mu","p":[{"t":"Any","n":"$got"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"$chars"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!SUBSTR-CHARS-OOR","k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"t":"Any","n":"source"},{"t":"Any","n":"indexes"},{"t":"Mu","n":"*%_"}]},"n":"!match-nth-iterator","m":0,"k":"m"},{"k":"m","n":"!match-pattern","m":0,"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"$pattern","t":"Any"},{"n":"$name","t":"str"},{"t":"Any","n":"$value"},{"t":"Any","n":"opts"},{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"!combiners","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"caller_dollar_slash","t":"Any"},{"n":"$matcher","t":"Any"},{"t":"Any","n":"$replacement"},{"n":":$g","t":"Any"},{"t":"Any","n":":$samecase"},{"n":":$samespace","t":"Any"},{"n":":$samemark","t":"Any"},{"n":"*%options","t":"Associative"}]},"n":"!SUBST","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"matches"},{"t":"Any","n":"$replacement"},{"n":"cds","t":"Any"},{"n":"SDS","t":"Any"},{"t":"Any","n":"word_by_word"},{"n":"space","t":"Any"},{"n":"case","t":"Any"},{"t":"Any","n":"mark"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!APPLY-MATCHES"},{"k":"m","m":0,"s":{"p":[{"n":"$needle","t":"str"},{"n":"overlap","t":"Any"},{"n":"$start","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!indicesic"}],"d":"<p><pre><code>class Str is Cool does Stringy { }</code></pre></p><p>Built-in class for strings. Objects of type Str are immutable, but read the FAQ to understand precisely what this means.</p>","mro":["Stringy","Cool"],"k":"c"},{"a":[{"n":"$!cursor","t":"Mu","k":"v"},{"t":"Mu","n":"$!move","k":"v"},{"k":"v","t":"Mu","n":"$!post"}],"mro":["Iterator","Any"],"t":"Str::POST-ITERATOR","k":"c","m":[{"s":{"r":"Mu","p":[{"t":"Any","n":"c"},{"n":"t","t":"Any"},{"n":"p","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"new","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"pull-one"},{"m":0,"n":"skip-one","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"n":"push-all","s":{"p":[{"n":"target","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"!SET-SELF","k":"m","s":{"p":[{"t":"Any","n":"cursor"},{"n":"move","t":"Any"},{"n":"post","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0}],"b":"A","n":"Str::POST-ITERATOR"},{"m":[{"n":"new","s":{"r":"Mu","p":[{"n":"c","t":"Any"},{"n":"t","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"pull-one"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"skip-one"},{"s":{"p":[{"n":"target","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"push-all","k":"m"},{"s":{"p":[{"t":"Any","n":"cursor"},{"t":"Any","n":"move"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!SET-SELF"}],"a":[{"t":"Mu","k":"v","n":"$!cursor"},{"t":"Mu","n":"$!move","k":"v"}],"k":"c","n":"Str::CURSOR-ITERATOR","mro":["Iterator","Any"],"t":"Str::CURSOR-ITERATOR","b":"A"},{"k":"v","t":"Sub+{is-nodal}+{Precedence}+{is-nodal}","n":"&postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Any"}],"r":"Mu"}},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Any","n":"key"},{"n":"ASSIGN","t":"Mu"}]},"m":1,"n":"postcircumfix:<{ }>"},{"m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"key"},{"t":"Mu","n":":$BIND!"}],"r":"Mu"},"k":"s","n":"postcircumfix:<{ }>"},{"k":"s","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Any","n":"key"},{"n":":$delete!","t":"Any"}],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"key"},{"t":"Any","n":":$delete!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<{ }>"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Any"},{"n":":$exists!","t":"Any"}],"r":"Mu"},"k":"s","n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"key"},{"t":"Any","n":":$exists!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<{ }>","s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Any"},{"n":":$kv!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"key","t":"Any"},{"t":"Any","n":":$p!"},{"n":"*%other","t":"Associative"}]}},{"s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Any"},{"t":"Any","n":":$k!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<{ }>","m":1,"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Any","n":"key"},{"t":"Any","n":":$v!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Iterable","n":"key"}],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<{ }>"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Iterable"},{"n":"ASSIGN","t":"Mu"}]},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Iterable"},{"n":":$BIND!","t":"Any"}],"r":"Mu"},"k":"s","m":1},{"m":1,"k":"s","n":"postcircumfix:<{ }>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Iterable"},{"n":":$delete!","t":"Any"},{"t":"Associative","n":"*%other"}]}},{"n":"postcircumfix:<{ }>","m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Iterable","n":"key"},{"n":":$exists!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Iterable"},{"n":":$kv!","t":"Any"},{"n":"*%other","t":"Associative"}]}},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Iterable","n":"key"},{"n":":$p!","t":"Any"},{"t":"Associative","n":"*%other"}]},"n":"postcircumfix:<{ }>"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"key","t":"Iterable"},{"t":"Any","n":":$k!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<{ }>","k":"s"},{"m":1,"n":"postcircumfix:<{ }>","k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Iterable","n":"key"},{"n":":$v!","t":"Any"},{"n":"*%other","t":"Associative"}]}},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$","t":"Whatever"}]},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"},{"n":"ASSIGN","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$","t":"Whatever"},{"n":":$BIND!","t":"Any"}]},"k":"s","n":"postcircumfix:<{ }>"},{"k":"s","n":"postcircumfix:<{ }>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"n":":$delete!","t":"Any"},{"n":"*%other","t":"Associative"}]}},{"m":1,"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"},{"t":"Any","n":":$exists!"},{"n":"*%other","t":"Associative"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$","t":"Whatever"},{"t":"Any","n":":$kv!"},{"t":"Associative","n":"*%other"}]},"n":"postcircumfix:<{ }>","k":"s"},{"n":"postcircumfix:<{ }>","k":"s","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"n":":$p!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"}},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"$","t":"Whatever"},{"n":":$k!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<{ }>","m":1,"k":"s"},{"k":"s","m":1,"n":"postcircumfix:<{ }>","s":{"p":[{"n":"SELF","t":"Any"},{"n":"$","t":"Whatever"},{"t":"Any","n":":$p!"},{"t":"Associative","n":"*%other"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"},{"t":"Any","n":":$v!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":":$BIND!","t":"Any"}]},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"n":":$delete!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Any","n":":$exists!"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<{ }>","k":"s"},{"m":1,"n":"postcircumfix:<{ }>","k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"n":":$kv!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"m":1,"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":":$p!","t":"Any"},{"t":"Associative","n":"*%other"}]},"k":"s"},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":":$k!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<{ }>","k":"s","m":1},{"k":"s","s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":":$p!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"m":1,"n":"postcircumfix:<{ }>"},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":":$v!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s","n":"postcircumfix:<{ }>","m":1},{"m":1,"s":{"p":[{"t":"Mu","n":"SELF"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s","n":"postcircumfix:<{ }>"},{"k":"v","t":"Sub+{Precedence}","d":"<p>Returns the first argument that evaluates to True in boolean context, otherwise returns the last argument.</p><p>Note that this short-circuits; i.e., if one of the arguments evaluates to a true value, the remaining arguments are not evaluated.</p><p><pre><code>sub a { 0 }\nsub b { 1 }\nsub c { die \"never called\" };\nsay a() || b() || c();      # OUTPUT: «1␤»</code></pre></p>","n":"&infix:<||>"},{"n":"infix:<||>","s":{"p":[{"n":"$x?","t":"Mu"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Mu"},{"n":"&b","t":"Callable"}],"r":"Mu"},"n":"infix:<||>","k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"Mu","n":"a"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<||>"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<+^>","d":"<p><pre><code>multi sub infix:&lt;+^&gt;($a, $b --&gt; Int:D)</code></pre></p><p>Integer bitwise XOR operator: Coerces both arguments to Int and does a bitwise XOR (exclusive OR) operation.</p>"},{"n":"infix:<+^>","k":"s","s":{"r":"Mu","p":[]},"m":1},{"s":{"r":"Mu","p":[{"t":"Any","n":"$x"}]},"m":1,"k":"s","n":"infix:<+^>"},{"k":"s","m":1,"n":"infix:<+^>","s":{"r":"Mu","p":[{"t":"Any","n":"$x"},{"n":"$y","t":"Any"}]}},{"n":"infix:<+^>","k":"s","m":1,"s":{"r":"Int:D","p":[{"n":"a","t":"Int"},{"t":"Int","n":"b"}]}},{"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"},"k":"s","m":1,"n":"infix:<+^>"},{"m":[{"m":1,"s":{"p":[{"n":"*@values","t":"Positional"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"STORE"},{"k":"m","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"m":0,"n":"BIND-POS"},{"s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"k":"m","m":0,"n":"DELETE-POS"},{"s":{"r":"Mu","p":[{"t":"Any","n":"pos"},{"t":"Mu","n":"assignee"},{"t":"Mu","n":"*%_"}]},"n":"ASSIGN-POS","k":"m","m":1},{"k":"m","n":"ASSIGN-POS","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"pos"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"shape"},{"m":1,"k":"m","n":"Real","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1,"n":"Int"},{"k":"m","n":"eager","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"flat","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"list"},{"k":"m","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"n":"sink","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"FLATTENABLE_LIST","m":0},{"m":0,"n":"FLATTENABLE_HASH","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"iterator"},{"s":{"p":[{"n":"$index","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"out_of_range","k":"m","m":0},{"n":"!create-ws","k":"m","m":0,"s":{"p":[{"n":"$shape","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"shape","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!shaped","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"!create"}],"t":"array","n":"array","b":"A","mro":["Iterable","Any"],"k":"c"},{"mro":["Rakudo::Internals::ShapedArrayCommon"],"b":"C","t":"array::shapedarray","k":"ro","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"shape"}],"n":"array::shapedarray"},{"b":"C","k":"ro","mro":["array::shapedintarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"m":[{"s":{"r":"array::shaped1intarray::Iterate-int:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"iterator"},{"k":"m","s":{"r":"::?CLASS","p":[{"t":"Mu","n":"*%_"}]},"n":"reverse","m":0},{"m":0,"k":"m","n":"rotate","s":{"r":"::?CLASS","p":[{"t":"Cool","n":"$rotate?"},{"n":"*%_","t":"Mu"}]}}],"t":"array::shaped1intarray","n":"array::shaped1intarray"},{"t":"array::shaped2intarray","n":"array::shaped2intarray","k":"ro","mro":["array::shapedintarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"b":"C"},{"b":"C","k":"ro","mro":["array::shapednumarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"t":"array::shaped1numarray","n":"array::shaped1numarray","m":[{"n":"iterator","s":{"r":"array::shaped1numarray::Iterate-num:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","m":0,"n":"reverse","s":{"r":"::?CLASS","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"r":"::?CLASS","p":[{"n":"$rotate?","t":"Cool"},{"t":"Mu","n":"*%_"}]},"n":"rotate"}]},{"mro":["array::shapednumarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"t":"array::shaped3numarray","b":"C","n":"array::shaped3numarray","k":"ro"},{"t":"array::shapedstrarray","k":"ro","mro":["array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"b":"C","m":[{"m":0,"n":"iterator","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"array::shapedstrarray::Iterate-str:D"},"k":"m"}],"n":"array::shapedstrarray"},{"t":"array::shapedintarray","m":[{"s":{"r":"array::shapedintarray::Iterate-int:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"iterator","m":0}],"mro":["array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"n":"array::shapedintarray","b":"C","k":"ro"},{"k":"ro","n":"array::shaped3strarray","mro":["array::shapedstrarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"b":"C","t":"array::shaped3strarray"},{"b":"C","k":"ro","n":"array::shapednumarray","mro":["array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"m":[{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"array::shapednumarray::Iterate-num:D"},"n":"iterator","m":0}],"t":"array::shapednumarray"},{"m":[{"n":"iterator","k":"m","m":0,"s":{"r":"array::shaped1strarray::Iterate-str:D","p":[{"t":"Mu","n":"*%_"}]}},{"n":"reverse","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"::?CLASS"}},{"s":{"p":[{"n":"$rotate?","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"::?CLASS"},"k":"m","m":0,"n":"rotate"}],"t":"array::shaped1strarray","k":"ro","mro":["array::shapedstrarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"b":"C","n":"array::shaped1strarray"},{"k":"c","n":"array::typedim2role","b":"C","t":"List","a":[{"k":"v","n":"$!reified","t":"Mu"},{"t":"Mu","n":"$!todo","k":"v"}],"mro":["Positional","Iterable","Cool"],"m":[{"k":"m","m":0,"n":"!JUNCTIONIZE","s":{"p":[{"t":"Any","n":"sep"},{"t":"Mu","n":"strings"},{"n":"i","t":"Any"},{"t":"Any","n":"elems"},{"n":"initial","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"pos"},{"n":"*%_","t":"Mu"}]},"n":"!AT_POS_SLOW"}]},{"k":"ro","n":"array::shaped2strarray","mro":["array::shapedstrarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"t":"array::shaped2strarray","b":"C"},{"mro":["array::shapednumarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"t":"array::shaped2numarray","k":"ro","n":"array::shaped2numarray","b":"C"},{"mro":["array::shapedintarray","array::shapedarray","Rakudo::Internals::ShapedArrayCommon"],"t":"array::shaped3intarray","k":"ro","b":"C","n":"array::shaped3intarray"},{"k":"v","n":"&atomic-fetch-add","t":"Sub"},{"n":"atomic-fetch-add","s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"int"}]},"m":1,"k":"s"},{"k":"s","m":1,"n":"atomic-fetch-add","s":{"r":"atomicint","p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"Int"}]}},{"k":"s","m":1,"n":"atomic-fetch-add","s":{"p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"Any"}],"r":"atomicint"}},{"t":"Endian","n":"BigEndian","k":"e"},{"t":"Sub","k":"v","n":"&atomic-fetch"},{"k":"s","m":1,"n":"atomic-fetch","s":{"p":[{"t":"Any","n":"$source"}],"r":"Mu"}},{"s":{"p":[{"n":"$source","t":"atomicint"}],"r":"Mu"},"m":1,"n":"atomic-fetch","k":"s"},{"n":"&infix:<xx>","d":"<p>Defined as:</p><p><pre><code>multi sub infix:&lt;xx&gt;()\nmulti sub infix:&lt;xx&gt;(Mu \\x)\nmulti sub infix:&lt;xx&gt;(&amp;x, Num:D() $n)\nmulti sub infix:&lt;xx&gt;(&amp;x, Whatever)\nmulti sub infix:&lt;xx&gt;(&amp;x, Bool:D $b)\nmulti sub infix:&lt;xx&gt;(&amp;x, Int:D $n)\nmulti sub infix:&lt;xx&gt;(Mu \\x, Num:D() $n)\nmulti sub infix:&lt;xx&gt;(Mu \\x, Whatever)\nmulti sub infix:&lt;xx&gt;(Mu \\x, Bool:D $b)\nmulti sub infix:&lt;xx&gt;(Mu \\x, Int:D $n)</code></pre></p><p>In general, it returns a Sequence of $a repeated and evaluated $b times ($b is coerced to Int). If $b &lt;= 0 , the empty list is returned. It will return an error with no operand, and return the operand itself with a single operand. An exception X::Numeric::CannotConvert will be thrown if $b is -Inf or NaN.</p><p>The left-hand side is evaluated for each repetition, so</p><p><pre><code>say [1, 2] xx 5;\n# OUTPUT: «([1 2] [1 2] [1 2] [1 2] [1 2])␤»</code></pre></p><p>returns five distinct arrays (but with the same content each time), and</p><p><pre><code>rand xx 3</code></pre></p><p>returns three pseudo random numbers that are determined independently.</p><p>The right-hand side can be *, in which case a lazy, infinite list is returned. If it's a Bool, a Seq with a single element is returned if it's True.</p>","k":"v","t":"Sub+{Precedence}"},{"k":"s","n":"infix:<xx>","m":1,"s":{"r":"Mu","p":[]}},{"n":"infix:<xx>","s":{"r":"Mu","p":[{"t":"Mu","n":"x"}]},"k":"s","m":1},{"s":{"r":"Mu","p":[{"t":"Callable","n":"&x"},{"t":"Any","n":"$n"}]},"k":"s","n":"infix:<xx>","m":1},{"n":"infix:<xx>","k":"s","s":{"r":"Mu","p":[{"n":"&x","t":"Callable"},{"t":"Whatever","n":"$"}]},"m":1},{"m":1,"k":"s","s":{"p":[{"n":"&x","t":"Callable"},{"n":"$b","t":"Bool"}],"r":"Mu"},"n":"infix:<xx>"},{"m":1,"n":"infix:<xx>","s":{"r":"Mu","p":[{"n":"&x","t":"Callable"},{"n":"$n","t":"Int"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"x"},{"n":"$n","t":"Any"}]},"n":"infix:<xx>","k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"x","t":"Mu"},{"n":"$","t":"Whatever"}]},"n":"infix:<xx>"},{"m":1,"s":{"p":[{"n":"x","t":"Mu"},{"t":"Bool","n":"$b"}],"r":"Mu"},"n":"infix:<xx>","k":"s"},{"m":1,"s":{"p":[{"t":"Mu","n":"x"},{"t":"Int","n":"$n"}],"r":"Mu"},"n":"infix:<xx>","k":"s"},{"a":[{"t":"Mu","n":"$.scheduler","k":"v"},{"t":"Mu","k":"v","n":"$.status"},{"n":"$!result","t":"Mu","k":"v"},{"t":"int","n":"$!vow_taken","k":"v"},{"n":"$!lock","t":"Mu","k":"v"},{"n":"$!cond","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$!thens"},{"k":"v","n":"$!dynamic_context","t":"Mu"},{"t":"Bool","n":"$!report-broken-if-sunk","k":"v"}],"d":"<p><pre><code>my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));\nclass Promise {}</code></pre></p><p>A Promise is used to handle the result of a computation that might not have finished. It allows the user to execute code once the computation is done (with the then method), execution after a time delay (with in), combining promises, and waiting for results.</p><p><pre><code>my $p = Promise.start({ sleep 2; 42});\n$p.then({ say .result });   # will print 42 once the block finished\nsay $p.status;              # OUTPUT: «Planned␤»\n$p.result;                  # waits for the computation to finish\nsay $p.status;              # OUTPUT: «Kept␤»</code></pre></p><p>There are two typical scenarios for using promises. The first is to use a factory method (start, in, at, anyof, allof, kept, broken) on the type object; those will make sure that the promise is automatically kept or broken for you, and you can't call break or keep on these promises yourself.</p><p>The second is to create your promises yourself with Promise.new. If you want to ensure that only your code can keep or break the promise, you can use the vow method to get a unique handle, and call keep or break on it:</p><p><pre><code>sub async-get-with-promise($user-agent, $url) {\n    my $p = Promise.new;\n    my $v = $p.vow;\n\n    # do an asynchronous call on a fictive user agent,\n    # and return the promise:\n    $user-agent.async-get($url,\n            on-error =&gt; -&gt; $error {\n                $v.break($error);\n            },\n            on-success =&gt; -&gt; $response {\n                $v.keep($response);\n            }\n    );\n    return $p;\n}\n</code></pre></p><p>Further examples can be found in the concurrency page.</p>","b":"A","t":"Promise","k":"c","n":"Promise","m":[{"m":0,"s":{"p":[{"t":"Any","n":":$scheduler?"},{"t":"Any","n":":$report-broken-if-sunk"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new","k":"s"},{"m":0,"s":{"p":[{"t":"Any","n":":$!scheduler?"},{"n":":$report-broken-if-sunk","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"s","n":"BUILD"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"vow","d":"<p><pre><code>my class Vow {\n    has Promise $.promise;\n    method keep() { ... }\n    method break() { ... }\n}\nmethod vow(Promise:D: --&gt; Vow:D)\n</code></pre></p><p>Returns an object that holds the sole authority over keeping or breaking a promise. Calling keep or break on a promise that has vow taken throws an exception of type X::Promise::Vowed.</p><p><pre><code>my $p   = Promise.new;\nmy $vow = $p.vow;\n$vow.keep($p);\nsay $p.status;          # OUTPUT: «Kept␤»</code></pre></p>","k":"m"},{"m":1,"k":"m","d":"<p><pre><code>multi method kept(Promise:U: \\result = True --&gt; Promise:D)</code></pre></p><p>Returns a new promise that is already kept, either with the given value, or with the default value True.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"kept"},{"d":"<p><pre><code>multi method kept(Promise:U: \\result = True --&gt; Promise:D)</code></pre></p><p>Returns a new promise that is already kept, either with the given value, or with the default value True.</p>","s":{"r":"Mu","p":[{"n":"result","t":"Mu"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"kept","k":"m"},{"k":"m","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>multi method keep(Promise:D: \\result = True)</code></pre></p><p>Keeps a promise, optionally setting the result. If no result is passed, the result will be True.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\nif Bool.pick {\n    $p.keep;\n}\nelse {\n     $p.break;\n}</code></pre></p>","n":"keep"},{"d":"<p><pre><code>multi method keep(Promise:D: \\result = True)</code></pre></p><p>Keeps a promise, optionally setting the result. If no result is passed, the result will be True.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\nif Bool.pick {\n    $p.keep;\n}\nelse {\n     $p.break;\n}</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"result"},{"t":"Mu","n":"*%_"}]},"n":"keep","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":1,"d":"<p><pre><code>multi method broken(Promise:U: --&gt; Promise:D)\nmulti method broken(Promise:U: \\exception --&gt; Promise:D)</code></pre></p><p>Returns a new promise that is already broken, either with the given value, or with the default value X::AdHoc.new(payload =&gt; \"Died\")</p>","n":"broken"},{"d":"<p><pre><code>multi method broken(Promise:U: --&gt; Promise:D)\nmulti method broken(Promise:U: \\exception --&gt; Promise:D)</code></pre></p><p>Returns a new promise that is already broken, either with the given value, or with the default value X::AdHoc.new(payload =&gt; \"Died\")</p>","n":"broken","s":{"p":[{"n":"exception","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"n":"break","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>multi method break(Promise:D: \\cause = False)</code></pre></p><p>Breaks a promise, optionally setting the cause. If no cause is passed, the cause will be False.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\n$p.break('sorry');\nsay $p.status;          # OUTPUT: «Broken␤»\nsay $p.cause;           # OUTPUT: «sorry␤»</code></pre></p>","m":1},{"d":"<p><pre><code>multi method break(Promise:D: \\cause = False)</code></pre></p><p>Breaks a promise, optionally setting the cause. If no cause is passed, the cause will be False.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\n$p.break('sorry');\nsay $p.status;          # OUTPUT: «Broken␤»\nsay $p.cause;           # OUTPUT: «sorry␤»</code></pre></p>","s":{"p":[{"t":"Any","n":"result"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"break"},{"n":"result","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"d":"<p><pre><code>method result(Promise:D)</code></pre></p><p>Waits for the promise to be kept or broken. If it is kept, returns the result; otherwise throws the result as an exception.</p>"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"d":"<p><pre><code>method cause(Promise:D)</code></pre></p><p>If the promise was broken, returns the result (or exception). Otherwise, throws an exception of type X::Promise::CauseOnlyValidOnBroken.</p>","n":"cause"},{"s":{"r":"Mu","p":[{"t":"Callable","n":"&code"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"then","m":0,"d":"<p><pre><code>method then(Promise:D: &amp;code)</code></pre></p><p>Schedules a piece of code to be run after the invocant has been kept or broken, and returns a new promise for this computation. In other words, creates a chained promise.</p><p><pre><code>my $timer = Promise.in(2);\nmy $after = $timer.then({ say \"2 seconds are over!\"; 'result' });\nsay $after.result;  # 2 seconds are over\n                    # result</code></pre></p>"},{"k":"m","n":"get-await-handle","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Awaitable::Handle:D"},"m":0},{"n":"sink","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Callable","n":"&code"},{"t":"Callable","n":":&catch"},{"t":"Any","n":":$scheduler?"},{"n":":$report-broken-if-sunk","t":"Any"},{"t":"Any","n":"c"}]},"d":"<p><pre><code>method start(Promise:U: &amp;code, :$scheduler = $*SCHEDULER --&gt; Promise:D)</code></pre></p><p>Creates a new Promise that runs the given code object. The promise will be kept when the code terminates normally, or broken if it throws an exception. The return value or exception can be inspected with the result method.</p><p>The scheduler that handles this promise can be passed as a named argument.</p><p>There is also a statement prefix start that provides syntactic sugar for this method:</p><p><pre><code># these two are equivalent:\nmy $p1 = Promise.start({ ;#`( do something here ) });\nmy $p2 = start { ;#`( do something here ) };</code></pre></p><p>As of the 6.d version of the language, start statement prefix used in sink context will automatically attach an exceptions handler. If an exception occurs in the given code, it will be printed and the program will then exit, like if it were thrown without any start statement prefixes involved.</p><p><pre><code>use v6.c;\nstart { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n</code></pre></p><p><pre><code>use v6.d;\nstart { die }; sleep ⅓; say \"hello\";\n# OUTPUT:\n# Unhandled exception in code scheduled on thread 4\n# Died\n#     in block  at -e line 1\n</code></pre></p><p>If you wish to avoid this behavior, use start in non-sink context or catch the exception yourself:</p><p><pre><code># Don't sink it:\nmy $ = start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n# Catch yourself:\nstart { die; CATCH { default { say \"caught\" } } };\nsleep ⅓;\nsay \"hello\";\n# OUTPUT: «caught␤hello␤»\n</code></pre></p><p>This behavior exists only syntactically, by using an alternate .sink method for Promise objects created by start blocks in sink context, thus simply sinking a Promise object that was created by other means won't trigger this behavior.</p>","m":0,"n":"start","k":"m"},{"s":{"p":[{"t":"Any","n":"$seconds"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER --&gt; Promise:D)</code></pre></p><p>Creates a new Promise that will be kept in $seconds seconds, or later.</p><p><pre><code>my $proc = Proc::Async.new('perl6', '-e', 'sleep 10; warn \"end\"');\n\nmy $result = await Promise.anyof(\n    my $promise = $proc.start,  # may or may not work in time\n    Promise.in(5).then: {       # fires after 5 seconds no matter what\n        unless $promise {       # don't do anything if we were successful\n            note 'timeout';\n            $proc.kill;\n        }\n    }\n).then: { $promise.result }\n# OUTPUT: «timeout␤»</code></pre></p><p>$seconds can be fractional or negative. Negative values are treated as 0 (i.e. keeping the returned Promise right away).</p><p>Please note that situations like these are often more clearly handled with a react and whenever block.</p>","k":"m","n":"in"},{"m":0,"k":"m","n":"at","d":"<p><pre><code>method at(Promise:U: $at, :$scheduler = $*SCHEDULER --&gt; Promise:D)</code></pre></p><p>Creates a new Promise that will be kept $at the given time—which is given as an Instant or equivalent Numeric—or as soon as possible after it.</p><p><pre><code>my $p = Promise.at(now + 2).then({ say \"2 seconds later\" });\n# do other stuff here\n\nawait $p;   # wait here until the 2 seconds are over</code></pre></p><p>If the given time is in the past, it will be treated as now (i.e. keeping the returned Promise right away).</p><p>Please note that situations like these are often more clearly handled with a react and whenever block.</p>","s":{"p":[{"n":"$at","t":"Any"},{"n":":$scheduler?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p><pre><code>method anyof(Promise:U: *@promises --&gt; Promise:D)</code></pre></p><p>Returns a new promise that will be kept as soon as any of the promises passed as arguments is kept or broken. The result of the completed Promise is not reflected in the result of the returned promise which will always be Kept.</p><p>You can use this to wait at most a number of seconds for a promise:</p><p><pre><code>my $timeout = 5;\nawait Promise.anyof(\n    Promise.in($timeout),\n    start {\n        # do a potentially long-running calculation here\n    },\n);</code></pre></p>","n":"anyof","s":{"p":[{"t":"Positional","n":"*@p"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"allof","s":{"p":[{"t":"Positional","n":"*@p"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method allof(Promise:U: *@promises --&gt; Promise:D)</code></pre></p><p>Returns a new promise that will be kept when all the promises passed as arguments are kept or broken. The result of the individual Promises is not reflected in the result of the returned promise: it simply indicates that all the promises have been completed in some way. If the results of the individual promises are important then they should be inspected after the allof promise is kept.</p><p>In the following requesting the result of a broken promise will cause the original Exception to be thrown. (You may need to run it several times to see the exception.)</p><p><pre><code>my @promises;\nfor 1..5 -&gt; $t {\n    push @promises, start {\n        sleep $t;\n    };\n}\nmy $all-done = Promise.allof(@promises);\nawait $all-done;\n@promises&gt;&gt;.result;\nsay \"Promises kept so we get to live another day!\";</code></pre></p>"},{"k":"m","n":"scheduler","d":"<p><pre><code>method scheduler(Promise:D:)</code></pre></p><p>Returns the scheduler that manages the promise.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"n":"status","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method status(Promise:D --&gt; PromiseStatus)</code></pre></p><p>Returns the current state of the promise: Kept, Broken or Planned:</p><p><pre><code>say \"promise got Kept\" if $promise.status ~~ Kept;\n</code></pre></p>","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"},{"s":{"p":[{"t":"Any","n":"result"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"k":"m","n":"!break"},{"n":"!keep","m":0,"k":"m","s":{"r":"Nil","p":[{"n":"result","t":"Mu"},{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"!schedule_thens","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"m":0,"n":"!until_n_kept","s":{"r":"Mu","p":[{"t":"Positional","n":"@promises"},{"t":"Int","n":"$N"},{"n":"$combinator","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"mro":["Awaitable","Any"]},{"k":"v","t":"Sub+{is-pure}","n":"&ceiling"},{"s":{"p":[{"n":"$a","t":"Any"}],"r":"Mu"},"k":"s","n":"ceiling","m":1},{"n":"ceiling","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"Numeric"}]}},{"n":"ceiling","k":"s","s":{"p":[{"n":"$a","t":"num"}],"r":"num"},"m":1},{"b":"C","n":"Grammar","mro":["NQPMatchRole","Match"],"m":[{"s":{"r":"Mu","p":[{"n":"$orig","t":"Any"},{"t":"Any","n":":$rule?"},{"n":":$args","t":"Any"},{"n":":$actions","t":"Mu"},{"n":"*%_","t":"Mu"}]},"n":"parse","d":"<p>Defined as:</p><p><pre><code>method parse($target, :$rule = 'TOP',  Capture() :$args = \\(), Mu :$actions = Mu, *%opt)</code></pre></p><p>Parses the $target, which will be coerced to Str if it isn't one, using $rule as the starting rule. Additional $args will be passed to the starting rule if provided.</p><p><pre><code>grammar RepeatChar {\n    token start($character) { $character+ }\n}\n\nsay RepeatChar.parse('aaaaaa', :rule('start'), :args(\\('a')));\nsay RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')));\n\n# OUTPUT:\n# ｢aaaaaa｣\n# ｢bbbbbb｣</code></pre></p><p>If the action named argument is provided, it will be used as an action object, that is, for each successful regex match, a method of the same name, if it exists, is called on the action object, passing the match object as the sole positional argument.</p><p><pre><code>my $actions = class { method TOP($/) { say \"7\" } };\ngrammar { token TOP { a { say \"42\" } b } }.parse('ab', :$actions);\n# OUTPUT : «42␤7␤»</code></pre></p><p>Additional named arguments are used as options for matching, so you can specify things like :pos(4) to start parsing from the fourth (zero-base) character. All matching adverbs are allowed, but not all of them take effect. There are several types of adverbs that a regex can have, some of which apply at compile time, like :s and :i. You cannot pass those to .parse, because the regexes have already been compiled. But, you can pass those adverbs that affect the runtime behavior, such as :pos and :continue.</p><p><pre><code>say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')), :pos(4)).Str;\n# OUTPUT : «bb␤»\n</code></pre></p><p>Method parse only succeeds if the cursor has arrived at the end of the target string when the match is over. Use method subparse if you want to be able to stop in the middle.</p><p>Returns a Match object on success, and Nil on failure.</p>","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method subparse($target, :$rule = 'TOP', Capture() :$args = \\(),  Mu :$actions = Mu, *%opt)</code></pre></p><p>Does exactly the same as method parse, except that cursor doesn't have to reach the end of the string to succeed. That is, it doesn't have to match the whole string.</p><p>Note that unlike method parse, subparse always returns a Match object, which will be a failed match (and thus falsy), if the grammar failed to match.</p><p><pre><code>grammar RepeatChar {\n    token start($character) { $character+ }\n}\n\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('b')));\nsay RepeatChar.parse('bbbabb', :rule('start'), :args(\\('b')));\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')));\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')), :pos(3));\n\n\n# OUTPUT:\n# ｢bbb｣\n# Nil\n# #&lt;failed match&gt;\n# ｢a｣</code></pre></p>","s":{"r":"Mu","p":[{"n":"$orig","t":"Any"},{"t":"Any","n":":$rule?"},{"t":"Any","n":":$args"},{"t":"Any","n":":$actions"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"subparse"},{"s":{"r":"Mu","p":[{"n":"$filename","t":"Cool"},{"n":":$enc","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"parsefile","k":"m","m":0},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"d":"<p><pre><code>class Grammar is Match {}</code></pre></p><p>Every type declared with grammar and not explicitly stating its superclass, becomes a subclass of Grammar.</p><p><pre><code>grammar Identifier {\n    token TOP       { &lt;initial&gt; &lt;rest&gt;* }\n    token initial   { &lt;+myletter +[_]&gt; }\n    token rest      { &lt;+myletter +mynumber +[_]&gt; }\n    token myletter  { &lt;[A..Za..z]&gt; }\n    token mynumber  { &lt;[0..9]&gt; }\n}\n\nsay Identifier.isa(Grammar);                # OUTPUT: «True␤»\nmy $match = Identifier.parse('W4anD0eR96');\nsay ~$match;                                # OUTPUT: «W4anD0eR96␤»</code></pre></p><p>More documentation on grammars is available.</p>","a":[{"t":"List","k":"v","n":"@!list"},{"t":"Hash","n":"%!hash","k":"v"}],"k":"c","t":"Grammar"},{"t":"Signal","n":"SIGABRT","k":"e"},{"n":"&infix:<(==)>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<(==)>","m":1,"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Setty"}],"r":"Bool:D"},"k":"s"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Mixy"}]},"k":"s","n":"infix:<(==)>"},{"s":{"p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<(==)>","m":1},{"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"n":"infix:<(==)>","m":1,"k":"s"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}]},"n":"infix:<(==)>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"n":"infix:<(==)>","k":"s"},{"m":1,"n":"infix:<(==)>","s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Setty"}]},"k":"s"},{"m":1,"n":"infix:<(==)>","k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}]}},{"s":{"r":"Bool:D","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Mixy"}]},"k":"s","n":"infix:<(==)>","m":1},{"m":1,"s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"k":"s","n":"infix:<(==)>"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Setty"}]},"m":1,"k":"s","n":"infix:<(==)>"},{"n":"infix:<(==)>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Any","n":"b"}],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}]},"n":"infix:<(==)>","k":"s","m":1},{"n":"infix:<(==)>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Iterable"},{"n":"b","t":"Map"}],"r":"Bool:D"}},{"k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Mixy"}],"r":"Bool:D"},"n":"infix:<(==)>","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<(==)>"},{"m":1,"n":"infix:<(==)>","k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Setty"}],"r":"Bool:D"}},{"m":1,"k":"s","n":"infix:<(==)>","s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"n":"$","t":"Any"}]}},{"m":1,"s":{"p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}],"r":"Mu"},"k":"s","n":"infix:<(==)>"},{"n":"infix:<(==)>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}],"r":"Bool:D"}},{"t":"Sub","k":"v","n":"&index"},{"m":1,"k":"s","s":{"p":[{"t":"Cool","n":"$s"},{"t":"Cool","n":"$needle"},{"n":":$ignorecase","t":"Any"},{"t":"Any","n":":$ignoremark"}],"r":"Int:D"},"n":"index"},{"n":"index","k":"s","m":1,"s":{"p":[{"t":"Cool","n":"$s"},{"t":"Cool","n":"$needle"},{"n":"$pos","t":"Cool"},{"t":"Any","n":":$ignorecase"},{"t":"Any","n":":$ignoremark"}],"r":"Int:D"}},{"n":"&round","t":"Sub+{is-pure}","k":"v"},{"n":"round","s":{"p":[{"t":"Any","n":"$a"}],"r":"Mu"},"k":"s","m":1},{"k":"s","n":"round","s":{"p":[{"n":"$a","t":"Any"},{"n":"$scale","t":"Any"}],"r":"Mu"},"m":1},{"n":"&infix:<?|>","d":"<p><pre><code>multi sub infix:&lt;?|&gt;($a, $b --&gt; Bool:D)</code></pre></p><p>Boolean logical OR operator.</p><p>Coerces both arguments to Bool and does a logical OR (inclusive OR) operation.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<?|>","s":{"p":[{"t":"Mu","n":"$x?"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"b"}],"r":"Mu"},"n":"infix:<?|>","k":"s"},{"n":"Order","k":"e","t":"Order"},{"t":"Order","n":"Order::Less","k":"e"},{"t":"Order","n":"Order::Same","k":"e"},{"t":"Order","k":"e","n":"Order::More"},{"n":"&split","k":"v","t":"Sub"},{"m":1,"n":"split","s":{"p":[{"n":"$pat","t":"Any"},{"n":"$target","t":"Cool"},{"t":"Any","n":"c"}],"r":"Mu"},"k":"s"},{"t":"Sub","k":"v","n":"&uninames"},{"s":{"p":[{"n":"$str","t":"Str"}],"r":"Mu"},"n":"uninames","m":1,"k":"s"},{"n":"&prefix:<−>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"}]},"k":"s","m":1,"n":"prefix:<−>"},{"m":1,"s":{"p":[{"t":"Real","n":"a"}],"r":"Mu"},"k":"s","n":"prefix:<−>"},{"n":"prefix:<−>","k":"s","s":{"p":[{"n":"a","t":"Int"}],"r":"Int:D"},"m":1},{"s":{"r":"int","p":[{"t":"int","n":"$a"}]},"n":"prefix:<−>","k":"s","m":1},{"m":1,"n":"prefix:<−>","k":"s","s":{"p":[{"t":"Num","n":"a"}],"r":"Mu"}},{"m":1,"s":{"p":[{"n":"$a","t":"num"}],"r":"num"},"k":"s","n":"prefix:<−>"},{"n":"prefix:<−>","m":1,"k":"s","s":{"p":[{"t":"Rat","n":"a"}],"r":"Rat:D"}},{"s":{"p":[{"t":"FatRat","n":"a"}],"r":"FatRat:D"},"m":1,"n":"prefix:<−>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Complex"}],"r":"Complex:D"},"k":"s","n":"prefix:<−>"},{"s":{"p":[{"t":"Duration","n":"$a"}],"r":"Duration:D"},"m":1,"k":"s","n":"prefix:<−>"},{"k":"e","t":"Signal","n":"SIGIO"},{"t":"ProtocolFamily","n":"PF_UNSPEC","k":"e"},{"k":"v","d":"<p>The notandthen operator returns Empty upon encountering the first defined argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as arguments if the right side is a Callable, whose count must be 0 or 1.</p><p>At first glance, notandthen might appear to be the same thing as the orelse operator. The difference is subtle: notandthen returns Empty when it encounters a defined item (that isn't the last item), whereas orelse returns that item. In other words, notandthen is a means to act when items aren't defined, whereas orelse is a means to obtain the first defined item:</p><p><pre><code>sub all-sensors-down     { [notandthen] |@_, True             }\nsub first-working-sensor { [orelse]     |@_, 'default sensor' }\n\nall-sensors-down Nil, Nil, Nil\n  and say 'OMG! All sensors are down!'; # OUTPUT:«OMG! All sensors are down!␤»\nsay first-working-sensor Nil, Nil, Nil; # OUTPUT:«default sensor␤»\n\nall-sensors-down Nil, 42, Nil\n  and say 'OMG! All sensors are down!'; # No output\nsay first-working-sensor Nil, 42, Nil;  # OUTPUT:«42␤»\n</code></pre></p><p>The notandthen operator is a close relative of without statement modifier, and some compilers compile without to notandthen, meaning these two lines have equivalent behavior:</p><p><pre><code>sub good-things { fail }\n\n'boo'.say without good-things;\ngood-things() notandthen 'boo'.say;\n</code></pre></p>","t":"Sub+{Precedence}","n":"&infix:<notandthen>"},{"k":"s","m":1,"n":"infix:<notandthen>","s":{"p":[{"t":"Any","n":"+a"}],"r":"Mu"}},{"n":"&words","t":"Sub","k":"v"},{"s":{"p":[{"n":"$what?","t":"Any"},{"t":"Any","n":"c"}],"r":"Mu"},"m":1,"n":"words","k":"s"},{"n":"SocketType","k":"e","t":"SocketType"},{"t":"SocketType","n":"SocketType::SOCK_RDM","k":"e"},{"n":"SocketType::SOCK_STREAM","k":"e","t":"SocketType"},{"t":"SocketType","n":"SocketType::SOCK_RAW","k":"e"},{"t":"SocketType","n":"SocketType::SOCK_DGRAM","k":"e"},{"k":"e","n":"SocketType::SOCK_PACKET","t":"SocketType"},{"n":"SocketType::SOCK_SEQPACKET","t":"SocketType","k":"e"},{"t":"SocketType","n":"SocketType::SOCK_MAX","k":"e"},{"t":"Sub","n":"&copy","k":"v"},{"n":"copy","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"$from"},{"n":"$to","t":"Any"},{"n":":$createonly","t":"Any"}]},"m":1},{"n":"SIGSTKFLT","t":"Signal","k":"e"},{"t":"Sub+{is-pure}","n":"&acosec","k":"v"},{"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"},"k":"s","m":1,"n":"acosec"},{"m":1,"s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]},"n":"acosec","k":"s"},{"k":"s","m":1,"n":"acosec","s":{"r":"Mu","p":[{"t":"Num","n":"x"}]}},{"t":"Sub","n":"&produce","k":"v"},{"n":"produce","m":1,"s":{"p":[{"t":"Callable","n":"&with"},{"n":"+list","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"e","t":"FileChangeEvent","n":"FileChanged"},{"t":"Endian","k":"e","n":"Endian"},{"t":"Endian","n":"Endian::NativeEndian","k":"e"},{"t":"Endian","k":"e","n":"Endian::BigEndian"},{"t":"Endian","n":"Endian::LittleEndian","k":"e"},{"t":"Sub+{is-pure}","k":"v","n":"&wordcase"},{"k":"s","n":"wordcase","m":1,"s":{"p":[{"n":"$x","t":"Str"}],"r":"Mu"}},{"n":"wordcase","s":{"p":[{"n":"$x","t":"Cool"}],"r":"Mu"},"k":"s","m":1},{"k":"v","t":"Sub","n":"&postfix:<⚛-->"},{"n":"postfix:<⚛-->","m":1,"s":{"p":[{"t":"atomicint","n":"$target"}],"r":"atomicint"},"k":"s"},{"d":"<p><pre><code>class Kernel does Systemic { }</code></pre></p><p>Built-in class for providing kernel related information. Usually accessed through the $*KERNEL dynamic variable.</p>","b":"A","n":"Kernel","a":[{"t":"Str","k":"v","n":"$!release"},{"n":"$!hardware","t":"Str","k":"v"},{"k":"v","t":"Str","n":"$!arch"},{"n":"$!bits","k":"v","t":"Int"},{"k":"v","t":"Mu","n":"$!uname"},{"n":"@!signals","k":"v","t":"Positional"},{"n":"$!signals-setup-lock","t":"Mu","k":"v"},{"n":"$!signals-setup","k":"v","t":"Mu"},{"t":"Associative","k":"v","n":"%!signals-by-Str"},{"t":"Mu","n":"$!signals-by-Str-setup","k":"v"},{"n":"$.name","t":"Str","k":"v"},{"k":"v","n":"$.auth","t":"Str"},{"t":"Version","n":"$.version","k":"v"},{"n":"$.signature","t":"Blob","k":"v"},{"t":"Str","n":"$.desc","k":"v"}],"k":"c","mro":["Systemic","Any"],"t":"Kernel","m":[{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"name"},{"n":"version","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Version:D"},"k":"m","m":0},{"n":"release","d":"<p><pre><code>method release</code></pre></p><p>Instance method returning the release information of the Kernel object. Dies if the release information could not be established.</p>","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"m":0,"n":"hardware","d":"<p>Defined as</p><p><pre><code>method hardware</code></pre></p><p>Instance method returning the hardware information of the Kernel object. Dies if the hardware information could not be established.</p><p><pre><code>say $*KERNEL.hardware; # OUTPUT: «x86_64␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m"},{"d":"<p><pre><code>method arch</code></pre></p><p>Instance method returning the \"arch\" (as in \"architecture\") information of the Kernel object. Dies if the \"arch\" could not be established.</p>","m":0,"n":"arch","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"archname","d":"<p><pre><code>method archname</code></pre></p><p>Instance method returning the concatenation of hardware and name.</p>","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"d":"<p><pre><code>method bits</code></pre></p><p>Instance method returning the number of bits used in the architecture of the processor. Usually 32 or 64.</p>","k":"m","m":0,"n":"bits","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"d":"<p><pre><code>method hostname</code></pre></p><p>Instance method returning the hostname of the Kernel object.</p>","n":"hostname","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"signals","m":0},{"m":1,"n":"signal","s":{"r":"Int:D","p":[{"n":"$signal","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method signal(Kernel:D: Str:D $signal --&gt; Int:D)\nmulti method signal(Kernel:D: Signal:D \\signal --&gt; Int:D)\nmulti method signal(Kernel:D: Int:D \\signal --&gt; Int:D)</code></pre></p><p>Instance method returning the Signal numeric code for a given name for the Kernel object.</p><p><pre><code>say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi method signal(Kernel:D: Str:D $signal --&gt; Int:D)\nmulti method signal(Kernel:D: Signal:D \\signal --&gt; Int:D)\nmulti method signal(Kernel:D: Int:D \\signal --&gt; Int:D)</code></pre></p><p>Instance method returning the Signal numeric code for a given name for the Kernel object.</p><p><pre><code>say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»</code></pre></p>","m":1,"s":{"p":[{"t":"Signal","n":"signal"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"signal","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method signal(Kernel:D: Str:D $signal --&gt; Int:D)\nmulti method signal(Kernel:D: Signal:D \\signal --&gt; Int:D)\nmulti method signal(Kernel:D: Int:D \\signal --&gt; Int:D)</code></pre></p><p>Instance method returning the Signal numeric code for a given name for the Kernel object.</p><p><pre><code>say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»</code></pre></p>","m":1,"k":"m","s":{"p":[{"n":"signal","t":"Int"},{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"signal"},{"d":"<p><pre><code>method cpu-cores(--&gt; Int)</code></pre></p><p>Instance / Class method returning the number of CPU cores that are available.</p><p><pre><code>say $*KERNEL.cpu-cores; # OUTPUT: «8␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int"},"n":"cpu-cores","k":"m","m":0},{"k":"m","d":"<p><pre><code>method cpu-usage(--&gt; Int)</code></pre></p><p>Instance / Class method returning the amount of CPU uses since the start of the program (in microseconds).</p>","s":{"r":"Int","p":[{"t":"Mu","n":"*%_"}]},"n":"cpu-usage","m":0},{"k":"m","s":{"r":"Int","p":[{"t":"Mu","n":"*%_"}]},"n":"free-memory","d":"<p><pre><code>method free-memory(--&gt; Int)</code></pre></p><p>Instance / Class method returning the available memory on the system. When using the JVM, this returns the available memory to the JVM instead. This method is only available in release v2019.06 and later.</p>","m":0},{"d":"<p><pre><code>method total-memory(--&gt; Int)</code></pre></p><p>Instance / Class method returning the total memory available to the system. When using the JVM, this returns the total memory available to the JVM instead. This method is only available in release v2019.06 and later.</p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int"},"n":"total-memory","k":"m"},{"s":{"r":"Endian:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"d":"<p><pre><code>method endian(--&gt; Endian:D)</code></pre></p><p>Class method that returns the Endian object associated with the kernel architecture (either LittleEndian or BigEndian).</p>","k":"m","n":"endian"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"auth"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"signature"},{"m":0,"n":"desc","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"},{"k":"m","m":0,"n":"!uname","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"t":"Str","n":"distro"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"!name","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"!uname-s","m":0,"k":"m"},{"s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!uname-m"},{"n":"!uname-r","m":0,"s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"distro","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"n":"!arch","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m","n":"!uname-v"},{"n":"!uname-p","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":0,"k":"m"}]},{"t":"Sub+{Precedence}","n":"&infix:<…^>","k":"v"},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Mu","n":"b"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<…^>"},{"n":"Awaitable","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"get-await-handle"}],"b":"C","mro":[],"t":"Awaitable","k":"ro"},{"n":"Awaitable::Handle","k":"ro","a":[{"t":"Bool","n":"$.already","k":"v"},{"t":"Bool","n":"$.success","k":"v"},{"n":"$.result","t":"Mu","k":"v"},{"t":"Exception","k":"v","n":"$.cause"}],"m":[{"k":"m","n":"already-success","s":{"r":"Mu","p":[{"n":"result","t":"Mu"},{"t":"Mu","n":"*%_"}]},"m":0},{"k":"m","s":{"p":[{"t":"Mu","n":"cause"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"already-failure"},{"s":{"r":"Mu","p":[{"n":"&subscriber","t":"Callable"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"subscribe-awaiter","k":"m"},{"m":0,"k":"m","n":"!ALREADY_FAILURE","s":{"r":"Mu","p":[{"t":"Mu","n":"cause"},{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"result","t":"Mu"},{"t":"Mu","n":"*%_"}]},"n":"!ALREADY_SUCCESS"}],"mro":[],"b":"C","t":"Awaitable::Handle"},{"k":"c","a":[{"k":"v","t":"Mu","n":"$!eigenstates"},{"k":"v","t":"str","n":"$!type"}],"t":"Junction","n":"Junction","m":[{"n":"new","k":"m","s":{"p":[{"n":"values","t":"Any"},{"t":"Str","n":":$type!"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method new(Junction: \\values, Str :$type!)\nmulti method new(Junction: Str:D \\type, \\values)</code></pre></p><p>Constructor to define a new Junction from the type that defines de Junction and a set of values.</p><p><pre><code>my $j = Junction.new(&lt;Þor Oðinn Loki&gt;, type =&gt; \"all\");\nmy $n = Junction.new( \"one\", 1..6 )</code></pre></p>","m":1},{"s":{"r":"Mu","p":[{"n":"type","t":"Str"},{"n":"values","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"new","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Junction: \\values, Str :$type!)\nmulti method new(Junction: Str:D \\type, \\values)</code></pre></p><p>Constructor to define a new Junction from the type that defines de Junction and a set of values.</p><p><pre><code>my $j = Junction.new(&lt;Þor Oðinn Loki&gt;, type =&gt; \"all\");\nmy $n = Junction.new( \"one\", 1..6 )</code></pre></p>","m":1},{"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"k":"m","m":0,"n":"CALL-ME"},{"m":0,"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"sink"},{"n":"!defined-one","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"$type","t":"str"},{"n":"values","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!SET-SELF"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"!defined-any"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"!defined-none"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!defined-all","k":"m"}],"b":"M","mro":["Mu"],"d":"<p><pre><code>class Junction is Mu { }</code></pre></p><p>A junction is an unordered composite value of zero or more values. Junctions autothread over many operations, which means that the operation is carried out for each junction element (also known as eigenstate), and the result is junction of the return values of all those operators.</p><p>Junctions collapse into a single value in boolean context, so when used in a conditional, a negation or an explicit coercion to Bool through the so or ? prefix operators. The semantics of this collapse depend on the junction type, which can be all, any, one or none.</p><table class='sections'><tr><th>type</th><th>constructor</th><th>operator</th><th>True if ...</th></tr>\n<tr><td>all</tr><td>all</tr><td>&amp;</tr><td>no value evaluates to False</tr></tr>\n<tr><td>any</tr><td>any</tr><td>|</tr><td>at least one value evaluates to True</tr></tr>\n<tr><td>one</tr><td>one</tr><td>^</tr><td>exactly one value evaluates to True</tr></tr>\n<tr><td>none</tr><td>none</tr><td></tr><td>no value evaluates to True</tr></tr>\n</table><p>As the table shows, in order to create junctions, you use the string that represents the type followed by any object, or else call .all, .none or .one on the object.</p><p><pre><code>say so 3 == (1..30).one;         # OUTPUT: «True␤»\nsay so (\"a\" ^ \"b\" ^ \"c\") eq \"a\"; # OUTPUT: «True␤»</code></pre></p><p>Junctions are very special objects. They fall outside the Any hierarchy, being only, as any other object, subclasses of Mu. That enables a feature for most methods: autothreading. Autothreading happens when a junction is bound to a parameter of a code object that doesn't accept values of type Junction. Instead of producing an error, the signature binding is repeated for each value of the junction.</p><p>Example:</p><p><pre><code>my $j = 1|2;\nif 3 == $j + 1 {\n    say 'yes';\n}</code></pre></p><p>First autothreads over the infix:&lt;+&gt;  operator, producing the Junction 2|3. The next autothreading step is over infix:&lt;==&gt; , which produces False|True. The if conditional evaluates the junction in boolean context, which collapses it to True. So the code prints yes\\n.</p><p>The type of a Junction does not affect the number of items in the resultant Junction after autothreading. For example, using a one Junction during Hash key lookup, still results in a Junction with several items. It is only in boolean context would the type of the Junction come into play:</p><p><pre><code>my %h = :42foo, :70bar;\nsay    %h{one &lt;foo meow&gt;}:exists; # OUTPUT: «one(True, False)␤»\nsay so %h{one &lt;foo meow&gt;}:exists; # OUTPUT: «True␤»\nsay    %h{one &lt;foo  bar&gt;}:exists; # OUTPUT: «one(True, True)␤»\nsay so %h{one &lt;foo  bar&gt;}:exists; # OUTPUT: «False␤»</code></pre></p><p>Note that the compiler is allowed, but not required, to parallelize autothreading (and Junction behavior in general), so it is usually an error to autothread junctions over code with side effects.</p><p>Autothreading implies that the function that's autothreaded will also return a Junction of the values that it would usually return.</p><p><pre><code>(1..3).head( 2|3 ).say; # OUTPUT: «any((1 2), (1 2 3))␤»</code></pre></p><p>Since .head returns a list, the autothreaded version returns a Junction of lists.</p><p><pre><code>(1..3).contains( 2&amp;3 ).say; # OUTPUT: «all(True, True)␤»</code></pre></p><p>Likewise, .contains returns a Boolean; thus, the autothreaded version returns a Junction of Booleans. In general, all methods and routines that take an argument of type T and return type TT, will also accept junctions of T, returning junctions of TT.</p><p>Implementations are allowed to short-circuit Junctions. For example one or more routine calls (a(), b(), or c()) in the code below might not get executed at all, if the result of the conditional has been fully determined from routine calls already performed (only one truthy return value is enough to know the entire Junction is true):</p><p><pre><code>if a() | b() | c() {\n    say \"At least one of the routines was called and returned a truthy value\"\n}\n</code></pre></p><p>Junctions are meant to be used as matchers in boolean context; introspection of junctions is not supported. If you feel the urge to introspect a junction, use a Set or a related type instead.</p><p>Usage examples:</p><p><pre><code>my @list = &lt;1 2 \"Great\"&gt;;\n@list.append(True).append(False);\nmy @bool_or_int = grep Bool|Int, @list;\n\nsub is_prime(Int $x) returns Bool {\n    # 'so' is for boolean context\n    so $x %% none(2..$x.sqrt);\n}\nmy @primes_ending_in_1 = grep &amp;is_prime &amp; / 1$ /, 2..100;\nsay @primes_ending_in_1;        # OUTPUT: «[11 31 41 61 71]␤»\n\nmy @exclude = &lt;~ .git&gt;;\nfor dir(\".\") { say .Str if .Str.ends-with(none @exclude) }</code></pre></p><p>Special care should be taken when using all with arguments that may produce an empty list:</p><p><pre><code>my @a = ();\nsay so all(@a) # True, because there are 0 False's</code></pre></p><p>To express \"all, but at least one\", you can use @a &amp;&amp; all(@a)</p><p><pre><code>my @a = ();\nsay so @a &amp;&amp; all(@a);   # OUTPUT: «False␤»</code></pre></p><p>Negated operators are special-cased when it comes to autothreading. $a !op $b is rewritten internally as !($a op $b). The outer negation collapses any junctions, so the return value always a plain Bool.</p><p><pre><code>my $word = 'yes';\nmy @negations = &lt;no none never&gt;;\nif $word !eq any @negations {\n    say '\"yes\" is not a negation';\n}</code></pre></p><p>Note that without this special-casing, an expression like $word ne any @words would always evaluate to True for non-trivial lists on one side.</p><p>For this purpose, infix:&lt;ne&gt;  counts as a negation of infix:&lt;eq&gt; .</p><p>In general it is more readable to use a positive comparison operator and a negated junction:</p><p><pre><code>my $word = 'yes';\nmy @negations = &lt;no none never&gt;;\nif $word eq none @negations {\n    say '\"yes\" is not a negation';\n}</code></pre></p>"},{"t":"Order","n":"More","k":"e"},{"k":"v","t":"Sub+{is-pure}","n":"&pair"},{"m":1,"k":"s","n":"pair","s":{"r":"Mu","p":[{"t":"Mu","n":"key"},{"n":"value","t":"Mu"}]}},{"t":"Sub+{is-pure}","k":"v","n":"&infix:«<»"},{"n":"infix:«<»","m":1,"k":"s","s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"m":1,"k":"s","n":"infix:«<»"},{"m":1,"n":"infix:«<»","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}]}},{"k":"s","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"n":"infix:«<»"},{"k":"s","s":{"p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}],"r":"Bool:D"},"m":1,"n":"infix:«<»"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Num"},{"t":"Num","n":"b"}]},"m":1,"k":"s","n":"infix:«<»"},{"k":"s","m":1,"s":{"p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}],"r":"Bool:D"},"n":"infix:«<»"},{"m":1,"s":{"r":"Bool:D","p":[{"t":"Rational","n":"a"},{"n":"b","t":"Rational"}]},"n":"infix:«<»","k":"s"},{"k":"s","s":{"p":[{"n":"a","t":"Rational"},{"n":"b","t":"Int"}],"r":"Bool:D"},"m":1,"n":"infix:«<»"},{"m":1,"s":{"p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:«<»"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}]},"n":"infix:«<»","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"DateTime"},{"t":"DateTime","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:«<»"},{"s":{"p":[{"n":"$a","t":"Date"},{"t":"Date","n":"$b"}],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«<»"},{"s":{"p":[{"n":"a","t":"Version"},{"t":"Version","n":"b"}],"r":"Mu"},"n":"infix:«<»","m":1,"k":"s"},{"m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"log2","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"log10","d":"<p><pre><code>multi sub    log10(Numeric:D  --&gt; Numeric:D)\nmulti method log10(Numeric:D: --&gt; Numeric:D)</code></pre></p><p>Calculates the logarithm to base 10. Returns NaN for negative arguments and -Inf for 0.</p>","k":"m"},{"k":"m","s":{"p":[{"n":"$n","t":"Cool"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"roots","m":0,"d":"<p><pre><code>multi method roots(Numeric:D: Int:D $n --&gt; Positional)</code></pre></p><p>Returns a list of the $n complex roots, which evaluate to the original number when raised to the $nth power.</p>"},{"n":"FatRat","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p><pre><code>method succ(Numeric:D:)</code></pre></p><p>Returns the number incremented by one (successor).</p>","m":0,"n":"succ","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"pred","k":"m"}],"t":"Numeric","k":"ro","mro":[],"d":"<p><pre><code>role Numeric { ... }</code></pre></p><p>Common role for numbers and types that can act as numbers.</p><p>Binary numeric operations return an object of the \"wider\" type:</p><p><pre><code>Int         narrowest\nRat\nFatRat\nNum\nComplex     widest\n</code></pre></p><p>So for example the product of a Rat and an Int is a Rat.</p><p>Unary operations that in pure math usually return an irrational number generally return Num in Raku.</p>","b":"C","n":"Numeric"},{"t":"Sub","n":"&circumfix:<{ }>","k":"v"},{"m":1,"n":"circumfix:<{ }>","s":{"p":[{"n":"*@elems","t":"Positional"}],"r":"Mu"},"k":"s"},{"t":"Order","n":"Same","k":"e"},{"m":[{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"a":[{"t":"Compiler","n":"$.compiler","k":"v"},{"t":"Str","n":"$.name","k":"v"},{"t":"Str","k":"v","n":"$.auth"},{"k":"v","t":"Version","n":"$.version"},{"n":"$.signature","k":"v","t":"Blob"},{"t":"Str","n":"$.desc","k":"v"}],"t":"Perl","b":"A","d":"<p><pre><code>class Perl does Systemic { }</code></pre></p><p>Built-in class for providing perl related information. Usually accessed through the $*PERL dynamic variable.</p>","k":"c","n":"Perl","mro":["Systemic","Raku"]},{"t":"Sub","n":"&uniparse","k":"v"},{"k":"s","m":1,"n":"uniparse","s":{"p":[{"n":"names","t":"Str"}],"r":"Str:D"}},{"b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"NFKC","k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"k":"m","n":"new"}],"t":"NFKC","k":"c","d":"<p><pre><code>class NFKC is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form KC. It is created by Compatibility Decomposition, followed by Canonical Composition. For more information on what this means, see Unicode TR15.</p>","n":"NFKC","mro":["Stringy","Positional[uint32]","Uni"]},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;**&gt;(Any, Any --&gt; Numeric:D) is assoc&lt;right&gt;</code></pre></p><p>The exponentiation operator coerces both arguments to Numeric and calculates the left-hand-side raised to the power of the right-hand side.</p><p>If the right-hand side is a non-negative integer and the left-hand side is an arbitrary precision type (Int, FatRat), then the calculation is carried out without loss of precision.</p><p>Unicode superscripts will behave in exactly the same way.</p><p><pre><code>sub squared( Int $num ) { $num² };\nsay squared($_) for ^5; OUTPUT: «0␤1␤4␤9␤16␤»</code></pre></p><p>It also works for sequences of several Unicode superscript numbers:</p><p><pre><code>sub twenty-second-power( Int $num ) { $num²² };\nsay twenty-second-power($_) for ^5; # OUTPUT: «0␤1␤4194304␤31381059609␤17592186044416␤»</code></pre></p>","k":"v","n":"&infix:<**>"},{"m":1,"s":{"p":[{"n":"$x?","t":"Any"}],"r":"Mu"},"n":"infix:<**>","k":"s"},{"m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"n":"infix:<**>","k":"s"},{"n":"infix:<**>","s":{"p":[{"t":"Real","n":"a"},{"t":"Real","n":"b"}],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"n":"infix:<**>","s":{"p":[{"n":"a","t":"Int"},{"t":"Int","n":"b"}],"r":"Real:D"}},{"k":"s","m":1,"s":{"p":[{"n":"$a","t":"int"},{"t":"int","n":"$b"}],"r":"int"},"n":"infix:<**>"},{"n":"infix:<**>","m":1,"s":{"p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}],"r":"Mu"},"k":"s"},{"s":{"r":"num","p":[{"n":"$a","t":"num"},{"n":"$b","t":"num"}]},"n":"infix:<**>","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"Rational","n":"a"},{"n":"b","t":"Int"}],"r":"Mu"},"n":"infix:<**>","k":"s"},{"m":1,"n":"infix:<**>","k":"s","s":{"p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}],"r":"Complex:D"}},{"s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Complex"}],"r":"Complex:D"},"n":"infix:<**>","k":"s","m":1},{"m":1,"s":{"r":"Complex:D","p":[{"t":"Complex","n":"a"},{"n":"b","t":"Real"}]},"k":"s","n":"infix:<**>"},{"t":"ProtocolFamily","n":"PF_UNIX","k":"e"},{"t":"Sub+{is-pure}","k":"v","n":"&infix:«>»"},{"k":"s","s":{"p":[{"t":"Any","n":"$?"}],"r":"Mu"},"n":"infix:«>»","m":1},{"n":"infix:«>»","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]},"k":"s"},{"n":"infix:«>»","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Real","n":"a"},{"n":"b","t":"Real"}]}},{"s":{"p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«>»"},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]},"n":"infix:«>»"},{"k":"s","m":1,"n":"infix:«>»","s":{"p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}],"r":"Bool:D"}},{"m":1,"n":"infix:«>»","s":{"p":[{"n":"$a","t":"num"},{"n":"$b","t":"num"}],"r":"Bool:D"},"k":"s"},{"n":"infix:«>»","m":1,"s":{"p":[{"n":"a","t":"Rational"},{"t":"Rational","n":"b"}],"r":"Bool:D"},"k":"s"},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"Rational","n":"a"},{"t":"Int","n":"b"}]},"n":"infix:«>»"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}]},"k":"s","n":"infix:«>»"},{"n":"infix:«>»","k":"s","m":1,"s":{"p":[{"n":"$a","t":"Instant"},{"t":"Instant","n":"$b"}],"r":"Bool:D"}},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"DateTime"},{"n":"b","t":"DateTime"}]},"n":"infix:«>»","k":"s"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"Date"},{"n":"$b","t":"Date"}]},"n":"infix:«>»","m":1,"k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Version"},{"n":"b","t":"Version"}],"r":"Mu"},"n":"infix:«>»"},{"mro":[],"t":"Scheduler","b":"C","n":"Scheduler","d":"<p><pre><code>role Scheduler {\n    has &amp;.uncaught_handler is rw\n}</code></pre></p><p>Common role for schedulers. A scheduler is a piece of code that determines which resources to use to run which task, and when.</p><p>Some operations for example on Proc::Async, Promise, Supply allow you to specify a scheduler explicitly; they generally expect those schedulers to follow the interface defined by Scheduler</p>","m":[{"k":"m","s":{"p":[{"t":"Any","n":"$exception"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"handle_uncaught","m":0},{"n":"cue","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"m":0,"n":"loads","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"}],"k":"ro","a":[{"k":"v","t":"Callable","n":"&.uncaught_handler"}]},{"n":"SIGSTOP","t":"Signal","k":"e"},{"k":"v","t":"Sub","n":"&warn"},{"k":"s","s":{"p":[{"t":"Positional","n":"*@msg"}],"r":"Mu"},"m":1,"n":"warn"},{"s":{"r":"Mu","p":[{"n":"j","t":"Junction"}]},"n":"warn","k":"s","m":1},{"t":"Range","m":[{"s":{"r":"Mu","p":[{"t":"Range","n":"$min"},{"n":"max","t":"Any"},{"n":":$excludes-min","t":"Any"},{"n":":$excludes-max","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"new","k":"m"},{"s":{"p":[{"n":"min","t":"Any"},{"t":"Range","n":"$max"},{"t":"Any","n":":$excludes-min"},{"n":":$excludes-max","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"new","m":1,"k":"m"},{"m":1,"s":{"p":[{"t":"Seq","n":"min"},{"n":"max","t":"Any"},{"t":"Any","n":":$excludes-min"},{"n":":$excludes-max","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new","k":"m"},{"k":"m","n":"new","m":1,"s":{"r":"Mu","p":[{"n":"min","t":"Any"},{"n":"max","t":"Seq"},{"t":"Any","n":":$excludes-min"},{"t":"Any","n":":$excludes-max"},{"n":"*%_","t":"Mu"}]}},{"m":1,"n":"new","s":{"p":[{"t":"Complex","n":"min"},{"t":"Any","n":"max"},{"t":"Any","n":":$excludes-min"},{"n":":$excludes-max","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":1,"n":"new","s":{"p":[{"n":"min","t":"Any"},{"t":"Complex","n":"max"},{"n":":$excludes-min","t":"Any"},{"n":":$excludes-max","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Whatever","n":"min"},{"n":"max","t":"Whatever"},{"t":"Any","n":":$excludes-min"},{"n":":$excludes-max","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"new"},{"s":{"p":[{"n":"min","t":"Whatever"},{"t":"Any","n":"max"},{"t":"Any","n":":$excludes-min"},{"t":"Any","n":":$excludes-max"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"new","m":1},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"min"},{"t":"Whatever","n":"max"},{"t":"Any","n":":$excludes-min"},{"t":"Any","n":":$excludes-max"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new"},{"m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Real","n":"min"},{"n":"$max","t":"Any"},{"n":":$excludes-min","t":"Any"},{"t":"Any","n":":$excludes-max"},{"n":"*%_","t":"Mu"}]},"n":"new"},{"m":1,"s":{"r":"Mu","p":[{"n":"min","t":"List"},{"t":"Any","n":"max"},{"t":"Any","n":":$excludes-min"},{"n":":$excludes-max","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"new","k":"m"},{"m":1,"n":"new","s":{"p":[{"t":"Match","n":"min"},{"n":"max","t":"Any"},{"n":":$excludes-min","t":"Any"},{"t":"Any","n":":$excludes-max"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":1,"s":{"p":[{"n":"min","t":"Any"},{"t":"Any","n":"max"},{"n":":$excludes-min","t":"Any"},{"n":":$excludes-max!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"new"},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"min"},{"t":"Any","n":"max"},{"t":"Any","n":":$excludes-min!"},{"t":"Any","n":":$excludes-max"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"new"},{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"min"},{"n":"max","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"new"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"excludes-min","d":"<p><pre><code>method excludes-min(Range:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the start point is excluded from the range, and False otherwise.</p><p><pre><code>say (1..5).excludes-min;                          # OUTPUT: «False␤»\nsay (1^..^5).excludes-min;                        # OUTPUT: «True␤»</code></pre></p>"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"excludes-max","k":"m","d":"<p><pre><code>method excludes-max(Range:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the end point is excluded from the range, and False otherwise.</p><p><pre><code>say (1..5).excludes-max;                          # OUTPUT: «False␤»\nsay (1^..^5).excludes-max;                        # OUTPUT: «True␤»</code></pre></p>","m":0},{"n":"infinite","d":"<p><pre><code>method infinite(Range:D: --&gt; Bool:D)</code></pre></p><p>Returns True if either end point was declared with ∞ or *.</p><p><pre><code>say (1..5).infinite;                              # OUTPUT: «False␤»\nsay (1..*).infinite;                              # OUTPUT: «True␤»</code></pre></p>","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p><pre><code>method is-int(Range:D: --&gt; Bool:D)</code></pre></p><p>Returns True if both end points are Int values.</p><p><pre><code>say ('a'..'d').is-int;                            # OUTPUT: «False␤»\nsay (1..^5).is-int;                               # OUTPUT: «True␤»\nsay (1.1..5.5).is-int;                            # OUTPUT: «False␤»</code></pre></p>","n":"is-int"},{"n":"elems","m":0,"d":"<p><pre><code>method elems(Range:D: --&gt; Numeric:D)</code></pre></p><p>Returns the number of elements in the range, e.g. when being iterated over, or when used as a List. Returns Inf if either end point was specified as Inf or *.</p><p><pre><code>say (1..5).elems;                                 # OUTPUT: «5␤»\nsay (1^..^5).elems;                               # OUTPUT: «3␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"iterator","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"d":"<p><pre><code>method flat(Range:D: --&gt; List:D)</code></pre></p><p>Generates the list of elements that the range represents.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"flat"},{"k":"m","m":0,"d":"<p><pre><code>method reverse(Range:D: --&gt; Seq:D)</code></pre></p><p>Returns a Seq where all elements that the Range represents have been reversed. Note that reversing an infinite Range won't produce any meaningful results.</p><p><pre><code>say (1^..5).reverse;                            # OUTPUT: «(5 4 3 2)␤»\nsay ('a'..'d').reverse;                         # OUTPUT: «(d c b a)␤»\nsay (1..∞).reverse;                             # OUTPUT: «(Inf Inf Inf ...)␤»\n</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"reverse"},{"k":"m","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"n":"first","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method bounds()</code></pre></p><p>Returns a list consisting of the start and end point.</p><p><pre><code>say (1..5).bounds;                                # OUTPUT: «(1 5)␤»\nsay (1^..^5).bounds;                              # OUTPUT: «(1 5)␤»</code></pre></p>","n":"bounds"},{"m":1,"d":"<p><pre><code>proto method int-bounds(|)\nmulti method int-bounds()\nmulti method int-bounds($from is rw, $to is rw --&gt; Bool:D)</code></pre></p><p>If the Range is an integer range (as indicated by is-int), then this method returns a list with the first and last value it will iterate over (taking into account excludes-min and excludes-max). Returns a Failure if it is not an integer range.</p><p><pre><code>say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\nsay (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»</code></pre></p><p>If called with (writable) arguments, these will take the values of the higher and lower bound and returns whether integer bounds could be determined from the Range:</p><p><pre><code>if (3..5).int-bounds( my $min, my $max) {\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»\n}\nelse {\n    say \"Could not determine integer bounds\";\n}</code></pre></p>","s":{"p":[{"t":"Any","n":"$from"},{"n":"$to","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"int-bounds","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"int-bounds","k":"m","m":1,"d":"<p><pre><code>proto method int-bounds(|)\nmulti method int-bounds()\nmulti method int-bounds($from is rw, $to is rw --&gt; Bool:D)</code></pre></p><p>If the Range is an integer range (as indicated by is-int), then this method returns a list with the first and last value it will iterate over (taking into account excludes-min and excludes-max). Returns a Failure if it is not an integer range.</p><p><pre><code>say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\nsay (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»</code></pre></p><p>If called with (writable) arguments, these will take the values of the higher and lower bound and returns whether integer bounds could be determined from the Range:</p><p><pre><code>if (3..5).int-bounds( my $min, my $max) {\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»\n}\nelse {\n    say \"Could not determine integer bounds\";\n}</code></pre></p>"},{"k":"m","n":"fmt","d":"<p>Defined as</p><p><pre><code>method fmt(|c)</code></pre></p><p>Returns a string where min and max in the Range have been formatted according to |c.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>say (1..2).fmt(\"Element: %d\", \",\") # OUTPUT: «Element: 1,Element: 2␤»</code></pre></p>","m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"}},{"k":"m","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"m":0,"n":"ASSIGN-POS"},{"d":"<p><pre><code>multi method roll(Range:D:         --&gt; Any:D)\nmulti method roll(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.roll, but attempts to optimize by not actually generating the list if it is not necessary.</p>","s":{"p":[{"n":"$","t":"Whatever"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"roll"},{"d":"<p><pre><code>multi method roll(Range:D:         --&gt; Any:D)\nmulti method roll(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.roll, but attempts to optimize by not actually generating the list if it is not necessary.</p>","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"roll"},{"m":1,"s":{"r":"Mu","p":[{"n":"$todo","t":"Cool"},{"n":"*%_","t":"Mu"}]},"n":"roll","d":"<p><pre><code>multi method roll(Range:D:         --&gt; Any:D)\nmulti method roll(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.roll, but attempts to optimize by not actually generating the list if it is not necessary.</p>","k":"m"},{"m":1,"d":"<p><pre><code>multi method pick(Range:D:         --&gt; Any:D)\nmulti method pick(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.pick, but attempts to optimize by not actually generating the list if it is not necessary.</p>","k":"m","n":"pick","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p><pre><code>multi method pick(Range:D:         --&gt; Any:D)\nmulti method pick(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.pick, but attempts to optimize by not actually generating the list if it is not necessary.</p>","m":1,"k":"m","s":{"r":"Mu","p":[{"n":"$","t":"Whatever"},{"n":"*%_","t":"Mu"}]},"n":"pick"},{"k":"m","m":1,"d":"<p><pre><code>multi method pick(Range:D:         --&gt; Any:D)\nmulti method pick(Range:D: $number --&gt; Seq:D)</code></pre></p><p>Performs the same function as Range.list.pick, but attempts to optimize by not actually generating the list if it is not necessary.</p>","n":"pick","s":{"r":"Mu","p":[{"t":"Cool","n":"$todo"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method Capture(Range --&gt; Capture:D)</code></pre></p><p>Returns a Capture with values of .min .max, .excludes-min, .excludes-max, .infinite, and .is-int as named arguments.</p>","n":"Capture","m":0},{"n":"push","k":"m","m":0,"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"}},{"m":0,"n":"append","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]}},{"k":"m","m":0,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"unshift"},{"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"prepend","m":0,"k":"m"},{"m":0,"k":"m","n":"shift","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"}},{"n":"pop","m":0,"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"sum","k":"m","d":"<p><pre><code>multi method sum(--&gt; Numeric:D)</code></pre></p><p>Returns the sum of all elements in the Range. Throws X::Str::Numeric if an element can not be coerced into Numeric.</p><p><pre><code>(1..10).sum                                       # 55</code></pre></p>"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method rand(Range:D --&gt; Num:D)</code></pre></p><p>Returns a pseudo-random value belonging to the range.</p><p><pre><code>say (1^..5).rand;                              # OUTPUT: «1.02405550417031␤»\nsay (0.1..0.3).rand;                           # OUTPUT: «0.2130353370062␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"rand","k":"m"},{"s":{"p":[{"t":"Any","n":"$got"},{"n":"$what?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"in-range","k":"m"},{"d":"<p><pre><code>method min(Range:D:)</code></pre></p><p>Returns the start point of the range.</p><p><pre><code>say (1..5).min;                                   # OUTPUT: «1␤»\nsay (1^..^5).min;                                 # OUTPUT: «1␤»</code></pre></p>","k":"m","n":"min","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method max(Range:D:)</code></pre></p><p>Returns the end point of the range.</p><p><pre><code>say (1..5).max;                                   # OUTPUT: «5␤»\nsay (1^..^5).max;                                 # OUTPUT: «5␤»</code></pre></p>","m":0,"n":"max"},{"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILDALL"},{"m":0,"s":{"p":[{"n":"min","t":"Any"},{"n":"max","t":"Any"},{"t":"Any","n":"excludes-min"},{"n":"excludes-max","t":"Any"},{"n":"infinite","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!SET-SELF","k":"m"},{"k":"m","n":"!reverse-iterator","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"!IS-NATIVE-INT","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0}],"d":"<p><pre><code>class Range is Cool does Iterable does Positional {}</code></pre></p><p>Ranges serve two main purposes: to generate lists of consecutive numbers or strings, and to act as a matcher to check if a number or string is within a certain range.</p><p>Ranges are constructed using one of the four possible range operators, which consist of two dots, and optionally a caret which indicates that the endpoint marked with it is excluded from the range.</p><p><pre><code>1 .. 5;  # 1 &lt;= $x &lt;= 5\n1^.. 5;  # 1 &lt;  $x &lt;= 5\n1 ..^5;  # 1 &lt;= $x &lt;  5\n1^..^5;  # 1 &lt;  $x &lt;  5</code></pre></p><p>The caret is also a prefix operator for constructing numeric ranges starting from zero:</p><p><pre><code>my $x = 10;\nsay ^$x;     # same as 0 ..^ $x.Numeric</code></pre></p><p>Iterating a range (or calling the list method) uses the same semantics as the ++ prefix and postfix operators, i.e., it calls the succ method on the start point, and then the generated elements.</p><p>Ranges always go from small to larger elements; if the start point is bigger than the end point, the range is considered empty.</p><p><pre><code>for 1..5 { .say };       # OUTPUT: «1␤2␤3␤4␤5␤»\n('a' ^..^ 'f').list;     # RESULT: «'b', 'c', 'd', 'e'»\n5 ~~ ^5;                 # RESULT: «False»\n4.5 ~~ 0..^5;            # RESULT: «True»\n(1.1..5).list;           # RESULT: «(1.1, 2.1, 3.1, 4.1)»</code></pre></p><p>Use the ... sequence operator to produce lists of elements that go from larger to smaller values, or to use offsets other than increment-by-1 and other complex cases.</p><p>Use ∞ or * (Whatever) to indicate an end point to be open-ended.</p><p><pre><code>for 1..* { .say };       # start from 1, continue until stopped\nfor 1..∞ { .say };       # the same\n</code></pre></p><p>Beware that a WhateverCode end point, instead of a plain Whatever, will go through the range operator and create another WhateverCode which returns a Range:</p><p><pre><code># A Whatever produces the 1..Inf range\nsay (1..*).^name;        # OUTPUT: «Range␤»\nsay (1..*);              # OUTPUT: «1..Inf␤»\n# Upper end point is now a WhateverCode\nsay (1..*+20).^name;     # OUTPUT: «{ ... }␤»\nsay (1..*+20).WHAT;      # OUTPUT: «(WhateverCode)␤»\nsay (1..*+20).(22);      # OUTPUT: «1..42␤»\n</code></pre></p><p>Ranges implement Positional interface, so its elements can be accessed using an index. In a case when the index given is bigger than the Range object's size, Nil object will be returned. The access works for lazy Range objects as well.</p><p><pre><code>say (1..5)[1];  # OUTPUT: «2␤»\nsay (1..5)[10]; # OUTPUT: «Nil␤»\nsay (1..*)[10]; # OUTPUT: «11␤»\n</code></pre></p>","n":"Range","k":"c","b":"C","a":[{"n":"$.min","t":"Mu","k":"v"},{"t":"Mu","n":"$.max","k":"v"},{"k":"v","t":"int","n":"$!excludes-min"},{"t":"int","k":"v","n":"$!excludes-max"},{"t":"int","n":"$!infinite","k":"v"},{"t":"int","k":"v","n":"$!is-int"}],"mro":["Positional","Iterable","Cool"]},{"t":"Signal","n":"SIGKILL","k":"e"},{"d":"<p>In this context, it acts as the list assignment operator. Its exact semantics are left to the container type on the left-hand side. See Array and Hash for common cases.</p><p>The distinction between item assignment and list assignment is determined by the parser depending on the syntax of the left-hand side.</p>","n":"&infix:<=>","k":"v","t":"Sub+{Precedence}"},{"n":"infix:<=>","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"n":"b","t":"Mu"}]}},{"n":"SIGUSR1","k":"e","t":"Signal"},{"d":"<p><pre><code>multi sub infix:&lt;eq&gt;(Any,   Any)\nmulti sub infix:&lt;eq&gt;(Str:D, Str:D)</code></pre></p><p>String equality operator.</p><p>Coerces both arguments to Str (if necessary); returns True if both are equal.</p><p>Mnemonic: equal</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<eq>","k":"v"},{"s":{"p":[{"n":"$x?","t":"Any"}],"r":"Mu"},"m":1,"n":"infix:<eq>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]},"n":"infix:<eq>","k":"s","m":1},{"m":1,"n":"infix:<eq>","k":"s","s":{"p":[{"n":"a","t":"Blob"},{"t":"Blob","n":"b"}],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}]},"n":"infix:<eq>","k":"s","m":1},{"s":{"r":"Bool:D","p":[{"t":"str","n":"$a"},{"n":"$b","t":"str"}]},"k":"s","m":1,"n":"infix:<eq>"},{"t":"Map","a":[{"t":"Mu","n":"$!storage","k":"v"}],"b":"C","mro":["Associative","Iterable","Cool"],"d":"<p><pre><code>class Map does Associative does Iterable { }</code></pre></p><p>A Map is an immutable mapping from string keys to values of arbitrary types. It serves as a base class for Hash, which is mutable.</p><p>In list context a Map behaves as a list of Pair objects.</p><p>Note that the order in which keys, values and pairs are retrieved is generally arbitrary, but the keys, values and pairs methods return them always in the same order when called on the same object.</p><p><pre><code>my %e := Map.new('a', 1, 'b', 2);\nsay %e.keys;    # can print \"a b\\n\" or \"b a\\n\";\nsay %e.values;  # prints \"1 2\\n\" if the previous line\n                # printed \"a b\\n\", \"b a\\n\" otherwise</code></pre></p><p>To retrieve a value from the Map by key, use the { } postcircumfix operator:</p><p><pre><code>my $map = Map.new('a', 1, 'b', 2);\nsay $map{'a'};      # OUTPUT: «1␤»\nsay $map{ 'a', 'b' }; # OUTPUT: «(1 2)␤»</code></pre></p><p>To check whether a given key is stored in a Map, modify the access with the :exists adverb:</p><p><pre><code>my $map = Map.new('a', 1, 'b', 2);\nmy $key = 'a';\nif $map{$key}:exists {\n    say \"$map{} has key $key\";\n}</code></pre></p><p>Being an immutable instance, it is not possible to add keys after a Map has been initialized:</p><p><pre><code>my $m = Map.new( 'a', 1, 'b', 2 );\n$m{ 'c' } = 'foo'; # WRONG!\n                   # Cannot modify an immutable Str</code></pre></p>","k":"c","m":[{"m":0,"d":"<p>Defined as:</p><p><pre><code>method elems(Map:D: --&gt; Int:D)</code></pre></p><p>Returns the number of pairs stored in the Map.</p><p><pre><code>my %map = Map.new('a', 1, 'b', 2);\nsay %map.elems; # OUTPUT: «2␤»</code></pre></p>","n":"elems","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"k":"m"},{"m":0,"n":"IterationBuffer","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"IterationBuffer:D"},"k":"m"},{"n":"List","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"List:D"},"k":"m"},{"m":0,"s":{"r":"Iterator:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"iterator"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"List:D"},"d":"<p>Defined as:</p><p><pre><code>method list(Map:D: --&gt; List:D)</code></pre></p><p>Returns a List of all keys and values in the Map.</p><p><pre><code>my $m = Map.new('a' =&gt; (2, 3), 'b' =&gt; 17);\nsay $m.list;                                      # OUTPUT: «(b =&gt; 17 a =&gt; (2 3))␤»</code></pre></p>","n":"list"},{"m":1,"k":"m","n":"STORE","s":{"p":[{"t":"Map","n":"map"},{"t":"Any","n":":$!"},{"n":":$!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Map:D"}},{"k":"m","n":"STORE","m":1,"s":{"r":"Map:D","p":[{"t":"Map","n":"map"},{"t":"Any","n":":$!"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Iterator","n":"iter"},{"t":"Any","n":":$!"},{"n":":$!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"m":1,"n":"STORE","k":"m"},{"s":{"p":[{"n":"iter","t":"Iterator"},{"t":"Any","n":":$!"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"n":"STORE","m":1,"k":"m"},{"m":1,"s":{"p":[{"t":"Any","n":"to_store"},{"n":":$!","t":"Any"},{"n":":$!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"k":"m","n":"STORE"},{"k":"m","m":1,"s":{"r":"Map:D","p":[{"t":"Any","n":"to_store"},{"n":":$!","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"STORE"},{"n":"STORE","m":1,"s":{"p":[{"t":"Any","n":"keys"},{"t":"Any","n":"values"},{"n":":$!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Map:D"},"k":"m"},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"STORE"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"Capture"},{"m":0,"k":"m","n":"fmt","s":{"r":"Str:D","p":[{"t":"Cool","n":"$format?"},{"n":"$sep?","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"hash","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"clone","k":"m"},{"n":"!STORE_MAP_FROM_ITERATOR_DECONT","s":{"r":"Map:D","p":[{"n":"iter","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0},{"s":{"p":[{"t":"Any","n":"map"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"n":"!STORE_MAP_DECONT","m":0,"k":"m"},{"n":"!STORE_MAP_FROM_MAP_DECONT","m":0,"s":{"p":[{"t":"Any","n":"map"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"k":"m"},{"s":{"r":"Map:D","p":[{"n":"map","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"!STORE_MAP"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!keys-as-str","k":"m"},{"s":{"p":[{"n":"iter","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Map:D"},"k":"m","m":0,"n":"!STORE_MAP_FROM_ITERATOR"},{"k":"m","n":"!STORE_MAP_FROM_OBJECT_HASH_DECONT","m":0,"s":{"p":[{"n":"map","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Map:D"}},{"s":{"r":"Map:D","p":[{"n":"map","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!STORE_MAP_FROM_OBJECT_HASH","m":0},{"m":0,"n":"!STORE_MAP_FROM_MAP","s":{"p":[{"t":"Any","n":"map"},{"n":"*%_","t":"Mu"}],"r":"Map:D"},"k":"m"}],"n":"Map"},{"n":"&infix:<⊂>","k":"v","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}"},{"k":"s","n":"infix:<⊂>","s":{"p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}],"r":"Bool:D"},"m":1},{"n":"infix:<⊂>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"Setty","n":"a"},{"n":"b","t":"Mixy"}]}},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}]},"k":"s","n":"infix:<⊂>"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Any"}]},"n":"infix:<⊂>","k":"s","m":1},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"t":"Mixy","n":"b"}]},"n":"infix:<⊂>","m":1,"k":"s"},{"n":"infix:<⊂>","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}]},"k":"s"},{"n":"infix:<⊂>","k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"t":"Any","n":"b"}]},"m":1},{"k":"s","s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Mixy"}],"r":"Bool:D"},"m":1,"n":"infix:<⊂>"},{"s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"k":"s","n":"infix:<⊂>","m":1},{"n":"infix:<⊂>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Any"}]}},{"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Mixy"}]},"m":1,"n":"infix:<⊂>"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"Baggy","n":"b"}]},"k":"s","m":1,"n":"infix:<⊂>"},{"n":"infix:<⊂>","s":{"p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}],"r":"Mu"},"n":"infix:<⊂>"},{"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"m":1,"n":"infix:<⊂>","k":"s"},{"k":"v","d":"<p><pre><code>multi sub infix:&lt;%%&gt;($a, $b --&gt; Bool:D)</code></pre></p><p>Divisibility operator. Returns True if $a % $b == 0.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<%%>"},{"m":1,"n":"infix:<%%>","s":{"p":[],"r":"Mu"},"k":"s"},{"n":"infix:<%%>","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$","t":"Any"}]}},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"n":"infix:<%%>"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"n":"infix:<%%>"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}]},"k":"s","m":1,"n":"infix:<%%>"},{"t":"Sub+{is-pure}","k":"v","n":"&tanh"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"n":"tanh"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Cool","n":"x"}]},"n":"tanh"},{"s":{"r":"num","p":[{"t":"num","n":"$x"}]},"n":"tanh","m":1,"k":"s"},{"b":"C","m":[{"n":"ast","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"made","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"Int","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"s":{"p":[{"n":":$orig?","t":"Any"},{"t":"Any","n":":$from?"},{"n":":$pos","t":"Any"},{"t":"Any","n":":$made"},{"n":":$shared","t":"Any"},{"t":"Any","n":":$braid"},{"t":"Any","n":":$list"},{"n":":$hash","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"BUILD","k":"s"},{"m":0,"n":"clone","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"Bool","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"m":1},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"Bool"},{"n":"prematch","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"postmatch","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"caps"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"chunks"},{"m":0,"k":"m","s":{"p":[{"n":"$replacement","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"n":"replace-with"},{"m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!sort-on-from-pos","k":"m","m":0},{"m":0,"n":"!MATCH-CAPTURES","k":"m","s":{"r":"Nil","p":[{"n":"$captures","t":"Mu"},{"t":"Mu","n":"*%_"}]}}],"a":[{"t":"List","k":"v","n":"@!list"},{"t":"Hash","n":"%!hash","k":"v"}],"k":"c","mro":["NQPMatchRole","Capture","Cool"],"t":"Match","n":"Cursor"},{"t":"Signature","a":[{"k":"v","t":"List","n":"@!params"},{"k":"v","n":"$!returns","t":"Mu"},{"k":"v","t":"int","n":"$!arity"},{"t":"Num","n":"$!count","k":"v"},{"t":"Code","n":"$!code","k":"v"}],"n":"Signature","b":"A","m":[{"n":"Capture","d":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p><pre><code>method arity(Signature:D: --&gt; Int:D)</code></pre></p><p>Returns the minimal number of positional arguments required to satisfy the signature.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"arity","m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method count(Signature:D: --&gt; Real:D)</code></pre></p><p>Returns the maximal number of positional arguments which can be bound to the signature. Returns Inf if there is a slurpy positional parameter.</p>","n":"count"},{"d":"<p><pre><code>method params(Signature:D: --&gt; Positional)</code></pre></p><p>Returns the list of Parameter objects that make up the signature.</p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"params"},{"k":"m","s":{"r":"Mu","p":[{"n":"$perl","t":"Any"},{"n":":$elide-type?","t":"Mu"},{"t":"Mu","n":"*%_"}]},"n":"!gistperl","m":0},{"n":"!SET-SELF","m":0,"s":{"p":[{"n":"@params","t":"Positional"},{"t":"Mu","n":"$returns"},{"t":"Any","n":"$arity"},{"n":"$count","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!deftype","k":"m"}],"mro":["Any"],"d":"<p><pre><code>class Signature { }</code></pre></p><p>A signature is a static description of the parameter list of a code object. That is, it describes what and how many arguments you need to pass to the code or function in order to call it.</p><p>Passing arguments to a signature binds the arguments, contained in a Capture, to the signature.</p><p> </p>","k":"c"},{"t":"Sub","k":"v","n":"&msb"},{"n":"msb","m":1,"k":"s","s":{"p":[{"t":"Int","n":"i"}],"r":"Int:D"}},{"t":"Sub","k":"v","n":"&uniprop-int"},{"m":1,"k":"s","n":"uniprop-int","s":{"r":"Mu","p":[{"n":"$str","t":"Str"},{"t":"Stringy","n":"$propname"}]}},{"s":{"p":[{"t":"Int","n":"$code"},{"n":"$propname","t":"Stringy"}],"r":"Mu"},"k":"s","m":1,"n":"uniprop-int"},{"k":"ro","t":"Encoding","mro":[],"n":"Encoding","b":"C","m":[{"n":"name","d":"<p><pre><code>method name(--&gt; Str)</code></pre></p><p>Abstract method that would return the primary name of the encoding.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str"},"k":"m","m":0},{"n":"alternative-names","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method alternative-names()</code></pre></p><p>Abstract methods that should get a list of alternative names for the encoding.</p>","k":"m"},{"n":"encoder","m":0,"k":"m","s":{"p":[{"n":"*%options","t":"Associative"}],"r":"Encoding::Encoder"}},{"m":0,"d":"<p><pre><code>method decoder(*%options --&gt; Encoding::Decoder)</code></pre></p><p>Should get a character decoder instance for this encoding, configured with the provided options. Options vary by encoding. The built-in encodings all support translate-nl, which if True will translate \\r\\n into \\n while decoding.</p>","k":"m","s":{"r":"Encoding::Decoder","p":[{"t":"Associative","n":"*%options"}]},"n":"decoder"}],"d":"<p><pre><code>role Encoding { ... }</code></pre></p><p>The Encoding role is implemented by classes that provide a character encoding, such as ASCII or UTF-8. Besides being used by the built-in character encodings, it may also be implemented by users to provide new encodings. Instances of objects doing this role are typically obtained using Encoding::Registry. For a list of supported encodings, see IO::Handle.</p><p>All methods provided by this role are stubs; they should be implemented by consumers of the role.</p>"},{"b":"C","m":[{"n":"add-bytes","m":0,"s":{"r":"Nil","p":[{"n":"$bytes","t":"Blob"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"consume-available-chars","m":0},{"m":0,"n":"consume-all-chars","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"m":0,"s":{"p":[{"n":"$chars","t":"int"},{"t":"Bool","n":":$eof?"},{"t":"Mu","n":"*%_"}],"r":"Str"},"n":"consume-exactly-chars","k":"m"},{"m":0,"s":{"p":[{"t":"Positional","n":"@seps"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"set-line-separators","k":"m"},{"k":"m","s":{"p":[{"t":"Bool","n":":$chomp?"},{"t":"Bool","n":":$eof?"},{"t":"Mu","n":"*%_"}],"r":"Str"},"m":0,"n":"consume-line-chars"},{"m":0,"s":{"r":"Bool","p":[{"t":"Mu","n":"*%_"}]},"n":"is-empty","k":"m"},{"m":0,"k":"m","n":"bytes-available","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"s":{"r":"Blob","p":[{"n":"$bytes","t":"int"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"consume-exactly-bytes","m":0}],"t":"Encoding::Decoder","k":"ro","mro":[],"n":"Encoding::Decoder"},{"mro":["Encoding::Decoder","Any"],"b":"A","t":"Encoding::Decoder::Builtin","k":"c","m":[{"n":"new","k":"m","s":{"r":"Mu","p":[{"t":"str","n":"$encoding"},{"t":"Any","n":":$translate-nl"},{"n":":$replacement","t":"Any"},{"t":"Any","n":":$strict"},{"n":"*%_","t":"Mu"}]},"m":0},{"n":"add-bytes","m":0,"s":{"p":[{"t":"Blob","n":"$bytes"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":0,"n":"consume-available-chars"},{"m":0,"n":"consume-all-chars","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"}},{"s":{"r":"Str","p":[{"n":"$chars","t":"int"},{"n":":$eof?","t":"Bool"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"consume-exactly-chars","k":"m"},{"m":0,"s":{"p":[{"t":"Positional","n":"@seps"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m","n":"set-line-separators"},{"n":"consume-line-chars","s":{"p":[{"n":":$chomp?","t":"Bool"},{"t":"Bool","n":":$eof?"},{"t":"Mu","n":"*%_"}],"r":"Str"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is-empty"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"bytes-available"},{"n":"consume-exactly-bytes","s":{"r":"Blob","p":[{"n":"$bytes","t":"int"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0}],"n":"Encoding::Decoder::Builtin"},{"n":"Encoding::Registry","t":"Encoding::Registry","b":"A","d":"<p><pre><code>class Encoding::Registry {}</code></pre></p><p>Encoding::Registry is initialized with a list of encoding that is available for any Raku application, namely:</p>* <p>utf8</p><br>* <p>utf8-c8</p><br>* <p>utf16</p><br>* <p>utf16le</p><br>* <p>utf16be</p><br>* <p>utf32, utf-32</p><br>* <p>ascii</p><br>* <p>iso-8859-1, iso_8859-1:1987, iso_8859-1, iso-ir-100, latin1, latin-1, csisolatin1, l1, ibm819, cp819</p><br>* <p>windows-1251</p><br>* <p>windows-1252</p><br>* <p>windows-932</p><br>","mro":["Any"],"k":"c","m":[{"m":0,"k":"m","s":{"p":[{"n":"$enc","t":"Encoding"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"register"},{"n":"find","s":{"p":[{"n":"$name","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"}]},{"t":"Encoding::Encoder","mro":[],"m":[{"k":"m","n":"encode-chars","m":0,"s":{"p":[{"t":"Str","n":"$"},{"t":"Mu","n":"*%_"}],"r":"Blob:D"}}],"n":"Encoding::Encoder","k":"ro","b":"C"},{"b":"A","t":"Encoding::Encoder::Builtin","mro":["Encoding::Encoder","Any"],"k":"c","n":"Encoding::Encoder::Builtin","a":[{"t":"str","k":"v","n":"$!encoding"},{"k":"v","t":"Blob","n":"$!type"},{"k":"v","n":"$!replacement","t":"Mu"},{"n":"$!config","t":"int","k":"v"}],"m":[{"n":"new","m":0,"k":"m","s":{"p":[{"n":"$encoding","t":"Str"},{"n":"$type","t":"Blob"},{"t":"Any","n":":$replacement"},{"n":":$strict","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Blob:D","p":[{"n":"$str","t":"str"},{"n":"*%_","t":"Mu"}]},"n":"encode-chars","m":0},{"s":{"p":[{"n":"$encoding","t":"Any"},{"n":"$type","t":"Any"},{"t":"Any","n":":$replacement"},{"t":"Any","n":":$strict"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"!setup","m":0}]},{"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"$delegate","t":"Encoding::Encoder"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"new"},{"s":{"p":[{"n":"$str","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"Blob:D"},"k":"m","n":"encode-chars","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Encoding::Encoder","n":"$delegate"},{"t":"Mu","n":"*%_"}]},"n":"!setup"}],"b":"A","t":"Encoding::Encoder::TranslateNewlineWrapper","n":"Encoding::Encoder::TranslateNewlineWrapper","a":[{"n":"$!delegate","t":"Encoding::Encoder","k":"v"}],"k":"c","mro":["Encoding::Encoder","Any"]},{"n":"Encoding::Builtin","b":"A","a":[{"n":"$.name","t":"Str","k":"v"},{"t":"Mu","n":"$!alternative-names","k":"v"}],"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"new","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"alternative-names","k":"m"},{"s":{"p":[{"t":"Any","n":":$replacement"},{"n":":$translate-nl","t":"Any"},{"t":"Any","n":":$strict"},{"n":"*%_","t":"Mu"}],"r":"Encoding::Decoder"},"n":"decoder","k":"m","m":0},{"m":0,"s":{"r":"Encoding::Encoder","p":[{"n":":$replacement","t":"Any"},{"t":"Any","n":":$translate-nl"},{"t":"Any","n":":$strict"},{"t":"Mu","n":"*%_"}]},"n":"encoder","k":"m"},{"m":0,"n":"name","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"s","m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"!buf-type","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"n":"!rep-char","s":{"p":[{"t":"Any","n":"$replacement"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0}],"mro":["Encoding","Any"],"t":"Encoding::Builtin"},{"k":"v","d":"<p><pre><code>multi sub postfix:&lt;++&gt;($x is rw) is assoc&lt;non&gt;</code></pre></p><p>Increments its argument by one and returns the original value.</p><p><pre><code>my $x = 3;\nsay $x++;   # OUTPUT: «3␤»\nsay $x;     # OUTPUT: «4␤»</code></pre></p><p>It works by calling the succ method (for successor) on its argument, which gives custom types the freedom to implement their own increment semantics.</p><p>Note that this does not necessarily return its argument; e.g., for undefined values, it returns 0:</p><p><pre><code>my $x;\nsay $x++;   # OUTPUT: «0␤»\nsay $x;     # OUTPUT: «1␤»</code></pre></p><p>Increment on Str will increment the number part of a string and assign the resulting string to the container. A is rw-container is required.</p><p><pre><code>my $filename = \"somefile-001.txt\";\nsay $filename++ for 1..3;\n# OUTPUT: «somefile-001.txt␤somefile-002.txt␤somefile-003.txt␤»</code></pre></p>","n":"&postfix:<++>","t":"Sub+{Precedence}"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"Mu"}]},"n":"postfix:<++>"},{"m":1,"s":{"p":[{"n":"$a","t":"Mu"}],"r":"Mu"},"k":"s","n":"postfix:<++>"},{"k":"s","m":1,"n":"postfix:<++>","s":{"r":"Int:D","p":[{"t":"Int","n":"$a"}]}},{"n":"postfix:<++>","k":"s","s":{"p":[{"t":"int","n":"$a"}],"r":"int"},"m":1},{"m":1,"s":{"p":[{"n":"$a","t":"Bool"}],"r":"Bool"},"k":"s","n":"postfix:<++>"},{"m":1,"s":{"p":[{"t":"Bool","n":"$a"}],"r":"Mu"},"n":"postfix:<++>","k":"s"},{"m":1,"n":"postfix:<++>","s":{"p":[{"t":"Num","n":"$a"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"n":"postfix:<++>","s":{"r":"Num","p":[{"t":"Num","n":"$a"}]}},{"s":{"r":"num","p":[{"n":"$a","t":"num"}]},"m":1,"n":"postfix:<++>","k":"s"},{"d":"<p><pre><code>sub infix:&lt;,&gt;(*@a --&gt; List:D) is assoc&lt;list&gt;</code></pre></p><p>Constructs a higher-order Cool from its arguments.</p><p><pre><code>my @list = :god('Þor'), ['is',\"mighty\"];\nsay @list;      # OUTPUT: «[god =&gt; Þor [is mighty]]␤»\nmy %hash = :god('Þor'), :is(\"mighty\");\nsay %hash.perl; # OUTPUT: «{:god(\"Þor\"), :is(\"mighty\")}␤»\nmy %a = :11a, :22b;\nsay %(%a, :33x);  # OUTPUT: «{a =&gt; 11, b =&gt; 22, x =&gt; 33}␤»</code></pre></p><p>In the first case it returns a List, in the second case, since the arguments are Pairs, it builds a Hash.</p><p>It can also be used for constructing variables from other variables, collating elements of different types, in this case a Hash and a Pair:</p><p><pre><code>my %features = %hash, :wields(\"hammer\");\nsay %features;  # OUTPUT: «{god =&gt; Þor, is =&gt; mighty, wields =&gt; hammer}␤»\n</code></pre></p><p>The comma is also used syntactically as the separator of arguments in calls.</p>","k":"v","n":"&infix:<,>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":[],"r":"List:D"},"k":"s","m":1,"n":"infix:<,>"},{"n":"infix:<,>","s":{"r":"List:D","p":[{"n":"a","t":"Slip"},{"t":"Slip","n":"b"}]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Slip"}],"r":"List:D"},"n":"infix:<,>"},{"k":"s","m":1,"s":{"r":"List:D","p":[{"t":"Slip","n":"a"},{"t":"Any","n":"b"}]},"n":"infix:<,>"},{"n":"infix:<,>","m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"List:D"}},{"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"n":"infix:<,>","k":"s","m":1},{"t":"Sub+{Callable[Nil]}","n":"&emit","k":"v"},{"n":"emit","k":"s","m":0,"s":{"r":"Nil","p":[{"t":"Mu","n":"value"}]}},{"mro":[],"n":"Associative","d":"<p><pre><code>role Associative[::TValue = Mu, ::TKey = Str(Any)] { }</code></pre></p><p>A common role for types that support name-based lookup through postcircumfix:&lt;{ }&gt;, for example Hash and Map. It is used for type checks in operators that expect to find specific methods to call. See Subscripts for details.</p><p>The % sigil restricts variables to objects that do Associative, so you will have to mix in that role if you want to use it for your classes.</p><p><pre><code>class Whatever {};\nmy %whatever := Whatever.new;\n# OUTPUT: «Type check failed in binding; expected Associative but got Whatever\n</code></pre></p><p>Please note that we are using binding := here, since by default % assignments expect a Hash in the right-hand side. However, with the Associative role:</p><p><pre><code>class Whatever is Associative {};\nmy %whatever := Whatever.new;</code></pre></p><p>will be syntactically correct.</p>","t":"Associative","k":"ro","m":[{"d":"<p>Defined as:</p><p><pre><code>method of()</code></pre></p><p>Associative is actually a parameterized role which can use different classes for keys and values. As seen at the top of the document, by default it coerces to Str for the key and uses a very generic Mu for value.</p><p><pre><code>my %any-hash;\nsay %any-hash.of;#  OUTPUT: «(Mu)␤»</code></pre></p><p>The value is the first parameter you use when instantiating Associative with particular classes:</p><p><pre><code>class DateHash is Hash does Associative[Cool,DateTime] {};\nmy %date-hash := DateHash.new;\nsay %date-hash.of; # OUTPUT: «(Cool)␤»</code></pre></p>","m":0,"k":"m","n":"of","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method keyof()</code></pre></p><p>Returns the parameterized key used for the Associative role, which is Any coerced to Str by default. This is the class used as second parameter when you use the parameterized version of Associative.</p><p><pre><code>my %any-hash;\n%any-hash.keyof; #OUTPUT: «(Str(Any))␤»</code></pre></p>","m":0,"k":"m","n":"keyof"}],"b":"C"},{"t":"StringyEnumeration","n":"StringyEnumeration","mro":[],"k":"ro","b":"C"},{"mro":["Associative","Iterable","Hash"],"b":"C","n":"Stash","m":[{"m":0,"s":{"p":[{"n":"$key","t":"str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"package_at_key","k":"m"},{"n":"merge-symbols","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Hash","n":"$globalish"},{"t":"Mu","n":"*%_"}]}}],"d":"<p><pre><code>class Stash is Hash { }</code></pre></p><p>A Stash is a hash that is used for symbol tables at the package scoping level in Raku.</p><p>To get a Stash, you can call the .WHO pseudo-method on a package (because it answers the question who lives here?), or if you write the package name as a literal, append two colons:</p><p><pre><code>class Boring {\n    class Nested { };\n    our sub package_sub { }\n    my sub lexical { };\n    method a_method() { }\n}\nsay Boring::.^name;             # OUTPUT: «Stash␤»\nsay Boring.WHO === Boring::;    # OUTPUT: «True␤»</code></pre></p><p>Since it inherits from Hash, you can use all the usual hash functionality:</p><p><pre><code>say Boring::.keys.sort;         # OUTPUT: «(&amp;package_sub Nested)␤»\nsay Boring::&lt;Nested&gt;;           # OUTPUT: «(Nested)␤»\n</code></pre></p><p>As the example above shows only \"our\"-scoped things appear in the Stash (nested classes are \"our\" by default, but can be excluded with \"my\".) Lexicals and methods are not included in a Stash, since they do not live in the package table. Lexicals live in a separate lexical pad, which is only visible from inside the scope. Methods (in the case that the package is also a class) have a separate method table, and are accessible through introspection on the class itself, via .can and .^methods.</p>","k":"c","a":[{"t":"str","k":"v","n":"$!longname"},{"t":"Mu","n":"$!descriptor","k":"v"},{"n":"$!storage","k":"v","t":"Mu"}],"t":"Stash"},{"m":[{"d":"<p><pre><code>method self(--&gt; Mu)</code></pre></p><p>Returns the object it is called on.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"self"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"sink","k":"m"},{"n":"perl","m":1,"k":"m","d":"<p><pre><code>multi method perl(--&gt; Str)</code></pre></p><p>Returns a Perlish representation of the object (i.e., can usually be re-evaluated with EVAL to regenerate the object). The exact output of perl is implementation specific, since there are generally many ways to write a Perl expression that produces a particular value.</p>","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]}},{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"m":0,"n":"perlseen"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"topic"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"ACCEPTS","d":"<p><pre><code>multi method ACCEPTS(Mu:U: $other)</code></pre></p><p>ACCEPTS is the method that smartmatching with the infix ~~ operator and given/when invokes on the right-hand side (the matcher).</p><p>The Mu:U multi performs a type check. Returns True if $other conforms to the invocant (which is always a type object or failure).</p><p><pre><code>say 42 ~~ Mu;           # OUTPUT: «True␤»\nsay 42 ~~ Int;          # OUTPUT: «True␤»\nsay 42 ~~ Str;          # OUTPUT: «False␤»</code></pre></p><p>Note that there is no multi for defined invocants; this is to allow autothreading of junctions, which happens as a fallback mechanism when no direct candidate is available to dispatch to.</p>","m":1},{"n":"ACCEPTS","d":"<p><pre><code>multi method ACCEPTS(Mu:U: $other)</code></pre></p><p>ACCEPTS is the method that smartmatching with the infix ~~ operator and given/when invokes on the right-hand side (the matcher).</p><p>The Mu:U multi performs a type check. Returns True if $other conforms to the invocant (which is always a type object or failure).</p><p><pre><code>say 42 ~~ Mu;           # OUTPUT: «True␤»\nsay 42 ~~ Int;          # OUTPUT: «True␤»\nsay 42 ~~ Str;          # OUTPUT: «False␤»</code></pre></p><p>Note that there is no multi for defined invocants; this is to allow autothreading of junctions, which happens as a fallback mechanism when no direct candidate is available to dispatch to.</p>","s":{"p":[{"n":"topic","t":"Junction"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"n":"WHERE","d":"<p><pre><code>method WHERE(--&gt; Int)</code></pre></p><p>Returns an Int representing the memory address of the object.</p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"ValueObjAt:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"WHICH","m":1,"d":"<p><pre><code>multi method WHICH(--&gt; ObjAt:D)</code></pre></p><p>Returns an object of type ObjAt which uniquely identifies the object. Value types override this method which makes sure that two equivalent objects return the same return value from WHICH.</p><p><pre><code>say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»</code></pre></p>"},{"m":1,"n":"WHICH","s":{"r":"ObjAt:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>multi method WHICH(--&gt; ObjAt:D)</code></pre></p><p>Returns an object of type ObjAt which uniquely identifies the object. Value types override this method which makes sure that two equivalent objects return the same return value from WHICH.</p><p><pre><code>say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»</code></pre></p>","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"d":"<p>Defined as:</p><p><pre><code>method iterator(--&gt; Iterator)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses iterator on it.</p><p><pre><code>my $it = Mu.iterator;\nsay $it.pull-one; # OUTPUT: «(Mu)␤»\nsay $it.pull-one; # OUTPUT: «IterationEnd␤»</code></pre></p>","k":"m","n":"iterator"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method emit()</code></pre></p><p>Emits the invocant into the enclosing supply or react block.</p><p><pre><code>react { whenever supply { .emit for \"foo\", 42, .5 } {\n    say \"received {.^name} ($_)\";\n}}\n\n# OUTPUT:\n# received Str (foo)\n# received Int (42)\n# received Rat (0.5)</code></pre></p>","n":"emit","k":"m"},{"d":"<p><pre><code>sub take(\\item)</code></pre></p><p>Takes the given item and passes it to the enclosing gather block.</p><p><pre><code>#| randomly select numbers for lotto\nmy $num-selected-numbers = 6;\nmy $max-lotto-numbers = 49;\ngather for ^$num-selected-numbers {\n    take (1 .. $max-lotto-numbers).pick(1);\n}.say;    # six random values</code></pre></p>","k":"m","n":"take","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"return-rw","d":"<p>Same as method return except that return-rw returns a writable container to the invocant (see more details here: return-rw).</p>","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]}},{"m":0,"d":"<p><pre><code>method return()</code></pre></p><p>The method return will stop execution of a subroutine or method, run all relevant phasers and provide invocant as a return value to the caller. If a return type constraint is provided it will be checked unless the return value is Nil. A control exception is raised and can be caught with CONTROL.</p><p><pre><code>sub f { (1|2|3).return };\nsay f(); # OUTPUT: «any(1, 2, 3)␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"n":"return","k":"m"},{"n":"WHY","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":1,"d":"<p><pre><code>multi method WHY(--&gt; Pod::Block::Declarator)</code></pre></p><p>Returns the attached Pod::Block::Declarator.</p><p>For instance:</p><p><pre><code>#| Initiate a specified spell normally\nsub cast(Spell $s) {\n  do-raw-magic($s);\n}\n#= (do not use for class 7 spells)\nsay &amp;cast.WHY;\n# OUTPUT: «Initiate a specified spell normally␤(do not use for class 7 spells)␤»\n</code></pre></p><p>See Pod declarator blocks for details about attaching Pod to variables, classes, functions, methods, etc.</p>"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$why","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"set_why"},{"d":"<p><pre><code>multi sub    Bool(Mu --&gt; Bool:D)\nmulti method Bool(   --&gt; Bool:D)</code></pre></p><p>Returns False on the type object, and True otherwise.</p><p>Many built-in types override this to be False for empty collections, the empty string or numerical zeros</p><p><pre><code>say Mu.Bool;                    # OUTPUT: «False␤»\nsay Mu.new.Bool;                # OUTPUT: «True␤»\nsay [1, 2, 3].Bool;             # OUTPUT: «True␤»\nsay [].Bool;                    # OUTPUT: «False␤»\nsay %( hash =&gt; 'full' ).Bool;   # OUTPUT: «True␤»\nsay {}.Bool;                    # OUTPUT: «False␤»\nsay \"\".Bool;                    # OUTPUT: «False␤»\nsay 0.Bool;                     # OUTPUT: «False␤»\nsay 1.Bool;                     # OUTPUT: «True␤»\nsay \"0\".Bool;                   # OUTPUT: «True␤»</code></pre></p>","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"Bool","k":"m"},{"m":1,"n":"Bool","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>multi sub    Bool(Mu --&gt; Bool:D)\nmulti method Bool(   --&gt; Bool:D)</code></pre></p><p>Returns False on the type object, and True otherwise.</p><p>Many built-in types override this to be False for empty collections, the empty string or numerical zeros</p><p><pre><code>say Mu.Bool;                    # OUTPUT: «False␤»\nsay Mu.new.Bool;                # OUTPUT: «True␤»\nsay [1, 2, 3].Bool;             # OUTPUT: «True␤»\nsay [].Bool;                    # OUTPUT: «False␤»\nsay %( hash =&gt; 'full' ).Bool;   # OUTPUT: «True␤»\nsay {}.Bool;                    # OUTPUT: «False␤»\nsay \"\".Bool;                    # OUTPUT: «False␤»\nsay 0.Bool;                     # OUTPUT: «False␤»\nsay 1.Bool;                     # OUTPUT: «True␤»\nsay \"0\".Bool;                   # OUTPUT: «True␤»</code></pre></p>"},{"k":"m","n":"so","d":"<p><pre><code>method so()</code></pre></p><p>Evaluates the item in boolean context (and thus, for instance, collapses Junctions), and returns the result. It is the opposite of not, and equivalent to the ? operator.</p><p>One can use this method similarly to the English sentence: \"If that is so, then do this thing\". For instance,</p><p><pre><code>my @args = &lt;-a -e -b -v&gt;;\nmy $verbose-selected = any(@args) eq '-v' | '-V';\nif $verbose-selected.so {\n    say \"Verbose option detected in arguments\";\n} # OUTPUT: «Verbose option detected in arguments␤»</code></pre></p><p>The $verbose-selected variable in this case contains a Junction, whose value is any(any(False, False), any(False, False), any(False, False), any(True, False)). That is actually a truish value; thus, negating it will yield False. The negation of that result will be True. so is performing all those operations under the hood.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"not","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Declared as</p><p><pre><code>multi sub defined(Mu --&gt; Bool:D)</code></pre></p><p>invokes the .defined method on the object and returns its result.</p>","m":1,"n":"defined","s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"k":"m","d":"<p>Declared as</p><p><pre><code>multi sub defined(Mu --&gt; Bool:D)</code></pre></p><p>invokes the .defined method on the object and returns its result.</p>","s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"n":"defined","m":1},{"n":"new","k":"m","s":{"p":[{"n":"*%attrinit","t":"Associative"}],"r":"Mu"},"d":"<p><pre><code>multi method new(*%attrinit)\nmulti method new($, *@)</code></pre></p><p>Default method for constructing (create + initialize) new objects of a class. This method expects only named arguments which are then used to initialize attributes with accessors of the same name.</p><p>Classes may provide their own new method to override this default.</p><p>new triggers an object construction mechanism that calls submethods named BUILD in each class of an inheritance hierarchy, if they exist. See the documentation on object construction for more information.</p>","m":1},{"k":"m","s":{"p":[{"n":"$","t":"Any"},{"n":"*@","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>multi method new(*%attrinit)\nmulti method new($, *@)</code></pre></p><p>Default method for constructing (create + initialize) new objects of a class. This method expects only named arguments which are then used to initialize attributes with accessors of the same name.</p><p>Classes may provide their own new method to override this default.</p><p>new triggers an object construction mechanism that calls submethods named BUILD in each class of an inheritance hierarchy, if they exist. See the documentation on object construction for more information.</p>","m":1,"n":"new"},{"m":1,"s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"n":"is-lazy","k":"m"},{"n":"CREATE","k":"m","d":"<p><pre><code>method CREATE(--&gt; Mu:D)</code></pre></p><p>Allocates a new object of the same type as the invocant, without initializing any attributes.</p><p><pre><code>say Mu.CREATE.defined;  # OUTPUT: «True␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"n":"bless","k":"m","d":"<p><pre><code>method bless(*%attrinit --&gt; Mu:D)</code></pre></p><p>Low-level object construction method, usually called from within new, implicitly from the default constructor, or explicitly if you create your own constructor. bless creates a new object of the same type as the invocant, using the named arguments to initialize attributes and returns the created object.</p><p>It is usually invoked within custom new method implementations:</p><p><pre><code>class Point {\n    has $.x;\n    has $.y;\n    multi method new($x, $y) {\n        self.bless(:$x, :$y);\n    }\n}\nmy $p = Point.new(-1, 1);\n</code></pre></p><p>In this case we are declaring new as a multi method so that we can still use the default constructor like this: Point.new( x =&gt; 3, y =&gt; 8 ). In this case we are declaring this new method simply to avoid the extra syntax of using pairs when creating the object. self.bless returns the object, which is in turn returned by new.</p><p>However, in general, implementing a customized new method might not be the best way of initializing a class, even more so if the default constructor is disabled, since it can make it harder to correctly initialize the class from a subclass. For instance, in the above example, the new implementation takes two positional arguments that must be passed from the subclass to the superclass in the exact order. That is not a real problem if it's documented, but take into account bless will eventually be calling BUILD in the class that is being instantiated. This might result in some unwanted problems, like having to create a BUILD submethod to serve it correctly:</p><p><pre><code>class Point {\n    has Int $.x;\n    has Int $.y;\n    multi method new($x, $y) {\n        self.bless(:$x, :$y);\n    }\n}\n\nclass Point-with-ID is Point {\n    has Int $.ID  is rw = 0;\n\n    submethod BUILD( *%args ) {\n        say %args;                # OUTPUT: «{x =&gt; 1, y =&gt; 2}␤»\n        for self.^attributes -&gt; $attr {\n            if $attr.Str ~~ /ID/ {\n                $attr.set_value( self, \"*\" ~ %args&lt;x&gt; ~ \"-\" ~ %args&lt;y&gt; ) ;\n            }\n        }\n    }\n}\n\nmy $p = Point-with-ID.new(1,2);\nsay $p.perl;\n# OUTPUT: «Point-with-ID.new(ID =&gt; \"*1-2\", x =&gt; 1, y =&gt; 2)␤»\n</code></pre></p><p>In this code, bless, called within Point.new, is eventually calling BUILD with the same parameters. We have to create a convoluted way of using the $.ID attribute using the metaobject protocol so that we can instantiate it and thus serve that new constructor, which can be called on Point-with-ID since it is a subclass.</p><p>We might have to use something similar if we want to instantiate superclasses. bless will help us with that, since it is calling across all the hierarchy:</p><p><pre><code>class Str-with-ID is Str {\n    my $.counter = 0;\n    has Int $.ID  is rw = 0;\n\n    multi method new( $str ) {\n        self.bless( value =&gt; $str, ID =&gt; $.counter++ );\n    }\n\n    submethod BUILD( *%args ) {\n        for self.^attributes -&gt; $attr {\n            if $attr.Str ~~ /ID/ {\n                $attr.set_value( self, %args&lt;ID&gt; ) ;\n            }\n        }\n    }\n}\n\nsay Str-with-ID.new(\"1.1,2e2\").ID;                  # OUTPUT: «0␤»\nmy $enriched-str = Str-with-ID.new(\"3,4\");\nsay \"$enriched-str, {$enriched-str.^name}, {$enriched-str.ID}\";\n# OUTPUT: «3,4, Str-with-ID, 1␤»\n</code></pre></p><p>We are enriching Str with an auto-incrementing ID. We create a new since we want to initialize it with a string and, besides, we need to instantiate the superclass. We do so using bless from within new. bless is going to call Str.BUILD. It will *capture* the value it's looking for, the pair value = $str&gt; and initialize itself. But we have to initialize also the properties of the subclass, which is why within BUILD we use the previously explained method to initialize $.ID with the value that is in the %args variable. As shown in the output, the objects will be correctly initialized with its ID, and will correctly behave as Str, converting themselves in just the string in the say statement, and including the ID property as required.</p><p>For more details see the documentation on object construction.</p>","s":{"p":[{"t":"Associative","n":"*%attrinit"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"@autovivs","t":"Positional"},{"t":"Associative","n":"%attrinit"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"},{"s":{"p":[{"t":"Associative","n":"%attrinit"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"BUILD_LEAST_DERIVED","k":"m"},{"n":"Numeric","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"Real"},{"d":"<p><pre><code>multi method Str(--&gt; Str)</code></pre></p><p>Returns a string representation of the invocant, intended to be machine readable. Method Str warns on type objects, and produces the empty string.</p><p><pre><code>say Mu.Str;   # Use of uninitialized value of type Mu in string context.\nmy @foo = [2,3,1];\nsay @foo.Str  # OUTPUT: «2 3 1␤»</code></pre></p>","k":"m","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Str"},{"d":"<p><pre><code>multi method Str(--&gt; Str)</code></pre></p><p>Returns a string representation of the invocant, intended to be machine readable. Method Str warns on type objects, and produces the empty string.</p><p><pre><code>say Mu.Str;   # Use of uninitialized value of type Mu in string context.\nmy @foo = [2,3,1];\nsay @foo.Str  # OUTPUT: «2 3 1␤»</code></pre></p>","m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Str"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"Stringy","m":1},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"Stringy"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method item(Mu \\item:) is raw</code></pre></p><p>Forces the invocant to be evaluated in item context and returns the value of it.</p><p><pre><code>say [1,2,3].item.perl;          # OUTPUT: «$[1, 2, 3]␤»\nsay %( apple =&gt; 10 ).item.perl; # OUTPUT: «${:apple(10)}␤»\nsay \"abc\".item.perl;            # OUTPUT: «\"abc\"␤»</code></pre></p>","n":"item","m":0},{"m":1,"n":"say","d":"<p><pre><code>multi method say()</code></pre></p><p>Will say to standard output.</p><p><pre><code>say 42;                 # OUTPUT: «42␤»</code></pre></p><p>What say actually does is, thus, deferred to the actual subclass. In most cases it calls .gist on the object, returning a compact string representation.</p><p>In non-sink context, say will always return True.</p><p><pre><code>say (1,[1,2],\"foo\",Mu).map: so *.say ;\n# OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»</code></pre></p><p>However, this behavior is just conventional and you shouldn't trust it for your code. It's useful, however, to explain certain behaviors.</p><p>say is first printing out in *.say, but the outermost say is printing the True values returned by the so operation.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"Any","n":"x"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"say","d":"<p><pre><code>multi method say()</code></pre></p><p>Will say to standard output.</p><p><pre><code>say 42;                 # OUTPUT: «42␤»</code></pre></p><p>What say actually does is, thus, deferred to the actual subclass. In most cases it calls .gist on the object, returning a compact string representation.</p><p>In non-sink context, say will always return True.</p><p><pre><code>say (1,[1,2],\"foo\",Mu).map: so *.say ;\n# OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»</code></pre></p><p>However, this behavior is just conventional and you shouldn't trust it for your code. It's useful, however, to explain certain behaviors.</p><p>say is first printing out in *.say, but the outermost say is printing the True values returned by the so operation.</p>"},{"d":"<p><pre><code>multi method say()</code></pre></p><p>Will say to standard output.</p><p><pre><code>say 42;                 # OUTPUT: «42␤»</code></pre></p><p>What say actually does is, thus, deferred to the actual subclass. In most cases it calls .gist on the object, returning a compact string representation.</p><p>In non-sink context, say will always return True.</p><p><pre><code>say (1,[1,2],\"foo\",Mu).map: so *.say ;\n# OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»</code></pre></p><p>However, this behavior is just conventional and you shouldn't trust it for your code. It's useful, however, to explain certain behaviors.</p><p>say is first printing out in *.say, but the outermost say is printing the True values returned by the so operation.</p>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"n":"say","k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"put","d":"<p><pre><code>multi method put(--&gt; Bool:D)</code></pre></p><p>Prints value to $*OUT, adding a newline at end, and if necessary, stringifying non-Str object using the .Str method.</p><p><pre><code>\"abc\".put;              # RESULT: «abc␤»</code></pre></p>","m":1},{"d":"<p><pre><code>multi method put(--&gt; Bool:D)</code></pre></p><p>Prints value to $*OUT, adding a newline at end, and if necessary, stringifying non-Str object using the .Str method.</p><p><pre><code>\"abc\".put;              # RESULT: «abc␤»</code></pre></p>","s":{"p":[{"t":"Any","n":"x"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"put","k":"m","m":1},{"m":1,"n":"put","d":"<p><pre><code>multi method put(--&gt; Bool:D)</code></pre></p><p>Prints value to $*OUT, adding a newline at end, and if necessary, stringifying non-Str object using the .Str method.</p><p><pre><code>\"abc\".put;              # RESULT: «abc␤»</code></pre></p>","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"m"},{"m":1,"n":"note","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":1,"n":"print","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>multi method print(--&gt; Bool:D)</code></pre></p><p>Prints value to $*OUT after stringification using .Str method without adding a newline at end.</p><p><pre><code>\"abc\\n\".print;          # RESULT: «abc␤»</code></pre></p>"},{"s":{"r":"Mu","p":[{"n":"$id","t":"Any"},{"n":"$gist","t":"Any"},{"n":"*%named","t":"Associative"}]},"n":"gistseen","m":0,"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>multi sub    gist(+args --&gt; Str)\nmulti method gist(   --&gt; Str)</code></pre></p><p>Returns a string representation of the invocant, optimized for fast recognition by humans. As such lists will be truncated at 100 elements. Use .perl to get all elements.</p><p>The default gist method in Mu re-dispatches to the perl method for defined invocants, and returns the type name in parenthesis for type object invocants. Many built-in classes override the case of instances to something more specific that may truncate output.</p><p>gist is the method that say calls implicitly, so say $something and say $something.gist generally produce the same output.</p><p><pre><code>say Mu.gist;        # OUTPUT: «(Mu)␤»\nsay Mu.new.gist;    # OUTPUT: «Mu.new␤»</code></pre></p>","k":"m","n":"gist"},{"d":"<p><pre><code>multi sub    gist(+args --&gt; Str)\nmulti method gist(   --&gt; Str)</code></pre></p><p>Returns a string representation of the invocant, optimized for fast recognition by humans. As such lists will be truncated at 100 elements. Use .perl to get all elements.</p><p>The default gist method in Mu re-dispatches to the perl method for defined invocants, and returns the type name in parenthesis for type object invocants. Many built-in classes override the case of instances to something more specific that may truncate output.</p><p>gist is the method that say calls implicitly, so say $something and say $something.gist generally produce the same output.</p><p><pre><code>say Mu.gist;        # OUTPUT: «(Mu)␤»\nsay Mu.new.gist;    # OUTPUT: «Mu.new␤»</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1,"n":"gist"},{"n":"rakuseen","k":"m","m":0,"s":{"p":[{"t":"Any","n":"$id"},{"t":"Any","n":"$perl"},{"n":"*%named","t":"Associative"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"raku","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"raku","m":1,"k":"m"},{"s":{"p":[{"n":"$type","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","d":"<p><pre><code>multi method isa(Mu $type     --&gt; Bool:D)\nmulti method isa(Str:D $type  --&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is an instance of class $type, a subset type or a derived class (through inheritance) of $type. does is similar, but includes roles.</p><p><pre><code>my $i = 17;\nsay $i.isa(\"Int\");   # OUTPUT: «True␤»\nsay $i.isa(Any);     # OUTPUT: «True␤»\nrole Truish {};\nmy $but-true = 0 but Truish;\nsay $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\nsay $but-true.does(Truish); # OUTPUT: «True␤»\nsay $but-true.isa(Truish);  # OUTPUT: «False␤»</code></pre></p>","n":"isa","m":1},{"m":1,"k":"m","d":"<p><pre><code>multi method isa(Mu $type     --&gt; Bool:D)\nmulti method isa(Str:D $type  --&gt; Bool:D)</code></pre></p><p>Returns True if the invocant is an instance of class $type, a subset type or a derived class (through inheritance) of $type. does is similar, but includes roles.</p><p><pre><code>my $i = 17;\nsay $i.isa(\"Int\");   # OUTPUT: «True␤»\nsay $i.isa(Any);     # OUTPUT: «True␤»\nrole Truish {};\nmy $but-true = 0 but Truish;\nsay $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\nsay $but-true.does(Truish); # OUTPUT: «True␤»\nsay $but-true.isa(Truish);  # OUTPUT: «False␤»</code></pre></p>","s":{"r":"Bool:D","p":[{"t":"Str","n":"$name"},{"n":"*%_","t":"Mu"}]},"n":"isa"},{"n":"does","s":{"r":"Mu","p":[{"n":"$type","t":"Mu"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method does(Mu $type --&gt; Bool:D)</code></pre></p><p>Returns True if and only if the invocant conforms to type $type.</p><p><pre><code>my $d = Date.new('2016-06-03');\nsay $d.does(Dateish);             # True    (Date does role Dateish)\nsay $d.does(Any);                 # True    (Date is a subclass of Any)\nsay $d.does(DateTime);            # False   (Date is not a subclass of DateTime)\n</code></pre></p><p>Unlike isa, which returns True only for superclasses, does includes both superclasses and roles.</p><p><pre><code>say $d.isa(Dateish); # OUTPUT: «False␤»\n</code></pre></p><p>Using the smartmatch operator ~~ is a more idiomatic alternative.</p><p><pre><code>my $d = Date.new('2016-06-03');\nsay $d ~~ Dateish;                # OUTPUT: «True␤»\nsay $d ~~ Any;                    # OUTPUT: «True␤»\nsay $d ~~ DateTime;               # OUTPUT: «False␤»</code></pre></p>","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"$name","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"can","k":"m"},{"s":{"r":"Mu","p":[{"t":"Associative","n":"*%twiddles"}]},"d":"<p><pre><code>multi method clone(Mu:U: *%twiddles)\nmulti method clone(Mu:D: *%twiddles)</code></pre></p><p>This method will clone type objects, or die if it's invoked with any argument.</p><p><pre><code>say Num.clone( :yes )\n# OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block &lt;unit&gt;␤␤»\n</code></pre></p><p>If invoked with value objects, it creates a shallow clone of the invocant, including shallow cloning of private attributes. Alternative values for public attributes can be provided via named arguments with names matching the attributes' names.</p><p><pre><code>class Point2D {\n    has ($.x, $.y);\n    multi method gist(Point2D:D:) {\n        \"Point($.x, $.y)\";\n    }\n}\n\nmy $p = Point2D.new(x =&gt; 2, y =&gt; 3);\n\nsay $p;                     # OUTPUT: «Point(2, 3)␤»\nsay $p.clone(y =&gt; -5);      # OUTPUT: «Point(2, -5)␤»\n</code></pre></p><p>Note that .clone does not go the extra mile to shallow-copy @. and %. sigiled attributes and, if modified, the modifications will still be available in the original object:</p><p><pre><code>class Foo {\n    has $.foo is rw = 42;\n    has &amp;.boo is rw = { say \"Hi\" };\n    has @.bar       = &lt;a b&gt;;\n    has %.baz       = &lt;a b c d&gt;;\n}\n\nmy $o1 = Foo.new;\nwith my $o2 = $o1.clone {\n    .foo = 70;\n    .bar = &lt;Z Y&gt;;\n    .baz = &lt;Z Y X W&gt;;\n    .boo = { say \"Bye\" };\n}\n\n# Hash and Array attribute modifications in clone appear in original as well:\nsay $o1;\n# OUTPUT: «Foo.new(foo =&gt; 42, bar =&gt; [\"Z\", \"Y\"], baz =&gt; {:X(\"W\"), :Z(\"Y\")}, …␤»\nsay $o2;\n# OUTPUT: «Foo.new(foo =&gt; 70, bar =&gt; [\"Z\", \"Y\"], baz =&gt; {:X(\"W\"), :Z(\"Y\")}, …␤»\n$o1.boo.(); # OUTPUT: «Hi␤»\n$o2.boo.(); # OUTPUT: «Bye␤»\n</code></pre></p><p>To clone those, you could implement your own .clone that clones the appropriate attributes and passes the new values to Mu.clone, for example, via nextwith.</p><p><pre><code>class Bar {\n    has $.quux;\n    has @.foo = &lt;a b&gt;;\n    has %.bar = &lt;a b c d&gt;;\n    method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n}\n\nmy $o1 = Bar.new( :42quux );\nwith my $o2 = $o1.clone {\n    .foo = &lt;Z Y&gt;;\n    .bar = &lt;Z Y X W&gt;;\n}\n\n# Hash and Array attribute modifications in clone do not affect original:\nsay $o1;\n# OUTPUT: «Bar.new(quux =&gt; 42, foo =&gt; [\"a\", \"b\"], bar =&gt; {:a(\"b\"), :c(\"d\")})␤»\nsay $o2;\n# OUTPUT: «Bar.new(quux =&gt; 42, foo =&gt; [\"Z\", \"Y\"], bar =&gt; {:X(\"W\"), :Z(\"Y\")})␤»\n</code></pre></p><p>The |%_ is needed to slurp the rest of the attributes that would have been copied via shallow copy.</p>","k":"m","m":1,"n":"clone"},{"s":{"p":[{"n":"*%twiddles","t":"Associative"}],"r":"Mu"},"m":1,"k":"m","n":"clone","d":"<p><pre><code>multi method clone(Mu:U: *%twiddles)\nmulti method clone(Mu:D: *%twiddles)</code></pre></p><p>This method will clone type objects, or die if it's invoked with any argument.</p><p><pre><code>say Num.clone( :yes )\n# OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block &lt;unit&gt;␤␤»\n</code></pre></p><p>If invoked with value objects, it creates a shallow clone of the invocant, including shallow cloning of private attributes. Alternative values for public attributes can be provided via named arguments with names matching the attributes' names.</p><p><pre><code>class Point2D {\n    has ($.x, $.y);\n    multi method gist(Point2D:D:) {\n        \"Point($.x, $.y)\";\n    }\n}\n\nmy $p = Point2D.new(x =&gt; 2, y =&gt; 3);\n\nsay $p;                     # OUTPUT: «Point(2, 3)␤»\nsay $p.clone(y =&gt; -5);      # OUTPUT: «Point(2, -5)␤»\n</code></pre></p><p>Note that .clone does not go the extra mile to shallow-copy @. and %. sigiled attributes and, if modified, the modifications will still be available in the original object:</p><p><pre><code>class Foo {\n    has $.foo is rw = 42;\n    has &amp;.boo is rw = { say \"Hi\" };\n    has @.bar       = &lt;a b&gt;;\n    has %.baz       = &lt;a b c d&gt;;\n}\n\nmy $o1 = Foo.new;\nwith my $o2 = $o1.clone {\n    .foo = 70;\n    .bar = &lt;Z Y&gt;;\n    .baz = &lt;Z Y X W&gt;;\n    .boo = { say \"Bye\" };\n}\n\n# Hash and Array attribute modifications in clone appear in original as well:\nsay $o1;\n# OUTPUT: «Foo.new(foo =&gt; 42, bar =&gt; [\"Z\", \"Y\"], baz =&gt; {:X(\"W\"), :Z(\"Y\")}, …␤»\nsay $o2;\n# OUTPUT: «Foo.new(foo =&gt; 70, bar =&gt; [\"Z\", \"Y\"], baz =&gt; {:X(\"W\"), :Z(\"Y\")}, …␤»\n$o1.boo.(); # OUTPUT: «Hi␤»\n$o2.boo.(); # OUTPUT: «Bye␤»\n</code></pre></p><p>To clone those, you could implement your own .clone that clones the appropriate attributes and passes the new values to Mu.clone, for example, via nextwith.</p><p><pre><code>class Bar {\n    has $.quux;\n    has @.foo = &lt;a b&gt;;\n    has %.bar = &lt;a b c d&gt;;\n    method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n}\n\nmy $o1 = Bar.new( :42quux );\nwith my $o2 = $o1.clone {\n    .foo = &lt;Z Y&gt;;\n    .bar = &lt;Z Y X W&gt;;\n}\n\n# Hash and Array attribute modifications in clone do not affect original:\nsay $o1;\n# OUTPUT: «Bar.new(quux =&gt; 42, foo =&gt; [\"a\", \"b\"], bar =&gt; {:a(\"b\"), :c(\"d\")})␤»\nsay $o2;\n# OUTPUT: «Bar.new(quux =&gt; 42, foo =&gt; [\"Z\", \"Y\"], bar =&gt; {:X(\"W\"), :Z(\"Y\")})␤»\n</code></pre></p><p>The |%_ is needed to slurp the rest of the attributes that would have been copied via shallow copy.</p>"},{"k":"m","n":"Capture","d":"<p>Declared as:</p><p><pre><code>method Capture(Mu:D: --&gt; Capture:D)</code></pre></p><p>Returns a Capture with named arguments corresponding to invocant's public attributes:</p><p><pre><code>class Foo {\n    has $.foo = 42;\n    has $.bar = 70;\n    method bar { 'something else' }\n}.new.Capture.say; # OUTPUT: «\\(:bar(\"something else\"), :foo(42))␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"r":"Mu","p":[{"n":"$var","t":"Any"},{"n":"c","t":"Any"}]},"m":0,"n":"dispatch:<var>","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"$name","t":"Any"},{"n":"$type","t":"Mu"},{"t":"Any","n":"c"}]},"n":"dispatch:<::>","m":0},{"n":"dispatch:<!>","m":0,"s":{"p":[{"t":"Any","n":"name"},{"t":"Mu","n":"type"},{"t":"Any","n":"c"}],"r":"Mu"},"k":"m"},{"n":"dispatch:<.=>","m":0,"s":{"r":"Mu","p":[{"n":"$name","t":"Any"},{"t":"Any","n":"c"}]},"k":"m"},{"s":{"p":[{"t":"Any","n":"$name"},{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"k":"m","n":"dispatch:<.?>"},{"m":0,"k":"m","n":"dispatch:<.+>","s":{"r":"Mu","p":[{"t":"Any","n":"name"},{"n":"c","t":"Any"}]}},{"s":{"p":[{"n":"name","t":"Any"},{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"n":"dispatch:<.*>","k":"m"},{"n":"dispatch:<hyper>","s":{"p":[{"t":"Any","n":"$nodality"},{"t":"Str","n":"$meth-name"},{"t":"Any","n":"c"}],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!default-raku"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"name"},{"t":"Capture","n":"c"},{"n":":$throw?","t":"Any"},{"n":":$reverse?","t":"Any"},{"t":"Any","n":":$roles?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!batch-call"}],"k":"c","n":"Mu","d":"<p><pre><code>class Mu { }</code></pre></p><p>The root of the Raku type hierarchy. For the origin of the name, see https://en.wikipedia.org/wiki/Mu_%28negative%29. One can also say that there are many undefined values in Raku, and Mu is the most undefined value.</p><p>Note that most classes do not derive from Mu directly, but rather from Any.</p>","b":"M","mro":[],"t":"Mu"},{"n":"&trait_mod:<is>","t":"Sub","k":"v"},{"n":"trait_mod:<is>","s":{"p":[{"n":"$child","t":"Mu"},{"t":"Mu","n":"$parent"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"n":"child","t":"Mu"},{"t":"Mu","n":"parent"},{"n":"@subtypes","t":"Positional"}]},"k":"s"},{"k":"s","n":"trait_mod:<is>","m":1,"s":{"p":[{"t":"Mu","n":"$child"},{"t":"Any","n":":$!"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"$type"},{"n":":$!","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"s":{"p":[{"t":"Mu","n":"$type"},{"n":":$nativesize!","t":"Any"}],"r":"Mu"},"k":"s","n":"trait_mod:<is>","m":1},{"s":{"p":[{"n":"$type","t":"Mu"},{"n":":$ctype!","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"s":{"p":[{"n":"$type","t":"Mu"},{"n":":$unsigned!","t":"Any"}],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"m":1,"s":{"r":"Mu","p":[{"n":"$type","t":"Mu"},{"t":"Any","n":":$!"}]},"n":"trait_mod:<is>","k":"s"},{"m":1,"s":{"p":[{"n":"$type","t":"Mu"},{"t":"Mu","n":":$array_type!"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s"},{"s":{"r":"Mu","p":[{"n":"$type","t":"Mu"},{"n":"$parent","t":"Mu"},{"t":"Block","n":"$"}]},"n":"trait_mod:<is>","k":"s","m":1},{"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"t":"Mu","n":"$type"},{"t":"Mu","n":"$parent"},{"n":"$","t":"Hash"}]},"m":1,"k":"s"},{"m":1,"s":{"p":[{"n":"$type","t":"Mu"},{"n":"*%fail","t":"Associative"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Attribute","n":"$attr"},{"t":"Any","n":"c"}]},"k":"s","m":1,"n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$attr","t":"Attribute"},{"n":":$!","t":"Any"}]},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","m":1,"s":{"r":"Mu","p":[{"t":"Attribute","n":"$attr"},{"t":"Any","n":":$!"}]},"k":"s"},{"m":1,"n":"trait_mod:<is>","k":"s","s":{"r":"Mu","p":[{"n":"$attr","t":"Attribute"},{"n":":$required!","t":"Any"}]}},{"s":{"p":[{"t":"Attribute","n":"$attr"},{"t":"Mu","n":":$default!"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s","m":1},{"n":"trait_mod:<is>","m":1,"s":{"r":"Mu","p":[{"t":"Attribute","n":"$attr"},{"t":"Any","n":":$!"}]},"k":"s"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"t":"Attribute","n":"$attr"},{"n":":$DEPRECATED!","t":"Any"}]},"m":1,"k":"s"},{"m":1,"n":"trait_mod:<is>","k":"s","s":{"r":"Mu","p":[{"t":"Attribute","n":"$attr"},{"n":":$leading_docs!","t":"Any"}]}},{"k":"s","m":1,"n":"trait_mod:<is>","s":{"p":[{"t":"Attribute","n":"$attr"},{"t":"Any","n":":$trailing_docs!"}],"r":"Mu"}},{"m":1,"n":"trait_mod:<is>","s":{"p":[{"t":"Routine","n":"$r"},{"n":"c","t":"Any"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"t":"Any","n":":$!"}]},"n":"trait_mod:<is>","m":1,"k":"s"},{"n":"trait_mod:<is>","s":{"p":[{"n":"$r","t":"Routine"},{"t":"Any","n":":$!"}],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":[{"t":"Routine","n":"$r"},{"n":":$!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s","m":1},{"s":{"p":[{"t":"Routine","n":"$r"},{"n":":$DEPRECATED!","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"k":"s","s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"n":":$inlinable!","t":"Mu"}]},"n":"trait_mod:<is>","m":1},{"s":{"p":[{"t":"Routine","n":"$r"},{"n":":$!","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"m":1,"k":"s","n":"trait_mod:<is>","s":{"p":[{"n":"$r","t":"Routine"},{"n":":%spec!","t":"Associative"}],"r":"Mu"}},{"k":"s","n":"trait_mod:<is>","m":1,"s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"n":":&equiv!","t":"Callable"}]}},{"k":"s","m":1,"s":{"p":[{"n":"$r","t":"Routine"},{"t":"Callable","n":":&tighter!"}],"r":"Mu"},"n":"trait_mod:<is>"},{"s":{"p":[{"n":"$r","t":"Routine"},{"t":"Callable","n":":&looser!"}],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"m":1,"s":{"p":[{"n":"$r","t":"Routine"},{"n":":$assoc!","t":"Any"}],"r":"Mu"},"k":"s","n":"trait_mod:<is>"},{"s":{"p":[{"n":"$param","t":"Parameter"},{"t":"Any","n":"c"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s","m":1},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"$param","t":"Parameter"},{"t":"Any","n":":$!"}]}},{"k":"s","m":1,"s":{"p":[{"n":"$param","t":"Parameter"},{"n":":$!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","m":1,"s":{"p":[{"t":"Parameter","n":"$param"},{"n":":$!","t":"Any"}],"r":"Mu"},"k":"s"},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":[{"t":"Parameter","n":"$param"},{"t":"Any","n":":$!"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Parameter","n":"$param"},{"t":"Any","n":":$!"}]},"k":"s","m":1,"n":"trait_mod:<is>"},{"s":{"r":"Mu","p":[{"n":"$param","t":"Parameter"},{"n":":$!","t":"Any"}]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"n":"$param","t":"Parameter"},{"n":":$leading_docs!","t":"Any"}]},"m":1,"k":"s"},{"s":{"r":"Mu","p":[{"n":"$param","t":"Parameter"},{"t":"Any","n":":$trailing_docs!"}]},"k":"s","m":1,"n":"trait_mod:<is>"},{"m":1,"k":"s","n":"trait_mod:<is>","s":{"p":[{"n":"r","t":"Routine"},{"n":":$export!","t":"Any"},{"n":":$SYMBOL?","t":"Any"}],"r":"Mu"}},{"m":1,"n":"trait_mod:<is>","k":"s","s":{"p":[{"n":"type","t":"Mu"},{"n":":$export!","t":"Any"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Mu","n":"sym"},{"t":"Any","n":":$export!"},{"t":"Any","n":":$SYMBOL!"}],"r":"Mu"},"k":"s","n":"trait_mod:<is>"},{"m":1,"s":{"p":[{"n":"$r","t":"Block"},{"n":":$leading_docs!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<is>","k":"s"},{"n":"trait_mod:<is>","m":1,"s":{"r":"Mu","p":[{"t":"Block","n":"$r"},{"t":"Any","n":":$trailing_docs!"}]},"k":"s"},{"s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"n":":$leading_docs!","t":"Any"}]},"m":1,"k":"s","n":"trait_mod:<is>"},{"s":{"p":[{"t":"Routine","n":"$r"},{"t":"Any","n":":$trailing_docs!"}],"r":"Mu"},"k":"s","n":"trait_mod:<is>","m":1},{"m":1,"n":"trait_mod:<is>","s":{"p":[{"n":"$docee","t":"Mu"},{"n":":$leading_docs!","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"s","n":"trait_mod:<is>","m":1,"s":{"p":[{"t":"Mu","n":"$docee"},{"n":":$trailing_docs!","t":"Any"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"t":"Any","n":":$implementation-detail!"}]},"n":"trait_mod:<is>","k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"t":"Any","n":":$hidden-from-backtrace!"}]},"n":"trait_mod:<is>"},{"s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"n":":$hidden-from-USAGE!","t":"Any"}]},"m":1,"n":"trait_mod:<is>","k":"s"},{"s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"t":"Any","n":":$pure!"}]},"m":1,"n":"trait_mod:<is>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Routine","n":"$r"},{"n":":$nodal!","t":"Any"}]},"n":"trait_mod:<is>","k":"s","m":1},{"s":{"r":"Mu","p":[{"n":"$a","t":"Attribute"},{"t":"Any","n":":$built!"}]},"m":1,"k":"s","n":"trait_mod:<is>"},{"s":{"p":[{"n":"$v","t":"Variable"},{"n":"c","t":"Any"}],"r":"Mu"},"m":1,"n":"trait_mod:<is>","k":"s"},{"m":1,"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"t":"Variable","n":"$v"},{"n":":$default!","t":"Mu"}]},"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Variable","n":"$v"},{"n":":$dynamic!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<is>"},{"k":"s","s":{"r":"Mu","p":[{"n":"$v","t":"Variable"},{"t":"Any","n":":$export!"}]},"n":"trait_mod:<is>","m":1},{"k":"s","m":1,"n":"trait_mod:<is>","s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"n":":$equiv!","t":"Str"}]}},{"m":1,"n":"trait_mod:<is>","k":"s","s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"t":"Str","n":":$tighter!"}]}},{"s":{"r":"Mu","p":[{"n":"$r","t":"Routine"},{"n":":$looser!","t":"Str"}]},"n":"trait_mod:<is>","k":"s","m":1},{"k":"v","n":"&samecase","t":"Sub"},{"m":1,"k":"s","s":{"p":[{"n":"$string","t":"Cool"},{"t":"Cool","n":"$pattern"}],"r":"Mu"},"n":"samecase"},{"a":[{"t":"List","k":"v","n":"@!dispatchees"},{"k":"v","n":"$!dispatcher_cache","t":"Mu"},{"t":"Mu","n":"$!dispatcher","k":"v"},{"t":"int","n":"$!flags","k":"v"},{"n":"$!inline_info","k":"v","t":"Mu"},{"k":"v","n":"$!package","t":"Mu"},{"k":"v","t":"int","n":"$!onlystar"},{"k":"v","n":"@!dispatch_order","t":"List"},{"n":"$!dispatch_cache","k":"v","t":"Mu"},{"n":"$!why","t":"Mu","k":"v"},{"k":"v","n":"$!do","t":"Code"},{"t":"Signature","k":"v","n":"$!signature"},{"t":"List","n":"@!compstuff","k":"v"}],"k":"c","d":"<p><pre><code>class Submethod is Routine {}</code></pre></p><p>A Submethod is a method that is not inherited by child classes. They are typically used for per-class initialization and tear-down tasks which are called explicitly per class in an inheritance tree, usually for enforcing a particular order. For example object construction with the BUILD submethod happens from the least-derived to most-derived, so that the most-derived (child) classes can depend on the parent already being initialized.</p><p>Submethods are of type Submethod, and are declared with the submethod declarator:</p><p><pre><code>class Area {\n    has $.size;\n    submethod BUILD(:$x, :$y, :$z) {\n        $!size = $x * $y * $z;\n    }\n}</code></pre></p>","b":"A","mro":["Callable","Routine"],"n":"Submethod","t":"Submethod"},{"t":"Sub+{is-pure}","k":"v","n":"&sec"},{"m":1,"n":"sec","k":"s","s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"}},{"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"n":"sec","m":1,"k":"s"},{"n":"sec","k":"s","m":1,"s":{"r":"num","p":[{"t":"num","n":"$x"}]}},{"k":"ro","b":"C","m":[{"m":0,"s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"n":"soft","k":"m"}],"t":"HardRoutine","n":"HardRoutine","mro":[]},{"n":"ProtocolFamily","t":"ProtocolFamily","k":"e"},{"t":"ProtocolFamily","n":"ProtocolFamily::PF_UNIX","k":"e"},{"t":"ProtocolFamily","n":"ProtocolFamily::PF_MAX","k":"e"},{"n":"ProtocolFamily::PF_INET","k":"e","t":"ProtocolFamily"},{"n":"ProtocolFamily::PF_UNSPEC","t":"ProtocolFamily","k":"e"},{"n":"ProtocolFamily::PF_LOCAL","t":"ProtocolFamily","k":"e"},{"t":"ProtocolFamily","k":"e","n":"ProtocolFamily::PF_INET6"},{"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str"},"k":"m","n":"encoding"},{"s":{"p":[{"n":"action","t":"Any"},{"t":"Any","n":"to"},{"n":"from","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!unshift-list","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"action"},{"n":"i","t":"Any"},{"n":"got","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!fail-typecheck-element"},{"s":{"p":[{"t":"Any","n":"to"},{"n":"from","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"!spread"},{"s":{"r":"Mu","p":[{"n":"action","t":"Any"},{"n":"to","t":"Any"},{"t":"Any","n":"from"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!push-list"},{"s":{"p":[{"n":"$action","t":"Any"},{"t":"Any","n":"$got"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"!fail-typecheck","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$got","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!fail-range"}],"b":"A","t":"utf32","mro":["Blob[uint32]","Positional[uint32]","Stringy","Any"],"n":"utf32","k":"c"},{"k":"v","t":"Sub","n":"&nextcallee"},{"m":0,"s":{"p":[],"r":"Mu"},"n":"nextcallee","k":"s"},{"t":"Sub","n":"&unival","k":"v"},{"m":1,"n":"unival","s":{"p":[{"t":"Str","n":"$str"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"$code","t":"Int"}]},"m":1,"k":"s","n":"unival"},{"n":"Exceptions::JSON","mro":["Any"],"b":"A","m":[{"k":"m","s":{"p":[{"n":"$ex","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"process"}],"t":"Exceptions::JSON","k":"c"},{"n":"Bool","k":"e","t":"Bool"},{"t":"Bool","n":"Bool::False","k":"e"},{"k":"e","t":"Bool","n":"Bool::True"},{"b":"C","m":[{"m":0,"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"n":"Str","k":"m"}],"t":"Systemic","k":"ro","mro":[],"a":[{"t":"Str","n":"$.name","k":"v"},{"n":"$.auth","t":"Str","k":"v"},{"t":"Version","n":"$.version","k":"v"},{"n":"$.signature","t":"Blob","k":"v"},{"n":"$.desc","t":"Str","k":"v"}],"d":"<p>Built-in class for providing built system related information. Usually accessed through dynamic variables mixing this role such as the $*KERNEL, $*VM, or $*PERL.</p>","n":"Systemic"},{"t":"Sub","k":"v","n":"&trait_mod:<of>"},{"k":"s","m":1,"n":"trait_mod:<of>","s":{"r":"Mu","p":[{"n":"$target","t":"Mu"},{"t":"Mu","n":"$type"}]}},{"n":"trait_mod:<of>","s":{"r":"Mu","p":[{"n":"$target","t":"Routine"},{"t":"Mu","n":"$type"}]},"k":"s","m":1},{"t":"Sub+{Precedence}","n":"&infix:<and>","d":"<p>Same as infix &amp;&amp;, except with looser precedence.</p><p>Short-circuits so that it returns the first operand that evaluates to False, otherwise returns the last operand. Note that and is easy to misuse, see traps.</p>","k":"v"},{"s":{"p":[{"t":"Mu","n":"$x?"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<and>"},{"s":{"p":[{"n":"a","t":"Mu"},{"t":"Callable","n":"&b"}],"r":"Mu"},"m":1,"n":"infix:<and>","k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"t":"Mu","n":"b"}]},"n":"infix:<and>"},{"t":"Sub","k":"v","n":"&join"},{"n":"join","m":1,"s":{"r":"Mu","p":[{"n":"$sep?","t":"Any"},{"n":"*@values","t":"Positional"}]},"k":"s"},{"n":"&chrs","t":"Sub","k":"v"},{"k":"s","n":"chrs","m":1,"s":{"r":"Str:D","p":[{"n":"*@c","t":"Positional"}]}},{"n":"&so","k":"v","t":"Sub"},{"m":1,"n":"so","s":{"p":[{"t":"Bool","n":"$"}],"r":"Bool"},"k":"s"},{"k":"s","n":"so","m":1,"s":{"r":"Mu","p":[{"n":"x","t":"Bool"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"x"}]},"m":1,"n":"so","k":"s"},{"k":"v","n":"&acosech","t":"Sub+{is-pure}"},{"n":"acosech","s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":[{"t":"Cool","n":"x"}]},"n":"acosech","m":1,"k":"s"},{"n":"acosech","m":1,"k":"s","s":{"p":[{"n":"$x","t":"num"}],"r":"num"}},{"d":"<p><pre><code>multi sub infix:&lt;^&gt;($a, $b --&gt; Junction:D) is assoc&lt;list&gt;</code></pre></p><p>One junction operator.</p><p>Creates a one Junction from its arguments. See Junction for more details.</p>","n":"&infix:<^>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"p":[{"n":"+values","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<^>"},{"n":"&take-rw","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[]},"m":1,"n":"take-rw","k":"s"},{"n":"take-rw","k":"s","s":{"p":[{"t":"Any","n":"value"}],"r":"Mu"},"m":1},{"n":"take-rw","k":"s","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"m":1},{"t":"Signal","n":"SIGBUS","k":"e"},{"t":"Sub","n":"&run","k":"v"},{"k":"s","n":"run","m":1,"s":{"p":[{"n":"*@args","t":"Positional"},{"n":":$in?","t":"Any"},{"n":":$out?","t":"Any"},{"t":"Any","n":":$err?"},{"n":":$bin","t":"Bool"},{"n":":$chomp?","t":"Bool"},{"n":":$merge","t":"Bool"},{"t":"Str","n":":$enc"},{"t":"Str","n":":$nl?"},{"n":":$cwd?","t":"Any"},{"t":"Any","n":":$env"},{"n":":$win-verbatim-args?","t":"Any"}],"r":"Mu"}},{"b":"A","d":"<p><pre><code>class CurrentThreadScheduler does Scheduler {}\n</code></pre></p><p>CurrentThreadScheduler executes tasks on the current threads. This means that method cue blocks until the code has finished executing.</p>","n":"CurrentThreadScheduler","mro":["Scheduler","Any"],"k":"c","m":[{"s":{"r":"Mu","p":[{"n":"$exception","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"handle_uncaught","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"&code","t":"Callable"},{"t":"Any","n":":$at"},{"t":"Any","n":":$in"},{"t":"Any","n":":$every"},{"t":"Any","n":":$times?"},{"n":":&catch","t":"Callable"},{"n":"*%_","t":"Mu"}]},"n":"cue"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int"},"n":"loads","k":"m"},{"n":"uncaught_handler","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"n":"BUILDALL","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0}],"a":[{"k":"v","t":"Callable","n":"&.uncaught_handler"}],"t":"CurrentThreadScheduler"},{"n":"&move","k":"v","t":"Sub"},{"m":1,"s":{"p":[{"n":"$from","t":"Any"},{"t":"Any","n":"$to"},{"t":"Any","n":":$createonly"}],"r":"Mu"},"n":"move","k":"s"},{"d":"<p><pre><code>class Proxy {}</code></pre></p><p>A Proxy is an object that allows you to set a hook that executes whenever a value is retrieved from a container (FETCH) or when it is set (STORE). Please note that Proxy can introduce mutability at places where it would break behavior, e.g. in Hash keys.</p><p>To create a container that returns twice what was stored in it, you do something like this:</p><p><pre><code>sub double() is rw {\n    my $storage = 0;\n    Proxy.new(\n        FETCH =&gt; method ()     { $storage * 2    },\n        STORE =&gt; method ($new) { $storage = $new },\n    )\n }\n my $doubled := double();\n $doubled = 4;\n say $doubled;       # OUTPUT: «8␤»</code></pre></p>","b":"A","t":"Proxy","mro":["Any"],"k":"c","n":"Proxy"},{"t":"Sub","n":"&prepend","k":"v"},{"n":"prepend","m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Positional","n":"**@b"}]},"n":"prepend"},{"a":[{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"b":"C","t":"Baggy","m":[{"n":"of","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"new-from-pairs","s":{"p":[{"n":"*@pairs","t":"Positional"},{"t":"Mu","n":"*%_"}],"r":"Baggy:D"},"d":"<p>Defined as:</p><p><pre><code>method new-from-pairs(*@pairs --&gt; Baggy:D)</code></pre></p><p>Constructs a Baggy objects from a list of Pair objects given as positional arguments:</p><p><pre><code>say Mix.new-from-pairs: 'butter' =&gt; 0.22, 'sugar' =&gt; 0.1, 'sugar' =&gt; 0.02;\n# OUTPUT: «mix(butter(0.22), sugar(0.12))␤»</code></pre></p><p>Note: be sure you aren't accidentally passing the Pairs as positional arguments; the quotes around the keys in the above example are significant.</p>","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int"},"d":"<p>Defined as:</p><p><pre><code>method default(Baggy:D: --&gt; Int:D)</code></pre></p><p>Returns zero.</p><p><pre><code>my $breakfast = bag &lt;eggs bacon&gt;;\nsay $breakfast.default;                           # OUTPUT: «0␤»</code></pre></p>","k":"m","n":"default"},{"m":0,"s":{"r":"Mu","p":[{"n":"type","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!HASHIFY"},{"s":{"r":"Baggy:D","p":[{"n":"type","t":"Any"},{"n":"iterator","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!create-from-iterator","m":0,"k":"m"}],"k":"ro","mro":["QuantHash","Associative"],"d":"<p><pre><code>role Baggy does QuantHash { }</code></pre></p><p>A role for collections of weighted objects. See Bag, BagHash, and Mixy.</p>","n":"Baggy"},{"k":"ro","mro":[],"d":"<p><pre><code>role Positional { ... }</code></pre></p><p>Role for objects which support indexing them using postcircumfix:«[ ]» (usually list-like objects). Example types with Positional role include List, Array, Range, and Buf.</p>","m":[{"m":0,"d":"<p><pre><code>method of()</code></pre></p><p>Returns the type constraint for elements of the positional container. Defaults to Mu.</p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"of"}],"t":"Positional","n":"Positional","b":"C"},{"a":[{"t":"Mu","k":"v","n":"$!descriptor"},{"n":"$!reified","k":"v","t":"Mu"},{"k":"v","n":"$!todo","t":"Mu"}],"m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Iterator:D"},"n":"iterator","k":"m"},{"s":{"p":[{"t":"Iterator","n":"$iter"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"from-iterator","k":"m","m":0},{"s":{"p":[{"t":"Mu","n":"list"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"from-list","k":"m","m":0},{"n":"new","m":1,"s":{"p":[{"n":":$shape!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"k":"m"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Array:D"},"k":"m","n":"new"},{"n":"new","s":{"p":[{"t":"Any","n":"values"},{"n":":$shape!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"k":"m","m":1},{"s":{"r":"Array:D","p":[{"n":"values","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"new","m":1,"k":"m"},{"m":1,"n":"new","s":{"p":[{"t":"Positional","n":"**@values"},{"n":":$shape!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Array:D"},"k":"m"},{"n":"new","s":{"p":[{"n":"**@values","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Array:D"},"m":1,"k":"m"},{"m":1,"s":{"p":[{"t":"Iterable","n":"iterable"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"STORE","k":"m"},{"s":{"p":[{"t":"Mu","n":"item"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"STORE","m":1,"k":"m"},{"n":"reification-target","s":{"r":"Array::ArrayReificationTarget:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","m":0,"n":"reverse","s":{"r":"Seq:D","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"s":{"p":[{"n":"$rotate?","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Seq:D"},"n":"rotate"},{"n":"shape","s":{"r":"List:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method shape() { (*,) }</code></pre></p><p>Returns the shape of the array as a list.</p><p>Example:</p><p><pre><code>my @foo[2;3] = ( &lt; 1 2 3 &gt;, &lt; 4 5 6 &gt; ); # Array with fixed dimensions\nsay @foo.shape;                          # OUTPUT: «(2 3)␤»\nmy @bar = ( &lt; 1 2 3 &gt;, &lt; 4 5 6 &gt; );      # Normal array (of arrays)\nsay @bar.shape;                          # OUTPUT: «(*)␤»</code></pre></p>"},{"m":0,"k":"m","n":"pop","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi sub    pop(Array:D )\nmulti method pop(Array:D:)</code></pre></p><p>Removes and returns the last item from the array. Fails for an empty array.</p><p>Example:</p><p><pre><code>my @foo = &lt;a b&gt;; # a b\n@foo.pop;        # b\npop @foo;        # a\npop @foo;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Cannot::Empty: Cannot pop from an empty Array␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    shift(Array:D )\nmulti method shift(Array:D:)</code></pre></p><p>Removes and returns the first item from the array. Fails for an empty arrays.</p><p>Example:</p><p><pre><code>my @foo = &lt;a b&gt;;\nsay @foo.shift;             # OUTPUT: «a␤»\nsay @foo.shift;             # OUTPUT: «b␤»\nsay @foo.shift;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Cannot::Empty: Cannot shift from an empty Array␤»</code></pre></p>","n":"shift","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"grab","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"n":"$calculate","t":"Callable"},{"n":"*%_","t":"Mu"}]},"n":"grab","m":1},{"s":{"r":"Seq:D","p":[{"t":"Whatever","n":"$"},{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"grab"},{"k":"m","s":{"p":[{"n":"count","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"m":1,"n":"grab"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"name","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method of</code></pre></p><p>Returns the type constraint for the values of the invocant. By default, i.e. if no type constraint is given during declaration, the method returns (Mu).</p><p><pre><code>my @a1 = 1, 'two', 3.14159;              # (no type constraint specified)\nsay @a1.of;                              # OUTPUT: «(Mu)␤»\n\nmy Int @a2 = 1, 2, 3;                    # (values must be of type Int)\nsay @a2.of;                              # OUTPUT: «(Int)␤»\n@a2.push: 'd';\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to @a2; expected Int but got Str (\"d\")␤»</code></pre></p>","m":0,"n":"of"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"default","d":"<p>Defined as:</p><p><pre><code>method default</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when trying to access an element in the Array which has not been previously initialized or when accessing an element which has explicitly been set to Nil. Unless the Array is declared as having a default value by using the is default trait the method returns the type object (Any).</p><p><pre><code>my @a1 = 1, \"two\", 2.718;\nsay @a1.default;                               # OUTPUT: «(Any)␤»\nsay @a1[4];                                    # OUTPUT: «(Any)␤»\n\nmy @a2 is default(17) = 1, \"two\", 3;\nsay @a2.default;                               # OUTPUT: «17␤»\nsay @a2[4];                                    # OUTPUT: «17␤»\n@a2[1] = Nil;                                  # (resets element to its default)\nsay @a2[1];                                    # OUTPUT: «17␤»\n</code></pre></p>","k":"m"},{"k":"m","n":"dynamic","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"n":"!empty","s":{"p":[{"t":"Any","n":"$action"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"!prepend-list","s":{"p":[{"n":"@values","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Array:D"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"n":"$pos","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!AT_POS_SLOW"},{"n":"!lazy","k":"m","m":0,"s":{"p":[{"n":"$action","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"shape"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"m":0,"n":"!difficult-shape","k":"m"},{"s":{"p":[{"n":"$pos","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!AT_POS_CONTAINER","k":"m","m":0},{"k":"m","n":"!splice-size-fail","m":0,"s":{"p":[{"t":"Any","n":"$got"},{"t":"Any","n":"$offset"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$pos"},{"t":"Mu","n":"*%_"}]},"n":"!INDEX_OOR"},{"n":"!splice-offset-size","k":"m","s":{"p":[{"t":"int","n":"$offset"},{"t":"int","n":"$size"},{"n":"*%_","t":"Mu"}],"r":"Array:D"},"m":0},{"m":0,"k":"m","s":{"p":[{"t":"Positional","n":"@values"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"!append-list"},{"m":0,"s":{"r":"Array:D","p":[{"t":"int","n":"$offset"},{"n":"$size","t":"int"},{"t":"Positional","n":"@new"},{"n":"*%_","t":"Mu"}]},"n":"!splice-offset-size-new","k":"m"},{"n":"!ASSIGN_POS_SLOW_PATH","m":0,"s":{"r":"Mu","p":[{"t":"Int","n":"$pos"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"!ASSIGN_POS_FAST_PATH","m":0,"s":{"p":[{"t":"Int","n":"$pos"},{"t":"Mu","n":"assignee_decont"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"!splice-save","s":{"p":[{"n":"$offset","t":"int"},{"t":"int","n":"$size"},{"n":"removed","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Array:D"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$got"},{"n":"*%_","t":"Mu"}]},"n":"!splice-offset-fail","m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"int","n":"$offset"},{"t":"Mu","n":"*%_"}],"r":"Array:D"},"n":"!splice-offset","k":"m"}],"b":"C","mro":["Positional","Iterable","List"],"n":"Array","d":"<p><pre><code>class Array is List {}</code></pre></p><p>An Array is a List which forces all its elements to be scalar containers, which means you can assign to array elements.</p><p>Array implements Positional and as such provides support for subscripts.</p><p>Note from version 6.d, .perl can be called on multi-dimensional arrays.</p>","t":"Array","k":"c"},{"t":"Sub","n":"&lc","k":"v"},{"n":"lc","m":1,"s":{"p":[{"t":"Cool","n":"$s"}],"r":"Mu"},"k":"s"},{"a":[{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"t":"MixHash","d":"<p><pre><code>class MixHash does Mixy { }</code></pre></p><p>A MixHash is a mutable mix, meaning a collection of distinct elements in no particular order that each have a real-number weight assigned to them. (For immutable mixes, see Mix instead.)</p><p>Objects/values of any type are allowed as mix elements. Within a MixHash, items that would compare positively with the === operator are considered the same element, with a combined weight.</p><p><pre><code>my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,\n              flour =&gt; 0.275, sugar =&gt; 0.02).MixHash;\n\nsay $recipe.elems;      # OUTPUT: «3␤»\nsay $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\nsay $recipe.pairs.sort; # OUTPUT: «\"butter\" =&gt; 0.22 \"flour\" =&gt; 0.275 \"sugar\" =&gt; 0.12␤»\nsay $recipe.total;      # OUTPUT: «0.615␤»\n</code></pre></p><p>MixHashes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding numeric weight for keys that are elements of the mix, and 0 for keys that aren't. It can also be used to modify weights; Setting a weight to 0 automatically removes that element from the mix, and setting a weight to a non-zero number adds that element if it didn't already exist:</p><p><pre><code>my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,\n              flour =&gt; 0.275, sugar =&gt; 0.02).MixHash;\n\nsay $recipe&lt;butter&gt;;     # OUTPUT: «0.22␤»\nsay $recipe&lt;sugar&gt;;      # OUTPUT: «0.12␤»\nsay $recipe&lt;chocolate&gt;;  # OUTPUT: «0␤»\n\n$recipe&lt;butter&gt; = 0;\n$recipe&lt;chocolate&gt; = 0.30;\nsay $recipe.pairs;       # OUTPUT: «\"sugar\" =&gt; 0.12 \"flour\" =&gt; 0.275 \"chocolate\" =&gt; 0.3␤»\n</code></pre></p>","k":"c","b":"A","mro":["Mixy","Baggy","QuantHash","Associative","Any"],"n":"MixHash","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"total"},{"n":"clone","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"type","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!HASHIFY","m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!total-positive"},{"m":0,"s":{"p":[{"n":"type","t":"Any"},{"n":"iterator","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Baggy:D"},"n":"!create-from-iterator","k":"m"}]},{"t":"Sub","k":"v","n":"&uniprop-str"},{"n":"uniprop-str","k":"s","s":{"r":"Mu","p":[{"n":"$str","t":"Str"},{"n":"$propname","t":"Stringy"}]},"m":1},{"s":{"r":"Mu","p":[{"n":"$code","t":"Int"},{"t":"Stringy","n":"$propname"}]},"k":"s","n":"uniprop-str","m":1},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;lcm&gt;($a, $b --&gt; Int:D)</code></pre></p><p>Coerces both arguments to Int and returns the least common multiple; that is, the smallest integer that is evenly divisible by both arguments.</p>","n":"&infix:<lcm>","k":"v"},{"k":"s","n":"infix:<lcm>","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"m":1},{"n":"infix:<lcm>","s":{"p":[{"t":"Int","n":"$x?"}],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}]},"k":"s","n":"infix:<lcm>","m":1},{"k":"s","m":1,"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"},"n":"infix:<lcm>"},{"k":"e","t":"ProtocolFamily","n":"PF_INET6"},{"mro":[],"b":"C","t":"Awaiter","k":"ro","m":[{"s":{"r":"Mu","p":[{"n":"$a","t":"Awaitable"},{"t":"Mu","n":"*%_"}]},"n":"await","k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"n":"$i","t":"Iterable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"await-all"}],"n":"Awaiter"},{"n":"Awaiter::Blocking","k":"c","mro":["Awaiter","Any"],"t":"Awaiter::Blocking","b":"A","m":[{"m":0,"s":{"p":[{"n":"$a","t":"Awaitable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"await"},{"s":{"r":"Mu","p":[{"t":"Iterable","n":"i"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"await-all","m":0}]},{"d":"<p><pre><code>sub infix:&lt;x&gt;($a, $b --&gt; Str:D)</code></pre></p><p>String repetition operator.</p><p>Repeats the string $a $b times, if necessary coercing $a to Str and $b Int. Returns an empty string if $b &lt;= 0 . An exception X::Numeric::CannotConvert will be thrown if $b is -Inf or NaN.</p><p><pre><code>say 'ab' x 3;           # OUTPUT: «ababab␤»\nsay 42 x 3;             # OUTPUT: «424242␤»\n\nmy $a = 'a'.IO;\nmy $b = 3.5;\nsay $a x $b;            # OUTPUT: «aaa␤»</code></pre></p><p>List repetition operator</p>","k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<x>"},{"s":{"r":"Mu","p":[]},"n":"infix:<x>","k":"s","m":1},{"s":{"r":"Mu","p":[{"t":"Any","n":"$x"}]},"n":"infix:<x>","m":1,"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Any","n":"$s"},{"t":"Num","n":"$n"}],"r":"Mu"},"n":"infix:<x>"},{"n":"infix:<x>","s":{"r":"Mu","p":[{"n":"$s","t":"Any"},{"n":"$n","t":"Any"}]},"k":"s","m":1},{"s":{"p":[{"n":"$s","t":"Any"},{"n":"$n","t":"Any"}],"r":"Mu"},"k":"s","n":"infix:<x>","m":1},{"k":"s","m":1,"n":"infix:<x>","s":{"p":[{"n":"$s","t":"Str"},{"t":"Bool","n":"$repetition"}],"r":"Str:D"}},{"s":{"r":"Str:D","p":[{"t":"Str","n":"$s"},{"t":"Int","n":"$repetition"}]},"k":"s","m":1,"n":"infix:<x>"},{"m":1,"k":"s","s":{"p":[{"t":"str","n":"$s"},{"t":"int","n":"$repetition"}],"r":"str"},"n":"infix:<x>"},{"t":"Sub","n":"&truncate","k":"v"},{"s":{"p":[{"n":"$x","t":"Real"}],"r":"Mu"},"n":"truncate","m":1,"k":"s"},{"s":{"p":[{"n":"$x","t":"Cool"}],"r":"Mu"},"m":1,"n":"truncate","k":"s"},{"t":"Sub","n":"&rand","k":"v"},{"m":1,"s":{"p":[],"r":"Num:D"},"k":"s","n":"rand"},{"n":"&is-prime","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Int:D","p":[{"t":"Any","n":"x"}]},"k":"s","m":1,"n":"is-prime"},{"k":"v","n":"&chop","t":"Sub"},{"n":"chop","k":"s","s":{"p":[{"t":"Cool","n":"$s"}],"r":"Str:D"},"m":1},{"s":{"p":[{"t":"Cool","n":"$s"},{"n":"$n","t":"Any"}],"r":"Str:D"},"n":"chop","k":"s","m":1},{"k":"e","t":"SocketType","n":"SOCK_RDM"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊍>","k":"v"},{"m":1,"n":"infix:<⊍>","k":"s","s":{"p":[],"r":"Mu"}},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Setty"}]},"n":"infix:<⊍>","m":1},{"m":1,"s":{"p":[{"t":"Baggy","n":"a"}],"r":"Mu"},"k":"s","n":"infix:<⊍>"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}],"r":"Mu"},"n":"infix:<⊍>"},{"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<⊍>","k":"s","m":1},{"m":1,"n":"infix:<⊍>","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}]},"k":"s"},{"n":"infix:<⊍>","k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}],"r":"Mu"},"m":1},{"m":1,"s":{"p":[{"n":"a","t":"Setty"},{"n":"b","t":"Mixy"}],"r":"Mu"},"k":"s","n":"infix:<⊍>"},{"n":"infix:<⊍>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Mixy","n":"b"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Mixy"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<⊍>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Baggy"}]},"n":"infix:<⊍>","k":"s","m":1},{"n":"infix:<⊍>","k":"s","s":{"p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}],"r":"Mu"},"m":1},{"m":1,"k":"s","n":"infix:<⊍>","s":{"p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}],"r":"Mu"}},{"n":"infix:<⊍>","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"m":1,"k":"s"},{"s":{"p":[{"t":"Positional","n":"+@p"}],"r":"Mu"},"m":1,"n":"infix:<⊍>","k":"s"},{"n":"&sprintf","k":"v","t":"Sub"},{"n":"sprintf","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Cool","n":"$format"},{"t":"Positional","n":"*@args"}]}},{"b":"A","k":"c","t":"PhasersList","n":"PhasersList","mro":["Any"]},{"d":"<p><pre><code>multi sub infix:&lt;==&gt;(Any, Any)\nmulti sub infix:&lt;==&gt;(Int:D, Int:D)\nmulti sub infix:&lt;==&gt;(Num:D, Num:D)\nmulti sub infix:&lt;==&gt;(Rational:D, Rational:D)\nmulti sub infix:&lt;==&gt;(Real:D, Real:D)\nmulti sub infix:&lt;==&gt;(Complex:D, Complex:D)\nmulti sub infix:&lt;==&gt;(Numeric:D, Numeric:D)</code></pre></p><p>Numeric equality operator.</p><p>Coerces both arguments to Numeric (if necessary); returns True if they are equal.</p>","k":"v","n":"&infix:<==>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","m":1,"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"n":"infix:<==>"},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]},"n":"infix:<==>","k":"s"},{"k":"s","s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Real"}],"r":"Mu"},"n":"infix:<==>","m":1},{"s":{"p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:<==>","k":"s"},{"n":"infix:<==>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]}},{"n":"infix:<==>","s":{"r":"Bool:D","p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}]},"m":1,"k":"s"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"num"},{"n":"$b","t":"num"}]},"n":"infix:<==>","m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}],"r":"Bool:D"},"n":"infix:<==>"},{"k":"s","m":1,"n":"infix:<==>","s":{"p":[{"t":"Rational","n":"a"},{"t":"Int","n":"b"}],"r":"Bool:D"}},{"s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Rational"}],"r":"Bool:D"},"m":1,"n":"infix:<==>","k":"s"},{"n":"infix:<==>","s":{"p":[{"n":"a","t":"Complex"},{"n":"b","t":"Complex"}],"r":"Bool:D"},"k":"s","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Complex"},{"n":"b","t":"Real"}],"r":"Bool:D"},"k":"s","n":"infix:<==>"},{"n":"infix:<==>","m":1,"s":{"p":[{"n":"a","t":"Real"},{"t":"Complex","n":"b"}],"r":"Bool:D"},"k":"s"},{"s":{"p":[{"t":"Instant","n":"$a"},{"n":"$b","t":"Instant"}],"r":"Bool:D"},"n":"infix:<==>","k":"s","m":1},{"s":{"r":"Bool:D","p":[{"n":"a","t":"DateTime"},{"n":"b","t":"DateTime"}]},"k":"s","m":1,"n":"infix:<==>"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"Date"},{"n":"$b","t":"Date"}]},"n":"infix:<==>","m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Version"},{"n":"b","t":"Version"}]},"n":"infix:<==>"},{"t":"Signal","k":"e","n":"SIGTERM"},{"k":"e","n":"SIGBREAK","t":"Signal"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:«(>)»"},{"s":{"p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}],"r":"Bool:D"},"n":"infix:«(>)»","m":1,"k":"s"},{"n":"&get","k":"v","t":"Sub"},{"s":{"p":[{"t":"IO::Handle","n":"$fh?"}],"r":"Mu"},"m":1,"k":"s","n":"get"},{"k":"ro","b":"C","mro":[],"n":"PositionalBindFailover","d":"<p><pre><code>role PositionalBindFailover { ... }</code></pre></p><p>This role provides an interface by which an object can be coerced into a Positional when binding to Positional parameters.</p><p>For example, Seq type is not Positional, but you can still write the following, because it does PositionalBindFailover role:</p><p><pre><code>sub fifths(@a) {        # @a is constraint to Positional\n    @a[4];\n}\nmy $seq := gather {     # a Seq, which is not Positional\n    take $_ for 1..*;\n}\nsay fifths($seq);       # OUTPUT: «5␤»</code></pre></p><p>The invocation of fifths in the example above would ordinarily give a type error, because $seq is of type Seq, which doesn't do the Positional interface that the @-sigil implies.</p><p>But the signature binder recognizes that Seq does the PositionalBindFailover role, and calls its cache method to coerce it to a List, which does the Positional role.</p><p>The same happens with custom classes that do the role; they simply need to provide an iterator method that produces an Iterator:</p><p><pre><code>class Foo does PositionalBindFailover {\n    method iterator {\n        class :: does Iterator {\n            method pull-one {\n                return 42 unless $++;\n                IterationEnd\n            }\n        }.new\n    }\n}\n\nsub first-five (@a) { @a[^5].say }\nfirst-five Foo.new; # OUTPUT: # OUTPUT: «(42 Nil Nil Nil Nil)␤»</code></pre></p>","m":[{"d":"<p><pre><code>method cache(PositionalBindFailover:D: --&gt; List:D)</code></pre></p><p>Returns a List based on the iterator method, and caches it. Subsequent calls to cache always return the same List object.</p>","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"cache"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"iterator","k":"m"}],"t":"PositionalBindFailover","a":[{"k":"v","t":"Mu","n":"$!list"}]},{"n":"&leave","t":"Sub","k":"v"},{"n":"leave","m":0,"k":"s","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi sub infix:&lt;unicmp&gt;(Str:D \\a, Str:D \\b --&gt; Order:D)\nmulti sub infix:&lt;unicmp&gt;(Pair:D \\a, Pair:D \\b --&gt; Order:D)\nmulti sub infix:&lt;coll&gt;(Pair:D \\a, Pair:D \\b --&gt; Order:D)</code></pre></p><p>Unlike the cmp operator which sorts according to codepoint, unicmp and coll sort according to how most users would expect, that is, disregarding aspects of the particular character like capitalization.</p><p><pre><code>say 'a' unicmp 'Z'; # Less\nsay 'a' coll 'Z';   # Less\nsay 'a' cmp 'Z';    # More</code></pre></p><p>The main difference between coll and unicmp is that the behavior of the former can be changed by the $*COLLATION dynamic variable.</p><p>NOTE: These are not yet implemented in the JVM.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<unicmp>"},{"s":{"p":[{"n":"a","t":"Str"},{"t":"Str","n":"b"}],"r":"Order:D"},"m":1,"k":"s","n":"infix:<unicmp>"},{"s":{"p":[{"n":"a","t":"Pair"},{"t":"Pair","n":"b"}],"r":"Order:D"},"n":"infix:<unicmp>","m":1,"k":"s"},{"n":"Backtrace","k":"c","m":[{"m":0,"n":"AT-POS","s":{"r":"Mu","p":[{"t":"Any","n":"$pos"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method next-interesting-index(Backtrace:D: Int $idx = 0, :$named, :$noproto, :$setting)</code></pre></p><p>Returns the index of the next interesting frame, once hidden and other settings are taken into account. $named will decide whether to printed only those with a name, $noproto will hide protos, and $setting will hide those are considered setting.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.next-interesting-index;           # OUTPUT: «2␤»\nsay $!.backtrace.next-interesting-index( :named ); #  OUTPUT: «4␤»\n</code></pre></p>","n":"next-interesting-index","k":"m","m":0,"s":{"p":[{"n":"$idx?","t":"Int"},{"t":"Any","n":":$named"},{"t":"Any","n":":$noproto"},{"n":":$setting","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"outer-caller-idx","s":{"p":[{"n":"$startidx","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method outer-caller-idx(Backtrace:D: Int $startidx)</code></pre></p><p>Returns as a list the index of the frames that called the current one.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.outer-caller-idx( 4 ); # OUTPUT: «[6]␤»\n</code></pre></p>","m":0},{"s":{"r":"Mu","p":[{"n":":$oneline","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"nice","d":"<p>Defined as:</p><p><pre><code>method nice(Backtrace:D: :$oneline)</code></pre></p><p>Returns the backtrace as a list of interesting frames. If :$oneline is set, will stop after the first frame.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.nice( :oneline ) if $!;\n# OUTPUT: «  in sub zipi at /tmp/... line 1␤␤»\n</code></pre></p>","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"first-none-setting-line"},{"n":"concise","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method concise(Backtrace:D:)</code></pre></p><p>Returns a concise string representation of the backtrace, filtered by !.is-hidden &amp;&amp; .is-routine &amp;&amp; !.is-setting.</p><p>This program:</p><p><pre><code>sub inner { say Backtrace.new.concise }\nsub outer { inner; }\nouter;</code></pre></p><p>results in:</p><p><pre><code>in sub inner at test.p6 line 1\nin sub outer at test.p6 line 2\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method full(Backtrace:D:)</code></pre></p><p>Returns a full string representation of the backtrace, including hidden frames, compiler-specific frames, and those from the setting.</p><p><pre><code>my $backtrace = Backtrace.new;\nsay $backtrace.full;</code></pre></p>","m":0,"n":"full","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"summary","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method summary(Backtrace:D: --&gt; Str:D)</code></pre></p><p>Returns a summary string representation of the backtrace, filtered by !.is-hidden &amp;&amp; (.is-routine || !.is-setting).</p><p>This program:</p><p><pre><code>sub inner { say Backtrace.new.summary }\nsub outer { inner; }\nouter;</code></pre></p><p>results in:</p><p><pre><code>in method new at SETTING::src/core/Backtrace.pm6 line 85\nin sub inner at test.p6 line 1\nin sub outer at test.p6 line 2\nin block &lt;unit&gt; at test.p6 line 3\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-runtime","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"$!bt","t":"Any"},{"n":"$!bt-next","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!SET-SELF","m":0}],"b":"A","t":"Backtrace","mro":["Any"],"a":[{"k":"v","t":"Mu","n":"$!bt"},{"t":"Mu","n":"$!frames","k":"v"},{"k":"v","t":"Int","n":"$!bt-next"}],"d":"<p><pre><code>class Backtrace {}</code></pre></p><p>A backtrace contains the dynamic call stack, usually leading up to a point where an exception was thrown, and is a List of Backtrace::Frame objects. Its default stringification excludes backtrace frames that are deemed unnecessary or confusing; for example routines like &amp;die are hidden by default. Being a list, you can also access individual elements.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry {\n    zipi;\n}\nif ($!) {\n    say $!.backtrace[*-1].perl;\n}\n</code></pre></p><p>This will print the last frame in the list, pointing at the line where it's happened.</p>"},{"mro":["Any"],"m":[{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"subtype"},{"m":0,"n":"package","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"is-hidden","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method is-hidden(Backtrace::Frame:D --&gt; Bool:D)</code></pre></p><p>Returns True if the frame is marked as hidden with the is hidden-from-backtrace trait.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.is-hidden;</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Defined as:</p><p><pre><code>method is-routine(Backtrace::Frame:D --&gt; Bool:D)</code></pre></p><p>Return True if the frame points into a routine (and not into a mere Block).</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.is-routine;</code></pre></p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"is-routine"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"is-setting"},{"n":"file","d":"<p>Defined as:</p><p><pre><code>method file(Backtrace::Frame:D --&gt; Str)</code></pre></p><p>Returns the file name.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.file;</code></pre></p>","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p>Defined as:</p><p><pre><code>method line(Backtrace::Frame:D --&gt; Int)</code></pre></p><p>Returns the line number (line numbers start counting from 1).</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.line;</code></pre></p>","k":"m","n":"line"},{"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method code(Backtrace::Frame:D)</code></pre></p><p>Returns the code object into which .file and .line point, if available.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.code;</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"code"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method subname(Backtrace::Frame:D --&gt; Str)</code></pre></p><p>Returns the name of the enclosing subroutine.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.subname;</code></pre></p>","n":"subname"},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"$!file","t":"Any"},{"n":"$!line","t":"Any"},{"n":"code","t":"Any"},{"n":"$!subname","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!SET-SELF","m":0,"k":"m"}],"t":"Backtrace::Frame","k":"c","a":[{"k":"v","t":"Str","n":"$.file"},{"k":"v","t":"Int","n":"$.line"},{"t":"Mu","k":"v","n":"$.code"},{"k":"v","n":"$.subname","t":"Str"}],"d":"<p><pre><code>class Backtrace::Frame { }</code></pre></p><p>A single backtrace frame. It identifies a location in the source code.</p>","n":"Backtrace::Frame","b":"A"},{"k":"v","n":"&tc","t":"Sub"},{"m":1,"n":"tc","k":"s","s":{"p":[{"t":"Cool","n":"$s"}],"r":"Mu"}},{"k":"v","d":"<p><pre><code>multi sub infix:&lt;before&gt;(Any,       Any)\nmulti sub infix:&lt;before&gt;(Real:D,    Real:D)\nmulti sub infix:&lt;before&gt;(Str:D,     Str:D)\nmulti sub infix:&lt;before&gt;(Version:D, Version:D)</code></pre></p><p>Generic ordering, uses the same semantics as cmp. Returns True if the first argument is smaller than the second.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<before>"},{"m":1,"s":{"r":"Bool","p":[{"t":"Any","n":"$?"}]},"n":"infix:<before>","k":"s"},{"m":1,"k":"s","n":"infix:<before>","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Bool:D"}},{"t":"SocketType","n":"SOCK_RAW","k":"e"},{"b":"A","d":"<p><pre><code>class Method is Routine { }</code></pre></p><p>A type for methods that behave the same way as Routine with some exceptions listed in the following. For details of a method's parameter list see Signature.</p><p>To create a method outside a class definition, use the declarators my and method. If an identifier is provided the methods name will be injected into the scope specified by the declarator.</p><p><pre><code>my $m = method ($invocant: $param) {\n    say \"$invocant: '$param'\";\n}\n\"greeting\".$m(\"hello\");  # OUTPUT: «greeting: 'hello'␤»\n\n&lt;a b c&gt;.&amp;(my method (List:D:) { say self.perl; self }).say;\n# OUTPUT: «(\"a\", \"b\", \"c\")␤(a b c)␤»</code></pre></p><p>The invocant of a method defaults to self. A type constraint including a type-smiley can be used and is honored both for methods defined in a class and for free floating methods. Call the latter with .&amp; on an object.</p><p><pre><code>my method m(Int:D: $b){\n    say self.^name\n}\nmy $i = 1;\n$i.&amp;m(&lt;a&gt;);\n# OUTPUT: «Int␤»</code></pre></p><p> Methods will ignore extra named arguments where other types of Routine will throw at runtime. Extra arguments will be forwarded by nextsame and friends.</p><p><pre><code>class A {\n    multi method m(:$a, :$b) { say \"2 named\" }\n}\n\nclass B is A {\n    method m(:$a) { say \"1 named\"; nextsame }\n}\nB.m( :1a, :2b );\n# OUTPUT: «1 named␤2 named␤»</code></pre></p>","k":"c","t":"Method","n":"Method","a":[{"n":"@!dispatchees","t":"List","k":"v"},{"n":"$!dispatcher_cache","k":"v","t":"Mu"},{"n":"$!dispatcher","t":"Mu","k":"v"},{"k":"v","n":"$!flags","t":"int"},{"k":"v","t":"Mu","n":"$!inline_info"},{"n":"$!package","t":"Mu","k":"v"},{"n":"$!onlystar","k":"v","t":"int"},{"k":"v","n":"@!dispatch_order","t":"List"},{"k":"v","n":"$!dispatch_cache","t":"Mu"},{"t":"Mu","n":"$!why","k":"v"},{"t":"Code","n":"$!do","k":"v"},{"n":"$!signature","t":"Signature","k":"v"},{"k":"v","n":"@!compstuff","t":"List"}],"mro":["Callable","Routine"]},{"d":"<p><pre><code>multi sub infix:&lt;/&gt;(Any, Any --&gt; Numeric:D)</code></pre></p><p>Division operator.</p><p>Coerces both argument to Numeric and divides the left through the right number. Division of Int values returns Rat, otherwise the \"wider type\" rule described in Numeric holds.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:</>","k":"v"},{"n":"infix:</>","m":1,"s":{"r":"Mu","p":[]},"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$x","t":"Any"}]},"n":"infix:</>"},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]},"n":"infix:</>","m":1},{"k":"s","n":"infix:</>","m":1,"s":{"p":[{"t":"Real","n":"a"},{"t":"Real","n":"b"}],"r":"Mu"}},{"n":"infix:</>","s":{"p":[{"n":"a","t":"Num"},{"t":"Num","n":"b"}],"r":"Mu"},"k":"s","m":1},{"s":{"r":"num","p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}]},"n":"infix:</>","k":"s","m":1},{"n":"infix:</>","k":"s","m":1,"s":{"p":[{"n":"r","t":"Range"},{"t":"Real","n":"v"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Rational"},{"t":"Rational","n":"b"}],"r":"Mu"},"n":"infix:</>","k":"s","m":1},{"k":"s","s":{"r":"Mu","p":[{"t":"Rational","n":"a"},{"n":"b","t":"Int"}]},"m":1,"n":"infix:</>"},{"n":"infix:</>","s":{"r":"Mu","p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}]},"k":"s","m":1},{"n":"infix:</>","s":{"r":"Mu","p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}]},"m":1,"k":"s"},{"m":1,"s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}]},"k":"s","n":"infix:</>"},{"k":"s","m":1,"n":"infix:</>","s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"n":"b","t":"Real"}]}},{"m":1,"s":{"r":"Complex:D","p":[{"t":"Real","n":"a"},{"t":"Complex","n":"b"}]},"n":"infix:</>","k":"s"},{"t":"Sub","n":"&roundrobin","k":"v"},{"k":"s","s":{"p":[{"t":"Any","n":"+lol"}],"r":"Seq:D"},"n":"roundrobin","m":1},{"t":"Sub","k":"v","n":"&trait_mod:<will>"},{"m":1,"s":{"p":[{"n":"$attr","t":"Attribute"},{"t":"Any","n":"c"}],"r":"Mu"},"n":"trait_mod:<will>","k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Attribute","n":"$attr"},{"n":":$build!","t":"Mu"}],"r":"Mu"},"n":"trait_mod:<will>"},{"k":"s","n":"trait_mod:<will>","s":{"p":[{"n":"$v","t":"Variable"},{"n":"$block","t":"Any"},{"t":"Any","n":"c"}],"r":"Mu"},"m":1},{"m":1,"s":{"p":[{"t":"Variable","n":"$v"},{"n":"$block","t":"Any"},{"t":"Any","n":":$!"}],"r":"Mu"},"k":"s","n":"trait_mod:<will>"},{"s":{"r":"Mu","p":[{"t":"Variable","n":"$v"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}]},"n":"trait_mod:<will>","m":1,"k":"s"},{"m":1,"k":"s","n":"trait_mod:<will>","s":{"r":"Mu","p":[{"t":"Variable","n":"$v"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}]}},{"k":"s","m":1,"n":"trait_mod:<will>","s":{"r":"Mu","p":[{"n":"$v","t":"Variable"},{"t":"Any","n":"$block"},{"t":"Any","n":":$!"}]}},{"k":"s","m":1,"s":{"p":[{"n":"$v","t":"Variable"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<will>"},{"s":{"p":[{"t":"Variable","n":"$v"},{"t":"Any","n":"$block"},{"t":"Any","n":":$!"}],"r":"Mu"},"n":"trait_mod:<will>","k":"s","m":1},{"n":"trait_mod:<will>","m":1,"k":"s","s":{"p":[{"n":"$v","t":"Variable"},{"n":"$block","t":"Any"},{"t":"Any","n":":$!"}],"r":"Mu"}},{"n":"trait_mod:<will>","m":1,"k":"s","s":{"p":[{"t":"Variable","n":"$v"},{"n":"$block","t":"Any"},{"t":"Any","n":":$!"}],"r":"Mu"}},{"s":{"p":[{"t":"Variable","n":"$v"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}],"r":"Mu"},"k":"s","n":"trait_mod:<will>","m":1},{"s":{"p":[{"n":"$v","t":"Variable"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}],"r":"Mu"},"n":"trait_mod:<will>","m":1,"k":"s"},{"s":{"r":"Mu","p":[{"n":"$v","t":"Variable"},{"t":"Any","n":"$block"},{"t":"Any","n":":$!"}]},"k":"s","m":1,"n":"trait_mod:<will>"},{"s":{"p":[{"n":"$v","t":"Variable"},{"n":"$block","t":"Any"},{"n":":$!","t":"Any"}],"r":"Mu"},"m":1,"n":"trait_mod:<will>","k":"s"},{"n":"trait_mod:<will>","m":1,"s":{"p":[{"t":"Variable","n":"$v"},{"n":"$block","t":"Any"},{"n":":$!","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"n":"trait_mod:<will>","s":{"r":"Mu","p":[{"t":"Variable","n":"$v"},{"n":"$block","t":"Any"},{"t":"Any","n":":$!"}]}},{"m":1,"n":"trait_mod:<will>","k":"s","s":{"p":[{"n":"$v","t":"Variable"},{"t":"Any","n":"$block"},{"n":":$!","t":"Any"}],"r":"Mu"}},{"n":"&infix:<~|>","k":"v","t":"Sub+{is-pure}+{Precedence}","d":"<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise OR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>"},{"m":1,"s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]},"n":"infix:<~|>","k":"s"},{"n":"infix:<~|>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]}},{"m":1,"n":"infix:<~|>","s":{"r":"Mu","p":[{"n":"a","t":"Blob"},{"n":"b","t":"Blob"}]},"k":"s"},{"m":1,"k":"s","n":"infix:<~|>","s":{"r":"Str:D","p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}]}},{"s":{"p":[{"n":"$a","t":"str"},{"n":"$b","t":"str"}],"r":"str"},"n":"infix:<~|>","m":1,"k":"s"},{"d":"<p><pre><code>multi sub infix:&lt;=~=&gt;(Any, Any)\nmulti sub infix:&lt;=~=&gt;(Int:D, Int:D)\nmulti sub infix:&lt;=~=&gt;(Num:D, Num:D)\nmulti sub infix:&lt;=~=&gt;(Rational:D, Rational:D)\nmulti sub infix:&lt;=~=&gt;(Real:D, Real:D)\nmulti sub infix:&lt;=~=&gt;(Complex:D, Complex:D)\nmulti sub infix:&lt;=~=&gt;(Numeric:D, Numeric:D)</code></pre></p><p>The approximately-equal operator ≅, whose ASCII variant is =~=, calculates the relative difference between the left-hand and right-hand sides and returns True if the difference is less than $*TOLERANCE (which defaults to 1e-15). However, if either side is zero then it checks that the absolute difference between the sides is less than $*TOLERANCE. Note that this operator is not arithmetically symmetrical (doesn't do ± Δ):</p><p><pre><code>my $x = 1;\nsay ($x + $*TOLERANCE) =~= $x;   # OUTPUT: «False␤»\nsay ($x - $*TOLERANCE) =~= $x;   # OUTPUT: «True␤»</code></pre></p><p>The tolerance is supposed to be modifiable via an adverb:</p><p><pre><code>my ($x, $y) = 42, 42.1;\nsay $x =~= $y :tolerance(.1);\n</code></pre></p><p>However, this is not yet implemented. The same effect can be achieved by assigning to $*TOLERANCE.</p><p><pre><code>{\n    my $*TOLERANCE = .1;\n    say 11 =~= 10;        # OUTPUT: «True␤»\n}</code></pre></p><p>Note that setting $*TOLERANCE = 0 will cause all comparisons to fail.</p><p><pre><code>{\n    my $*TOLERANCE = 0;\n    say 1 =~= 1;          # OUTPUT: «False␤»\n}</code></pre></p>","n":"&infix:<=~=>","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[{"n":"$?","t":"Any"}]},"m":1,"n":"infix:<=~=>","k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"},{"n":":$tolerance?","t":"Any"}]},"n":"infix:<=~=>"},{"n":"infix:<=~=>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"$","t":"Num"},{"n":"$","t":"Num"}]}},{"n":"infix:<=~=>","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Num","n":"$"},{"t":"Num","n":"$"}]}},{"n":"infix:<=~=>","k":"s","s":{"r":"Bool:D","p":[{"t":"Complex","n":"a"},{"n":"b","t":"Complex"}]},"m":1},{"s":{"r":"Bool:D","p":[{"t":"Complex","n":"a"},{"n":"b","t":"Real"}]},"m":1,"k":"s","n":"infix:<=~=>"},{"m":1,"n":"infix:<=~=>","k":"s","s":{"r":"Bool:D","p":[{"t":"Real","n":"a"},{"t":"Complex","n":"b"}]}},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<&>"},{"k":"s","n":"infix:<&>","m":1,"s":{"p":[{"n":"+values","t":"Any"}],"r":"Mu"}},{"t":"Signal","k":"e","n":"SIGTTOU"},{"t":"Sub","n":"&shift","k":"v"},{"m":1,"n":"shift","s":{"r":"Mu","p":[{"n":"@a","t":"Positional"}]},"k":"s"},{"d":"<p><pre><code>sub infix:&lt;!=&gt;(Mu, Mu --&gt; Bool:D)</code></pre></p><p>Numeric inequality operator.</p><p>Coerces both arguments to Numeric (if necessary); returns True if they are distinct.</p><p>Is an alias to !==.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<!=>"},{"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"k":"s","n":"infix:<!=>","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"t":"Mu","n":"b"}]},"k":"s","n":"infix:<!=>"},{"s":{"p":[{"n":"$a","t":"int"},{"t":"int","n":"$b"}],"r":"Bool:D"},"m":1,"n":"infix:<!=>","k":"s"},{"s":{"p":[{"n":"a","t":"Int"},{"t":"Int","n":"b"}],"r":"Bool:D"},"n":"infix:<!=>","k":"s","m":1},{"m":1,"n":"infix:<!=>","k":"s","s":{"r":"Bool:D","p":[{"n":"$a","t":"num"},{"t":"num","n":"$b"}]}},{"k":"s","m":1,"n":"infix:<!=>","s":{"p":[{"t":"Instant","n":"$a"},{"n":"$b","t":"Instant"}],"r":"Bool:D"}},{"s":{"p":[{"n":"a","t":"DateTime"},{"t":"DateTime","n":"b"}],"r":"Bool:D"},"n":"infix:<!=>","k":"s","m":1},{"m":1,"s":{"r":"Mu","p":[{"t":"Version","n":"a"},{"n":"b","t":"Version"}]},"k":"s","n":"infix:<!=>"},{"n":"&infix:<|>","d":"<p><pre><code>multi sub infix:&lt;|&gt;($a, $b --&gt; Junction:D) is assoc&lt;list&gt;</code></pre></p><p> Creates an any Junction from its arguments.</p><p><pre><code>my $three-letters = /&lt;[a b c]&gt;/ | /&lt;[i j k]&gt;/ | /&lt;[x y z]&gt;/;\nsay $three-letters.perl; # OUTPUT: «any(/&lt;[a b c]&gt;/, /&lt;[i j k]&gt;/, /&lt;[x y z]&gt;/)␤»\nsay 'b' ~~ $three-letters; # OUTPUT: «True␤»</code></pre></p><p>This first creates an any Junction of three regular expressions (every one of them matching any of 3 letters), and then uses smartmatching to check whether the letter b matches any of them, resulting in a positive match. See also Junction for more details.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<|>","k":"s","m":1,"s":{"p":[{"n":"+values","t":"Any"}],"r":"Mu"}},{"d":"<p><pre><code>multi sub prefix:&lt;?&gt;(Mu --&gt; Bool:D)</code></pre></p><p>Boolean context operator.</p><p>Coerces the argument to Bool by calling the Bool method on it. Note that this collapses Junctions.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<?>","k":"v"},{"s":{"r":"Mu","p":[{"t":"Bool","n":"a"}]},"m":1,"k":"s","n":"prefix:<?>"},{"m":1,"n":"prefix:<?>","k":"s","s":{"p":[{"n":"a","t":"Bool"}],"r":"Mu"}},{"n":"prefix:<?>","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mu"}]}},{"mro":["Stringy","Str"],"b":"C","n":"Allomorph","t":"Allomorph","k":"c","m":[{"m":0,"k":"m","n":"succ","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"pred"},{"m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}]},{"k":"v","n":"&infix:<max>","d":"<p>Returns the largest of the arguments, as determined by cmp semantics.</p><p><pre><code>my $foo = -42;\n$foo max= 0   # read as: $foo increases to 0</code></pre></p>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<max>","k":"s","m":1,"s":{"p":[{"t":"Mu","n":"a"},{"n":"$","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"p":[{"n":"$","t":"Mu"},{"t":"Mu","n":"b"}],"r":"Mu"},"k":"s","n":"infix:<max>"},{"m":1,"k":"s","n":"infix:<max>","s":{"r":"Mu","p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"b"}]}},{"k":"s","s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}],"r":"Mu"},"n":"infix:<max>","m":1},{"m":1,"n":"infix:<max>","k":"s","s":{"p":[{"n":"a","t":"int"},{"n":"b","t":"int"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Num","n":"a"},{"n":"b","t":"Num"}],"r":"Mu"},"n":"infix:<max>","k":"s"},{"n":"infix:<max>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"num"},{"n":"b","t":"num"}]}},{"m":1,"n":"infix:<max>","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"+args"}]}},{"a":[{"n":"$!name","k":"v","t":"Str"},{"n":"$!file","t":"Str","k":"v"},{"t":"Int","n":"$!line","k":"v"},{"n":"$!prematch","k":"v","t":"Str"},{"t":"Str","k":"v","n":"$!postmatch"}],"k":"c","t":"Label","m":[{"n":"new","m":0,"s":{"r":"Mu","p":[{"n":":$name","t":"Any"},{"t":"Any","n":":$line"},{"n":":$prematch","t":"Any"},{"n":":$postmatch","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"name","d":"<p>Defined as:</p><p><pre><code>method name()</code></pre></p><p>Not terribly useful, returns the name of the defined label:</p><p><pre><code>A: while True {\n  say A.name; # OUTPUT: «A»\n  last A;\n}</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*@","t":"Positional"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"goto"},{"k":"m","n":"leave","m":0,"s":{"p":[{"t":"Positional","n":"*@"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"Int","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method next(Label:)</code></pre></p><p>Begin the next iteration of the loop associated with the label.</p><p><pre><code>MY-LABEL:\nfor 1..10 {\n    next MY-LABEL if $_ &lt; 5;\n    print \"$_ \";\n}\n\n# OUTPUT: «5 6 7 8 9 10 »</code></pre></p>","n":"next","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method redo(Label:)</code></pre></p><p>Repeat the same iteration of the loop associated with the label.</p><p><pre><code>my $has-repeated = False;\n\nMY-LABEL:\nfor 1..10 {\n    print \"$_ \";\n    if $_ == 5 {\n        LEAVE $has-repeated = True;\n        redo MY-LABEL unless $has-repeated;\n    }\n}\n\n# OUTPUT: «1 2 3 4 5 5 6 7 8 9 10 »</code></pre></p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"redo"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"last","m":0}],"d":"<p><pre><code>class Label {}</code></pre></p><p>Labels are used in Raku to tag loops so that you can specify the one you want to jump to with statements such as last. You can use it to jump out of loops and get to outer ones, instead of just exiting the current loop or going to the statement before.</p><p><pre><code>USERS:          # the label\nfor @users -&gt; $u {\n    for $u.pets -&gt; $pet {\n        # usage of a label\n        next USERS if $pet.barks;\n    }\n    say \"None of {$u}'s pets barks\";\n}\nsay USERS.^name;        # OUTPUT: «Label␤»\n</code></pre></p><p>Those label are objects of type Label, as shown in the last statement. Labels can be used in any loop construct, as long as they appear right before the loop statement.</p><p><pre><code>my $x = 0;\nmy $y = 0;\nmy $t = '';\nA: while $x++ &lt; 2 {\n    $t ~= \"A$x\";\n    B: while $y++ &lt; 2 {\n        $t ~= \"B$y\";\n        redo A if $y++ == 1;\n        last A\n    }\n}\nsay $t; # OUTPUT: «A1B1A1A2»\n</code></pre></p><p>Putting them on the line before the loop or the same line is optional. Labels must follow the syntax of ordinary identifiers, although traditionally we will use the latin alphabet in uppercase so that they stand out in the source. You can use, however, other alphabets like here:</p><p><pre><code>駱駝道: while True {\n  say 駱駝道.name;\n  last 駱駝道;\n}</code></pre></p>","mro":["Any"],"b":"A","n":"Label"},{"d":"<p><pre><code>multi sub prefix:&lt;so&gt;(Mu $x --&gt; Bool:D)</code></pre></p><p>Evaluates its argument in boolean context (and thus collapses Junctions), and returns the result.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<so>","k":"v"},{"n":"prefix:<so>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Bool"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Bool"}],"r":"Mu"},"n":"prefix:<so>","k":"s","m":1},{"n":"prefix:<so>","s":{"r":"Mu","p":[{"n":"a","t":"Mu"}]},"k":"s","m":1},{"t":"Sub+{is-pure}","n":"&chars","k":"v"},{"m":1,"s":{"p":[{"n":"$x","t":"Cool"}],"r":"Mu"},"n":"chars","k":"s"},{"k":"s","s":{"p":[{"n":"$x","t":"Str"}],"r":"Mu"},"m":1,"n":"chars"},{"s":{"r":"int","p":[{"n":"$x","t":"str"}]},"k":"s","n":"chars","m":1},{"k":"c","d":"<p><pre><code>class IntStr is Int is Str { }</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = &lt;42&gt;; say $f.^name; # OUTPUT: «IntStr␤»</code></pre></p><p>As a subclass of both Int and Str, an IntStr will be accepted where either is expected. However, IntStr does not share object identity with Int- or Str-only variants:</p><p><pre><code>my $int-str = &lt;42&gt;;\nmy Int $int = $int-str; # OK!\nmy Str $str = $int-str; # OK!\nsay 42 ∈ &lt;42  55  1&gt;;   # False; ∈ operator cares about object identity</code></pre></p>","b":"C","m":[{"d":"<p><pre><code>method new(Int $i, Str $s)</code></pre></p><p>The constructor requires both the Int and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = IntStr.new(42, \"forty two\");\nsay +$f; # OUTPUT: «42␤»\nsay ~$f; # OUTPUT: «\"forty two\"␤»</code></pre></p>","n":"new","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$i","t":"Int"},{"t":"Str","n":"$s"},{"t":"Mu","n":"*%_"}]}},{"k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"t":"IntStr","mro":["Stringy","Real","Numeric","Allomorph","Int"],"n":"IntStr"},{"n":"&rmdir","t":"Sub","k":"v"},{"s":{"p":[{"n":"*@filenames","t":"Positional"}],"r":"Mu"},"k":"s","m":1,"n":"rmdir"},{"k":"ro","mro":[],"b":"C","t":"NumericStringyEnumeration","n":"NumericStringyEnumeration"},{"t":"Sub","n":"&values","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$x","t":"Any"}]},"n":"values"},{"n":"&lines","t":"Sub","k":"v"},{"n":"lines","s":{"r":"Mu","p":[{"t":"Any","n":"$what?"},{"n":"c","t":"Any"}]},"k":"s","m":1},{"t":"Sub","n":"&indices","k":"v"},{"n":"indices","k":"s","s":{"p":[{"n":"$s","t":"Cool"},{"t":"Cool","n":"$needle"},{"n":":$ignorecase","t":"Any"},{"n":":$ignoremark","t":"Any"},{"n":":$overlap","t":"Any"}],"r":"Mu"},"m":1},{"s":{"p":[{"n":"$s","t":"Cool"},{"t":"Cool","n":"$needle"},{"t":"Cool","n":"$pos"},{"n":":$ignorecase","t":"Any"},{"t":"Any","n":":$ignoremark"},{"t":"Any","n":":$overlap"}],"r":"Mu"},"n":"indices","m":1,"k":"s"},{"t":"Signal","n":"SIGCHLD","k":"e"},{"t":"Sub+{is-pure}","n":"&sqrt","k":"v"},{"m":1,"s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"k":"s","n":"sqrt"},{"s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"},"m":1,"n":"sqrt","k":"s"},{"m":1,"n":"sqrt","s":{"p":[{"t":"num","n":"$a"}],"r":"num"},"k":"s"},{"n":"SIGPROF","t":"Signal","k":"e"},{"n":"&one","t":"Sub+{is-pure}","k":"v"},{"m":1,"n":"one","s":{"r":"Mu","p":[{"n":"@values","t":"Positional"}]},"k":"s"},{"s":{"p":[{"n":"+values","t":"Any"}],"r":"Mu"},"m":1,"n":"one","k":"s"},{"k":"c","m":[{"s":{"p":[{"n":"$iter","t":"Iterator"},{"t":"Mu","n":"*%_"}],"r":"List:D"},"n":"from-iterator","k":"m","m":0},{"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"m":0,"k":"m","n":"from-slurpy"},{"n":"from-slurpy-onearg","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"n":"from-slurpy-flat","m":0,"k":"m"},{"s":{"p":[{"n":"**@things","t":"Positional"},{"t":"Mu","n":"*%_"}],"r":"List:D"},"m":0,"n":"new","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","d":"<p><pre><code>\"abc123def\" ~~ m:g/\\d/;\nsay $/.to; # OUTPUT: «6␤»</code></pre></p><p>Assumes the List contains Match objects, such as the $/ variable being a List, when using :g modifier in regexes. Returns the value of .to called on the last element of the list.</p>","n":"to"},{"k":"m","m":0,"n":"from","d":"<p>Assumes the list contains Match objects and returns the value of .from called on the first element of the list.</p><p><pre><code>'abcdefg' ~~ /(c)(d)/;\nsay $/.list.from;         # OUTPUT: «2␤»\n\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.list.from;         # OUTPUT: «3␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>sub    sum($list   --&gt; Numeric:D)\nmethod sum(List:D: --&gt; Numeric:D)</code></pre></p><p>Returns the sum of all elements in the list or 0 if the list is empty. Throws an exception if an element can not be coerced into Numeric.</p><p><pre><code>say (1, 3, pi).sum;       # OUTPUT: «7.14159265358979␤»\nsay (1, \"0xff\").sum;      # OUTPUT: «256␤»\nsay sum(0b1111, 5);       # OUTPUT: «20␤»</code></pre></p><p>When being called on native integer arrays, it is also possible to specify a :wrap named parameter. This will add the values as native integers, wrapping around if they exceed the size of a native integer. If you are sure you will not exceed that value, or if you don't mind, using :wrap will make the calculation about 20x as fast.</p><p><pre><code>my int @values = ^1_000_000;\nsay @a.sum(:wrap);        # OUTPUT: «499999500000␤»\n</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"sum","m":0,"k":"m"},{"n":"fmt","m":1,"d":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s', $separator = ' ' --&gt; Str:D)</code></pre></p><p>Returns a string where each element in the list has been formatted according to $format and where each element is separated by $separator.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>my @a = 8..11;\nsay @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»</code></pre></p>","k":"m","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]}},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s', $separator = ' ' --&gt; Str:D)</code></pre></p><p>Returns a string where each element in the list has been formatted according to $format and where each element is separated by $separator.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>my @a = 8..11;\nsay @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»</code></pre></p>","s":{"p":[{"t":"Cool","n":"$format"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"fmt"},{"n":"fmt","m":1,"s":{"p":[{"n":"$format","t":"Cool"},{"t":"Any","n":"$separator"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"d":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s', $separator = ' ' --&gt; Str:D)</code></pre></p><p>Returns a string where each element in the list has been formatted according to $format and where each element is separated by $separator.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>my @a = 8..11;\nsay @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»</code></pre></p>","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Int","n":"pos"},{"n":"what","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"ASSIGN-POS"},{"n":"BIND-POS","s":{"r":"Mu","p":[{"t":"Int","n":"pos"},{"t":"Any","n":"what"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"n":"reification-target","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"iterator","s":{"r":"Iterator:D","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"d":"<p>Defined as:</p><p><pre><code>method sink(--&gt; Nil) { }</code></pre></p><p>It does nothing, and returns Nil, as the definition clearly shows.</p><p><pre><code>sink [1,2,Failure.new(\"boo!\"),\"still here\"]; # OUTPUT: «»</code></pre></p>","s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"sink"},{"s":{"p":[{"n":"iterable","t":"Iterable"},{"t":"Any","n":":$!"},{"n":"*%_","t":"Mu"}],"r":"List:D"},"m":1,"n":"STORE","k":"m"},{"s":{"p":[{"n":"iterable","t":"Iterable"},{"t":"Mu","n":"*%_"}],"r":"List:D"},"m":1,"n":"STORE","k":"m"},{"s":{"p":[{"n":"item","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"List:D"},"n":"STORE","k":"m","m":1},{"n":"eager","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"List:D"},"d":"<p>Defined as:</p><p><pre><code>multi method eager(List:D: --&gt; List:D)\nmulti sub eager(*@elems --&gt; List:D)</code></pre></p><p>Evaluates all elements in the List eagerly, and returns them as a List.</p><p><pre><code>my  \\ll = (lazy 1..5).cache;\n\nsay ll[];     # OUTPUT: «(...)␤»\nsay ll.eager  # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p>","k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method Capture(--&gt; Capture:D)</code></pre></p><p>Returns a Capture where each Pair, if any, in the List has been converted to a named argument (with the key of the Pair stringified). All other elements in the List are converted to positional arguments in the order they are found, i.e. the first non pair item in the list becomes the first positional argument, which gets index 0, the second non pair item becomes the second positional argument, getting index 1 etc.</p><p><pre><code>my $list = (7, 5, a =&gt; 2, b =&gt; 17);\nmy $capture = $list.Capture;\nsay $capture.keys;                                # OUTPUT: «(0 1 a b)␤»\nmy-sub(|$capture);                                # RESULT: «7, 5, 2, 17»\n\nsub my-sub($first, $second, :$a, :$b) {\n    say \"$first, $second, $a, $b\"\n}</code></pre></p><p>A more advanced example demonstrating the returned Capture being matched against a Signature.</p><p><pre><code>my $list = (7, 5, a =&gt; 2, b =&gt; 17);\nsay so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «True␤»\n\n$list = (8, 5, a =&gt; 2, b =&gt; 17);\nsay so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «False␤»</code></pre></p>","m":0,"s":{"r":"Capture:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Capture"},{"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"n":"CALL-ME","k":"m","m":0},{"m":1,"n":"pick","d":"<p>Defined as:</p><p><pre><code>multi sub    pick($count, *@list --&gt; Seq:D)\nmulti method pick(List:D: $count --&gt; Seq:D)\nmulti method pick(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns $count elements chosen at random and without repetition from the invocant. If * is passed as $count, or $count is greater than or equal to the size of the list, then all elements from the invocant list are returned in a random sequence; i.e. they are returned shuffled.</p><p>In method form, if $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.pick;           # OUTPUT: «b␤»\nsay &lt;a b c d e&gt;.pick: 3;        # OUTPUT: «(c a e)␤»\nsay &lt;a b c d e&gt;.pick: *;        # OUTPUT: «(e d a b c)␤»</code></pre></p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi sub    pick($count, *@list --&gt; Seq:D)\nmulti method pick(List:D: $count --&gt; Seq:D)\nmulti method pick(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns $count elements chosen at random and without repetition from the invocant. If * is passed as $count, or $count is greater than or equal to the size of the list, then all elements from the invocant list are returned in a random sequence; i.e. they are returned shuffled.</p><p>In method form, if $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.pick;           # OUTPUT: «b␤»\nsay &lt;a b c d e&gt;.pick: 3;        # OUTPUT: «(c a e)␤»\nsay &lt;a b c d e&gt;.pick: *;        # OUTPUT: «(e d a b c)␤»</code></pre></p>","n":"pick","k":"m","s":{"p":[{"t":"Callable","n":"$calculate"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub    pick($count, *@list --&gt; Seq:D)\nmulti method pick(List:D: $count --&gt; Seq:D)\nmulti method pick(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns $count elements chosen at random and without repetition from the invocant. If * is passed as $count, or $count is greater than or equal to the size of the list, then all elements from the invocant list are returned in a random sequence; i.e. they are returned shuffled.</p><p>In method form, if $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.pick;           # OUTPUT: «b␤»\nsay &lt;a b c d e&gt;.pick: 3;        # OUTPUT: «(c a e)␤»\nsay &lt;a b c d e&gt;.pick: *;        # OUTPUT: «(e d a b c)␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"$number","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"pick"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1,"n":"roll","d":"<p>Defined as:</p><p><pre><code>multi sub    roll($count, *@list --&gt; Seq:D)\nmulti method roll(List:D: $count --&gt; Seq:D)\nmulti method roll(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns a sequence of $count elements, each randomly selected from the list. Each random choice is made independently, like a separate die roll where each die face is a list element. If * is passed as $count returns a lazy, infinite sequence of randomly chosen elements from the original list.</p><p>If $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.roll;       # 1 random letter\nsay &lt;a b c d e&gt;.roll: 3;    # 3 random letters\nsay roll 8, &lt;a b c d e&gt;;    # 8 random letters\n\nmy $random-digits := (^10).roll(*);\nsay $random-digits[^15];    # 15 random digits</code></pre></p>"},{"s":{"r":"Mu","p":[{"t":"Whatever","n":"$"},{"n":"*%_","t":"Mu"}]},"n":"roll","k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub    roll($count, *@list --&gt; Seq:D)\nmulti method roll(List:D: $count --&gt; Seq:D)\nmulti method roll(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns a sequence of $count elements, each randomly selected from the list. Each random choice is made independently, like a separate die roll where each die face is a list element. If * is passed as $count returns a lazy, infinite sequence of randomly chosen elements from the original list.</p><p>If $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.roll;       # 1 random letter\nsay &lt;a b c d e&gt;.roll: 3;    # 3 random letters\nsay roll 8, &lt;a b c d e&gt;;    # 8 random letters\n\nmy $random-digits := (^10).roll(*);\nsay $random-digits[^15];    # 15 random digits</code></pre></p>","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi sub    roll($count, *@list --&gt; Seq:D)\nmulti method roll(List:D: $count --&gt; Seq:D)\nmulti method roll(List:D: --&gt; Mu)</code></pre></p><p>If $count is supplied: Returns a sequence of $count elements, each randomly selected from the list. Each random choice is made independently, like a separate die roll where each die face is a list element. If * is passed as $count returns a lazy, infinite sequence of randomly chosen elements from the original list.</p><p>If $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say &lt;a b c d e&gt;.roll;       # 1 random letter\nsay &lt;a b c d e&gt;.roll: 3;    # 3 random letters\nsay roll 8, &lt;a b c d e&gt;;    # 8 random letters\n\nmy $random-digits := (^10).roll(*);\nsay $random-digits[^15];    # 15 random digits</code></pre></p>","n":"roll","k":"m","s":{"r":"Mu","p":[{"n":"number","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":1},{"n":"reverse","d":"<p>Defined as:</p><p><pre><code>multi sub    reverse(*@list  --&gt; Seq:D)\nmulti method reverse(List:D: --&gt; Seq:D)</code></pre></p><p>Returns a Seq with the same elements in reverse order.</p><p>Note that reverse always refers to reversing elements of a list; to reverse the characters in a string, use flip.</p><p>Examples:</p><p><pre><code>say &lt;hello world!&gt;.reverse;     # OUTPUT: «(world! hello)␤»\nsay reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»</code></pre></p>","k":"m","m":0,"s":{"r":"Seq:D","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi sub    rotate(@list,  Int:D $n = 1 --&gt; List:D)\nmulti method rotate(List:D: Int:D $n = 1 --&gt; List:D)</code></pre></p><p>Returns the list rotated by $n elements.</p><p>Examples:</p><p><pre><code>&lt;a b c d e&gt;.rotate(2);   # &lt;c d e a b&gt;\n&lt;a b c d e&gt;.rotate(-1);  # &lt;e a b c d&gt;</code></pre></p>","m":0,"k":"m","n":"rotate","s":{"r":"Seq:D","p":[{"t":"Cool","n":"$rotate?"},{"n":"*%_","t":"Mu"}]}},{"n":"combinations","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Seq:D"},"d":"<p>Defined as:</p><p><pre><code>multi sub    combinations($from, $of = 0..*             --&gt; Seq:D)\nmulti method combinations(List:D: Int() $of             --&gt; Seq:D)\nmulti method combinations(List:D: Iterable:D $of = 0..* --&gt; Seq:D)</code></pre></p><p>Returns a Seq with all $of-combinations of the invocant list. $of can be a numeric Range, in which case combinations of the range of item numbers it represents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item combinations&gt;). Otherwise, $of is coerced to an Int.</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)</code></pre></p><p>Above, there are three possible ways to combine the 2-items lists from the original list, which is what we receive in the output. See permutations if you want permutations instead of combinations.</p><p>With Range argument, we get both three 2-item combinations and one 3-item combination:</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2..3;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)\n# (a b c)</code></pre></p><p>If $of is negative or is larger than there are items in the given list, an empty list will be returned. If $of is zero, a 1-item list containing an empty list will be returned (there's exactly 1 way to pick no items).</p><p>The subroutine form is equivalent to the method form called on the first argument ($from), with the exception that if $from is not an Iterable, it gets coerced to an Int and combinations are made from a Range constructed with 0..^$from instead:</p><p><pre><code>.say for combinations 3, 2\n# OUTPUT:\n# (0 1)\n# (0 2)\n# (1 2)</code></pre></p><p>Note: some implementations may limit the maximum value of non-Iterable $from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems have a limit of 2²⁸-1.</p>","m":1,"k":"m"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi sub    combinations($from, $of = 0..*             --&gt; Seq:D)\nmulti method combinations(List:D: Int() $of             --&gt; Seq:D)\nmulti method combinations(List:D: Iterable:D $of = 0..* --&gt; Seq:D)</code></pre></p><p>Returns a Seq with all $of-combinations of the invocant list. $of can be a numeric Range, in which case combinations of the range of item numbers it represents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item combinations&gt;). Otherwise, $of is coerced to an Int.</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)</code></pre></p><p>Above, there are three possible ways to combine the 2-items lists from the original list, which is what we receive in the output. See permutations if you want permutations instead of combinations.</p><p>With Range argument, we get both three 2-item combinations and one 3-item combination:</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2..3;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)\n# (a b c)</code></pre></p><p>If $of is negative or is larger than there are items in the given list, an empty list will be returned. If $of is zero, a 1-item list containing an empty list will be returned (there's exactly 1 way to pick no items).</p><p>The subroutine form is equivalent to the method form called on the first argument ($from), with the exception that if $from is not an Iterable, it gets coerced to an Int and combinations are made from a Range constructed with 0..^$from instead:</p><p><pre><code>.say for combinations 3, 2\n# OUTPUT:\n# (0 1)\n# (0 2)\n# (1 2)</code></pre></p><p>Note: some implementations may limit the maximum value of non-Iterable $from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems have a limit of 2²⁸-1.</p>","n":"combinations","k":"m","s":{"p":[{"t":"Any","n":"$of"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"}},{"d":"<p>Defined as:</p><p><pre><code>multi sub    combinations($from, $of = 0..*             --&gt; Seq:D)\nmulti method combinations(List:D: Int() $of             --&gt; Seq:D)\nmulti method combinations(List:D: Iterable:D $of = 0..* --&gt; Seq:D)</code></pre></p><p>Returns a Seq with all $of-combinations of the invocant list. $of can be a numeric Range, in which case combinations of the range of item numbers it represents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item combinations&gt;). Otherwise, $of is coerced to an Int.</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)</code></pre></p><p>Above, there are three possible ways to combine the 2-items lists from the original list, which is what we receive in the output. See permutations if you want permutations instead of combinations.</p><p>With Range argument, we get both three 2-item combinations and one 3-item combination:</p><p><pre><code>.say for &lt;a b c&gt;.combinations: 2..3;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)\n# (a b c)</code></pre></p><p>If $of is negative or is larger than there are items in the given list, an empty list will be returned. If $of is zero, a 1-item list containing an empty list will be returned (there's exactly 1 way to pick no items).</p><p>The subroutine form is equivalent to the method form called on the first argument ($from), with the exception that if $from is not an Iterable, it gets coerced to an Int and combinations are made from a Range constructed with 0..^$from instead:</p><p><pre><code>.say for combinations 3, 2\n# OUTPUT:\n# (0 1)\n# (0 2)\n# (1 2)</code></pre></p><p>Note: some implementations may limit the maximum value of non-Iterable $from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems have a limit of 2²⁸-1.</p>","m":1,"s":{"p":[{"t":"Range","n":"$ofrange"},{"t":"Mu","n":"*%_"}],"r":"Seq:D"},"k":"m","n":"combinations"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    permutations(Int()    $from --&gt; Seq:D)\nmulti sub    permutations(Iterable $from --&gt; Seq:D)\nmulti method permutations(List:D:        --&gt; Seq:D)</code></pre></p><p>Returns all possible permutations of a list as a Seq of lists:</p><p><pre><code>.say for &lt;a b c&gt;.permutations;\n# OUTPUT:\n# (a b c)\n# (a c b)\n# (b a c)\n# (b c a)\n# (c a b)\n# (c b a)</code></pre></p><p>permutations treats all elements as unique, thus (1, 1, 2).permutations returns a list of 6 elements, even though there are only three distinct permutations, due to first two elements being the same.</p><p>The subroutine form behaves the same as the method form, computing permutations from its first argument $from. If $from is not an Iterable, coerces $from to an Int and picks from a Range constructed with 0..^$from:</p><p><pre><code>.say for permutations 3;\n# OUTPUT:\n# (0 1 2)\n# (0 2 1)\n# (1 0 2)\n# (1 2 0)\n# (2 0 1)\n# (2 1 0)</code></pre></p>","s":{"r":"Seq:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"permutations"},{"n":"join","d":"<p>Defined as:</p><p><pre><code>sub    join($separator, *@list)\nmethod join(List:D: $separator = \"\")</code></pre></p><p>Treats the elements of the list as strings by calling .Str on each of them, interleaves them with $separator and concatenates everything into a single string. Note that you can omit the $separator if you use the method syntax.</p><p>Example:</p><p><pre><code>join ', ', &lt;a b c&gt;;             # RESULT: «a, b, c»</code></pre></p><p>Note that the method form does not flatten sublists:</p><p><pre><code>say (1, &lt;a b c&gt;).join('|');     # OUTPUT: «1|a b c␤»</code></pre></p><p>The method form also allows you to omit the separator:</p><p><pre><code>say &lt;a b c&gt;.join;               # OUTPUT: «abc␤»</code></pre></p><p>But it behaves slurpily, flattening all arguments after the first into a single list:</p><p><pre><code>say join('|', 3, 'þ', 1+4i);    # OUTPUT: «3|þ|1+4i␤»\nsay join ', ', &lt;a b c&gt;, 'd', 'e' , 'f'; # OUTPUT: «a, b, c, d, e, f␤»</code></pre></p><p>In this case, the first list &lt;a b c is slurped and flattened, unlike what happens when join is invoked as a method.</p><p>If one of the elements of the list happens to be a Junction, then join will also return a Junction with concatenation done as much as possible:</p><p><pre><code>say (\"a\"|\"b\",\"c\",\"d\").join;     # OUTPUT: «any(acd,bcd)␤»</code></pre></p>","m":0,"s":{"p":[{"n":"$separator?","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"n":"push","k":"m"},{"m":0,"k":"m","n":"append","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"}},{"k":"m","m":0,"n":"unshift","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]}},{"k":"m","m":0,"n":"prepend","s":{"r":"Mu","p":[{"n":"|","t":"Any"}]}},{"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"n":"shift","m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"pop","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"sep"},{"n":"strings","t":"Mu"},{"t":"Any","n":"i"},{"n":"elems","t":"Any"},{"n":"initial","t":"Mu"},{"t":"Mu","n":"*%_"}]},"n":"!JUNCTIONIZE","k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"pos"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!AT_POS_SLOW","m":0}],"d":"<p><pre><code>my class List does Iterable does Positional { }\n</code></pre></p><p>List stores items sequentially and potentially lazily.</p><p>Indexes into lists and arrays start at 0 by default.</p><p>You can assign to list elements if they are containers. Use Arrays to have every value of the list stored in a container.</p><p>List implements Positional and as such provides support for subscripts.</p>","b":"C","n":"List","t":"List","mro":["Positional","Iterable","Cool"],"a":[{"n":"$!reified","k":"v","t":"Mu"},{"n":"$!todo","k":"v","t":"Mu"}]},{"k":"c","m":[{"s":{"r":"Mu","p":[{"n":"$elems","t":"int"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"reify-at-least","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"reify-until-lazy"},{"n":"reify-all","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"fully-reified","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"is-lazy"}],"mro":["Any"],"n":"List::Reifier","t":"List::Reifier","b":"A","a":[{"k":"v","t":"Mu","n":"$!reified"},{"t":"Iterator","k":"v","n":"$!current-iter"},{"t":"Mu","n":"$!future","k":"v"},{"t":"Mu","n":"$!reification-target","k":"v"}]},{"d":"<p><pre><code>role Distribution { }</code></pre></p><p>This role is an interface for objects that provide API access mapping META6 data to the files it represents. Objects that fulfill the Distribution role can be read by e.g. CompUnit::Repository::Installation. Generally a Distribution provides read access to a set of modules and metadata. These may be backed by the filesystem (Distribution::Path, Distribution::Hash) but could also read from an e.g. tar file or socket.</p>","t":"Distribution","n":"Distribution","b":"C","k":"ro","m":[{"n":"meta","k":"m","m":0,"s":{"r":"Hash","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method meta(--&gt; Hash:D) { ... }</code></pre></p><p>Returns a Hash with the representation of the metadata. Please note that an actual META6.json file does not need to exist, just a representation in that format.</p>"},{"s":{"p":[{"t":"Any","n":"$content-id"},{"t":"Mu","n":"*%_"}],"r":"IO::Handle"},"m":0,"n":"content","k":"m"}],"mro":[]},{"a":[{"k":"v","t":"Str","n":"$.dist-id"},{"t":"Str","k":"v","n":"$.repo"},{"n":"$.repo-name","t":"Str","k":"v"}],"k":"c","mro":["Associative","Any"],"t":"Distribution::Resources","b":"A","m":[{"m":1,"n":"BUILD","k":"m","s":{"p":[{"t":"Any","n":":$!dist-id"},{"t":"CompUnit::Repository","n":":$repo"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":":$!dist-id"},{"n":":$repo","t":"Any"},{"t":"Str","n":":$!repo-name"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"BUILD"},{"m":1,"s":{"p":[{"t":"Any","n":":$!dist-id"},{"n":":$!repo","t":"Str"},{"n":":$repo-name","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"BUILD","k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"from-precomp"},{"s":{"p":[{"n":"$key","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"AT-KEY","k":"m","m":0},{"m":0,"n":"Str","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"dist-id","k":"m","m":0},{"m":0,"n":"repo","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"repo-name","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"Distribution::Resources"},{"k":"c","t":"Distribution::Path","n":"Distribution::Path","d":"<p><pre><code>    class Distribution::Path does Distribution::Locally { }\n</code></pre></p><p>A Distribution implementation backed by the filesystem. It requires a META6.json file at its root.</p>","mro":["Distribution::Locally","Distribution","Any"],"b":"A","a":[{"t":"Mu","n":"$!meta","k":"v"},{"k":"v","n":"$!meta-file","t":"Mu"},{"t":"IO::Path","k":"v","n":"$.prefix"}],"m":[{"m":0,"s":{"r":"Nil","p":[{"n":":$!meta","t":"Any"},{"t":"Any","n":":$!prefix"},{"n":":$!meta-file","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILD","k":"s"},{"d":"<p><pre><code>method new(IO::Path $prefix, IO::Path :$meta-file = IO::Path)</code></pre></p><p>Creates a new Distribution::Path instance from the META6.json file found at the given $prefix, and from which all paths in the metadata will be prefixed with. :$meta-file may optionally be passed if a filename other than META6.json needs to be used.</p>","m":0,"s":{"p":[{"n":"$prefix","t":"IO::Path"},{"n":":$meta-file?","t":"IO::Path"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"new"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"meta","d":"<p><pre><code>method meta()</code></pre></p><p>Returns a Hash with the representation of the metadata.</p>","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"raku","k":"m"},{"m":0,"n":"prefix","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s","m":0}]},{"k":"c","a":[{"t":"Mu","n":"$.repo","k":"v"},{"t":"Mu","k":"v","n":"$.repo-name"},{"t":"Mu","n":"$.dist-id","k":"v"},{"t":"Mu","n":"$.key","k":"v"}],"mro":["Any"],"b":"A","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"IO","m":0,"k":"m"},{"n":"platform-library-name","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"absolute","m":0,"k":"m"},{"k":"m","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"n":"is-absolute","m":0},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"n":"relative"},{"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"n":"is-relative","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","n":"parts"},{"n":"volume","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]}},{"k":"m","n":"dirname","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0},{"m":0,"n":"basename","s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"n":"extension"},{"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"k":"m","m":0,"n":"open"},{"n":"resolve","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"m":0,"n":"slurp","k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"k":"m","n":"lines","m":0},{"k":"m","n":"comb","m":0,"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]}},{"m":0,"k":"m","s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"split"},{"n":"words","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"k":"m"},{"n":"copy","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"k":"m"},{"n":"repo","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"n":"repo-name","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"dist-id","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"key"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"t":"Distribution::Resource","n":"Distribution::Resource"},{"d":"<p><pre><code>role Distribution::Locally does Distribution { }</code></pre></p><p>Provides read access to specific files pointed at by a distributions metadata, providing the Distribution#method_content method for Distribution::Path and Distribution::Hash.</p>","a":[{"n":"$.prefix","k":"v","t":"IO::Path"}],"m":[{"n":"content","m":0,"k":"m","s":{"p":[{"t":"Any","n":"$address"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"k":"ro","n":"Distribution::Locally","b":"C","t":"Distribution::Locally","mro":["Distribution"]},{"k":"c","a":[{"k":"v","n":"$!meta","t":"Mu"},{"t":"IO::Path","n":"$.prefix","k":"v"}],"mro":["Distribution::Locally","Distribution","Any"],"m":[{"k":"s","s":{"p":[{"n":":$!meta","t":"Any"},{"t":"Any","n":":$!prefix"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"BUILD","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"$hash","t":"Any"},{"t":"Any","n":":$prefix"},{"n":"*%_","t":"Mu"}]},"n":"new","m":0,"d":"<p><pre><code>method new($hash, :$prefix)</code></pre></p><p>Creates a new Distribution::Hash instance from the metadata contained in $hash. All paths in the metadata will be prefixed with :$prefix.</p>"},{"d":"<p><pre><code>method meta()</code></pre></p><p>Returns a Hash with the representation of the metadata.</p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"meta","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"raku"},{"k":"m","m":0,"n":"prefix","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"b":"A","d":"<p><pre><code>    class Distribution::Hash does Distribution::Locally { }\n</code></pre></p><p>A Distribution implementation backed by the filesystem. It does not require a META6.json file, essentially providing a lower level Distribution::Path.</p>","t":"Distribution::Hash","n":"Distribution::Hash"},{"t":"ProtocolType","n":"ProtocolType","k":"e"},{"n":"ProtocolType::PROTO_UDP","k":"e","t":"ProtocolType"},{"n":"ProtocolType::PROTO_TCP","t":"ProtocolType","k":"e"},{"t":"Sub+{is-pure}","n":"&exp","k":"v"},{"m":1,"s":{"p":[{"n":"$x","t":"Numeric"}],"r":"Mu"},"n":"exp","k":"s"},{"n":"exp","m":1,"s":{"r":"Mu","p":[{"n":"$x","t":"Numeric"},{"t":"Numeric","n":"$base"}]},"k":"s"},{"t":"Sub","k":"v","n":"&exit"},{"m":1,"s":{"r":"Mu","p":[]},"k":"s","n":"exit"},{"s":{"p":[{"n":"$status","t":"Any"}],"r":"Mu"},"n":"exit","m":1,"k":"s"},{"k":"v","t":"Sub","n":"&slurp"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Associative"}]},"n":"slurp"},{"n":"slurp","m":1,"s":{"p":[{"t":"IO::Handle","n":"$fh"},{"n":"*%_","t":"Associative"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$path"},{"t":"Any","n":":$bin!"}]},"m":1,"k":"s","n":"slurp"},{"s":{"r":"Mu","p":[{"n":"$path","t":"Any"},{"n":":$enc","t":"Any"}]},"m":1,"n":"slurp","k":"s"},{"m":1,"n":"slurp","k":"s","s":{"r":"Mu","p":[{"n":"$path","t":"Any"}]}},{"n":"Broken","t":"PromiseStatus","k":"e"},{"b":"A","m":[{"s":{"r":"Real:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"total"},{"k":"m","n":"classify-list","m":1,"s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"t":"Any","n":"list"},{"n":"*%_","t":"Mu"}]}},{"n":"classify-list","m":1,"k":"m","s":{"p":[{"n":"%test","t":"Associative"},{"n":"c","t":"Any"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Positional","n":"@test"},{"t":"Any","n":"c"}]},"m":1,"n":"classify-list","k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"t":"Positional","n":"**@list"},{"t":"Any","n":"c"}]},"n":"classify-list"},{"s":{"p":[{"n":"&test","t":"Callable"},{"n":"list","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"categorize-list"},{"m":1,"n":"categorize-list","s":{"r":"Mu","p":[{"n":"%test","t":"Associative"},{"n":"c","t":"Any"}]},"k":"m"},{"n":"categorize-list","s":{"p":[{"t":"Positional","n":"@test"},{"n":"c","t":"Any"}],"r":"Mu"},"m":1,"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"n":"**@list","t":"Positional"},{"t":"Any","n":"c"}]},"k":"m","n":"categorize-list"},{"k":"m","s":{"r":"Real:D","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"!total-positive"},{"s":{"r":"Baggy:D","p":[{"n":"type","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Mu","n":"*%_"}]},"n":"!create-from-iterator","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!WHICH","k":"m","m":0},{"s":{"p":[{"t":"Any","n":"type"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"!HASHIFY","k":"m"}],"n":"Mix","k":"c","a":[{"n":"$!WHICH","t":"ValueObjAt","k":"v"},{"k":"v","t":"Real","n":"$!total"},{"t":"Real","n":"$!total-positive","k":"v"},{"t":"Rakudo::Internals::IterationSet","n":"$!elems","k":"v"}],"d":"<p><pre><code>class Mix does Mixy { }</code></pre></p><p>A Mix is an immutable collection of distinct elements in no particular order that each have a real-number weight assigned to them. (For mutable mixes, see MixHash instead.)</p><p>Mixes are often used for performing weighted random selections - see .roll.</p><p>Objects/values of any type are allowed as mix elements. Within a Mix, items that would compare positively with the === operator are considered the same element, with a combined weight.</p><p><pre><code>my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,\n              flour =&gt; 0.275, sugar =&gt; 0.02).Mix;\n\nsay $recipe.elems;      # OUTPUT: «3␤»\nsay $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\nsay $recipe.pairs.sort; # OUTPUT: «\"butter\" =&gt; 0.22 \"flour\" =&gt; 0.275 \"sugar\" =&gt; 0.12␤»\nsay $recipe.total;      # OUTPUT: «0.615␤»\n</code></pre></p><p>Mixes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding numeric weight for keys that are elements of the mix, and 0 for keys that aren't:</p><p><pre><code>my $recipe = (butter =&gt; 0.22, sugar =&gt; 0.1,\n              flour =&gt; 0.275, sugar =&gt; 0.02).Mix;\nsay $recipe&lt;butter&gt;;     # OUTPUT: «0.22␤»\nsay $recipe&lt;sugar&gt;;      # OUTPUT: «0.12␤»\nsay $recipe&lt;chocolate&gt;;  # OUTPUT: «0␤»</code></pre></p>","mro":["Mixy","Baggy","QuantHash","Associative","Any"],"t":"Mix"},{"k":"v","n":"&callframe","t":"Sub"},{"m":0,"s":{"r":"Mu","p":[{"n":"$level?","t":"Int"}]},"n":"callframe","k":"s"},{"n":"&infix:<≠>","t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p>Numeric inequality operator.</p><p>Equivalent to !=, at codepoint U+2260 (NOT EQUAL TO).</p>"},{"n":"infix:<≠>","s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"k":"s","m":1},{"n":"infix:<≠>","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"n":"b","t":"Mu"}]},"k":"s"},{"m":1,"k":"s","s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"Bool:D"},"n":"infix:<≠>"},{"n":"infix:<≠>","s":{"r":"Bool:D","p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}]},"m":1,"k":"s"},{"k":"s","n":"infix:<≠>","m":1,"s":{"p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":[{"t":"Instant","n":"$a"},{"t":"Instant","n":"$b"}]},"m":1,"n":"infix:<≠>","k":"s"},{"m":1,"s":{"p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}],"r":"Bool:D"},"n":"infix:<≠>","k":"s"},{"m":1,"k":"s","n":"infix:<≠>","s":{"p":[{"n":"a","t":"Version"},{"t":"Version","n":"b"}],"r":"Mu"}},{"k":"c","mro":["Stringy","Rational[Int,Int]","Real","Numeric","Allomorph","Rat"],"m":[{"d":"<p><pre><code>method new(Rat $i, Str $s)</code></pre></p><p>The constructor requires both the Rat and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = RatStr.new(42.1, \"forty two and a bit\");\nsay +$f; # OUTPUT: «42.1␤»\nsay ~$f; # OUTPUT: «\"forty two and a bit\"␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"n":"$r","t":"Rat"},{"t":"Str","n":"$s"},{"t":"Mu","n":"*%_"}]},"n":"new","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method Capture(RatStr:D --&gt; Capture:D)</code></pre></p><p>Equivalent to Mu.Capture.</p>","m":0,"n":"Capture","k":"m"},{"k":"m","m":0,"d":"<p><pre><code>method Rat</code></pre></p><p>Returns the Rat value of the RatStr.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Rat"},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}],"a":[{"n":"$.numerator","k":"v","t":"Int"},{"t":"Int","k":"v","n":"$.denominator"}],"t":"RatStr","n":"RatStr","b":"C","d":"<p><pre><code>class RatStr is Rat is Str {}</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = &lt;42.1&gt;; say $f.^name; # OUTPUT: «RatStr␤»</code></pre></p><p>As a subclass of both Rat and Str, a RatStr will be accepted where either is expected. However, RatStr does not share object identity with Rat- or Str-only variants:</p><p><pre><code>my $rat-str = &lt;42.1&gt;;\nmy Rat $rat = $rat-str; # OK!\nmy Str $str = $rat-str; # OK!\nsay 42.1 ∈ &lt;42.1  55  1&gt;; # False; ∈ operator cares about object identity</code></pre></p>"},{"t":"Setty","k":"ro","a":[{"t":"Rakudo::Internals::IterationSet","n":"$!elems","k":"v"}],"mro":["QuantHash","Associative"],"b":"C","d":"<p><pre><code>role Setty does QuantHash { }</code></pre></p><p>A role for collections which make sure that each element can only appear once. See Set and SetHash.</p>","n":"Setty","m":[{"m":0,"n":"of","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method new-from-pairs(*@pairs --&gt; Setty:D)</code></pre></p><p>Constructs a Setty object from a list of Pair objects given as positional arguments:</p><p><pre><code>say Set.new-from-pairs: 'butter' =&gt; 0.22, 'salt' =&gt; 0, 'sugar' =&gt; 0.02;\n# OUTPUT: «set(butter, sugar)␤»</code></pre></p><p>Note: be sure you aren't accidentally passing the Pairs as positional arguments; the quotes around the keys in the above example are significant.</p>","n":"new-from-pairs","s":{"p":[{"t":"Positional","n":"*@pairs"},{"n":"*%_","t":"Mu"}],"r":"Setty:D"}},{"k":"m","m":0,"n":"default","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"d":"<p>Defined as:</p><p><pre><code>method default(--&gt; False)</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when trying to access an element in the Setty object which has not been previously initialized or when accessing an element which has explicitly been set to Nil or False.</p><p><pre><code>my $s1 = SetHash.new(1, 2, 3);\nsay $s1{2};                                           # OUTPUT: «True␤»\n$s1{2} = Nil;\nsay $s1{2};                                           # OUTPUT: «False␤»\n# access non initialized element\nsay $s1{4};                                           # OUTPUT: «False␤»</code></pre></p>"},{"n":"elems","m":0,"d":"<p><pre><code>method elems(--&gt; Int)</code></pre></p><p>The number of elements of the set.</p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"d":"<p><pre><code>method total(--&gt; Int)</code></pre></p><p>The total of all the values of the QuantHash object. For a Setty object, this is just the number of elements.</p>","m":0,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"n":"total","k":"m"},{"m":0,"k":"m","s":{"r":"Setty:D","p":[{"n":"type","t":"Any"},{"n":"iterator","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!create-from-iterator"},{"m":0,"n":"!HASHIFY","k":"m","s":{"p":[{"n":"type","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}]},{"n":"&infix:<⚛−=>","k":"v","t":"Sub"},{"s":{"p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"int"}],"r":"atomicint"},"n":"infix:<⚛−=>","m":1,"k":"s"},{"n":"infix:<⚛−=>","m":1,"s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"t":"Int","n":"$add"}]},"k":"s"},{"s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"Any"}]},"m":1,"n":"infix:<⚛−=>","k":"s"},{"d":"<p><pre><code>multi sub infix:&lt;gcd&gt;($a, $b --&gt; Int:D)</code></pre></p><p>Coerces both arguments to Int and returns the greatest common divisor. If one of its arguments is 0, the other is returned (when both arguments are 0, the operator returns 0).</p>","n":"&infix:<gcd>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<gcd>","k":"s","m":1,"s":{"p":[],"r":"Mu"}},{"k":"s","n":"infix:<gcd>","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"}},{"m":1,"n":"infix:<gcd>","s":{"r":"Mu","p":[{"t":"Int","n":"$x"}]},"k":"s"},{"m":1,"k":"s","n":"infix:<gcd>","s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}]}},{"k":"s","n":"infix:<gcd>","m":1,"s":{"r":"int","p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}]}},{"k":"c","mro":["Real","Numeric","Cool"],"t":"Num","b":"C","n":"π"},{"n":"&prefix:<--⚛>","k":"v","t":"Sub"},{"s":{"p":[{"t":"atomicint","n":"$target"}],"r":"atomicint"},"m":1,"n":"prefix:<--⚛>","k":"s"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&zip"},{"s":{"r":"Seq:D","p":[{"t":"Any","n":"+lol"},{"n":":&with!","t":"Callable"}]},"k":"s","m":1,"n":"zip"},{"s":{"r":"Seq:D","p":[{"t":"Any","n":"+lol"}]},"n":"zip","k":"s","m":1},{"k":"v","n":"&rotate","t":"Sub"},{"m":1,"s":{"p":[{"n":"@a","t":"Positional"}],"r":"Mu"},"n":"rotate","k":"s"},{"m":1,"s":{"p":[{"t":"Positional","n":"@a"},{"t":"Int","n":"$n"}],"r":"Mu"},"k":"s","n":"rotate"},{"k":"v","t":"Sub+{is-pure}","n":"&cosh"},{"s":{"r":"Mu","p":[{"n":"x","t":"Numeric"}]},"m":1,"k":"s","n":"cosh"},{"k":"s","s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"},"n":"cosh","m":1},{"n":"cosh","m":1,"k":"s","s":{"p":[{"n":"$x","t":"num"}],"r":"num"}},{"t":"Sub+{Precedence}","k":"v","d":"<p><pre><code>multi sub prefix:&lt;--&gt;($x is rw) is assoc&lt;non&gt;</code></pre></p><p>Decrements its argument by one and returns the updated value.</p><p><pre><code>my $x = 3;\nsay --$x;   # OUTPUT: «2␤»\nsay $x;     # OUTPUT: «2␤»</code></pre></p><p>It works by calling the pred method (for predecessor) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p>","n":"&prefix:<-->"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"$a"}]},"m":1,"k":"s","n":"prefix:<-->"},{"s":{"r":"Mu","p":[{"n":"$a","t":"Mu"}]},"m":1,"n":"prefix:<-->","k":"s"},{"k":"s","m":1,"n":"prefix:<-->","s":{"r":"Int:D","p":[{"n":"$a","t":"Int"}]}},{"n":"prefix:<-->","k":"s","s":{"r":"int","p":[{"t":"int","n":"$a"}]},"m":1},{"k":"s","m":1,"s":{"p":[{"t":"Bool","n":"$a"}],"r":"Mu"},"n":"prefix:<-->"},{"s":{"p":[{"t":"Num","n":"$a"}],"r":"Mu"},"n":"prefix:<-->","k":"s","m":1},{"m":1,"k":"s","s":{"p":[{"n":"$a","t":"Num"}],"r":"Mu"},"n":"prefix:<-->"},{"n":"prefix:<-->","m":1,"s":{"p":[{"t":"num","n":"$a"}],"r":"num"},"k":"s"},{"mro":["Associative","Iterable","Map"],"m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"clone"},{"s":{"r":"Mu","p":[{"n":"to_store","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1,"n":"STORE"},{"m":1,"s":{"r":"Mu","p":[{"n":"keys","t":"Any"},{"n":"values","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"STORE","k":"m"},{"m":1,"s":{"p":[{"t":"Any","n":"key"},{"t":"Mu","n":"bindval"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BIND-KEY","k":"m"},{"m":1,"n":"BIND-KEY","s":{"r":"Mu","p":[{"n":"key","t":"Str"},{"t":"Mu","n":"bindval"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"d":"<p>Defined as:</p><p><pre><code>method keyof()</code></pre></p><p>Returns the type constraint for the keys of the invocant. For normal hashes the method returns the coercion type (Str(Any)) while for non-string keys hashes the type used in the declaration of the Hash is returned.</p><p><pre><code>my %h1 = 'apples' =&gt; 3, 'oranges' =&gt; 7;  # (no key type specified)\nsay %h1.keyof;                           # OUTPUT: «(Str(Any))␤»\n\nmy %h2{Str} = 'oranges' =&gt; 7;            # (keys must be of type Str)\nsay %h2.keyof;                           # (Str)\n%h2{3} = 'apples';                       # throws exception\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Binding: Type check failed in binding to key; expected Str but got Int (3)␤»\n\nmy %h3{Int};                             # (this time, keys must be of type Int)\n%h3{42} = 4096;\nsay %h3.keyof;                           # (Int)</code></pre></p>","n":"keyof","k":"m"},{"n":"of","d":"<p>Defined as:</p><p><pre><code>method of()</code></pre></p><p>Returns the type constraint for the values of the invocant. By default, i.e., if no type constraint is given during declaration, the method returns (Mu).</p><p><pre><code>my %h1 = 'apples' =&gt; 3, 'oranges' =&gt; 7;  # (no type constraint specified)\nsay %h1.of;                              # OUTPUT: «(Mu)␤»\n\nmy Int %h2 = 'oranges' =&gt; 7;             # (values must be of type Int)\nsay %h2.of;                              # OUTPUT: «(Int)␤»</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"n":"name","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"default","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method default()</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when a non existing key is used to access an element in the Hash. Unless the Hash is declared as having a default value by using the is default trait the method returns the type object (Any).</p><p><pre><code>my %h1 = 'apples' =&gt; 3, 'oranges' =&gt; 7;\nsay %h1.default;                                       # OUTPUT: «(Any)␤»\nsay %h1{'bananas'};                                    # OUTPUT: «(Any)␤»\n\nmy %h2 is default(1) = 'apples' =&gt; 3, 'oranges' =&gt; 7;\nsay %h2.default;                                       # OUTPUT: «1␤»\nsay %h2{'apples'} + %h2{'bananas'};                    # OUTPUT: «4␤»</code></pre></p>","m":0},{"n":"dynamic","k":"m","d":"<p>Defined as:</p><p><pre><code>method dynamic(--&gt; Bool:D)</code></pre></p><p>Returns True if the invocant has been declared with the is dynamic trait.</p><p><pre><code>my %a;\nsay %a.dynamic;                          # OUTPUT: «False␤»\n\nmy %b is dynamic;\nsay %b.dynamic;                          # OUTPUT: «True␤»</code></pre></p><p>If you declare a variable with the * twigil is dynamic is implied.</p><p><pre><code>my %*b;\nsay %*b.dynamic;                         # OUTPUT: «True␤»</code></pre></p><p>Note that in the Scalar case you have to use the VAR method in order to get correct information.</p><p><pre><code>my $s is dynamic = %('apples' =&gt; 5);\nsay $s.dynamic;                   # OUTPUT: «False␤»  (wrong, don't do this)\nsay $s.VAR.dynamic;               # OUTPUT: «True␤»   (correct approach)</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"d":"<p>Defined as:</p><p><pre><code>multi method push(Hash:D: *@new)</code></pre></p><p>Adds the @new elements to the hash with the same semantics as hash assignment, but with three exceptions:</p>* <p>The hash isn't emptied first, i.e. old pairs are not deleted.</p><br>* <p>If a key already exists in the hash, and the corresponding value is an Array, the new value is pushed onto the array (instead of replacing it).</p><br>* <p>If a key already exists in the hash, and the corresponding value is not an Array, old and new value are both placed into an array in the place of the old value.</p><br><p>Example:</p><p><pre><code>my %h  = a =&gt; 1;\n%h.push: (a =&gt; 1);              # a =&gt; [1,1]\n%h.push: (a =&gt; 1) xx 3 ;        # a =&gt; [1,1,1,1,1]\n%h.push: (b =&gt; 3);              # a =&gt; [1,1,1,1,1], b =&gt; 3\n%h.push('c' =&gt; 4);              # a =&gt; [1,1,1,1,1], b =&gt; 3, c =&gt; 4\npush %h, 'd' =&gt; 5;              # a =&gt; [1,1,1,1,1], b =&gt; 3, c =&gt; 4, d =&gt; 5</code></pre></p><p>Please note that Pairs or colon pairs as arguments to push will be treated as extra named arguments and as such wont end up the Hash. The same applies to the sub push.</p><p><pre><code>my %h .= push(e =&gt; 6);\npush %h, f =&gt; 7;\nsay %h.perl;\n# OUTPUT: «{}␤»</code></pre></p><p>Also note that push can be used as a replacement for assignment during hash initialization very useful ways. Take for instance the case of an inverted index:</p><p><pre><code>my %wc = 'hash' =&gt; 323, 'pair' =&gt; 322, 'pipe' =&gt; 323;\n(my %inv).push: %wc.invert;\nsay %inv;                     # OUTPUT: «{322 =&gt; pair, 323 =&gt; [pipe hash]}␤»</code></pre></p><p>Note that such an initialization could also be written as</p><p><pre><code>my %wc = 'hash' =&gt; 323, 'pair' =&gt; 322, 'pipe' =&gt; 323;\nmy %inv .= push: %wc.invert;</code></pre></p><p>Note: Compared to append, push will add the given value as is, whereas append will slip it in:</p><p><pre><code>my %ha = :a[42, ]; %ha.push: \"a\" =&gt; &lt;a b c a&gt;;\nsay %ha; # OUTPUT: «{a =&gt; [42 (a b c a)]}␤»\n\nmy %hb = :a[42, ]; %hb.append: \"a\" =&gt; &lt;a b c a&gt;;\nsay %hb; # OUTPUT: «{a =&gt; [42 a b c a]}␤»</code></pre></p>","k":"m","m":0,"s":{"p":[{"n":"+values","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"push"},{"d":"<p>Defined as:</p><p><pre><code>method append(+@values)</code></pre></p><p>Append the provided Pairs or even sized list to the Hash. If a key already exists, turn the existing value into an Array and push new value onto that Array. Please note that you can't mix even sized lists and lists of Pairs. Also, bare Pairs or colon pairs will be treated as named arguments to .append.</p><p><pre><code>my %h = a =&gt; 1;\n%h.append('b', 2, 'c', 3);\n%h.append( %(d =&gt; 4) );\nsay %h;\n# OUTPUT: «{a =&gt; 1, b =&gt; 2, c =&gt; 3, d =&gt; 4}␤»\n%h.append('a', 2);\n# OUTPUT: «{{a =&gt; [1 2], b =&gt; 2, c =&gt; 3, d =&gt; 4}␤»</code></pre></p><p>Note: Compared to push, append will slip in the given value, whereas push will add it as is:</p><p><pre><code>my %hb = :a[42, ]; %hb.append: \"a\" =&gt; &lt;a b c a&gt;;\nsay %hb; # OUTPUT: «{a =&gt; [42 a b c a]}␤»\n\nmy %ha = :a[42, ]; %ha.push: \"a\" =&gt; &lt;a b c a&gt;;\nsay %ha; # OUTPUT: «{a =&gt; [42 (a b c a)]}␤»</code></pre></p>","m":0,"n":"append","k":"m","s":{"r":"Mu","p":[{"n":"+values","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method classify-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","m":1,"n":"classify-list","k":"m","s":{"p":[{"n":"&test","t":"Callable"},{"n":"list","t":"Any"},{"t":"Callable","n":":&as"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"classify-list","d":"<p>Defined as:</p><p><pre><code>multi method classify-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","s":{"p":[{"t":"Associative","n":"%test"},{"n":"c","t":"Any"}],"r":"Mu"},"m":1,"k":"m"},{"n":"classify-list","s":{"r":"Mu","p":[{"n":"@test","t":"Positional"},{"n":"c","t":"Any"}]},"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method classify-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>"},{"s":{"p":[{"t":"Callable","n":"&test"},{"n":"**@list","t":"Positional"},{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method classify-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method classify-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","n":"classify-list","m":1},{"s":{"p":[{"n":"&test","t":"Callable"},{"n":"list","t":"Any"},{"t":"Callable","n":":&as"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1,"n":"categorize-list","d":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","k":"m","s":{"r":"Mu","p":[{"t":"Associative","n":"%test"},{"t":"Any","n":"c"}]},"n":"categorize-list"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","n":"categorize-list","s":{"p":[{"t":"Positional","n":"@test"},{"t":"Any","n":"c"}],"r":"Mu"},"m":1},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&amp;mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(%mapper, *@list, :&amp;as --&gt; Hash:D)\nmulti method categorize-list(@mapper, *@list, :&amp;as --&gt; Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&amp;as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"n":"**@list","t":"Positional"},{"n":"c","t":"Any"}]},"k":"m","n":"categorize-list"},{"n":"!_append_construct","s":{"p":[{"n":"$key","t":"Mu"},{"n":"value","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m","m":0},{"s":{"p":[{"t":"Str","n":"key"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!AT_KEY_CONTAINER","k":"m","m":0},{"s":{"r":"Nil","p":[{"t":"Any","n":"map"},{"t":"Mu","n":"*%_"}]},"n":"!STORE_MAP","m":0,"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"$key"},{"t":"Mu","n":"value"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"!_push_construct"}],"d":"<p><pre><code>class Hash is Map { }</code></pre></p><p>A Hash is a mutable Map; it implements Associative through its inheritance of Map and as such provides support for looking up values using keys, providing support for associative subscripting.</p><p>Although the order of the hashes is guaranteed to be random in every single call, still successive calls to .keys and .values are guaranteed to return them in the same order:</p><p><pre><code>my %orig = :1a, :2b; my %new = :5b, :6c;\n%orig{ %new.keys } = %new.values;\nsay %orig.perl; # OUTPUT: «{:a(1), :b(5), :c(6)}␤»</code></pre></p><p>In this case, b will always be associated to 5 and c to 6; even if two successive calls to keys will return them in different order. Successive calls to any of them separately and repeatedly will always return the same order in any program invocation.</p><p>Please see the section on hash literals for different ways to declare a hash. Additionally, they can be declared using curly braces as long as these rules are followed:</p>* <p>Empty curly braces will always declare an empty hash.</p><br>* <p>A reference to $_ (even implicit) will instead declare a block.</p><br>* <p>A Pair or variable with % as the first element will declare a hash.</p><br><p><pre><code>given 3 { say WHAT {3 =&gt; 4, :b}  };     # OUTPUT: «(Hash)␤»\ngiven 3 { say WHAT {3 =&gt; 4, :b($_)} };  # OUTPUT: «(Block)␤»\ngiven 3 { say WHAT {3 =&gt; 4, :b(.Num)} };# OUTPUT: «(Block)␤»\nsay { 'a',:b(3), 'c' }.^name;           # OUTPUT: «Block␤»\n</code></pre></p><p>The next-to-last two cases are examples of the generation of Blocks in the presence of the topic variable $_. The last case does not meet the third criterium for generating a hash, and thus generates a Block.</p><p>A % in front of parentheses or square brackets will generate a Hash as long as the elements can be paired.</p><p><pre><code>say %( 'a', 3, :b(3), 'c', 3 ).^name; # OUTPUT: «Hash␤»</code></pre></p><p>Elements in this hash can be paired both sides of the Pair :b(3).</p><p><pre><code>say %(«a b c 1 2 3»).^name;           # OUTPUT: «Hash␤»</code></pre></p><p>An empty hash can be initialized either with empty curly braces or, since 6.d, %().</p><p><pre><code>say %().^name; # OUTPUT: «Hash␤»\nsay {}.^name;  # OUTPUT: «Hash␤»</code></pre></p>","k":"c","a":[{"n":"$!descriptor","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!storage"}],"t":"Hash","n":"Hash","b":"C"},{"mro":["Any"],"k":"c","n":"Metamodel::Primitives","d":"<p><pre><code>class Metamodel::Primitives {}</code></pre></p><p>Metamodel::Primitives provides low-level operations for working with types, which are otherwise only available as implementation-dependent directives. These primitives are available as class methods.</p><p>Here is an example that steals the metamodel instance from the Int class to create a custom type (usually you would create your own metaclass if you mess with something as low-level), which allows calling of just one method called why:</p><p><pre><code>my Mu $type := Metamodel::Primitives.create_type(Int.HOW, 'P6opaque');\n$type.^set_name('why oh why?');\nmy %methods =  why =&gt; sub ($) { say 42 };\nMetamodel::Primitives.install_method_cache($type, %methods, :authoritative);\n$type.why;      # 42\n$type.list;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Method::NotFound: Method 'list' not found for invocant of class 'why oh why?'␤»</code></pre></p>","b":"A","t":"Metamodel::Primitives","m":[{"k":"m","m":0,"n":"create_type","d":"<p><pre><code>method create_type(Mu $how, $repr = 'P6opaque')</code></pre></p><p>Creates and returns a new type from a metaobject $how and a representation name.</p>","s":{"p":[{"t":"Mu","n":"$how"},{"t":"Any","n":"$repr?"},{"t":"Any","n":":$mixin?"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Mu","n":"$type"},{"t":"Any","n":"$package"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method set_package(Mu $type, $package)</code></pre></p><p>Sets the package associated with the type.</p>","n":"set_package","k":"m"},{"s":{"r":"Mu","p":[{"n":"$type","t":"Mu"},{"n":"%cache","t":"Associative"},{"n":":$authoritative?","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"install_method_cache","k":"m","d":"<p><pre><code>method install_method_cache( Mu $type, %cache, :$authoritative = True)</code></pre></p><p>Installs a method cache, that is, a mapping from method names to code objects. If :authoritative is missing, or set to True, then calls of methods that do not exist in the cache will throw an exception of type X::Method::NotFound. If :authoritative is set to False, the usual fallback mechanism are tried.</p>","m":0},{"d":"<p><pre><code>method configure_type_checking( Mu $type, @cache, :$authoritative = True,   :$call_accepts = False )</code></pre></p><p>Configures the type checking for $type. @cache is a list of known types against which $type checks positively (so in a classical class-based system, the type itself and all recursive superclasses). If :authoritative is missing or True, this type will fail checks against all types not in @cache. If :call_accepts is True, the method ACCEPTS will be called for type checks against this type.</p>","m":0,"s":{"r":"Mu","p":[{"n":"$type","t":"Mu"},{"n":"@cache","t":"Positional"},{"n":":$authoritative?","t":"Any"},{"t":"Any","n":":$call_accepts?"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"configure_type_checking"},{"d":"<p><pre><code>method configure_destroy(Mu $type, $destroy)</code></pre></p><p>Configures whether DESTROY methods are called (if present) when the garbage collector collects an object of this type (if $destroy is set to a true value). This comes with a performance overhead, so should only be set to a true value if necessary.</p>","s":{"p":[{"n":"$type","t":"Mu"},{"t":"Any","n":"$destroy"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"configure_destroy"},{"s":{"p":[{"t":"Mu","n":"$type"},{"n":"$configuration","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"d":"<p><pre><code>method compose_type(Mu $type, $configuration)</code></pre></p><p>Composes $type (that is, finalizes it to be ready for instantiation). See https://github.com/perl6/nqp/blob/master/docs/6model/repr-compose-protocol.markdown for what $configuration can contain (until we have better docs, sorry).</p>","n":"compose_type","k":"m"},{"d":"<p><pre><code>method rebless(Mu $object, Mu $type)</code></pre></p><p>Changes $obj to be of type $type. This only works if $type type-checks against the current type of $obj, and if the storage of $object is a subset of that of $type.</p>","k":"m","s":{"r":"Mu","p":[{"n":"$obj","t":"Mu"},{"n":"$type","t":"Mu"},{"n":"*%_","t":"Mu"}]},"n":"rebless","m":0},{"s":{"p":[{"t":"Mu","n":"obj"},{"n":"type","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is_type","m":0,"k":"m"},{"n":"set_parameterizer","m":0,"s":{"p":[{"n":"obj","t":"Mu"},{"n":"&parameterizer","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"},{"s":{"p":[{"t":"Mu","n":"obj"},{"t":"Any","n":"+parameters"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"parameterize_type"},{"n":"type_parameterized","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"obj","t":"Mu"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Mu","n":"obj"},{"n":"*%_","t":"Mu"}],"r":"List:D"},"k":"m","m":0,"n":"type_parameters"},{"s":{"p":[{"n":"obj","t":"Mu"},{"t":"Int","n":"$idx"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"type_parameter_at","k":"m","m":0}]},{"k":"c","b":"A","mro":["Callable","Code"],"m":[{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"of"},{"m":0,"n":"returns","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"add_phaser","s":{"p":[{"n":"name","t":"Str"},{"n":"&block","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"},{"k":"m","n":"fire_if_phasers","m":0,"s":{"p":[{"n":"$name","t":"Str"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"m":0,"n":"fire_phasers","k":"m","s":{"p":[{"n":"$name","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"has-phasers"},{"k":"m","s":{"r":"Mu","p":[{"n":"name","t":"Str"},{"t":"Mu","n":"*%_"}]},"n":"has-phaser","m":0},{"n":"phasers","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$name","t":"Str"},{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"WHY"},{"m":0,"s":{"r":"Nil","p":[{"t":"Any","n":"$why"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"set_why"}],"d":"<p><pre><code>class Block is Code { }</code></pre></p><p>A Block is a code object meant for small-scale code reuse. A block is created syntactically by a list of statements enclosed in curly braces.</p><p>Without an explicit signature or placeholder arguments, a block has $_ as a positional argument</p><p><pre><code>my $block = { uc $_; };\nsay $block.^name;           # OUTPUT: «Block␤»\nsay $block('hello');        # OUTPUT: «HELLO␤»</code></pre></p><p>A block can have a Signature between -&gt;  or &lt;-&gt;  and the block:</p><p><pre><code>my $add = -&gt; $a, $b = 2 { $a + $b };\nsay $add(40);               # OUTPUT: «42␤»</code></pre></p><p>If the signature is introduced with &lt;-&gt; , then the parameters are marked as rw by default: </p><p><pre><code>my $swap = &lt;-&gt; $a, $b { ($a, $b) = ($b, $a) };\nmy ($a, $b) = (2, 4);\n$swap($a, $b);\nsay $a;                     # OUTPUT: «4␤»</code></pre></p><p>Blocks that aren't of type Routine (which is a subclass of Block) are transparent to return.</p><p><pre><code>sub f() {\n    say &lt;a b c&gt;.map: { return 42 };\n                   #   ^^^^^^   exits &amp;f, not just the block\n}</code></pre></p><p>The last statement is the implicit return value of the block.</p><p><pre><code>say {1}.(); # OUTPUT: «1␤»</code></pre></p><p>Bare blocks are automatically executed in the order they appear:</p><p><pre><code>say 1;                # OUTPUT: «1␤»\n{\n    say 2;            # OUTPUT: «2␤»; executed directly, not a Block object\n}\nsay 3;                # OUTPUT: «3␤»</code></pre></p>","t":"Block","a":[{"t":"Mu","n":"$!why","k":"v"},{"n":"$!do","t":"Code","k":"v"},{"n":"$!signature","t":"Signature","k":"v"},{"k":"v","t":"List","n":"@!compstuff"}],"n":"Block"},{"t":"Sub","n":"&circumfix:<[ ]>","k":"v"},{"m":1,"n":"circumfix:<[ ]>","s":{"p":[],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"iterable","t":"Iterable"}]},"n":"circumfix:<[ ]>","k":"s","m":1},{"n":"circumfix:<[ ]>","k":"s","s":{"r":"Mu","p":[{"n":"x","t":"Mu"}]},"m":1},{"m":[{"m":0,"n":"read-int8","k":"m","d":"<p>Defined as:</p><p><pre><code>method read-int8(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native int value for the byte at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","s":{"p":[{"n":"$offset","t":"int"},{"n":"$?","t":"Endian"},{"n":"*%_","t":"Mu"}],"r":"int"}},{"n":"read-int16","m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method read-int16(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native int value for the two bytes starting at the given position.</p>","s":{"r":"int","p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}]}},{"n":"read-int32","d":"<p>Defined as:</p><p><pre><code>method read-int32(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native int value for the four bytes starting at the given position.</p>","s":{"r":"int","p":[{"n":"$offset","t":"int"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method read-int64(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native int value for the eight bytes starting at the given position.</p>","s":{"p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}],"r":"int"},"m":0,"n":"read-int64"},{"n":"read-int128","k":"m","d":"<p>Defined as:</p><p><pre><code>method read-int128(blob8:D: uint $pos, $endian = NativeEndian --&gt; Int:D)</code></pre></p><p>Returns an integer value for the sixteen bytes starting at the given position.</p>","s":{"r":"Int","p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}]},"m":0},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method read-uint8(blob8:D: uint $pos, $endian = NativeEndian --&gt; uint)</code></pre></p><p>Returns an unsigned native integer value for the byte at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","s":{"p":[{"t":"int","n":"$offset"},{"t":"Endian","n":"$?"},{"n":"*%_","t":"Mu"}],"r":"uint"},"m":0,"n":"read-uint8"},{"n":"read-uint16","k":"m","s":{"p":[{"t":"int","n":"$offset"},{"t":"Endian","n":"$endian?"},{"t":"Mu","n":"*%_"}],"r":"uint"},"m":0,"d":"<p>Defined as:</p><p><pre><code>method read-uint16(blob8:D: uint $pos, $endian = NativeEndian --&gt; uint)</code></pre></p><p>Returns a native uint value for the two bytes starting at the given position.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method read-uint32(blob8:D: uint $pos, $endian = NativeEndian --&gt; uint)</code></pre></p><p>Returns a native uint value for the four bytes starting at the given position.</p>","m":0,"s":{"p":[{"n":"$offset","t":"int"},{"t":"Endian","n":"$endian?"},{"t":"Mu","n":"*%_"}],"r":"uint"},"k":"m","n":"read-uint32"},{"m":0,"k":"m","n":"read-uint64","d":"<p>Defined as:</p><p><pre><code>method read-uint64(blob8:D: uint $pos, $endian = NativeEndian --&gt; UInt:D)</code></pre></p><p>Returns an unsigned integer value for the eight bytes starting at the given position.</p>","s":{"p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}],"r":"uint"}},{"s":{"p":[{"n":"$offset","t":"int"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}],"r":"uint"},"n":"read-uint128","m":0,"d":"<p>Defined as:</p><p><pre><code>method read-uint128(blob8:D: uint $pos, $endian = NativeEndian --&gt; UInt:D)</code></pre></p><p>Returns an unsigned integer value for the sixteen bytes starting at the given position.</p>","k":"m"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method read-num32(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native num value for the four bytes starting at the given position.</p>","s":{"p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}],"r":"num"},"n":"read-num32","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method read-num64(blob8:D: uint $pos, $endian = NativeEndian --&gt; int)</code></pre></p><p>Returns a native num value for the eight bytes starting at the given position.</p>","m":0,"s":{"r":"num","p":[{"t":"int","n":"$offset"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}]},"n":"read-num64","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"int","n":"$pos"},{"n":"$bits","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"read-bits"},{"n":"read-ubits","k":"m","s":{"p":[{"t":"int","n":"$pos"},{"n":"$bits","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"UInt:D"},"d":"<p>Defined as:</p><p><pre><code>method read-ubits(blob8:D: uint $pos, uint $bits --&gt; UInt:D)</code></pre></p><p>Returns an unsigned integer value for the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian.</p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method Capture(Blob:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","m":0,"n":"Capture","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"Numeric","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"Int"},{"n":"bytes","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method bytes(Blob:D: --&gt; Int:D)</code></pre></p><p>Returns the number of bytes used by the elements in the buffer.</p><p><pre><code>say Blob.new([1, 2, 3]).bytes;      # OUTPUT: «3␤»\nsay blob16.new([1, 2, 3]).bytes;    # OUTPUT: «6␤»\nsay blob64.new([1, 2, 3]).bytes;    # OUTPUT: «24␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method chars(Blob:D:)</code></pre></p><p>Throws X::Buf::AsStr with chars as payload.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"chars","m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method reverse(Blob:D: --&gt; Blob:D)</code></pre></p><p>Returns a Blob with all elements in reversed order.</p><p><pre><code>say Blob.new([1, 2, 3]).reverse;    # OUTPUT: «Blob:0x&lt;03 02 01&gt;␤»\nsay blob16.new([2]).reverse;        # OUTPUT: «Blob[uint16]:0x&lt;02&gt;␤»\nsay buf32.new([16, 32]).reverse;    # OUTPUT: «Buf[uint32]:0x&lt;20 10&gt;␤»</code></pre></p>","k":"m","n":"reverse","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"join","s":{"p":[{"n":"$delim?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"contents","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"encoding"},{"s":{"p":[{"t":"Any","n":"action"},{"n":"i","t":"Any"},{"n":"got","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!fail-typecheck-element","k":"m"},{"m":0,"s":{"p":[{"n":"action","t":"Any"},{"t":"Any","n":"to"},{"t":"Any","n":"from"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!push-list","k":"m"},{"n":"!spread","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"to"},{"t":"Any","n":"from"},{"t":"Mu","n":"*%_"}]},"m":0},{"m":0,"n":"!fail-typecheck","k":"m","s":{"p":[{"n":"$action","t":"Any"},{"n":"$got","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"action","t":"Any"},{"t":"Any","n":"to"},{"n":"from","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!unshift-list"},{"s":{"p":[{"t":"Any","n":"$got"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!fail-range","k":"m","m":0}],"t":"Blob","d":"<p><pre><code>role Blob[::T = uint8] does Positional[T] does Stringy { }</code></pre></p><p>The Blob role is an immutable interface to binary types, and offers a list-like interface to lists of integers, typically unsigned integers.</p>","k":"ro","n":"Blob","mro":["Positional[T]","Stringy"],"b":"C"},{"t":"Signal","k":"e","n":"SIGURG"},{"mro":["X::Control","Exception"],"b":"A","k":"c","t":"CX::Proceed","n":"CX::Proceed","a":[{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message","k":"m"}],"d":"<p><pre><code>role CX::Proceed does X::Control { }</code></pre></p><p>A control exception to be used when proceed is used within when or default blocks.</p>"},{"k":"c","b":"A","mro":["X::Control","Exception"],"t":"CX::Last","n":"CX::Last","m":[{"m":0,"k":"m","n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"d":"<p><pre><code>role CX::Last does X::Control { }</code></pre></p><p>A control exception that is thrown when last is called.</p>","a":[{"n":"$!ex","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}]},{"k":"c","n":"CX::Return","mro":["X::Control","Exception"],"b":"A","a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"<p><pre><code>role CX::Next does X::Control { }</code></pre></p><p>A control exception to be used when return is called from within a sub.</p>","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"message","k":"m","m":0}],"t":"CX::Return"},{"m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message"}],"k":"c","mro":["X::Control","Exception"],"t":"CX::Take","b":"A","a":[{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"CX::Take","d":"<p><pre><code>role CX::Take does X::Control { }</code></pre></p><p>A control exception triggered by take.</p>"},{"d":"<p><pre><code>role CX::Emit does X::Control { }</code></pre></p><p>A control exception to be used when emit is used inside a Supply block.</p>","mro":["X::Control","Exception"],"a":[{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"k":"c","t":"CX::Emit","n":"CX::Emit","b":"A","m":[{"m":0,"k":"m","n":"message","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}}]},{"n":"CX::Succeed","mro":["X::Control","Exception"],"m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"message"}],"t":"CX::Succeed","d":"<p><pre><code>role CX::Succeed does X::Control { }</code></pre></p><p>A control exception thrown when succeed is called from a when or default block.</p>","a":[{"n":"$!ex","k":"v","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"k":"c","b":"A"},{"mro":["X::Control","Exception"],"b":"A","n":"CX::Redo","k":"c","t":"CX::Redo","a":[{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"d":"<p><pre><code>role CX::Redo does X::Control { }</code></pre></p><p>A control exception thrown when redo is called.</p>","m":[{"n":"message","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"}]},{"a":[{"t":"Mu","k":"v","n":"$!ex"},{"t":"Mu","k":"v","n":"$!bt"}],"mro":["X::Control","Exception"],"d":"<p><pre><code>role CX::Done does X::Control { }</code></pre></p><p>A control exception to be used to indicate a supply block is finished by calling done.</p>","n":"CX::Done","k":"c","t":"CX::Done","b":"A","m":[{"k":"m","n":"message","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}}]},{"t":"CX::Warn","a":[{"k":"v","n":"$.message","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"message"},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"n":"CX::Warn","k":"c","d":"<p><pre><code>role CX::Warn does X::Control { }</code></pre></p><p>A control exception triggered when warn is called to warn about any incidence.</p>","b":"A","mro":["X::Control","Exception"]},{"a":[{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","k":"v","t":"Mu"}],"t":"CX::Next","n":"CX::Next","b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"message","m":0,"k":"m"}],"mro":["X::Control","Exception"],"d":"<p><pre><code>role CX::Next does X::Control { }</code></pre></p><p>A control exception that is triggered when next is called.</p><p><pre><code>for ^10 {\n    CONTROL {\n      when CX::Next { say \"We're next\" };\n    }\n    next if $_ %% 2;\n    say \"We're in $_\";\n}\n</code></pre></p><p>This will print:</p><p><pre><code>We're next\nWe're in 1\nWe're next\nWe're in 3\nWe're next\nWe're in 5\nWe're next\nWe're in 7\nWe're next\nWe're in 9\n</code></pre></p>","k":"c"},{"k":"v","t":"Sub","n":"&lsb"},{"n":"lsb","m":1,"k":"s","s":{"p":[{"t":"Int","n":"i"}],"r":"Int:D"}},{"t":"Sub","n":"&trim-trailing","k":"v"},{"s":{"p":[{"n":"$s","t":"Cool"}],"r":"Str:D"},"n":"trim-trailing","k":"s","m":1},{"k":"e","t":"Signal","n":"SIGTRAP"},{"n":"&done","t":"Sub+{Callable[Nil]}","k":"v"},{"k":"s","s":{"r":"Nil","p":[]},"n":"done","m":0},{"t":"uint","k":"n","n":"uint"},{"n":"&trait_mod:<returns>","t":"Sub","k":"v"},{"k":"s","n":"trait_mod:<returns>","s":{"r":"Mu","p":[{"n":"$target","t":"Routine"},{"n":"$type","t":"Mu"}]},"m":1},{"t":"Sub","n":"&deepmap","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"op","t":"Any"},{"t":"Any","n":"obj"}]},"n":"deepmap"},{"n":"deepmap","m":1,"s":{"r":"Mu","p":[{"n":"op","t":"Any"},{"n":"h","t":"Associative"}]},"k":"s"},{"k":"n","n":"int8","t":"int8"},{"d":"<p><pre><code>class AST { }</code></pre></p><p>An AST or Abstract Syntax Tree is a partially processed representation of a program. ASTs are return values of the quasi quoting construct, and are typically used within macros to generate code that is inserted in the calling location of the macro.</p><p>There is no API defined for ASTs yet. Hopefully that will emerge as part of the work on macros.</p>","k":"c","n":"AST","mro":["Any"],"t":"AST","m":[{"s":{"r":"Nil","p":[{"n":":$past","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILD","k":"s","m":0},{"n":"incarnate","m":0,"s":{"r":"Mu","p":[{"n":"$quasi_context","t":"Any"},{"n":"@unquote_asts","t":"Positional"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"evaluate_unquotes","s":{"p":[{"n":"@unquote_asts","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"is_quasi_ast","m":0,"k":"m"},{"m":0,"n":"Str","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s"}],"b":"A","a":[{"k":"v","t":"Mu","n":"$!past"},{"n":"$!quasi_context","k":"v","t":"Mu"},{"t":"Mu","n":"$!Str","k":"v"}]},{"n":"&term:<now>","t":"Sub+{Callable[Instant:D]}","k":"v"},{"m":0,"s":{"r":"Instant:D","p":[]},"n":"term:<now>","k":"s"},{"d":"<p><pre><code>class Semaphore { }</code></pre></p><p>Protect your shared code, data or device access using semaphores. An example is a printer manager managing a pool of printers without the need of storing print jobs when all printers are occupied. The next job is just blocked until a printer becomes available.</p><p><pre><code>class print-manager {\n  has Array $!printers;\n  has Semaphore $!print-control;\n\n  method BUILD( Int:D :$nbr-printers ) {\n    for ^$nbr-printers -&gt; $pc {\n      $!printers[$pc] = { :name{\"printer-$pc\"} };\n    }\n\n    $!print-control .= new($nbr-printers);\n  }\n\n  method find-available-printer-and-print-it($job) { say \"Is printed!\"; }\n\n  method print( $print-job ) {\n    $!print-control.acquire;\n\n    self.find-available-printer-and-print-it($print-job);\n\n    $!print-control.release;\n  }\n}</code></pre></p><p>Another example is a protection around code updating sensitive data. In such a case the semaphore is typically initialized to 1.</p><p>It is important to have a release on every exit of your program! While this is obvious, it is easy to fall in traps such as throwing an exception caused by some event. When the program dies there is no problem. When the exception is caught your program might eventually come back to the acquire method and will hang indefinitely.</p>","mro":["Any"],"m":[{"m":0,"k":"m","d":"<p><pre><code>method new( int $permits )</code></pre></p><p>Initialize the semaphore with the number of permitted accesses. E.g. when set to 2, program threads can pass the acquire method twice until it blocks on the third time acquire is called.</p>","n":"new","s":{"p":[{"n":"$permits","t":"int"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","d":"<p><pre><code>method acquire()</code></pre></p><p>Acquire access. When other threads have called the method before and the number of permits are used up, the process blocks until threads passed before releases the semaphore.</p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"acquire"},{"d":"<p><pre><code>method try_acquire(--&gt; Bool)</code></pre></p><p>Same as acquire but will not block. Instead it returns True if access is permitted or False otherwise.</p>","m":0,"k":"m","s":{"r":"Bool:D","p":[{"t":"Mu","n":"*%_"}]},"n":"try_acquire"},{"n":"release","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"}],"n":"Semaphore","t":"Semaphore","k":"c","b":"A"},{"t":"int64","n":"int64","k":"n"},{"t":"Sub","n":"&atomic-inc-fetch","k":"v"},{"m":1,"s":{"p":[{"t":"atomicint","n":"$target"}],"r":"atomicint"},"k":"s","n":"atomic-inc-fetch"},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;leg&gt;(Any,   Any)\nmulti sub infix:&lt;leg&gt;(Str:D, Str:D)</code></pre></p><p>String three-way comparator. Short for less, equal or greater?.</p><p>Coerces both arguments to Str and then does a lexicographic comparison.</p><p><pre><code>say 'a' leg 'b';       # OUTPUT: «Less␤»\nsay 'a' leg 'a';       # OUTPUT: «Same␤»\nsay 'b' leg 'a';       # OUTPUT: «More␤»</code></pre></p>","k":"v","n":"&infix:<leg>"},{"n":"infix:<leg>","m":1,"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"},"k":"s"},{"s":{"r":"Order:D","p":[{"t":"Str","n":"a"},{"t":"Str","n":"b"}]},"k":"s","m":1,"n":"infix:<leg>"},{"n":"infix:<leg>","m":1,"k":"s","s":{"r":"Order:D","p":[{"t":"str","n":"$a"},{"n":"$b","t":"str"}]}},{"a":[{"n":"$.re","k":"v","t":"num"},{"t":"num","n":"$.im","k":"v"}],"k":"c","d":"<p><pre><code>class ComplexStr is Complex is Str {}</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = &lt;42+0i&gt;; say $f.^name; # OUTPUT: «ComplexStr␤»</code></pre></p><p>As a subclass of both Complex and Str, a ComplexStr will be accepted where either is expected. However, ComplexStr does not share object identity with Complex- or Str-only variants:</p><p><pre><code>my $complex-str = &lt; 42+0i &gt;;\nmy Complex $complex = $complex-str; # OK!\nmy Str     $str     = $complex-str; # OK!\nsay 42+0i ∈ &lt;42+0i  55  1&gt;; # False; ∈ operator cares about object identity</code></pre></p>","mro":["Stringy","Numeric","Allomorph","Complex"],"n":"ComplexStr","b":"C","m":[{"m":0,"n":"new","d":"<p><pre><code>method new(Complex $i, Str $s)</code></pre></p><p>The constructor requires both the Complex and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = ComplexStr.new(42+0i, \"forty two (but complicated)\");\nsay +$f; # OUTPUT: «42+0i␤»\nsay ~$f; # OUTPUT: «\"forty two (but complicated)\"␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"$c","t":"Complex"},{"n":"$s","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"Capture","d":"<p>Defined as:</p><p><pre><code>method Capture(ComplexStr:D --&gt; Capture:D)</code></pre></p><p>Equivalent to Mu.Capture.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"d":"<p><pre><code>method Complex</code></pre></p><p>Returns the Complex value of the ComplexStr.</p>","n":"Complex","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL"},{"k":"m","s":{"p":[{"n":"$target","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!has-imaginary"}],"t":"ComplexStr"},{"t":"Sub","k":"v","n":"&die"},{"m":1,"k":"s","s":{"r":"Nil","p":[]},"n":"die"},{"k":"s","s":{"p":[{"n":"$e","t":"Exception"}],"r":"Nil"},"m":1,"n":"die"},{"m":1,"n":"die","s":{"p":[{"t":"Any","n":"$payload"}],"r":"Nil"},"k":"s"},{"k":"s","s":{"p":[{"n":"cap","t":"Any"}],"r":"Nil"},"n":"die","m":1},{"m":1,"n":"die","s":{"r":"Nil","p":[{"t":"Failure","n":"$f"}]},"k":"s"},{"n":"die","m":1,"k":"s","s":{"r":"Nil","p":[{"n":"$f","t":"Failure"}]}},{"t":"Sub+{Precedence}","n":"&infix:<^…^>","k":"v"},{"m":1,"n":"infix:<^…^>","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Mu","n":"b"}]},"k":"s"},{"s":{"r":"Mu","p":[{"n":"lol","t":"Any"}]},"n":"infix:<^…^>","k":"s","m":1},{"n":"&val","t":"Sub","k":"v"},{"n":"val","m":1,"s":{"p":[{"n":"*@maybevals","t":"Positional"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"mu","t":"Mu"}]},"n":"val","m":1,"k":"s"},{"n":"val","m":1,"s":{"r":"Mu","p":[{"t":"Slip","n":"maybevals"}]},"k":"s"},{"s":{"p":[{"n":"maybevals","t":"List"}],"r":"Mu"},"m":1,"k":"s","n":"val"},{"k":"s","n":"val","m":1,"s":{"p":[{"t":"Pair","n":"ww-thing"}],"r":"Mu"}},{"s":{"p":[{"n":"one-thing","t":"Any"}],"r":"Mu"},"k":"s","m":1,"n":"val"},{"m":1,"s":{"p":[{"t":"Str","n":"$MAYBEVAL"},{"n":":$val-or-fail","t":"Any"}],"r":"Mu"},"k":"s","n":"val"},{"k":"v","t":"Sub","n":"&slip"},{"n":"slip","m":1,"s":{"p":[],"r":"Slip"},"k":"s"},{"s":{"p":[{"t":"Positional","n":"@args"}],"r":"Slip:D"},"k":"s","m":1,"n":"slip"},{"n":"slip","m":1,"s":{"p":[{"t":"Any","n":"+args"}],"r":"Slip:D"},"k":"s"},{"b":"C","m":[{"d":"<p>Defined as:</p><p><pre><code>multi method new(Real $re, Real $im --&gt; Complex:D)</code></pre></p><p>Creates a new Complex object from real and imaginary parts.</p><p><pre><code>my $complex = Complex.new(1, 1);\nsay $complex;    # OUTPUT: «1+1i␤»</code></pre></p><p>When created without arguments, both parts are considered to be zero.</p><p><pre><code>say Complex.new; # OUTPUT: «0+0i␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m","n":"new"},{"d":"<p>Defined as:</p><p><pre><code>multi method new(Real $re, Real $im --&gt; Complex:D)</code></pre></p><p>Creates a new Complex object from real and imaginary parts.</p><p><pre><code>my $complex = Complex.new(1, 1);\nsay $complex;    # OUTPUT: «1+1i␤»</code></pre></p><p>When created without arguments, both parts are considered to be zero.</p><p><pre><code>say Complex.new; # OUTPUT: «0+0i␤»</code></pre></p>","n":"new","k":"m","m":1,"s":{"p":[{"t":"Real","n":"re"},{"n":"im","t":"Real"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"reals","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method reals(Complex:D: --&gt; Positional:D)</code></pre></p><p>Returns a two-element list containing the real and imaginary parts for this value.</p><p><pre><code>say (3+5i).reals;    # OUTPUT: «(3 5)␤»</code></pre></p>","m":0,"k":"m"},{"n":"isNaN","d":"<p>Defined as:</p><p><pre><code>method isNaN(Complex:D: --&gt; Bool:D)</code></pre></p><p>Returns true if the real or imaginary part is NaN (not a number).</p><p><pre><code>say (NaN+5i).isNaN; # OUTPUT: «True␤»\nsay (7+5i).isNaN;   # OUTPUT: «False␤»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"s":{"p":[{"n":"$exception-target","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"coerce-to-real","k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Num","k":"m","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"Int"},{"n":"Rat","s":{"p":[{"n":"$epsilon?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","n":"FatRat","s":{"p":[{"n":"$epsilon?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"Complex","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method conj(Complex:D: --&gt; Complex:D)</code></pre></p><p>Returns the complex conjugate of the invocant (that is, the number with the sign of the imaginary part negated).</p><p><pre><code>say (1-4i).conj;                # OUTPUT: «1+4i␤»</code></pre></p>","m":0,"k":"m","n":"conj"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"abs","d":"<p>Defined as:</p><p><pre><code>method abs(Complex:D: --&gt; Num:D)\nmulti sub abs(Complex:D $z --&gt; Num:D)</code></pre></p><p>Returns the absolute value of the invocant (or the argument in sub form). For a given complex number $z the absolute value |$z| is defined as sqrt($z.re * $z.re + $z.im * $z.im).</p><p><pre><code>say (3+4i).abs;                 # OUTPUT: «5␤»\n                                # sqrt(3*3 + 4*4) == 5</code></pre></p>"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method polar(Complex:D: --&gt; Positional:D)</code></pre></p><p>Returns a two-element list of the polar coordinates for this value, i.e. magnitude and angle in radians.</p><p><pre><code>say (10+7i).polar; # OUTPUT: «(12.2065556157337 0.610725964389209)␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"polar"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"cis","m":0},{"n":"sqrt","d":"<p>Defined as:</p><p><pre><code>method sqrt(Complex:D: --&gt; Complex:D)</code></pre></p><p>Returns the complex square root of the invocant, i.e. the root where the real part is ≥ 0 and the imaginary part has the same sign as the imaginary part of the invocant.</p><p><pre><code>say (3-4i).sqrt;                # OUTPUT: «2-1i␤»\nsay (-3+4i).sqrt;               # OUTPUT: «1+2i␤»</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"n":"roots","s":{"p":[{"t":"Any","n":"$n"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"sin","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"asin","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"cos"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"acos"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"tan","m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"atan"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"sec","m":0},{"n":"asec","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"cosec"},{"m":0,"n":"acosec","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"cotan","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"acotan"},{"n":"sinh","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"asinh"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"cosh","k":"m"},{"n":"acosh","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"tanh"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"atanh","k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"sech"},{"k":"m","n":"asech","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"cosech","k":"m"},{"k":"m","n":"acosech","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"cotanh"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"acotanh","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method floor(Complex:D: --&gt; Complex:D)</code></pre></p><p>Returns self.re.floor + self.im.floor. That is, each of the real and imaginary parts is rounded to the highest integer not greater than the value of that part.</p><p><pre><code>say (1.2-3.8i).floor;           # OUTPUT: «1-4i␤»</code></pre></p>","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"floor"},{"d":"<p>Defined as:</p><p><pre><code>method ceiling(Complex:D: --&gt; Complex:D)</code></pre></p><p>Returns self.re.ceiling + self.im.ceiling. That is, each of the real and imaginary parts is rounded to the lowest integer not less than the value of that part.</p><p><pre><code>say (1.2-3.8i).ceiling;         # OUTPUT: «2-3i␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"ceiling"},{"d":"<p>Defined as:</p><p><pre><code>multi method round(Complex:D: --&gt; Complex:D)\nmulti method round(Complex:D: Real() $scale --&gt; Complex:D)</code></pre></p><p>With no arguments, rounds both the real and imaginary parts to the nearest integer and returns a new Complex number. If $scale is given, rounds both parts of the invocant to the nearest multiple of $scale. Uses the same algorithm as Real.round on each part of the number.</p><p><pre><code>say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\nsay (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»</code></pre></p>","n":"round","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"t":"Any","n":"$scale"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method round(Complex:D: --&gt; Complex:D)\nmulti method round(Complex:D: Real() $scale --&gt; Complex:D)</code></pre></p><p>With no arguments, rounds both the real and imaginary parts to the nearest integer and returns a new Complex number. If $scale is given, rounds both parts of the invocant to the nearest multiple of $scale. Uses the same algorithm as Real.round on each part of the number.</p><p><pre><code>say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\nsay (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»</code></pre></p>","m":1,"n":"round","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method truncate(Complex:D: --&gt; Complex:D)</code></pre></p><p>Removes the fractional part of both the real and imaginary parts of the number, using Real.truncate, and returns the result as a new Complex.</p><p><pre><code>say (1.2-3.8i).truncate;        # OUTPUT: «1-3i␤»</code></pre></p>","n":"truncate"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"narrow","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method re(Complex:D: --&gt; Real:D)</code></pre></p><p>Returns the real part of the complex number.</p><p><pre><code>say (3+5i).re;    # OUTPUT: «3␤»</code></pre></p>","m":0,"n":"re"},{"n":"im","m":0,"d":"<p>Defined as:</p><p><pre><code>method im(Complex:D: --&gt; Real:D)</code></pre></p><p>Returns the imaginary part of the complex number.</p><p><pre><code>say (3+5i).im;    # OUTPUT: «5␤»</code></pre></p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"},{"s":{"p":[{"t":"Any","n":"re"},{"t":"Any","n":"im"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!SET-SELF"}],"a":[{"t":"num","n":"$.re","k":"v"},{"k":"v","t":"num","n":"$.im"}],"t":"Complex","n":"Complex","d":"<p><pre><code>class Complex is Cool does Numeric {}</code></pre></p><p>Represents a number in the complex plane.</p><p>Complex objects are immutable.</p>","mro":["Numeric","Cool"],"k":"c"},{"d":"<p><pre><code>class Tap {}</code></pre></p><p>A Tap is a subscription to a Supply.</p><p><pre><code>my $s = Supplier.new;\nmy $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n    -&gt; $v { say \"the value is $v\" },\n    done    =&gt; { say \"Supply is done\" },\n    quit    =&gt; -&gt; $ex { say \"Supply finished with error $ex\" },\n);\n\n# later\n$tap.close;</code></pre></p>","k":"c","m":[{"k":"s","n":"BUILD","m":0,"s":{"r":"Nil","p":[{"t":"Callable","n":":&!on-close"},{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"r":"Bool","p":[{"t":"Mu","n":"*%_"}]},"n":"close","k":"m"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s","n":"BUILDALL","m":0}],"mro":["Any"],"t":"Tap","n":"Tap","a":[{"k":"v","t":"Callable","n":"&!on-close"}],"b":"A"},{"d":"<p><pre><code>multi sub infix:&lt;~&gt;(Any,   Any)\nmulti sub infix:&lt;~&gt;(Str:D, Str:D)\nmulti sub infix:&lt;~&gt;(Buf:D, Buf:D)</code></pre></p><p>This is the string concatenation operator, which coerces both arguments to Str and concatenates them. If both arguments are Buf, a combined buffer is returned.</p><p><pre><code>say 'ab' ~ 'c';     # OUTPUT: «abc␤»</code></pre></p>","n":"&infix:<~>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","n":"infix:<~>","s":{"r":"Str","p":[]}},{"k":"s","n":"infix:<~>","m":1,"s":{"p":[{"t":"Any","n":"$x"}],"r":"Str:D"}},{"n":"infix:<~>","m":1,"k":"s","s":{"p":[{"t":"Str","n":"$a"},{"n":"$b","t":"Junction"}],"r":"Mu"}},{"m":1,"n":"infix:<~>","k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"Junction"},{"t":"Str","n":"$b"}]}},{"s":{"p":[{"t":"Junction","n":"a"},{"n":"b","t":"Junction"}],"r":"Mu"},"n":"infix:<~>","k":"s","m":1},{"m":1,"k":"s","s":{"p":[{"t":"Blob","n":"a"}],"r":"Mu"},"n":"infix:<~>"},{"s":{"r":"Mu","p":[{"n":"$a","t":"Blob"},{"t":"Blob","n":"$b"}]},"n":"infix:<~>","k":"s","m":1},{"k":"s","m":1,"n":"infix:<~>","s":{"r":"str","p":[{"t":"str","n":"$a"},{"t":"str","n":"$b"}]}},{"s":{"r":"str","p":[{"n":"a","t":"Str"},{"t":"str","n":"$b"}]},"k":"s","m":1,"n":"infix:<~>"},{"s":{"r":"str","p":[{"t":"str","n":"$a"},{"t":"Str","n":"b"}]},"k":"s","n":"infix:<~>","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}],"r":"Str:D"},"n":"infix:<~>","k":"s"},{"k":"s","m":1,"n":"infix:<~>","s":{"p":[{"t":"Cool","n":"a"},{"n":"b","t":"Str"}],"r":"Str:D"}},{"k":"s","s":{"p":[{"t":"Str","n":"a"},{"n":"b","t":"Cool"}],"r":"Str:D"},"m":1,"n":"infix:<~>"},{"s":{"p":[{"t":"Cool","n":"a"},{"t":"Cool","n":"b"}],"r":"Str:D"},"m":1,"n":"infix:<~>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Str"}],"r":"Str:D"},"n":"infix:<~>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Str"},{"t":"Any","n":"b"}],"r":"Str:D"},"n":"infix:<~>","k":"s"},{"m":1,"s":{"p":[{"n":"@args","t":"Positional[str]"}],"r":"str"},"k":"s","n":"infix:<~>"},{"s":{"p":[{"n":"@args","t":"Positional"}],"r":"Mu"},"m":1,"n":"infix:<~>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Positional","n":"*@args"}]},"k":"s","m":1,"n":"infix:<~>"},{"t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub infix:&lt;(elem)&gt;($a,$b --&gt; Bool:D)\nmulti sub infix:&lt;∈&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Membership operator.</p><p>Returns True if $a is an element of $b.</p><p><pre><code>say 2 (elem) (1, 2, 3); # OUTPUT: «True␤»\nsay 4 ∈ (1, 2, 3); # OUTPUT: «False␤»\n</code></pre></p><p>∈ is equivalent to (elem), at codepoint U+2208 (ELEMENT OF).</p>","n":"&infix:<(elem)>"},{"s":{"p":[{"n":"a","t":"Str"},{"n":"b","t":"Map"}],"r":"Bool:D"},"n":"infix:<(elem)>","k":"s","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"t":"Map","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<(elem)>"},{"s":{"p":[{"n":"a","t":"Int"},{"t":"Range","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<(elem)>","m":1},{"m":1,"n":"infix:<(elem)>","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"Iterable","n":"b"}]},"k":"s"},{"k":"s","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"Iterator","n":"b"}]},"n":"infix:<(elem)>"},{"n":"infix:<(elem)>","k":"s","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"QuantHash","n":"b"}]}},{"s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"t":"Failure","n":"b"}]},"n":"infix:<(elem)>","m":1,"k":"s"},{"s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"t":"Any","n":"$"}]},"k":"s","n":"infix:<(elem)>","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]},"n":"infix:<(elem)>"},{"n":"&trim-leading","t":"Sub","k":"v"},{"k":"s","m":1,"n":"trim-leading","s":{"p":[{"n":"$s","t":"Cool"}],"r":"Str:D"}},{"mro":["Stringy","Positional[uint32]","Uni"],"t":"NFKD","b":"A","m":[{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"m":0,"n":"new"},{"n":"NFKD","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"NFKD","k":"c","d":"<p><pre><code>class NFKD is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form KD. It is created by Compatibility Decomposition. For more information on what this means, see Unicode TR15.</p>"},{"n":"&cis","k":"v","t":"Sub"},{"m":1,"k":"s","n":"cis","s":{"r":"Mu","p":[{"t":"Real","n":"$a"}]}},{"b":"C","d":"<p><pre><code>class PseudoStash is Map { }</code></pre></p><p>PseudoStash is the stash type (hanging off .WHO) that backs various pseudo-packages. So, when you do MY:: or CALLER::, that gives back a PseudoStash. In most cases, Package:: gives back a Stash. Neither of these are objects the user is expected to create by themselves, but in case you have one, you can just use it like a hash.</p><p><pre><code>my $a = 42;\nmy $b = q/$a/;\nsay MY::{$b};\n#OUTPUT: «42␤»\n</code></pre></p><p>This shows how you can use a PseudoStash to look up variables, by name, at runtime.</p>","t":"PseudoStash","m":[{"n":"new","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":":$implementation-detail"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"n":"keys"},{"n":"values","s":{"p":[{"n":":$implementation-detail","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"m":0,"k":"m"},{"s":{"p":[{"n":":$implementation-detail","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"k":"m","m":0,"n":"kv"},{"k":"m","s":{"r":"Seq:D","p":[{"n":":$implementation-detail","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"pairs","m":0},{"s":{"r":"Seq:D","p":[{"n":":$implementation-detail","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"sort"},{"s":{"r":"Int:D","p":[{"n":":$implementation-detail","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"elems","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Any","n":"$key"},{"t":"Any","n":"value"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BIND-KEY","k":"m"},{"m":0,"n":"EXISTS-KEY","k":"m","s":{"p":[{"t":"Any","n":"$key"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"a":[{"t":"Mu","k":"v","n":"$!ctx"},{"t":"int","k":"v","n":"$!mode"},{"t":"Mu","k":"v","n":"$!storage"}],"k":"c","mro":["Associative","Iterable","Map"],"n":"PseudoStash"},{"k":"v","n":"&splice","t":"Sub"},{"k":"s","n":"splice","s":{"p":[{"t":"Positional","n":"@arr"},{"n":"c","t":"Any"}],"r":"Mu"},"m":1},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<×>"},{"m":1,"s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]},"n":"infix:<×>","k":"s"},{"n":"infix:<×>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"}},{"n":"infix:<×>","m":1,"s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Real"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}],"r":"Int:D"},"n":"infix:<×>","k":"s"},{"k":"s","m":1,"n":"infix:<×>","s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}]},"k":"s","n":"infix:<×>"},{"m":1,"k":"s","s":{"p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}],"r":"num"},"n":"infix:<×>"},{"s":{"p":[{"t":"Range","n":"r"},{"n":"v","t":"Real"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<×>"},{"s":{"r":"Mu","p":[{"n":"v","t":"Real"},{"n":"r","t":"Range"}]},"m":1,"n":"infix:<×>","k":"s"},{"k":"s","m":1,"n":"infix:<×>","s":{"p":[{"t":"Rational","n":"a"},{"t":"Rational","n":"b"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"t":"Int","n":"b"}]},"k":"s","n":"infix:<×>"},{"s":{"r":"Mu","p":[{"t":"Int","n":"a"},{"n":"b","t":"Rational"}]},"n":"infix:<×>","k":"s","m":1},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Complex"},{"n":"b","t":"Complex"}],"r":"Complex:D"},"n":"infix:<×>"},{"m":1,"n":"infix:<×>","k":"s","s":{"p":[{"n":"a","t":"Complex"},{"t":"Real","n":"b"}],"r":"Complex:D"}},{"m":1,"n":"infix:<×>","s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Complex"}],"r":"Complex:D"},"k":"s"},{"n":"&unique","k":"v","t":"Sub"},{"n":"unique","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"+values","t":"Any"},{"n":"c","t":"Any"}]}},{"k":"v","n":"&first","t":"Sub"},{"m":1,"k":"s","s":{"p":[{"n":"$t","t":"Bool"},{"t":"Any","n":"|"}],"r":"Mu"},"n":"first"},{"m":1,"s":{"p":[{"n":"$test","t":"Mu"},{"n":"+values","t":"Any"},{"n":"*%a","t":"Associative"}],"r":"Mu"},"k":"s","n":"first"},{"n":"&keys","k":"v","t":"Sub"},{"m":1,"k":"s","s":{"p":[{"n":"$x","t":"Any"}],"r":"Mu"},"n":"keys"},{"t":"Sub+{is-pure}+{Precedence}","n":"&cross","k":"v"},{"k":"s","s":{"p":[{"t":"Any","n":"+lol"},{"t":"Any","n":":$with!"}],"r":"Seq:D"},"n":"cross","m":1},{"m":1,"n":"cross","s":{"r":"Seq:D","p":[{"t":"Any","n":"+lol"}]},"k":"s"},{"n":"&infix:<ge>","k":"v","d":"<p><pre><code>multi sub infix:&lt;ge&gt;(Mu,    Mu)\nmulti sub infix:&lt;ge&gt;(Str:D, Str:D)</code></pre></p><p>String greater than or equal to operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is equal to or larger than the second, as determined by lexicographic comparison.</p><p>Mnemonic: greater or equal</p>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]},"n":"infix:<ge>","k":"s","m":1},{"m":1,"n":"infix:<ge>","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"n":"infix:<ge>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Blob"},{"t":"Blob","n":"b"}],"r":"Mu"}},{"s":{"r":"Bool:D","p":[{"t":"Str","n":"a"},{"n":"b","t":"Str"}]},"m":1,"n":"infix:<ge>","k":"s"},{"k":"v","n":"&infix:«<=>»","t":"Sub+{is-pure}"},{"n":"infix:«<=>»","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]},"m":1},{"s":{"r":"Mu","p":[{"t":"Real","n":"a"},{"n":"b","t":"Real"}]},"k":"s","m":1,"n":"infix:«<=>»"},{"s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}],"r":"Mu"},"n":"infix:«<=>»","k":"s","m":1},{"n":"infix:«<=>»","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}]}},{"s":{"p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}],"r":"Mu"},"m":1,"n":"infix:«<=>»","k":"s"},{"s":{"p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}],"r":"Mu"},"m":1,"n":"infix:«<=>»","k":"s"},{"m":1,"s":{"r":"Order:D","p":[{"n":"a","t":"Rational"},{"t":"Rational","n":"b"}]},"n":"infix:«<=>»","k":"s"},{"k":"s","s":{"r":"Order:D","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Int"}]},"n":"infix:«<=>»","m":1},{"m":1,"k":"s","s":{"p":[{"t":"Int","n":"a"},{"t":"Rational","n":"b"}],"r":"Order:D"},"n":"infix:«<=>»"},{"m":1,"s":{"r":"Order:D","p":[{"n":"a","t":"Complex"},{"n":"b","t":"Complex"}]},"n":"infix:«<=>»","k":"s"},{"s":{"r":"Order:D","p":[{"n":"a","t":"Real"},{"t":"Complex","n":"b"}]},"n":"infix:«<=>»","m":1,"k":"s"},{"n":"infix:«<=>»","k":"s","m":1,"s":{"p":[{"t":"Complex","n":"a"},{"t":"Real","n":"b"}],"r":"Order:D"}},{"s":{"p":[{"n":"$a","t":"Instant"},{"t":"Instant","n":"$b"}],"r":"Order:D"},"n":"infix:«<=>»","m":1,"k":"s"},{"m":1,"n":"infix:«<=>»","k":"s","s":{"r":"Order:D","p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}]}},{"s":{"p":[{"n":"$a","t":"Date"},{"n":"$b","t":"Date"}],"r":"Order:D"},"n":"infix:«<=>»","m":1,"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"t":"Version","n":"a"},{"n":"b","t":"Version"}]},"n":"infix:«<=>»","k":"s"},{"mro":["Any"],"n":"Scalar","t":"Scalar","b":"A","d":"<p><pre><code>class Scalar {}</code></pre></p><p>A Scalar is an internal indirection which is for most purposes invisible during ordinary use of Raku. It is the default container type associated with the $ sigil. A literal Scalar may be placed around a literal value by enclosing the value in $(…). This notation will appear in the output of a .perl method in certain places where it is important to note the presence of Scalars.</p><p>When a value is assigned to a $-sigiled variable, the variable will actually bind to a Scalar, which in turn will bind to the value. When a Scalar is assigned to a $-sigiled variable, the value bound to by that Scalar will be bound to the Scalar which that variable was bound to (a new one will be created if necessary.)</p><p>In addition, Scalars delegate all method calls to the value which they contain. As such, Scalars are for the most part invisible. There is, however, one important place where Scalars have a visible impact: a Scalar will shield its content from flattening by most Raku core list operations.</p><p>A $-sigiled variable may be bound directly to a value with no intermediate Scalar using the binding operator :=. You can tell if this has been done by examining the output of the introspective pseudo-method .VAR:</p><p><pre><code>my $a = 1;\n$a.^name.say;     # OUTPUT: «Int␤»\n$a.VAR.^name.say; # OUTPUT: «Scalar␤»\nmy $b := 1;\n$b.^name.say;     # OUTPUT: «Int␤»\n$b.VAR.^name.say; # OUTPUT: «Int␤»</code></pre></p><p>This same thing happens when values are assigned to an element of an Array, however, Lists directly contain their values:</p><p><pre><code>my @a = 1, 2, 3;\n@a[0].^name.say;            # OUTPUT: «Int␤»\n@a[0].VAR.^name.say;        # OUTPUT: «Scalar␤»\n[1, 2, 3][0].^name.say;     # OUTPUT: «Int␤»\n[1, 2, 3][0].VAR.^name.say; # OUTPUT: «Scalar␤»\n(1, 2, 3)[0].^name.say;     # OUTPUT: «Int␤»\n(1, 2, 3)[0].VAR.^name.say; # OUTPUT: «Int␤»</code></pre></p><p>Array elements may be bound directly to values using := as well; however, this is discouraged as it may lead to confusion. Doing so will break exact round-tripping of .perl output – since Arrays are assumed to place Scalars around each element, Scalars are not denoted with $ in the output of Array.perl.</p><p><pre><code>[1, $(2, 3)].perl.say;     # OUTPUT: «[1, (2, 3)]␤»\n(1, $(2, 3)).perl.say;     # OUTPUT: «(1, $(2, 3))␤»</code></pre></p><p>Binding a Scalar to a $-sigiled variable replaces the existing Scalar in that variable, if any, with the given Scalar. That means more than one variable may refer to the same Scalar. Because the Scalar may be mutated, this makes it possible to alter the value of both variables by altering only one of them:</p><p><pre><code>my $a = 1;\nmy $b := $a;\n$b = 2;\n$a.say;       # OUTPUT: «2␤»</code></pre></p><p> SSA-style constants bind directly to their value with no intervening Scalar, even when assignment (=) is used. They may be forced to use a Scalar by assigning a $-sigiled variable to them, at which point, they behave entirely like $-sigiled variables.</p><p><pre><code>my \\c = 1;\nc.^name.say;             # OUTPUT: «Int␤»\nc.VAR.^name.say;         # OUTPUT: «Int␤»\nmy $a = 1;\nmy \\d = $a;              # just \"my \\d = $ = 1\" works, too\nd.^name.say;             # OUTPUT: «Int␤»\nd.VAR.^name.say;         # OUTPUT: «Scalar␤»\nd = 2;                   # ok\nc = 2;                   # fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»</code></pre></p>","m":[{"m":0,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"new","k":"m"},{"n":"name","k":"m","m":0,"d":"<p><pre><code>method name(Scalar:D: --&gt; Str)</code></pre></p><p>Returns the name associated with the container.</p><p>Example:</p><p><pre><code>my $x = 42;\nsay $x.VAR.name;                # OUTPUT: «$x»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"of","d":"<p><pre><code>method of(Scalar:D: --&gt; Mu)</code></pre></p><p>Returns the type constraint of the container.</p><p>Example:</p><p><pre><code>my Cool $x = 42;\nsay $x.VAR.of;                  # OUTPUT: «(Cool)»</code></pre></p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p><pre><code>method default(Scalar:D: --&gt; Str)</code></pre></p><p>Returns the default value associated with the container.</p><p>Example:</p><p><pre><code>my $x is default(666) = 42;\nsay $x.VAR.default;             # OUTPUT: «666»</code></pre></p>","m":0,"n":"default","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"dynamic","k":"m","d":"<p><pre><code>method dynamic(Scalar:D: --&gt; Bool)</code></pre></p><p>Returns whether the variable is visible in dynamic variable lookups.</p><p>Example:</p><p><pre><code>my $*FOO = 42;\nsay $*FOO.VAR.dynamic;          # OUTPUT: «True»</code></pre></p>","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}}],"k":"c"},{"n":"&roll","k":"v","t":"Sub"},{"n":"roll","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$n"},{"t":"Any","n":"+values"}]},"k":"s"},{"k":"c","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"Capture","k":"m","m":0}],"t":"Whatever","mro":["Any"],"b":"A","n":"Whatever","d":"<p><pre><code>class Whatever { }</code></pre></p><p>Whatever is a class whose objects don't have any explicit meaning; it gets its semantics from other routines that accept Whatever-objects as markers to do something special. Using the * literal as an operand creates a Whatever object.</p><p>Much of *'s charm comes from Whatever-currying. When * is used in term position, that is, as an operand, in combination with most operators, the compiler will transform the expression into a closure of type WhateverCode, which is actually a Block that can be used wherever Callables are accepted.</p><p><pre><code>my $c = * + 2;          # same as   -&gt; $x { $x + 2 };\nsay $c(4);              # OUTPUT: «6␤»</code></pre></p><p>Multiple * in one expression generate closures with as many arguments:</p><p><pre><code>my $c = * + *;          # same as   -&gt; $x, $y { $x + $y }</code></pre></p><p>Using * in complex expressions will also generate closures:</p><p><pre><code>my $c = 4 * * + 5;      # same as   -&gt; $x { 4 * $x + 5 }</code></pre></p><p>Calling a method on * also creates a closure:</p><p><pre><code>&lt;a b c&gt;.map: *.uc;      # same as    &lt;a b c&gt;.map: -&gt; $char { $char.uc }\n</code></pre></p><p>As mentioned before, not all operators and syntactic constructs curry * (or Whatever-stars) to WhateverCode. In the following cases, * will remain a Whatever object.</p><table class='sections'><tr><th>Exception</th><th>Example</th><th>What it does</th></tr>\n<tr><td>comma</tr><td>1, *, 2</tr><td>generates a List with a * element</tr></tr>\n<tr><td>range operators</tr><td>1 .. *</tr><td>Range.new(:from(1), :to(*));</tr></tr>\n<tr><td>series operator</tr><td>1 ... *</tr><td>infinite list</tr></tr>\n<tr><td>assignment</tr><td>$x = *</tr><td>assign * to $x</tr></tr>\n<tr><td>binding</tr><td>$x := *</tr><td>bind * to $x</tr></tr>\n<tr><td>list repetition</tr><td>1 xx *</tr><td>generates an infinite list</tr></tr>\n</table><p>The range operators are handled specially. They do not curry with Whatever-stars, but they do curry with WhateverCode</p><p><pre><code>say (1..*).^name;       # OUTPUT: «Range␤»\nsay ((1..*-1)).^name;   # OUTPUT: «WhateverCode␤»</code></pre></p><p>This allows all these constructs to work:</p><p><pre><code>.say for 1..*;          # infinite loop\n</code></pre></p><p>and</p><p><pre><code>my @a = 1..4;\nsay @a[0..*];           # OUTPUT: «(1 2 3 4)␤»\nsay @a[0..*-2];         # OUTPUT: «(1 2 3)␤»</code></pre></p><p>Because Whatever-currying is a purely syntactic compiler transform, you will get no runtime currying of stored Whatever-stars into WhateverCodes.</p><p><pre><code>my $x = *;\n$x + 2;   # Not a closure, dies because it can't coerce $x to Numeric\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Multi::NoMatch: Cannot resolve caller Numeric(Whatever: );\n# none of these signatures match:␤\n# (Mu:U \\v: *%_)»\n</code></pre></p><p>The use cases for stored Whatever-stars involve those curry-exception cases mentioned above. For example, if you want an infinite series by default.</p><p><pre><code>my $max    = potential-upper-limit() // *;\nmy $series = known-lower-limit() ... $max;\n</code></pre></p><p>A stored * will also result in the generation of a WhateverCode in the specific case of smartmatch. Note that this is not actually the stored * which is being curried, but rather the * on the left-hand side.</p><p><pre><code>my $constraint           = find-constraint() // *;\nmy $maybe-always-matcher = * ~~ $constraint;\n</code></pre></p><p>If this hypothetical find-constraint were to have found no constraint, $maybe-always-matcher would evaluate to True for anything.</p><p><pre><code>$maybe-always-matcher(555);      # True\n$maybe-always-matcher(Any);      # True\n</code></pre></p><p>HyperWhatever's functionality is similar to Whatever, except it refers to multiple values, instead of a single one.</p>"},{"k":"v","n":"&infix:<*>","t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;*&gt;(Any, Any --&gt; Numeric:D)</code></pre></p><p>Multiplication operator.</p><p>Coerces both arguments to Numeric and multiplies them. The result is of the wider type. See Numeric for details.</p>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$x?"}]},"k":"s","m":1,"n":"infix:<*>"},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"n":"infix:<*>","k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}]},"n":"infix:<*>"},{"n":"infix:<*>","s":{"r":"Int:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"k":"s","m":1},{"s":{"p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}],"r":"int"},"m":1,"n":"infix:<*>","k":"s"},{"n":"infix:<*>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}]},"m":1},{"s":{"p":[{"n":"$a","t":"num"},{"n":"$b","t":"num"}],"r":"num"},"k":"s","m":1,"n":"infix:<*>"},{"m":1,"s":{"r":"Mu","p":[{"n":"r","t":"Range"},{"t":"Real","n":"v"}]},"n":"infix:<*>","k":"s"},{"s":{"r":"Mu","p":[{"n":"v","t":"Real"},{"t":"Range","n":"r"}]},"m":1,"k":"s","n":"infix:<*>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}]},"n":"infix:<*>","k":"s","m":1},{"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Int"}]},"k":"s","n":"infix:<*>","m":1},{"k":"s","m":1,"s":{"p":[{"t":"Int","n":"a"},{"t":"Rational","n":"b"}],"r":"Mu"},"n":"infix:<*>"},{"k":"s","m":1,"s":{"r":"Complex:D","p":[{"t":"Complex","n":"a"},{"n":"b","t":"Complex"}]},"n":"infix:<*>"},{"s":{"r":"Complex:D","p":[{"t":"Complex","n":"a"},{"n":"b","t":"Real"}]},"m":1,"n":"infix:<*>","k":"s"},{"k":"s","s":{"r":"Complex:D","p":[{"t":"Real","n":"a"},{"t":"Complex","n":"b"}]},"n":"infix:<*>","m":1},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>sub infix:&lt;===&gt;(Any, Any)</code></pre></p><p>Value identity operator. Returns True if both arguments are the same object, disregarding any containerization.</p><p><pre><code>my class A { };\nmy $a = A.new;\nsay $a === $a;              # OUTPUT: «True␤»\nsay A.new === A.new;        # OUTPUT: «False␤»\nsay A === A;                # OUTPUT: «True␤»</code></pre></p><p>For value types, === behaves like eqv:</p><p><pre><code>say 'a' === 'a';            # OUTPUT: «True␤»\nsay 'a' === 'b';            # OUTPUT: «False␤»\n\nmy $b = 'a';\nsay $b === 'a';             # OUTPUT: «True␤»\n\n# different types\nsay 1 === 1.0;              # OUTPUT: «False␤»</code></pre></p><p>=== uses the WHICH method to obtain the object identity.</p><p>If you want to create a class that should act as a value type, then that class must create an instance method WHICH, that should return a ValueObjAt object that won't change for the lifetime of the object.</p>","n":"&infix:<===>","k":"v"},{"k":"s","m":1,"s":{"p":[{"t":"Any","n":"$?"}],"r":"Bool"},"n":"infix:<===>"},{"m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"k":"s","n":"infix:<===>"},{"s":{"p":[{"t":"Enumeration","n":"a"},{"t":"Enumeration","n":"b"}],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<===>"},{"m":1,"s":{"r":"Bool:D","p":[{"t":"Int","n":"$a"},{"n":"$b","t":"Int"}]},"n":"infix:<===>","k":"s"},{"n":"infix:<===>","s":{"p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}],"r":"Bool:D"},"m":1,"k":"s"},{"s":{"r":"Mu","p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}]},"n":"infix:<===>","k":"s","m":1},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"num","n":"a"},{"t":"num","n":"b"}]},"n":"infix:<===>"},{"m":1,"s":{"r":"Bool:D","p":[{"t":"Str","n":"a"},{"t":"Str","n":"b"}]},"n":"infix:<===>","k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"str","n":"$a"},{"n":"$b","t":"str"}],"r":"Bool:D"},"n":"infix:<===>"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}]},"k":"s","n":"infix:<===>"},{"s":{"p":[{"t":"Complex","n":"a"},{"t":"Complex","n":"b"}],"r":"Bool:D"},"n":"infix:<===>","m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"IntStr","n":"$a"},{"n":"$b","t":"IntStr"}],"r":"Mu"},"n":"infix:<===>"},{"m":1,"n":"infix:<===>","k":"s","s":{"r":"Mu","p":[{"t":"RatStr","n":"$a"},{"n":"$b","t":"RatStr"}]}},{"k":"s","m":1,"s":{"p":[{"n":"$a","t":"NumStr"},{"t":"NumStr","n":"$b"}],"r":"Mu"},"n":"infix:<===>"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"ComplexStr"},{"n":"$b","t":"ComplexStr"}]},"n":"infix:<===>"},{"t":"HyperConfiguration","b":"A","k":"c","n":"HyperConfiguration","a":[{"k":"v","t":"int","n":"$.batch"},{"t":"Int","k":"v","n":"$.degree"}],"mro":["Any"],"m":[{"n":"TWEAK","m":0,"s":{"p":[{"t":"Any","n":":$method"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"batch","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"degree","k":"m"},{"m":0,"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"}]},{"t":"Sub","n":"&prefix:<temp>","k":"v","d":"<p><pre><code>sub prefix:&lt;temp&gt;(Mu $a is rw)</code></pre></p><p>\"temporizes\" the variable passed as the argument. The variable begins with the same value as it had in the outer scope, but can be assigned new values in this scope. Upon exiting the scope, the variable will be restored to its original value.</p><p><pre><code>my $a = \"three\";\nsay $a; # OUTPUT: «three␤»\n{\n    temp $a;\n    say $a; # OUTPUT: «three␤»\n    $a = \"four\";\n    say $a; # OUTPUT: «four␤»\n}\nsay $a; # OUTPUT: «three␤»</code></pre></p><p>You can also assign immediately as part of the call to temp:</p><p><pre><code>temp $a = \"five\";\n</code></pre></p><p>Be warned the temp effects get removed once the block is left. If you were to access the value from, say, within a Promise after the temp was undone, you'd get the original value, not the temp one:</p><p><pre><code>my $v = \"original\";\n{\n    temp $v = \"new one\";\n    start {\n        say \"[PROMISE] Value before block is left: `$v`\";\n        sleep 1;\n        say \"[PROMISE] Block was left while we slept; value is now `$v`\";\n    }\n    sleep ½;\n    say \"About to leave the block; value is `$v`\";\n}\nsay \"Left the block; value is now `$v`\";\nsleep 2;\n\n# OUTPUT:\n# [PROMISE] Value before block is left: `new one`\n# About to leave the block; value is `new one`\n# Left the block; value is now `original`\n# [PROMISE] Block was left while we slept; value is now `original`\n</code></pre></p>"},{"k":"s","m":0,"n":"prefix:<temp>","s":{"r":"Mu","p":[{"n":"cont","t":"Mu"}]}},{"k":"e","t":"ProtocolType","n":"PROTO_TCP"},{"k":"n","t":"atomicint","n":"atomicint"},{"k":"v","n":"&infix:<(&)>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","n":"infix:<(&)>","m":1,"s":{"r":"Mu","p":[]}},{"n":"infix:<(&)>","m":1,"k":"s","s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"}},{"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Setty"}],"r":"Mu"},"n":"infix:<(&)>","k":"s","m":1},{"s":{"p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}],"r":"Mu"},"k":"s","n":"infix:<(&)>","m":1},{"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Setty","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<(&)>","k":"s"},{"k":"s","n":"infix:<(&)>","m":1,"s":{"p":[{"n":"a","t":"Setty"},{"n":"b","t":"Mixy"}],"r":"Mu"}},{"n":"infix:<(&)>","m":1,"s":{"r":"Mu","p":[{"t":"Mixy","n":"a"},{"t":"Setty","n":"b"}]},"k":"s"},{"k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}],"r":"Mu"},"n":"infix:<(&)>","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}],"r":"Mu"},"n":"infix:<(&)>","k":"s"},{"m":1,"n":"infix:<(&)>","k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}],"r":"Mu"}},{"m":1,"k":"s","n":"infix:<(&)>","s":{"r":"Mu","p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Mixy"}]}},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"t":"Any","n":"b"}]},"n":"infix:<(&)>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Baggy"}]},"k":"s","n":"infix:<(&)>","m":1},{"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}],"r":"Mu"},"n":"infix:<(&)>","k":"s","m":1},{"m":1,"n":"infix:<(&)>","k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Mixy"}],"r":"Mu"}},{"s":{"p":[{"t":"Map","n":"a"},{"t":"Map","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<(&)>","k":"s"},{"n":"infix:<(&)>","k":"s","s":{"p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}],"r":"Mu"},"m":1},{"m":1,"s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"n":"$","t":"Any"}]},"k":"s","n":"infix:<(&)>"},{"n":"infix:<(&)>","m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"+@p","t":"Positional"}]},"n":"infix:<(&)>","k":"s","m":1},{"n":"int16","t":"int16","k":"n"},{"k":"v","t":"Sub+{is-pure}","n":"&sinh"},{"n":"sinh","k":"s","m":1,"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"}},{"n":"sinh","m":1,"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"n":"sinh","k":"s"},{"k":"v","t":"Sub+{is-pure}","n":"&abs"},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"}]},"m":1,"k":"s","n":"abs"},{"k":"s","m":1,"n":"abs","s":{"p":[{"t":"Real","n":"a"}],"r":"Mu"}},{"m":1,"n":"abs","k":"s","s":{"r":"Int:D","p":[{"t":"Int","n":"a"}]}},{"m":1,"n":"abs","s":{"r":"int","p":[{"t":"int","n":"$a"}]},"k":"s"},{"s":{"p":[{"n":"a","t":"Num"}],"r":"Mu"},"m":1,"n":"abs","k":"s"},{"m":1,"s":{"p":[{"n":"$a","t":"num"}],"r":"num"},"k":"s","n":"abs"},{"k":"s","s":{"p":[{"n":"a","t":"Complex"}],"r":"Num:D"},"n":"abs","m":1},{"k":"v","t":"Sub+{is-pure}","n":"&sin"},{"n":"sin","s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"m":1,"k":"s"},{"k":"s","n":"sin","m":1,"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"}},{"n":"sin","s":{"r":"num","p":[{"n":"$x","t":"num"}]},"m":1,"k":"s"},{"n":"Parameter","d":"<p><pre><code>class Parameter { }</code></pre></p><p>Represents a parameter, for purpose of introspection.</p><p>The usual way to obtain a Parameter object is to create a signature, and call .params on it to obtain a list of the Parameters.</p><p><pre><code>my $sig   = :(Str $x);\nmy $param = $sig.params[0];\nsay $param.type;              # OUTPUT: «Str()␤»</code></pre></p><p>See Signature for more information, and also for an explanation on what most of the concepts related to parameters mean.</p>","m":[{"n":"BUILD","m":0,"s":{"p":[{"n":":$name?","t":"Str"},{"t":"Int","n":":$flags?"},{"n":":$named?","t":"Bool"},{"n":":$optional?","t":"Bool"},{"t":"Bool","n":":$mandatory?"},{"n":":$is-copy?","t":"Bool"},{"n":":$is-raw?","t":"Bool"},{"n":":$is-rw?","t":"Bool"},{"n":":$multi-invocant?","t":"Bool"},{"n":"*%args","t":"Associative"}],"r":"Nil"},"k":"s"},{"n":"name","m":0,"d":"<p>Returns the variable name, which includes all sigils and twigils. This name is used internally when applied to code, or in a declaration determines the name declared. This name is not necessarily usable by a caller – if it is, it will also appear as an alias. Often, the name will chosen descriptively as a form of self-documentation.</p><p>If the parameter is anonymous, Nil will be returned.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m"},{"k":"m","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"usage-name"},{"d":"<p>Defined as:</p><p><pre><code>method sigil(Parameter:D: --&gt; Str:D)</code></pre></p><p>Returns a string containing the parameter's sigil, for a looser definition of \"sigil\" than what is considered part of the variable's name|method name. Still returns a sigil even if the parameter is anonymous.</p><p>This \"sigil\" is actually an introspection used to help determine the normal binding style of a parameter, if it has not been altered through a trait.</p><table class='sections'><tr><th>Sigil</th><th>Will bind to</th><th>Default behavior</th></tr>\n<tr><td>$</tr><td>Scalar</tr><td>Generate new Scalar, use instead of Scalar in argument, if any</tr></tr>\n<tr><td>@</tr><td>Positional</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>@</tr><td>PositionalBindFailover</tr><td>If binding failed, call argument's .cache method, bind to result</tr></tr>\n<tr><td>%</tr><td>Associative</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>&amp;</tr><td>Callable</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>\\</tr><td>(anything)</tr><td>Bind directly to the argument, keep existing Scalar, if any</tr></tr>\n</table><p>Also, | will bind to all remaining arguments and make new Capture if needed.</p>","s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"sigil","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method twigil(Parameter:D: --&gt; Str:D)</code></pre></p><p>Returns a string containing the twigil part of the parameter's name.</p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"k":"m","n":"twigil"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m","n":"prefix"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"k":"m","n":"suffix","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"modifier","k":"m"},{"k":"m","m":0,"s":{"r":"List:D","p":[{"t":"Mu","n":"*%_"}]},"n":"constraint_list"},{"d":"<p>Returns additional constraints on the parameter (usually as an all-Junction).</p>","k":"m","n":"constraints","m":0,"s":{"r":"Junction:D","p":[{"t":"Mu","n":"*%_"}]}},{"n":"type","d":"<p>Returns the nominal type constraint of the parameter.</p>","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"coerce_type","d":"<p>Returns the coercion type of the parameter.</p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method named_names(Parameter:D: --&gt; List:D)</code></pre></p><p>Returns the list of externally usable names/aliases for a named parameter.</p>","k":"m","m":0,"s":{"r":"List:D","p":[{"n":"*%_","t":"Mu"}]},"n":"named_names"},{"d":"<p>Defined as:</p><p><pre><code>method named(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True if it's a named parameter.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named);\nsay $sig.params[0].named;                          # OUTPUT: «False␤»\nsay $sig.params[1].named;                          # OUTPUT: «True␤»</code></pre></p>","n":"named","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m"},{"m":0,"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"n":"positional","d":"<p>Defined as:</p><p><pre><code>method positional(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the parameter is positional.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named);\nsay $sig.params[0].positional;                     # OUTPUT: «True␤»\nsay $sig.params[1].positional;                     # OUTPUT: «False␤»</code></pre></p>","k":"m"},{"n":"slurpy","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"d":"<p>Defined as:</p><p><pre><code>method slurpy(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for slurpy parameters.</p>"},{"n":"optional","d":"<p>Defined as:</p><p><pre><code>method optional(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for optional parameters.</p>","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"}},{"d":"<p>Defined as:</p><p><pre><code>method raw(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for raw parameters.</p><p><pre><code>sub f($a, $b is raw, \\c) {\n    my $sig = &amp;?ROUTINE.signature;\n    for ^$sig.params.elems {\n        say $sig.params[$_].raw;\n    }\n}\nf(17, \"4711\", 42); OUTPUT: «False␤True␤True␤»</code></pre></p><p>Raw parameters bind either a variable or a value passed to it, with no decontainerization taking place. That means that if a variable was passed to it, you can assign to the parameter. This is different from rw-parameter which can only bind to variables, never to values.</p><p>This is the normal behavior for parameters declared with a sigil of '\\', which is not really a sigil insofar as it is only used on the parameter.</p><p><pre><code>sub f(\\x) {\n    x = 5;\n}\nf(my $x);   # works\nf(42);      # dies\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»</code></pre></p><p>Other parameters may become raw through use of the 'is raw' trait. These still use their sigil in code.</p><p><pre><code>sub f($x is raw) {\n    $x = 5;\n}</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"raw","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method capture(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for parameters that capture the rest of the argument list into a single Capture object.</p><p><pre><code>sub how_many_extra_positionals($!, |capture) { capture.elems.say }\nhow_many_extra_positionals(0, 1, 2, 3);                        # RESULT: «3»\nsay &amp;how_many_extra_positionals.signature.params[1].capture;   # OUTPUT: «True␤»</code></pre></p><p>Like raw parameters, Capture parameters do not force any context on the values bound to them, which is why their sigils are only used in declarations.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","m":0,"n":"capture"},{"d":"<p>Defined as:</p><p><pre><code>method rw(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for is rw parameters.</p><p><pre><code>my Signature $sig = :(Str $x is rw, Bool :$is-named);\nsay $sig.params[0].rw;                             # OUTPUT: «True␤»\nsay $sig.params[1].rw;                             # OUTPUT: «False␤»</code></pre></p>","s":{"r":"Bool:D","p":[{"t":"Mu","n":"*%_"}]},"n":"rw","m":0,"k":"m"},{"m":0,"s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"n":"onearg","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method copy(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for is copy parameters.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named is copy);\nsay $sig.params[0].copy;                           # OUTPUT: «False␤»\nsay $sig.params[1].copy;                           # OUTPUT: «True␤»</code></pre></p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"copy","k":"m"},{"m":0,"n":"readonly","k":"m","s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method readonly(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True for read-only parameters (the default).</p><p><pre><code>my Signature $sig = :(Str $x is rw, Bool :$is-named);\nsay $sig.params[0].readonly;                       # OUTPUT: «False␤»\nsay $sig.params[1].readonly;                       # OUTPUT: «True␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method invocant(Parameter:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the parameter is the invocant parameter.</p>","s":{"r":"Bool:D","p":[{"n":"*%_","t":"Mu"}]},"n":"invocant","k":"m","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","n":"multi-invocant"},{"d":"<p>Returns a closure that upon invocation returns the default value for this parameter, or Any if no default was provided.</p>","n":"default","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Code"},"k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method type_captures(Parameter:D: --&gt; List:D)</code></pre></p><p>Returns a list of variable names of type captures associated with this parameter. Type captures define a type name within the attached code, which is an alias to the type gleaned from the argument during a call.</p><p><pre><code>sub a(::T ::U $x) { T.say }\na(8);                                       # OUTPUT: «(Int)␤»\nsay &amp;a.signature.params[0].type_captures;   # OUTPUT: «(T U)␤»\nsub b($x) { $x.^name.say }\na(8);                                       # OUTPUT: «Int␤»</code></pre></p><p>The type used may change from call to call. Once they are defined, type captures can be used wherever you would use a type, even later in same the signature:</p><p><pre><code>sub c(::T $x, T $y, $z) { my T $zz = $z };\nc(4, 5, 6);          # OK\nc(4, 5, \"six\");      # Fails when assigning to $zz, wants Int not Str\nc(\"four\", 5, \"six\"); # Fails when binding $y, wants Str, not Int\n</code></pre></p><p>Type captures may be used at the same time as type constraints.</p><p><pre><code>sub d(::T Numeric $x, T $y) {};\nd(4, 5);            # OK\nd(4e0, 5e0);        # OK\nd(4e0, 5);          # Fails when binding $y\nd(\"four\", \"five\");  # Fails when binding $x\n</code></pre></p>","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"List:D"},"n":"type_captures","k":"m"},{"d":"<p>If the parameter has a sub-signature, returns a Signature object for it. Otherwise returns Any.</p>","s":{"r":"Signature","p":[{"t":"Mu","n":"*%_"}]},"n":"sub_signature","m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"$why"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"set_why","k":"m","m":0},{"m":0,"k":"m","n":"set_default","s":{"r":"Nil","p":[{"n":"$default","t":"Code"},{"t":"Mu","n":"*%_"}]}},{"n":"BUILDALL","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!flags"}],"mro":["Any"],"b":"A","k":"c","t":"Parameter","a":[{"t":"str","k":"v","n":"$!variable_name"},{"n":"@!named_names","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"@!type_captures"},{"t":"int","n":"$!flags","k":"v"},{"t":"Mu","n":"$!nominal_type","k":"v"},{"t":"List","k":"v","n":"@!post_constraints"},{"n":"$!coerce_type","k":"v","t":"Mu"},{"t":"str","k":"v","n":"$!coerce_method"},{"n":"$!sub_signature","t":"Signature","k":"v"},{"k":"v","t":"Code","n":"$!default_value"},{"n":"$!container_descriptor","k":"v","t":"Mu"},{"t":"Mu","n":"$!attr_package","k":"v"},{"n":"$!why","k":"v","t":"Mu"}]},{"t":"Sub+{is-pure}","k":"v","n":"&log"},{"s":{"p":[{"t":"Numeric","n":"$x"}],"r":"Mu"},"m":1,"n":"log","k":"s"},{"s":{"p":[{"t":"Numeric","n":"$x"},{"t":"Numeric","n":"$base"}],"r":"Mu"},"k":"s","m":1,"n":"log"},{"m":1,"s":{"p":[{"n":"$x","t":"Cool"}],"r":"Mu"},"n":"log","k":"s"},{"n":"log","s":{"r":"Mu","p":[{"t":"Cool","n":"$x"},{"t":"Cool","n":"$base"}]},"m":1,"k":"s"},{"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"n":"log","m":1,"k":"s"},{"t":"Sub+{Precedence}","k":"v","d":"<p>The orelse operator is similar to infix //, except with looser precedence and $_ aliasing.</p><p>Returns the first defined argument, or else the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as an argument if the right side is a Callable, whose count must be 0 or 1.</p><p>This operator is useful for handling Failures returned by routines since the expected value is usually defined and Failure never is:</p><p><pre><code>sub meows { ++$ &lt; 4 ?? fail 'out of meows!' !! '\uD83D\uDC31' }\n\nsub meows-processor1 { meows() orelse .return } # return handled Failure\nsub meows-processor2 { meows() orelse fail $_ } # return re-armed Failure\nsub meows-processor3 {\n    # Use non-Failure output, or else print a message that stuff's wrong\n    meows() andthen .say orelse ‘something's wrong’.say;\n}\n\nsay \"{.^name}, {.handled}\"  # OUTPUT: «Failure, True␤»\n    given meows-processor1;\nsay \"{.^name}, {.handled}\"  # OUTPUT: «Failure, False␤»\n    given meows-processor2;\nmeows-processor3;           # OUTPUT: «something's wrong␤»\nmeows-processor3;           # OUTPUT: «\uD83D\uDC31␤»</code></pre></p>","n":"&infix:<orelse>"},{"m":1,"n":"infix:<orelse>","s":{"p":[{"n":"+$","t":"Any"}],"r":"Mu"},"k":"s"},{"t":"Sub+{is-pure}","k":"v","n":"&sech"},{"s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"},"m":1,"k":"s","n":"sech"},{"k":"s","s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"n":"sech","m":1},{"n":"sech","m":1,"s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"k":"s"},{"t":"Sub","n":"&prompt","k":"v"},{"k":"s","m":1,"n":"prompt","s":{"p":[],"r":"Mu"}},{"m":1,"n":"prompt","s":{"p":[{"n":"$msg","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"e","t":"SocketType","n":"SOCK_DGRAM"},{"k":"v","n":"&sleep","t":"Sub"},{"m":1,"n":"sleep","s":{"r":"Nil","p":[]},"k":"s"},{"m":1,"k":"s","n":"sleep","s":{"p":[{"t":"Any","n":"$seconds"}],"r":"Nil"}},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∩>","k":"v"},{"k":"s","s":{"r":"Mu","p":[]},"n":"infix:<∩>","m":1},{"m":1,"k":"s","n":"infix:<∩>","s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}]},"n":"infix:<∩>","m":1,"k":"s"},{"m":1,"n":"infix:<∩>","k":"s","s":{"p":[{"t":"Setty","n":"a"},{"t":"Baggy","n":"b"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Setty"}]},"k":"s","n":"infix:<∩>"},{"k":"s","m":1,"n":"infix:<∩>","s":{"p":[{"t":"Setty","n":"a"},{"t":"Mixy","n":"b"}],"r":"Mu"}},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Setty","n":"b"}],"r":"Mu"},"n":"infix:<∩>"},{"s":{"p":[{"t":"Baggy","n":"a"},{"t":"Baggy","n":"b"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<∩>"},{"m":1,"n":"infix:<∩>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}]}},{"m":1,"n":"infix:<∩>","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Mixy"}]},"k":"s"},{"n":"infix:<∩>","k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"t":"Mixy","n":"b"}],"r":"Mu"},"m":1},{"m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Any"}]},"n":"infix:<∩>"},{"n":"infix:<∩>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Baggy","n":"b"}]}},{"n":"infix:<∩>","m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<∩>","k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Map"},{"t":"Map","n":"b"}]},"n":"infix:<∩>","k":"s"},{"n":"infix:<∩>","m":1,"s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"t":"Failure","n":"b"}]},"k":"s"},{"n":"infix:<∩>","m":1,"s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"n":"$","t":"Any"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"k":"s","n":"infix:<∩>"},{"m":1,"k":"s","n":"infix:<∩>","s":{"p":[{"t":"Positional","n":"+@p"}],"r":"Mu"}},{"n":"SIGSYS","k":"e","t":"Signal"},{"n":"&asin","k":"v","t":"Sub+{is-pure}"},{"k":"s","m":1,"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"},"n":"asin"},{"n":"asin","m":1,"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"k":"s"},{"s":{"r":"num","p":[{"t":"num","n":"$x"}]},"n":"asin","k":"s","m":1},{"t":"Sub","n":"&signal","k":"v"},{"s":{"p":[{"n":"*@signals","t":"Positional"},{"t":"Any","n":":$scheduler?"}],"r":"Mu"},"n":"signal","k":"s","m":1},{"mro":["Stringy","Cool"],"t":"Str","b":"C","k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"n":"$name","t":"str"},{"t":"Any","n":"$value"},{"t":"Any","n":"opts"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!match-cursor"},{"s":{"p":[{"n":"slash","t":"Any"},{"t":"Any","n":"cursor"},{"n":"move","t":"Any"},{"n":"post","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!match-list","k":"m","m":0},{"k":"m","s":{"p":[{"n":"$needle","t":"str"},{"t":"Any","n":"overlap"},{"n":"$start","t":"int"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!indicesicim","m":0},{"n":"!match-last","m":0,"s":{"p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"n":"move","t":"Any"},{"n":"$tail","t":"int"},{"t":"Mu","n":"*%_"}]},"n":"!match-nth-tail"},{"m":0,"k":"m","n":"!match-nth","s":{"p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"n":"move","t":"Any"},{"t":"Any","n":"post"},{"n":"$nth","t":"Any"},{"n":"%opts","t":"Associative"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"!ensure-limit-sanity","s":{"r":"Nil","p":[{"t":"Any","n":"limit"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"s":{"p":[{"t":"Any","n":"$radix"},{"t":"Any","n":"$pos"},{"t":"Mu","n":"*%_"}],"r":"Failure"},"n":"!parse-fail","k":"m"},{"s":{"r":"Numeric:D","p":[{"t":"int","n":"$radix"},{"n":"$whole","t":"Int"},{"n":"$offset","t":"int"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"!parse-rat","k":"m"},{"m":0,"n":"!ensure-split-sanity","s":{"p":[{"n":"v","t":"Any"},{"n":"k","t":"Any"},{"n":"kv","t":"Any"},{"n":"p","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"!eggify","s":{"r":"Int:D","p":[{"n":"$egg","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"n":"!match-nth-int","s":{"p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"t":"Any","n":"post"},{"t":"int","n":"$nth"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"!SUBSTR-START-OOR","k":"m","s":{"p":[{"t":"Any","n":"$from"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"p":[{"t":"str","n":"$needle"},{"n":"overlap","t":"Any"},{"t":"int","n":"$start"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!indicesim"},{"m":0,"s":{"p":[{"n":"$radix","t":"int"},{"t":"Any","n":"whole"},{"n":"$failed-at","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Numeric:D"},"k":"m","n":"!slow-parse-base"},{"n":"!hexify-at","k":"m","m":0,"s":{"p":[{"n":"$i","t":"int"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"!rakufy","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"t":"Any","n":"cursor"},{"t":"Mu","n":"*%_"}]},"n":"!match-one"},{"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Any","n":"$min"},{"t":"Any","n":"$max"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"!match-x-range"},{"m":0,"n":"!match-nth-range","s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"iterator"},{"n":"$min","t":"Any"},{"t":"Any","n":"$max"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"str","n":"$needle"},{"n":"overlap","t":"Any"},{"t":"int","n":"$start"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"!indices"},{"m":0,"s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"cursor"},{"n":"as","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!match-as-one","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"iterator","t":"Any"},{"n":"$x","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!match-x","k":"m"},{"s":{"p":[{"n":"$got","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!fail-oor","k":"m"},{"m":0,"k":"m","s":{"p":[{"n":"$chars","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!SUBSTR-CHARS-OOR"},{"m":0,"n":"!match-nth-iterator","k":"m","s":{"p":[{"t":"Any","n":"slash"},{"n":"source","t":"Any"},{"t":"Any","n":"indexes"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"!match-pattern","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"$pattern","t":"Any"},{"n":"$name","t":"str"},{"n":"$value","t":"Any"},{"n":"opts","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!combiners","m":0},{"n":"!SUBST","m":0,"s":{"p":[{"t":"Any","n":"caller_dollar_slash"},{"n":"$matcher","t":"Any"},{"t":"Any","n":"$replacement"},{"t":"Any","n":":$g"},{"t":"Any","n":":$samecase"},{"t":"Any","n":":$samespace"},{"t":"Any","n":":$samemark"},{"n":"*%options","t":"Associative"}],"r":"Mu"},"k":"m"},{"n":"!APPLY-MATCHES","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"matches","t":"Any"},{"n":"$replacement","t":"Any"},{"t":"Any","n":"cds"},{"t":"Any","n":"SDS"},{"t":"Any","n":"word_by_word"},{"t":"Any","n":"space"},{"t":"Any","n":"case"},{"t":"Any","n":"mark"},{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"$needle","t":"str"},{"t":"Any","n":"overlap"},{"n":"$start","t":"int"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!indicesic"}],"n":"CORE-SETTING-REV"},{"t":"Signal","n":"SIGINFO","k":"e"},{"a":[{"n":"$.annotations","t":"Mu","k":"v"},{"n":"$.my","t":"Mu","k":"v"}],"m":[{"s":{"p":[{"t":"Int","n":"$level?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new","m":0,"k":"m"},{"k":"m","n":"line","d":"<p><pre><code>method line()</code></pre></p><p>This is a shortcut for looking up the line annotation. For example, the following two calls are identical.</p><p><pre><code>say callframe(1).line;\nsay callframe(1).annotations&lt;line&gt;;</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method file()</code></pre></p><p>This is a shortcut for looking up the file annotation. Therefore, the following code prints True.</p><p><pre><code>my $frame = callframe(0);\nsay $frame.file eq $frame.annotations&lt;file&gt;;</code></pre></p>","k":"m","n":"file"},{"m":0,"n":"code","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method code()</code></pre></p><p>Return the callable code for the current block. When called on the object returned by callframe(0), this will be the same value found in &amp;?BLOCK.</p><p><pre><code>my $frame;\nfor ^3 { FIRST $frame = callframe; say $_ * 3 };\nsay $frame.code()\n</code></pre></p><p>The $frame variable will hold the Code for the block inside the loop in this case.</p>","k":"m"},{"s":{"p":[{"t":"Int","n":"$?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"callframe","k":"m","m":0},{"m":0,"n":"annotations","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method annotations()</code></pre></p><p>Returns a Map containing the invocants annotations, i.e. line and file. An easier way to get hold of the annotation information is to use one of the convenience methods instead.</p><p><pre><code>say callframe.annotations.^name;                   # OUTPUT: «Map␤»\nsay callframe.annotations&lt;file&gt; eq callframe.file; # OUTPUT: «True␤»</code></pre></p>","k":"m"},{"d":"<p><pre><code>method my()</code></pre></p><p>Return a Hash that names all the variables and their values associated with the lexical scope of the frame.</p><p><pre><code>sub some-value {\n    my $the-answer = 42;\n    callframe(0);\n}\n\nmy $frame = some-value();\nsay $frame.my&lt;$the-answer&gt;; # OUTPUT: «42␤»</code></pre></p>","m":0,"n":"my","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"s","n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"CallFrame","d":"<p><pre><code>class CallFrame {}</code></pre></p><p>A CallFrame will be usually captured from the current state of a program using the callframe subroutine.</p><p><pre><code>my $frame = callframe;\nsay \"The above line of code ran at {$frame.file}:{$frame.line}.\";</code></pre></p><p>With no arguments the callframe will give you frame information for the line calling callframe. The file and line annotations will be identical to those in $?FILE and $?LINE.</p><p>You may, however, pass a number to callframe to specify a different frame level. A positive number will move upward through the levels of frame. A negative number will move downward into the callframe method and class itself at the point at which they are running to construct this information for you.</p><p>The frames themselves do not necessarily match only method or subroutine calls. Perl constructs a frames for blocks and such as well, so if you need a callframe for a particular method call, do not assume it is a fixed number of levels up.</p><p>Each frame stores annotations, including the file and line annotations, which have convenience methods for accessing them directly. You can also retrieve a reference to the code block of the currently executing frame using the code method. The frame also captures all lexical variables stored with the frame, which are available by calling my on the frame object.</p><p>Here's a short example that will find the calling routine and print the package of the caller using the callframe interface.</p><p><pre><code>sub calling-frame() {\n    for 1..* -&gt; $level {\n        given callframe($level) -&gt; $frame {\n            when $frame ~~ CallFrame {\n                    next unless $frame.code ~~ Routine;\n                    say $frame.code.package;\n                    last;\n            }\n            default {\n                    say \"no calling routine or method found\";\n                    last;\n            }\n        }\n    }\n}\n\ncalling-frame;</code></pre></p><p>If you just need to trace caller information, Backtrace may provide a better means of getting it. CallFrame contains more information about a specific frame, but provides a tedious interface for enumerating a call stack.</p>","b":"A","k":"c","n":"CallFrame","mro":["Any"]},{"t":"Sub","n":"&gist","k":"v"},{"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"m":1,"n":"gist","k":"s"},{"mro":["Nil"],"b":"C","d":"<p><pre><code>class Failure is Nil { }</code></pre></p><p>A Failure is a soft or unthrown Exception, usually generated by calling &amp;fail. It acts as a wrapper around an Exception object.</p><p>Sink (void) context causes a Failure to throw, i.e. turn into a normal exception. The use fatal pragma causes this to happen in all contexts within the pragma's scope. Inside try blocks, use fatal is automatically set, and you can disable it with no fatal.</p><p>That means that Failures are generally only useful in cases of code that normally would produce an rvalue; Failures are more or less equivalent to Exceptions in code that will frequently be called in sink context (i.e., for its side-effects, such as with say).</p><p>Similarly, you should generally use &amp;fail only inside code that is normally expected to return something.</p><p>Checking a Failure for truth (with the Bool method) or definedness (with the defined method) marks the failure as handled, and causes it not to throw in sink context anymore.</p><p>You can call the handled method to check if a failure has been handled.</p><p>Calling methods on unhandled failures propagates the failure. The specification says the result is another Failure, in Rakudo it causes the failure to throw.</p><p>Because a Failure is Nil, which is undefined, a common idiom for safely executing code that may fail uses a with/else statement:</p><p><pre><code>sub may_fail( --&gt; Numeric:D ) {\n  my $value = (^10).pick || fail \"Zero is unacceptable\";\n  fail \"Odd is also not okay\" if $value % 2;\n  return $value;\n}\n\nwith may_fail() -&gt; $value { # defined, so didn't fail\n  say \"I know $value isn't zero or odd.\"\n} else { # undefined, so failed, and the Failure is the topic\n  say \"Uh-oh: {.exception.message}.\"\n}\n</code></pre></p>","n":"Failure","m":[{"n":"!throw","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"exception","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"!SET-SELF"}],"t":"Failure","a":[{"t":"Mu","k":"v","n":"$.exception"},{"n":"$.backtrace","t":"Mu","k":"v"},{"t":"int","n":"$!handled","k":"v"}],"k":"c"},{"d":"<p><pre><code>multi sub infix:&lt;div&gt;(Int:D, Int:D --&gt; Int:D)</code></pre></p><p>Integer division operator. Rounds down.</p>","n":"&infix:<div>","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Int:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"m":1,"n":"infix:<div>","k":"s"},{"m":1,"s":{"r":"int","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]},"n":"infix:<div>","k":"s"},{"d":"<p><pre><code>class Nil is Cool { }</code></pre></p><p>The value Nil may be used to fill a spot where a value would normally go, and in so doing, explicitly indicate that no value is present. It may also be used as a cheaper and less explosive alternative to a Failure. (In fact, class Failure is derived from Nil, so smartmatching Nil will also match Failure.)</p><p>The class Nil is the same exact thing as its only possible value, Nil.</p><p><pre><code>say Nil === Nil.new;        # OUTPUT: «True␤»</code></pre></p><p>Along with Failure, Nil and its sub classes may always be returned from a routine even when the routine specifies a particular return type. It may also be returned regardless of the definedness of the return type, however, Nil is considered undefined for all other purposes.</p><p><pre><code>sub a( --&gt; Int:D ) { return Nil }\na().say;                    # OUTPUT: «Nil␤»</code></pre></p><p>Nil is what is returned from empty routines or closure, or routines that use a bare return statement.</p><p><pre><code>sub a { }; a().say;         # OUTPUT: «Nil␤»\nsub b { return }; b().say;  # OUTPUT: «Nil␤»\nsay (if 1 { });             # OUTPUT: «Nil␤»\n{ ; }().say;                # OUTPUT: «Nil␤»\nsay EVAL \"\";                # OUTPUT: «Nil␤»</code></pre></p><p>In a list, Nil takes the space of one value. Iterating a Nil behaves like iteration of any non-iterable value, producing a sequence of one Nil. (When you need the other meaning, the special value Empty is available to take no spaces when inserted into list, and to return no values when iterated.)</p><p><pre><code>(1, Nil, 3).elems.say;      # OUTPUT: «3␤»\n(for Nil { $_ }).perl.say;  # OUTPUT: «(Nil,)␤»</code></pre></p><p>Any method call on Nil of a method that does not exist, and consequently, any subscripting operation, will succeed and return Nil.</p><p><pre><code>say Nil.ITotallyJustMadeThisUp;  # OUTPUT: «Nil␤»\nsay (Nil)[100];                  # OUTPUT: «Nil␤»\nsay (Nil){100};                  # OUTPUT: «Nil␤»</code></pre></p><p> When assigned to a container, the Nil value (but not any subclass of Nil) will attempt to revert the container to its default value; if no such default is declared, Raku assumes Any.</p><p>Since a hash assignment expects two elements, use Empty not Nil, e.g.</p><p><pre><code>my %h = 'a'..'b' Z=&gt; 1..*;\n# stuff happens\n%h = Empty; # %h = Nil will generate an error</code></pre></p><p>However, if the container type is constrained with :D, assigning Nil to it will immediately throw an exception. (In contrast, an instantiated Failure matches :D because it's a definite value, but will fail to match the actual nominal type unless it happens to be a parent class of Failure.) Native types can not have default values nor hold a type object. Assigning Nil to a native type container will fail with a runtime error.</p><p><pre><code>my Int $x = 42;\n$x = Nil;\n$x.say;                     # OUTPUT: «(Int)␤»\n\nsub f( --&gt; Int:D ){ Nil };  # this definedness constraint is ignored\nmy Int:D $i = f;            # this definedness constraint is not ignored, so throws\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)»\n\nsub g( --&gt; Int:D ){ fail \"oops\" }; # this definedness constraint is ignored\nmy Any:D $h = g;                   # failure object matches Any:D, so is assigned</code></pre></p><p>but</p><p><pre><code>my Int:D $j = g;\n# It will throw both exceptions:\n# Earlier failure:\n#  oops\n#   in sub g at &lt;unknown file&gt; line 1\n#   in block &lt;unit&gt; at &lt;unknown file&gt; line 1\n#\n# Final error:\n#  Type check failed in assignment to $j; expected Int:D but got Failure (Failure.new(exception...)\n#   in block &lt;unit&gt; at &lt;unknown file&gt; line 1\n</code></pre></p><p>Because an untyped variable is type Any, assigning a Nil to one will result in an (Any) type object.</p><p><pre><code>my $x = Nil;\n$x.say;          # OUTPUT: «(Any)␤»\nmy Int $y = $x;  # will throw an exception\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)␤»</code></pre></p><p>If you are looking for a variable which transforms objects into type objects when said variable appears on the right-hand side, you can type the container as Nil.</p><p><pre><code>my Nil $x;\nmy Str $s = $x;\n$s.say;          # OUTPUT: «(Str)␤»</code></pre></p><p>There is an important exception to this transforms-into-type-object rule: assigning Nil to a variable which has a default will restore that default.</p><p><pre><code>my Int $x is default(42) = -1;\nmy $y = 1;\nfor $x, $y -&gt; $val is rw { $val = Nil unless $val &gt; 0 }\n$x.say;          # OUTPUT: «42␤»</code></pre></p>","mro":["Cool"],"t":"Nil","n":"Nil","m":[{"s":{"r":"Nil","p":[{"n":"*@","t":"Positional"},{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method new(*@)</code></pre></p><p>Returns Nil</p>","m":0,"k":"m","n":"new"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"Numeric"},{"m":0,"n":"Str","k":"m","d":"<p><pre><code>method Str()</code></pre></p><p>Warns the user that they tried to stringify a Nil.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"sink","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0},{"s":{"r":"Nil","p":[{"n":"|","t":"Any"}]},"n":"AT-POS","m":0,"k":"m"},{"n":"AT-KEY","s":{"p":[{"t":"Any","n":"|"}],"r":"Nil"},"m":0,"k":"m"},{"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"BIND-POS","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"k":"m","n":"BIND-KEY","m":0},{"k":"m","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"ASSIGN-POS","m":0},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"ASSIGN-KEY"},{"k":"m","n":"STORE","m":0,"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]}},{"d":"<p><pre><code>method push(*@)</code></pre></p><p>Warns the user that they tried to push onto a Nil.</p>","k":"m","m":0,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"push"},{"n":"append","m":0,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method append(*@)</code></pre></p><p>Warns the user that they tried to append onto a Nil.</p>"},{"m":0,"d":"<p><pre><code>method unshift(*@)</code></pre></p><p>Warns the user that they tried to unshift onto a Nil.</p>","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"m","n":"unshift"},{"s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"n":"prepend","k":"m","d":"<p><pre><code>method prepend(*@)</code></pre></p><p>Warns the user that they tried to prepend onto a Nil.</p>","m":0},{"n":"FALLBACK","d":"<p><pre><code>method FALLBACK(| --&gt; Nil) {}</code></pre></p><p>The fallback method takes any arguments and always returns a Nil.</p>","s":{"r":"Nil","p":[{"n":"|","t":"Any"}]},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"ords"},{"k":"m","n":"chrs","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"n":"chop","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"chomp"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"iterator","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"Set"},{"n":"SetHash","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"Bag","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"BagHash","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"Mix","k":"m"},{"n":"MixHash","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0}],"b":"C","k":"c"},{"n":"&sort","k":"v","t":"Sub"},{"m":1,"s":{"p":[{"n":"&by","t":"Callable"},{"n":"@values","t":"Positional"}],"r":"Mu"},"n":"sort","k":"s"},{"n":"sort","m":1,"k":"s","s":{"p":[{"n":"&by","t":"Callable"},{"n":"+values","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"n":"@values","t":"Positional"}],"r":"Mu"},"m":1,"n":"sort","k":"s"},{"m":1,"s":{"p":[{"t":"Any","n":"+values"}],"r":"Mu"},"k":"s","n":"sort"},{"n":"&infix:<⚛-=>","t":"Sub","k":"v"},{"m":1,"n":"infix:<⚛-=>","s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"int"}]},"k":"s"},{"m":1,"n":"infix:<⚛-=>","s":{"p":[{"n":"$target","t":"atomicint"},{"t":"Int","n":"$add"}],"r":"atomicint"},"k":"s"},{"n":"infix:<⚛-=>","s":{"p":[{"n":"$target","t":"atomicint"},{"t":"Any","n":"$add"}],"r":"atomicint"},"m":1,"k":"s"},{"n":"&sleep-until","k":"v","t":"Sub"},{"n":"sleep-until","s":{"p":[{"n":"$until","t":"Any"}],"r":"Bool:D"},"k":"s","m":1},{"mro":["Stringy","Real","Numeric","Allomorph","Num"],"b":"C","d":"<p><pre><code>class NumStr is Num is Str { }</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = &lt;42.1e0&gt;; say $f.^name; # OUTPUT: «NumStr␤»</code></pre></p><p>As a subclass of both Num and Str, a NumStr will be accepted where either is expected. However, NumStr does not share object identity with Num- or Str-only variants:</p><p><pre><code>my $num-str = &lt;42e10&gt;;\nmy Num $num = $num-str; # OK!\nmy Str $str = $num-str; # OK!\nsay 42e10 ∈ &lt;42e10  55  1&gt;; # False; ∈ operator cares about object identity</code></pre></p>","m":[{"k":"m","n":"new","m":0,"s":{"r":"Mu","p":[{"n":"$n","t":"Num"},{"n":"$s","t":"Str"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method new(Num $i, Str $s)</code></pre></p><p>The constructor requires both the Num and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = NumStr.new(42.1e0, \"forty two and a bit\");\nsay +$f; # OUTPUT: «42.1␤»\nsay ~$f; # OUTPUT: «\"forty two and a bit\"␤»</code></pre></p>"},{"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","t":"NumStr","n":"NumStr"},{"t":"Slip","b":"C","n":"Empty","a":[{"k":"v","t":"Mu","n":"$!reified"},{"t":"Mu","n":"$!todo","k":"v"}],"mro":["Positional","Iterable","List"],"k":"c"},{"t":"Raku","a":[{"n":"$.compiler","t":"Compiler","k":"v"},{"n":"$.name","t":"Str","k":"v"},{"t":"Str","n":"$.auth","k":"v"},{"k":"v","n":"$.version","t":"Version"},{"n":"$.signature","t":"Blob","k":"v"},{"t":"Str","k":"v","n":"$.desc"}],"m":[{"n":"TWEAK","m":0,"k":"s","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"VMnames","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"DISTROnames","k":"m"},{"m":0,"n":"KERNELnames","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"version"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"compiler","m":0},{"n":"name","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"auth","k":"m"},{"m":0,"n":"signature","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"desc"},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"mro":["Systemic","Any"],"k":"c","n":"Raku","b":"A"},{"k":"v","t":"Sub","n":"&fail"},{"s":{"r":"Nil","p":[]},"m":1,"k":"s","n":"fail"},{"s":{"r":"Nil","p":[{"n":"$e","t":"Exception"}]},"n":"fail","m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Nil","p":[{"n":"$payload","t":"Any"}]},"n":"fail"},{"s":{"r":"Nil","p":[{"n":"cap","t":"Any"}]},"k":"s","m":1,"n":"fail"},{"n":"fail","s":{"p":[{"t":"Failure","n":"$f"}],"r":"Nil"},"k":"s","m":1},{"k":"s","m":1,"n":"fail","s":{"r":"Nil","p":[{"n":"$fail","t":"Failure"}]}},{"m":[{"n":"new","m":1,"k":"m","s":{"p":[{"n":"key","t":"Cool"},{"n":"value","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method new(Pair: Mu  $key, Mu  $value)\nmulti method new(Pair: Mu :$key, Mu :$value)</code></pre></p><p>Constructs a new Pair object.</p>"},{"n":"new","m":1,"s":{"p":[{"t":"Mu","n":"key"},{"t":"Mu","n":"value"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method new(Pair: Mu  $key, Mu  $value)\nmulti method new(Pair: Mu :$key, Mu :$value)</code></pre></p><p>Constructs a new Pair object.</p>"},{"m":1,"s":{"p":[{"t":"Mu","n":":$key!"},{"t":"Mu","n":":$value!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"new","d":"<p>Defined as:</p><p><pre><code>multi method new(Pair: Mu  $key, Mu  $value)\nmulti method new(Pair: Mu :$key, Mu :$value)</code></pre></p><p>Constructs a new Pair object.</p>"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"Pair"},{"d":"<p>Defined as:</p><p><pre><code>method antipair(--&gt; Pair:D)</code></pre></p><p>Returns a new Pair object with key and value exchanged.</p><p><pre><code>my $p = (6 =&gt; 'Perl').antipair;\nsay $p.key;         # OUTPUT: «Perl␤»\nsay $p.value;       # OUTPUT: «6␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"antipair"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"freeze","k":"m","d":"<p>Defined as:</p><p><pre><code>method freeze(Pair:D:)</code></pre></p><p>Makes the value of the Pair read-only, by removing it from its Scalar container, and returns it.</p><p><pre><code>my $str = \"apple\";\nmy $p = Pair.new('key', $str);\n$p.value = \"orange\";              # this works as expected\n$p.say;                           # OUTPUT: «key =&gt; orange␤»\n$p.freeze.say;                    # OUTPUT: «orange␤»\n$p.value = \"a new apple\";         # Fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Str (apple)␤»</code></pre></p><p>NOTE: this method is deprecated as of 6.d language version. Instead, create a new Pair, with a decontainerized key/value.</p><p><pre><code>$p.=Map.=head.say;                                    # OUTPUT: «orange␤»\n</code></pre></p>"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"iterator"},{"n":"fmt","k":"m","s":{"p":[{"t":"Any","n":"$format?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method fmt(Pair:D: Str:D $format --&gt; Str:D)</code></pre></p><p>Takes a format string, and returns a string the key and value parts of the Pair formatted. Here's an example:</p><p><pre><code>my $pair = :Earth(1);\nsay $pair.fmt(\"%s is %.3f AU away from the sun\")\n# OUTPUT: «Earth is 1.000 AU away from the sun␤»</code></pre></p><p>For more about format strings, see sprintf.</p>","m":0},{"n":"key","d":"<p>Defined as:</p><p><pre><code>multi method key(Pair:D:)</code></pre></p><p>Returns the key part of the Pair.</p><p><pre><code>my $p = (Perl =&gt; 6);\nsay $p.key; # OUTPUT: «Perl␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi method value(Pair:D:) is rw</code></pre></p><p>Returns the value part of the Pair.</p><p><pre><code>my $p = (Perl =&gt; 6);\nsay $p.value; # OUTPUT: «6␤»</code></pre></p>","n":"value","k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"s","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!WHICH"}],"k":"c","b":"A","d":"<p><pre><code>class Pair does Associative {}</code></pre></p><p>Consists of two parts, a key and a value. Pairs can be seen as the atomic units in Hashes, and they are also used in conjunction with named arguments and parameters.</p><p>     There are many syntaxes for creating Pairs:</p><p><pre><code>Pair.new('key', 'value'); # The canonical way\n'key' =&gt; 'value';         # this...\n:key&lt;value&gt;;              # ...means the same as this\n:key&lt;value1 value2&gt;;      # But this is  key =&gt; &lt;value1 value2&gt;\n:foo(127);                # short for  foo =&gt; 127\n:127foo;                  # the same   foo =&gt; 127</code></pre></p><p>Note that last form supports Non-ASCII numerics as well:</p><p><pre><code># use MATHEMATICAL DOUBLE-STRUCK DIGIT THREE\nsay (:\uD835\uDFDBmath-three);         # OUTPUT: «math-three =&gt; 3␤»</code></pre></p><p>You can also use an identifier-like literal as key; this will not need the quotes as long as it follows the syntax of ordinary identifiers:</p><p><pre><code>(foo =&gt; 127)              # the same   foo =&gt; 127</code></pre></p><p>Variants of this are</p><p><pre><code>:key;                     # same as   key =&gt; True\n:!key;                    # same as   key =&gt; False</code></pre></p><p>And this other variant, to be used in routine invocation</p><p><pre><code>sub colon-pair( :$key-value ) {\n    say $key-value;\n}\nmy $key-value = 'value';\ncolon-pair( :$key-value );               # OUTPUT: «value␤»\ncolon-pair( key-value =&gt; $key-value );   # OUTPUT: «value␤»\n</code></pre></p><p> Colon pairs can be chained without a comma to create a List of Pairs. Depending on context you may have to be explicit when assigning colon lists.</p><p><pre><code>sub s(*%h){ say %h.perl };\ns :a1:b2;\n# OUTPUT: «{:a1, :b2}␤»\n\nmy $manna = :a1:b2:c3;\nsay $manna.^name;\n# OUTPUT: «Pair␤»\n\n$manna = (:a1:b2:c3);\nsay $manna.^name;\n# OUTPUT: «List␤»</code></pre></p><p>Any variable can be turned into a Pair of its name and its value.</p><p><pre><code>my $bar = 10;\nmy $p   = :$bar;\nsay $p; # OUTPUT: «bar =&gt; 10␤»</code></pre></p><p>It is worth noting that when assigning a Scalar as value of a Pair the value holds the container of the value itself. This means that it is possible to change the value from outside of the Pair itself:</p><p><pre><code>my $v = 'value A';\nmy $pair = a =&gt; $v;\n$pair.say;  # OUTPUT: «a =&gt; value A␤»\n\n$v = 'value B';\n$pair.say;  # OUTPUT: «a =&gt; value B␤»\n</code></pre></p><p>Please also note that this behavior is totally unrelated to the way used to build the Pair itself (i.e., explicit usage of new, use of colon, fat arrow), as well as if the Pair is bound to a variable.</p><p>It is possible to change the above behavior forcing the Pair to remove the scalar container and to hold the effective value itself via the method freeze:</p><p><pre><code>my $v = 'value B';\nmy $pair = a =&gt; $v;\n$pair.freeze;\n$v = 'value C';\n$pair.say; # OUTPUT: «a =&gt; value B␤»\n</code></pre></p><p>As Pair implements Associative role, its value can be accessed using Associative subscription operator, however, due to Pair's singular nature, the pair's value will be only returned for the pair's key. Nil object will be returned for any other key. Subscript adverbs such as :exists can be used on Pair.</p><p><pre><code>my $pair = a =&gt; 5;\nsay $pair&lt;a&gt;;           # OUTPUT: «5␤»\nsay $pair&lt;a&gt;:exists;    # OUTPUT: «True␤»\nsay $pair&lt;no-such-key&gt;; # OUTPUT: «Nil␤»\n</code></pre></p>","mro":["Associative","Any"],"a":[{"n":"$.key","k":"v","t":"Mu"},{"t":"Mu","n":"$.value","k":"v"},{"n":"$!WHICH","t":"ObjAt","k":"v"}],"n":"Pair","t":"Pair"},{"t":"Sub","n":"&infix:«~<»","k":"v"},{"n":"infix:«~<»","k":"s","m":1,"s":{"r":"Str:D","p":[{"t":"Str","n":"a"},{"n":"b","t":"Int"}]}},{"k":"s","n":"infix:«~<»","m":1,"s":{"p":[{"n":"$a","t":"str"},{"t":"int","n":"$b"}],"r":"Mu"}},{"t":"str","n":"str","k":"n"},{"n":"&parse-names","t":"Sub","k":"v"},{"m":0,"n":"parse-names","s":{"p":[{"n":"names","t":"Str"}],"r":"Mu"},"k":"s"},{"d":"<p><pre><code>sub infix:&lt;eqv&gt;(Any, Any)</code></pre></p><p>Equivalence operator. Returns True if the two arguments are structurally the same, i.e. from the same type and (recursively) contain equivalent values.</p><p><pre><code>say [1, 2, 3] eqv [1, 2, 3];    # OUTPUT: «True␤»\nsay Any eqv Any;                # OUTPUT: «True␤»\nsay 1 eqv 2;                    # OUTPUT: «False␤»\nsay 1 eqv 1.0;                  # OUTPUT: «False␤»</code></pre></p><p>Lazy Iterables cannot be compared, as they're assumed to be infinite. However, the operator will do its best and return False if the two lazy Iterables are of different types or if only one Iterable is lazy.</p><p><pre><code>say (1…∞) eqv (1…∞).List; # Both lazy, but different types;   OUTPUT: «False␤»\nsay (1…∞) eqv (1…3);      # Same types, but only one is lazy; OUTPUT: «False␤»\n(try say (1…∞) eqv (1…∞)) # Both lazy and of the same type. Cannot compare; throws.\n    orelse say $!.^name;  # OUTPUT: «X::Cannot::Lazy␤»</code></pre></p><p>The default eqv operator even works with arbitrary objects. E.g., eqv will consider two instances of the same object as being structurally equivalent:</p><p><pre><code>my class A {\n    has $.a;\n}\nsay A.new(a =&gt; 5) eqv A.new(a =&gt; 5);  # OUTPUT: «True␤»</code></pre></p><p>Although the above example works as intended, the eqv code might fall back to a slower code path in order to do its job. One way to avoid this is to implement an appropriate infix eqv operator:</p><p><pre><code>my class A {\n    has $.a;\n}\nmulti infix:&lt;eqv&gt;(A $l, A $r) { $l.a eqv $r.a }\nsay A.new(a =&gt; 5) eqv A.new(a =&gt; 5);            # OUTPUT: «True␤»</code></pre></p><p>Note that eqv does not work recursively on every kind of container type, e.g. Set:</p><p><pre><code>my class A {\n    has $.a;\n}\nsay Set(A.new(a =&gt; 5)) eqv Set(A.new(a =&gt; 5));  # OUTPUT: «False␤»</code></pre></p><p>Even though the contents of the two sets are eqv, the sets are not. The reason is that eqv delegates the equality check to the Set object which relies on element-wise === comparison. Turning the class A into a value type by giving it a WHICH method produces the expected behavior:</p><p><pre><code>my class A {\n    has $.a;\n    method WHICH {\n        ValueObjAt.new: \"A|$!a.WHICH()\"\n    }\n}\nsay Set(A.new(a =&gt; 5)) eqv Set(A.new(a =&gt; 5));  # OUTPUT: «True␤»</code></pre></p>","k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<eqv>"},{"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"n":"infix:<eqv>","m":1,"k":"s"},{"n":"infix:<eqv>","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"m":1,"k":"s"},{"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Bool"},"k":"s","m":1,"n":"infix:<eqv>"},{"m":1,"n":"infix:<eqv>","s":{"r":"Bool","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"k":"s"},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<eqv>"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Stringy"},{"t":"Stringy","n":"b"}],"r":"Bool:D"},"n":"infix:<eqv>"},{"n":"infix:<eqv>","m":1,"s":{"p":[{"n":"a","t":"Iterable"},{"t":"Iterable","n":"b"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Numeric"},{"t":"Numeric","n":"b"}],"r":"Bool:D"},"n":"infix:<eqv>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":[{"t":"Int","n":"$a"},{"t":"Int","n":"$b"}]},"n":"infix:<eqv>"},{"n":"infix:<eqv>","k":"s","m":1,"s":{"r":"Bool:D","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]}},{"k":"s","s":{"p":[{"n":"a","t":"Blob"},{"t":"Blob","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:<eqv>"},{"m":1,"s":{"r":"Bool:D","p":[{"t":"Str","n":"a"},{"n":"b","t":"Str"}]},"k":"s","n":"infix:<eqv>"},{"n":"infix:<eqv>","k":"s","s":{"p":[{"n":"a","t":"Capture"},{"n":"b","t":"Capture"}],"r":"Bool:D"},"m":1},{"n":"infix:<eqv>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"Range","n":"a"},{"t":"Range","n":"b"}]}},{"s":{"r":"Bool:D","p":[{"t":"Pair","n":"a"},{"n":"b","t":"Pair"}]},"k":"s","m":1,"n":"infix:<eqv>"},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"Map","n":"a"},{"n":"b","t":"Map"}]},"n":"infix:<eqv>"},{"m":1,"k":"s","s":{"p":[{"t":"Parameter","n":"a"},{"n":"b","t":"Parameter"}],"r":"Mu"},"n":"infix:<eqv>"},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Signature"},{"t":"Signature","n":"b"}]},"m":1,"n":"infix:<eqv>"},{"m":1,"n":"infix:<eqv>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Match"},{"n":"b","t":"Match"}]}},{"s":{"r":"Bool:D","p":[{"t":"Allomorph","n":"$a"},{"n":"$b","t":"Allomorph"}]},"n":"infix:<eqv>","k":"s","m":1},{"m":1,"n":"infix:<eqv>","k":"s","s":{"r":"Bool:D","p":[{"t":"Setty","n":"a"},{"t":"Setty","n":"b"}]}},{"k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"n":"infix:<eqv>","m":1},{"m":1,"n":"infix:<eqv>","s":{"r":"Bool:D","p":[{"n":"a","t":"ObjAt"},{"t":"ObjAt","n":"b"}]},"k":"s"},{"k":"s","s":{"p":[{"t":"Version","n":"a"},{"n":"b","t":"Version"}],"r":"Bool:D"},"n":"infix:<eqv>","m":1},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Promise"},{"n":"b","t":"Promise"}]},"k":"s","n":"infix:<eqv>"},{"b":"A","t":"ValueObjAt","d":"<p><pre><code>class ValueObjAt is ObjAt { }</code></pre></p><p>A subclass of ObjAt that should be used to indicate that a class produces objects that are value types (in other words: are immutable after they have been initialized.</p><p><pre><code>my %h = a =&gt; 42;        # mutable Hash\nsay %h.WHICH;           # OUTPUT: «ObjAt.new(\"Hash|1402...888\")␤»\n\nmy %m is Map = a =&gt; 42; # immutable Map\nsay %m.WHICH;           # OUTPUT: «ValueObjAt.new(\"Map|AAF...09F61F\")␤»</code></pre></p><p>If you create a class that should be considered a value type, you should add a WHICH method to that class that returns a ValueObjAt object, for instance:</p><p><pre><code>class YourClass {\n    has $.foo;  # note these are not mutable\n    has $.bar;\n\n    method WHICH() {\n        ValueObjAt.new(\"YourClass|$!foo|$!bar\");\n    }\n}</code></pre></p><p>Note that it is customary to always start the identifying string with the name of the object, followed by a \"|\". This to prevent confusion with other classes that may generate similar string values: the name of the class should then be enough of a differentiator to prevent collisions.</p>","k":"c","mro":["ObjAt"],"n":"ValueObjAt"},{"k":"v","t":"Sub","n":"&undefine"},{"n":"undefine","m":1,"s":{"p":[{"n":"x","t":"Mu"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"x","t":"Array"}],"r":"Mu"},"n":"undefine"},{"n":"undefine","m":1,"k":"s","s":{"p":[{"t":"Hash","n":"x"}],"r":"Mu"}},{"n":"&prefix:<⚛>","t":"Sub","k":"v"},{"k":"s","m":1,"n":"prefix:<⚛>","s":{"p":[{"t":"Any","n":"$source"}],"r":"Mu"}},{"n":"prefix:<⚛>","s":{"p":[{"t":"atomicint","n":"$source"}],"r":"Mu"},"m":1,"k":"s"},{"t":"SeekType","n":"SeekFromCurrent","k":"e"},{"t":"Any","n":"Any","k":"c","mro":["Mu"],"b":"A","m":[{"k":"m","m":1,"s":{"p":[{"n":"$","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"EXISTS-KEY"},{"s":{"p":[{"t":"Any","n":"$"},{"n":"*%_","t":"Mu"}],"r":"Bool"},"m":1,"n":"EXISTS-KEY","k":"m"},{"k":"m","m":1,"n":"DELETE-KEY","s":{"p":[{"t":"Any","n":"$"},{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"k":"m","s":{"p":[{"n":"$","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"DELETE-KEY","m":1},{"s":{"r":"Nil","p":[{"n":"$pos","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":1,"k":"m","n":"DELETE-POS"},{"m":1,"s":{"r":"Mu","p":[{"n":"$pos","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"DELETE-POS","k":"m"},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"one"},{"t":"Any","n":"two"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"DELETE-POS"},{"s":{"r":"Mu","p":[{"n":"one","t":"Any"},{"t":"Any","n":"two"},{"n":"three","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"DELETE-POS","k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Positional","n":"**@indices"},{"n":"*%_","t":"Mu"}]},"n":"DELETE-POS"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"cache","k":"m","d":"<p>Defined as:</p><p><pre><code>method cache()</code></pre></p><p>Provides a List representation of the object itself, calling the method list on the instance.</p>"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"list","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method list(Any:U: --&gt; List)\nmulti method list(Any:D \\SELF: --&gt; List)</code></pre></p><p>Applies the infix , operator to the invocant and returns the resulting List:</p><p><pre><code>say 42.list.^name;           # OUTPUT: «List␤»\nsay 42.list.elems;           # OUTPUT: «1␤»</code></pre></p><p>Subclasses of Any may choose to return any core type that does the Positional role from .list. Use .List to coerce specifically to List.</p><p> @ can also be used as a list or Positional contextualizer:</p><p><pre><code>my $not-a-list-yet = $[1,2,3];\nsay $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\nmy @maybe-a-list = @$not-a-list-yet;\nsay @maybe-a-list.^name;              # OUTPUT: «Array␤»\n</code></pre></p><p>In the first case, the list is itemized. @ as a prefix puts the initial scalar in a list context by calling .list and turning it into an Array.</p>"},{"m":1,"n":"list","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method list(Any:U: --&gt; List)\nmulti method list(Any:D \\SELF: --&gt; List)</code></pre></p><p>Applies the infix , operator to the invocant and returns the resulting List:</p><p><pre><code>say 42.list.^name;           # OUTPUT: «List␤»\nsay 42.list.elems;           # OUTPUT: «1␤»</code></pre></p><p>Subclasses of Any may choose to return any core type that does the Positional role from .list. Use .List to coerce specifically to List.</p><p> @ can also be used as a list or Positional contextualizer:</p><p><pre><code>my $not-a-list-yet = $[1,2,3];\nsay $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\nmy @maybe-a-list = @$not-a-list-yet;\nsay @maybe-a-list.^name;              # OUTPUT: «Array␤»\n</code></pre></p><p>In the first case, the list is itemized. @ as a prefix puts the initial scalar in a list context by calling .list and turning it into an Array.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method flat() is nodal</code></pre></p><p>Interprets the invocant as a list, flattens non-containerized Iterables into a flat list, and returns that list. Keep in mind Map and Hash types are Iterable and so will be flattened into lists of pairs.</p><p><pre><code>say ((1, 2), (3), %(:42a));      # OUTPUT: «((1 2) 3 {a =&gt; 42})␤»\nsay ((1, 2), (3), %(:42a)).flat; # OUTPUT: «(1 2 3 a =&gt; 42)␤»</code></pre></p><p>Note that Arrays containerize their elements by default, and so flat will not flatten them. You can use hyper method call to call .List method on all the inner Iterables and so de-containerize them, so that flat can flatten them:</p><p><pre><code>say [[1, 2, 3], [(4, 5), 6, 7]]      .flat; # OUTPUT: «([1 2 3] [(4 5) 6 7])␤»\nsay [[1, 2, 3], [(4, 5), 6, 7]]».List.flat; # OUTPUT: «(1 2 3 4 5 6 7)␤»</code></pre></p><p>For more fine-tuned options, see deepmap, duckmap, and signature destructuring</p>","n":"flat"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>method eager() is nodal</code></pre></p><p>Interprets the invocant as a List, evaluates it eagerly, and returns that List.</p><p><pre><code>my  $range = 1..5;\nsay $range;         # OUTPUT: «1..5␤»\nsay $range.eager;   # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p>","k":"m","n":"eager","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1,"d":"<p>Defined as</p><p><pre><code>multi method serial()</code></pre></p><p>This method is Rakudo specific, and is not included in the Raku spec.</p><p>The method returns the self-reference to the instance itself:</p><p><pre><code>my $b;                 # defaults to Any\nsay $b.serial.^name;   # OUTPUT: «Any␤»\nsay $b.^name;          # OUTPUT: «Any␤»\nmy $breakfast = 'food';\n$breakfast.serial.say; # OUTPUT: «food␤»\n</code></pre></p><p>This is apparently a no-op, as exemplified by the third example above. However, in HyperSeqs and RaceSeqs it returns a serialized Seq, so it can be considered the opposite of the hyper/race methods. As such, it ensures that we are in serial list-processing mode, as opposed to the autothreading mode of those methods.</p>","n":"serial","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method List(--&gt; List:D) is nodal</code></pre></p><p>Coerces the invocant to List, using the list method.</p>","m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"List"},{"d":"<p>Defined as:</p><p><pre><code>method Slip(--&gt; Slip:D) is nodal</code></pre></p><p>Coerces the invocant to Slip.</p>","m":1,"n":"Slip","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method Array(--&gt; Array:D) is nodal</code></pre></p><p>Coerces the invocant to an Array.</p>","n":"Array","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1},{"n":"Seq","k":"m","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method hash(Any:U:)\nmulti method hash(Any:D:)</code></pre></p><p>When called on a type object, returns an empty Hash. On instances, it is equivalent to assigning the invocant to a %-sigiled variable and returning that.</p><p>Subclasses of Any may choose to return any core type that does the Associative role from .hash. Use .Hash to coerce specifically to Hash.</p><p><pre><code>my $d; # $d is Any\nsay $d.hash; # OUTPUT: {}\n\nmy %m is Map = a =&gt; 42, b =&gt; 666;\nsay %m.hash;  # Map.new((a =&gt; 42, b =&gt; 666))\nsay %m.Hash;  # {a =&gt; 42, b =&gt; 666}\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"hash","k":"m"},{"n":"hash","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method hash(Any:U:)\nmulti method hash(Any:D:)</code></pre></p><p>When called on a type object, returns an empty Hash. On instances, it is equivalent to assigning the invocant to a %-sigiled variable and returning that.</p><p>Subclasses of Any may choose to return any core type that does the Associative role from .hash. Use .Hash to coerce specifically to Hash.</p><p><pre><code>my $d; # $d is Any\nsay $d.hash; # OUTPUT: {}\n\nmy %m is Map = a =&gt; 42, b =&gt; 666;\nsay %m.hash;  # Map.new((a =&gt; 42, b =&gt; 666))\nsay %m.Hash;  # {a =&gt; 42, b =&gt; 666}\n</code></pre></p>","m":1,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method Hash( --&gt; Hash:D)</code></pre></p><p>Coerces the invocant to Hash.</p>","n":"Hash"},{"n":"Map","d":"<p>Defined as:</p><p><pre><code>method Map(--&gt; Map:D) is nodal</code></pre></p><p>Coerces the invocant to Map.</p>","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method elems(Any:U: --&gt; 1)\nmulti method elems(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the number of elements in the list.</p><p><pre><code>say 42.elems;                   # OUTPUT: «1␤»\nsay &lt;a b c&gt;.elems;              # OUTPUT: «3␤»\nsay Whatever.elems ;            # OUTPUT: «1␤»</code></pre></p><p>It will also return 1 for classes.</p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int"},"n":"elems","m":1},{"n":"elems","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method elems(Any:U: --&gt; 1)\nmulti method elems(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the number of elements in the list.</p><p><pre><code>say 42.elems;                   # OUTPUT: «1␤»\nsay &lt;a b c&gt;.elems;              # OUTPUT: «3␤»\nsay Whatever.elems ;            # OUTPUT: «1␤»</code></pre></p><p>It will also return 1 for classes.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1},{"d":"<p><pre><code>multi method end(Any:U: --&gt; 0)\nmulti method end(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the last index of that list.</p><p><pre><code>say 6.end;                      # OUTPUT: «0␤»\nsay &lt;a b c&gt;.end;                # OUTPUT: «2␤»</code></pre></p>","n":"end","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int"},"m":1,"k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>multi method end(Any:U: --&gt; 0)\nmulti method end(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the last index of that list.</p><p><pre><code>say 6.end;                      # OUTPUT: «0␤»\nsay &lt;a b c&gt;.end;                # OUTPUT: «2␤»</code></pre></p>","m":1,"n":"end"},{"d":"<p>Defined as:</p><p><pre><code>multi method keys(Any:U: --&gt; List)\nmulti method keys(Any:D: --&gt; List)</code></pre></p><p>For defined Any returns its keys after calling list on it, otherwise calls list and returns it.</p><p><pre><code>my $setty = Set(&lt;Þor Oðin Freija&gt;);\nsay $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»</code></pre></p><p>See also List.keys.</p><p>Trying the same on a class will return an empty list, since most of them don't really have keys.</p>","k":"m","m":1,"n":"keys","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"keys","d":"<p>Defined as:</p><p><pre><code>multi method keys(Any:U: --&gt; List)\nmulti method keys(Any:D: --&gt; List)</code></pre></p><p>For defined Any returns its keys after calling list on it, otherwise calls list and returns it.</p><p><pre><code>my $setty = Set(&lt;Þor Oðin Freija&gt;);\nsay $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»</code></pre></p><p>See also List.keys.</p><p>Trying the same on a class will return an empty list, since most of them don't really have keys.</p>"},{"n":"kv","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method kv(Any:U:)\nmulti method kv(Any:D:)\nmulti sub    kv($x)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>Sub.kv.say ;# OUTPUT: «()␤»</code></pre></p><p>It calls list on the invocant for value objects and returns the result of List.kv on it as a list where keys and values will be ordered and contiguous</p><p><pre><code>&lt;1 2 3&gt;.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»</code></pre></p><p>In the case of Positionals, the indices will be considered keys.</p>","m":1,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method kv(Any:U:)\nmulti method kv(Any:D:)\nmulti sub    kv($x)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>Sub.kv.say ;# OUTPUT: «()␤»</code></pre></p><p>It calls list on the invocant for value objects and returns the result of List.kv on it as a list where keys and values will be ordered and contiguous</p><p><pre><code>&lt;1 2 3&gt;.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»</code></pre></p><p>In the case of Positionals, the indices will be considered keys.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1,"k":"m","n":"kv"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1,"n":"values","d":"<p>Defined as:</p><p><pre><code>multi method values(Any:U:)\nmulti method values(Any:D:)</code></pre></p><p>Will return an empty list for undefined or class arguments, and the object converted to a list otherwise.</p><p><pre><code>say (1..3).values; # OUTPUT: «(1 2 3)␤»\nsay List.values;   # OUTPUT: «()␤»</code></pre></p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method values(Any:U:)\nmulti method values(Any:D:)</code></pre></p><p>Will return an empty list for undefined or class arguments, and the object converted to a list otherwise.</p><p><pre><code>say (1..3).values; # OUTPUT: «(1 2 3)␤»\nsay List.values;   # OUTPUT: «()␤»</code></pre></p>","n":"values","m":1,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pairs","d":"<p>Defined as:</p><p><pre><code>multi method pairs(Any:U:)\nmulti method pairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>say Num.pairs; # OUTPUT: «()␤»</code></pre></p><p>For a value object, it converts the invocant to a List via the list method and returns the result of List.pairs on it.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.Bag.pairs.say;# OUTPUT: «(1 =&gt; 1 3 =&gt; 3 2 =&gt; 2)␤»</code></pre></p><p>In this case, every element (with weight) in a bag is converted to a pair.</p>","m":1},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"pairs","d":"<p>Defined as:</p><p><pre><code>multi method pairs(Any:U:)\nmulti method pairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>say Num.pairs; # OUTPUT: «()␤»</code></pre></p><p>For a value object, it converts the invocant to a List via the list method and returns the result of List.pairs on it.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.Bag.pairs.say;# OUTPUT: «(1 =&gt; 1 3 =&gt; 3 2 =&gt; 2)␤»</code></pre></p><p>In this case, every element (with weight) in a bag is converted to a pair.</p>"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method antipairs(Any:U:)\nmulti method antipairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object</p><p><pre><code>Range.antipairs.say; # OUTPUT: «()␤»</code></pre></p><p>If it's a value object, it returns the inverted list of pairs after converting it to a list of pairs; the values will become keys and the other way round.</p><p><pre><code>%(s =&gt; 1, t=&gt; 2, u =&gt; 3).antipairs.say ;# OUTPUT: «(2 =&gt; t 1 =&gt; s 3 =&gt; u)␤»</code></pre></p>","n":"antipairs","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method antipairs(Any:U:)\nmulti method antipairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object</p><p><pre><code>Range.antipairs.say; # OUTPUT: «()␤»</code></pre></p><p>If it's a value object, it returns the inverted list of pairs after converting it to a list of pairs; the values will become keys and the other way round.</p><p><pre><code>%(s =&gt; 1, t=&gt; 2, u =&gt; 3).antipairs.say ;# OUTPUT: «(2 =&gt; t 1 =&gt; s 3 =&gt; u)␤»</code></pre></p>","n":"antipairs","k":"m","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method invert(Any:U:)\nmulti method invert(Any:D:)</code></pre></p><p>Applied to a type object will return an empty list; applied to an object will convert it to a list and apply List.invert to it, that is, interchange key with value in every Pair. The resulting list needs to be a list of Pairs.</p><p><pre><code>\"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 =&gt; c 3 =&gt; a 2 =&gt; b)␤»</code></pre></p><p>In this case, a Bag can be converted to a list of Pairs. If the result of converting the object to a list is not a list of pairs, the method will fail.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"invert","k":"m","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi method invert(Any:U:)\nmulti method invert(Any:D:)</code></pre></p><p>Applied to a type object will return an empty list; applied to an object will convert it to a list and apply List.invert to it, that is, interchange key with value in every Pair. The resulting list needs to be a list of Pairs.</p><p><pre><code>\"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 =&gt; c 3 =&gt; a 2 =&gt; b)␤»</code></pre></p><p>In this case, a Bag can be converted to a list of Pairs. If the result of converting the object to a list is not a list of pairs, the method will fail.</p>","n":"invert","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"pick","d":"<p>Defined as:</p><p><pre><code>multi method pick(--&gt; Any)\nmulti method pick($n --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.pick on it.</p><p><pre><code>my Range $rg = 'α'..'ω';\nsay $rg.pick(3); # OUTPUT: «(β α σ)␤»</code></pre></p>","k":"m","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"$n","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"pick","d":"<p>Defined as:</p><p><pre><code>multi method pick(--&gt; Any)\nmulti method pick($n --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.pick on it.</p><p><pre><code>my Range $rg = 'α'..'ω';\nsay $rg.pick(3); # OUTPUT: «(β α σ)␤»</code></pre></p>"},{"m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method roll(--&gt; Any)\nmulti method roll($n --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.roll on it.</p><p><pre><code>my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\nsay $m.roll;    # OUTPUT: «ð␤»\nsay $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»</code></pre></p><p>$m, in this case, is converted into a list and then a (weighted in this case) dice is rolled on it. See also List.roll for more information.</p>","n":"roll","k":"m"},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method roll(--&gt; Any)\nmulti method roll($n --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.roll on it.</p><p><pre><code>my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\nsay $m.roll;    # OUTPUT: «ð␤»\nsay $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»</code></pre></p><p>$m, in this case, is converted into a list and then a (weighted in this case) dice is rolled on it. See also List.roll for more information.</p>","s":{"p":[{"n":"$n","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"roll"},{"m":0,"n":"match","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method classify()\nmulti method classify(Whatever)\nmulti method classify($test, :$into!, :&amp;as)\nmulti method classify($test, :&amp;as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>The two first forms will fail. The rest include a $test, which is a function that will return a scalar for every input; these will be used as keys of a hash whose values will be arrays with the elements that output that key for the test function.</p><p><pre><code>my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n@years.classify( *.is-leap-year , into =&gt; my %leap-years );\nsay %leap-years;\n# OUTPUT: «{False =&gt; [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n#           True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>Similarly to .categorize, elements can be normalized by the Callable passed with the :as argument, and it can use the :into named argument to pass a Hash the results will be classified into; in the example above, it's defined on the fly.</p><p>From version 6.d, .classify will also work with Junctions.</p>","n":"classify","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Whatever","n":"$"},{"t":"Mu","n":"*%_"}]},"n":"classify","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method classify()\nmulti method classify(Whatever)\nmulti method classify($test, :$into!, :&amp;as)\nmulti method classify($test, :&amp;as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>The two first forms will fail. The rest include a $test, which is a function that will return a scalar for every input; these will be used as keys of a hash whose values will be arrays with the elements that output that key for the test function.</p><p><pre><code>my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n@years.classify( *.is-leap-year , into =&gt; my %leap-years );\nsay %leap-years;\n# OUTPUT: «{False =&gt; [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n#           True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>Similarly to .categorize, elements can be normalized by the Callable passed with the :as argument, and it can use the :into named argument to pass a Hash the results will be classified into; in the example above, it's defined on the fly.</p><p>From version 6.d, .classify will also work with Junctions.</p>"},{"n":"classify","d":"<p>Defined as:</p><p><pre><code>multi method classify()\nmulti method classify(Whatever)\nmulti method classify($test, :$into!, :&amp;as)\nmulti method classify($test, :&amp;as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>The two first forms will fail. The rest include a $test, which is a function that will return a scalar for every input; these will be used as keys of a hash whose values will be arrays with the elements that output that key for the test function.</p><p><pre><code>my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n@years.classify( *.is-leap-year , into =&gt; my %leap-years );\nsay %leap-years;\n# OUTPUT: «{False =&gt; [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n#           True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>Similarly to .categorize, elements can be normalized by the Callable passed with the :as argument, and it can use the :into named argument to pass a Hash the results will be classified into; in the example above, it's defined on the fly.</p><p>From version 6.d, .classify will also work with Junctions.</p>","m":1,"s":{"r":"Mu","p":[{"n":"$test","t":"Any"},{"n":":$into!","t":"Any"},{"t":"Callable","n":":&as"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"$test","t":"Any"},{"n":":&as","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method classify()\nmulti method classify(Whatever)\nmulti method classify($test, :$into!, :&amp;as)\nmulti method classify($test, :&amp;as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>The two first forms will fail. The rest include a $test, which is a function that will return a scalar for every input; these will be used as keys of a hash whose values will be arrays with the elements that output that key for the test function.</p><p><pre><code>my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n@years.classify( *.is-leap-year , into =&gt; my %leap-years );\nsay %leap-years;\n# OUTPUT: «{False =&gt; [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n#           True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>Similarly to .categorize, elements can be normalized by the Callable passed with the :as argument, and it can use the :into named argument to pass a Hash the results will be classified into; in the example above, it's defined on the fly.</p><p>From version 6.d, .classify will also work with Junctions.</p>","n":"classify","m":1,"k":"m"},{"n":"categorize","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&amp;as)\nmulti method categorize($test, :&amp;as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>The two first forms fail with an error message.</p><p>In its simplest form, it uses a $test whose result will be used as a key; the values of the key will be an array of the elements that produced that key as a result of the test.</p><p><pre><code>say (1..13).categorize( * %% 3);\nsay categorize( * %% 3, 1..13)\n# OUTPUT: «{False =&gt; [1 2 4 5 7 8 10 11 13], True =&gt; [3 6 9 12]}␤»\n</code></pre></p><p>The :as argument will normalize before categorizing</p><p><pre><code>say categorize( * %% 3, -5..5, as =&gt; &amp;abs )\n# OUTPUT: «{False =&gt; [5 4 2 1 1 2 4 5], True =&gt; [3 0 3]}␤»\n</code></pre></p><p>The $into associative argument can be used to put the result instead of returning a new Hash</p><p><pre><code>my %leap-years;\nmy @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n@years.categorize( *.is-leap-year , into =&gt; %leap-years );\nsay %leap-years\n# OUTPUT:\n# «{ False\n# =&gt; [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n#    True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>The function used to categorize can return an array indicating all possible bins their argument can be put into:</p><p><pre><code>sub divisible-by( Int $n --&gt; Array(Seq) ) {\n    gather {\n        for &lt;2 3 5 7&gt; {\n            take $_ if $n %% $_;\n        }\n    }\n}\n\nsay (3..13).categorize( &amp;divisible-by );\n# OUTPUT:\n# «{2 =&gt; [4 6 8 10 12], 3 =&gt; [3 6 9 12], 5 =&gt; [5 10], 7 =&gt; [7]}␤»\n</code></pre></p><p>In this case, every number in the range is classified in as many bins as it can be divided by.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"$","t":"Whatever"},{"n":"*%_","t":"Mu"}]},"n":"categorize","d":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&amp;as)\nmulti method categorize($test, :&amp;as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>The two first forms fail with an error message.</p><p>In its simplest form, it uses a $test whose result will be used as a key; the values of the key will be an array of the elements that produced that key as a result of the test.</p><p><pre><code>say (1..13).categorize( * %% 3);\nsay categorize( * %% 3, 1..13)\n# OUTPUT: «{False =&gt; [1 2 4 5 7 8 10 11 13], True =&gt; [3 6 9 12]}␤»\n</code></pre></p><p>The :as argument will normalize before categorizing</p><p><pre><code>say categorize( * %% 3, -5..5, as =&gt; &amp;abs )\n# OUTPUT: «{False =&gt; [5 4 2 1 1 2 4 5], True =&gt; [3 0 3]}␤»\n</code></pre></p><p>The $into associative argument can be used to put the result instead of returning a new Hash</p><p><pre><code>my %leap-years;\nmy @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n@years.categorize( *.is-leap-year , into =&gt; %leap-years );\nsay %leap-years\n# OUTPUT:\n# «{ False\n# =&gt; [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n#    True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>The function used to categorize can return an array indicating all possible bins their argument can be put into:</p><p><pre><code>sub divisible-by( Int $n --&gt; Array(Seq) ) {\n    gather {\n        for &lt;2 3 5 7&gt; {\n            take $_ if $n %% $_;\n        }\n    }\n}\n\nsay (3..13).categorize( &amp;divisible-by );\n# OUTPUT:\n# «{2 =&gt; [4 6 8 10 12], 3 =&gt; [3 6 9 12], 5 =&gt; [5 10], 7 =&gt; [7]}␤»\n</code></pre></p><p>In this case, every number in the range is classified in as many bins as it can be divided by.</p>","m":1,"k":"m"},{"m":1,"s":{"p":[{"n":"$test","t":"Any"},{"t":"Any","n":":$into!"},{"t":"Callable","n":":&as"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&amp;as)\nmulti method categorize($test, :&amp;as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>The two first forms fail with an error message.</p><p>In its simplest form, it uses a $test whose result will be used as a key; the values of the key will be an array of the elements that produced that key as a result of the test.</p><p><pre><code>say (1..13).categorize( * %% 3);\nsay categorize( * %% 3, 1..13)\n# OUTPUT: «{False =&gt; [1 2 4 5 7 8 10 11 13], True =&gt; [3 6 9 12]}␤»\n</code></pre></p><p>The :as argument will normalize before categorizing</p><p><pre><code>say categorize( * %% 3, -5..5, as =&gt; &amp;abs )\n# OUTPUT: «{False =&gt; [5 4 2 1 1 2 4 5], True =&gt; [3 0 3]}␤»\n</code></pre></p><p>The $into associative argument can be used to put the result instead of returning a new Hash</p><p><pre><code>my %leap-years;\nmy @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n@years.categorize( *.is-leap-year , into =&gt; %leap-years );\nsay %leap-years\n# OUTPUT:\n# «{ False\n# =&gt; [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n#    True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>The function used to categorize can return an array indicating all possible bins their argument can be put into:</p><p><pre><code>sub divisible-by( Int $n --&gt; Array(Seq) ) {\n    gather {\n        for &lt;2 3 5 7&gt; {\n            take $_ if $n %% $_;\n        }\n    }\n}\n\nsay (3..13).categorize( &amp;divisible-by );\n# OUTPUT:\n# «{2 =&gt; [4 6 8 10 12], 3 =&gt; [3 6 9 12], 5 =&gt; [5 10], 7 =&gt; [7]}␤»\n</code></pre></p><p>In this case, every number in the range is classified in as many bins as it can be divided by.</p>","n":"categorize","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&amp;as)\nmulti method categorize($test, :&amp;as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>The two first forms fail with an error message.</p><p>In its simplest form, it uses a $test whose result will be used as a key; the values of the key will be an array of the elements that produced that key as a result of the test.</p><p><pre><code>say (1..13).categorize( * %% 3);\nsay categorize( * %% 3, 1..13)\n# OUTPUT: «{False =&gt; [1 2 4 5 7 8 10 11 13], True =&gt; [3 6 9 12]}␤»\n</code></pre></p><p>The :as argument will normalize before categorizing</p><p><pre><code>say categorize( * %% 3, -5..5, as =&gt; &amp;abs )\n# OUTPUT: «{False =&gt; [5 4 2 1 1 2 4 5], True =&gt; [3 0 3]}␤»\n</code></pre></p><p>The $into associative argument can be used to put the result instead of returning a new Hash</p><p><pre><code>my %leap-years;\nmy @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n@years.categorize( *.is-leap-year , into =&gt; %leap-years );\nsay %leap-years\n# OUTPUT:\n# «{ False\n# =&gt; [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n#    True =&gt; [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>The function used to categorize can return an array indicating all possible bins their argument can be put into:</p><p><pre><code>sub divisible-by( Int $n --&gt; Array(Seq) ) {\n    gather {\n        for &lt;2 3 5 7&gt; {\n            take $_ if $n %% $_;\n        }\n    }\n}\n\nsay (3..13).categorize( &amp;divisible-by );\n# OUTPUT:\n# «{2 =&gt; [4 6 8 10 12], 3 =&gt; [3 6 9 12], 5 =&gt; [5 10], 7 =&gt; [7]}␤»\n</code></pre></p><p>In this case, every number in the range is classified in as many bins as it can be divided by.</p>","m":1,"s":{"r":"Mu","p":[{"n":"$test","t":"Any"},{"t":"Callable","n":":&as"},{"t":"Mu","n":"*%_"}]},"n":"categorize","k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi sub    reverse(*@list  --&gt; Seq:D)\nmulti method reverse(List:D: --&gt; Seq:D)</code></pre></p><p>Returns a Seq with the same elements in reverse order.</p><p>Note that reverse always refers to reversing elements of a list; to reverse the characters in a string, use flip.</p><p>Examples:</p><p><pre><code>say &lt;hello world!&gt;.reverse;     # OUTPUT: «(world! hello)␤»\nsay reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»</code></pre></p>","m":0,"n":"reverse"},{"d":"<p>Defined as:</p><p><pre><code>method combinations(|c)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.combinations on it.</p><p><pre><code>say (^3).combinations; # OUTPUT: «(() (0) (1) (2) (0 1) (0 2) (1 2) (0 1 2))␤»\n</code></pre></p>","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"c"}]},"n":"combinations"},{"m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method permutations(|c)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.permutations on it.</p><p><pre><code>say &lt;a b c&gt;.permutations;\n# OUTPUT: «((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»\nsay set(1,2).permutations;\n# OUTPUT: «((2 =&gt; True 1 =&gt; True) (1 =&gt; True 2 =&gt; True))␤»</code></pre></p>","n":"permutations"},{"k":"m","d":"<p>Defined as</p><p><pre><code>method join($separator = '') is nodal</code></pre></p><p>Converts the object to a list by calling self.list, and calls .join on the list. Can take a separator, which is an empty string by default.</p><p><pre><code>(1..3).join.say;       # OUTPUT: «123␤»\n&lt;a b c&gt;.join(\"❧\").put; # OUTPUT: «a❧b❧c␤»</code></pre></p>","s":{"p":[{"t":"Any","n":"$separator?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"join"},{"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method nodemap(&amp;block --&gt; List) is nodal</code></pre></p><p>nodemap will apply &amp;block to each element and return a new List with the return values of &amp;block. In contrast to deepmap it will not descend recursively into sublists if it finds elements which do the Iterable role.</p><p><pre><code>say [[1,2,3], [[4,5],6,7], 7].nodemap(*+1);\n# OUTPUT: «(4, 4, 8)␤»\n\nsay [[2, 3], [4, [5, 6]]]».nodemap(*+1)\n# OUTPUT: «((3 4) (5 3))␤»</code></pre></p><p>The examples above would have produced the exact same results if we had used map instead of nodemap. The difference between the two lies in the fact that map flattens out slips while nodemap doesn't.</p><p><pre><code>say [[2,3], [[4,5],6,7], 7].nodemap({.elems == 1 ?? $_ !! slip});\n# OUTPUT: «(() () 7)␤»\nsay [[2,3], [[4,5],6,7], 7].map({.elems == 1 ?? $_ !! slip});\n# OUTPUT: «(7)␤»</code></pre></p><p>When applied to Associatives, it will act on the values:</p><p><pre><code>{ what =&gt; \"is\", this =&gt; \"thing\" }.nodemap( *.flip ).say;\n# OUTPUT: «{this =&gt; gniht, what =&gt; si}␤»</code></pre></p>","s":{"p":[{"n":"&block","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"nodemap"},{"d":"<p>Defined as:</p><p><pre><code>method duckmap(&amp;block) is rw is nodal</code></pre></p><p>duckmap will apply &amp;block on each element that behaves in such a way that &amp;block can be applied. If it fails, it will descend recursively if possible, or otherwise return the item without any transformation. It will act on values if the object is Associative.</p><p><pre><code>&lt;a b c d e f g&gt;.duckmap(-&gt; $_ where &lt;c d e&gt;.any { .uc }).say;\n# OUTPUT: «(a b C D E f g)␤»\n(('d', 'e'), 'f').duckmap(-&gt; $_ where &lt;e f&gt;.any { .uc }).say;\n# OUTPUT: «((d E) F)␤»\n{ first =&gt; ('d', 'e'), second =&gt; 'f'}.duckmap(-&gt; $_ where &lt;e f&gt;.any { .uc }).say;\n# OUTPUT: «{first =&gt; (d E), second =&gt; F}␤»\n</code></pre></p><p>In the first case, it is applied to c, d and e which are the ones that meet the conditions for the block ({ .uc }) to be applied; the rest are returned as is.</p><p>In the second case, the first item is a list that does not meet the condition, so it's visited; that flat list will behave in the same way as the first one. In this case:</p><p><pre><code>say [[1,2,3],[[4,5],6,7]].duckmap( *² ); # OUTPUT: «[9 9]␤»</code></pre></p><p>You can square anything as long as it behaves like a number. In this case, there are two arrays with 3 elements each; these arrays will be converted into the number 3 and squared. In the next case, however</p><p><pre><code>say [[1,2,3],[[4,5],6.1,7.2]].duckmap( -&gt; Rat $_ { $_²} );\n# OUTPUT: «[[1 2 3] [[4 5] 37.21 51.84]]␤»</code></pre></p><p>3-item lists are not Rat, so it descends recursively, but eventually only applies the operation to those that walk (or slither, as the case may be) like a Rat.</p><p>Although on the surface (and name), duckmap might look similar to deepmap, the latter is applied recursively regardless of the type of the item.</p>","m":0,"s":{"r":"Mu","p":[{"n":"&block","t":"Callable"},{"n":"*%_","t":"Mu"}]},"n":"duckmap","k":"m"},{"n":"deepmap","s":{"p":[{"t":"Callable","n":"&block"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method deepmap(&amp;block --&gt; List) is nodal</code></pre></p><p>deepmap will apply &amp;block to each element and return a new List with the return values of &amp;block, unless the element does the Iterable role. For those elements deepmap will descend recursively into the sublist.</p><p><pre><code>say [[1,2,3],[[4,5],6,7]].deepmap(* + 1);\n# OUTPUT: «[[2 3 4] [[5 6] 7 8]]␤»</code></pre></p><p>In the case of Associatives, it will be applied to its values:</p><p><pre><code>{ what =&gt; \"is\", this =&gt; \"thing\", a =&gt; &lt;real list&gt; }.deepmap( *.flip ).say\n# OUTPUT: «{a =&gt; (laer tsil), this =&gt; gniht, what =&gt; si}␤»\n</code></pre></p>","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"tree"},{"m":1,"n":"tree","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","m":1,"s":{"r":"Mu","p":[{"t":"Whatever","n":"$"},{"n":"*%_","t":"Mu"}]},"n":"tree","k":"m"},{"n":"tree","s":{"r":"Mu","p":[{"t":"Cool","n":"$count"},{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","m":1},{"k":"m","n":"tree","d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","m":1,"s":{"p":[{"n":"@","t":"Positional"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&amp;first, *@rest])\nmulti method tree(Any:D: &amp;first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","n":"tree","s":{"p":[{"n":"&first","t":"Callable"},{"n":"*@rest","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method push(|values --&gt; Positional:D)</code></pre></p><p>The method push is defined for undefined invocants and allows for autovivifying undefined to an empty Array, unless the undefined value implements Positional already. The argument provided will then be pushed into the newly created Array.</p><p><pre><code>my %h;\nsay %h&lt;a&gt;;     # OUTPUT: «(Any)␤»      &lt;-- Undefined\n%h&lt;a&gt;.push(1); # .push on Any\nsay %h;        # OUTPUT: «{a =&gt; [1]}␤» &lt;-- Note the Array</code></pre></p>","n":"push","m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"values"}]}},{"k":"m","s":{"p":[{"n":"values","t":"Any"}],"r":"Mu"},"m":1,"n":"append","d":"<p>Defined as:</p><p><pre><code>multi method append(Any:U \\SELF: |values --&gt; Array)</code></pre></p><p>In the case the instance is not a positional-thing, it instantiates it as a new Array, otherwise clone the current instance. After that, it appends the values passed as arguments to the array obtained calling Array.append on it.</p><p><pre><code>my $a;\nsay $a.append; # OUTPUT: «[]␤»\nmy $b;\nsay $b.append((1,2,3)); # OUTPUT: «[1 2 3]␤»</code></pre></p>"},{"n":"unshift","m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method unshift(--&gt; Array)\nmulti method unshift(@values --&gt; Array)</code></pre></p><p>Initializes Any variable as empty Array and calls Array.unshift on it.</p><p><pre><code>my $a;\nsay $a.unshift; # OUTPUT: «[]␤»\nsay $a;         # OUTPUT: «[]␤»\nmy $b;\nsay $b.unshift([1,2,3]); # OUTPUT: «[[1 2 3]]␤»</code></pre></p>","s":{"p":[{"t":"Any","n":"values"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method prepend(--&gt; Array)\nmulti method prepend(@values --&gt; Array)</code></pre></p><p>Called with no arguments on an empty variable, it initializes it as an empty Array; if called with arguments, it creates an array and then applies Array.prepend on it.</p><p><pre><code>my $a;\nsay $a.prepend; # OUTPUT: «[]␤»\nsay $a;         # OUTPUT: «[]␤»\nmy $b;\nsay $b.prepend(1,2,3); # OUTPUT: «[1 2 3]␤»</code></pre></p>","s":{"p":[{"t":"Any","n":"values"}],"r":"Mu"},"m":1,"n":"prepend","k":"m"},{"n":"EXISTS-POS","s":{"r":"Bool","p":[{"t":"Any","n":"$"},{"t":"Mu","n":"*%_"}]},"k":"m","m":1},{"s":{"r":"Mu","p":[{"n":"$pos","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"EXISTS-POS","m":1,"k":"m"},{"s":{"r":"Bool:D","p":[{"n":"pos","t":"int"},{"n":"*%_","t":"Mu"}]},"n":"EXISTS-POS","m":1,"k":"m"},{"n":"EXISTS-POS","k":"m","s":{"r":"Bool:D","p":[{"n":"pos","t":"Int"},{"n":"*%_","t":"Mu"}]},"m":1},{"k":"m","m":1,"s":{"r":"Bool:D","p":[{"t":"Num","n":"pos"},{"n":"*%_","t":"Mu"}]},"n":"EXISTS-POS"},{"s":{"p":[{"t":"Any","n":"pos"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":1,"n":"EXISTS-POS","k":"m"},{"s":{"p":[{"n":"pos","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"EXISTS-POS","k":"m"},{"m":1,"k":"m","s":{"p":[{"n":"one","t":"Any"},{"n":"two","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"EXISTS-POS"},{"n":"EXISTS-POS","m":1,"k":"m","s":{"r":"Bool:D","p":[{"n":"one","t":"Any"},{"n":"two","t":"Any"},{"t":"Any","n":"three"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"**@indices","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"EXISTS-POS","m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":[{"t":"int","n":"pos"},{"t":"Mu","n":"*%_"}]},"n":"AT-POS"},{"k":"m","s":{"r":"Mu","p":[{"t":"Int","n":"pos"},{"t":"Mu","n":"*%_"}]},"n":"AT-POS","m":1},{"k":"m","m":1,"s":{"p":[{"n":"pos","t":"Num"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"AT-POS"},{"s":{"p":[{"t":"Any","n":"pos"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"AT-POS","k":"m","m":1},{"m":1,"n":"AT-POS","s":{"p":[{"t":"int","n":"pos"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","s":{"p":[{"n":"pos","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"AT-POS"},{"k":"m","m":1,"s":{"r":"Mu","p":[{"n":"pos","t":"Num"},{"n":"*%_","t":"Mu"}]},"n":"AT-POS"},{"m":1,"s":{"p":[{"n":"pos","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"AT-POS"},{"s":{"r":"Mu","p":[{"n":"pos","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"AT-POS","k":"m"},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"one"},{"n":"two","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"AT-POS"},{"n":"AT-POS","s":{"p":[{"n":"one","t":"Any"},{"t":"Any","n":"two"},{"t":"Any","n":"three"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1},{"m":1,"n":"AT-POS","s":{"r":"Mu","p":[{"n":"**@indices","t":"Positional"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"t":"Associative","n":"*%unexpected"}]},"k":"m","n":"ZEN-POS"},{"m":1,"k":"m","s":{"p":[{"t":"Associative","n":"*%unexpected"}],"r":"Mu"},"n":"ZEN-KEY"},{"k":"m","m":1,"n":"ASSIGN-POS","s":{"r":"Mu","p":[{"t":"Any","n":"pos"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}]}},{"n":"ASSIGN-POS","s":{"p":[{"n":"pos","t":"int"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"s":{"p":[{"n":"pos","t":"Int"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"ASSIGN-POS","k":"m"},{"n":"ASSIGN-POS","m":1,"k":"m","s":{"p":[{"n":"pos","t":"Num"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"pos","t":"Any"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"ASSIGN-POS","m":1},{"k":"m","s":{"p":[{"t":"Any","n":"pos"},{"n":"assignee","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"ASSIGN-POS","m":1},{"m":1,"n":"ASSIGN-POS","k":"m","s":{"r":"Mu","p":[{"n":"one","t":"Any"},{"t":"Any","n":"two"},{"n":"assignee","t":"Mu"},{"t":"Mu","n":"*%_"}]}},{"m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"one"},{"n":"two","t":"Any"},{"t":"Any","n":"three"},{"n":"assignee","t":"Mu"},{"n":"*%_","t":"Mu"}]},"n":"ASSIGN-POS"},{"s":{"p":[{"t":"Positional","n":"**@indices"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"ASSIGN-POS","m":1,"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"t":"Positional","n":"**@indices"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"BIND-POS"},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"all","d":"<p>Defined as:</p><p><pre><code>method all(--&gt; Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates an all-Junction from it.</p><p><pre><code>say so 1 &lt; &lt;2 3 4&gt;.all;         # OUTPUT: «True␤»\nsay so 3 &lt; &lt;2 3 4&gt;.all;         # OUTPUT: «False␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method any(--&gt; Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates an any-Junction from it.</p><p><pre><code>say so 2 == &lt;1 2 3&gt;.any;        # OUTPUT: «True␤»\nsay so 5 == &lt;1 2 3&gt;.any;        # OUTPUT: «False␤»</code></pre></p>","n":"any","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method one(--&gt; Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates a one-Junction from it.</p><p><pre><code>say so 1 == (1, 2, 3).one;      # OUTPUT: «True␤»\nsay so 1 == (1, 2, 1).one;      # OUTPUT: «False␤»</code></pre></p>","m":0,"k":"m","n":"one","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"none","k":"m","d":"<p>Defined as:</p><p><pre><code>method none(--&gt; Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates a none-Junction from it.</p><p><pre><code>say so 1 == (1, 2, 3).none;     # OUTPUT: «False␤»\nsay so 4 == (1, 2, 3).none;     # OUTPUT: «True␤»</code></pre></p>","m":0},{"m":1,"n":"AT-KEY","k":"m","s":{"r":"Mu","p":[{"n":"$key","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"key"},{"n":"*%_","t":"Mu"}]},"n":"AT-KEY"},{"k":"m","n":"BIND-KEY","m":1,"s":{"r":"Mu","p":[{"n":"k","t":"Any"},{"n":"v","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"m":1,"k":"m","s":{"p":[{"t":"Any","n":"$key"},{"t":"Any","n":"$BIND"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BIND-KEY"},{"m":1,"s":{"p":[{"t":"Any","n":"key"},{"t":"Mu","n":"assignee"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"ASSIGN-KEY","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"FLATTENABLE_LIST","m":0,"k":"m"},{"n":"FLATTENABLE_HASH","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method Set(--&gt; Set:D) is nodal</code></pre></p><p>Coerces the invocant to Set, whereby Positionals are treated as lists of values.</p>","s":{"r":"Set:D","p":[{"n":"*%_","t":"Mu"}]},"m":1,"n":"Set","k":"m"},{"n":"SetHash","d":"<p>Defined as:</p><p><pre><code>method SetHash(--&gt; SetHash:D) is nodal</code></pre></p><p>Coerces the invocant to SetHash, whereby Positionals are treated as lists of values.</p>","m":1,"s":{"r":"SetHash:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"Bag","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>method Bag(--&gt; Bag:D) is nodal</code></pre></p><p>Coerces the invocant to Bag, whereby Positionals are treated as lists of values.</p>","s":{"r":"Bag:D","p":[{"n":"*%_","t":"Mu"}]}},{"n":"BagHash","d":"<p>Defined as:</p><p><pre><code>method BagHash(--&gt; BagHash:D) is nodal</code></pre></p><p>Coerces the invocant to BagHash, whereby Positionals are treated as lists of values.</p>","m":1,"k":"m","s":{"r":"BagHash:D","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method Mix(--&gt; Mix:D) is nodal</code></pre></p><p>Coerces the invocant to Mix, whereby Positionals are treated as lists of values.</p>","m":1,"s":{"r":"Mix:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Mix","k":"m"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>method MixHash(--&gt; MixHash:D) is nodal</code></pre></p><p>Coerces the invocant to MixHash, whereby Positionals are treated as lists of values.</p>","n":"MixHash","k":"m","s":{"r":"MixHash:D","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p>Defined as:</p><p><pre><code>method Supply(--&gt; Supply:D) is nodal</code></pre></p><p>First, it coerces the invocant to a list by applying its .list method, and then to a Supply.</p>","n":"Supply","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1},{"s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"n":"nl-out","d":"<p>Defined as:</p><p><pre><code>method nl-out(--&gt; Str)</code></pre></p><p>Returns Str with the value of \"\\n\". See IO::Handle.nl-out for the details.</p><p><pre><code>Num.nl-out.print;     # OUTPUT: «␤»\nWhatever.nl-out.print;# OUTPUT: «␤»\n33.nl-out.print;      # OUTPUT: «␤»</code></pre></p>","m":0,"k":"m"},{"n":"print-nl","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"n":"lazy-if","m":0,"s":{"p":[{"t":"Any","n":"$flag"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"sum","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"map","m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Hash","n":"hash"},{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &amp;block;; :$label, :$item)\nmulti sub map(&amp;code, +values)</code></pre></p><p>map will iterate over the invocant and apply the number of positional parameters of the code object from the invocant per call. The returned values of the code object will become elements of the returned Seq.</p><p>The :$label and :$item are useful only internally, since for loops get converted to maps. The :$label takes an existing Label to label the .map's loop with and :$item controls whether the iteration will occur over (SELF,) (if :$item is set) or SELF.</p><p>In sub form, will apply the code block to the values, which will be used as invocant.</p><p>The form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will fail with X::Cannot::Map, and are mainly meant to catch common traps.</p>"},{"m":1,"s":{"r":"Mu","p":[{"t":"Iterable","n":"iterable"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &amp;block;; :$label, :$item)\nmulti sub map(&amp;code, +values)</code></pre></p><p>map will iterate over the invocant and apply the number of positional parameters of the code object from the invocant per call. The returned values of the code object will become elements of the returned Seq.</p><p>The :$label and :$item are useful only internally, since for loops get converted to maps. The :$label takes an existing Label to label the .map's loop with and :$item controls whether the iteration will occur over (SELF,) (if :$item is set) or SELF.</p><p>In sub form, will apply the code block to the values, which will be used as invocant.</p><p>The form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will fail with X::Cannot::Map, and are mainly meant to catch common traps.</p>","n":"map"},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &amp;block;; :$label, :$item)\nmulti sub map(&amp;code, +values)</code></pre></p><p>map will iterate over the invocant and apply the number of positional parameters of the code object from the invocant per call. The returned values of the code object will become elements of the returned Seq.</p><p>The :$label and :$item are useful only internally, since for loops get converted to maps. The :$label takes an existing Label to label the .map's loop with and :$item controls whether the iteration will occur over (SELF,) (if :$item is set) or SELF.</p><p>In sub form, will apply the code block to the values, which will be used as invocant.</p><p>The form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will fail with X::Cannot::Map, and are mainly meant to catch common traps.</p>","k":"m","m":1,"n":"map"},{"n":"map","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &amp;block;; :$label, :$item)\nmulti sub map(&amp;code, +values)</code></pre></p><p>map will iterate over the invocant and apply the number of positional parameters of the code object from the invocant per call. The returned values of the code object will become elements of the returned Seq.</p><p>The :$label and :$item are useful only internally, since for loops get converted to maps. The :$label takes an existing Label to label the .map's loop with and :$item controls whether the iteration will occur over (SELF,) (if :$item is set) or SELF.</p><p>In sub form, will apply the code block to the values, which will be used as invocant.</p><p>The form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will fail with X::Cannot::Map, and are mainly meant to catch common traps.</p>","s":{"r":"Mu","p":[{"n":"&block","t":"Callable"},{"n":":$label","t":"Any"},{"n":":$item","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":1},{"s":{"p":[{"t":"Callable","n":"&block"},{"n":":$label","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method flatmap(&amp;block, :$label)</code></pre></p><p>DEPRECATION NOTICE: This method is deprecated in 6.d and will be removed in 6.e. Use .map followed by .flat instead.</p><p>Applies map to every element with the block and Label used as an argument and flattens out the result using .flat.</p><p><pre><code>say \"aabbccc\".comb.Mix.flatmap: \"→ \" ~ *; # OUTPUT: «(→ b␉2 → c␉3 → a␉2)␤»</code></pre></p><p>In this case, the elements of the Mix are itemized to key␉value, and then mapped and flattened. Same result as</p><p><pre><code>say \"aabbccc\".comb.Mix.map( \"→ \" ~ * ).flat</code></pre></p><p>Which is why it is deprecated in 6.d and will be eventually eliminated in 6.e.</p>","m":1,"n":"flatmap"},{"d":"<p>Defined as:</p><p><pre><code>method grep(Mu $matcher, :$k, :$kv, :$p, :$v --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.grep on it.</p><p>Based on $matcher value can be either ((Any)) or empty List.</p><p><pre><code>my $a;\nsay $a.grep({ True }); # OUTPUT: «((Any))␤»\nsay $a.grep({ $_ });   # OUTPUT: «()␤»</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"t":"Bool","n":"$t"},{"n":"*%_","t":"Mu"}]},"n":"grep","k":"m"},{"m":1,"s":{"p":[{"n":"$t","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method grep(Mu $matcher, :$k, :$kv, :$p, :$v --&gt; Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.grep on it.</p><p>Based on $matcher value can be either ((Any)) or empty List.</p><p><pre><code>my $a;\nsay $a.grep({ True }); # OUTPUT: «((Any))␤»\nsay $a.grep({ $_ });   # OUTPUT: «()␤»</code></pre></p>","k":"m","n":"grep"},{"k":"m","m":1,"s":{"r":"Mu","p":[{"n":"$t","t":"Bool"},{"n":"*%_","t":"Mu"}]},"n":"first","d":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>","n":"first","m":1,"s":{"p":[{"n":"$test","t":"Regex"},{"n":":$end","t":"Any"},{"n":"*%a","t":"Associative"}],"r":"Mu"},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"$test","t":"Callable"},{"t":"Any","n":":$end"},{"t":"Associative","n":"*%a"}]},"k":"m","m":1,"n":"first"},{"d":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>","n":"first","k":"m","m":1,"s":{"r":"Mu","p":[{"n":"$test","t":"Mu"},{"n":":$end","t":"Any"},{"n":"*%a","t":"Associative"}]}},{"m":1,"n":"first","s":{"p":[{"t":"Any","n":":$end"},{"n":"*%a","t":"Associative"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>","k":"m"},{"m":1,"n":"min","d":"<p>Defined as:</p><p><pre><code>multi method min()\nmulti method min(&amp;by)\nmulti sub min(+args, :&amp;by!)\nmulti sub min(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically smallest element; in the case of Hashes, it returns the Pair with the lowest value. In sub form, the invocant is passed as an argument.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original value is still the one returned from min.</p><p><pre><code>say (1,7,3).min();              # OUTPUT:«1␤»\nsay (1,7,3).min({1/$_});        # OUTPUT:«7␤»\nsay min(1,7,3);                 # OUTPUT: «1␤»\nsay min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\nmin( %(a =&gt; 3, b=&gt; 7 ) ).say ;  # OUTPUT: «a =&gt; 3␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"min","d":"<p>Defined as:</p><p><pre><code>multi method min()\nmulti method min(&amp;by)\nmulti sub min(+args, :&amp;by!)\nmulti sub min(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically smallest element; in the case of Hashes, it returns the Pair with the lowest value. In sub form, the invocant is passed as an argument.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original value is still the one returned from min.</p><p><pre><code>say (1,7,3).min();              # OUTPUT:«1␤»\nsay (1,7,3).min({1/$_});        # OUTPUT:«7␤»\nsay min(1,7,3);                 # OUTPUT: «1␤»\nsay min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\nmin( %(a =&gt; 3, b=&gt; 7 ) ).say ;  # OUTPUT: «a =&gt; 3␤»</code></pre></p>","m":1,"s":{"r":"Mu","p":[{"t":"Callable","n":"&by"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"max","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method max()\nmulti method max(&amp;by)\nmulti sub max(+args, :&amp;by!)\nmulti sub max(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically largest element; in the case of Hashes, the Pair with the highest value.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and the return value is compared instead of the original value. The original value is still the one returned from max.</p><p><pre><code>say (1,7,3).max();                # OUTPUT:«7␤»\nsay (1,7,3).max({1/$_});          # OUTPUT:«1␤»\nsay max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\nsay max(1,7,3);                   # OUTPUT: «7␤»\nmax( %(a =&gt; 'B', b=&gt; 'C' ) ).say; # OUTPUT: «b =&gt; C␤»</code></pre></p>"},{"n":"max","s":{"p":[{"t":"Callable","n":"&by"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method max()\nmulti method max(&amp;by)\nmulti sub max(+args, :&amp;by!)\nmulti sub max(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically largest element; in the case of Hashes, the Pair with the highest value.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and the return value is compared instead of the original value. The original value is still the one returned from max.</p><p><pre><code>say (1,7,3).max();                # OUTPUT:«7␤»\nsay (1,7,3).max({1/$_});          # OUTPUT:«1␤»\nsay max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\nsay max(1,7,3);                   # OUTPUT: «7␤»\nmax( %(a =&gt; 'B', b=&gt; 'C' ) ).say; # OUTPUT: «b =&gt; C␤»</code></pre></p>","k":"m"},{"m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"minmax","d":"<p>Defined as:</p><p><pre><code>multi method minmax()\nmulti method minmax(&amp;by)\nmulti sub minmax(+args, :&amp;by!)\nmulti sub minmax(+args)</code></pre></p><p>Returns a Range from the smallest to the largest element.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original values are still used in the returned Range.</p><p><pre><code>say (1,7,3).minmax();        # OUTPUT:«1..7␤»\nsay (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\nsay minmax(1,7,3);           # OUTPUT: «1..7␤»\nsay minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»</code></pre></p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method minmax()\nmulti method minmax(&amp;by)\nmulti sub minmax(+args, :&amp;by!)\nmulti sub minmax(+args)</code></pre></p><p>Returns a Range from the smallest to the largest element.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original values are still used in the returned Range.</p><p><pre><code>say (1,7,3).minmax();        # OUTPUT:«1..7␤»\nsay (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\nsay minmax(1,7,3);           # OUTPUT: «1..7␤»\nsay minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»</code></pre></p>","n":"minmax","s":{"r":"Mu","p":[{"n":"&by","t":"Callable"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1},{"d":"<p>Defined as:</p><p><pre><code>multi method sort()\nmulti method sort(&amp;custom-routine-to-use)</code></pre></p><p>Sorts iterables with cmp or given code object and returns a new Seq. Optionally, takes a Callable as a positional parameter, specifying how to sort.</p><p>Examples:</p><p><pre><code>say &lt;b c a&gt;.sort;                           # OUTPUT: «(a b c)␤»\nsay 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\nsay 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\nsay '231'.comb.sort(&amp;infix:«&lt;=&gt;»).join;     # OUTPUT: «123␤»</code></pre></p>","n":"sort","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"s":{"p":[{"n":"&by","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method sort()\nmulti method sort(&amp;custom-routine-to-use)</code></pre></p><p>Sorts iterables with cmp or given code object and returns a new Seq. Optionally, takes a Callable as a positional parameter, specifying how to sort.</p><p>Examples:</p><p><pre><code>say &lt;b c a&gt;.sort;                           # OUTPUT: «(a b c)␤»\nsay 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\nsay 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\nsay '231'.comb.sort(&amp;infix:«&lt;=&gt;»).join;     # OUTPUT: «123␤»</code></pre></p>","k":"m","m":1,"n":"sort"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"collate","d":"<p>Defined as:</p><p><pre><code>method collate()</code></pre></p><p>Collate sorts taking into account Unicode grapheme characteristics; that is, sorting more or less as one would expect instead of using the order in which their codepoints appear. collate will behave this way if the object it is applied to is Iterable.</p><p><pre><code>say ('a', 'Z').sort; # (Z a)\nsay ('a', 'Z').collate; # (a Z)\nsay &lt;ä a o ö&gt;.collate; # (a ä o ö)\nmy %hash = 'aa' =&gt; 'value', 'Za' =&gt; 'second';\nsay %hash.collate; # (aa =&gt; value Za =&gt; second);\n</code></pre></p><p>This method is affected by the $*COLLATION variable, which configures the four collation levels. While the Primary, Secondary and Tertiary mean different things for different scripts, for the Latin script used in English they mostly correspond with Primary being Alphabetic, Secondary being Diacritics and Tertiary being Case.</p><p>In the example below you can see how when we disable tertiary collation which in Latin script generally is for case, and also disable quaternary which breaks any ties by checking the codepoint values of the strings, we get Same back for A and a:</p><p><pre><code>$*COLLATION.set(:quaternary(False), :tertiary(False));\nsay 'a' coll 'A'; #OUTPUT: «Same␤»\nsay ('a','A').collate == ('A','a').collate; # OUTPUT: «True␤»</code></pre></p><p>The variable affects the coll operator as shown as well as this method.</p>","k":"m"},{"m":1,"s":{"r":"Nil","p":[{"n":"&","t":"Callable"},{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method reduce(Any:U: &amp; --&gt; Nil)\nmulti method reduce(Any:D: &amp;with)\nmulti sub reduce (&amp;with, +list)</code></pre></p><p>Applying it to a class will always produce Nil. Applies its argument (or first argument, in case it's a sub) as an operator to all the elements in the object (or second argument), producing a single result. The argument must be an infix operator or take, in any case, two positional arguments.</p><p><pre><code>(1..13).reduce( &amp;[*] ).say; # OUTPUT: «6227020800␤»</code></pre></p>","n":"reduce"},{"m":1,"n":"reduce","s":{"r":"Mu","p":[{"t":"Callable","n":"&with"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi method reduce(Any:U: &amp; --&gt; Nil)\nmulti method reduce(Any:D: &amp;with)\nmulti sub reduce (&amp;with, +list)</code></pre></p><p>Applying it to a class will always produce Nil. Applies its argument (or first argument, in case it's a sub) as an operator to all the elements in the object (or second argument), producing a single result. The argument must be an infix operator or take, in any case, two positional arguments.</p><p><pre><code>(1..13).reduce( &amp;[*] ).say; # OUTPUT: «6227020800␤»</code></pre></p>","k":"m"},{"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method produce(Any:U: &amp; --&gt; Nil)\nmulti method produce(Any:D: &amp;with)\nmulti sub produce (&amp;with, +list)</code></pre></p><p>This is similar to reduce, but returns a list with the accumulated values instead of a single result.</p><p><pre><code>&lt;10 5 3&gt;.reduce( &amp;[*] ).say ; # OUTPUT: «150␤»\n&lt;10 5 3&gt;.produce( &amp;[*] ).say; # OUTPUT: «(10 50 150)␤»\n</code></pre></p><p>The last element of the produced list would be the output produced by the .reduce method.</p><p>If it's a class, it will simply return Nil.</p>","s":{"p":[{"t":"Callable","n":"&"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m","n":"produce"},{"s":{"r":"Mu","p":[{"n":"&with","t":"Callable"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method produce(Any:U: &amp; --&gt; Nil)\nmulti method produce(Any:D: &amp;with)\nmulti sub produce (&amp;with, +list)</code></pre></p><p>This is similar to reduce, but returns a list with the accumulated values instead of a single result.</p><p><pre><code>&lt;10 5 3&gt;.reduce( &amp;[*] ).say ; # OUTPUT: «150␤»\n&lt;10 5 3&gt;.produce( &amp;[*] ).say; # OUTPUT: «(10 50 150)␤»\n</code></pre></p><p>The last element of the produced list would be the output produced by the .reduce method.</p><p>If it's a class, it will simply return Nil.</p>","m":1,"n":"produce"},{"n":"unique","d":"<p>Defined as:</p><p><pre><code>multi method unique()\nmulti method unique( :&amp;as!, :&amp;with! )\nmulti method unique( :&amp;as! )\nmulti method unique( :&amp;with! )</code></pre></p><p>Creates a sequence of unique elements either of the object or of values in the case it's called as a sub.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.unique.say; # OUTPUT: «(1 2 3)␤»\nsay unique &lt;1 2 2 3 3 3&gt;; # OUTPUT: «(1 2 3)␤»</code></pre></p><p>The :as and :with parameters receive functions that are used for transforming the item before checking equality, and for checking equality, since by default the === operator is used:</p><p><pre><code>(\"1\", 1, \"1 \", 2).unique( as =&gt; Int, with =&gt; &amp;[==] ).say; #OUTPUT: «(1 2)␤»</code></pre></p><p>Please see unique for additional examples that use its sub form.</p>","m":1,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":1,"s":{"r":"Mu","p":[{"n":":&as!","t":"Callable"},{"n":":&with!","t":"Callable"},{"n":"*%_","t":"Mu"}]},"n":"unique","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method unique()\nmulti method unique( :&amp;as!, :&amp;with! )\nmulti method unique( :&amp;as! )\nmulti method unique( :&amp;with! )</code></pre></p><p>Creates a sequence of unique elements either of the object or of values in the case it's called as a sub.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.unique.say; # OUTPUT: «(1 2 3)␤»\nsay unique &lt;1 2 2 3 3 3&gt;; # OUTPUT: «(1 2 3)␤»</code></pre></p><p>The :as and :with parameters receive functions that are used for transforming the item before checking equality, and for checking equality, since by default the === operator is used:</p><p><pre><code>(\"1\", 1, \"1 \", 2).unique( as =&gt; Int, with =&gt; &amp;[==] ).say; #OUTPUT: «(1 2)␤»</code></pre></p><p>Please see unique for additional examples that use its sub form.</p>"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method unique()\nmulti method unique( :&amp;as!, :&amp;with! )\nmulti method unique( :&amp;as! )\nmulti method unique( :&amp;with! )</code></pre></p><p>Creates a sequence of unique elements either of the object or of values in the case it's called as a sub.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.unique.say; # OUTPUT: «(1 2 3)␤»\nsay unique &lt;1 2 2 3 3 3&gt;; # OUTPUT: «(1 2 3)␤»</code></pre></p><p>The :as and :with parameters receive functions that are used for transforming the item before checking equality, and for checking equality, since by default the === operator is used:</p><p><pre><code>(\"1\", 1, \"1 \", 2).unique( as =&gt; Int, with =&gt; &amp;[==] ).say; #OUTPUT: «(1 2)␤»</code></pre></p><p>Please see unique for additional examples that use its sub form.</p>","s":{"p":[{"t":"Callable","n":":&as!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"unique","m":1},{"k":"m","s":{"r":"Mu","p":[{"t":"Callable","n":":&with!"},{"n":"*%_","t":"Mu"}]},"m":1,"d":"<p>Defined as:</p><p><pre><code>multi method unique()\nmulti method unique( :&amp;as!, :&amp;with! )\nmulti method unique( :&amp;as! )\nmulti method unique( :&amp;with! )</code></pre></p><p>Creates a sequence of unique elements either of the object or of values in the case it's called as a sub.</p><p><pre><code>&lt;1 2 2 3 3 3&gt;.unique.say; # OUTPUT: «(1 2 3)␤»\nsay unique &lt;1 2 2 3 3 3&gt;; # OUTPUT: «(1 2 3)␤»</code></pre></p><p>The :as and :with parameters receive functions that are used for transforming the item before checking equality, and for checking equality, since by default the === operator is used:</p><p><pre><code>(\"1\", 1, \"1 \", 2).unique( as =&gt; Int, with =&gt; &amp;[==] ).say; #OUTPUT: «(1 2)␤»</code></pre></p><p>Please see unique for additional examples that use its sub form.</p>","n":"unique"},{"m":1,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi method repeated()\nmulti method repeated( :&amp;as!, :&amp;with! )\nmulti method repeated( :&amp;as! )\nmulti method repeated( :&amp;with! )</code></pre></p><p>Similarly to unique, finds repeated elements in values (as a routine) or in the object, using the :as associative argument as a normalizing function and :with as equality function.</p><p><pre><code>&lt;1 -1 2 -2 3&gt;.repeated(:as(&amp;abs),:with(&amp;[==])).say; # OUTPUT: «(-1 -2)␤»\n(3+3i, 3+2i, 2+1i).repeated(as =&gt; *.re).say;        # OUTPUT: «(3+2i)␤»</code></pre></p><p>It returns the last repeated element before normalization, as shown in the example above. See repeated for more examples that use its sub form.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"repeated"},{"m":1,"n":"repeated","s":{"p":[{"n":":&as!","t":"Callable"},{"t":"Callable","n":":&with!"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method repeated()\nmulti method repeated( :&amp;as!, :&amp;with! )\nmulti method repeated( :&amp;as! )\nmulti method repeated( :&amp;with! )</code></pre></p><p>Similarly to unique, finds repeated elements in values (as a routine) or in the object, using the :as associative argument as a normalizing function and :with as equality function.</p><p><pre><code>&lt;1 -1 2 -2 3&gt;.repeated(:as(&amp;abs),:with(&amp;[==])).say; # OUTPUT: «(-1 -2)␤»\n(3+3i, 3+2i, 2+1i).repeated(as =&gt; *.re).say;        # OUTPUT: «(3+2i)␤»</code></pre></p><p>It returns the last repeated element before normalization, as shown in the example above. See repeated for more examples that use its sub form.</p>","k":"m"},{"m":1,"n":"repeated","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method repeated()\nmulti method repeated( :&amp;as!, :&amp;with! )\nmulti method repeated( :&amp;as! )\nmulti method repeated( :&amp;with! )</code></pre></p><p>Similarly to unique, finds repeated elements in values (as a routine) or in the object, using the :as associative argument as a normalizing function and :with as equality function.</p><p><pre><code>&lt;1 -1 2 -2 3&gt;.repeated(:as(&amp;abs),:with(&amp;[==])).say; # OUTPUT: «(-1 -2)␤»\n(3+3i, 3+2i, 2+1i).repeated(as =&gt; *.re).say;        # OUTPUT: «(3+2i)␤»</code></pre></p><p>It returns the last repeated element before normalization, as shown in the example above. See repeated for more examples that use its sub form.</p>","s":{"r":"Mu","p":[{"n":":&as!","t":"Callable"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method repeated()\nmulti method repeated( :&amp;as!, :&amp;with! )\nmulti method repeated( :&amp;as! )\nmulti method repeated( :&amp;with! )</code></pre></p><p>Similarly to unique, finds repeated elements in values (as a routine) or in the object, using the :as associative argument as a normalizing function and :with as equality function.</p><p><pre><code>&lt;1 -1 2 -2 3&gt;.repeated(:as(&amp;abs),:with(&amp;[==])).say; # OUTPUT: «(-1 -2)␤»\n(3+3i, 3+2i, 2+1i).repeated(as =&gt; *.re).say;        # OUTPUT: «(3+2i)␤»</code></pre></p><p>It returns the last repeated element before normalization, as shown in the example above. See repeated for more examples that use its sub form.</p>","s":{"r":"Mu","p":[{"n":":&with!","t":"Callable"},{"n":"*%_","t":"Mu"}]},"n":"repeated","m":1,"k":"m"},{"n":"squish","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method squish( :&amp;as!, :&amp;with = &amp;[===] )\nmulti method squish( :&amp;with = &amp;[===] )</code></pre></p><p>Similar to .repeated, returns the sequence of first elements of contiguous sequences of equal elements, after normalization by the function :as, if present, and using as an equality operator the :with argument or === by default.</p><p><pre><code>\"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n\"aABbccdDaa\".comb.squish( :as(&amp;lc) ).say; # OUTPUT: «(a B c d a)␤»\n(3+2i,3+3i,4+0i).squish( as =&gt; *.re, with =&gt; &amp;[==]).put; #OUTPUT: «3+2i 4+0i␤»\n</code></pre></p><p>As shown in the last example, a sequence can contain a single element. See squish for additional sub examples.</p>","s":{"r":"Mu","p":[{"t":"Callable","n":":&as!"},{"n":":&with?","t":"Callable"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method squish( :&amp;as!, :&amp;with = &amp;[===] )\nmulti method squish( :&amp;with = &amp;[===] )</code></pre></p><p>Similar to .repeated, returns the sequence of first elements of contiguous sequences of equal elements, after normalization by the function :as, if present, and using as an equality operator the :with argument or === by default.</p><p><pre><code>\"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n\"aABbccdDaa\".comb.squish( :as(&amp;lc) ).say; # OUTPUT: «(a B c d a)␤»\n(3+2i,3+3i,4+0i).squish( as =&gt; *.re, with =&gt; &amp;[==]).put; #OUTPUT: «3+2i 4+0i␤»\n</code></pre></p><p>As shown in the last example, a sequence can contain a single element. See squish for additional sub examples.</p>","m":1,"k":"m","s":{"p":[{"t":"Callable","n":":&with?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"squish"},{"m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pairup","d":"<p>Defined as:</p><p><pre><code>multi method pairup(Any:U:)\nmulti method pairup(Any:D:)</code></pre></p><p>Returns an empty Seq if the invocant is a type object</p><p><pre><code>Range.pairup.say; # OUTPUT: «()␤»</code></pre></p><p>Interprets the invocant as a list, and constructs a list of pairs from it, in the same way that assignment to a Hash does. That is, it takes two consecutive elements and constructs a pair from them, unless the item in the key position already is a pair (in which case the pair is passed through, and the next list item, if any, is considered to be a key again). It returns a Seq of Pairs.</p><p><pre><code>say (a =&gt; 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»</code></pre></p><p></p>"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi method pairup(Any:U:)\nmulti method pairup(Any:D:)</code></pre></p><p>Returns an empty Seq if the invocant is a type object</p><p><pre><code>Range.pairup.say; # OUTPUT: «()␤»</code></pre></p><p>Interprets the invocant as a list, and constructs a list of pairs from it, in the same way that assignment to a Hash does. That is, it takes two consecutive elements and constructs a pair from them, unless the item in the key position already is a pair (in which case the pair is passed through, and the next list item, if any, is considered to be a key again). It returns a Seq of Pairs.</p><p><pre><code>say (a =&gt; 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»</code></pre></p><p></p>","n":"pairup","m":1},{"n":"toggle","k":"m","d":"<p>Defined as:</p><p><pre><code>method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --&gt; Seq:D)</code></pre></p><p>Iterates over the invocant, producing a Seq, toggling whether the received values are propagated to the result on and off, depending on the results of calling Callables in @conditions:</p><p><pre><code>say (1..15).toggle(* &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\nsay (1..15).toggle(:off, * &gt; 2, * &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n</code></pre></p><p>Imagine a switch that's either on or off (True or False), and values are produced if it's on. By default, the initial state of that switch is in \"on\" position, unless :$off is set to a true value, in which case the initial state will be \"off\".</p><p>A Callable from the head of @conditions is taken (if any are available) and it becomes the current tester. Each value from the original sequence is tested by calling the tester Callable with that value. The state of our imaginary switch is set to the return value from the tester: if it's truthy, set switch to \"on\", otherwise set it to \"off\".</p><p>Whenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from \"on\" to \"off\"), the current tester Callable is replaced by the next Callable in @conditions, if available, which will be used to test any further values. If no more tester Callables are available, the switch will remain in its current state until the end of iteration.</p><p><pre><code># our original sequence of elements:\nsay list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n# toggled result:\nsay ^10 .toggle: * &lt; 4, * %% 2, &amp;is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n# First tester Callable is `* &lt; 4` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &lt; 4 === True  switch is on, value gets into result, switch is\n#                      toggled, so we keep using the same Callable:\n# 1 =&gt; 1 &lt; 4 === True  same\n# 2 =&gt; 2 &lt; 4 === True  same\n# 3 =&gt; 3 &lt; 4 === True  same\n# 4 =&gt; 4 &lt; 4 === False switch is now off, \"4\" does not make it into the\n#                      result. In addition, our switch got toggled, so\n#                      we're switching to the next tester Callable\n# 5 =&gt; 5 %% 2 === False  switch is still off, keep trying to find a value\n# 6 =&gt; 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n#                        toggled, so we'll use the next tester Callable\n# 7 =&gt; is-prime(7) === True  switch is still on, take value and keep going\n# 8 =&gt; is-prime(8) === False switch is now off, \"8\" does not make it into\n#                            the result. The switch got toggled, but we\n#                            don't have any more tester Callables, so it\n#                            will remain off for the rest of the sequence.\n</code></pre></p><p>Since the toggle of the switch's state loads the next tester Callable, setting :$off to a True value affects when first tester is discarded:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: * &gt; 1; # OUTPUT: «()␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                      In addition, switch got toggled, so we change the\n#                      tester Callable, and since we don't have any more\n#                      of them, the switch will remain \"off\" until the end\n</code></pre></p><p>The behavior changes when :off is used:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: :off, * &gt; 1; # OUTPUT: «(2)␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"off\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                       The switch did NOT get toggled this time, so we\n#                       keep using our current tester Callable\n# 1 =&gt; 1 &gt; 1 === False  same\n# 2 =&gt; 2 &gt; 1 === True   switch is on, \"2\" makes it into the result\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"condition","t":"Callable"},{"n":":$off!","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":1},{"s":{"r":"Mu","p":[{"n":"condition","t":"Callable"},{"n":"*%_","t":"Mu"}]},"m":1,"d":"<p>Defined as:</p><p><pre><code>method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --&gt; Seq:D)</code></pre></p><p>Iterates over the invocant, producing a Seq, toggling whether the received values are propagated to the result on and off, depending on the results of calling Callables in @conditions:</p><p><pre><code>say (1..15).toggle(* &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\nsay (1..15).toggle(:off, * &gt; 2, * &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n</code></pre></p><p>Imagine a switch that's either on or off (True or False), and values are produced if it's on. By default, the initial state of that switch is in \"on\" position, unless :$off is set to a true value, in which case the initial state will be \"off\".</p><p>A Callable from the head of @conditions is taken (if any are available) and it becomes the current tester. Each value from the original sequence is tested by calling the tester Callable with that value. The state of our imaginary switch is set to the return value from the tester: if it's truthy, set switch to \"on\", otherwise set it to \"off\".</p><p>Whenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from \"on\" to \"off\"), the current tester Callable is replaced by the next Callable in @conditions, if available, which will be used to test any further values. If no more tester Callables are available, the switch will remain in its current state until the end of iteration.</p><p><pre><code># our original sequence of elements:\nsay list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n# toggled result:\nsay ^10 .toggle: * &lt; 4, * %% 2, &amp;is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n# First tester Callable is `* &lt; 4` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &lt; 4 === True  switch is on, value gets into result, switch is\n#                      toggled, so we keep using the same Callable:\n# 1 =&gt; 1 &lt; 4 === True  same\n# 2 =&gt; 2 &lt; 4 === True  same\n# 3 =&gt; 3 &lt; 4 === True  same\n# 4 =&gt; 4 &lt; 4 === False switch is now off, \"4\" does not make it into the\n#                      result. In addition, our switch got toggled, so\n#                      we're switching to the next tester Callable\n# 5 =&gt; 5 %% 2 === False  switch is still off, keep trying to find a value\n# 6 =&gt; 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n#                        toggled, so we'll use the next tester Callable\n# 7 =&gt; is-prime(7) === True  switch is still on, take value and keep going\n# 8 =&gt; is-prime(8) === False switch is now off, \"8\" does not make it into\n#                            the result. The switch got toggled, but we\n#                            don't have any more tester Callables, so it\n#                            will remain off for the rest of the sequence.\n</code></pre></p><p>Since the toggle of the switch's state loads the next tester Callable, setting :$off to a True value affects when first tester is discarded:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: * &gt; 1; # OUTPUT: «()␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                      In addition, switch got toggled, so we change the\n#                      tester Callable, and since we don't have any more\n#                      of them, the switch will remain \"off\" until the end\n</code></pre></p><p>The behavior changes when :off is used:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: :off, * &gt; 1; # OUTPUT: «(2)␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"off\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                       The switch did NOT get toggled this time, so we\n#                       keep using our current tester Callable\n# 1 =&gt; 1 &gt; 1 === False  same\n# 2 =&gt; 2 &gt; 1 === True   switch is on, \"2\" makes it into the result\n</code></pre></p>","k":"m","n":"toggle"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --&gt; Seq:D)</code></pre></p><p>Iterates over the invocant, producing a Seq, toggling whether the received values are propagated to the result on and off, depending on the results of calling Callables in @conditions:</p><p><pre><code>say (1..15).toggle(* &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\nsay (1..15).toggle(:off, * &gt; 2, * &lt; 5, * &gt; 10, * &lt; 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n</code></pre></p><p>Imagine a switch that's either on or off (True or False), and values are produced if it's on. By default, the initial state of that switch is in \"on\" position, unless :$off is set to a true value, in which case the initial state will be \"off\".</p><p>A Callable from the head of @conditions is taken (if any are available) and it becomes the current tester. Each value from the original sequence is tested by calling the tester Callable with that value. The state of our imaginary switch is set to the return value from the tester: if it's truthy, set switch to \"on\", otherwise set it to \"off\".</p><p>Whenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from \"on\" to \"off\"), the current tester Callable is replaced by the next Callable in @conditions, if available, which will be used to test any further values. If no more tester Callables are available, the switch will remain in its current state until the end of iteration.</p><p><pre><code># our original sequence of elements:\nsay list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n# toggled result:\nsay ^10 .toggle: * &lt; 4, * %% 2, &amp;is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n# First tester Callable is `* &lt; 4` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &lt; 4 === True  switch is on, value gets into result, switch is\n#                      toggled, so we keep using the same Callable:\n# 1 =&gt; 1 &lt; 4 === True  same\n# 2 =&gt; 2 &lt; 4 === True  same\n# 3 =&gt; 3 &lt; 4 === True  same\n# 4 =&gt; 4 &lt; 4 === False switch is now off, \"4\" does not make it into the\n#                      result. In addition, our switch got toggled, so\n#                      we're switching to the next tester Callable\n# 5 =&gt; 5 %% 2 === False  switch is still off, keep trying to find a value\n# 6 =&gt; 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n#                        toggled, so we'll use the next tester Callable\n# 7 =&gt; is-prime(7) === True  switch is still on, take value and keep going\n# 8 =&gt; is-prime(8) === False switch is now off, \"8\" does not make it into\n#                            the result. The switch got toggled, but we\n#                            don't have any more tester Callables, so it\n#                            will remain off for the rest of the sequence.\n</code></pre></p><p>Since the toggle of the switch's state loads the next tester Callable, setting :$off to a True value affects when first tester is discarded:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: * &gt; 1; # OUTPUT: «()␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                      In addition, switch got toggled, so we change the\n#                      tester Callable, and since we don't have any more\n#                      of them, the switch will remain \"off\" until the end\n</code></pre></p><p>The behavior changes when :off is used:</p><p><pre><code># our original sequence of elements:\nsay &lt;0 1 2&gt;; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay &lt;0 1 2&gt;.toggle: :off, * &gt; 1; # OUTPUT: «(2)␤»\n\n# First tester Callable is `* &gt; 1` and initial state of switch is \"off\".\n# As we iterate over our original sequence:\n# 0 =&gt; 0 &gt; 1 === False  switch is off, \"0\" does not make it into result.\n#                       The switch did NOT get toggled this time, so we\n#                       keep using our current tester Callable\n# 1 =&gt; 1 &gt; 1 === False  same\n# 2 =&gt; 2 &gt; 1 === True   switch is on, \"2\" makes it into the result\n</code></pre></p>","m":1,"n":"toggle","s":{"p":[{"t":"Positional","n":"*@conditions"},{"n":":$off","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"n":"head","d":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>Returns either the first element in the object, or the first $n if that's used.</p><p><pre><code>\"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n\"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\nsay ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\nsay ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\nsay ^10 .head;              # OUTPUT: «0␤»\nsay ^∞ .head;               # OUTPUT: «0␤»</code></pre></p><p>In the first two cases, the results are different since there's no defined order in Mixes. In the other cases, it returns a Seq. A Callable can be used to return all but the last elements:</p><p><pre><code>say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»</code></pre></p>","m":1,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"head","d":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>Returns either the first element in the object, or the first $n if that's used.</p><p><pre><code>\"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n\"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\nsay ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\nsay ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\nsay ^10 .head;              # OUTPUT: «0␤»\nsay ^∞ .head;               # OUTPUT: «0␤»</code></pre></p><p>In the first two cases, the results are different since there's no defined order in Mixes. In the other cases, it returns a Seq. A Callable can be used to return all but the last elements:</p><p><pre><code>say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»</code></pre></p>","m":1},{"n":"head","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>Returns either the first element in the object, or the first $n if that's used.</p><p><pre><code>\"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n\"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\nsay ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\nsay ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\nsay ^10 .head;              # OUTPUT: «0␤»\nsay ^∞ .head;               # OUTPUT: «0␤»</code></pre></p><p>In the first two cases, the results are different since there's no defined order in Mixes. In the other cases, it returns a Seq. A Callable can be used to return all but the last elements:</p><p><pre><code>say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"$w","t":"Callable"},{"t":"Mu","n":"*%_"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>Returns either the first element in the object, or the first $n if that's used.</p><p><pre><code>\"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n\"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\nsay ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\nsay ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\nsay ^10 .head;              # OUTPUT: «0␤»\nsay ^∞ .head;               # OUTPUT: «0␤»</code></pre></p><p>In the first two cases, the results are different since there's no defined order in Mixes. In the other cases, it returns a Seq. A Callable can be used to return all but the last elements:</p><p><pre><code>say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»</code></pre></p>","n":"head","s":{"r":"Mu","p":[{"t":"Any","n":"$n"},{"n":"*%_","t":"Mu"}]},"k":"m","m":1},{"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"d":"<p>Defined as:</p><p><pre><code>multi method tail() is raw\nmulti method tail($n)</code></pre></p><p>Returns the last or the list of the $n last elements of an object. $n can be a Callable, usually a WhateverCode, which will be used to get all but the first n elements of the object.</p><p><pre><code>say (^12).reverse.tail ;     # OUTPUT: «0␤»\nsay (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\nsay (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»\n</code></pre></p>","m":1,"k":"m","n":"tail"},{"d":"<p>Defined as:</p><p><pre><code>multi method tail() is raw\nmulti method tail($n)</code></pre></p><p>Returns the last or the list of the $n last elements of an object. $n can be a Callable, usually a WhateverCode, which will be used to get all but the first n elements of the object.</p><p><pre><code>say (^12).reverse.tail ;     # OUTPUT: «0␤»\nsay (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\nsay (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»\n</code></pre></p>","m":1,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"tail"},{"d":"<p>Defined as:</p><p><pre><code>multi method tail() is raw\nmulti method tail($n)</code></pre></p><p>Returns the last or the list of the $n last elements of an object. $n can be a Callable, usually a WhateverCode, which will be used to get all but the first n elements of the object.</p><p><pre><code>say (^12).reverse.tail ;     # OUTPUT: «0␤»\nsay (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\nsay (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»\n</code></pre></p>","n":"tail","m":1,"s":{"r":"Mu","p":[{"n":"$n","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"skip","m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>multi method skip()\nmulti method skip(Whatever)\nmulti method skip(Callable:D $w)\nmulti method skip(Int() $n)</code></pre></p><p>Creates a Seq from 1-item list's iterator and uses Seq.skip on it, please check that document for real use cases; calling skip without argument is equivalent to skip(1).</p><p>Calling it with Whatever will return an empty iterator:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*);   # OUTPUT: «()␤»</code></pre></p><p>The multi that uses a Callable is intended mainly to be used this way:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*-1); # OUTPUT: «(3)␤»</code></pre></p><p>Instead of throwing away the first $n elements, it throws away everything but the elements indicated by the WhateverCode, in this case all but the last one.</p>","k":"m"},{"n":"skip","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method skip()\nmulti method skip(Whatever)\nmulti method skip(Callable:D $w)\nmulti method skip(Int() $n)</code></pre></p><p>Creates a Seq from 1-item list's iterator and uses Seq.skip on it, please check that document for real use cases; calling skip without argument is equivalent to skip(1).</p><p>Calling it with Whatever will return an empty iterator:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*);   # OUTPUT: «()␤»</code></pre></p><p>The multi that uses a Callable is intended mainly to be used this way:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*-1); # OUTPUT: «(3)␤»</code></pre></p><p>Instead of throwing away the first $n elements, it throws away everything but the elements indicated by the WhateverCode, in this case all but the last one.</p>","s":{"r":"Mu","p":[{"n":"$","t":"Whatever"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method skip()\nmulti method skip(Whatever)\nmulti method skip(Callable:D $w)\nmulti method skip(Int() $n)</code></pre></p><p>Creates a Seq from 1-item list's iterator and uses Seq.skip on it, please check that document for real use cases; calling skip without argument is equivalent to skip(1).</p><p>Calling it with Whatever will return an empty iterator:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*);   # OUTPUT: «()␤»</code></pre></p><p>The multi that uses a Callable is intended mainly to be used this way:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*-1); # OUTPUT: «(3)␤»</code></pre></p><p>Instead of throwing away the first $n elements, it throws away everything but the elements indicated by the WhateverCode, in this case all but the last one.</p>","m":1,"n":"skip","k":"m","s":{"p":[{"n":"$w","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"skip","k":"m","m":1,"d":"<p>Defined as:</p><p><pre><code>multi method skip()\nmulti method skip(Whatever)\nmulti method skip(Callable:D $w)\nmulti method skip(Int() $n)</code></pre></p><p>Creates a Seq from 1-item list's iterator and uses Seq.skip on it, please check that document for real use cases; calling skip without argument is equivalent to skip(1).</p><p>Calling it with Whatever will return an empty iterator:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*);   # OUTPUT: «()␤»</code></pre></p><p>The multi that uses a Callable is intended mainly to be used this way:</p><p><pre><code>say &lt;1 2 3&gt;.skip(*-1); # OUTPUT: «(3)␤»</code></pre></p><p>Instead of throwing away the first $n elements, it throws away everything but the elements indicated by the WhateverCode, in this case all but the last one.</p>","s":{"r":"Mu","p":[{"t":"Any","n":"$n"},{"n":"*%_","t":"Mu"}]}},{"m":1,"n":"minpairs","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>multi method minpairs(Any:D:)</code></pre></p><p>Calls .pairs and returns a Seq with all of the Pairs with minimum values, as judged by the cmp operator:</p><p><pre><code>&lt;a b c a b c&gt;.minpairs.perl.put; # OUTPUT: «(0 =&gt; \"a\", 3 =&gt; \"a\").Seq␤»\n%(:42a, :75b).minpairs.perl.put; # OUTPUT: «(:a(42),).Seq␤»</code></pre></p>"},{"m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"maxpairs","d":"<p>Defined as:</p><p><pre><code>multi method maxpairs(Any:D:)</code></pre></p><p>Calls .pairs and returns a Seq with all of the Pairs with maximum values, as judged by the cmp operator:</p><p><pre><code>&lt;a b c a b c&gt;.maxpairs.perl.put; # OUTPUT: «(2 =&gt; \"c\", 5 =&gt; \"c\").Seq␤»\n%(:42a, :75b).maxpairs.perl.put; # OUTPUT: «(:b(75),).Seq␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>multi method batch(Int:D $batch)\nmulti method batch(Int:D :$elems!)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.batch on it.</p>","m":1,"s":{"r":"Mu","p":[{"n":":$elems!","t":"Int"},{"n":"*%_","t":"Mu"}]},"n":"batch","k":"m"},{"n":"batch","s":{"p":[{"t":"Int","n":"$batch"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>multi method batch(Int:D $batch)\nmulti method batch(Int:D :$elems!)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.batch on it.</p>","m":1,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi method rotor(Any:D: Int:D $batch, :$partial)\nmulti method rotor(Any:D: *@cycle, :$partial)</code></pre></p><p>Groups the elements of the object in lists of $batch elements.</p><p><pre><code>say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»</code></pre></p><p>With the :partial named argument, it will also include lists that do not get to be the $batch size:</p><p><pre><code>say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»</code></pre></p><p>.rotor can be called with an array of integers and pairs, which will be applied in turn. While integers will establish the batch size, as above, Pairs will use the key as batch size and the value as number of elements to skip if it's positive, or overlap if it's negative.</p><p><pre><code>say (3..11).rotor(3, 2 =&gt; 1, 3 =&gt; -2, :partial);\n# OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»</code></pre></p><p>In this case, the first batch (ruled by an integer) has 3 elements; the second one has 2 elements (key of the pair), but skips one (the number 8); the third one has size 2 (because partials are allowed), and an overlap of 2 also.</p><p>Please see also list.rotor for examples applied to lists.</p>","m":1,"s":{"p":[{"n":"$batch","t":"Int"},{"t":"Any","n":":$partial"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"rotor"},{"d":"<p>Defined as:</p><p><pre><code>multi method rotor(Any:D: Int:D $batch, :$partial)\nmulti method rotor(Any:D: *@cycle, :$partial)</code></pre></p><p>Groups the elements of the object in lists of $batch elements.</p><p><pre><code>say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»</code></pre></p><p>With the :partial named argument, it will also include lists that do not get to be the $batch size:</p><p><pre><code>say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»</code></pre></p><p>.rotor can be called with an array of integers and pairs, which will be applied in turn. While integers will establish the batch size, as above, Pairs will use the key as batch size and the value as number of elements to skip if it's positive, or overlap if it's negative.</p><p><pre><code>say (3..11).rotor(3, 2 =&gt; 1, 3 =&gt; -2, :partial);\n# OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»</code></pre></p><p>In this case, the first batch (ruled by an integer) has 3 elements; the second one has 2 elements (key of the pair), but skips one (the number 8); the third one has size 2 (because partials are allowed), and an overlap of 2 also.</p><p>Please see also list.rotor for examples applied to lists.</p>","m":1,"n":"rotor","k":"m","s":{"r":"Mu","p":[{"t":"Positional","n":"+@cycle"},{"t":"Any","n":":$partial"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"index","t":"Any"},{"n":"value","t":"Any"},{"n":"$what","t":"Any"},{"n":"%a","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"!first-result"},{"m":0,"k":"m","n":"!grep-callable","s":{"p":[{"t":"Callable","n":"$test"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"!first-accepts-end","m":0,"s":{"p":[{"t":"Mu","n":"$test"},{"t":"Associative","n":"%a"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"!grep-k","m":0,"s":{"p":[{"n":"$test","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"s":{"p":[{"n":"$action","t":"Any"},{"n":"first","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!iterator-and-first","k":"m"},{"k":"m","s":{"p":[{"n":"$test","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!grep-p","m":0},{"s":{"r":"Mu","p":[{"n":"$test","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!wrap-callable-for-grep"},{"s":{"r":"Nil","p":[{"n":"value","t":"Any"},{"t":"Any","n":"mi"},{"t":"Any","n":"exmi"},{"t":"Any","n":"ma"},{"n":"exma","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!minmax-range-check","k":"m","m":0},{"n":"!grep-accepts","k":"m","s":{"p":[{"n":"$test","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"$test","t":"Mu"},{"t":"Associative","n":"%a"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"!first-accepts"},{"s":{"p":[{"t":"Any","n":"value"},{"n":"mi","t":"Any"},{"t":"Any","n":"exmi"},{"n":"ma","t":"Any"},{"n":"exma","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"!minmax-range-init","k":"m","m":0},{"n":"!grep-kv","m":0,"k":"m","s":{"p":[{"t":"Callable","n":"$test"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"!cmp-minmax-range-check","m":0,"s":{"p":[{"n":"value","t":"Any"},{"t":"Any","n":"$cmp"},{"n":"mi","t":"Any"},{"t":"Any","n":"exmi"},{"t":"Any","n":"ma"},{"n":"exma","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m"}],"d":"<p><pre><code>class Any is Mu {}</code></pre></p><p>While Mu is the root of the Raku class hierarchy, Any is the class that serves as a default base class for new classes, and as the base class for most built-in classes.</p><p>Since Raku intentionally confuses items and single-element lists, most methods in Any are also present on class List, and coerce to List or a list-like type.</p>"},{"n":"Any::Grepper","t":"Any::Grepper","k":"ro","mro":["Iterator"],"m":[{"n":"new","k":"m","s":{"p":[{"n":"list","t":"Any"},{"t":"Mu","n":"test"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"is-lazy","m":0},{"n":"!SET-SELF","s":{"p":[{"t":"Any","n":"list"},{"t":"Mu","n":"test"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"}],"b":"C","a":[{"t":"Mu","n":"$!iter","k":"v"},{"n":"$!test","t":"Mu","k":"v"}]},{"n":"Any::Repeated-As","a":[{"t":"Mu","k":"v","n":"$!iter"},{"n":"&!as","t":"Callable","k":"v"},{"n":"$!seen","t":"Mu","k":"v"}],"mro":["Iterator","Any"],"b":"A","k":"c","t":"Any::Repeated-As","m":[{"m":0,"n":"new","k":"m","s":{"p":[{"n":"list","t":"Any"},{"t":"Callable","n":"&as"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pull-one","k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"target"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"push-all"},{"m":0,"n":"is-lazy","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"!SET-SELF","k":"m","m":0,"s":{"p":[{"t":"Any","n":"list"},{"t":"Callable","n":"&!as"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}]},{"mro":["Cool"],"n":"StrDistance","b":"C","a":[{"t":"Str","k":"v","n":"$.before"},{"t":"Str","k":"v","n":"$.after"},{"n":"$!distance","t":"Int","k":"v"}],"t":"StrDistance","m":[{"k":"m","d":"<p>Returns True if before is different from after.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Bool"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"*%_"}]},"n":"ACCEPTS","k":"m"},{"k":"m","d":"<p>Returns the distance as a number.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Numeric","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Str"},{"n":"before","d":"<p>This is actually a class attribute, and called as a method returns the string before the transformation:</p><p><pre><code>say $str-dist.before; # OUTPUT: «fold␤»\n</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"n":"after","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p>Also a class attribute, returns the string after the transformation:</p><p><pre><code>say $str-dist.after;  # OUTPUT: «fnew␤»\n</code></pre></p>","m":0},{"n":"BUILDALL","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"d":"<p>StrDistance objects are used to represent the return of the string transformation operator.</p><p><pre><code>say (($ = \"fold\") ~~ tr/old/new/).^name;  # OUTPUT: «StrDistance␤»</code></pre></p><p>A StrDistance object will stringify to the resulting string after the transformation, and will numify to the distance between the two strings.</p><p><pre><code>my $str = \"fold\";\nmy $str-dist = ($str ~~ tr/old/new/);\nsay ~$str-dist;  # OUTPUT: «fnew␤»\nsay +$str-dist;  # OUTPUT: «3␤»\n</code></pre></p>","k":"c"},{"b":"A","k":"c","m":[{"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"clear","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"elems","m":0},{"m":0,"s":{"p":[{"t":"Mu","n":"value"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"push","k":"m"},{"m":0,"s":{"p":[{"t":"IterationBuffer","n":"buffer"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"append"},{"n":"AT-POS","m":1,"k":"m","s":{"p":[{"n":"$pos","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Int","n":"$pos"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"AT-POS"},{"n":"BIND-POS","m":1,"s":{"r":"Mu","p":[{"t":"int","n":"$pos"},{"n":"value","t":"Mu"},{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":1,"s":{"p":[{"t":"Int","n":"$pos"},{"t":"Mu","n":"value"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BIND-POS","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Slip","m":0,"k":"m"},{"m":0,"n":"List","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"n":"Seq"},{"n":"iterator","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"}],"t":"IterationBuffer","mro":["Any"],"n":"IterationBuffer"},{"t":"Signal","n":"SIGQUIT","k":"e"},{"k":"v","n":"&infix:<coll>","d":"<p>Defined as:</p><p><pre><code>multi sub infix:&lt;coll&gt;(Str:D \\a, Str:D \\b --&gt; Order:D)\nmulti sub infix:&lt;coll&gt;(Cool:D \\a, Cool:D \\b --&gt; Order:D)\nmulti sub infix:&lt;coll&gt;(Pair:D \\a, Pair:D \\b --&gt; Order:D)</code></pre></p><p>coll is a sorting operator that takes pairs of Strs, Cools or Pairs and returns an Order that uses the $*COLLATION order. The default behavior disregards diacritic marks and capitalization, for instance.</p><p><pre><code>say \"b\" cmp \"à\";  # OUTPUT: «Less␤»\nsay \"b\" coll \"à\"; # OUTPUT: «More␤»</code></pre></p><p>In the first case, lexicographic or codepoint order is taken into account. In the second, which uses coll, the diacritic is not considered and sorting happens according to intuitive order.</p><p>NOTE: These are not yet implemented in the JVM.</p>","t":"Sub+{Precedence}"},{"s":{"r":"Order:D","p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}]},"n":"infix:<coll>","m":1,"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Cool"},{"n":"b","t":"Cool"}],"r":"Order:D"},"n":"infix:<coll>","k":"s"},{"s":{"p":[{"n":"a","t":"Pair"},{"t":"Pair","n":"b"}],"r":"Order:D"},"m":1,"n":"infix:<coll>","k":"s"},{"n":"Channel","b":"A","a":[{"k":"v","n":"$!queue","t":"Mu"},{"t":"Mu","n":"$!closed_promise","k":"v"},{"k":"v","t":"Mu","n":"$!closed_promise_vow"},{"t":"int","k":"v","n":"$!closed"},{"n":"$!async-notify","k":"v","t":"Mu"}],"k":"c","d":"<p><pre><code>class Channel {}</code></pre></p><p>A Channel is a thread-safe queue that helps you to send a series of objects from one or more producers to one or more consumers. Each object will arrive at only one such consumer, selected by the scheduler. If there is only one consumer and one producer, the order of objects is guaranteed to be preserved. Sending on a Channel is non-blocking.</p><p><pre><code>my $c = Channel.new;\nawait (^10).map: {\n    start {\n        my $r = rand;\n        sleep $r;\n        $c.send($r);\n    }\n}\n$c.close;\nsay $c.list;</code></pre></p><p>Further examples can be found in the concurrency page</p>","t":"Channel","m":[{"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]},"n":"BUILD","k":"s","m":0},{"d":"<p>Defined as:</p><p><pre><code>method send(Channel:D: \\item)</code></pre></p><p>Enqueues an item into the Channel. Throws an exception of type X::Channel::SendOnClosed if the channel has been closed already. This call will not block waiting for a consumer to take the object. There is no set limit on the number of items that may be queued, so care should be taken to prevent runaway queueing.</p><p><pre><code>my $c = Channel.new;\n$c.send(1);\n$c.send([2, 3, 4, 5]);\n$c.close;\nsay $c.list; # OUTPUT: «(1 [2 3 4 5])␤»</code></pre></p>","s":{"p":[{"n":"item","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"send","m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method receive(Channel:D:)</code></pre></p><p>Receives and removes an item from the channel. It blocks if no item is present, waiting for a send from another thread.</p><p>Throws an exception of type X::Channel::ReceiveOnClosed if the channel has been closed, and the last item has been removed already, or if close is called while receive is waiting for an item to arrive.</p><p>If the channel has been marked as erratic with method fail, and the last item has been removed, throws the argument that was given to fail as an exception.</p><p>See method poll for a non-blocking version that won't throw exceptions.</p><p><pre><code>my $c = Channel.new;\n$c.send(1);\nsay $c.receive; # OUTPUT: «1␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"receive","k":"m","m":0},{"d":"<p>Defined as:</p><p><pre><code>method poll(Channel:D:)</code></pre></p><p>Receives and removes an item from the channel. If no item is present, returns Nil instead of waiting.</p><p><pre><code>my $c = Channel.new;\nPromise.in(2).then: { $c.close; }\n^10 .map({ $c.send($_); });\nloop {\n    if $c.poll -&gt; $item { $item.say };\n    if $c.closed  { last };\n    sleep 0.1;\n}</code></pre></p><p>See method receive for a blocking version that properly responds to channel closing and failure.</p>","m":0,"n":"poll","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method Capture(Channel:D --&gt; Capture:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","n":"Capture","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"iterator","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","n":"list","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method list(Channel:D: --&gt; List:D)</code></pre></p><p>Returns a list based on the Seq which will iterate items in the queue and remove each item from it as it iterates. This can only terminate once the close method has been called.</p><p><pre><code>my $c = Channel.new; $c.send(1); $c.send(2);\n$c.close;\nsay $c.list; # OUTPUT: «(1 2)␤»</code></pre></p>"},{"k":"m","n":"get-await-handle","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Awaitable::Handle:D"}},{"n":"close","d":"<p>Defined as:</p><p><pre><code>method close(Channel:D:)</code></pre></p><p>Close the Channel, normally. This makes subsequent send calls die with X::Channel::SendOnClosed. Subsequent calls of .receive may still drain any remaining items that were previously sent, but if the queue is empty, will throw an X::Channel::ReceiveOnClosed exception. Since you can produce a Seq from a Channel by contextualizing to array with @() or by calling the .list method, these methods will not terminate until the channel has been closed. A whenever-block will also terminate properly on a closed channel.</p><p><pre><code>my $c = Channel.new;\n$c.close;\n$c.send(1);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n</code></pre></p><p>Please note that any exception thrown may prevent .close from being called, this may hang the receiving thread. Use a LEAVE phaser to enforce the .close call in this case.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0,"k":"m"},{"m":0,"n":"elems","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method fail(Channel:D: $error)</code></pre></p><p>Closes the Channel (that is, makes subsequent send calls die), and enqueues the error to be thrown as the final element in the channel. Method receive will throw that error as an exception. Does nothing if the channel has already been closed or .fail has already been called on it.</p><p><pre><code>my $c = Channel.new;\n$c.fail(\"Bad error happens!\");\n$c.receive;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::AdHoc: Bad error happens!␤»</code></pre></p>","n":"fail","k":"m","s":{"r":"Mu","p":[{"n":"$error","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","n":"closed","d":"<p>Defined as:</p><p><pre><code>method closed(Channel:D: --&gt; Promise:D)</code></pre></p><p>Returns a promise that will be kept once the channel is closed by a call to method close.</p><p><pre><code>my $c = Channel.new;\n$c.closed.then({ say \"It's closed!\" });\n$c.close;\nsleep 1;</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"!peek"}],"mro":["Awaitable","Any"]},{"n":"Inf","b":"C","t":"Num","k":"c","mro":["Real","Numeric","Cool"]},{"a":[{"t":"str","k":"v","n":"$.name"},{"k":"v","t":"str","n":"$.scope"},{"k":"v","t":"Mu","n":"$.var"},{"n":"$.block","t":"Mu","k":"v"},{"t":"Mu","k":"v","n":"$.slash"},{"n":"$.implicit-lexical-usage","k":"v","t":"Mu"}],"b":"A","d":"<p><pre><code>class Variable {}</code></pre></p><p>Variables have a wealth of compile-time information, but at runtime, accesses to a variable usually act on the value stored inside it, not the variable itself. The runtime class of a variable is Scalar.</p><p>Class Variable holds the compile-time information that traits can use to introspect and manipulate variables.</p>","t":"Variable","k":"c","m":[{"n":"throw","k":"s","m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"&block","t":"Callable"},{"t":"Any","n":"$caller-levels?"},{"t":"Mu","n":"*%_"}]},"n":"willdo","k":"s","m":0},{"k":"s","s":{"p":[{"n":"$what","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"native"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"name"},{"n":"scope","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"var","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"block","m":0,"k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"slash"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"implicit-lexical-usage","k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0,"k":"s"}],"n":"Variable","mro":["Any"]},{"t":"Sub","n":"&printf","k":"v"},{"n":"printf","s":{"p":[{"n":"$format","t":"Cool"},{"n":"j","t":"Junction"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"n":"printf","s":{"r":"Mu","p":[{"t":"Cool","n":"$format"},{"n":"|","t":"Any"}]},"k":"s"},{"t":"Sub","k":"v","n":"&uniprop"},{"k":"s","m":1,"s":{"p":[{"n":"$str","t":"Str"},{"n":"c","t":"Any"}],"r":"Mu"},"n":"uniprop"},{"m":1,"k":"s","s":{"p":[{"n":"$code","t":"Int"}],"r":"Mu"},"n":"uniprop"},{"s":{"r":"Mu","p":[{"t":"Int","n":"$code"},{"t":"Stringy","n":"$propname"}]},"m":1,"k":"s","n":"uniprop"},{"n":"&acosh","k":"v","t":"Sub+{is-pure}"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"x","t":"Numeric"}]},"n":"acosh"},{"s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"},"m":1,"k":"s","n":"acosh"},{"n":"acosh","k":"s","m":1,"s":{"p":[{"t":"num","n":"$x"}],"r":"num"}},{"n":"&classify","t":"Sub","k":"v"},{"k":"s","m":1,"n":"classify","s":{"p":[{"n":"$test","t":"Any"},{"n":"+items","t":"Any"},{"t":"Any","n":":$into!"},{"n":"*%named","t":"Associative"}],"r":"Mu"}},{"k":"s","m":1,"n":"classify","s":{"p":[{"n":"$test","t":"Any"},{"t":"Any","n":"+items"},{"t":"Associative","n":"*%named"}],"r":"Mu"}},{"n":"&infix:<after>","d":"<p><pre><code>multi sub infix:&lt;after&gt;(Any,       Any)\nmulti sub infix:&lt;after&gt;(Real:D,    Real:D)\nmulti sub infix:&lt;after&gt;(Str:D,     Str:D)\nmulti sub infix:&lt;after&gt;(Version:D, Version:D)</code></pre></p><p>Generic ordering, uses the same semantics as cmp. Returns True if the first argument is larger than the second.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Bool","p":[{"t":"Any","n":"$x?"}]},"n":"infix:<after>"},{"m":1,"n":"infix:<after>","k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Bool:D"}},{"t":"Sub","n":"&uc","k":"v"},{"m":1,"n":"uc","k":"s","s":{"r":"Mu","p":[{"n":"$s","t":"Cool"}]}},{"n":"&infix:<...>","k":"v","t":"Sub+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;...&gt;(**@) is assoc&lt;list&gt;\nmulti sub infix:&lt;...^&gt;(**@) is assoc&lt;list&gt;</code></pre></p><p>The sequence operator, which can be written either as ... or as … (with variants ...^ and …^) will produce (possibly lazy) generic sequences on demand.</p><p>The left-hand side will always include the initial elements; it may include a generator too (after the first element or elements). The right-hand side will have an endpoint, which can be Inf or * for \"infinite\" lists (that is, lazy lists whose elements are only produced on demand), an expression which will end the sequence when True, or other elements such as Junctions.</p><p>The sequence operator invokes the generator with as many arguments as necessary. The arguments are taken from the initial elements and the already generated elements. The default generator is *.succ or *.pred, depending on how the end points compare:</p><p><pre><code>say 1 ... 4;        # OUTPUT: «(1 2 3 4)␤»\nsay 4 ... 1;        # OUTPUT: «(4 3 2 1)␤»\nsay 'a' ... 'e';    # OUTPUT: «(a b c d e)␤»\nsay 'e' ... 'a';    # OUTPUT: «(e d c b a)␤»</code></pre></p><p>An endpoint of * (Whatever), Inf or ∞ generates on demand an infinite sequence, with a default generator of *.succ</p><p><pre><code>say (1 ... *)[^5];  # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p><p>Custom generators need to be the last element of the list before the '...' operator. This one takes two arguments, and generates the eight first Fibonacci numbers</p><p><pre><code>say (1, 1, -&gt; $a, $b { $a + $b } ... *)[^8]; # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\n# same but shorter\nsay (1, 1, * + * ... *)[^8];                 # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\n</code></pre></p><p>Of course the generator can also take only one argument.</p><p><pre><code>say 5, { $_ * 2 } ... 40;                # OUTPUT: «5 10 20 40␤»</code></pre></p><p>There must be at least as many initial elements as arguments to the generator.</p><p>Without a generator and with more than one initial element and all initial elements numeric, the sequence operator tries to deduce the generator. It knows about arithmetic and geometric sequences.</p><p><pre><code>say 2, 4, 6 ... 12;     # OUTPUT: «(2 4 6 8 10 12)␤»\nsay 1, 2, 4 ... 32;     # OUTPUT: «(1 2 4 8 16 32)␤»</code></pre></p><p>If the endpoint is not *, it's smartmatched against each generated element and the sequence is terminated when the smartmatch succeeded. For the ... operator, the final element is included, for the ...^ operator it's excluded.</p><p>This allows you to write</p><p><pre><code>say 1, 1, * + * ...^ *&gt;= 100;</code></pre></p><p>to generate all Fibonacci numbers up to but excluding 100.</p><p>The ... operators consider the initial values as \"generated elements\" as well, so they are also checked against the endpoint:</p><p><pre><code>my $end = 4;\nsay 1, 2, 4, 8, 16 ... $end;\n# OUTPUT: «(1 2 4)␤»</code></pre></p>"},{"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<...>","m":1,"k":"s"},{"m":1,"n":"infix:<...>","k":"s","s":{"r":"Mu","p":[{"n":"lol","t":"Any"}]}},{"b":"C","m":[{"s":{"r":"Mu","p":[{"t":"Positional","n":"*@"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"new","k":"m"},{"s":{"p":[{"n":"$posix","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Instant:D"},"k":"m","m":1,"n":"from-posix","d":"<p><pre><code>method from-posix($posix, Bool $prefer-leap-second = False)</code></pre></p><p>Converts the POSIX timestamp $posix to an Instant. If $prefer-leap-second is True, the return value will be the first of the two possible seconds in the case of a leap second.</p><p><pre><code>say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\nsay DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»</code></pre></p>"},{"m":1,"n":"from-posix","d":"<p><pre><code>method from-posix($posix, Bool $prefer-leap-second = False)</code></pre></p><p>Converts the POSIX timestamp $posix to an Instant. If $prefer-leap-second is True, the return value will be the first of the two possible seconds in the case of a leap second.</p><p><pre><code>say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\nsay DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»</code></pre></p>","s":{"p":[{"n":"$posix","t":"Any"},{"n":"$prefer-leap-second","t":"Bool"},{"t":"Mu","n":"*%_"}],"r":"Instant:D"},"k":"m"},{"d":"<p><pre><code>method to-posix()</code></pre></p><p>Converts the invocant to a POSIX timestamp and returns a two element list containing the POSIX timestamp and a Bool. It is the inverse of #method from-posix, except that the second return value is True if *and only if* this Instant is in a leap second.</p><p><pre><code>say DateTime.new(\"1999-01-01T00:00:00Z\").Instant.to-posix; # OUTPUT: «(915148800 False)␤»\nsay DateTime.new('1998-12-31T23:59:60Z').Instant.to-posix; # OUTPUT: «(915148800 True)␤»</code></pre></p>","n":"to-posix","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"List:D"}},{"n":"Bridge","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Num:D"},"m":0,"k":"m","n":"Num"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Rat:D"},"m":0,"n":"Rat","k":"m"},{"n":"Int","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"}},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"narrow"},{"n":"Date","d":"<p>Defined as:</p><p><pre><code>method Date(Instant:D: --&gt; Date:D)</code></pre></p><p>Coerces the invocant to Date.</p><p><pre><code>my $i = \"/etc/passwd\".IO.modified;\nsay $i;             # OUTPUT: «Instant:1451489025.878018␤»\nsay $i.Date;        # OUTPUT: «2015-12-30␤»</code></pre></p>","k":"m","s":{"r":"Date:D","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"n":"DateTime","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"DateTime:D"}},{"k":"m","n":"Instant","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"tai","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL","k":"s","m":0}],"mro":["Real","Numeric","Cool"],"t":"Instant","k":"c","a":[{"t":"Rat","n":"$.tai","k":"v"}],"n":"Instant","d":"<p><pre><code>class Instant is Cool does Real { }</code></pre></p><p>An Instant is a particular moment in time measured in atomic seconds, with fractions. It is not tied to or aware of any epoch.</p><p>An Instant can be used to create a DateTime object set to that Instant. The pseudo-constant now returns the current time as an Instant.</p><p>Basic math is defined for Instants (as well as Durations). Adding an Instant to a Duration returns another Instant. Subtracting two Instants will yield a Duration. Adding two Instants is explicitly disallowed. All other operations with Instants are undefined.</p>"},{"t":"Sub+{is-pure}","n":"&expmod","k":"v"},{"n":"expmod","s":{"r":"Int:D","p":[{"t":"Int","n":"base"},{"t":"Int","n":"exp"},{"n":"mod","t":"Int"}]},"m":1,"k":"s"},{"n":"expmod","k":"s","m":1,"s":{"r":"Int:D","p":[{"n":"base","t":"Any"},{"t":"Any","n":"exp"},{"t":"Any","n":"mod"}]}},{"k":"c","m":[{"n":"new","s":{"r":"Mu","p":[{"t":"Any","n":"$type"},{"t":"Mu","n":"*%_"}]},"m":1,"k":"m"},{"s":{"r":"Int:D","p":[{"n":"value","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":1,"n":"new","k":"m"},{"m":1,"s":{"r":"Int:D","p":[{"n":"value","t":"int"},{"n":"*%_","t":"Mu"}]},"n":"new","k":"m"},{"m":1,"s":{"p":[{"n":"value?","t":"Int"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"new","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","n":"Capture"},{"n":"Int","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Int:D","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"sign"},{"m":0,"n":"Num","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Num:D"},"k":"m"},{"n":"Rat","k":"m","m":0,"s":{"p":[{"t":"Any","n":"$?"},{"t":"Mu","n":"*%_"}],"r":"Rat:D"}},{"n":"FatRat","k":"m","m":0,"s":{"r":"FatRat:D","p":[{"n":"$?","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"k":"m","n":"abs"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Num:D"},"n":"Bridge","m":0},{"d":"<p>Defined as:</p><p><pre><code>multi sub    chr(Int:D  --&gt; Str:D)\nmulti method chr(Int:D: --&gt; Str:D)</code></pre></p><p>Returns a one-character string, by interpreting the integer as a Unicode codepoint number and converting it to the corresponding character.</p><p>Example:</p><p><pre><code>65.chr;  # returns \"A\"\n196.chr; # returns \"Ä\"</code></pre></p>","n":"chr","k":"m","s":{"r":"Str:D","p":[{"t":"Mu","n":"*%_"}]},"m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Num:D"},"n":"sqrt","m":0},{"n":"base","k":"m","s":{"p":[{"n":"$base","t":"Int"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":1},{"m":1,"k":"m","s":{"p":[{"n":"$base","t":"Cool"},{"t":"Any","n":"$digits?"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"base"},{"k":"m","n":"base","s":{"p":[{"t":"Str","n":"$"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":1},{"s":{"r":"Str:D","p":[{"n":"$","t":"Str"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"base","m":1},{"m":0,"s":{"p":[{"n":"+@mods","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"n":"polymod","d":"<p>Defined as:</p><p><pre><code>method polymod(Int:D: +@mods)</code></pre></p><p>Returns a sequence of mod results corresponding to the divisors in @mods in the same order as they appear there. For the best effect, the divisors should be given from the smallest \"unit\" to the largest (e.g. 60 seconds per minute, 60 minutes per hour) and the results are returned in the same way: from smallest to the largest (5 seconds, 4 minutes). The last non-zero value will be the last remainder.</p><p><pre><code>say 120.polymod(10);    # OUTPUT: «(0 12)␤»\nsay 120.polymod(10,10); # OUTPUT: «(0 2 1)␤»</code></pre></p><p>In the first case, 120 is divided by 10 giving as a remainder 12, which is the last element. In the second, 120 is divided by 10, giving 12, whose remainder once divided by 10 is 2; the result of the integer division of 12 div 10 is the last remainder. The number of remainders will be always one more item than the number of given divisors. If the divisors are given as a lazy list, runs until the remainder is 0 or the list of divisors is exhausted. All divisors must be Ints, unless the method is called on a non-Int number.</p><p><pre><code>my $seconds = 1 * 60*60*24 # days\n            + 3 * 60*60    # hours\n            + 4 * 60       # minutes\n            + 5;           # seconds\n\nsay $seconds.polymod(60, 60);                # OUTPUT: «(5 4 27)␤»\nsay $seconds.polymod(60, 60, 24);            # OUTPUT: «(5 4 3 1)␤»\n\nsay 120.polymod:      1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12 0 0 0)␤»\nsay 120.polymod: lazy 1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12)␤»\nsay 120.polymod:      1, 10, 10² … ∞;        # OUTPUT: «(0 0 12)␤»\n\nsay ⅔.polymod(⅓);                            # OUTPUT: «(0 2)␤»\nsay 5.Rat.polymod(.3, .2);                   # OUTPUT: «(0.2 0 80)␤»\n\nmy @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion\nsay @digits-in-base37.reverse                    # OUTPUT: «[4 32 4 15 36]␤»</code></pre></p><p>To illustrate how the Int, non-lazy version of polymod works, consider this code that implements it:</p><p><pre><code>my $seconds = 2 * 60*60*24 # days\n            + 3 * 60*60    # hours\n            + 4 * 60       # minutes\n            + 5;           # seconds\n\nmy @pieces;\nfor 60, 60, 24 -&gt; $divisor {\n    @pieces.push: $seconds mod $divisor;\n    $seconds div= $divisor\n}\n@pieces.push: $seconds;\n\nsay @pieces; # OUTPUT: «[5 4 3 2]␤»</code></pre></p><p>For a more detailed discussion, see this blog post</p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>multi sub    expmod(      $x,     $y,     $mod --&gt; Int:D)\nmulti sub    expmod(Int:D $x, Int $y, Int $mod --&gt; Int:D)\nmulti method expmod(Int:D:    Int $y, Int $mod --&gt; Int:D)</code></pre></p><p>Returns the given Int raised to the $y power within modulus $mod, that is gives the result of ($x ** $y) mod $mod. The subroutine form can accept non-Int arguments, which will be coerced to Int.</p><p><pre><code>say expmod(4, 2, 5);    # OUTPUT: «1␤»\nsay 7.expmod(2, 5);     # OUTPUT: «4␤»</code></pre></p><p>$y argument can also be negative, in which case, the result is equivalent to ($x ** $y) mod $mod.</p><p><pre><code>say 7.expmod(-2, 5);     # OUTPUT: «4␤»</code></pre></p>","s":{"r":"Int:D","p":[{"n":"base","t":"Int"},{"n":"mod","t":"Int"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"expmod","k":"m"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub    is-prime (Int:D $number --&gt; Bool:D)\nmulti method is-prime (Int:D: --&gt; Bool:D)</code></pre></p><p>Returns True if this Int is known to be a prime, or is likely to be a prime based on a probabilistic Miller-Rabin test.</p><p>Returns False if this Int is known not to be a prime.</p><p><pre><code>say 2.is-prime;         # OUTPUT: «True␤»\nsay is-prime(9);        # OUTPUT: «False␤»</code></pre></p>","n":"is-prime"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"floor"},{"m":0,"n":"ceiling","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1,"k":"m","n":"round"},{"s":{"r":"Real:D","p":[{"n":"$scale","t":"Cool"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"round","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"round","m":1},{"n":"round","m":1,"k":"m","s":{"r":"Mu","p":[{"n":"$scale","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>multi method lsb(Int:D:)\nmulti sub    lsb(Int:D)</code></pre></p><p>Short for \"Least Significant Bit\". Returns Nil if the number is 0. Otherwise returns the zero-based index from the right of the least significant (rightmost) 1 in the binary representation of the number.</p><p><pre><code>say 0b01011.lsb;        # OUTPUT: «0␤»\nsay 0b01010.lsb;        # OUTPUT: «1␤»\nsay 0b10100.lsb;        # OUTPUT: «2␤»\nsay 0b01000.lsb;        # OUTPUT: «3␤»\nsay 0b10000.lsb;        # OUTPUT: «4␤»</code></pre></p>","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"n":"lsb","m":0,"k":"m"},{"n":"msb","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"d":"<p>Defined as:</p><p><pre><code>multi method msb(Int:D:)\nmulti sub    msb(Int:D)</code></pre></p><p>Short for \"Most Significant Bit\". Returns Nil if the number is 0. Otherwise returns the zero-based index from the right of the most significant (leftmost) 1 in the binary representation of the number.</p><p><pre><code>say 0b00001.msb;        # OUTPUT: «0␤»\nsay 0b00011.msb;        # OUTPUT: «1␤»\nsay 0b00101.msb;        # OUTPUT: «2␤»\nsay 0b01010.msb;        # OUTPUT: «3␤»\nsay 0b10011.msb;        # OUTPUT: «4␤»</code></pre></p>","m":0,"k":"m"},{"n":"narrow","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"Range","d":"<p>Returns a Range object that represents the range of values supported.</p>","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Range:D"},"m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"unival","k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub    unival(Int:D  --&gt; Numeric)\nmulti method unival(Int:D: --&gt; Numeric)</code></pre></p><p>Returns the number represented by the Unicode codepoint with the given integer number, or NaN if it does not represent a number.</p><p><pre><code>say ord(\"¾\").unival;    # OUTPUT: «0.75␤»\nsay 190.unival;         # OUTPUT: «0.75␤»\nsay unival(65);         # OUTPUT: «NaN␤»</code></pre></p>","m":0},{"s":{"r":"Str:D","p":[{"n":"$egg","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!eggify","m":0,"k":"m"}],"mro":["Real","Numeric","Cool"],"d":"<p><pre><code>class Int is Cool does Real { }\n</code></pre></p><p>Int objects store integral numbers of arbitrary size. Ints are immutable.</p><p>There are two main syntax forms for Int literals</p><p><pre><code>123;         # Int in decimal notation\n:16&lt;BEEF&gt;;   # Int in radix notations</code></pre></p><p>For your convenience common radix forms come with a prefix shortcut.</p><p><pre><code>say so :2&lt;11111111&gt; == 0b11111111 == :8&lt;377&gt; == 0o377 == 255 == 0d255 == :16&lt;ff&gt; == 0xff;\n# OUTPUT: «True␤»</code></pre></p><p>All forms allow underscores between any two digits which can serve as visual separators, but don't carry any meaning:</p><p><pre><code>5_00000;       # five Lakhs\n500_000;       # five hundred thousand\n0xBEEF_CAFE;   # a strange place\n:2&lt;1010_1010&gt;; # 0d170</code></pre></p><p>Radix notation also supports round and angle brackets which allow you to parse a string for a given base, and putting together digits into a whole number respectively:</p><p><pre><code>:16(\"9F\");         # 159\n:100[99, 2, 3];    # 990203</code></pre></p><p>These notations allow you to use variables, too:</p><p><pre><code>my $two = \"2\";\nmy $ninety-nine = \"99\";\n:16($ninety-nine); # 153\n:100[99, $two, 3]; # 990203</code></pre></p>","b":"C","n":"Int","t":"Int"},{"t":"Sub","n":"&samemark","k":"v"},{"m":1,"n":"samemark","s":{"p":[{"t":"Any","n":"$s"},{"t":"Any","n":"$pat"}],"r":"Str:D"},"k":"s"},{"n":"True","t":"Bool","k":"e"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<∪>"},{"k":"s","s":{"p":[],"r":"Mu"},"n":"infix:<∪>","m":1},{"m":1,"n":"infix:<∪>","k":"s","s":{"p":[{"t":"QuantHash","n":"a"}],"r":"Mu"}},{"m":1,"k":"s","n":"infix:<∪>","s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Setty"}]}},{"s":{"p":[{"n":"a","t":"Setty"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<∪>","k":"s","m":1},{"m":1,"n":"infix:<∪>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}]}},{"n":"infix:<∪>","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}]}},{"k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}],"r":"Mu"},"n":"infix:<∪>","m":1},{"m":1,"s":{"p":[{"t":"Mixy","n":"a"},{"t":"Setty","n":"b"}],"r":"Mu"},"n":"infix:<∪>","k":"s"},{"k":"s","m":1,"n":"infix:<∪>","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Mixy","n":"b"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}],"r":"Mu"},"n":"infix:<∪>","k":"s","m":1},{"m":1,"n":"infix:<∪>","k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Setty","n":"b"}],"r":"Mu"}},{"m":1,"k":"s","n":"infix:<∪>","s":{"p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Iterable"},{"n":"b","t":"Iterable"}],"r":"Mu"},"n":"infix:<∪>","m":1,"k":"s"},{"s":{"p":[{"n":"a","t":"Failure"},{"t":"Any","n":"$"}],"r":"Mu"},"n":"infix:<∪>","m":1,"k":"s"},{"n":"infix:<∪>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}]}},{"m":1,"n":"infix:<∪>","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"+@p","t":"Positional"}]},"k":"s","m":1,"n":"infix:<∪>"},{"n":"&spurt","k":"v","t":"Sub"},{"k":"s","s":{"r":"Mu","p":[{"n":"$fh","t":"IO::Handle"},{"n":"$data","t":"Any"},{"n":"*%_","t":"Associative"}]},"n":"spurt","m":1},{"n":"spurt","m":1,"k":"s","s":{"p":[{"n":"$path","t":"Any"},{"n":"data","t":"Blob"},{"n":":$append!","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"n":"$path","t":"Any"},{"t":"Blob","n":"data"},{"t":"Any","n":":$createonly!"}],"r":"Mu"},"k":"s","m":1,"n":"spurt"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$path"},{"t":"Blob","n":"data"}]},"n":"spurt","k":"s","m":1},{"n":"spurt","s":{"p":[{"t":"Any","n":"$path"},{"n":"text","t":"Any"},{"n":":$append!","t":"Any"},{"t":"Any","n":":$enc"}],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"$path"},{"n":"text","t":"Any"},{"t":"Any","n":":$createonly!"},{"t":"Any","n":":$enc"}],"r":"Mu"},"n":"spurt"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"$path"},{"t":"Any","n":"text"},{"t":"Any","n":":$enc!"}],"r":"Mu"},"n":"spurt"},{"m":1,"s":{"p":[{"t":"Any","n":"$path"},{"t":"Any","n":"text"}],"r":"Mu"},"n":"spurt","k":"s"},{"t":"Sub+{is-pure}","n":"&cotan","k":"v"},{"n":"cotan","m":1,"k":"s","s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"}},{"n":"cotan","k":"s","m":1,"s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"}},{"n":"cotan","s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"m":1,"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;(|)&gt;(**@p)\nmulti sub infix:&lt;∪&gt;(**@p)</code></pre></p><p>Union operator.</p><p>Returns the union of all of its arguments. This creates a new Set that contains all the elements its arguments contain if none of the arguments are a Bag, BagHash, Mix or MixHash.</p><p><pre><code>say &lt;a b d&gt; ∪ bag(&lt;a a b c&gt;); # OUTPUT: «Bag(a(2), b, c, d)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy&gt;, the result is a new Bag (or Mix) containing all the elements, each weighted by the highest weight that appeared for that element.</p><p><pre><code>say &lt;a b d&gt; ∪ bag(&lt;a a b c&gt;); # OUTPUT: «Bag(a(2), b, c, d)␤»\n</code></pre></p><p>∪ is equivalent to (|), at codepoint U+222A (UNION).</p>","k":"v","n":"&infix:<(|)>"},{"n":"infix:<(|)>","s":{"p":[],"r":"Mu"},"k":"s","m":1},{"k":"s","s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"},"n":"infix:<(|)>","m":1},{"s":{"r":"Mu","p":[{"t":"Setty","n":"a"},{"n":"b","t":"Setty"}]},"k":"s","n":"infix:<(|)>","m":1},{"m":1,"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Mixy"}],"r":"Mu"},"k":"s","n":"infix:<(|)>"},{"s":{"p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}],"r":"Mu"},"k":"s","n":"infix:<(|)>","m":1},{"n":"infix:<(|)>","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":[{"t":"Mixy","n":"a"},{"t":"Baggy","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<(|)>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Setty"}],"r":"Mu"},"n":"infix:<(|)>","k":"s"},{"s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Mixy"}],"r":"Mu"},"k":"s","n":"infix:<(|)>","m":1},{"n":"infix:<(|)>","s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Baggy"}],"r":"Mu"},"k":"s","m":1},{"m":1,"n":"infix:<(|)>","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Setty"}],"r":"Mu"},"k":"s"},{"n":"infix:<(|)>","s":{"r":"Mu","p":[{"t":"Map","n":"a"},{"n":"b","t":"Map"}]},"m":1,"k":"s"},{"s":{"r":"Mu","p":[{"t":"Iterable","n":"a"},{"n":"b","t":"Iterable"}]},"n":"infix:<(|)>","k":"s","m":1},{"m":1,"k":"s","n":"infix:<(|)>","s":{"p":[{"t":"Failure","n":"a"},{"n":"$","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}],"r":"Mu"},"m":1,"n":"infix:<(|)>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"k":"s","m":1,"n":"infix:<(|)>"},{"m":1,"n":"infix:<(|)>","s":{"r":"Mu","p":[{"t":"Positional","n":"+@p"}]},"k":"s"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∌>","d":"<p><pre><code>multi sub infix:&lt;∌&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Non-membership operator.</p><p>Returns True if $a is not an element of $b. Equivalent to !(cont).</p><p><pre><code>say (1,2,3) ∌ 4; # OUTPUT: «True␤»\nsay (1,2,3) !(cont) 2; # OUTPUT: «False␤»\n</code></pre></p><p>∉ is codepoint U+220C (DOES NOT CONTAIN AS MEMBER).</p>"},{"m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Bool:D"},"k":"s","n":"infix:<∌>"},{"t":"Sub+{Callable[Complex:D]}+{is-pure}+{Precedence}","n":"&postfix:<i>","k":"v"},{"k":"s","s":{"p":[{"n":"a","t":"Real"}],"r":"Complex:D"},"m":1,"n":"postfix:<i>"},{"k":"s","m":1,"n":"postfix:<i>","s":{"r":"Complex:D","p":[{"t":"Complex","n":"a"}]}},{"s":{"r":"Complex:D","p":[{"n":"a","t":"Numeric"}]},"n":"postfix:<i>","m":1,"k":"s"},{"m":1,"s":{"r":"Complex:D","p":[{"n":"a","t":"Cool"}]},"n":"postfix:<i>","k":"s"},{"a":[{"n":"$.type","k":"v","t":"Mu"},{"t":"Associative","k":"v","n":"%.config"}],"b":"A","n":"Pod::Config","t":"Pod::Config","k":"c","m":[{"n":"type","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"config"},{"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Any"]},{"b":"A","mro":["Pod::Block"],"d":"<p><pre><code>class Pod::Defn is Pod::Block { }</code></pre></p><p>Class for definition lists in a Pod document.</p>","k":"c","n":"Pod::Defn","m":[{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"term","k":"m"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s","n":"BUILDALL"}],"t":"Pod::Defn","a":[{"n":"$.term","k":"v","t":"Mu"},{"t":"Associative","n":"%.config","k":"v"},{"n":"@.contents","t":"Positional","k":"v"}]},{"k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"level"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Pod::Block"],"b":"A","a":[{"t":"Mu","k":"v","n":"$.level"},{"k":"v","n":"%.config","t":"Associative"},{"k":"v","t":"Positional","n":"@.contents"}],"t":"Pod::Item","n":"Pod::Item","d":"<p><pre><code>class Pod::Item is Pod::Block { }</code></pre></p><p>Class for items in Pod enumeration lists.</p>"},{"mro":["Any"],"b":"A","a":[{"t":"Mu","k":"v","n":"$.target"},{"t":"Positional","k":"v","n":"@.contents"}],"t":"Pod::Raw","n":"Pod::Raw","k":"c","m":[{"m":0,"k":"m","n":"target","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"contents","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}]},{"d":"<p><pre><code>class Pod::Block { }</code></pre></p><p>Class for a Pod block, and base class for most other Pod classes.</p><p>A Pod block has contents (more pod blocks or strings) and a config hash.</p><p>Useful subclasses:</p><table class='sections'><tr><th>Class</th><th>Used for</th></tr>\n<tr><td>Pod::Block::Para</tr><td>paragraphs</tr></tr>\n<tr><td>Pod::Block::Named</tr><td>named blocks</tr></tr>\n<tr><td>Pod::Block::Declarator</tr><td>declarator blocks</tr></tr>\n<tr><td>Pod::Block::Code</tr><td>code blocks</tr></tr>\n<tr><td>Pod::Block::Comment</tr><td>comments</tr></tr>\n<tr><td>Pod::Block::Table</tr><td>=begin/end table</tr></tr>\n<tr><td></tr><td>tabular data</tr></tr>\n<tr><td>Pod::Heading</tr><td>=head1 etc. headings</tr></tr>\n<tr><td>Pod::Item</tr><td>list items</tr></tr>\n<tr><td>Pod::Defn</tr><td>definition lists</tr></tr>\n<tr><td>Pod::FormattingCode</tr><td>formatting codes</tr></tr>\n</table>","k":"c","mro":["Any"],"m":[{"n":"BUILD","k":"s","m":0,"s":{"r":"Nil","p":[{"n":":%!config","t":"Associative"},{"n":":@!contents","t":"Positional"},{"n":"*%_","t":"Mu"}]}},{"n":"config","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"d":"<p><pre><code>method contents(--&gt; Positional:D)</code></pre></p><p>Returns a list of contents of this block.</p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"contents"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]}}],"n":"Pod::Block","a":[{"n":"%.config","k":"v","t":"Associative"},{"t":"Positional","n":"@.contents","k":"v"}],"t":"Pod::Block","b":"A"},{"k":"c","d":"<p><pre><code>class Pod::Block::Para is Pod::Block { }</code></pre></p><p>Class for a Pod paragraph.</p>","n":"Pod::Block::Para","mro":["Pod::Block"],"t":"Pod::Block::Para","a":[{"n":"%.config","k":"v","t":"Associative"},{"n":"@.contents","t":"Positional","k":"v"}],"b":"A","m":[{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"k":"s","n":"BUILDALL","m":0}]},{"mro":["Pod::Block"],"t":"Pod::Block::Code","k":"c","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s"}],"a":[{"n":"%.config","t":"Associative","k":"v"},{"t":"Positional","k":"v","n":"@.contents"}],"d":"<p><pre><code>class Pod::Block::Code is Pod::Block { }</code></pre></p><p>Class for a code (verbatim) Pod block.</p>","b":"A","n":"Pod::Block::Code"},{"m":[{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"name"},{"m":0,"n":"BUILDALL","s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"b":"A","n":"Pod::Block::Named","mro":["Pod::Block"],"d":"<p><pre><code>class Pod::Block::Named is Pod::Block { }</code></pre></p><p>Class for a named Pod block. For example</p><p><pre><code>=begin MySection\n...\n=end MySection\n</code></pre></p><p>creates a Pod::Block::Named with name MySection.</p>","k":"c","a":[{"k":"v","n":"$.name","t":"Mu"},{"t":"Associative","n":"%.config","k":"v"},{"n":"@.contents","t":"Positional","k":"v"}],"t":"Pod::Block::Named"},{"t":"Pod::Block::Declarator","m":[{"n":"BUILD","s":{"p":[{"n":":@!leading","t":"Positional"},{"n":":@!trailing","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"m":0,"k":"s"},{"s":{"r":"Mu","p":[{"n":"$d","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"set_docee","m":0,"k":"m"},{"n":"Str","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"contents"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method leading(--&gt; Str)</code></pre></p><p>Returns the leading Pod comment attached to the declarator</p>","m":0,"n":"leading","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"trailing","d":"<p><pre><code>method trailing(--&gt; Str)</code></pre></p><p>Returns the trailing Pod comment attached to the declarator</p>","m":0},{"n":"_add_leading","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$addition"},{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"p":[{"t":"Any","n":"$addition"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"_add_trailing"},{"k":"m","m":0,"n":"WHEREFORE","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"BUILDALL","m":0,"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}]},"k":"s"}],"n":"Pod::Block::Declarator","k":"c","d":"<p><pre><code>class Pod::Block::Declarator is Pod::Block { }</code></pre></p><p>Class for a declarator Pod block</p>","mro":["Pod::Block"],"a":[{"n":"$.WHEREFORE","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@!leading"},{"t":"Positional","n":"@!trailing","k":"v"},{"t":"Associative","k":"v","n":"%.config"},{"n":"@.contents","t":"Positional","k":"v"}],"b":"A"},{"mro":["Pod::Block"],"a":[{"k":"v","t":"Associative","n":"%.config"},{"n":"@.contents","k":"v","t":"Positional"}],"d":"<p><pre><code>class Pod::Block::Comment is Pod::Block { }</code></pre></p><p>Class for a Pod comment.</p>","b":"A","t":"Pod::Block::Comment","m":[{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"n":"Pod::Block::Comment","k":"c"},{"k":"c","m":[{"d":"<p><pre><code>method caption(--&gt; Str:D)</code></pre></p><p>Returns the associated caption of the table.</p>","m":0,"n":"caption","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"n":"headers","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"d":"<p><pre><code>class Pod::Block::Table is Pod::Block { }</code></pre></p><p>Class for a table in a Pod document.</p>","mro":["Pod::Block"],"t":"Pod::Block::Table","b":"A","a":[{"t":"Mu","n":"$.caption","k":"v"},{"k":"v","n":"@.headers","t":"Positional"},{"k":"v","t":"Associative","n":"%.config"},{"k":"v","t":"Positional","n":"@.contents"}],"n":"Pod::Block::Table"},{"a":[{"k":"v","t":"Mu","n":"$.level"},{"n":"%.config","t":"Associative","k":"v"},{"t":"Positional","n":"@.contents","k":"v"}],"n":"Pod::Heading","m":[{"k":"m","n":"level","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","m":0}],"k":"c","mro":["Pod::Block"],"d":"<p><pre><code>class Pod::Heading is Pod::Block { }</code></pre></p><p>Class for headings in a Pod document.</p>","b":"A","t":"Pod::Heading"},{"k":"c","n":"Pod::FormattingCode","d":"<p><pre><code>class Pod::FormattingCode is Pod::Block { }</code></pre></p><p>Class for formatting codes in a Pod document.</p>","mro":["Pod::Block"],"b":"A","m":[{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"type","k":"m","d":"<p><pre><code>method type(--&gt; Mu)</code></pre></p>"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"meta"},{"m":0,"k":"s","s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"}],"a":[{"n":"$.type","k":"v","t":"Mu"},{"t":"Positional","k":"v","n":"@.meta"},{"n":"%.config","t":"Associative","k":"v"},{"n":"@.contents","k":"v","t":"Positional"}],"t":"Pod::FormattingCode"},{"k":"n","t":"uint32","n":"uint32"},{"m":[{"k":"m","m":0,"s":{"p":[{"n":"&emit","t":"Callable"},{"t":"Callable","n":"&done"},{"n":"&quit","t":"Callable"},{"t":"Callable","n":"&tap"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"tap"},{"n":"live","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"serial"},{"m":0,"n":"sane","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"}],"k":"ro","n":"Tappable","mro":[],"t":"Tappable","b":"C"},{"t":"Sub","n":"&prefix:<let>","k":"v","d":"<p><pre><code>sub prefix:&lt;let&gt;(Mu $a is rw)</code></pre></p><p>Refers to a variable in an outer scope whose value will be restored if the block exits unsuccessfully, implying that the block returned a defined object.</p><p><pre><code>my $name = \"Jane Doe\";\n\n{\n    let $name = prompt(\"Say your name \");\n    die if !$name;\n    CATCH {\n        default { say \"No name entered\" }\n    }\n    say \"We have $name\";\n}\n\nsay \"We got $name\";\n</code></pre></p><p>This code provides a default name for $name. If the user exits from the prompt or simply does not provide a valid input for $name; let will restore the default value provided at the top. If user input is valid, it will keep that.</p>"},{"n":"prefix:<let>","s":{"p":[{"n":"cont","t":"Mu"}],"r":"Mu"},"k":"s","m":0},{"t":"Int","k":"ss","n":"UInt"},{"n":"&infix:<minmax>","d":"<p>Returns the Range starting from the lowest to the highest of the values, as determined by the cmp semantics. For instance:</p><p><pre><code># numeric comparison\n10 minmax 3;     # 3..10\n\n# string comparison\n'10' minmax '3'; # \"10\"..\"3\"\n'z' minmax 'k';  # \"k\"..\"z\"\n</code></pre></p><p>If the lowest and highest values coincide, the operator returns a Range made by the same value:</p><p><pre><code>1 minmax 1;  # 1..1\n</code></pre></p><p>When applied to Lists, the operator evaluates the lowest and highest values among all available values:</p><p><pre><code>(10,20,30) minmax (0,11,22,33);       # 0..33\n('a','b','z') minmax ('c','d','w');   # \"a\"..\"z\"\n</code></pre></p><p>Similarly, when applied to Hashes, it performs a cmp way comparison:</p><p><pre><code>my %winner = points =&gt; 30, misses =&gt; 10;\nmy %loser = points =&gt; 20, misses =&gt; 10;\n%winner cmp %loser;      # More\n%winner minmax %loser;\n# ${:misses(10), :points(20)}..${:misses(10), :points(30)}\n</code></pre></p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Mu","p":[{"t":"Any","n":"+args"}]},"n":"infix:<minmax>","m":1,"k":"s"},{"t":"Signal","k":"e","n":"SIGUSR2"},{"n":"&postfix:<ⁿ>","k":"v","t":"Sub+{is-pure}"},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"},"k":"s","m":1,"n":"postfix:<ⁿ>"},{"k":"v","d":"<p><pre><code>multi sub infix:&lt;∉&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Non-membership operator.</p><p>Returns True if $a is not an element of $b. Equivalent to !(elem).</p><p><pre><code>say 4 ∉ (1, 2, 3); # OUTPUT: «True␤»\nsay 2 !(elem) (1, 2, 3); # OUTPUT: «False␤»\n</code></pre></p><p>∉ is codepoint U+2209 (NOT AN ELEMENT OF).</p>","n":"&infix:<∉>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]},"n":"infix:<∉>","k":"s","m":1},{"n":"SIGTSTP","t":"Signal","k":"e"},{"k":"v","t":"Sub+{is-pure}","n":"&defined"},{"m":1,"s":{"p":[{"n":"x","t":"Mu"}],"r":"Mu"},"n":"defined","k":"s"},{"k":"v","n":"&indir","t":"Sub"},{"n":"indir","m":1,"s":{"p":[{"t":"Any","n":"$path"},{"n":"&what","t":"Callable"},{"n":":$test!","t":"Any"}],"r":"Mu"},"k":"s"},{"k":"s","n":"indir","s":{"p":[{"t":"Any","n":"$path"},{"t":"Callable","n":"&what"},{"t":"Any","n":":$d?"},{"n":":$r","t":"Any"},{"n":":$w","t":"Any"},{"t":"Any","n":":$x"}],"r":"Mu"},"m":1},{"k":"v","t":"Sub","n":"&list"},{"m":1,"n":"list","s":{"r":"Mu","p":[{"t":"Any","n":"+l"}]},"k":"s"},{"n":"&infix:<⚛+=>","k":"v","t":"Sub"},{"s":{"p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"int"}],"r":"atomicint"},"m":1,"k":"s","n":"infix:<⚛+=>"},{"s":{"p":[{"n":"$target","t":"atomicint"},{"t":"Int","n":"$add"}],"r":"atomicint"},"n":"infix:<⚛+=>","m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"n":"$target","t":"atomicint"},{"t":"Any","n":"$add"}],"r":"atomicint"},"n":"infix:<⚛+=>"},{"k":"c","t":"Slang","a":[{"t":"Mu","n":"$.grammar","k":"v"},{"t":"Mu","n":"$.actions","k":"v"}],"b":"A","m":[{"n":"parse","m":0,"k":"m","s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"grammar"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"actions"},{"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"Slang","mro":["Any"]},{"n":"Kept","t":"PromiseStatus","k":"e"},{"d":"<p><pre><code>multi sub infix:&lt;?^&gt;(Mu $x = Bool::False)\nmulti sub infix:&lt;?^&gt;(Mu \\a, Mu \\b)</code></pre></p><p>Boolean bitwise XOR operator: Coerces the argument(s) to Bool and performs logical XOR on them: it will return True if and only if just one of the argument is true. It returns identity on a single argument.</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<?^>","k":"v"},{"s":{"r":"Mu","p":[{"n":"$x?","t":"Mu"}]},"n":"infix:<?^>","k":"s","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Mu"},{"t":"Mu","n":"b"}],"r":"Mu"},"n":"infix:<?^>","k":"s"},{"t":"SeekType","n":"SeekFromBeginning","k":"e"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","d":"<p>Returns the smallest of the arguments, as determined by cmp semantics.</p><p><pre><code>my $foo = 42;\n$foo min= 0   # read as: $foo decreases to 0</code></pre></p>","n":"&infix:<min>"},{"n":"infix:<min>","s":{"r":"Mu","p":[{"t":"Mu","n":"a"},{"n":"$","t":"Mu"}]},"m":1,"k":"s"},{"s":{"p":[{"n":"$","t":"Mu"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<min>","k":"s","m":1},{"s":{"p":[{"n":"a","t":"Mu"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<min>","m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Int"},{"t":"Int","n":"b"}]},"n":"infix:<min>"},{"s":{"r":"Mu","p":[{"n":"a","t":"int"},{"n":"b","t":"int"}]},"n":"infix:<min>","k":"s","m":1},{"s":{"r":"Mu","p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}]},"m":1,"k":"s","n":"infix:<min>"},{"s":{"p":[{"t":"num","n":"a"},{"n":"b","t":"num"}],"r":"Mu"},"m":1,"n":"infix:<min>","k":"s"},{"m":1,"s":{"p":[{"n":"+args","t":"Any"}],"r":"Mu"},"n":"infix:<min>","k":"s"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub prefix:&lt;not&gt;(Mu $x --&gt; Bool:D)</code></pre></p><p>Evaluates its argument in boolean context (and thus collapses Junctions), and negates the result. Please note that not is easy to misuse. See traps.</p>","n":"&prefix:<not>"},{"n":"prefix:<not>","s":{"r":"Mu","p":[{"t":"Bool","n":"a"}]},"k":"s","m":1},{"s":{"p":[{"n":"a","t":"Mu"}],"r":"Mu"},"m":1,"n":"prefix:<not>","k":"s"},{"b":"C","k":"ro","n":"NumericEnumeration","mro":[],"t":"NumericEnumeration"},{"n":"&infix:<(^)>","k":"v","d":"<p><pre><code>multi sub infix:&lt;(^)&gt;($a, $b)\nmulti sub infix:&lt;⊖&gt;($a,$b)\n\nmulti sub infix:&lt;(^)&gt;(**@p)\nmulti sub infix:&lt;⊖&gt;(**@p)</code></pre></p><p>Symmetric set difference operator.</p><p>Returns the symmetric set difference of all its arguments. This creates a new Set made up of all the elements that $a has but $b doesn't and all the elements $b has but $a doesn't if none of the arguments are a Bag, BagHash, Mix or MixHash. Equivalent to ($a ∖ $b) ∪ ($b ∖ $a).</p><p><pre><code>say &lt;a b&gt; (^) &lt;b c&gt;; # OUTPUT: «set(a c)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy&gt;, the result is a new Bag (or Mix).</p><p><pre><code>say &lt;a b&gt; ⊖ bag(&lt;b c&gt;); # OUTPUT: «Bag(a, c)␤»\n</code></pre></p><p>⊖ is equivalent to (^), at codepoint U+2296 (CIRCLED MINUS).</p>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<(^)>"},{"n":"infix:<(^)>","k":"s","m":1,"s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Setty"}],"r":"Mu"},"k":"s","n":"infix:<(^)>"},{"m":1,"k":"s","s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}],"r":"Mu"},"n":"infix:<(^)>"},{"m":1,"k":"s","s":{"p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<(^)>"},{"k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}],"r":"Mu"},"n":"infix:<(^)>","m":1},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Setty"}]},"n":"infix:<(^)>","m":1},{"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}]},"n":"infix:<(^)>","m":1,"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Baggy"}]},"k":"s","n":"infix:<(^)>"},{"m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Setty","n":"b"}],"r":"Mu"},"n":"infix:<(^)>","k":"s"},{"n":"infix:<(^)>","s":{"p":[{"n":"a","t":"Map"},{"t":"Map","n":"b"}],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}]},"n":"infix:<(^)>"},{"k":"s","s":{"p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}],"r":"Mu"},"m":1,"n":"infix:<(^)>"},{"s":{"p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<(^)>","k":"s"},{"k":"s","s":{"p":[{"n":"+@p","t":"Positional"}],"r":"Mu"},"m":1,"n":"infix:<(^)>"},{"n":"Buf","k":"ro","d":"<p><pre><code>role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T){ ... }</code></pre></p><p>A Buf does the role of a mutable sequence of (usually unsigned) integers.</p><p><pre><code>my $b = Buf.new(1, 2, 3);\n$b[1] = 42;</code></pre></p><p>However, it's a parameterized type, and you can instantiate with several integer types:</p><p><pre><code>my $b = Buf[int32].new( 3, -3, 0xff32, -44)\n# OUTPUT: «Buf[int32]:0x&lt;03 -3 FF32 -2C&gt;»\n</code></pre></p><p>By default, Buf uses 8-bit unsigned integers, that is, it is equivalent to Buf[uint8]. Some other types of Bufs which are used often get their own class name.</p><p></p><table class='sections'><tr></tr>\n<tr><td>buf8</tr><td>Buf[uint8]</tr></tr>\n<tr><td>buf16</tr><td>Buf[uint16]</tr></tr>\n<tr><td>buf32</tr><td>Buf[uint32]</tr></tr>\n<tr><td>buf64</tr><td>Buf[uint64]</tr></tr>\n</table><p>You can use these in pretty much the same way you would with Buf:</p><p><pre><code>my $buf = buf8.new(3,6, 254);\nsay $buf; # OUTPUT: «Buf[uint8]:0x&lt;03 06 fe&gt;␤»</code></pre></p><p>Plus there are some object methods, like encode that might return a buf8 in some cases where it is the best representation for a particular encoding.</p>","m":[{"d":"<p>Defined as:</p><p><pre><code>method write-int8(buf8: uint $pos, int8 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a signed 8-bit integer value at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","n":"write-int8","m":0,"s":{"r":"Mu","p":[{"n":"$offset","t":"int"},{"t":"int8","n":"$value"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"write-int16","s":{"r":"Mu","p":[{"n":"$offset","t":"int"},{"t":"int16","n":"$value"},{"t":"Endian","n":"$endian?"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method write-int16(buf8: uint $pos, int16 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a signed 16-bit integer value at the given position with the given endianness.</p>"},{"k":"m","s":{"p":[{"n":"$offset","t":"int"},{"n":"$value","t":"int32"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"write-int32","m":0,"d":"<p>Defined as:</p><p><pre><code>method write-int32(buf8: uint $pos, int32 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a signed 32-bit integer value at the given position with the given endianness.</p>"},{"k":"m","n":"write-int64","m":0,"s":{"r":"Mu","p":[{"n":"$offset","t":"int"},{"t":"Int","n":"$value"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method write-int64(buf8: uint $pos, Int:D $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a signed 64-bit integer value at the given position with the given endianness.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method write-int128(buf8: uint $pos, Int:D $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a signed 128-bit integer value at the given position with the given endianness.</p>","s":{"r":"Mu","p":[{"t":"int","n":"$offset"},{"t":"Int","n":"$value"},{"n":"$endian?","t":"Endian"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"write-int128"},{"s":{"p":[{"t":"int","n":"$offset"},{"t":"uint8","n":"$value"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p>Defined as:</p><p><pre><code>method write-uint8(buf8: uint $pos, uint8 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes an unsigned 8-bit integer value at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","m":0,"n":"write-uint8","k":"m"},{"n":"write-uint16","d":"<p>Defined as:</p><p><pre><code>method write-uint16(buf8: uint $pos, uint16 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes an unsigned 16-bit integer value at the given position with the given endianness.</p>","s":{"r":"Mu","p":[{"n":"$offset","t":"int"},{"n":"$value","t":"uint16"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method write-uint32(buf8: uint $pos, uint32 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes an unsigned 32-bit integer value at the given position with the given endianness.</p>","k":"m","s":{"p":[{"t":"int","n":"$offset"},{"n":"$value","t":"uint32"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"write-uint32"},{"d":"<p>Defined as:</p><p><pre><code>method write-uint64(buf8: uint $pos, uint64 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes an unsigned 64-bit integer value at the given position with the given endianness.</p>","m":0,"s":{"r":"Mu","p":[{"t":"int","n":"$offset"},{"t":"Int","n":"$value"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"write-uint64"},{"n":"write-uint128","k":"m","d":"<p>Defined as:</p><p><pre><code>method write-uint128(buf8: uint $pos, UInt:D $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes an unsigned 128-bit integer value at the given position with the given endianness.</p>","m":0,"s":{"r":"Mu","p":[{"t":"int","n":"$offset"},{"n":"$value","t":"Int"},{"t":"Endian","n":"$endian?"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method write-num32(buf8: uint $pos, num32 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a native num32 IEEE floating point value at the given position with the given endianness.</p>","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"int","n":"$offset"},{"n":"$value","t":"num32"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}]},"n":"write-num32"},{"s":{"p":[{"n":"$offset","t":"int"},{"t":"num64","n":"$value"},{"n":"$endian?","t":"Endian"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"write-num64","k":"m","d":"<p>Defined as:</p><p><pre><code>method write-num64(buf8: uint $pos, num64 $value, $endian = NativeEndian --&gt; buf8:D)</code></pre></p><p>Writes a native num64 IEEE floating point value at the given position with the given endianness.</p>"},{"s":{"r":"Mu","p":[{"n":"$pos","t":"int"},{"n":"$bits","t":"Int"},{"n":"value","t":"Int"},{"t":"Mu","n":"*%_"}]},"n":"write-bits","m":0,"d":"<p>Defined as:</p><p><pre><code>method write-bits(buf8:D: uint $pos, uint $bits, Int:D $value --&gt; Nil)</code></pre></p><p>Writes a signed integer value for the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian. Always returns Nil.</p>","k":"m"},{"n":"write-ubits","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method write-ubits(buf8: uint $pos, uint $bits, UInt:D $value --&gt; buf8:D)</code></pre></p><p>Writes an unsigned integer value to the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian.</p>","s":{"p":[{"n":"$pos","t":"int"},{"t":"Int","n":"$bits"},{"t":"Int","n":"value"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"n":"reallocate","s":{"p":[{"t":"Int","n":"$elements"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method reallocate($elems)</code></pre></p><p>Change the number of elements of the Buf, returning the changed Buf. The size of Buf will be adapted depending on the number of $elems specified: if it is smaller than the actual size of the Buf the resulting Buf will be shrunk down, otherwise it will be enlarged to fit the number of $elems. In the case the Buf is enlarged, newly created items will be assigned a Virtual Machine specific null value, therefore you should not rely upon their value since it could be inconsistent across different virtual machines.</p><p><pre><code>my Buf $b .= new(^10);\n$b.reallocate(5);\nsay $b.perl;  # OUTPUT: «Buf.new(0,1,2,3,4)␤»\n\n$b = Buf.new( 1..3 );\n$b.reallocate( 10 );\n$b.perl.say; # OUTPUT: «Buf.new(1,2,3,0,0,0,0,0,0,0)␤»</code></pre></p>"},{"s":{"p":[{"t":"Any","n":"$from?"},{"n":"$elems?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"subbuf-rw","d":"<p>Declared as</p><p><pre><code>multi sub subbuf-rw(Buf:D \\b) is rw\nmulti sub subbuf-rw(Buf:D \\b, Int() $from) is rw\nmulti sub subbuf-rw(Buf:D \\b, $from, $elems) is rw</code></pre></p><p>Returns a writable reference to a part of a buffer. Invokes the subbuf-rw method on the specified Buf:</p><p><pre><code>my Buf $b .= new(1,2,3);\nsubbuf-rw($b,2,1) = Buf.new(42);\nsay $b.perl;   # OUTPUT: «Buf.new(1,2,42)␤»</code></pre></p>","k":"m","m":0},{"n":"!pend","k":"m","s":{"r":"Mu","p":[{"n":"@values","t":"Positional"},{"t":"Any","n":"$action"},{"t":"Mu","n":"*%_"}]},"m":0},{"s":{"r":"Mu","p":[{"t":"Int","n":"$offset"},{"n":"$size","t":"Any"},{"n":"x","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m","n":"!splice-native"},{"s":{"p":[{"t":"Any","n":"offset"},{"n":"size","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!remove","m":0,"k":"m"}],"mro":["Blob[T]","Positional[T]","Stringy"],"t":"Buf","b":"C"},{"n":"&atomic-add-fetch","t":"Sub","k":"v"},{"s":{"r":"atomicint","p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"int"}]},"n":"atomic-add-fetch","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"atomicint","n":"$target"},{"t":"Int","n":"$add"}],"r":"atomicint"},"k":"s","n":"atomic-add-fetch"},{"s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"t":"Any","n":"$add"}]},"k":"s","m":1,"n":"atomic-add-fetch"},{"n":"Exception","m":[{"d":"<p>Defined as:</p><p><pre><code>method backtrace(Exception:D:)</code></pre></p><p>Returns the backtrace associated with the exception in a Backtrace object or an empty string if there is none. Only makes sense on exceptions that have been thrown at least once.</p><p><pre><code>try die \"Something bad happened\";\nwith $! { .backtrace.print ; }</code></pre></p>","n":"backtrace","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"vault-backtrace"},{"n":"reset-backtrace","m":0,"k":"m","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"$bt?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"throw","k":"m","d":"<p>Defined as:</p><p><pre><code>method throw(Exception:D:)</code></pre></p><p>Throws the exception.</p><p><pre><code>my $exception = X::AdHoc.new;    # Totally fine\ntry $exception.throw;            # Throws\nif ($!) { #`( some handling ) }; # Suppress the exception</code></pre></p>"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"rethrow","k":"m","d":"<p>Defined as:</p><p><pre><code>method rethrow(Exception:D:)</code></pre></p><p>Rethrows an exception that has already been thrown at least once. This is different from throw in that it preserves the original backtrace.</p><p><pre><code>my $e = X::AdHoc.new(payload =&gt; \"Bad situation\");\nsub f() { die 'Bad' };\nsub g() { try f; CATCH { default { .rethrow } } };\ng;\nCATCH { default { say .backtrace.full } };</code></pre></p>"},{"n":"resume","s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method resume(Exception:D:)</code></pre></p><p>Resumes control flow where .throw left it when handled in a CATCH block.</p><p><pre><code># For example, resume control flow for any exception\nCATCH { default { .resume } }</code></pre></p>","m":0,"k":"m"},{"n":"die","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>multi sub    fail(*@text)\nmulti sub    fail(Exception $e)\nmethod fail(Exception:D:)</code></pre></p><p>Exits the calling Routine and returns a Failure object wrapping the exception $e - or, for the *@text form, an X::AdHoc exception constructed from the concatenation of @text. If the caller activated fatal exceptions via the pragma use fatal;, the exception is thrown instead of being returned as a Failure.</p><p><pre><code># A custom exception defined\nclass ForbiddenDirectory is Exception {\n    has Str $.name;\n\n    method message { \"This directory is forbidden: '$!name'\" }\n}\n\nsub copy-directory-tree ($dir) {\n    # We don't allow for non-directories to be copied\n    fail \"$dir is not a directory\" if !$dir.IO.d;\n    # We don't allow 'foo' directory to be copied too\n    fail ForbiddenDirectory.new(:name($dir)) if $dir eq 'foo';\n    # or above can be written in method form as:\n    # ForbiddenDirectory.new(:name($dir)).fail if $dir eq 'foo';\n    # Do some actual copying here\n    ...\n}\n\n# A Failure with X::AdHoc exception object is returned and\n# assigned, so no throwing Would be thrown without an assignment\nmy $result = copy-directory-tree(\"cat.jpg\");\nsay $result.exception; # OUTPUT: «cat.jpg is not a directory␤»\n\n# A Failure with a custom Exception object is returned\n$result = copy-directory-tree('foo');\nsay $result.exception; # OUTPUT: «This directory is forbidden: 'foo'␤»</code></pre></p>","n":"fail"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool"},"n":"is-compile-time","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method message(Exception:D: --&gt; Str:D)</code></pre></p><p>This is a stub that must be overwritten by subclasses, and should return the exception message.</p><p>Special care should be taken that this method does not produce an exception itself.</p><p><pre><code>try die \"Something bad happened\";\nif ($!) {\n    say $!.message; # OUTPUT: «Something bad happened.␤»\n}</code></pre></p>","n":"message","k":"m","m":0},{"n":"!maybe-set-control","m":0,"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"k":"m"}],"d":"<p><pre><code>class Exception {}</code></pre></p><p>All exceptions that are placed into the $! variable (or into $_ in CATCH blocks) inherit from Exception. When you call die or fail with a non-Exception argument, it is wrapped into an X::AdHoc object, which also inherits from Exception.</p><p>User-defined exception classes should inherit from Exception too, and define at least a method message.</p><p><pre><code>class X::YourApp::SomeError is Exception {\n    method message() {\n        \"A YourApp-Specific error occurred: out of coffee!\";\n    }\n}</code></pre></p>","b":"A","k":"c","t":"Exception","a":[{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["Any"]},{"n":"&infix:«(>+)»","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"s":{"p":[{"t":"Any","n":"$a"},{"n":"$b","t":"Any"}],"r":"Bool:D"},"n":"infix:«(>+)»","k":"s"},{"t":"ProtocolFamily","k":"e","n":"PF_LOCAL"},{"k":"v","t":"Sub","n":"&trait_mod:<handles>"},{"s":{"p":[{"n":"$target","t":"Attribute"},{"t":"Any","n":"$thunk"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<handles>"},{"s":{"r":"Mu","p":[{"n":"$m","t":"Method"},{"n":"&thunk","t":"Callable"}]},"k":"s","n":"trait_mod:<handles>","m":1},{"a":[{"n":"@!dispatchees","k":"v","t":"List"},{"t":"Mu","n":"$!dispatcher_cache","k":"v"},{"k":"v","t":"Mu","n":"$!dispatcher"},{"k":"v","t":"int","n":"$!flags"},{"k":"v","t":"Mu","n":"$!inline_info"},{"t":"Mu","n":"$!package","k":"v"},{"n":"$!onlystar","t":"int","k":"v"},{"t":"List","n":"@!dispatch_order","k":"v"},{"k":"v","t":"Mu","n":"$!dispatch_cache"},{"k":"v","n":"$!why","t":"Mu"},{"t":"Code","n":"$!do","k":"v"},{"k":"v","t":"Signature","n":"$!signature"},{"n":"@!compstuff","k":"v","t":"List"}],"n":"Routine","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"onlystar","m":0,"k":"m"},{"n":"candidates","d":"<p><pre><code>method candidates(Routine:D: --&gt; Positional:D)</code></pre></p><p>Returns a list of multi candidates, or a one-element list with itself if it's not a multi</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"p":[{"n":"$c","t":"Capture"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"cando","k":"m","d":"<p><pre><code>method cando(Capture $c)</code></pre></p><p>Returns a possibly-empty list of candidates that can be called with the given Capture, ordered by narrowest candidate first. For methods, the first element of the Capture needs to be the invocant:</p><p><pre><code>.signature.say for \"foo\".^can(\"comb\")[0].cando: \\(Cool, \"o\");\n# OUTPUT: «(Cool $: Str $matcher, $limit = Inf, *%_)␤»</code></pre></p>"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"multi","d":"<p><pre><code>method multi(Routine:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the routine is a multi sub or method. Note that the name of a multi sub refers to its proto and this method would return false if called on it. It needs to be called on the candidates themselves:</p><p><pre><code>multi foo ($, $) {};\nsay &amp;foo.multi;             # OUTPUT: «False␤»\nsay &amp;foo.candidates».multi; # OUTPUT: «(True)␤»</code></pre></p>","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"soft","m":0,"k":"m"},{"d":"<p><pre><code>method wrap(Routine:D: &amp;wrapper)</code></pre></p><p>Wraps (i.e. in-place modifies) the routine. That means a call to this routine first calls &amp;wrapper, which then can (but doesn't have to) call the original routine with the callsame, callwith, nextsame and nextwith dispatchers. The return value from the routine is also the return value from the wrapper.</p><p>wrap returns an instance of a private class called Routine::WrapHandle, which you can pass to unwrap to restore the original routine.</p>","m":0,"n":"wrap","k":"m","s":{"r":"Mu","p":[{"t":"Callable","n":"&wrapper"},{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$handle"},{"n":"*%_","t":"Mu"}]},"n":"unwrap","d":"<p><pre><code>method unwrap($wraphandle)</code></pre></p><p>Restores the original routine after it has been wrapped with wrap. While the signature allows any type to be passed, only the Routine::WrapHandle type returned from wrap can usefully be.</p>","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>method package(Routine:D:)</code></pre></p><p>Returns the package in which the routine is defined.</p>","m":0,"n":"package"},{"k":"m","s":{"p":[{"n":"*@","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"leave"}],"d":"<p><pre><code>class Routine is Block { }</code></pre></p><p>A Routine is a code object meant for larger unities of code than Block. Routine is the common superclass for Sub (and therefore operators) and Method, the two primary code objects for code reuse.</p><p>Routines serve as a scope limiter for return (i.e. a return returns from the innermost outer Routine).</p><p>The routine level is also the one at which multiness (multi subs and multi methods) are handled. Subroutines can also be declared anon. See the documentation on the anon declarator for more information.</p>","mro":["Callable","Block"],"k":"c","t":"Routine","b":"A"},{"n":"NFD","d":"<p><pre><code>class NFD is Uni {}</code></pre></p><p>A Codepoint string in the \"D\" Unicode Normalization Form</p>","k":"c","b":"A","t":"NFD","m":[{"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"n":"new","k":"m","m":0},{"n":"NFD","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}}],"mro":["Stringy","Positional[uint32]","Uni"]},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊎>"},{"n":"infix:<⊎>","k":"s","m":1,"s":{"r":"Mu","p":[]}},{"n":"infix:<⊎>","s":{"p":[{"n":"a","t":"Bag"}],"r":"Mu"},"k":"s","m":1},{"n":"infix:<⊎>","s":{"r":"Mu","p":[{"n":"a","t":"Mix"}]},"k":"s","m":1},{"k":"s","n":"infix:<⊎>","m":1,"s":{"p":[{"t":"MixHash","n":"a"}],"r":"Mu"}},{"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"t":"QuantHash","n":"b"}]},"n":"infix:<⊎>","m":1},{"n":"infix:<⊎>","k":"s","s":{"r":"Mu","p":[{"t":"Setty","n":"a"},{"n":"b","t":"Map"}]},"m":1},{"s":{"p":[{"t":"Mixy","n":"a"},{"t":"QuantHash","n":"b"}],"r":"Mu"},"n":"infix:<⊎>","k":"s","m":1},{"n":"infix:<⊎>","m":1,"s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"QuantHash"}],"r":"Mu"},"k":"s"},{"n":"infix:<⊎>","s":{"p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}],"r":"Mu"},"m":1,"k":"s"},{"k":"s","s":{"r":"Mu","p":[{"t":"Iterable","n":"a"},{"t":"Iterable","n":"b"}]},"m":1,"n":"infix:<⊎>"},{"m":1,"s":{"p":[{"t":"Any","n":"$"},{"t":"Failure","n":"b"}],"r":"Mu"},"n":"infix:<⊎>","k":"s"},{"m":1,"n":"infix:<⊎>","k":"s","s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"t":"Any","n":"$"}]}},{"k":"s","m":1,"n":"infix:<⊎>","s":{"p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Positional","n":"+@p"}]},"k":"s","m":1,"n":"infix:<⊎>"},{"b":"A","n":"Hyper","mro":["Any"],"a":[{"k":"v","t":"Mu","n":"$.operator"},{"t":"int8","n":"$.dwim-left","k":"v"},{"k":"v","t":"int8","n":"$.dwim-right"},{"n":"$.assigns","k":"v","t":"int8"}],"k":"c","m":[{"m":0,"k":"m","s":{"p":[{"n":"op","t":"Any"},{"t":"Any","n":":$dwim-left"},{"n":":$dwim-right","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"new"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"name"},{"n":"infix","k":"m","m":1,"s":{"r":"Mu","p":[{"n":"left","t":"Any"},{"t":"Any","n":"right"},{"n":"*%_","t":"Mu"}]}},{"m":1,"s":{"r":"Associative:D","p":[{"n":"left","t":"Associative"},{"n":"right","t":"Associative"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"infix"},{"k":"m","m":1,"n":"infix","s":{"r":"Mu","p":[{"n":"left","t":"Associative"},{"n":"right","t":"List"},{"n":"*%_","t":"Mu"}]}},{"n":"infix","k":"m","m":1,"s":{"p":[{"n":"left","t":"Associative"},{"n":"right","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Associative:D"}},{"s":{"r":"Mu","p":[{"t":"List","n":"left"},{"t":"Associative","n":"right"},{"n":"*%_","t":"Mu"}]},"n":"infix","m":1,"k":"m"},{"n":"infix","k":"m","m":1,"s":{"r":"Associative:D","p":[{"n":"left","t":"Any"},{"t":"Associative","n":"right"},{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Positional:D","p":[{"t":"Positional","n":"left"},{"n":"right","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"infix","k":"m","m":1},{"m":1,"s":{"p":[{"n":"left","t":"Any"},{"n":"right","t":"Positional"},{"n":"*%_","t":"Mu"}],"r":"Positional:D"},"n":"infix","k":"m"},{"k":"m","n":"infix","s":{"r":"Iterable:D","p":[{"n":"left","t":"Iterable"},{"t":"Iterable","n":"right"},{"t":"Mu","n":"*%_"}]},"m":1},{"k":"m","n":"infix","s":{"p":[{"n":"object","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"operator","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"dwim-left"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"dwim-right"},{"k":"m","n":"assigns","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"},{"n":"!right-exhausted","s":{"p":[{"t":"Iterator","n":"iterator"},{"t":"int","n":"$right-elems"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"n":"!str-associatives","k":"m","s":{"r":"Mu","p":[{"n":"left","t":"Any"},{"n":"right","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Iterator","n":"iterator"},{"t":"int","n":"$left-elems"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!left-exhausted"},{"s":{"r":"Mu","p":[{"t":"Any","n":"left"},{"n":"right","t":"Any"},{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"!mu-pair"},{"k":"m","m":0,"s":{"p":[{"t":"Iterator","n":"left"},{"n":"right","t":"Iterator"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!iterators-left-right"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"left","t":"Any"},{"t":"Any","n":"right"},{"n":"*%_","t":"Mu"}]},"n":"!obj-associatives"},{"s":{"r":"Mu","p":[{"t":"PredictiveIterator","n":"left"},{"n":"right","t":"PredictiveIterator"},{"t":"Mu","n":"*%_"}]},"n":"!predictive-iterators","k":"m","m":0},{"k":"m","m":0,"s":{"p":[{"n":"left","t":"Iterator"},{"t":"Iterator","n":"right"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!iterators-left"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Iterator","n":"left"},{"t":"Iterator","n":"right"},{"t":"Mu","n":"*%_"}]},"n":"!iterators"},{"m":0,"n":"!iterators-right","k":"m","s":{"p":[{"n":"left","t":"Iterator"},{"n":"right","t":"Iterator"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"!pair-mu","m":0,"k":"m","s":{"r":"Mu","p":[{"n":"left","t":"Any"},{"n":"right","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"k":"m","n":"!pair-pair","m":0,"s":{"p":[{"n":"left","t":"Any"},{"t":"Any","n":"right"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","s":{"p":[{"t":"Positional","n":"@keys"},{"n":"left","t":"Any"},{"n":"right","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!associatives"}],"t":"Hyper"},{"t":"Sub","n":"&chmod","k":"v"},{"s":{"p":[{"n":"$mode","t":"Any"},{"t":"Positional","n":"*@filenames"}],"r":"Mu"},"k":"s","n":"chmod","m":1},{"k":"v","n":"&infix:«+>»","t":"Sub+{is-pure}"},{"m":1,"n":"infix:«+>»","s":{"r":"Mu","p":[]},"k":"s"},{"n":"infix:«+>»","m":1,"k":"s","s":{"p":[{"n":"$x","t":"Any"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"$x","t":"Any"},{"n":"$y","t":"Any"}]},"n":"infix:«+>»","k":"s"},{"s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}]},"m":1,"n":"infix:«+>»","k":"s"},{"n":"infix:«+>»","s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"},"m":1,"k":"s"},{"t":"int","n":"int","k":"n"},{"a":[{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"m":[{"m":0,"n":"iterator","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"clone"},{"s":{"p":[{"n":"to-set","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"set","k":"m"},{"m":0,"s":{"p":[{"n":"to-unset","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m","n":"unset"},{"s":{"r":"Setty:D","p":[{"n":"type","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Mu","n":"*%_"}]},"n":"!create-from-iterator","k":"m","m":0},{"n":"!HASHIFY","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"type"},{"n":"*%_","t":"Mu"}]},"m":0}],"t":"SetHash","mro":["Setty","QuantHash","Associative","Any"],"k":"c","b":"A","d":"<p><pre><code>class SetHash does Setty { }</code></pre></p><p>A SetHash is a mutable set, meaning a collection of distinct elements in no particular order. (For immutable sets, see Set instead.)</p><p>Objects/values of any type are allowed as set elements. Within a Set, every element is guaranteed to be unique (in the sense that no two elements would compare positively with the === operator):</p><p><pre><code>my $fruits = &lt;peach apple orange apple apple&gt;.SetHash;\n\nsay $fruits.elems;      # OUTPUT: «3␤»\nsay $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n</code></pre></p><p>SetHashes can be treated as object hashes using the { } postcircumfix operator, which returns the value True for keys that are elements of the set, and False for keys that aren't. Assigning a value that boolifies to True or False, respectively, can be used to add or remove a set element:</p><p><pre><code>my $fruits = &lt;peach apple orange apple apple&gt;.SetHash;\n\nsay $fruits&lt;apple&gt;;     # OUTPUT: «True␤»\nsay $fruits&lt;kiwi&gt;;      # OUTPUT: «False␤»\n\n$fruits&lt;apple kiwi&gt; = False, True;\nsay $fruits.keys.sort;  # OUTPUT: «kiwi orange peach␤»\n</code></pre></p><p>Here is a convenient shorthand idiom for adding and removing SetHash elements:</p><p><pre><code>my SetHash $fruits .= new;\nsay $fruits&lt;cherry&gt;;      # OUTPUT: «False␤»\n$fruits&lt;cherry&gt;++;\nsay $fruits&lt;cherry&gt;;      # OUTPUT: «True␤»\n$fruits&lt;apple banana kiwi&gt;»++; # Add multiple elements\n\n$fruits&lt;cherry&gt;--;\nsay $fruits&lt;cherry&gt;;      # OUTPUT: «False␤»\n$fruits&lt;banana kiwi&gt;»--; # Remove multiple elements\n\n</code></pre></p>","n":"SetHash"},{"k":"c","a":[{"t":"Int","k":"v","n":"$.initial_threads"},{"k":"v","t":"Int","n":"$.max_threads"},{"k":"v","t":"Lock","n":"$!state-lock"},{"t":"ThreadPoolScheduler::Queue","n":"$!general-queue","k":"v"},{"t":"ThreadPoolScheduler::Queue","k":"v","n":"$!timer-queue"},{"k":"v","t":"Mu","n":"$!general-workers"},{"t":"Mu","n":"$!timer-workers","k":"v"},{"n":"$!affinity-workers","k":"v","t":"Mu"},{"k":"v","n":"$!supervisor","t":"Thread"},{"k":"v","t":"Callable","n":"&.uncaught_handler"}],"m":[{"k":"s","m":0,"n":"BUILD","s":{"r":"Nil","p":[{"n":":$!initial_threads?","t":"Int"},{"n":":$!max_threads?","t":"Int"},{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Bool","n":":$hint-time-sensitive"},{"t":"Any","n":":$hint-affinity"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"queue","k":"m"},{"m":1,"s":{"p":[{"n":"&code","t":"Callable"},{"n":":$every!","t":"Any"},{"n":":$times?","t":"Any"},{"t":"Associative","n":"*%_"}],"r":"Mu"},"k":"m","n":"cue"},{"s":{"r":"Mu","p":[{"n":"&code","t":"Callable"},{"n":":$times!","t":"Any"},{"t":"Associative","n":"*%_"}]},"k":"m","m":1,"n":"cue"},{"k":"m","m":1,"s":{"r":"Mu","p":[{"n":"&code","t":"Callable"},{"t":"Any","n":":$at!"},{"n":"*%_","t":"Associative"}]},"n":"cue"},{"m":1,"k":"m","n":"cue","s":{"p":[{"t":"Callable","n":"&code"},{"t":"Any","n":":$in!"},{"n":"*%_","t":"Associative"}],"r":"Mu"}},{"s":{"r":"Nil","p":[{"n":"&code","t":"Callable"},{"n":":&catch!","t":"Callable"},{"t":"Mu","n":"*%_"}]},"k":"m","m":1,"n":"cue"},{"n":"cue","k":"m","m":1,"s":{"r":"Nil","p":[{"t":"Callable","n":"&code"},{"t":"Mu","n":"*%_"}]}},{"m":0,"k":"m","n":"loads","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":1,"n":"usage","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"k":"m","m":1,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"usage"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"initial_threads"},{"m":0,"n":"max_threads","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"uncaught_handler","m":0,"k":"m"},{"m":0,"n":"BUILDALL","k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"!general-queue","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Callable","n":"&code"},{"n":"$delay","t":"int"},{"t":"int","n":"$times"},{"n":"%args","t":"Associative"},{"t":"Mu","n":"*%_"}]},"n":"!CUE_DELAY_TIMES","k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!timer-queue","k":"m","m":0},{"k":"m","m":0,"n":"!maybe-start-supervisor","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"!affinity-queue","k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Any","n":"queue"},{"n":"worker-list","t":"Any"},{"t":"Callable","n":"&add-worker"},{"n":"$cores","t":"Any"},{"n":"$per-core-util","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!tweak-workers"}],"d":"<p><pre><code>class ThreadPoolScheduler does Scheduler {}\n</code></pre></p><p>The ThreadPoolScheduler has a range of number of threads that it maintains, and it distributes work among those threads. When the upper limit of threads isn't reached yet, and there is work pending, it spawns new threads to handle the work.</p>","n":"ThreadPoolScheduler","b":"A","mro":["Scheduler","Any"],"t":"ThreadPoolScheduler"},{"n":"ThreadPoolScheduler::ThreadPoolAwaiter","mro":["Awaiter","Any"],"m":[{"n":"BUILD","k":"s","s":{"r":"Mu","p":[{"n":":$queue!","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0},{"k":"m","s":{"p":[{"n":"$a","t":"Awaitable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"await"},{"n":"await-all","s":{"p":[{"n":"i","t":"Iterable"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m"},{"k":"s","m":0,"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Iterable","n":"i"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!do-await-all","k":"m","m":0},{"m":0,"n":"!do-await","s":{"r":"Mu","p":[{"t":"Awaitable","n":"$a"},{"n":"*%_","t":"Mu"}]},"k":"m"}],"a":[{"t":"Mu","k":"v","n":"$!queue"}],"t":"ThreadPoolScheduler::ThreadPoolAwaiter","b":"A","k":"c"},{"m":[{"d":"<p>Defined as:</p><p><pre><code>method pull-one(Iterator:D: --&gt; Mu)</code></pre></p><p>This method stub ensures that classes implementing the Iterator role provide a method named pull-one.</p><p>The pull-one method is supposed to produce and return the next value if possible, or return the sentinel value IterationEnd if no more values could be produced.</p><p><pre><code>my $i = (1 .. 3).iterator;\nsay $i.pull-one;       # OUTPUT: «1␤»\nsay $i.pull-one;       # OUTPUT: «2␤»\nsay $i.pull-one;       # OUTPUT: «3␤»\nsay $i.pull-one.perl;  # OUTPUT: «IterationEnd␤»</code></pre></p><p>As a more illustrative example of its use, here is a count down iterator along with a simplistic subroutine re-implementation of the for loop.</p><p><pre><code># works the same as (10 ... 1, 'lift off')\nclass CountDown does Iterator {\n    has Int:D $!current = 10;\n\n    method pull-one ( --&gt; Mu ) {\n        my $result = $!current--;\n        if $result ==  0 { return 'lift off' }\n        if $result == -1 { return IterationEnd }\n\n        # calling .pull-one again after it returns IterationEnd is undefined\n        if $result &lt;= -2 {\n            # so for fun we will give them nonsense data\n            return (1..10).pick;\n        }\n\n        return $result;\n    }\n}\n\nsub for( Iterable:D $sequence, &amp;do --&gt; Nil ) {\n    my Iterator:D $iterator = $sequence.iterator;\n\n    loop {\n        # must bind the result so that =:= works\n        my Mu $pulled := $iterator.pull-one;\n\n        # always check the result and make sure that .pull-one\n        # is not called again after it returns IterationEnd\n        if $pulled =:= IterationEnd { last }\n\n        do( $pulled );\n    }\n}\n\nfor( Seq.new(CountDown.new), &amp;say );  # OUTPUT: «10␤9␤8␤7␤6␤5␤4␤3␤2␤1␤lift off␤»</code></pre></p><p>It would be more idiomatic to use while or until, and a sigilless variable.</p><p><pre><code>until IterationEnd =:= (my \\pulled = $iterator.pull-one) {\n    do( pulled );\n}\n</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"pull-one","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"skip-one","d":"<p>Defined as:</p><p><pre><code>method skip-one(Iterator:D: $target --&gt; Mu)</code></pre></p><p>Should skip producing one value. The return value should be truthy if the skip was successful and falsy if there were no values to be skipped:</p><p><pre><code>my $i = &lt;a b&gt;.iterator;\nsay $i.skip-one; say $i.pull-one; say $i.skip-one\n# OUTPUT: «1␤b␤0␤»</code></pre></p><p>The Iterator role implements this method as a call pull-one and returning whether the value obtained was not IterationEnd.</p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method push-exactly(Iterator:D: $target, int $count --&gt; Mu)</code></pre></p><p>Should produce $count elements, and for each of them, call $target.push($value).</p><p>If fewer than $count elements are available from the iterator, it should return the sentinel value IterationEnd. Otherwise it should return $count.</p><p><pre><code>my @array;\nsay (1 .. ∞).iterator.push-exactly(@array, 3); # OUTPUT: «3␤»\nsay @array; # OUTPUT: «[1 2 3]␤»</code></pre></p><p>The Iterator role implements this method in terms of pull-one. In general, this is a method that is not intended to be called directly from the end user who, instead, should implement it in classes that mix the iterator role. For instance, this class implements that role:</p><p><pre><code>class DNA does Iterable does Iterator {\n    has $.chain;\n    has Int $!index = 0;\n\n    method new ($chain where {\n                       $chain ~~ /^^ &lt;[ACGT]&gt;+ $$ / and\n                       $chain.chars %% 3 } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator( ){ self }\n\n    method pull-one( --&gt; Mu){\n      if $!index &lt; $.chain.chars {\n         my $codon = $.chain.comb.rotor(3)[$!index div 3];\n         $!index += 3;\n         return $codon;\n      } else {\n        return IterationEnd;\n      }\n    }\n\n    method push-exactly(Iterator:D: $target, int $count --&gt; Mu) {\n        return IterationEnd if $.chain.elems / 3 &lt; $count;\n        for ^($count) {\n            $target.push: $.chain.comb.rotor(3)[ $_ ];\n        }\n    }\n\n};\n\nmy $b := DNA.new(\"AAGCCT\");\nfor $b -&gt; $a, $b, $c { say \"Never mind\" }; # Does not enter the loop\nmy $þor := DNA.new(\"CAGCGGAAGCCT\");\nfor $þor -&gt; $first, $second {\n    say \"Coupled codons: $first, $second\";\n    # OUTPUT: «Coupled codons: C A G, C G G␤Coupled codons: A A G, C C T␤»\n}\n</code></pre></p><p>This code, which groups DNA chains in triplets (usually called codons) returns those codons when requested in a loop; if too many are requested, like in the first case for $b -&gt; $a, $b, $c, it simply does not enter the loop since push-exactly will return IterationEnd since it is not able to serve the request for exactly 3 codons. In the second case, however, it requests exactly two codons in each iteration of the loop; push-exactly is being called with the number of loop variables as the $count variable.</p>","m":0,"k":"m","s":{"p":[{"n":"target","t":"Any"},{"n":"$n","t":"int"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"push-exactly"},{"d":"<p>Defined as:</p><p><pre><code>method push-at-least(Iterator:D: $target, int $count --&gt; Mu)</code></pre></p><p>Should produce at least $count elements, and for each of them, call $target.push($value).</p><p>If fewer than $count elements are available from the iterator, it should return the sentinel value IterationEnd. Otherwise it should return $count.</p><p>Iterators with side effects should produce exactly $count elements; iterators without side effects (such as Range iterators) can produce more elements to achieve better performance.</p><p><pre><code>my @array;\nsay (1 .. ∞).iterator.push-at-least(@array, 10); # OUTPUT: «10␤»\nsay @array; # OUTPUT: «[1 2 3 4 5 6 7 8 9 10]␤»</code></pre></p><p>The Iterator role implements this method in terms of pull-one. In general, it is also not intended to be called directly as in the example above. It can be implemented, if unhappy with this default implementation, by those using this role. See the documentation for push-exactly for an example implementation.</p>","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"target"},{"t":"int","n":"$n"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"push-at-least"},{"k":"m","s":{"p":[{"t":"Any","n":"target"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"push-all","d":"<p>Defined as:</p><p><pre><code>method push-all(Iterator:D: $target)</code></pre></p><p>Should produce all elements from the iterator and push them to $target.</p><p><pre><code>my @array;\nsay (1 .. 1000).iterator.push-all(@array); # All 1000 values are pushed</code></pre></p><p>The Iterator role implements this method in terms of push-at-least. As in the case of the other push-* methods, it is mainly intended for developers implementing this role. push-all is called when assigning an object with this role to an array, for instance, like in this example:</p><p><pre><code>class DNA does Iterable does Iterator {\n    has $.chain;\n    has Int $!index = 0;\n\n    method new ($chain where {\n                       $chain ~~ /^^ &lt;[ACGT]&gt;+ $$ / and\n                       $chain.chars %% 3 } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator( ){ self }\n    method pull-one( --&gt; Mu){\n      if $!index &lt; $.chain.chars {\n         my $codon = $.chain.comb.rotor(3)[$!index div 3];\n         $!index += 3;\n         return $codon;\n      } else {\n        return IterationEnd;\n      }\n    }\n\n    method push-all(Iterator:D: $target) {\n        for $.chain.comb.rotor(3) -&gt; $codon {\n            $target.push: $codon;\n        }\n    }\n\n};\n\nmy $b := DNA.new(\"AAGCCT\");\nmy @dna-array = $b;\nsay @dna-array; # OUTPUT: «[(A A G) (C C T)]␤»\n</code></pre></p><p>The push-all method implemented pushes to the target iterator in lists of three aminoacid representations; this is called under the covers when we assign $b to @dna-array.</p>"},{"k":"m","n":"push-until-lazy","s":{"p":[{"t":"Any","n":"target"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"d":"<p>Defined as:</p><p><pre><code>method push-until-lazy(Iterator:D: $target --&gt; Mu)</code></pre></p><p>Should produce values until it considers itself to be lazy, and push them onto $target.</p><p>The Iterator role implements this method as a no-op if is-lazy returns a True value, or as a synonym of push-all if not.</p><p>This matters mostly for iterators that have other iterators embedded, some of which might be lazy, while others aren't.</p>"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method skip-at-least(Iterator:D: $target, int $to-skip --&gt; Mu)</code></pre></p><p>Should skip producing $to-skip values. The return value should be truthy if the skip was successful and falsy if there were not enough values to be skipped:</p><p><pre><code>my $i = &lt;a b c&gt;.iterator;\nsay $i.skip-at-least(2); say $i.pull-one; say $i.skip-at-least(20);\n# OUTPUT: «1␤c␤0␤»</code></pre></p><p>The Iterator role implements this method as a loop calling skip-one and returning whether it returned a truthy value sufficient number of times.</p>","m":0,"s":{"p":[{"n":"$toskip","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"skip-at-least"},{"n":"skip-at-least-pull-one","d":"<p>Defined as:</p><p><pre><code>method skip-at-least-pull-one(Iterator:D: $target, int $to-skip --&gt; Mu)</code></pre></p><p>Should skip producing $to-skip values and if the iterator is still not exhausted, produce and return the next value. Should return IterationEnd if the iterator got exhausted at any point:</p><p><pre><code>my $i = &lt;a b c&gt;.iterator;\nsay $i.skip-at-least-pull-one(2);\nsay $i.skip-at-least-pull-one(20) =:= IterationEnd;\n# OUTPUT: «c␤True␤»</code></pre></p><p>The Iterator role implements this method as calling skip-at-least and then calling pull-one if it was not exhausted yet.</p>","m":0,"k":"m","s":{"p":[{"t":"int","n":"$toskip"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method sink-all(Iterator:D: --&gt; IterationEnd)</code></pre></p><p>Should exhaust the iterator purely for the side-effects of producing the values, without actually saving them in any way. Should always return IterationEnd. If there are no side-effects associated with producing a value, then it can be implemented by a consuming class to be a virtual no-op.</p><p><pre><code>say (1 .. 1000).iterator.sink-all;  # OUTPUT: «IterationEnd␤»</code></pre></p><p>The Iterator role implements this method as a loop that calls pull-one until it is exhausted.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"sink-all","m":0},{"m":0,"s":{"r":"Bool","p":[{"n":"*%_","t":"Mu"}]},"n":"is-lazy","d":"<p>Defined as:</p><p><pre><code>method is-lazy(Iterator:D: --&gt; Bool:D)</code></pre></p><p>Should return True for iterators that consider themselves lazy, and False otherwise.</p><p>Built-in operations that know that they can produce infinitely many values return True here, for example (1..6).roll(*).</p><p><pre><code>say (1 .. 100).is-lazy; # OUTPUT: «False␤»\nsay (1 .. ∞).is-lazy; # OUTPUT: «True␤»</code></pre></p><p>The Iterator role implements this method returning False, indicating a non-lazy iterator.</p>","k":"m"}],"mro":[],"n":"Iterator","b":"C","t":"Iterator","k":"ro","d":"<p><pre><code>constant IterationEnd\nrole Iterator { }\n</code></pre></p><p>A Iterator is an object that can generate or provide elements of a sequence. Users usually don't have to care about iterators, their usage is hidden behind iteration APIs such as for @list { }, map, grep, head, tail, skip and list indexing with .[$idx].</p><p>The main API is the pull-one method, which either returns the next value, or the sentinel value IterationEnd if no more elements are available. Each class implementing Iterator must provide a pull-one method. All other non-optional Iterator API methods are implemented in terms of pull-one, but can also be overridden by consuming classes for performance or other reasons. There are also optional Iterator API methods that will only be called if they are implemented by the consuming class: these are not implemented by the Iterator role.</p><p></p>"},{"t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:«(<)»","k":"v"},{"s":{"r":"Bool:D","p":[{"t":"Setty","n":"a"},{"t":"Setty","n":"b"}]},"k":"s","m":1,"n":"infix:«(<)»"},{"k":"s","n":"infix:«(<)»","s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"t":"Mixy","n":"b"}]},"m":1},{"m":1,"s":{"p":[{"n":"a","t":"Setty"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"n":"infix:«(<)»","k":"s"},{"s":{"p":[{"t":"Setty","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<)»"},{"n":"infix:«(<)»","m":1,"k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"t":"Mixy","n":"b"}],"r":"Bool:D"}},{"k":"s","s":{"r":"Bool:D","p":[{"t":"Mixy","n":"a"},{"t":"Baggy","n":"b"}]},"m":1,"n":"infix:«(<)»"},{"m":1,"n":"infix:«(<)»","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}],"r":"Bool:D"},"k":"s"},{"s":{"r":"Bool:D","p":[{"t":"Baggy","n":"a"},{"t":"Mixy","n":"b"}]},"m":1,"k":"s","n":"infix:«(<)»"},{"k":"s","n":"infix:«(<)»","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"m":1},{"k":"s","n":"infix:«(<)»","s":{"r":"Bool:D","p":[{"t":"Baggy","n":"a"},{"t":"Any","n":"b"}]},"m":1},{"n":"infix:«(<)»","k":"s","m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Mixy"}],"r":"Bool:D"}},{"k":"s","s":{"p":[{"n":"a","t":"Any"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:«(<)»"},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"t":"Any","n":"$"}]},"n":"infix:«(<)»","k":"s"},{"n":"infix:«(<)»","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}]}},{"m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Bool:D"},"n":"infix:«(<)»","k":"s"},{"n":"SIGFPE","t":"Signal","k":"e"},{"k":"v","n":"&infix:<≡>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}"},{"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}]},"n":"infix:<≡>","m":1},{"m":1,"n":"infix:<≡>","k":"s","s":{"p":[{"n":"a","t":"Setty"},{"t":"Mixy","n":"b"}],"r":"Bool:D"}},{"n":"infix:<≡>","k":"s","s":{"r":"Bool:D","p":[{"t":"Setty","n":"a"},{"t":"Baggy","n":"b"}]},"m":1},{"k":"s","s":{"p":[{"n":"a","t":"Setty"},{"t":"Any","n":"b"}],"r":"Bool:D"},"n":"infix:<≡>","m":1},{"m":1,"s":{"p":[{"t":"Mixy","n":"a"},{"t":"Mixy","n":"b"}],"r":"Bool:D"},"n":"infix:<≡>","k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"n":"infix:<≡>"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Setty"}]},"n":"infix:<≡>","k":"s"},{"s":{"p":[{"n":"a","t":"Mixy"},{"t":"Any","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<≡>","m":1},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Mixy"}]},"n":"infix:<≡>"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"n":"infix:<≡>"},{"s":{"p":[{"n":"a","t":"Baggy"},{"t":"Setty","n":"b"}],"r":"Bool:D"},"n":"infix:<≡>","m":1,"k":"s"},{"k":"s","n":"infix:<≡>","m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Any"}],"r":"Bool:D"}},{"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}]},"m":1,"n":"infix:<≡>"},{"k":"s","s":{"p":[{"n":"a","t":"Iterable"},{"n":"b","t":"Map"}],"r":"Bool:D"},"n":"infix:<≡>","m":1},{"k":"s","n":"infix:<≡>","m":1,"s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"n":"b","t":"Mixy"}]}},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"t":"Baggy","n":"b"}],"r":"Bool:D"},"n":"infix:<≡>"},{"n":"infix:<≡>","m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Setty"}],"r":"Bool:D"}},{"s":{"r":"Mu","p":[{"t":"Failure","n":"a"},{"t":"Any","n":"$"}]},"k":"s","m":1,"n":"infix:<≡>"},{"s":{"p":[{"n":"$","t":"Any"},{"t":"Failure","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<≡>","k":"s"},{"m":1,"n":"infix:<≡>","s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]},"k":"s"},{"k":"v","t":"Sub","n":"&fc"},{"k":"s","n":"fc","m":1,"s":{"r":"Mu","p":[{"n":"$s","t":"Cool"}]}},{"m":[{"k":"m","d":"<p><pre><code>method new(Iterator:D $iter --&gt; Seq:D)</code></pre></p><p>Creates a new Seq object from the iterator passed as the single argument.</p>","m":1,"s":{"r":"Mu","p":[{"t":"Iterator","n":"$iter"},{"t":"Mu","n":"*%_"}]},"n":"new"},{"d":"<p><pre><code>method new(Iterator:D $iter --&gt; Seq:D)</code></pre></p><p>Creates a new Seq object from the iterator passed as the single argument.</p>","m":1,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"new","k":"m"},{"k":"m","d":"<p><pre><code>method iterator(Seq:D: --&gt; Iterator:D)</code></pre></p><p>Returns the underlying iterator, and marks the invocant as consumed. If called on an already consumed sequence, throws an error of type X::Seq::Consumed.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"iterator"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Capture"},{"m":0,"d":"<p><pre><code>method elems(Seq:D:)</code></pre></p><p>If the caller Seq is not lazy, consumes and caches its values, returning their length. Otherwise, throws an error of type X::Cannot::Lazy.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"elems","k":"m"},{"k":"m","n":"Numeric","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"n":"Int","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"Bool","k":"m"},{"k":"m","s":{"r":"Str:D","p":[{"n":"$separator?","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"join","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Seq:D"},"k":"m","n":"reverse","m":0},{"m":0,"k":"m","s":{"r":"Seq:D","p":[{"n":"$rotate?","t":"Cool"},{"t":"Mu","n":"*%_"}]},"n":"rotate"},{"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]},"m":0,"d":"<p>Defined as:</p><p><pre><code>method sink(--&gt; Nil)</code></pre></p><p>Calls sink-all if it is an Iterator, sink if the Sequence is a list.</p><p><pre><code>say (1 ... 1000).sink; # OUTPUT: «Nil␤»</code></pre></p><p>This is something you might want to do for the side effects of producing those values.</p>","n":"sink","k":"m"},{"m":1,"s":{"r":"Mu","p":[{"n":"&body","t":"Callable"},{"n":":$label","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"from-loop","d":"<p><pre><code>multi method from-loop(&amp;body --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, :$repeat --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, &amp;afterward --&gt; Seq:D)</code></pre></p><p>These methods create new Seq-based callbacks.</p><p>The first form produces an infinite Seq by calling &amp;body each time a new element is requested, using the return value from &amp;body as the item. This emulates (or implements) a loop { body } construct.</p><p>The second form calls &amp;cond before each call to &amp;body, and terminates the sequence if &amp;cond returns a false value. If $repeat is set to a true value, the first call to &amp;cond is omitted, and &amp;body called right away. This emulates (or implements) while cond { body } and repeat { body } while cond loops.</p><p>The third form enables C-style looping by calling a third callback, &amp;afterward, after each call to &amp;body.</p>","k":"m"},{"s":{"p":[{"n":"&body","t":"Callable"},{"n":"&cond","t":"Callable"},{"n":":$repeat!","t":"Any"},{"n":":$label","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"n":"from-loop","d":"<p><pre><code>multi method from-loop(&amp;body --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, :$repeat --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, &amp;afterward --&gt; Seq:D)</code></pre></p><p>These methods create new Seq-based callbacks.</p><p>The first form produces an infinite Seq by calling &amp;body each time a new element is requested, using the return value from &amp;body as the item. This emulates (or implements) a loop { body } construct.</p><p>The second form calls &amp;cond before each call to &amp;body, and terminates the sequence if &amp;cond returns a false value. If $repeat is set to a true value, the first call to &amp;cond is omitted, and &amp;body called right away. This emulates (or implements) while cond { body } and repeat { body } while cond loops.</p><p>The third form enables C-style looping by calling a third callback, &amp;afterward, after each call to &amp;body.</p>","k":"m"},{"d":"<p><pre><code>multi method from-loop(&amp;body --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, :$repeat --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, &amp;afterward --&gt; Seq:D)</code></pre></p><p>These methods create new Seq-based callbacks.</p><p>The first form produces an infinite Seq by calling &amp;body each time a new element is requested, using the return value from &amp;body as the item. This emulates (or implements) a loop { body } construct.</p><p>The second form calls &amp;cond before each call to &amp;body, and terminates the sequence if &amp;cond returns a false value. If $repeat is set to a true value, the first call to &amp;cond is omitted, and &amp;body called right away. This emulates (or implements) while cond { body } and repeat { body } while cond loops.</p><p>The third form enables C-style looping by calling a third callback, &amp;afterward, after each call to &amp;body.</p>","n":"from-loop","m":1,"k":"m","s":{"p":[{"n":"&body","t":"Callable"},{"n":"&cond","t":"Callable"},{"t":"Any","n":":$label"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p><pre><code>multi method from-loop(&amp;body --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, :$repeat --&gt; Seq:D)\nmulti method from-loop(&amp;body, &amp;cond, &amp;afterward --&gt; Seq:D)</code></pre></p><p>These methods create new Seq-based callbacks.</p><p>The first form produces an infinite Seq by calling &amp;body each time a new element is requested, using the return value from &amp;body as the item. This emulates (or implements) a loop { body } construct.</p><p>The second form calls &amp;cond before each call to &amp;body, and terminates the sequence if &amp;cond returns a false value. If $repeat is set to a true value, the first call to &amp;cond is omitted, and &amp;body called right away. This emulates (or implements) while cond { body } and repeat { body } while cond loops.</p><p>The third form enables C-style looping by calling a third callback, &amp;afterward, after each call to &amp;body.</p>","s":{"r":"Mu","p":[{"t":"Callable","n":"&body"},{"n":"&cond","t":"Callable"},{"t":"Callable","n":"&afterwards"},{"n":":$label","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":1,"k":"m","n":"from-loop"}],"k":"c","a":[{"t":"Iterator","k":"v","n":"$!iter"},{"k":"v","n":"$!list","t":"Mu"}],"t":"Seq","d":"<p><pre><code>class Seq is Cool does Iterable does PositionalBindFailover { }</code></pre></p><p>A Seq represents anything that can lazily produce a sequence of values. A Seq is born in a state where iterating it will consume the values. However, calling .cache on a Seq will return a List that is still lazy, but stores the generated values for later access. However, assigning a Seq to an array consumes the Seq; alternatively, you can use the lazy statement prefix to avoid it from being iterated during the assignment:</p><p><pre><code># The Seq created by gather ... take is consumed on the spot here.\nmy @a = gather do { say 'consuming...'; take 'one' };  # OUTPUT: «consuming...␤»\n\n# The Seq here is only consumed as we iterate over @a later.\nmy @a = lazy gather do { say 'consuming...'; take 'one' };  # outputs nothing.\n.say for @a;  # OUTPUT: «consuming...␤one␤»\n</code></pre></p><p>A typical use case is method lines in IO::Handle, which could use a lot of memory if it stored all the lines read from the file. So</p><p><pre><code>for open('README.md').lines -&gt; $line {\n    say $line;\n}\n</code></pre></p><p>won't keep all lines from the file in memory.</p><p>This implies that you cannot iterate the same Seq object twice (otherwise it couldn't throw away old values), so this dies:</p><p><pre><code>my @a = 1, 2, 3;\nmy @b = &lt;a b c&gt;;\nmy \\c = @a Z=&gt; @b;\n.say for c;\n.say for c; # fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Seq::Consumed: This Seq has already been iterated, and its values consumed\n# (you might solve this by adding .cache on usages of the Seq, or\n# by assigning the Seq into an array)»</code></pre></p><p>A high-level construct to generate a Seq is gather/take, as well as many built-in methods like map and grep, low-level constructors to create a Seq from an iterator or from looping constructs are available too.</p><p>Caution: No program should ever assume a Seq may only be iterated once even if not cached by the program. Caching is a volatile state exposed to the developer as an optimization. The Seq may become cached by many operations, including calling perl on the Seq (if called prior to a non-cached iteration). From version 6.d, you .perl can be called on consumed &lt;Seq&gt;. If a program assumes a Seq can only iterate once, but then is later changed to call one of these operations during the loop, that assumption will fail.</p>","n":"Seq","mro":["Sequence","PositionalBindFailover","Iterable","Cool"],"b":"C"},{"k":"v","n":"&infix:<o>","t":"Sub"},{"m":1,"n":"infix:<o>","s":{"r":"Mu","p":[]},"k":"s"},{"n":"infix:<o>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"&f","t":"Callable"}]}},{"s":{"r":"Block:D","p":[{"n":"&f","t":"Callable"},{"n":"&g","t":"Callable"}]},"k":"s","n":"infix:<o>","m":1},{"n":"e","k":"c","mro":["Real","Numeric","Cool"],"t":"Num","b":"C"},{"n":"Less","t":"Order","k":"e"},{"t":"Rational","mro":["Real","Numeric"],"d":"<p><pre><code>role Rational[::NuT, ::DeT] does Real { ... }</code></pre></p><p>Rational is the common role for numbers that are stored as pairs of numerator and denominator. It is parameterized by the types of the numerator (NuT) and denominator (DeT). By default, these are Int, but other types of Rational are possible by using a different parameterization. In addition, Rational objects are immutable throughout their life.</p><p><pre><code>class Positive does Rational[UInt] {};\nmy Positive $one-third = Positive.new(1,3);\nsay $one-third;                         # OUTPUT: «0.333333␤»\nmy Positive $fail =Positive.new(-2,3);  # OUTPUT: «Type check failed in binding to parameter 'nu'; expected UInt but got Int (-2)␤»</code></pre></p><p>Please note that, since DeT is by default equal to NuT, in this case both are instantiated to UInt. Built into Raku are Rat and FatRat, which both do the Rational role.</p>","k":"ro","a":[{"t":"NuT","k":"v","n":"$.numerator"},{"n":"$.denominator","t":"DeT","k":"v"}],"b":"C","n":"Rational","m":[{"s":{"p":[{"n":"nu?","t":"NuT"},{"n":"de?","t":"DeT"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new","d":"<p><pre><code>    method new(NuT:D $numerator, DeT:D $denominator --&gt; Rational:D)\n</code></pre></p><p>Creates a new rational object from numerator and denominator, which it normalizes to the lowest terms. The $denominator can be zero, in which case the numerator is normalized to -1, 0, or 1 depending on whether the original is negative, zero, or positive, respectively.</p>","k":"m","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"nude","k":"m","d":"<p><pre><code>method nude(Rational:D: --&gt; Positional)</code></pre></p><p>Returns a list of the numerator and denominator.</p>"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method Num(Rational:D: --&gt; Num:D)</code></pre></p><p>Coerces the invocant to Num by dividing numerator by denominator. If denominator is 0, returns Inf, -Inf, or NaN, based on whether numerator is a positive number, negative number, or 0, respectively.</p>","n":"Num","k":"m","s":{"r":"Num:D","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"n":"floor","k":"m","d":"<p>Defined as:</p><p><pre><code>method floor(Rational:D: --&gt; Int:D)</code></pre></p><p>Return the largest integer not greater than the invocant. If denominator is zero, fails with X::Numeric::DivideByZero.</p>"},{"d":"<p>Defined as:</p><p><pre><code>method ceiling(Rational:D: --&gt; Int:D)</code></pre></p><p>Return the smallest integer not less than the invocant. If denominator is zero, fails with X::Numeric::DivideByZero.</p>","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"n":"ceiling","m":0,"k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method Int(Rational:D: --&gt; Int:D)</code></pre></p><p>Coerces the invocant to Int by truncating non-whole portion of the represented number, if any. If the denominator is zero, will fail with X::Numeric::DivideByZero.</p>","m":0,"s":{"r":"Int:D","p":[{"t":"Mu","n":"*%_"}]},"n":"Int","k":"m"},{"m":0,"n":"Bridge","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"Range","k":"m","m":0},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"isNaN","d":"<p><pre><code>method isNaN(Rational:D: --&gt; Bool:D)</code></pre></p><p>Tests whether the invocant's Num value is a NaN, an acronym for Not available Number. That is both its numerator and denominator are zero.</p>"},{"k":"m","n":"is-prime","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Bool:D"}},{"s":{"p":[{"n":"$base?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method base-repeating(Rational:D: Int:D() $base = 10)</code></pre></p><p>Returns a list of two strings that, when concatenated, represent the number in base $base. The second element is the one that repeats. For example:</p><p><pre><code>my ($non-rep, $repeating) = (19/3).base-repeating(10);\nsay $non-rep;                               # OUTPUT: «6.␤»\nsay $repeating;                             # OUTPUT: «3␤»\nprintf '%s(%s)', $non-rep, $repeating;      # OUTPUT: «6.(3)»</code></pre></p><p>19/3 is 6.333333... with the 3 repeating indefinitely.</p><p>If no repetition occurs, the second string is empty:</p><p><pre><code>say (5/2).base-repeating(10).perl;          # OUTPUT: «(\"2.5\", \"\")␤»</code></pre></p><p>The precision for determining the repeating group is limited to 1000 characters, above that, the second string is ???.</p><p>$base defaults to 10.</p>","n":"base-repeating","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"succ"},{"n":"pred","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"m":0,"d":"<p><pre><code>method norm(Rational:D: --&gt; Rational:D)</code></pre></p><p>DEPRECATED as of 6.d. The method is no longer needed, because as of 6.d language version, it's required for Rational type to be normalized on creation.</p><p>Returns a normalized Rational object, i.e. with positive denominator, and numerator and denominator coprime. The denominator can also by zero, but using it in any operation or a conversion to string will result in an exception.</p><p><pre><code>use v6.c;\nmy Rational $by-zero = 3/0;\nsay $by-zero.norm.perl; # OUTPUT: «&lt;1/0&gt;␤»\n</code></pre></p><p><pre><code>say $by-zero; # OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤\n</code></pre></p>","n":"norm","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"narrow","m":0,"k":"m"},{"n":"!base","k":"m","s":{"p":[{"n":"$base","t":"Int"},{"t":"int","n":"$digits"},{"t":"int","n":"$trailing-zeroes"},{"t":"Mu","n":"*%_"}],"r":"Str:D"},"m":0},{"n":"!STRINGIFY","m":0,"s":{"p":[{"n":"whole","t":"Any"},{"n":"fract","t":"Any"},{"n":"$digits","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"}]},{"b":"A","k":"c","n":"NFC","m":[{"n":"new","k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"|"}]},"m":0},{"n":"NFC","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0}],"mro":["Stringy","Positional[uint32]","Uni"],"t":"NFC","d":"<p><pre><code>class NFC is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form C. It is created by Canonical Decomposition, followed by Canonical Composition. For more information on what this means, see Unicode TR15.</p>"},{"t":"Sub","n":"&infix:<≅>","k":"v"},{"m":1,"n":"infix:<≅>","k":"s","s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"}},{"n":"infix:<≅>","m":1,"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"},{"t":"Any","n":":$tolerance?"}],"r":"Mu"},"k":"s"},{"m":1,"n":"infix:<≅>","s":{"p":[{"t":"Num","n":"$"},{"n":"$","t":"Num"}],"r":"Mu"},"k":"s"},{"n":"infix:<≅>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Num","n":"$"},{"n":"$","t":"Num"}]}},{"m":1,"k":"s","n":"infix:<≅>","s":{"p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":[{"t":"Complex","n":"a"},{"t":"Real","n":"b"}]},"k":"s","m":1,"n":"infix:<≅>"},{"m":1,"s":{"p":[{"n":"a","t":"Real"},{"t":"Complex","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:<≅>"},{"t":"Sub","n":"&tclc","k":"v"},{"k":"s","m":1,"s":{"p":[{"n":"$s","t":"Cool"}],"r":"Mu"},"n":"tclc"},{"t":"Sub","n":"&uniprop-bool","k":"v"},{"m":1,"n":"uniprop-bool","s":{"p":[{"n":"$str","t":"Str"},{"n":"$propname","t":"Stringy"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"t":"Int","n":"$code"},{"t":"Stringy","n":"$propname"}],"r":"Mu"},"n":"uniprop-bool","k":"s"},{"n":"&set","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":[]},"k":"s","n":"set","m":1},{"n":"set","s":{"p":[{"n":"*@a","t":"Positional"}],"r":"Set:D"},"m":1,"k":"s"},{"n":"&infix:<cmp>","t":"Sub+{is-pure}+{Precedence}","k":"v","d":"<p><pre><code>multi sub infix:&lt;cmp&gt;(Any,       Any)\nmulti sub infix:&lt;cmp&gt;(Real:D,    Real:D)\nmulti sub infix:&lt;cmp&gt;(Str:D,     Str:D)\nmulti sub infix:&lt;cmp&gt;(Version:D, Version:D)</code></pre></p><p>Generic, \"smart\" three-way comparator.</p><p>Compares strings with string semantics, numbers with number semantics, Pair objects first by key and then by value etc.</p><p>if $a eqv $b, then $a cmp $b always returns Order::Same.</p><p><pre><code>say (a =&gt; 3) cmp (a =&gt; 4);   # OUTPUT: «Less␤»\nsay 4        cmp 4.0;        # OUTPUT: «Same␤»\nsay 'b'      cmp 'a';        # OUTPUT: «More␤»</code></pre></p><p>Strings are compared codepoint by codepoint; if leading codepoints are the same, the result of comparing the first differing codepoint is returned or the longer string if their lengths differ.</p><p><pre><code>\"abcd\" cmp \"abcde\"    # OUTPUT: «Less␤»\n\"abcd \" cmp \"abcde\"   # OUTPUT: «Less␤»\n'A' cmp 'Ẳ'           # OUTPUT: «Less␤»</code></pre></p>"},{"n":"infix:<cmp>","m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Real"},{"n":"b","t":"Any"}]},"k":"s","n":"infix:<cmp>"},{"s":{"p":[{"n":"a","t":"Any"},{"t":"Real","n":"b"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<cmp>"},{"n":"infix:<cmp>","m":1,"s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Real"}],"r":"Mu"},"k":"s"},{"n":"infix:<cmp>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Int"},{"t":"Rational","n":"b"}]},"m":1},{"k":"s","m":1,"n":"infix:<cmp>","s":{"r":"Mu","p":[{"t":"Rational","n":"a"},{"n":"b","t":"Int"}]}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}]}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"Mu"}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":[{"t":"Code","n":"a"},{"n":"b","t":"Code"}],"r":"Mu"}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Code"},{"t":"Any","n":"b"}]}},{"m":1,"n":"infix:<cmp>","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b","t":"Code"}]},"k":"s"},{"n":"infix:<cmp>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}],"r":"Mu"}},{"k":"s","m":1,"s":{"p":[{"t":"num","n":"$a"},{"t":"num","n":"$b"}],"r":"Mu"},"n":"infix:<cmp>"},{"k":"s","m":1,"n":"infix:<cmp>","s":{"p":[{"n":"a","t":"Blob"},{"n":"b","t":"Blob"}],"r":"Mu"}},{"n":"infix:<cmp>","s":{"p":[{"t":"Str","n":"a"},{"n":"b","t":"Str"}],"r":"Order:D"},"k":"s","m":1},{"n":"infix:<cmp>","m":1,"s":{"p":[{"t":"str","n":"$a"},{"n":"$b","t":"str"}],"r":"Order:D"},"k":"s"},{"k":"s","n":"infix:<cmp>","m":1,"s":{"p":[{"t":"Range","n":"a"},{"n":"b","t":"Range"}],"r":"Order:D"}},{"k":"s","m":1,"s":{"r":"Order:D","p":[{"t":"Real","n":"a"},{"t":"Range","n":"b"}]},"n":"infix:<cmp>"},{"s":{"p":[{"n":"a","t":"Range"},{"n":"b","t":"Real"}],"r":"Order:D"},"m":1,"k":"s","n":"infix:<cmp>"},{"n":"infix:<cmp>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Positional"},{"t":"Range","n":"b"}],"r":"Order:D"}},{"m":1,"k":"s","s":{"p":[{"t":"Range","n":"a"},{"t":"Positional","n":"b"}],"r":"Order:D"},"n":"infix:<cmp>"},{"s":{"p":[{"t":"Positional","n":"@a"},{"t":"Positional","n":"@b"}],"r":"Order:D"},"k":"s","n":"infix:<cmp>","m":1},{"n":"infix:<cmp>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Pair"},{"t":"Pair","n":"b"}]},"m":1},{"m":1,"s":{"p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}],"r":"Order:D"},"k":"s","n":"infix:<cmp>"},{"s":{"p":[{"n":"a","t":"Real"},{"n":"b","t":"Complex"}],"r":"Order:D"},"m":1,"n":"infix:<cmp>","k":"s"},{"m":1,"k":"s","n":"infix:<cmp>","s":{"r":"Order:D","p":[{"n":"a","t":"Complex"},{"n":"b","t":"Real"}]}},{"s":{"r":"Mu","p":[{"n":"$a","t":"Allomorph"},{"n":"$b","t":"Allomorph"}]},"k":"s","n":"infix:<cmp>","m":1},{"n":"infix:<cmp>","k":"s","s":{"r":"Order:D","p":[{"t":"Instant","n":"$a"},{"t":"Instant","n":"$b"}]},"m":1},{"s":{"r":"Order:D","p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}]},"n":"infix:<cmp>","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"Date","n":"$a"},{"t":"Date","n":"$b"}],"r":"Order:D"},"n":"infix:<cmp>","k":"s"},{"s":{"p":[{"t":"Version","n":"a"},{"n":"b","t":"Version"}],"r":"Mu"},"n":"infix:<cmp>","k":"s","m":1},{"m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"!default-raku","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Any","n":"name"},{"n":"c","t":"Capture"},{"t":"Any","n":":$throw?"},{"n":":$reverse?","t":"Any"},{"n":":$roles?","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!batch-call","k":"m","m":0}],"n":"IterationEnd","b":"M","k":"c","t":"Mu","mro":[]},{"k":"v","t":"Sub","n":"&ords"},{"m":1,"s":{"r":"Mu","p":[{"t":"Cool","n":"$s"}]},"k":"s","n":"ords"},{"n":"&nextsame","t":"Sub","k":"v"},{"s":{"p":[],"r":"Mu"},"m":0,"n":"nextsame","k":"s"},{"n":"&bag","k":"v","t":"Sub+{is-pure}"},{"n":"bag","m":1,"k":"s","s":{"r":"Mu","p":[]}},{"m":1,"s":{"r":"Bag:D","p":[{"n":"*@a","t":"Positional"}]},"n":"bag","k":"s"},{"k":"c","d":"<p><pre><code>class Collation { }\n</code></pre></p><p>Collation is the class that allows proper sorting, taking into account all Unicode characteristics. It's the class the object $*COLLATION is instantiated to, and thus includes collation levels, that is, what kind of features should be looked up when comparing two strings and in which order.</p>","b":"A","n":"Collation","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"gist"},{"n":"set","k":"m","m":0,"s":{"p":[{"t":"Int","n":":$primary?"},{"n":":$secondary?","t":"Int"},{"n":":$tertiary?","t":"Int"},{"t":"Int","n":":$quaternary?"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"check","k":"m","s":{"p":[{"n":"$more","t":"Any"},{"n":"$less","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"n":"primary","d":"<p>Defined as:</p><p><pre><code>method primary</code></pre></p><p>Returns the state of the primary collation level.</p>","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method secondary</code></pre></p><p>Returns the state of the secondary collation level.</p>","m":0,"n":"secondary","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"tertiary","k":"m","d":"<p>Defined as:</p><p><pre><code>method tertiary</code></pre></p><p>Returns the state of the tertiary collation level.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"quaternary"},{"n":"collation-level","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"}],"a":[{"n":"$.collation-level","t":"int","k":"v"},{"n":"$!Country","k":"v","t":"Mu"}],"t":"Collation","mro":["Any"]},{"t":"Sub","k":"v","n":"&comb"},{"n":"comb","m":1,"k":"s","s":{"p":[{"n":"$matcher","t":"Regex"},{"n":"$input","t":"Cool"},{"n":"$limit?","t":"Any"},{"n":":$match","t":"Any"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Str","n":"$matcher"},{"n":"$input","t":"Cool"},{"n":"$limit?","t":"Any"}],"r":"Mu"},"n":"comb","k":"s"},{"n":"comb","s":{"p":[{"t":"Int","n":"$size"},{"n":"$input","t":"Cool"},{"t":"Any","n":"$limit?"}],"r":"Mu"},"m":1,"k":"s"},{"t":"byte","n":"byte","k":"n"},{"d":"<p><pre><code>role Iterable { }</code></pre></p><p>Iterable serves as an API for objects that can be iterated with for and related iteration constructs, like assignment to a Positional variable.</p><p>Iterable objects nested in other Iterable objects (but not within scalar containers) flatten in certain contexts, for example when passed to a slurpy parameter (*@a), or on explicit calls to flat.</p><p>Its most important aspect is a method stub for iterator.</p><p><pre><code>class DNA does Iterable {\n    has $.chain;\n    method new ($chain where { $chain ~~ /^^ &lt;[ACGT]&gt;+ $$ / } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator(DNA:D:) {\n        $!chain.comb.rotor(3).iterator;\n    }\n}\n\nmy $a := DNA.new('GAATCC');\n.say for $a; # OUTPUT: «(G A A)␤(T C C)␤»\n</code></pre></p><p>This example mixes in the Iterable role to offer a new way of iterating over what is essentially a string (constrained by where to just the four DNA letters). In the last statement, for actually hooks to the iterator role printing the letters in groups of 3.</p>","k":"ro","t":"Iterable","mro":[],"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p>Defined as:</p><p><pre><code>method iterator(--&gt; Iterator:D)</code></pre></p><p>Method stub that ensures all classes doing the Iterable role have a method iterator.</p><p>It is supposed to return an Iterator.</p><p><pre><code>say (1..10).iterator;</code></pre></p>","k":"m","n":"iterator"},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"item"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"flat","k":"m","m":0,"d":"<p>Defined as:</p><p><pre><code>method flat(--&gt; Iterable)</code></pre></p><p>Returns another Iterable that flattens out all iterables that the first one returns.</p><p>For example</p><p><pre><code>say (&lt;a b&gt;, 'c').elems;         # OUTPUT: «2␤»\nsay (&lt;a b&gt;, 'c').flat.elems;    # OUTPUT: «3␤»</code></pre></p><p>because &lt;a b&gt;  is a List and thus iterable, so  (&lt;a b&gt;, 'c').flat  returns ('a', 'b', 'c'), which has three elems.</p><p>Note that the flattening is recursive, so (((\"a\", \"b\"), \"c\"), \"d\").flat returns (\"a\", \"b\", \"c\", \"d\"), but it does not flatten itemized sublists:</p><p><pre><code>say ($('a', 'b'), 'c').perl;    # OUTPUT: «($(\"a\", \"b\"), \"c\")␤»</code></pre></p>"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$flag"},{"n":"*%_","t":"Mu"}]},"n":"lazy-if","k":"m"},{"m":0,"d":"<p>Defined as:</p><p><pre><code>method lazy(--&gt; Iterable)</code></pre></p><p>Returns a lazy iterable wrapping the invocant.</p><p><pre><code>say (1 ... 1000).is-lazy;      # OUTPUT: «False␤»\nsay (1 ... 1000).lazy.is-lazy; # OUTPUT: «True␤»</code></pre></p>","k":"m","n":"lazy","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4)</code></pre></p><p>Returns another Iterable that is potentially iterated in parallel, with a given batch size and degree of parallelism.</p><p>The order of elements is preserved.</p><p><pre><code>say ([1..100].hyper.map({ $_ +1 }).list);</code></pre></p><p>Use hyper in situations where it is OK to do the processing of items in parallel, and the output order should be kept relative to the input order. See race for situations where items are processed in parallel and the output order does not matter.</p>","n":"hyper","m":0,"s":{"p":[{"n":":$batch?","t":"Cool"},{"t":"Cool","n":":$degree?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"race","m":0,"s":{"p":[{"t":"Cool","n":":$batch?"},{"n":":$degree?","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"}],"b":"C","n":"Iterable"},{"n":"&infix:«(<+)»","k":"v","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"n":"b","t":"QuantHash"}]},"n":"infix:«(<+)»","m":1,"k":"s"},{"n":"infix:«(<+)»","m":1,"s":{"r":"Bool:D","p":[{"t":"Mixy","n":"a"},{"t":"Baggy","n":"b"}]},"k":"s"},{"m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}]},"n":"infix:«(<+)»","k":"s"},{"m":1,"s":{"p":[{"t":"QuantHash","n":"$a"},{"n":"$b","t":"QuantHash"}],"r":"Bool"},"n":"infix:«(<+)»","k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"QuantHash","n":"$a"},{"t":"QuantHash","n":"$b"}],"r":"Bool"},"n":"infix:«(<+)»"},{"s":{"p":[{"n":"$a","t":"QuantHash"},{"n":"$b","t":"QuantHash"}],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<+)»"},{"k":"s","n":"infix:«(<+)»","m":1,"s":{"r":"Bool:D","p":[{"t":"QuantHash","n":"$a"},{"n":"$b","t":"QuantHash"}]}},{"s":{"p":[{"t":"Any","n":"$"},{"n":"$b","t":"Failure"}],"r":"Mu"},"n":"infix:«(<+)»","k":"s","m":1},{"m":1,"k":"s","n":"infix:«(<+)»","s":{"p":[{"t":"Failure","n":"$a"},{"t":"Any","n":"$"}],"r":"Mu"}},{"k":"s","s":{"r":"Bool:D","p":[{"t":"Any","n":"$a"},{"n":"$b","t":"Any"}]},"m":1,"n":"infix:«(<+)»"},{"t":"Signal","n":"SIGHUP","k":"e"},{"n":"&infix:<...^>","t":"Sub+{Precedence}","k":"v"},{"n":"infix:<...^>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Mu"}],"r":"Mu"}},{"n":"&infix:<&&>","k":"v","t":"Sub+{Precedence}"},{"k":"s","m":1,"s":{"p":[{"n":"$x?","t":"Mu"}],"r":"Mu"},"n":"infix:<&&>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"n":"&b","t":"Callable"}]},"n":"infix:<&&>","k":"s","m":1},{"k":"s","m":1,"s":{"p":[{"t":"Mu","n":"a"},{"t":"Mu","n":"b"}],"r":"Mu"},"n":"infix:<&&>"},{"n":"&append","k":"v","t":"Sub"},{"n":"append","k":"s","m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Any"},{"t":"Positional","n":"**@b"}],"r":"Mu"},"n":"append","k":"s","m":1},{"k":"v","d":"<p>The smartmatch operator aliases the left-hand side to $_, then evaluates the right-hand side and calls .ACCEPTS($_) on it. The semantics are left to the type of the right-hand side operand.</p><p>Here is a partial list of some of the built-in smartmatching functionality. For full details, see ACCEPTS documentation for the type on the right-hand side of the operator.</p><table class='sections'><tr><th>Right-hand side</th><th>Comparison semantics</th></tr>\n<tr><td>Mu:U</tr><td>type check</tr></tr>\n<tr><td>Str</tr><td>string equality</tr></tr>\n<tr><td>Numeric</tr><td>numeric equality</tr></tr>\n<tr><td>Regex</tr><td>regex match</tr></tr>\n<tr><td>Callable</tr><td>boolean result of invocation</tr></tr>\n<tr><td>Set/Bag</tr><td>equal element values</tr></tr>\n<tr><td>Any:D</tr><td>object identity</tr></tr>\n</table>","n":"&infix:<~~>","t":"Sub+{Precedence}"},{"n":"infix:<~~>","k":"s","s":{"p":[{"t":"Mu","n":"topic"},{"n":"matcher","t":"Mu"}],"r":"Mu"},"m":1},{"s":{"p":[{"t":"Mu","n":"topic"},{"n":"matcher","t":"Regex"}],"r":"Mu"},"n":"infix:<~~>","k":"s","m":1},{"k":"v","n":"&atomic-sub-fetch","t":"Sub"},{"n":"atomic-sub-fetch","s":{"p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"int"}],"r":"atomicint"},"m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"Int"}],"r":"atomicint"},"k":"s","n":"atomic-sub-fetch"},{"k":"s","n":"atomic-sub-fetch","s":{"r":"atomicint","p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"Any"}]},"m":1},{"n":"&prefix:<|>","k":"v","d":"<p>Flattens objects of type Capture, Pair, List, Map and Hash into an argument list.</p><p><pre><code>sub slurpee( |args ){\n    say args.perl\n};\nslurpee( &lt;a b c d&gt;, { e =&gt; 3 }, 'e' =&gt; 'f' =&gt; 33 )\n# OUTPUT: «\\((\"a\", \"b\", \"c\", \"d\"), {:e(3)}, :e(:f(33)))␤»</code></pre></p><p>Please see the Signature page, specially the section on Captures for more information on the subject.</p><p>Outside of argument lists, it returns a Slip, which makes it flatten into the outer list. Inside argument list Positionals are turned into positional arguments and Associatives are turned into named arguments.</p>","t":"Sub+{Precedence}"},{"m":1,"s":{"r":"Slip:D","p":[{"t":"Any","n":"x"}]},"k":"s","n":"prefix:<|>"},{"t":"Sub","n":"&subbuf-rw","k":"v"},{"n":"subbuf-rw","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Buf","n":"b"}]}},{"n":"subbuf-rw","k":"s","m":1,"s":{"p":[{"n":"b","t":"Buf"},{"t":"Any","n":"$from"}],"r":"Mu"}},{"n":"subbuf-rw","m":1,"k":"s","s":{"r":"Mu","p":[{"n":"b","t":"Buf"},{"n":"$from","t":"Any"},{"n":"$elems","t":"Any"}]}},{"b":"C","n":"tau","mro":["Real","Numeric","Cool"],"k":"c","t":"Num"},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;+&gt;($a, $b --&gt; Numeric:D)</code></pre></p><p>Addition operator.</p><p>Coerces both arguments to Numeric and adds them.</p>","n":"&infix:<+>","k":"v"},{"n":"infix:<+>","k":"s","s":{"p":[{"t":"Any","n":"$x?"}],"r":"Mu"},"m":1},{"m":1,"n":"infix:<+>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]}},{"n":"infix:<+>","k":"s","s":{"r":"Mu","p":[{"t":"Real","n":"a"},{"t":"Real","n":"b"}]},"m":1},{"k":"s","m":1,"n":"infix:<+>","s":{"p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}],"r":"Int:D"}},{"n":"infix:<+>","s":{"r":"int","p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":[{"t":"Num","n":"a"},{"n":"b","t":"Num"}],"r":"Mu"},"n":"infix:<+>"},{"n":"infix:<+>","s":{"p":[{"t":"num","n":"$a"},{"t":"num","n":"$b"}],"r":"num"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":[{"n":"r","t":"Range"},{"n":"v","t":"Real"}],"r":"Mu"},"n":"infix:<+>"},{"m":1,"k":"s","n":"infix:<+>","s":{"p":[{"t":"Real","n":"v"},{"t":"Range","n":"r"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"t":"Rational","n":"a"},{"n":"b","t":"Rational"}],"r":"Mu"},"n":"infix:<+>"},{"n":"infix:<+>","s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"t":"Int","n":"b"}]},"k":"s","m":1},{"k":"s","n":"infix:<+>","s":{"r":"Mu","p":[{"n":"a","t":"Int"},{"n":"b","t":"Rational"}]},"m":1},{"k":"s","s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}]},"n":"infix:<+>","m":1},{"n":"infix:<+>","k":"s","s":{"p":[{"n":"a","t":"Complex"},{"t":"Real","n":"b"}],"r":"Complex:D"},"m":1},{"k":"s","s":{"p":[{"t":"Real","n":"a"},{"n":"b","t":"Complex"}],"r":"Complex:D"},"m":1,"n":"infix:<+>"},{"n":"infix:<+>","k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}]},"m":1},{"n":"infix:<+>","k":"s","s":{"p":[{"n":"$a","t":"Instant"},{"t":"Real","n":"$b"}],"r":"Instant:D"},"m":1},{"m":1,"k":"s","s":{"r":"Instant:D","p":[{"n":"$a","t":"Real"},{"t":"Instant","n":"$b"}]},"n":"infix:<+>"},{"s":{"r":"Instant:D","p":[{"n":"$a","t":"Instant"},{"t":"Duration","n":"$b"}]},"n":"infix:<+>","m":1,"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Duration","n":"$a"},{"t":"Instant","n":"$b"}],"r":"Instant:D"},"n":"infix:<+>"},{"k":"s","s":{"p":[{"n":"$a","t":"Duration"},{"t":"Real","n":"$b"}],"r":"Duration:D"},"m":1,"n":"infix:<+>"},{"m":1,"s":{"p":[{"t":"Real","n":"$a"},{"n":"$b","t":"Duration"}],"r":"Duration:D"},"n":"infix:<+>","k":"s"},{"k":"s","m":1,"n":"infix:<+>","s":{"p":[{"t":"Duration","n":"$a"},{"n":"$b","t":"Duration"}],"r":"Duration:D"}},{"s":{"p":[{"n":"a","t":"DateTime"},{"t":"Duration","n":"b"}],"r":"DateTime:D"},"m":1,"k":"s","n":"infix:<+>"},{"s":{"p":[{"t":"Duration","n":"a"},{"t":"DateTime","n":"b"}],"r":"DateTime:D"},"n":"infix:<+>","k":"s","m":1},{"s":{"p":[{"t":"Date","n":"date"},{"t":"Int","n":"$x"}],"r":"Date:D"},"n":"infix:<+>","k":"s","m":1},{"k":"s","s":{"r":"Date:D","p":[{"n":"$x","t":"Int"},{"n":"date","t":"Date"}]},"m":1,"n":"infix:<+>"},{"d":"<p>Coerces the argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then flips each bit in that buffer.</p><p>Please note that this has not yet been implemented.</p>","k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<~^>"},{"n":"prefix:<~^>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"}]},"k":"s"},{"k":"s","n":"prefix:<~^>","s":{"p":[{"t":"Blob","n":"a"}],"r":"Mu"},"m":1},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Str"}],"r":"Mu"},"n":"prefix:<~^>"},{"m":[{"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"n":"from-args","k":"m","m":0},{"m":0,"k":"s","s":{"p":[{"n":":@list","t":"Positional"},{"n":":%hash","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"BUILD"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"hash","k":"m","d":"<p>Defined as:</p><p><pre><code>method hash(Capture:D:)</code></pre></p><p>Returns the named/hash part of the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples =&gt; (red =&gt; 2));\nsay $c.hash; # OUTPUT: «Map.new((:apples(:red(2))))␤»</code></pre></p>"},{"m":0,"k":"m","n":"list","d":"<p>Defined as:</p><p><pre><code>method list(Capture:D:)</code></pre></p><p>Returns the positional part of the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples =&gt; (red =&gt; 2));\nsay $c.list;                                      # OUTPUT: «(2 3 5)␤»</code></pre></p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p>Defined as:</p><p><pre><code>method elems(Capture:D: --&gt; Int:D)</code></pre></p><p>Returns the number of positional elements in the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples =&gt; (red =&gt; 2));\nsay $c.elems;                                  # OUTPUT: «3␤»</code></pre></p>","m":0,"n":"elems"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"Capture","d":"<p>Defined as:</p><p><pre><code>method Capture(Capture:D: --&gt; Capture:D)</code></pre></p><p>Returns itself, i.e. the invocant.</p><p><pre><code>say \\(1,2,3, apples =&gt; 2).Capture; # OUTPUT: «\\(1, 2, 3, :apples(2))␤»</code></pre></p>","k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL","k":"s","m":0}],"b":"A","a":[{"n":"@!list","t":"List","k":"v"},{"t":"Hash","n":"%!hash","k":"v"}],"t":"Capture","d":"<p> </p><p><pre><code>class Capture { }\n</code></pre></p><p>A Capture is a container for passing arguments to a code object. Captures are the flip-side of Signatures – Captures are the caller defined arguments, while Signatures are the callee defined parameters.</p><p>When you call print $a, $b, the $a, $b part is a Capture.</p><p>Captures contain a list-like part for positional arguments and a hash-like part for named arguments, thus behaving as Positional and Associative, although it does not actually mixes in those roles. For the named arguments, Captures use a slightly different syntax than a normal List. There are two easy ways to make a named argument: 1) use an unquoted key naming a parameter, followed by =&gt;, followed by the argument and 2) use a colon-pair literal named after the parameter:</p><p><pre><code>say unique 1, -2, 2, 3, as =&gt; { abs $_ };   # OUTPUT: «(1 -2 3)␤»\n# ... is the same thing as:\nsay unique 1, -2, 2, 3, :as({ abs $_ });    # OUTPUT: «(1 -2 3)␤»\n# Be careful not to quote the name of a named parameter:\nsay unique 1, -2, 2, 3, 'as' =&gt; { abs $_ };\n# OUTPUT: «(1 -2 2 3 as =&gt; -&gt; ;; $_? is raw { #`(Block|78857320) ... })␤»</code></pre></p><p>A stand-alone Capture can also be made, stored, and used later. A literal Capture can be created by prefixing a term with a backslash \\. Commonly, this term will be a List of terms, from which any Pair literal will be placed in the named part, and all other terms will be placed in the positional part.</p><p><pre><code>my $c = \\(42);          # Capture with one positional part\n$c = \\(1, 2, a =&gt; 'b'); # Capture with two positional and one named parts</code></pre></p><p>To use such a Capture, you may use '|' before it in a function call, and it will be as if the values in the Capture were passed directly to the function as arguments – named arguments will be passed as named arguments and positional arguments will be passed as positional arguments. You may re-use the Capture as many times as you want, even with different functions.</p><p><pre><code>my $c = \\(4, 2, 3);\nreverse(|$c).say; # OUTPUT: «3 2 4␤»\nsort(5,|$c).say;  # OUTPUT: «2 3 4 5␤»</code></pre></p><p>Inside a Signature, a Capture may be created by prefixing a sigilless parameter with a vertical bar |. This packs the remainder of the argument list into that parameter.</p><p><pre><code>f(1, 2, 3, a =&gt; 4, b =&gt; 5);\nsub f($a, |c) {\n    # c  is  \\(2, 3, a =&gt; 4, b =&gt; 5)\n}</code></pre></p><p>Note that Captures are still Lists in that they may contain containers, not just values:</p><p><pre><code>my $b = 1;\nmy $c = \\(4, 2, $b, 3);\nsort(|$c).say;        # OUTPUT: «1 2 3 4␤»\n$b = 6;\nsort(|$c).say;        # OUTPUT: «2 3 4 6␤»</code></pre></p>","k":"c","n":"Capture","mro":["Any"]},{"n":"&log10","t":"Sub+{is-pure}","k":"v"},{"m":1,"s":{"r":"Mu","p":[{"n":"$x","t":"Numeric"}]},"k":"s","n":"log10"},{"n":"log10","m":1,"s":{"p":[{"n":"$x","t":"Cool"}],"r":"Mu"},"k":"s"},{"t":"Sub","k":"v","n":"&callsame"},{"m":0,"k":"s","s":{"p":[],"r":"Mu"},"n":"callsame"},{"n":"&unpolar","t":"Sub","k":"v"},{"s":{"p":[{"n":"$mag","t":"Real"},{"n":"$angle","t":"Real"}],"r":"Mu"},"k":"s","m":1,"n":"unpolar"},{"t":"Code","n":"Code","k":"c","a":[{"t":"Code","k":"v","n":"$!do"},{"n":"$!signature","t":"Signature","k":"v"},{"n":"@!compstuff","t":"List","k":"v"}],"m":[{"k":"m","n":"is-implementation-detail","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"}},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"arity","d":"<p>Defined as:</p><p><pre><code>method arity(Code:D: --&gt; Int:D)</code></pre></p><p>Returns the minimum number of positional arguments that must be passed in order to call the code object. Any optional or slurpy parameters in the code object's Signature do not contribute, nor do named parameters.</p><p><pre><code>sub argless() { }\nsub args($a, $b?) { }\nsub slurpy($a, $b, *@c) { }\nsay &amp;argless.arity;             # OUTPUT: «0␤»\nsay &amp;args.arity;                # OUTPUT: «1␤»\nsay &amp;slurpy.arity;              # OUTPUT: «2␤»</code></pre></p>"},{"d":"<p>Defined as:</p><p><pre><code>method count(Code:D: --&gt; Real:D)</code></pre></p><p>Returns the maximum number of positional arguments that may be passed when calling the code object. For code objects that can accept any number of positional arguments (that is, they have a slurpy parameter), count will return Inf. Named parameters do not contribute.</p><p><pre><code>sub argless() { }\nsub args($a, $b?) { }\nsub slurpy($a, $b, *@c) { }\nsay &amp;argless.count;             # OUTPUT: «0␤»\nsay &amp;args.count;                # OUTPUT: «2␤»\nsay &amp;slurpy.count;              # OUTPUT: «Inf␤»</code></pre></p>","n":"count","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"signature","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method signature(Code:D: --&gt; Signature:D)</code></pre></p><p>Returns the Signature object for this code object, which describes its parameters.</p><p><pre><code>sub a(Int $one, Str $two) {};\nsay &amp;a.signature; # OUTPUT: «(Int $one, Str $two)␤»</code></pre></p>","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"$c","t":"Capture"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method cando(Capture $c)</code></pre></p><p>Returns a list of candidates that can be called with the given Capture. Since Code objects do not have any multiple dispatch, this either returns a list with the object, or an empty list.</p><p><pre><code>my $single = \\'a';         # a single argument Capture\nmy $plural = \\('a', 42);   # a two argument Capture\nmy &amp;block = { say $^a };   # a Block object, that is a subclass of Code, taking one argument\nsay &amp;block.cando($single); # OUTPUT: «(-&gt; $a { #`(Block|94212856419136) ... })␤»\nsay &amp;block.cando($plural); # OUTPUT: «()␤»</code></pre></p>","m":0,"n":"cando"},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":1,"n":"prec"},{"s":{"p":[{"n":"$","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"prec","m":1,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"outer"},{"k":"m","n":"static_id","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"file","k":"m","d":"<p>Defined as:</p><p><pre><code>method file(Code:D: --&gt; Str:D)</code></pre></p><p>Returns the name of the file in which the code object was declared.</p><p><pre><code>say &amp;infix:&lt;+&gt;.file;</code></pre></p>"},{"n":"line","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"primers"}],"r":"Mu"},"n":"assuming","d":"<p><pre><code>method assuming(Callable:D $self: |primers)</code></pre></p><p>Returns a Callable that implements the same behavior as the original, but has the values passed to .assuming already bound to the corresponding parameters.</p><p><pre><code>my sub slow($n){ my $i = 0; $i++ while $i &lt; $n; $i };\n\n# takes only one parameter and as such wont forward $n\nsub bench(&amp;c){ c, now - ENTER now };\n\nsay &amp;slow.assuming(10000000).&amp;bench; # OUTPUT: «(10000000 7.5508834)␤»</code></pre></p><p>For a sub with arity greater than one, you can use Whatever * for all of the positional parameters that are not \"assumed\".</p><p><pre><code>sub first-and-last ( $first, $last ) {\n    say \"Name is $first $last\";\n}\n\nmy &amp;surname-smith = &amp;first-and-last.assuming( *, 'Smith' );\n\n&amp;surname-smith.( 'Joe' ); # OUTPUT: «Name is Joe Smith␤»</code></pre></p><p>You can handle any combination of assumed and not assumed positional parameters:</p><p><pre><code>sub longer-names ( $first, $middle, $last, $suffix ) {\n    say \"Name is $first $middle $last $suffix\";\n}\n\nmy &amp;surname-public = &amp;longer-names.assuming( *, *, 'Public', * );\n\n&amp;surname-public.( 'Joe', 'Q.', 'Jr.'); # OUTPUT: «Name is Joe Q. Public Jr.␤»\n</code></pre></p><p>Named parameters can be assumed as well:</p><p><pre><code>sub foo { say \"$^a $^b $:foo $:bar\" }\n&amp;foo.assuming(13, :42foo)(24, :72bar); # OUTPUT: «13 24 42 72␤»</code></pre></p><p>And you can use .assuming on all types of Callables, including Methods and Blocks:</p><p><pre><code># We use a Whatever star for the invocant:\nmy &amp;comber = Str.^lookup('comb').assuming: *, /P \\w+/;\nsay comber 'Perl is awesome! Python is great! And PHP is OK too';\n# OUTPUT: «(Perl Python PHP)␤»\n\nmy &amp;learner = {\n    \"It took me $:months months to learn $^lang\"\n}.assuming: 'Raku';\nsay learner :6months;  # OUTPUT: «It took me 6 months to learn Raku␤»</code></pre></p>"}],"d":"<p><pre><code>class Code is Any does Callable {}</code></pre></p><p>Code is the ultimate base class of all code objects in Raku. It exposes functionality that all code objects have. While thunks are directly of type Code, most code objects (such as those resulting from blocks, subroutines or methods) will belong to some subclass of Code.</p>","mro":["Callable","Any"],"b":"A"},{"n":"&proceed","k":"v","t":"Sub+{Callable[Nil]}"},{"n":"proceed","m":0,"s":{"p":[],"r":"Nil"},"k":"s"},{"k":"v","d":"<p><pre><code>sub infix:&lt;does&gt;(Mu $obj, Mu $role) is assoc&lt;non&gt;</code></pre></p><p>Mixes $role into $obj at runtime. Requires $obj to be mutable.</p><p>Similar to but operator, the $role can instead be an instantiated object, in which case, the operator will create a role for you automatically. The role will contain a single method named the same as $obj.^name and that returns $obj:</p><p><pre><code>my $o = class { method Str { \"original\" } }.new;\nput $o;            # OUTPUT: «original␤»\n$o does \"modded\";\nput $o;            # OUTPUT: «modded␤»</code></pre></p><p>If methods of the same name are present already, the last mixed in role takes precedence.</p>","t":"Sub+{Precedence}","n":"&infix:<does>"},{"s":{"p":[{"t":"Mu","n":"obj"},{"n":"rolish","t":"Mu"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<does>"},{"m":1,"k":"s","n":"infix:<does>","s":{"r":"Mu","p":[{"n":"obj","t":"Mu"},{"n":"rolish","t":"Mu"},{"n":":$value!","t":"Any"}]}},{"s":{"r":"Mu","p":[{"n":"obj","t":"Mu"},{"n":"role","t":"Mu"},{"t":"Associative","n":"*%_"}]},"k":"s","m":1,"n":"infix:<does>"},{"s":{"r":"Mu","p":[{"n":"obj","t":"Mu"},{"t":"Positional","n":"**@roles"}]},"k":"s","m":1,"n":"infix:<does>"},{"m":1,"k":"s","s":{"p":[{"n":"obj","t":"Mu"},{"t":"Positional","n":"**@roles"}],"r":"Mu"},"n":"infix:<does>"},{"n":"&min","k":"v","t":"Sub+{is-pure}"},{"k":"s","n":"min","s":{"p":[{"t":"Any","n":"+args"},{"n":":&by!","t":"Callable"}],"r":"Mu"},"m":1},{"k":"s","n":"min","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"+args"}]}},{"k":"v","t":"Sub","n":"&univals"},{"m":1,"k":"s","n":"univals","s":{"p":[{"t":"Str","n":"$str"}],"r":"Mu"}},{"t":"Sub","k":"v","n":"&trait_mod:<trusts>"},{"s":{"p":[{"t":"Mu","n":"$truster"},{"n":"$trustee","t":"Mu"}],"r":"Mu"},"m":1,"n":"trait_mod:<trusts>","k":"s"},{"n":"&infix:«~>»","k":"v","t":"Sub"},{"s":{"p":[{"t":"Str","n":"a"},{"t":"Int","n":"b"}],"r":"Mu"},"n":"infix:«~>»","k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"str"},{"n":"$b","t":"int"}]},"n":"infix:«~>»"},{"n":"&chr","k":"v","t":"Sub+{is-pure}"},{"k":"s","n":"chr","m":1,"s":{"p":[{"n":"x","t":"Int"}],"r":"Str:D"}},{"s":{"p":[{"n":"x","t":"Cool"}],"r":"Str:D"},"n":"chr","m":1,"k":"s"},{"m":1,"n":"chr","s":{"r":"str","p":[{"n":"$x","t":"int"}]},"k":"s"},{"k":"v","t":"Sub","n":"&unshift"},{"s":{"r":"Mu","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"n":"unshift","m":1,"k":"s"},{"s":{"p":[{"n":"a","t":"Any"},{"n":"*@b","t":"Positional"}],"r":"Mu"},"k":"s","m":1,"n":"unshift"},{"k":"v","t":"Sub+{is-pure}","n":"&minmax"},{"m":1,"n":"minmax","s":{"p":[{"n":"+args","t":"Any"},{"t":"Callable","n":":&by!"}],"r":"Mu"},"k":"s"},{"n":"minmax","m":1,"s":{"r":"Mu","p":[{"n":"+args","t":"Any"}]},"k":"s"},{"k":"v","t":"Sub","n":"&dir"},{"n":"dir","k":"s","m":1,"s":{"p":[{"t":"Any","n":"$path"},{"t":"Any","n":":$test!"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"$path","t":"Any"}],"r":"Mu"},"n":"dir"},{"m":1,"n":"dir","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":":$test!"}]}},{"k":"s","s":{"p":[],"r":"Mu"},"n":"dir","m":1},{"t":"Sub","k":"v","n":"&atomic-assign"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$target"},{"t":"Any","n":"value"}]},"m":1,"k":"s","n":"atomic-assign"},{"s":{"r":"Mu","p":[{"t":"atomicint","n":"$target"},{"n":"$value","t":"int"}]},"n":"atomic-assign","m":1,"k":"s"},{"k":"s","s":{"r":"Mu","p":[{"t":"atomicint","n":"$target"},{"n":"$value","t":"Int"}]},"m":1,"n":"atomic-assign"},{"s":{"r":"Mu","p":[{"n":"$target","t":"atomicint"},{"n":"$value","t":"Any"}]},"n":"atomic-assign","m":1,"k":"s"},{"t":"Sub","n":"&symlink","k":"v"},{"m":1,"n":"symlink","s":{"r":"Mu","p":[{"n":"$target","t":"Any"},{"t":"Any","n":"$name"}]},"k":"s"},{"n":"SOCK_SEQPACKET","k":"e","t":"SocketType"},{"n":"&permutations","k":"v","t":"Sub"},{"n":"permutations","k":"s","s":{"p":[{"n":"n","t":"Any"}],"r":"Seq:D"},"m":1},{"k":"s","m":1,"s":{"r":"Seq:D","p":[{"n":"n","t":"Iterable"}]},"n":"permutations"},{"k":"v","t":"Sub+{is-pure}","n":"&max"},{"k":"s","m":1,"n":"max","s":{"r":"Mu","p":[{"t":"Any","n":"+args"},{"n":":&by!","t":"Callable"}]}},{"n":"max","k":"s","m":1,"s":{"r":"Mu","p":[{"n":"+args","t":"Any"}]}},{"mro":["Rakudo::Internals::ImplementationDetail","Callable","Any"],"n":"ForeignCode","a":[{"t":"Code","n":"$!do","k":"v"}],"m":[{"d":"<p><pre><code>method arity()</code></pre></p><p>Returns the arity of the enclosed code.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"arity"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method count()</code></pre></p><p>Returns the number of arguments the enclosed code needs.</p>","k":"m","m":0,"n":"count"},{"d":"<p><pre><code>method signature( ForeignCode:D: )</code></pre></p><p>Returns the signature of the enclosed code.</p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"signature"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method name()</code></pre></p><p>Returns the name of the enclosed code, or &lt;anon&gt; if it has not received any.</p>","k":"m","n":"name"}],"t":"ForeignCode","k":"c","b":"A","d":"<p><pre><code>class ForeignCode does Callable {}</code></pre></p><p>This is a Rakudo specific class, and as such it is advisable not to use it in your own code, since its interface might change or even disappear in the future. This is provided here only as a reference</p><p>ForeignCode is a Raku wrapper around code that is not written originally in that language; its intention is to use these blocks of code in Callable contexts easily. For instance, subs have some anonymous functions that are actually ForeignCode.</p><p><pre><code>sub does-nothing(){};\nsay $_.name ~ ' → ' ~ $_.^name for &amp;does-nothing.^methods;\n# OUTPUT: «&lt;anon&gt; → ForeignCode␤&lt;anon&gt; → ForeignCode␤soft → Method␤…»\n</code></pre></p><p>This script will map method names to their class, and it shows that routines, in particular, have several methods that are actually ForeignCode instead of Methods.</p>"},{"m":[{"m":0,"n":"TWEAK","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"k":"s"},{"n":"cur-sep","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"release"},{"d":"<p>Instance method returning a Bool indicating whether the distribution is a version of the Windows operating system.</p>","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"is-win","k":"m"},{"m":0,"d":"<p>Instance method returning the string that can be used to delimit elements in a path specification.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"path-sep","k":"m"},{"n":"name","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"auth","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"version","m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"signature"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"desc","m":0,"k":"m"},{"m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"b":"A","n":"Distro","mro":["Systemic","Any"],"d":"<p><pre><code>class Distro does Systemic { }</code></pre></p><p>Built-in class for providing distribution related information. Usually accessed through the $*DISTRO dynamic variable.</p>","k":"c","t":"Distro","a":[{"k":"v","t":"Str","n":"$.release"},{"t":"Bool","n":"$.is-win","k":"v"},{"t":"Str","k":"v","n":"$.path-sep"},{"t":"Str","k":"v","n":"$.name"},{"t":"Str","k":"v","n":"$.auth"},{"n":"$.version","t":"Version","k":"v"},{"t":"Blob","k":"v","n":"$.signature"},{"n":"$.desc","k":"v","t":"Str"}]},{"k":"e","t":"SocketType","n":"SOCK_MAX"},{"n":"uint16","k":"n","t":"uint16"},{"k":"v","t":"Sub","n":"&reduce"},{"m":1,"s":{"p":[{"n":"&with","t":"Callable"},{"t":"Any","n":"+list"}],"r":"Mu"},"n":"reduce","k":"s"},{"t":"Signal","n":"SIGSEGV","k":"e"},{"n":"&infix:<^..>","d":"<p><pre><code>multi sub infix:&lt;^..&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</code></pre></p><p>Left-open range operator.</p><p>Constructs a Range from the arguments, excluding the start point.</p>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"$min"},{"t":"Any","n":"$max"}]},"m":1,"n":"infix:<^..>"},{"k":"e","t":"FileChangeEvent","n":"FileChangeEvent"},{"t":"FileChangeEvent","k":"e","n":"FileChangeEvent::FileRenamed"},{"n":"FileChangeEvent::FileChanged","k":"e","t":"FileChangeEvent"},{"n":"Planned","k":"e","t":"PromiseStatus"},{"k":"c","b":"A","mro":["Any"],"a":[{"k":"v","t":"IO::Pipe","n":"$.in"},{"t":"IO::Pipe","k":"v","n":"$.out"},{"t":"IO::Pipe","n":"$.err","k":"v"},{"n":"$.exitcode","t":"Mu","k":"v"},{"t":"Mu","n":"$.signal","k":"v"},{"n":"$.pid","t":"Mu","k":"v"},{"t":"Positional","k":"v","n":"@.command"},{"t":"Proc::Async","k":"v","n":"$!proc"},{"t":"Bool","n":"$!w","k":"v"},{"n":"@!pre-spawn","k":"v","t":"Positional"},{"t":"Positional","n":"@!post-spawn","k":"v"},{"t":"Mu","n":"$!active-handles","k":"v"},{"n":"&!start-stdout","t":"Callable","k":"v"},{"t":"Callable","k":"v","n":"&!start-stderr"},{"k":"v","n":"$!finished","t":"Mu"}],"t":"Proc","m":[{"m":0,"n":"BUILD","k":"s","s":{"p":[{"n":":$in?","t":"Any"},{"t":"Any","n":":$out?"},{"n":":$err?","t":"Any"},{"t":"Any","n":":$exitcode"},{"n":":$bin","t":"Bool"},{"n":":$chomp?","t":"Bool"},{"n":":$merge","t":"Bool"},{"n":":$command","t":"Any"},{"t":"Str","n":":$enc"},{"t":"Str","n":":$nl?"},{"n":":$signal","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"d":"<p><pre><code>method spawn(*@args ($, *@), :$cwd = $*CWD, Hash() :$env = %*ENV --&gt; Bool:D)</code></pre></p><p>Runs the Proc object with the given command, argument list, working directory, and environment.</p>","m":0,"s":{"p":[{"t":"Positional","n":"*@args"},{"n":":$cwd?","t":"Any"},{"n":":$env","t":"Any"},{"n":":$win-verbatim-args?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"spawn","k":"m"},{"m":0,"d":"<p><pre><code>method shell($cmd, :$cwd = $*CWD, :$env --&gt; Bool:D)</code></pre></p><p>Runs the Proc object with the given command and environment which are passed through to the shell for parsing and execution. See shell for an explanation of which shells are used by default in the most common operating systems.</p>","k":"m","s":{"p":[{"t":"Any","n":"$cmd"},{"n":":$cwd?","t":"Any"},{"n":":$env","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"n":"shell"},{"s":{"p":[{"n":"$new_status","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"status","k":"m","m":1},{"n":"status","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":1},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method exitcode(Proc:D: --&gt; Int:D)</code></pre></p><p>Returns the exit code of the external process, or -1 if it has not exited yet.</p>","n":"exitcode","m":0,"k":"m"},{"n":"signal","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"n":"sink","k":"m","d":"<p>Defined as:</p><p><pre><code>method sink(--&gt; Nil)</code></pre></p><p>When sunk, the Proc object will throw X::Proc::Unsuccessful if the process it ran exited unsuccessfully.</p><p><pre><code>shell 'ls /qqq';\n# OUTPUT: «(exit code 1) ls: cannot access '/qqq': No such file or directory␤The spawned command 'ls /qqq' exited unsuccessfully (exit code: 2)␤\nn block &lt;unit&gt; at /tmp/3169qXElwq line 1␤␤»\n</code></pre></p>","m":0,"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"in"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"out"},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"err","k":"m"},{"d":"<p><pre><code>method pid()</code></pre></p><p>Returns the PID value of the process if available, or Nil.</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"pid"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"command","m":0,"k":"m","d":"<p><pre><code>method command(Proc:D: --&gt; List:D)</code></pre></p><p>The command method is an accessor to a list containing the arguments that were passed when the Proc object was executed via spawn or shell or run.</p>"},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s","n":"BUILDALL"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"n":"!wait-for-finish","k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"!status"},{"m":0,"s":{"p":[{"t":"Positional","n":"@args"},{"t":"Any","n":"$cwd"},{"t":"Any","n":"$env"},{"t":"Any","n":":$win-verbatim-args"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"!spawn-internal","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"!await-if-last-handle","m":0},{"n":"!set-status","k":"m","m":0,"s":{"p":[{"n":"$new_status","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"n":"Proc","d":"<p><pre><code>class Proc {}</code></pre></p><p>Proc is a representation of an invocation of an external process. It provides access to the input, output and error stream as well as the exit code. It is typically created through the run subroutine:</p><p><pre><code>my $proc = run 'echo', 'Hallo world', :out;\nmy $captured-output = $proc.out.slurp: :close;\nsay \"Output was $captured-output.perl()\";# OUTPUT: «Output was \"Hallo world\\n\"␤»\n</code></pre></p><p>Piping several commands is easy too. To achieve the equivalent of the pipe echo \"Hello, world\" | cat -n in Raku, and capture the output from the second command, you can do</p><p><pre><code>my $p1 = run 'echo', 'Hello, world', :out;\nmy $p2 = run 'cat', '-n', :in($p1.out), :out;\nsay $p2.out.get;\n</code></pre></p><p>You can also feed the :in (standard input) pipe directly from your program, by setting it to True, which will make the pipe available via .in method on the Proc:</p><p><pre><code>my $p = run \"cat\", \"-n\", :in, :out;\n$p.in.say: \"Hello,\\nworld!\";\n$p.in.close;\nsay $p.out.slurp: :close;\n# OUTPUT: «1  Hello,␤\n#          2  world!␤»\n</code></pre></p><p>In order to capture the standard error, :err can be supplied:</p><p><pre><code>my $p = run \"ls\", \"-l\", \".\", \"qqrq\", :out, :err;\nmy $captured-output = $p.out.slurp: :close;\nmy $captured-error  = $p.err.slurp: :close;\nmy $exit-code       = $p.exitcode;\n</code></pre></p><p>In sink context, a Proc will call its sink method, throwing an exception if the process has exited with an exit code different from zero:</p><p><pre><code>shell 'exit 1'\n# OUTPUT: «(exit code 1) The spawned command 'exit 1' exited unsuccessfully (exit code: 1)␤»\n</code></pre></p><p>Note: Versions of Rakudo older than 2017.04 do not have .slurp available on IO::Pipe objects; use .slurp-rest instead.</p><p>Use Proc::Async for non-blocking operations.</p>"},{"m":[{"n":"new","m":1,"k":"m","d":"<p><pre><code>multi method new(*@ ($path, *@args), :$w, :$enc, :$translate-nl --&gt; Proc::Async:D)\nmulti method new(   :$path, :@args,  :$w, :$enc, :$translate-nl --&gt; Proc::Async:D)</code></pre></p><p>Creates a new Proc::Async object with external program name or path $path and the command line arguments @args.</p><p>If :w is passed to new, then a pipe to the external program's standard input stream (stdin) is opened, to which you can write with write and say.</p><p>The :enc specifies the encoding for streams (can still be overridden in individual methods) and defaults to utf8.</p><p>If :translate-nl is set to True (default value), OS-specific newline terminators (e.g. \\r\\n on Windows) will be automatically translated to \\n.</p>","s":{"r":"Mu","p":[{"n":"*@args","t":"Positional"},{"t":"Mu","n":"*%_"}]}},{"n":"TWEAK","m":0,"k":"s","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"s":{"p":[{"n":":$bin!","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method stdout(Proc::Async:D: :$bin --&gt; Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard output stream. If :bin is passed, the standard output is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stdout.tap( -&gt; $str {\n    say \"Got output '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stdout before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stdout is not called, the external program's standard output is not captured at all.</p><p>Note that you cannot call stdout both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","m":1,"n":"stdout","k":"m"},{"d":"<p><pre><code>method stdout(Proc::Async:D: :$bin --&gt; Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard output stream. If :bin is passed, the standard output is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stdout.tap( -&gt; $str {\n    say \"Got output '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stdout before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stdout is not called, the external program's standard output is not captured at all.</p><p>Note that you cannot call stdout both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","n":"stdout","m":1,"s":{"p":[{"n":":$enc","t":"Any"},{"n":":$translate-nl","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"stderr","d":"<p><pre><code>method stderr(Proc::Async:D: :$bin --&gt; Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard error stream. If :bin is passed, the standard error is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stderr.tap( -&gt; $str {\n    say \"Got error '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stderr before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stderr is not called, the external program's standard error stream is not captured at all.</p><p>Note that you cannot call stderr both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","k":"m","m":1,"s":{"p":[{"n":":$bin!","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p><pre><code>method stderr(Proc::Async:D: :$bin --&gt; Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard error stream. If :bin is passed, the standard error is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stderr.tap( -&gt; $str {\n    say \"Got error '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stderr before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stderr is not called, the external program's standard error stream is not captured at all.</p><p>Note that you cannot call stderr both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","s":{"r":"Mu","p":[{"t":"Any","n":":$enc"},{"n":":$translate-nl","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"stderr","m":1},{"k":"m","s":{"r":"Mu","p":[{"n":":$bin!","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"Supply","d":"<p><pre><code>multi method Supply(Proc::Async:D: :$bin!)\nmulti method Supply(Proc::Async:D: :$enc, :$translate-nl)</code></pre></p><p>Returns a Supply of merged stdout and stderr streams. If :$bin named argument is provided, the Supply will be binary, producing Buf objects, otherwise, it will be in character mode, producing Str objects and :$enc named argument can specify encoding to use. The :$translate-nl option specifies whether new line endings should be translated for to match those used by the current operating system (e.g. \\r\\n on Windows).</p><p><pre><code>react {\n    with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n        whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n        whenever .start {}\n    }\n}\n</code></pre></p><p>It is an error to create both binary and non-binary .Supply. It is also an error to use both .Supply and either stderr or stdout supplies.</p>","m":1},{"k":"m","s":{"p":[{"t":"Any","n":":$enc"},{"t":"Any","n":":$translate-nl"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>multi method Supply(Proc::Async:D: :$bin!)\nmulti method Supply(Proc::Async:D: :$enc, :$translate-nl)</code></pre></p><p>Returns a Supply of merged stdout and stderr streams. If :$bin named argument is provided, the Supply will be binary, producing Buf objects, otherwise, it will be in character mode, producing Str objects and :$enc named argument can specify encoding to use. The :$translate-nl option specifies whether new line endings should be translated for to match those used by the current operating system (e.g. \\r\\n on Windows).</p><p><pre><code>react {\n    with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n        whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n        whenever .start {}\n    }\n}\n</code></pre></p><p>It is an error to create both binary and non-binary .Supply. It is also an error to use both .Supply and either stderr or stdout supplies.</p>","m":1,"n":"Supply"},{"d":"<p><pre><code>multi method bind-stdin(IO::Handle:D $handle)\nmulti method bind-stdin(Proc::Async::Pipe:D $pipe)</code></pre></p><p>Sets a handle (which must be opened) or a Pipe as a source of STDIN. The STDIN of the target process must be writable or X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"cat\", :in);\nmy $h = \"/etc/profile\".IO.open;\n$p.bind-stdin($h);\n$p.start;</code></pre></p><p>This is equivalent to</p><p><pre><code>cat &lt; /etc/profile\n</code></pre></p><p>and will print the content of /etc/profile to standard output.</p>","s":{"p":[{"t":"IO::Handle","n":"$handle"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"bind-stdin","m":1,"k":"m"},{"d":"<p><pre><code>multi method bind-stdin(IO::Handle:D $handle)\nmulti method bind-stdin(Proc::Async::Pipe:D $pipe)</code></pre></p><p>Sets a handle (which must be opened) or a Pipe as a source of STDIN. The STDIN of the target process must be writable or X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"cat\", :in);\nmy $h = \"/etc/profile\".IO.open;\n$p.bind-stdin($h);\n$p.start;</code></pre></p><p>This is equivalent to</p><p><pre><code>cat &lt; /etc/profile\n</code></pre></p><p>and will print the content of /etc/profile to standard output.</p>","m":1,"s":{"p":[{"n":"$pipe","t":"Proc::Async::Pipe"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"bind-stdin","k":"m"},{"m":0,"s":{"p":[{"n":"$handle","t":"IO::Handle"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m","d":"<p><pre><code>method bind-stdout(IO::Handle:D $handle)</code></pre></p><p>Redirects STDOUT of the target process to a handle (which must be opened). If STDOUT is closed X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"ls\", :out);\nmy $h = \"ls.out\".IO.open(:w);\n$p.bind-stdout($h);\n$p.start;</code></pre></p><p>This program will pipe the output of the ls shell command to a file called ls.out, which we are opened for reading.</p>","n":"bind-stdout"},{"k":"m","d":"<p><pre><code>method bind-stderr(IO::Handle:D $handle)</code></pre></p><p>Redirects STDERR of the target process to a handle (which must be opened). If STDERR is closed X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"ls\", \"--foo\", :err);\nmy $h = \"ls.err\".IO.open(:w);\n$p.bind-stderr($h);\n$p.start;</code></pre></p>","s":{"p":[{"n":"$handle","t":"IO::Handle"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"n":"bind-stderr","m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Promise"},"n":"ready","k":"m","d":"<p><pre><code>method ready(Proc::Async:D: --&gt; Promise:D)</code></pre></p><p>Returns a Promise that will be kept once the process has successfully started. Promise will be broken if the program fails to start.</p><p>Implementation-specific note: Starting from Rakudo 2018.04, the returned promise will hold the process id (PID).</p>"},{"d":"<p><pre><code>method pid(Proc::Async:D: --&gt; Promise:D)</code></pre></p><p>Equivalent to ready.</p><p>Returns a Promise that will be kept once the process has successfully started. Promise will be broken if the program fails to start. Returned promise will hold the process id (PID).</p><p>Implementation-specific note: Available starting from Rakudo 2018.04.</p>","m":0,"n":"pid","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Promise"}},{"n":"start","m":0,"k":"m","d":"<p><pre><code>method start(Proc::Async:D: :$scheduler = $*SCHEDULER, :$ENV, :$cwd = $*CWD)</code></pre></p><p>Initiates spawning of the external program. Returns a Promise that will be kept with a Proc object once the external program exits or broken if the program cannot be started. Optionally, you can use a scheduler instead of the default $*SCHEDULER, or change the environment the process is going to run in via the named argument :$ENV or the directory via the named argument :$cwd.</p><p>If start is called on a Proc::Async object on which it has already been called before, an exception of type X::Proc::Async::AlreadyStarted is thrown.</p><p>Note: If you wish to await the Promise and discard its result, using</p><p><pre><code>try await $p.start;\n</code></pre></p><p>will throw if the program exited with non-zero status, as the Proc returned as the result of the Promise throws when sunk and in this case it will get sunk outside the try. To avoid that, sink it yourself inside the try:</p><p><pre><code>try sink await $p.start;\n</code></pre></p>","s":{"p":[{"t":"Any","n":":$scheduler?"},{"n":":$ENV","t":"Any"},{"t":"Any","n":":$cwd?"},{"n":"*%_","t":"Mu"}],"r":"Promise"}},{"s":{"r":"Mu","p":[{"n":"$str","t":"Any"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method print(Proc::Async:D: Str(Any) $str, :$scheduler = $*SCHEDULER)</code></pre></p><p>Write the text data in $str to the standard input stream of the external program, encoding it as UTF-8.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method print, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","m":0,"k":"m","n":"print"},{"m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"x"},{"n":"c","t":"Any"}]},"n":"put","k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"x","t":"Any"},{"n":"c","t":"Any"}]},"d":"<p><pre><code>method say(Proc::Async:D: $output, :$scheduler = $*SCHEDULER)</code></pre></p><p>Calls method gist on the $output, adds a newline, encodes it as UTF-8, and sends it to the standard input stream of the external program, encoding it as UTF-8.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method say, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","n":"say"},{"k":"m","n":"write","d":"<p><pre><code>method write(Proc::Async:D: Blob:D $b, :$scheduler = $*SCHEDULER --&gt; Promise:D)</code></pre></p><p>Write the binary data in $b to the standard input stream of the external program.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method write, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","s":{"p":[{"n":"$b","t":"Blob"},{"n":":$scheduler?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"m":0,"n":"close-stdin","d":"<p><pre><code>method close-stdin(Proc::Async:D: --&gt; True)</code></pre></p><p>Closes the standard input stream of the external program. Programs that read from STDIN often only terminate when their input stream is closed. So if waiting for the promise from #method start hangs (for a program opened for writing), it might be a forgotten close-stdin.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method close-stdin, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>"},{"s":{"r":"Mu","p":[{"t":"Signal","n":"signal?"},{"n":"*%_","t":"Mu"}]},"m":1,"n":"kill","k":"m"},{"k":"m","m":1,"s":{"p":[{"t":"Int","n":"signal"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"kill"},{"m":1,"n":"kill","s":{"r":"Mu","p":[{"t":"Str","n":"signal"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"path","k":"m","d":"<p><pre><code>method path(Proc::Async:D:)</code></pre></p><p>Deprecated as of v6.d. Use command instead.</p><p>Returns the name and/or path of the external program that was passed to the new method as first argument.</p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"d":"<p><pre><code>method args(Proc::Async:D: --&gt; Positional:D)</code></pre></p><p>Deprecated as of v6.d. Use command instead.</p><p>Returns the command line arguments for the external programs, as passed to the new method.</p>","m":0,"n":"args","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p><pre><code>method command(Proc::Async:D: --&gt; List:D)</code></pre></p><p>Available as of v6.d.</p><p>Returns the command and arguments used for this Proc::Async object:</p><p><pre><code>my $p := Proc::Async.new: 'cat', 'some', 'files';\n$p.command.say; # OUTPUT: «(cat some files)␤»</code></pre></p>","m":0,"n":"command","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"n":"w","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method w(Proc::Async:D:)</code></pre></p><p>Returns a true value if :w was passed to the constructor, that is, if the external program is started with its input stream made available to output to the program through the .print, .say and .write methods.</p>"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"enc","k":"m","m":0},{"n":"translate-nl","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"win-verbatim-args","m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"d":"<p><pre><code>method started(Proc::Async:D: --&gt; Bool:D)</code></pre></p><p>Returns False before .start has been called, and True afterwards.</p>","n":"started"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"s"},{"m":0,"s":{"r":"Mu","p":[{"t":"Positional","n":"*@args"},{"t":"Mu","n":"*%_"}]},"n":"!win-quote-CommandLineToArgvW","k":"m"},{"m":0,"n":"!capture","k":"m","s":{"p":[{"n":"callbacks","t":"Any"},{"n":"std","t":"Any"},{"t":"Any","n":"the-supply"},{"n":"*%_","t":"Mu"}],"r":"Promise"}},{"n":"!start-internal","s":{"r":"Promise","p":[{"n":"$scheduler","t":"Any"},{"n":"$ENV","t":"Any"},{"t":"Any","n":"$cwd"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"m":0,"k":"m","n":"!pipe-cbs","s":{"p":[{"n":"channel","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"!pipe","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"what"},{"n":"the-supply","t":"Any"},{"n":"type","t":"Any"},{"t":"Any","n":"value"},{"n":"fd-vow","t":"Any"},{"n":"permit-channel","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Supply","n":"$bin-supply"},{"n":"$enc","t":"Any"},{"n":"fd-vow","t":"Any"},{"n":"permit-channel","t":"Any"},{"n":":$translate-nl","t":"Any"},{"t":"Mu","n":"*%_"}]},"n":"!wrap-decoder"}],"d":"<p><pre><code>class Proc::Async {}\n</code></pre></p><p>Proc::Async allows you to run external commands asynchronously, capturing standard output and error handles, and optionally write to its standard input.</p><p><pre><code>my $file = ‘foo’.IO;\nspurt $file, “and\\nCamelia\\n♡\\nme\\n”;\n\nmy $proc = Proc::Async.new: :w, ‘tac’, ‘--’, $file, ‘-’;\n# my $proc = Proc::Async.new: :w, ‘sleep’, 15; # uncomment to try timeouts\n\nreact {\n    whenever $proc.stdout.lines { # split input on \\r\\n, \\n, and \\r\n        say ‘line: ’, $_\n    }\n    whenever $proc.stderr { # chunks\n        say ‘stderr: ’, $_\n    }\n    whenever $proc.ready {\n        say ‘PID: ’, $_ # Only in Rakudo 2018.04 and newer, otherwise Nil\n    }\n    whenever $proc.start {\n        say ‘Proc finished: exitcode=’, .exitcode, ‘ signal=’, .signal;\n        done # gracefully jump from the react block\n    }\n    whenever $proc.print: “I\\n♥\\nCamelia\\n” {\n        $proc.close-stdin\n    }\n    whenever signal(SIGTERM).merge: signal(SIGINT) {\n        once {\n            say ‘Signal received, asking the process to stop’;\n            $proc.kill; # sends SIGHUP, change appropriately\n            whenever signal($_).zip: Promise.in(2).Supply {\n                say ‘Kill it!’;\n                $proc.kill: SIGKILL\n            }\n        }\n    }\n    whenever Promise.in(5) {\n        say ‘Timeout. Asking the process to stop’;\n        $proc.kill; # sends SIGHUP, change appropriately\n        whenever Promise.in(2) {\n            say ‘Timeout. Forcing the process to stop’;\n            $proc.kill: SIGKILL\n        }\n    }\n}\n\nsay ‘Program finished’;\n</code></pre></p><p>Example above produces the following output:</p><p><pre><code>line: me\nline: ♡\nline: Camelia\nline: and\nline: Camelia\nline: ♥\nline: I\nProc finished. Exit code: 0\nProgram finished\n</code></pre></p><p>Alternatively, you can use Proc::Async without using a react block:</p><p><pre><code># command with arguments\nmy $proc = Proc::Async.new('echo', 'foo', 'bar');\n\n# subscribe to new output from out and err handles:\n$proc.stdout.tap(-&gt; $v { print \"Output: $v\" }, quit =&gt; { say 'caught exception ' ~ .^name });\n$proc.stderr.tap(-&gt; $v { print \"Error:  $v\" });\n\nsay \"Starting...\";\nmy $promise = $proc.start;\n\n# wait for the external program to terminate\nawait $promise;\nsay \"Done.\";</code></pre></p><p>This produces the following output:</p><p><pre><code>Starting...\nOutput: foo bar\nDone.\n</code></pre></p><p>An example that opens an external program for writing:</p><p><pre><code>my $prog = Proc::Async.new(:w, 'hexdump', '-C');\nmy $promise = $prog.start;\nawait $prog.write(Buf.new(12, 42));\n$prog.close-stdin;\nawait $promise;</code></pre></p><p>An example of piping several commands like echo \"Hello, world\" | cat -n:</p><p><pre><code>my $proc-echo = Proc::Async.new: 'echo', 'Hello, world';\nmy $proc-cat = Proc::Async.new: 'cat', '-n';\n$proc-cat.bind-stdin: $proc-echo.stdout;\nawait $proc-echo.start, $proc-cat.start;</code></pre></p>","a":[{"n":"$!ready_promise","k":"v","t":"Mu"},{"t":"Mu","n":"$!ready_vow","k":"v"},{"n":"$!handle_available_promise","k":"v","t":"Mu"},{"t":"Mu","n":"$!stdout_descriptor_vow","k":"v"},{"n":"$!stderr_descriptor_vow","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!stdout_descriptor_used"},{"k":"v","t":"Mu","n":"$!stderr_descriptor_used"},{"t":"Mu","k":"v","n":"$.path"},{"t":"Positional","k":"v","n":"@.args"},{"k":"v","t":"List","n":"@.command"},{"t":"Mu","n":"$.w","k":"v"},{"t":"Mu","k":"v","n":"$.enc"},{"t":"Mu","n":"$.translate-nl","k":"v"},{"t":"Mu","n":"$.win-verbatim-args","k":"v"},{"n":"$.started","t":"Bool","k":"v"},{"t":"Mu","n":"$!stdout_supply","k":"v"},{"k":"v","n":"$!stdout_type","t":"CharsOrBytes"},{"t":"Mu","k":"v","n":"$!stderr_supply"},{"n":"$!stderr_type","k":"v","t":"CharsOrBytes"},{"k":"v","t":"Mu","n":"$!merge_supply"},{"k":"v","n":"$!merge_type","t":"CharsOrBytes"},{"t":"Mu","k":"v","n":"$!stdin-fd"},{"n":"$!stdin-fd-close","t":"Mu","k":"v"},{"t":"Mu","n":"$!stdout-fd","k":"v"},{"t":"Mu","n":"$!stderr-fd","k":"v"},{"n":"$!process_handle","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!exit_promise"},{"t":"Positional","n":"@!promises","k":"v"},{"n":"$!encoder","t":"Mu","k":"v"},{"t":"Positional","n":"@!close-after-exit","k":"v"}],"n":"Proc::Async","mro":["Any"],"b":"A","k":"c","t":"Proc::Async"},{"a":[{"t":"Promise","n":"$.native-descriptor","k":"v"},{"k":"v","t":"Callable","n":"&!on-nd-used"},{"t":"Tappable","n":"$!tappable","k":"v"}],"t":"Proc::Async::Pipe","mro":["Awaitable","Supply"],"b":"A","m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"native-descriptor","k":"m"},{"s":{"p":[{"n":"$delegate","t":"Any"},{"n":"$native-descriptor","t":"Any"},{"t":"Callable","n":"&on-tap"},{"n":"&on-nd-used","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"new"},{"k":"s","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"Proc::Async::Pipe"},{"b":"A","t":"Supplier","n":"Supplier","m":[{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"new","d":"<p><pre><code>method new()</code></pre></p><p>The Supplier constructor.</p>","m":0,"k":"m"},{"n":"BUILD","k":"s","m":0,"s":{"p":[{"t":"Any","n":":$!taplist!"},{"t":"Mu","n":"*%_"}],"r":"Nil"}},{"k":"m","m":0,"n":"emit","d":"<p><pre><code>method emit(Supplier:D: Mu \\value)</code></pre></p><p>Sends the given value to all of the taps on all of the supplies created by Supply on this Supplier.</p>","s":{"r":"Nil","p":[{"n":"value","t":"Mu"},{"n":"*%_","t":"Mu"}]}},{"k":"m","d":"<p><pre><code>method done(Supplier:D:)</code></pre></p><p>Calls the done callback on all the taps that have one.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply   = $supplier.Supply;\n$supply.tap(-&gt; $v { say $v }, done =&gt; { say \"no more answers\" });\n$supplier.emit(42);\n$supplier.done;</code></pre></p><p>Will output:</p><p><pre><code>42\nno more answers\n</code></pre></p>","m":0,"n":"done","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Nil"}},{"m":1,"k":"m","n":"quit","s":{"p":[{"t":"Exception","n":"$ex"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$message"},{"n":"*%_","t":"Mu"}]},"n":"quit"},{"n":"Supply","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method Supply(Supplier:D: --&gt; Supply)</code></pre></p><p>This creates a new Supply object to which any values which are emitted on this supplier are passed. This is the factory for all live supplies.</p>","m":0},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"unsanitized-supply","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"d":"<p><pre><code>class Supplier { }</code></pre></p><p>This is a factory for live Supply objects, which provides the mechanism for emitting new values onto the supplies:</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply_1 = $supplier.Supply;\n$supply_1.tap(-&gt; $v { say \"One $v\" });\nmy $supply_2 = $supplier.Supply;\n$supply_2.tap(-&gt; $v { say \"Two $v\" });\n$supplier.emit(42);</code></pre></p><p>Will output:</p><p><pre><code>One 42\nTwo 42\n</code></pre></p><p>on demand supplies are created by the factory methods of the Supply class or by the supply keyword. A mixture of a live and on-demand Supply can be created with a Supplier::Preserving.</p>","a":[{"n":"$!taplist","t":"Mu","k":"v"}],"mro":["Any"],"k":"c"},{"t":"Supplier::Preserving","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"new","m":0,"k":"m"},{"m":0,"k":"s","n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"b":"A","a":[{"n":"$!taplist","t":"Mu","k":"v"}],"k":"c","mro":["Supplier"],"n":"Supplier::Preserving","d":"<p><pre><code>class Supplier::Preserving is Supplier { }</code></pre></p><p>This is a factory for live Supply-type objects, and it provides the mechanism for emitting new values onto the supplies, whereby values are kept when no consumer has tapped into the Supply. Any tapping will consume the already stored and future values.</p><p>Starting a preserving Supply and consuming its values after it is done:</p><p><pre><code>my $p = Supplier::Preserving.new;\nstart for ^3 {\n    $p.emit($_);\n    LAST {\n        say „done after { now - BEGIN now}s“;\n        $p.done;\n    }\n}\nsleep 2;\nreact {\n    whenever $p.Supply { $_.say; }\n    whenever Promise.in(2) { done }\n}\nsay „also done after { now - BEGIN now }s“</code></pre></p><p>Will output:</p><p><pre><code>done after 0.0638467s\n0\n1\n2\nalso done after 4.0534119s\n</code></pre></p>"},{"t":"Sub","n":"&rindex","k":"v"},{"m":1,"k":"s","n":"rindex","s":{"p":[{"n":"$s","t":"Cool"},{"t":"Cool","n":"$needle"}],"r":"Int:D"}},{"m":1,"s":{"p":[{"n":"$s","t":"Cool"},{"t":"Cool","n":"$needle"},{"t":"Cool","n":"$pos"}],"r":"Int:D"},"n":"rindex","k":"s"},{"b":"C","mro":["Baggy","QuantHash","Associative"],"m":[{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","n":"of"},{"k":"m","m":0,"s":{"r":"Mixy:D","p":[{"t":"Positional","n":"*@pairs"},{"n":"*%_","t":"Mu"}]},"n":"new-from-pairs"}],"n":"Mixy","t":"Mixy","k":"ro","d":"<p><pre><code>role Mixy does Baggy { }</code></pre></p><p>A role for collections of weighted values. See Mix and MixHash. Mixy objects differ from Baggy objects in that the weights of Mixy are Reals rather than Ints.</p>"},{"t":"Sub","n":"&EVALFILE","k":"v"},{"n":"EVALFILE","m":1,"s":{"r":"Mu","p":[{"n":"$filename","t":"Any"},{"t":"Any","n":":$lang?"},{"t":"Any","n":":$check"}]},"k":"s"},{"n":"&sleep-timer","t":"Sub","k":"v"},{"k":"s","s":{"p":[],"r":"Duration:D"},"m":1,"n":"sleep-timer"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"$seconds"}],"r":"Duration:D"},"n":"sleep-timer"},{"t":"Sub","k":"v","n":"&put"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"put"},{"k":"s","s":{"r":"Mu","p":[{"n":"j","t":"Junction"}]},"n":"put","m":1},{"m":1,"k":"s","n":"put","s":{"p":[{"n":"x","t":"Any"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"n":"put"},{"d":"<p><pre><code>multi sub infix:&lt;..^&gt;($a, $b --&gt; Range:D) is assoc&lt;non&gt;</code></pre></p><p>Right-open range operator.</p><p>Constructs a Range from the arguments, excluding the end point.</p>","k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<..^>"},{"n":"infix:<..^>","m":1,"s":{"p":[{"n":"$min","t":"Any"},{"n":"$max","t":"Any"}],"r":"Mu"},"k":"s"},{"n":"&asinh","t":"Sub+{is-pure}","k":"v"},{"m":1,"k":"s","s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"},"n":"asinh"},{"n":"asinh","m":1,"s":{"r":"Mu","p":[{"t":"Cool","n":"x"}]},"k":"s"},{"k":"s","n":"asinh","m":1,"s":{"r":"num","p":[{"t":"num","n":"$x"}]}},{"k":"v","t":"Sub","n":"&flip"},{"n":"flip","k":"s","s":{"p":[{"n":"$s","t":"Cool"}],"r":"Str:D"},"m":1},{"t":"Signal","k":"e","n":"SIGTTIN"},{"n":"&atan2","t":"Sub","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Real"},{"n":"b?","t":"Real"}]},"n":"atan2"},{"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"n":"b?","t":"Any"}]},"n":"atan2","m":1},{"m":1,"s":{"p":[{"t":"Num","n":"$a"},{"t":"Num","n":"$b?"}],"r":"Mu"},"n":"atan2","k":"s"},{"d":"<p><pre><code>multi sub prefix:&lt;+^&gt;(Any --&gt; Int:D)</code></pre></p><p>Integer bitwise negation operator: Coerces the argument to Int and does a bitwise negation on the result, assuming two's complement.</p>","k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<+^>"},{"s":{"p":[{"t":"Any","n":"$x"}],"r":"Mu"},"k":"s","m":1,"n":"prefix:<+^>"},{"m":1,"k":"s","n":"prefix:<+^>","s":{"p":[{"t":"Int","n":"a"}],"r":"Int:D"}},{"k":"s","m":1,"n":"prefix:<+^>","s":{"r":"int","p":[{"n":"$a","t":"int"}]}},{"d":"<p>Same as infix ^^, except with looser precedence.</p><p>Returns the operand that evaluates to True in boolean context, if and only if the other operand evaluates to False in boolean context. If both operands evaluate to False, returns the last argument. If both operands evaluate to True, returns Nil.</p><p>When chaining, returns the operand that evaluates to True, if and only if there is one such operand. If more than one operand is true, it short-circuits after evaluating the second and returns Nil. If all operands are false, returns the last one.</p>","t":"Sub+{Precedence}","n":"&infix:<xor>","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Mu","n":"$x?"}]},"n":"infix:<xor>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Mu"},{"n":"&b","t":"Callable"}]},"n":"infix:<xor>","m":1,"k":"s"},{"n":"infix:<xor>","s":{"r":"Mu","p":[{"t":"Mu","n":"a"},{"n":"b","t":"Mu"}]},"m":1,"k":"s"},{"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"s","n":"infix:<xor>","m":1},{"k":"v","n":"&infix:<⊃>","t":"Sub+{is-pure}"},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:<⊃>","k":"s"},{"m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"n":"soft","k":"m","m":0}],"b":"C","mro":[],"t":"SoftRoutine","n":"SoftRoutine","k":"ro"},{"n":"&infix:<÷>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<÷>","s":{"p":[],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":[{"n":"$x","t":"Any"}]},"k":"s","m":1,"n":"infix:<÷>"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"n":"infix:<÷>"},{"s":{"p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<÷>"},{"k":"s","m":1,"n":"infix:<÷>","s":{"p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}],"r":"num"},"n":"infix:<÷>"},{"s":{"r":"Mu","p":[{"n":"r","t":"Range"},{"n":"v","t":"Real"}]},"n":"infix:<÷>","k":"s","m":1},{"n":"infix:<÷>","k":"s","m":1,"s":{"p":[{"t":"Rational","n":"a"},{"t":"Rational","n":"b"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"n":"a","t":"Rational"},{"n":"b","t":"Int"}]},"k":"s","n":"infix:<÷>","m":1},{"m":1,"n":"infix:<÷>","s":{"p":[{"n":"a","t":"Int"},{"n":"b","t":"Rational"}],"r":"Mu"},"k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}],"r":"Mu"},"n":"infix:<÷>"},{"m":1,"k":"s","s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}]},"n":"infix:<÷>"},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Complex"},{"n":"b","t":"Real"}],"r":"Complex:D"},"n":"infix:<÷>"},{"m":1,"n":"infix:<÷>","s":{"r":"Complex:D","p":[{"t":"Real","n":"a"},{"n":"b","t":"Complex"}]},"k":"s"},{"n":"&atomic-fetch-sub","k":"v","t":"Sub"},{"k":"s","m":1,"s":{"r":"atomicint","p":[{"n":"$target","t":"atomicint"},{"n":"$add","t":"int"}]},"n":"atomic-fetch-sub"},{"k":"s","m":1,"n":"atomic-fetch-sub","s":{"p":[{"n":"$target","t":"atomicint"},{"t":"Int","n":"$add"}],"r":"atomicint"}},{"n":"atomic-fetch-sub","k":"s","m":1,"s":{"p":[{"t":"atomicint","n":"$target"},{"n":"$add","t":"Any"}],"r":"atomicint"}},{"k":"v","d":"<p>Defined as:</p><p><pre><code>multi sub infix:&lt;X&gt;(+lol, :&amp;with! --&gt; Seq:D)\nmulti sub infix:&lt;X&gt;(+lol --&gt; Seq:D)</code></pre></p><p>Creates a cross product from all the lists, ordered so that the rightmost elements vary most rapidly, and returns a Seq:</p><p><pre><code>1..3 X &lt;a b c&gt; X 9\n# produces ((1 a 9) (1 b 9) (1 c 9)\n#           (2 a 9) (2 b 9) (2 c 9)\n#           (3 a 9) (3 b 9) (3 c 9))</code></pre></p><p>The X operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p><p><pre><code>1..3 X~ &lt;a b c&gt; X~ 9\n# produces (1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)</code></pre></p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<X>"},{"k":"s","n":"infix:<X>","s":{"p":[{"n":"+lol","t":"Any"},{"t":"Any","n":":$with!"}],"r":"Seq:D"},"m":1},{"m":1,"n":"infix:<X>","s":{"r":"Seq:D","p":[{"t":"Any","n":"+lol"}]},"k":"s"},{"k":"v","t":"Sub+{is-nodal}","n":"&elems"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"$a"}]},"n":"elems"},{"k":"v","t":"Sub","n":"&cache"},{"k":"s","s":{"r":"Mu","p":[{"n":"+@l","t":"Positional"}]},"n":"cache","m":1},{"t":"Sub+{is-pure}","k":"v","n":"&atan"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"x","t":"Numeric"}]},"n":"atan"},{"m":1,"k":"s","n":"atan","s":{"r":"Mu","p":[{"n":"x","t":"Cool"}]}},{"k":"s","m":1,"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"n":"atan"},{"k":"v","n":"&samewith","t":"Sub"},{"m":0,"s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"n":"samewith","k":"s"},{"t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;gt&gt;(Mu,    Mu)\nmulti sub infix:&lt;gt&gt;(Str:D, Str:D)</code></pre></p><p>String greater than operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is larger than the second, as determined by lexicographic comparison.</p><p>Mnemonic: greater than</p>","k":"v","n":"&infix:<gt>"},{"k":"s","m":1,"n":"infix:<gt>","s":{"p":[{"n":"$x?","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"},"m":1,"n":"infix:<gt>","k":"s"},{"m":1,"k":"s","n":"infix:<gt>","s":{"p":[{"n":"a","t":"Blob"},{"n":"b","t":"Blob"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}],"r":"Bool:D"},"n":"infix:<gt>"},{"m":1,"s":{"p":[{"n":"$a","t":"str"},{"n":"$b","t":"str"}],"r":"Bool:D"},"n":"infix:<gt>","k":"s"},{"n":"Supply","t":"Supply","m":[{"m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"new"},{"n":"new","k":"m","s":{"r":"Mu","p":[{"t":"Tappable","n":"$tappable"},{"n":"*%_","t":"Mu"}]},"m":1},{"s":{"r":"Nil","p":[{"n":":$!tappable!","t":"Tappable"},{"n":"*%_","t":"Mu"}]},"k":"s","m":0,"n":"BUILD"},{"d":"<p>Defined as:</p><p><pre><code>method Capture(Supply:D --&gt; Capture:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","k":"m","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"Capture"},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"live","d":"<p><pre><code>method live(Supply:D: --&gt; Bool:D)</code></pre></p><p>Returns True if the supply is \"live\", that is, values are emitted to taps as soon as they arrive. Always returns True in the default Supply (but for example on the supply returned from Supply.from-list it's False).</p><p><pre><code>say Supplier.new.Supply.live;    # OUTPUT: «True␤»</code></pre></p>"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"serial","m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Tappable","p":[{"t":"Mu","n":"*%_"}]},"n":"Tappable"},{"s":{"r":"Mu","p":[{"n":"&emit?","t":"Callable"},{"n":":&done?","t":"Callable"},{"n":":&quit?","t":"Callable"},{"n":":&tap?","t":"Callable"},{"n":"*%_","t":"Mu"}]},"k":"m","d":"<p><pre><code>method tap(Supply:D: &amp;emit = -&gt; $ { },\n        :&amp;done,\n        :&amp;quit,\n        :&amp;tap\n    --&gt; Tap:D)\n</code></pre></p><p>Creates a new tap (a kind of subscription if you will), in addition to all existing taps. The first positional argument is a piece of code that will be called when a new value becomes available through the emit call.</p><p>The &amp;done callback can be called in a number of cases: if a supply block is being tapped, when a done routine is reached; if a supply block is being tapped, it will be automatically triggered if the supply block reaches the end; if the done method is called on the parent Supplier (in the case of a supply block, if there are multiple Suppliers referenced by whenever, they must all have their done method invoked for this to trigger the &amp;done callback of the tap as the block will then reach its end).</p><p>The &amp;quit callback is called if the tap is on a supply block which exits with an error. It is also called if the quit method is invoked on the parent Supplier (in the case of a supply block any one Supplier quitting with an uncaught exception will call the &amp;quit callback as the block will exit with an error). The error is passed as a parameter to the callback.</p><p>The &amp;tap callback is called once the Tap object is created, which is passed as a parameter to the callback. The callback is called ahead of emit/done/quit, providing a reliable way to get the Tap object. One case where this is useful is when the Supply begins emitting values synchronously, since the call to .tap won't return the Tap object until it is done emitting, preventing it from being stopped if needed.</p><p>Method tap returns an object of type Tap, on which you can call the close method to cancel the subscription.</p><p><pre><code>my $s = Supply.from-list(0 .. 5);\nmy $t = $s.tap(-&gt; $v { say $v }, done =&gt; { say \"no more ticks\" });</code></pre></p><p>Produces:</p><p><pre><code>0\n1\n2\n3\n4\n5\nno more ticks\n</code></pre></p>","m":0,"n":"tap"},{"s":{"r":"Mu","p":[{"t":"Callable","n":"&actor"},{"n":"*%others","t":"Associative"}]},"n":"act","k":"m","d":"<p><pre><code>method act(Supply:D: &amp;act --&gt; Tap:D)</code></pre></p><p>Creates a tap on the given supply with the given code. Differently from tap, the given code is guaranteed to be only executed by one thread at a time.</p>","m":0},{"n":"on-demand","s":{"p":[{"t":"Callable","n":"&producer"},{"n":":&closing","t":"Callable"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"from-list","s":{"p":[{"t":"Positional","n":"+@values"},{"t":"Any","n":":$scheduler?"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method from-list(Supply:U: +@values --&gt; Supply:D)</code></pre></p><p>Creates an on-demand supply from the values passed to this method.</p><p><pre><code>my $s = Supply.from-list(1, 2, 3);\n$s.tap(&amp;say);           # OUTPUT: «1␤2␤3␤»</code></pre></p>","k":"m"},{"d":"<p><pre><code>method interval(Supply:U: $interval, $delay = 0, :$scheduler = $*SCHEDULER --&gt; Supply:D)</code></pre></p><p>Creates a supply that emits a value every $interval seconds, starting $delay seconds from the call. The emitted value is an integer, starting from 0, and is incremented by one for each value emitted.</p><p>Implementations may treat too-small values as lowest resolution they support, possibly warning in such situations; e.g. treating 0.0001 as 0.001. For 6.d language version, the minimal value specified is 0.001.</p>","m":0,"s":{"r":"Mu","p":[{"n":"$interval","t":"Any"},{"t":"Any","n":"$delay?"},{"n":":$scheduler?","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"interval","k":"m"},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0,"k":"m","n":"serialize"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0,"n":"sanitize"},{"k":"m","d":"<p><pre><code>method on-close(Supply:D: &amp;on-close --&gt; Supply:D)</code></pre></p><p>Returns a new Supply which will run &amp;on-close whenever a Tap of that Supply is closed. This includes if further operations are chained on to the Supply. (for example, $supply.on-close(&amp;on-close).map(*.uc)). When using a react or supply block, using the CLOSE phaser is usually a better choice.</p><p><pre><code>my $s = Supplier.new;\nmy $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n    -&gt; $v { say \"the value is $v\" },\n    done    =&gt; { say \"Supply is done\" },\n    quit    =&gt; -&gt; $ex { say \"Supply finished with error $ex\" },\n);\n\n$s.emit('Raku');\n$tap.close;        # OUTPUT: «Tap closed␤»</code></pre></p>","m":0,"s":{"p":[{"t":"Callable","n":"&on-close"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"on-close"},{"n":"map","k":"m","d":"<p><pre><code>method map(Supply:D: &amp;mapper --&gt; Supply:D)</code></pre></p><p>Returns a new supply that maps each value of the given supply through &amp;mapper and emits it to the new supply.</p><p><pre><code>my $supplier = Supplier.new;\nmy $all      = $supplier.Supply;\nmy $double   = $all.map(-&gt; $value { $value * 2 });\n$double.tap(&amp;say);\n$supplier.emit(4);           # RESULT: «8»</code></pre></p>","m":0,"s":{"p":[{"t":"Callable","n":"&mapper"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"$test","t":"Mu"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"grep","k":"m","d":"<p><pre><code>method grep(Supply:D: Mu $test --&gt; Supply:D)</code></pre></p><p>Creates a new supply that only emits those values from the original supply that smartmatch against $test.</p><p><pre><code>my $supplier = Supplier.new;\nmy $all      = $supplier.Supply;\nmy $ints     = $all.grep(Int);\n$ints.tap(&amp;say);\n$supplier.emit($_) for 1, 'a string', 3.14159;   # prints only 1</code></pre></p>"},{"s":{"p":[{"n":":$end","t":"Any"},{"t":"Any","n":"c"}],"r":"Mu"},"m":0,"k":"m","n":"first"},{"d":"<p><pre><code>method schedule-on(Supply:D: Scheduler $scheduler)</code></pre></p><p>Runs the emit, done and quit callbacks on the specified scheduler.</p><p>This is useful for GUI toolkits that require certain actions to be run from the GUI thread.</p>","m":0,"k":"m","n":"schedule-on","s":{"r":"Mu","p":[{"n":"$scheduler","t":"Scheduler"},{"t":"Mu","n":"*%_"}]}},{"k":"m","s":{"r":"Mu","p":[{"n":"&startee","t":"Callable"},{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method start(Supply:D: &amp;startee --&gt; Supply:D)</code></pre></p><p>Creates a supply of supplies. For each value in the original supply, the code object is scheduled on another thread, and returns a supply either of a single value (if the code succeeds), or one that quits without a value (if the code fails).</p><p>This is useful for asynchronously starting work that you don't block on.</p><p>Use migrate to join the values into a single supply again.</p>","m":0,"n":"start"},{"m":0,"n":"stable","k":"m","d":"<p><pre><code>method stable(Supply:D: $time, :$scheduler = $*SCHEDULER --&gt; Supply:D)</code></pre></p><p>Creates a new supply that only passes on a value flowing through the given supply if it wasn't superseded by another value in the given $time (in seconds). Optionally uses another scheduler than the default scheduler, using the :scheduler parameter.</p><p>To clarify the above, if, during the timeout $time, additional values are emitted to the Supplier all but the last one will be thrown away. Each time an additional value is emitted to the Supplier, during the timeout, $time is reset.</p><p>This method can be quite useful when handling UI input, where it is not desired to perform an operation until the user has stopped typing for a while rather than on every keystroke.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply1 = $supplier.Supply;\n$supply1.tap(-&gt; $v { say \"Supply1 got: $v\" });\n$supplier.emit(42);\n\nmy Supply $supply2 = $supply1.stable(5);\n$supply2.tap(-&gt; $v { say \"Supply2 got: $v\" });\nsleep(3);\n$supplier.emit(43);  # will not be seen by $supply2 but will reset $time\n$supplier.emit(44);\nsleep(10);\n# OUTPUT: «Supply1 got: 42␤Supply1 got: 43␤Supply1 got: 44␤Supply2 got: 44␤»\n</code></pre></p><p>As can be seen above, $supply1 received all values emitted to the Supplier while $supply2 only received one value. The 43 was thrown away because it was followed by another 'last' value 44 which was retained and sent to $supply2 after approximately eight seconds, this due to the fact that the timeout $time was reset after three seconds.</p>","s":{"p":[{"t":"Any","n":"$time"},{"t":"Any","n":":$scheduler?"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"n":"delayed","s":{"p":[{"t":"Any","n":"$time"},{"n":":$scheduler?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method delayed(Supply:D: $seconds, :$scheduler = $*SCHEDULER --&gt; Supply:D)</code></pre></p><p>Creates a new supply in which all values flowing through the given supply are emitted, but with the given delay in seconds.</p>","m":0},{"d":"<p><pre><code>method do(Supply:D: &amp;do --&gt; Supply:D)</code></pre></p><p>Creates a supply to which all values seen in the given supply, are emitted again. The given code, executed for its side-effects only, is guaranteed to be only executed by one thread at a time.</p>","s":{"p":[{"t":"Callable","n":"&side-effect"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"do","m":0,"k":"m"},{"k":"m","n":"flat","d":"<p><pre><code>method flat(Supply:D: --&gt; Supply:D)</code></pre></p><p>Creates a supply on which all of the values seen in the given supply are flattened before being emitted again.</p>","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"d":"<p><pre><code>method merge(Supply @*supplies --&gt; Supply:D)</code></pre></p><p>Creates a supply to which any value seen from the given supplies, is emitted. The resulting supply is done Only when all given supplies are done. Can also be called as a class method.</p>","n":"merge","s":{"p":[{"n":"*@s","t":"Positional"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"d":"<p><pre><code>method reduce(Supply:D: &amp;with --&gt; Supply:D)</code></pre></p><p>Creates a \"reducing\" supply with the same semantics as List.reduce.</p><p><pre><code>my $supply = Supply.from-list(1..5).reduce({$^a + $^b});\n$supply.tap(-&gt; $v { say \"$v\" }); # OUTPUT: «15␤»</code></pre></p>","m":0,"s":{"p":[{"n":"&with","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"reduce"},{"s":{"p":[{"n":"&with","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p><pre><code>method produce(Supply:D: &amp;with --&gt; Supply:D)</code></pre></p><p>Creates a \"producing\" supply with the same semantics as List.produce.</p><p><pre><code>my $supply = Supply.from-list(1..5).produce({$^a + $^b});\n$supply.tap(-&gt; $v { say \"$v\" }); # OUTPUT: «1␤3␤6␤10␤15␤»</code></pre></p>","n":"produce","m":0},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"d":"<p><pre><code>method migrate(Supply:D: --&gt; Supply:D)</code></pre></p><p>Takes a Supply which itself has values that are of type Supply as input. Each time the outer Supply emits a new Supply, this will be tapped and its values emitted. Any previously tapped Supply will be closed. This is useful for migrating between different data sources, and only paying attention to the latest one.</p><p>For example, imagine an application where the user can switch between different stocks. When they switch to a new one, a connection is established to a web socket to get the latest values, and any previous connection should be closed. Each stream of values coming over the web socket would be represented as a Supply, which themselves are emitted into a Supply of latest data sources to watch. The migrate method could be used to flatten this supply of supplies into a single Supply of the current values that the user cares about.</p><p>Here is a simple simulation of such a program:</p><p><pre><code>my Supplier $stock-sources .= new;\n\nsub watch-stock($symbol) {\n    $stock-sources.emit: supply {\n        say \"Starting to watch $symbol\";\n        whenever Supply.interval(1) {\n            emit \"$symbol: 111.\" ~ 99.rand.Int;\n        }\n        CLOSE say \"Lost interest in $symbol\";\n    }\n}\n\n$stock-sources.Supply.migrate.tap: *.say;\n\nwatch-stock('GOOG');\nsleep 3;\nwatch-stock('AAPL');\nsleep 3;\n</code></pre></p><p>Which produces output like:</p><p><pre><code>Starting to watch GOOG\nGOOG: 111.67\nGOOG: 111.20\nGOOG: 111.37\nLost interest in GOOG\nStarting to watch AAPL\nAAPL: 111.55\nAAPL: 111.6\nAAPL: 111.6\n</code></pre></p>","n":"migrate","m":0,"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"t":"Callable","n":"&mapper"},{"t":"Mu","n":"*%_"}]},"k":"m","n":"classify"},{"n":"classify","s":{"p":[{"t":"Associative","n":"%mapper"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":1},{"s":{"p":[{"t":"Positional","n":"@mapper"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"classify","k":"m","m":1},{"n":"categorize","s":{"p":[{"t":"Callable","n":"&mapper"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":1,"k":"m"},{"n":"categorize","s":{"p":[{"n":"%mapper","t":"Associative"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":1,"k":"m"},{"m":1,"s":{"r":"Mu","p":[{"t":"Positional","n":"@mapper"},{"n":"*%_","t":"Mu"}]},"n":"categorize","k":"m"},{"n":"comb","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":1},{"k":"m","m":1,"n":"comb","s":{"p":[{"n":"$the-batch","t":"Int"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":1,"s":{"p":[{"n":"$the-needle","t":"Str"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"comb"},{"s":{"p":[{"n":"$matcher","t":"Regex"},{"n":":$match!","t":"Any"},{"t":"Any","n":"c"}],"r":"Mu"},"n":"comb","k":"m","m":1},{"n":"comb","m":1,"k":"m","s":{"p":[{"n":"$matcher","t":"Regex"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","n":"comb","m":1,"s":{"p":[{"n":"the-thing","t":"Any"},{"t":"Any","n":"the-limit"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[{"n":"$encoding?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"encode"},{"n":"decode","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$encoding?"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"d":"<p><pre><code>method Channel(Supply:D: --&gt; Channel:D)</code></pre></p><p>Returns a Channel object that will receive all future values from the supply, and will be closed when the Supply is done, and quit (shut down with error) when the supply is quit.</p>","n":"Channel","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"Seq","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"n":"Promise","d":"<p><pre><code>method Promise(Supply:D: --&gt; Promise:D)</code></pre></p><p>Returns a Promise that will be kept when the Supply is done. If the Supply also emits any values, then the Promise will be kept with the final value. Otherwise, it will be kept with Nil. If the Supply ends with a quit instead of a done, then the Promise will be broken with that exception.</p><p><pre><code>my $supplier = Supplier.new;\nmy $s = $supplier.Supply;\nmy $p = $s.Promise;\n$p.then(-&gt; $v { say \"got $v.result()\" });\n$supplier.emit('cha');         # not output yet\n$supplier.done();              # got cha</code></pre></p><p>The Promise method is most useful when dealing with supplies that will tend to produce just one value, when only the final value is of interest, or when only completion (successful or not) is relevant.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"d":"<p><pre><code>method wait(Supply:D:)</code></pre></p><p>Taps the Supply it is called on, and blocks execution until the either the supply is done (in which case it evaluates to the final value that was emitted on the Supply, or Nil if not value was emitted) or quit (in which case it will throw the exception that was passed to quit).</p><p><pre><code>my $s = Supplier.new;\nstart {\n  sleep 1;\n  say \"One second: running.\";\n  sleep 1;\n  $s.emit(42);\n  $s.done;\n}\n$s.Supply.wait;\nsay \"Two seconds: done\";</code></pre></p>","k":"m","n":"wait","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Awaitable::Handle","p":[{"n":"*%_","t":"Mu"}]},"n":"get-await-handle"},{"d":"<p><pre><code>method batch(Supply:D: :$elems, :$seconds --&gt; Supply:D)</code></pre></p><p>Creates a new supply that batches the values of the given supply by either the number of elements in the batch (using :elems) or the maximum number of seconds (using the :seconds) or both. Any remaining values are emitted in a final batch when the supply is done.</p>","m":0,"n":"batch","k":"m","s":{"p":[{"t":"Cool","n":":$elems?"},{"t":"Any","n":":$seconds"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"n":"lines","k":"m","d":"<p><pre><code>method lines(Supply:D: :$chomp = True --&gt; Supply:D)</code></pre></p><p>Creates a supply that will emit the characters coming in line by line from a supply that's usually created by some asynchronous I/O operation. The optional :chomp parameter indicates whether to remove line separators: the default is True.</p>","m":1,"s":{"r":"Mu","p":[{"n":":$chomp!","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"m":1,"d":"<p><pre><code>method lines(Supply:D: :$chomp = True --&gt; Supply:D)</code></pre></p><p>Creates a supply that will emit the characters coming in line by line from a supply that's usually created by some asynchronous I/O operation. The optional :chomp parameter indicates whether to remove line separators: the default is True.</p>","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"lines"},{"d":"<p><pre><code>method words(Supply:D: --&gt; Supply:D)</code></pre></p><p>Creates a supply that will emit the characters coming in word for word from a supply that's usually created by some asynchronous I/O operation.</p><p><pre><code>my $s = Supply.from-list(\"Hello Word!\".comb);\nmy $ws = $s.words;\n$ws.tap(&amp;say);           # OUTPUT: «Hello␤Word!␤»</code></pre></p>","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"words"},{"s":{"p":[{"n":"$number?","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"d":"<p><pre><code>method skip(Supply:D: Int(Cool) $number = 1 --&gt; Supply:D)</code></pre></p><p>Returns a new Supply which will emit all values from the given Supply except for the first $number values, which will be thrown away.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply = $supplier.Supply;\n$supply = $supply.skip(3);\n$supply.tap({ say $_ });\n$supplier.emit($_) for 1..10; # OUTPUT: «4␤5␤6␤7␤8␤9␤10␤»\n</code></pre></p>","m":0,"n":"skip","k":"m"},{"d":"<p><pre><code>method min(Supply:D: &amp;custom-routine-to-use = &amp;infix:&lt;cmp&gt; --&gt; Supply:D)</code></pre></p><p>Creates a supply that only emits values from the given supply if they are smaller than any value seen before. In other words, from a continuously descending supply it will emit all the values. From a continuously ascending supply it will only emit the first value. The optional parameter specifies the comparator, just as with Any.min.</p>","m":0,"s":{"r":"Mu","p":[{"n":"&by?","t":"Callable"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"min"},{"m":0,"d":"<p><pre><code>method max(Supply:D: &amp;custom-routine-to-use = &amp;infix:&lt;cmp&gt; --&gt; Supply:D)</code></pre></p><p>Creates a supply that only emits values from the given supply if they are larger than any value seen before. In other words, from a continuously ascending supply it will emit all the values. From a continuously descending supply it will only emit the first value. The optional parameter specifies the comparator, just as with Any.max.</p>","k":"m","s":{"p":[{"t":"Callable","n":"&by?"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"max"},{"k":"m","s":{"r":"Mu","p":[{"t":"Callable","n":"&by?"},{"t":"Mu","n":"*%_"}]},"m":0,"d":"<p><pre><code>method minmax(Supply:D: &amp;custom-routine-to-use = &amp;infix:&lt;cmp&gt; --&gt; Supply:D)</code></pre></p><p>Creates a supply that emits a Range every time a new minimum or maximum values is seen from the given supply. The optional parameter specifies the comparator, just as with Any.minmax.</p>","n":"minmax"},{"k":"m","d":"<p><pre><code>method grab(Supply:D: &amp;when-done --&gt; Supply:D)</code></pre></p><p>Taps the Supply it is called on. When it is done, calls &amp;when-done and then emits the list of values that it returns on the result Supply. If the original Supply quits, then the exception is immediately conveyed on the return Supply.</p><p><pre><code>my $s = Supply.from-list(4, 10, 3, 2);\nmy $t = $s.grab(&amp;sum);\n$t.tap(&amp;say);           # OUTPUT: «19␤»</code></pre></p>","s":{"p":[{"n":"&when_done","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"grab"},{"k":"m","m":0,"n":"rotate","s":{"p":[{"n":"$rotate?","t":"Cool"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p><pre><code>method reverse(Supply:D: --&gt; Supply:D)</code></pre></p><p>Taps the Supply it is called on. Once that Supply emits done, all of the values it emitted will be emitted on the returned Supply in reverse order. If the original Supply quits, then the exception is immediately conveyed on the return Supply.</p><p><pre><code>my $s = Supply.from-list(1, 2, 3);\nmy $t = $s.reverse;\n$t.tap(&amp;say);           # OUTPUT: «3␤2␤1␤»</code></pre></p>","n":"reverse"},{"d":"<p><pre><code>method zip(Supply @*supplies, :&amp;with = &amp;[,] --&gt; Supply:D)</code></pre></p><p>Creates a supply that emits combined values as soon as there is a new value seen on all of the supplies. By default, Lists are created, but this can be changed by specifying your own combiner with the :with parameter. The resulting supply is done as soon as any of the given supplies are done. Can also be called as a class method.</p>","m":0,"s":{"r":"Mu","p":[{"n":"**@s","t":"Positional"},{"t":"Callable","n":":&with"},{"n":"*%_","t":"Mu"}]},"n":"zip","k":"m"},{"n":"zip-latest","m":0,"k":"m","d":"<p><pre><code>method zip-latest(Supply @*supplies, :&amp;with = &amp;[,], :$initial --&gt; Supply:D)</code></pre></p><p>Creates a supply that emits combined values as soon as there is a new value seen on any of the supplies. By default, Lists are created, but this can be changed by specifying your own combiner with the :with parameter. The optional :initial parameter can be used to indicate the initial state of the combined values. By default, all supplies have to have at least one value emitted on them before the first combined values is emitted on the resulting supply. The resulting supply is done as soon as any of the given supplies are done. Can also be called as a class method.</p>","s":{"r":"Mu","p":[{"n":"**@s","t":"Positional"},{"t":"Callable","n":":&with"},{"n":":$initial","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"d":"<p><pre><code>method throttle(Supply:D:\n  $limit,                 # values / time or simultaneous processing\n  $seconds or $callable,  # time-unit / code to process simultaneously\n  $delay = 0,             # initial delay before starting, in seconds\n  :$control,              # supply to emit control messages on (optional)\n  :$status,               # supply to tap status messages from (optional)\n  :$bleed,                # supply to bleed messages to (optional)\n  :$vent-at,              # bleed when so many buffered (optional)\n  :$scheduler,            # scheduler to use, default $*SCHEDULER\n  --&gt; Supply:D)\n</code></pre></p><p>Produces a Supply from a given Supply, but makes sure the number of messages passed through, is limited.</p><p>It has two modes of operation: per time-unit or by maximum number of execution of a block of code: this is determined by the second positional parameter.</p><p>The first positional parameter specifies the limit that should be applied.</p><p>If the second positional parameter is a Callable, then the limit indicates the maximum number of parallel processes executing the Callable, which is given the value that was received. The emitted values in this case will be the Promises that were obtained from starting the Callable.</p><p>If the second positional parameter is a numeric value, it is interpreted as the time-unit (in seconds). If you specify .1 as the value, then it makes sure you don't exceed the limit for every tenth of a second.</p><p>If the limit is exceeded, then incoming messages are buffered until there is room to pass on / execute the Callable again.</p><p>The third positional parameter is optional: it indicates the number of seconds the throttle will wait before passing on any values.</p><p>The :control named parameter optionally specifies a Supply that you can use to control the throttle while it is in operation. Messages that can be sent, are strings in the form of \"key:value\". Please see below for the types of messages that you can send to control the throttle.</p><p>The :status named parameter optionally specifies a Supply that will receive any status messages. If specified, it will at least send one status message after the original Supply is exhausted. See status message below.</p><p>The :bleed named parameter optionally specifies a Supply that will receive any values that were either explicitly bled (with the bleed control message), or automatically bled (if there's a vent-at active).</p><p>The :vent-at named parameter indicates the number of values that may be buffered before any additional value will be routed to the :bleed Supply. Defaults to 0 if not specified (causing no automatic bleeding to happen). Only makes sense if a :bleed Supply has also been specified.</p><p>The :scheduler named parameter indicates the scheduler to be used. Defaults to $*SCHEDULER.</p>","m":1,"s":{"p":[{"n":"$elems","t":"Any"},{"t":"Any","n":"$seconds"},{"n":"$delay?","t":"Any"},{"n":":$scheduler?","t":"Any"},{"t":"Any","n":":$control"},{"t":"Any","n":":$status"},{"t":"Any","n":":$bleed"},{"n":":$vent-at","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"throttle","k":"m"},{"m":1,"n":"throttle","k":"m","d":"<p><pre><code>method throttle(Supply:D:\n  $limit,                 # values / time or simultaneous processing\n  $seconds or $callable,  # time-unit / code to process simultaneously\n  $delay = 0,             # initial delay before starting, in seconds\n  :$control,              # supply to emit control messages on (optional)\n  :$status,               # supply to tap status messages from (optional)\n  :$bleed,                # supply to bleed messages to (optional)\n  :$vent-at,              # bleed when so many buffered (optional)\n  :$scheduler,            # scheduler to use, default $*SCHEDULER\n  --&gt; Supply:D)\n</code></pre></p><p>Produces a Supply from a given Supply, but makes sure the number of messages passed through, is limited.</p><p>It has two modes of operation: per time-unit or by maximum number of execution of a block of code: this is determined by the second positional parameter.</p><p>The first positional parameter specifies the limit that should be applied.</p><p>If the second positional parameter is a Callable, then the limit indicates the maximum number of parallel processes executing the Callable, which is given the value that was received. The emitted values in this case will be the Promises that were obtained from starting the Callable.</p><p>If the second positional parameter is a numeric value, it is interpreted as the time-unit (in seconds). If you specify .1 as the value, then it makes sure you don't exceed the limit for every tenth of a second.</p><p>If the limit is exceeded, then incoming messages are buffered until there is room to pass on / execute the Callable again.</p><p>The third positional parameter is optional: it indicates the number of seconds the throttle will wait before passing on any values.</p><p>The :control named parameter optionally specifies a Supply that you can use to control the throttle while it is in operation. Messages that can be sent, are strings in the form of \"key:value\". Please see below for the types of messages that you can send to control the throttle.</p><p>The :status named parameter optionally specifies a Supply that will receive any status messages. If specified, it will at least send one status message after the original Supply is exhausted. See status message below.</p><p>The :bleed named parameter optionally specifies a Supply that will receive any values that were either explicitly bled (with the bleed control message), or automatically bled (if there's a vent-at active).</p><p>The :vent-at named parameter indicates the number of values that may be buffered before any additional value will be routed to the :bleed Supply. Defaults to 0 if not specified (causing no automatic bleeding to happen). Only makes sense if a :bleed Supply has also been specified.</p><p>The :scheduler named parameter indicates the scheduler to be used. Defaults to $*SCHEDULER.</p>","s":{"p":[{"n":"$elems","t":"Any"},{"n":"$process","t":"Callable"},{"n":"$delay?","t":"Any"},{"n":":$scheduler?","t":"Any"},{"n":":$control","t":"Any"},{"n":":$status","t":"Any"},{"n":":$bleed","t":"Any"},{"t":"Any","n":":$vent-at"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"share","d":"<p><pre><code>method share(Supply:D: --&gt; Supply:D)</code></pre></p><p>Creates a live supply from an on-demand supply, thus making it possible to share the values of the on-demand supply on multiple taps, instead of each tap seeing its own copy of all values from the on-demand supply.</p><p><pre><code># this says in turn: \"first 1\" \"first 2\" \"second 2\" \"first 3\" \"second 3\"\nmy $s = Supply.interval(1).share;\n$s.tap: { \"first $_\".say };\nsleep 1.1;\n$s.tap: { \"second $_\".say };\nsleep 2</code></pre></p>","k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}]},"n":"BUILDALL"},{"k":"m","s":{"r":"Mu","p":[{"t":"Callable","n":"&mapper"},{"n":":$multi","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!classify","m":0}],"b":"A","mro":["Awaitable","Any"],"d":"<p><pre><code>class Supply {}</code></pre></p><p>A supply is a thread-safe, asynchronous data stream like a Channel, but it can have multiple subscribers (taps) that all get the same values flowing through the supply.</p><p>It is a thread-safe implementation of the Observer Pattern, and central to supporting reactive programming in Raku.</p><p>There are two types of Supplies: live and on demand. When tapping into a live supply, the tap will only see values that are flowing through the supply after the tap has been created. Such supplies are normally infinite in nature, such as mouse movements. Closing such a tap does not stop mouse events from occurring, it just means that the values will go by unseen. All tappers see the same flow of values.</p><p>A tap on an on demand supply will initiate the production of values, and tapping the supply again may result in a new set of values. For example, Supply.interval produces a fresh timer with the appropriate interval each time it is tapped. If the tap is closed, the timer simply stops emitting values to that tap.</p><p>A live Supply is obtained from the Supplier factory method Supply. New values are emitted by calling emit on the Supplier object.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply = $supplier.Supply;\n$supply.tap(-&gt; $v { say \"$v\" });\n$supplier.emit(42); # Will cause the tap to output \"42\"</code></pre></p><p>The live method returns True on live supplies. Factory methods such as interval, from-list will return on demand supplies.</p><p>A live Supply that keeps values until tapped the first time can be created with Supplier::Preserving.</p><p>Further examples can be found in the concurrency page.</p>","k":"c","a":[{"k":"v","t":"Tappable","n":"$!tappable"}]},{"k":"v","t":"Sub","n":"&reverse"},{"k":"s","s":{"p":[{"n":"@a","t":"Positional"}],"r":"Mu"},"m":1,"n":"reverse"},{"k":"s","m":1,"n":"reverse","s":{"r":"Mu","p":[{"n":"+@a","t":"Positional"}]}},{"t":"num32","k":"n","n":"num32"},{"k":"v","d":"<p><pre><code>multi sub infix:&lt;le&gt;(Mu,    Mu)\nmulti sub infix:&lt;le&gt;(Str:D, Str:D)</code></pre></p><p>String less than or equal to operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is equal to or smaller than the second, as determined by lexicographic comparison.</p><p>Mnemonic: less or equal</p>","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<le>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"$x?"}]},"n":"infix:<le>","m":1,"k":"s"},{"n":"infix:<le>","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Blob"},{"t":"Blob","n":"b"}],"r":"Mu"},"n":"infix:<le>"},{"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Str"},{"t":"Str","n":"b"}]},"n":"infix:<le>","m":1},{"m":1,"k":"s","n":"infix:<le>","s":{"p":[{"t":"str","n":"$a"},{"t":"str","n":"$b"}],"r":"Bool:D"}},{"n":"infix:<le>","m":1,"s":{"p":[{"t":"str","n":"$a"},{"t":"str","n":"$b"}],"r":"Bool:D"},"k":"s"},{"b":"A","mro":["Completions","Any"],"m":[{"n":"new","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"compiler"},{"n":"adverbs","t":"Mu"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"compiler"},{"n":"$multi-line-enabled","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"k":"m","m":0,"n":"init"},{"m":0,"k":"m","n":"teardown","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"n":"$code","t":"Any"},{"t":"Any","n":"exception"},{"n":"*%adverbs","t":"Associative"}],"r":"Mu"},"k":"m","n":"repl-eval","m":0},{"m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"interactive_prompt","k":"m"},{"m":0,"s":{"p":[{"t":"Associative","n":"*%adverbs"}],"r":"Mu"},"n":"repl-loop","k":"m"},{"n":"ctxsave","k":"m","m":0,"s":{"r":"Nil","p":[{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"n":"$value","t":"Mu"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"m":0,"k":"m","n":"input-incomplete"},{"k":"m","s":{"p":[{"t":"Mu","n":"$value"},{"n":"*%_","t":"Mu"}],"r":"Bool:D"},"n":"input-toplevel-control","m":0},{"n":"repl-print","s":{"p":[{"t":"Mu","n":"$value"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m","m":0},{"s":{"r":"Str:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"history-file","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"compiler","m":0,"k":"m"},{"s":{"r":"Mu","p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"BUILDALL","k":"s","m":0}],"k":"c","n":"REPL","a":[{"k":"v","t":"Mu","n":"$.compiler"},{"n":"$!multi-line-enabled","k":"v","t":"Bool"},{"k":"v","n":"$!history-file","t":"IO::Path"},{"n":"$!save_ctx","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!need-more-input"},{"k":"v","n":"$!control-not-allowed","t":"Mu"},{"k":"v","t":"Positional","n":"@!completions"}],"t":"REPL"},{"t":"Sub","n":"&take","k":"v"},{"k":"s","n":"take","m":1,"s":{"p":[],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"value"}]},"k":"s","m":1,"n":"take"},{"k":"s","s":{"r":"Mu","p":[{"n":"|","t":"Any"}]},"m":1,"n":"take"},{"k":"v","n":"&infix:<≢>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","n":"infix:<≢>","m":1,"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"Any","n":"b"}]}},{"n":"&cosec","t":"Sub+{is-pure}","k":"v"},{"m":1,"s":{"r":"Mu","p":[{"t":"Numeric","n":"x"}]},"n":"cosec","k":"s"},{"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"n":"cosec","m":1,"k":"s"},{"n":"cosec","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Num","n":"x"}]}},{"d":"<p><pre><code>multi sub infix:&lt;⊉&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Not a superset of nor equal to operator.</p><p>Returns True if $a is not a superset of $b. Equivalent to !(&gt;=).</p><p><pre><code>say (1,2,3) ⊉ (2,3,1); # OUTPUT: «False␤»\nsay (1,2,3) ⊉ (2,3); # OUTPUT: «False␤»\nsay 4 !(&gt;=) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊉ is codepoint U+2289 (NEITHER A SUPERSET OF OR EQUAL TO).</p>","n":"&infix:<⊉>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"k":"s","m":1,"n":"infix:<⊉>","s":{"r":"Bool:D","p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}]}},{"k":"n","n":"uint64","t":"uint64"},{"t":"Rat","m":[{"k":"m","s":{"r":"Rat:D","p":[{"t":"Real","n":"$?"},{"n":"*%_","t":"Mu"}]},"n":"Rat","m":0},{"k":"m","s":{"r":"FatRat:D","p":[{"t":"Real","n":"$?"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"FatRat"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"numerator","m":0},{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"n":"denominator"},{"k":"s","m":0,"s":{"p":[{"t":"Any","n":"@auto"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"BUILDALL"},{"n":"!base","s":{"r":"Str:D","p":[{"n":"$base","t":"Int"},{"t":"int","n":"$digits"},{"n":"$trailing-zeroes","t":"int"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"whole"},{"n":"fract","t":"Any"},{"n":"$digits","t":"int"},{"n":"*%_","t":"Mu"}]},"n":"!STRINGIFY","m":0}],"d":"<p><pre><code>class Rat is Cool does Rational[Int, uint64] { }</code></pre></p><p>Rat objects store rational numbers as a pair of a numerator and denominator. Number literals with a dot but without exponent produce Rats.</p><p><pre><code>say 3.1;          # OUTPUT: «3.1␤»      (same as: Rat.new(31, 10))\nsay 3.1.^name;    # OUTPUT: «Rat␤»\nsay 3.1.nude;     # OUTPUT: «(31 10)␤»\n\nsay &lt;1/2&gt;;        # OUTPUT: «0.5␤»      (same as: Rat.new(1, 2))\nsay &lt;1/2&gt;.^name;  # OUTPUT: «Rat␤»\nsay &lt;1/2&gt;.nude;   # OUTPUT: «(1 2)␤»</code></pre></p><p>Thus arithmetic with short dotted-decimal numbers does not suffer from floating point errors.</p><p>To prevent the numerator and denominator from becoming pathologically large, the denominator is limited to 64 bit storage. On overflow of the denominator a Num (floating-point number) is returned instead.</p><p>For example this function crudely approximates a square root, and overflows the denominator quickly:</p><p><pre><code>sub approx-sqrt($n, $iterations) {\n    my $x = $n;\n    $x = ($x + $n / $x) / 2 for ^$iterations;\n    return $x;\n}\nsay approx-sqrt(2, 5).^name;     # OUTPUT: «Rat␤»\nsay approx-sqrt(2, 10).^name;    # OUTPUT: «Num␤»</code></pre></p><p>If you want arbitrary precision arithmetic with rational numbers, use the FatRat type instead.</p><p>Rat objects are immutable.</p>","k":"c","b":"C","n":"Rat","mro":["Rational[Int,Int]","Real","Numeric","Cool"],"a":[{"n":"$.numerator","t":"Int","k":"v"},{"n":"$.denominator","k":"v","t":"Int"}]},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<~&>","k":"v"},{"m":1,"s":{"p":[],"r":"Mu"},"k":"s","n":"infix:<~&>"},{"s":{"p":[{"t":"Any","n":"$x"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<~&>"},{"n":"infix:<~&>","m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"}},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Blob"},{"n":"b","t":"Blob"}],"r":"Mu"},"n":"infix:<~&>"},{"m":1,"s":{"r":"Str:D","p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}]},"n":"infix:<~&>","k":"s"},{"k":"s","s":{"r":"str","p":[{"t":"str","n":"$a"},{"t":"str","n":"$b"}]},"n":"infix:<~&>","m":1},{"n":"Sub","k":"c","t":"Sub","b":"A","d":"<p><pre><code>class Sub is Routine { }</code></pre></p><p>A type for subroutines and operators. Subs are created with the sub declarator keyword followed by an optional identifier. This short tutorial explains how operators are declared. For details of a sub's parameter list, see Signature.</p><p>Note that subs that go by the same name as coercers will not take precedence over them. Use the &amp;-sigil to call them.</p><p><pre><code>sub Int(Str $s){'what?'};\nsay [Int, Int('42'),&amp;Int('42')];\n# OUTPUT: «[(Int) 42 what?]␤»</code></pre></p><p> Subs can be nested and scoped with my and our, whereby my is the default. A sub declared with my cannot be reached from any outer scope. An our scoped sub will not redefine a sub of the same name in the outer scope. Any sub can be accessed via a closure from any outer scope. For instance, in this example</p><p><pre><code>sub can-be-seener( $whatever ) {\n  my sub can-be-seen ( $objection ) {\n    return $whatever but $objection;\n  }\n  return &amp;can-be-seen\n}\n\nmy $objectioner = can-be-seener( \"Really?\");\nsay $objectioner(42).Int; # OUTPUT: «42␤»</code></pre></p><p>$objectioner will contain the can-be-seen subroutine, even if it has been declared in another scope; calling it with 42 will return \"Really?\" with the number 42 mixed in, as shown in the last sentence.</p>","a":[{"n":"@!dispatchees","k":"v","t":"List"},{"k":"v","t":"Mu","n":"$!dispatcher_cache"},{"k":"v","t":"Mu","n":"$!dispatcher"},{"t":"int","n":"$!flags","k":"v"},{"n":"$!inline_info","k":"v","t":"Mu"},{"k":"v","t":"Mu","n":"$!package"},{"t":"int","k":"v","n":"$!onlystar"},{"n":"@!dispatch_order","t":"List","k":"v"},{"n":"$!dispatch_cache","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!why"},{"t":"Code","k":"v","n":"$!do"},{"t":"Signature","k":"v","n":"$!signature"},{"k":"v","n":"@!compstuff","t":"List"}],"mro":["Callable","Routine"]},{"n":"&infix:<−>","k":"v","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]},"m":1,"k":"s","n":"infix:<−>"},{"n":"infix:<−>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]}},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}],"r":"Mu"},"n":"infix:<−>"},{"k":"s","s":{"r":"Int:D","p":[{"n":"a","t":"Int"},{"n":"b","t":"Int"}]},"m":1,"n":"infix:<−>"},{"m":1,"s":{"p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}],"r":"int"},"n":"infix:<−>","k":"s"},{"s":{"r":"Mu","p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}]},"k":"s","m":1,"n":"infix:<−>"},{"k":"s","n":"infix:<−>","m":1,"s":{"p":[{"n":"$a","t":"num"},{"t":"num","n":"$b"}],"r":"num"}},{"m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Range","n":"r"},{"n":"v","t":"Real"}]},"n":"infix:<−>"},{"s":{"p":[{"n":"a","t":"Rational"},{"n":"b","t":"Rational"}],"r":"Mu"},"m":1,"n":"infix:<−>","k":"s"},{"n":"infix:<−>","m":1,"s":{"r":"Mu","p":[{"t":"Rational","n":"a"},{"n":"b","t":"Int"}]},"k":"s"},{"n":"infix:<−>","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Int","n":"a"},{"n":"b","t":"Rational"}]}},{"s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"t":"Complex","n":"b"}]},"n":"infix:<−>","k":"s","m":1},{"s":{"r":"Complex:D","p":[{"n":"a","t":"Complex"},{"n":"b","t":"Real"}]},"k":"s","n":"infix:<−>","m":1},{"s":{"p":[{"t":"Real","n":"a"},{"t":"Complex","n":"b"}],"r":"Complex:D"},"k":"s","m":1,"n":"infix:<−>"},{"n":"infix:<−>","m":1,"s":{"p":[{"n":"$a","t":"Instant"},{"t":"Instant","n":"$b"}],"r":"Duration:D"},"k":"s"},{"m":1,"s":{"p":[{"t":"Instant","n":"$a"},{"n":"$b","t":"Real"}],"r":"Instant:D"},"n":"infix:<−>","k":"s"},{"m":1,"n":"infix:<−>","k":"s","s":{"p":[{"n":"$a","t":"Duration"},{"n":"$b","t":"Real"}],"r":"Duration:D"}},{"k":"s","s":{"r":"Duration:D","p":[{"n":"$a","t":"Duration"},{"t":"Duration","n":"$b"}]},"n":"infix:<−>","m":1},{"m":1,"s":{"p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}],"r":"Duration:D"},"k":"s","n":"infix:<−>"},{"k":"s","n":"infix:<−>","s":{"p":[{"t":"DateTime","n":"a"},{"t":"Duration","n":"b"}],"r":"DateTime:D"},"m":1},{"s":{"p":[{"t":"Date","n":"date"},{"t":"Int","n":"$x"}],"r":"Date:D"},"k":"s","n":"infix:<−>","m":1},{"m":1,"k":"s","s":{"r":"Int:D","p":[{"n":"$a","t":"Date"},{"t":"Date","n":"$b"}]},"n":"infix:<−>"},{"k":"e","t":"ProtocolFamily","n":"PF_MAX"},{"k":"v","t":"Sub","n":"&shell"},{"k":"s","m":1,"n":"shell","s":{"p":[{"n":"$cmd","t":"Any"},{"n":":$in?","t":"Any"},{"n":":$out?","t":"Any"},{"n":":$err?","t":"Any"},{"n":":$bin","t":"Bool"},{"n":":$chomp?","t":"Bool"},{"t":"Bool","n":":$merge"},{"n":":$enc","t":"Str"},{"n":":$nl?","t":"Str"},{"t":"Any","n":":$cwd?"},{"t":"Any","n":":$env"}],"r":"Mu"}},{"t":"Sub+{is-pure}","k":"v","n":"&log2"},{"m":1,"n":"log2","k":"s","s":{"r":"Mu","p":[{"t":"Numeric","n":"$x"}]}},{"s":{"r":"Mu","p":[{"n":"$x","t":"Cool"}]},"m":1,"n":"log2","k":"s"},{"t":"Sub","n":"&last","k":"v"},{"m":1,"s":{"r":"Nil","p":[]},"n":"last","k":"s"},{"k":"s","m":1,"s":{"r":"Nil","p":[{"n":"x","t":"Label"}]},"n":"last"},{"k":"c","a":[{"t":"Mu","k":"v","n":"$!reified"},{"n":"$!todo","t":"Mu","k":"v"}],"n":"Slip","mro":["Positional","Iterable","List"],"d":"<p><pre><code>class Slip is List {}</code></pre></p><p>A Slip is a List that automatically flattens into an outer List (or other list-like container or iterable).</p><p>For example it allows you to write a map that produces more than one value into the result without nesting:</p><p><pre><code>say &lt;a b c&gt;.map({ ($_, $_.uc).Slip }).join('|');        # OUTPUT: «a|A|b|B|c|C␤»\n</code></pre></p><p>In contrast, when returning an ordinary List, the resulting list is nested:</p><p><pre><code>say &lt;a b c&gt;.map({ $_, $_.uc }).join('|');               # OUTPUT: «a A|b B|c C␤»\n</code></pre></p><p>To create a Slip, either coerce another list-like type to it by calling the Slip method, or use the slip subroutine:</p><p><pre><code># This says \"1\" and then says \"2\", rather than saying \"(1 2)\"\n.say for gather {\n    take slip(1, 2);\n}</code></pre></p><p>A Slip may also be created by using the prefix:&lt;|&gt; operator. This differs from the slip subroutine in both precedence and treatment of single arguments. In fact, prefix:&lt;|&gt; only takes a single argument, so in that way, it behaves closer to the .Slip method than the slip subroutine.</p><p><pre><code>my $l = (1, 2, 3);\nsay (1, slip 2, 3).perl;  # says (1, 2, 3)      , slips 2, 3 into (1, …)\nsay (0, slip $l).perl;    # says (0, $(1, 2, 3)), $l does not break apart\nsay (0, $l.Slip).perl;    # says (0, 1, 2, 3)   , slips from $l into (0, …)\nsay (|$l).perl;           # says slip(1, 2, 3)  , breaks apart $l\nsay (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\nsay (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\nsay (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\nsay (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n</code></pre></p><p>Loops that do not want to produce a value for an iteration use Slips, rather than empty Lists to do so, as do if statements that do not run their blocks.</p><p>Please note that prefix:&lt;|&gt; will also apply parameters in a slippy manner to a routine call. It does not forward a Slip to the called routine, that includes return and take.</p><p><pre><code>my \\l = gather for 1..10 -&gt; $a, $b { take |($a, $b) }; say l.perl;\n# OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»\nmy \\m= gather for 1..10 -&gt; $a, $b { take ($a, $b).Slip }; say m.perl;\n# OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»</code></pre></p>","m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"+args"},{"n":"*%_","t":"Mu"}]},"n":"CALL-ME"}],"b":"C","t":"Slip"},{"n":"SIGWINCH","t":"Signal","k":"e"},{"d":"<p><pre><code>multi sub infix:&lt;⊅&gt;($a,$b --&gt; Bool:D)</code></pre></p><p>Not a superset of operator.</p><p>Returns True if $a is not a strict superset of $b. Equivalent to !(&gt;).</p><p><pre><code>say (1,2,3) ⊅ (2,3,1); # OUTPUT: «True␤»\nsay (1,2,3) ⊅ (2,3); # OUTPUT: «False␤»\nsay 4 !(&gt;) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊅ is codepoint U+2285 (NOT A SUPERSET OF).</p>","n":"&infix:<⊅>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<⊅>","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"m":1,"k":"s"},{"n":"SIGCONT","t":"Signal","k":"e"},{"k":"e","t":"Signal","n":"SIGEMT"},{"n":"uint8","t":"uint8","k":"n"},{"k":"v","n":"&infix:<mod>","t":"Sub+{is-pure}+{Precedence}","d":"<p><pre><code>multi sub infix:&lt;mod&gt;(Int:D $a, Int:D $b --&gt; Int:D)</code></pre></p><p>Integer modulo operator. Returns the remainder of an integer modulo operation.</p>"},{"s":{"p":[{"n":"$a","t":"Real"},{"t":"Real","n":"$b"}],"r":"Mu"},"m":1,"k":"s","n":"infix:<mod>"},{"n":"Callable","k":"ro","m":[{"n":"of","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"returns","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"n":"Capture","k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"d":"<p><pre><code>role Callable { ... }</code></pre></p><p>Role for objects which support calling them. It's used in Block, Routine, Sub, Method, Submethod and Macro types.</p><p>Callables can be stored in &amp;-sigiled containers, the default type constraint of such a container is Callable.</p><p><pre><code>my &amp;a = {;}; # Empty block needs a semicolon\nmy &amp;b = -&gt; {};\nmy &amp;c = sub () {};\nsub foo() {};\nmy &amp;d = &amp;foo;</code></pre></p>","t":"Callable","mro":[],"b":"C"},{"t":"Sub+{is-pure}","k":"v","n":"&infix:«>=»"},{"k":"s","m":1,"s":{"p":[{"n":"$?","t":"Any"}],"r":"Mu"},"n":"infix:«>=»"},{"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"n":"infix:«>=»","k":"s","m":1},{"n":"infix:«>=»","s":{"p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"n":"infix:«>=»","s":{"p":[{"n":"a","t":"Int"},{"t":"Int","n":"b"}],"r":"Bool:D"}},{"n":"infix:«>=»","m":1,"s":{"p":[{"t":"int","n":"$a"},{"t":"int","n":"$b"}],"r":"Bool:D"},"k":"s"},{"s":{"p":[{"n":"a","t":"Num"},{"n":"b","t":"Num"}],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«>=»"},{"m":1,"k":"s","s":{"p":[{"n":"$a","t":"num"},{"n":"$b","t":"num"}],"r":"Bool:D"},"n":"infix:«>=»"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Rational"},{"t":"Rational","n":"b"}]},"n":"infix:«>=»","k":"s","m":1},{"m":1,"n":"infix:«>=»","s":{"p":[{"n":"a","t":"Rational"},{"n":"b","t":"Int"}],"r":"Bool:D"},"k":"s"},{"n":"infix:«>=»","k":"s","s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Rational"}],"r":"Bool:D"},"m":1},{"m":1,"s":{"r":"Bool:D","p":[{"n":"$a","t":"Instant"},{"n":"$b","t":"Instant"}]},"n":"infix:«>=»","k":"s"},{"s":{"p":[{"t":"DateTime","n":"a"},{"n":"b","t":"DateTime"}],"r":"Bool:D"},"m":1,"n":"infix:«>=»","k":"s"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"Date"},{"t":"Date","n":"$b"}]},"n":"infix:«>=»","k":"s","m":1},{"k":"s","m":1,"n":"infix:«>=»","s":{"p":[{"n":"a","t":"Version"},{"n":"b","t":"Version"}],"r":"Mu"}},{"k":"e","n":"SIGPIPE","t":"Signal"},{"mro":[],"t":"Dateish","d":"<p><pre><code>role Dateish { ... }</code></pre></p><p>Both Date and DateTime support accessing a year, month and day-of-month, as well as related functionality such as calculating the day of the week.</p>","k":"ro","b":"C","n":"Dateish","m":[{"m":0,"s":{"r":"IO::Path:D","p":[{"n":"*%_","t":"Mu"}]},"k":"m","n":"IO"},{"s":{"p":[{"n":"dateish","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"CALL-ME"},{"d":"<p>Defined as:</p><p><pre><code>method is-leap-year(--&gt; Bool:D)</code></pre></p><p>Returns True if the year of the Dateish object is a leap year.</p><p><pre><code>say DateTime.new(:year&lt;2016&gt;).is-leap-year; # OUTPUT: «True␤»\nsay Date.new(\"1900-01-01\").is-leap-year;    # OUTPUT: «False␤»</code></pre></p>","n":"is-leap-year","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool:D"},"k":"m"},{"m":0,"n":"days-in-month","s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method days-in-month(Dateish:D: --&gt; Int:D)</code></pre></p><p>Returns the number of days in the month represented by the Dateish object:</p><p><pre><code>say Date.new(\"2016-01-02\").days-in-month;                # OUTPUT: «31␤»\nsay DateTime.new(:year&lt;10000&gt;, :month&lt;2&gt;).days-in-month; # OUTPUT: «29␤»</code></pre></p>","k":"m"},{"k":"m","d":"<p>Defined as:</p><p><pre><code>method daycount(Dateish:D: --&gt; Int:D)</code></pre></p><p>Returns the number of days from the epoch Nov. 17, 1858 to the day of the invocant. The daycount returned by this method is the MJD, i.e. the Modified Julian Day, which is used routinely by e.g. astronomers, geodesists, scientists and others. The MJD convention is designed to facilitate simplified chronological calculations.</p><p><pre><code>say Date.new('1995-09-27').daycount;    # OUTPUT: «49987␤»</code></pre></p>","n":"daycount","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"}},{"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method day-of-month(Date:D: --&gt; Int:D)</code></pre></p><p>Returns the day of the month of the date (1..31). Synonymous to the day method.</p><p><pre><code>say Date.new('2015-12-31').day-of-month;                                  # OUTPUT: «31␤»\nsay DateTime.new(date =&gt; Date.new('2015-12-24'), hour =&gt; 1).day-of-month; # OUTPUT: «24␤»</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"},"n":"day-of-month"},{"n":"day-of-week","d":"<p>Defined as:</p><p><pre><code>method day-of-week(Date:D: --&gt; Int:D)</code></pre></p><p>Returns the day of the week, where 1 is Monday, 2 is Tuesday and Sunday is 7.</p><p><pre><code>say Date.new('2015-12-31').day-of-week;                                  # OUTPUT: «4␤»\nsay DateTime.new(date =&gt; Date.new('2015-12-24'), hour =&gt; 1).day-of-week; # OUTPUT: «4␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"m":0,"k":"m"},{"k":"m","m":0,"n":"week","d":"<p>Defined as:</p><p><pre><code>method week()</code></pre></p><p>Returns a list of two integers: the year, and the week number. This is because at the start or end of a year, the week may actually belong to the other year.</p><p><pre><code>my ($year, $week) = Date.new(\"2014-12-31\").week;\nsay $year;                       # OUTPUT: «2015␤»\nsay $week;                       # OUTPUT: «1␤»\nsay Date.new('2015-01-31').week; # OUTPUT: «(2015 5)␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","d":"<p>Defined as:</p><p><pre><code>method week-year(Date:D: --&gt; Int:D)</code></pre></p><p>Returns the week year of the date specified by the invocant. Normally week-year is equal to Date.year. Note however that dates early in January often end up in the last week of the prior year, and similarly, the final few days of December may be placed in the first week of the next year.</p><p><pre><code>say Date.new(\"2015-11-15\").week-year;   # 2015\nsay Date.new(\"2014-12-31\").week-year;   # 2015 (date belongs to the first week of 2015)\nsay Date.new(\"2016-01-02\").week-year;   # 2015 (date belongs to the last week of 2015)</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"week-year"},{"s":{"r":"Int:D","p":[{"t":"Mu","n":"*%_"}]},"n":"week-number","k":"m","d":"<p>Defined as:</p><p><pre><code>method week-number(Date:D: --&gt; Int:D)</code></pre></p><p>Returns the week number (1..53) of the date specified by the invocant. The first week of the year is defined by ISO as the one which contains the fourth day of January. Thus, dates early in January often end up in the last week of the prior year, and similarly, the final few days of December may be placed in the first week of the next year.</p><p><pre><code>say Date.new(\"2014-12-31\").week-number;   # 1  (first week of 2015)\nsay Date.new(\"2016-01-02\").week-number;   # 53 (last week of 2015)</code></pre></p>","m":0},{"m":0,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method weekday-of-month(Date:D: --&gt; Int:D)</code></pre></p><p>Returns a number (1..5) indicating the number of times a particular day-of-week has occurred so far during that month, the day itself included.</p><p><pre><code>say Date.new(\"2003-06-09\").weekday-of-month;  # 2  (second Monday of the month)</code></pre></p>","n":"weekday-of-month","k":"m"},{"n":"day-of-year","m":0,"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method day-of-year(Date:D: --&gt; Int:D)</code></pre></p><p>Returns the day of the year (1..366).</p><p><pre><code>say Date.new('2015-12-31').day-of-year;                                  # OUTPUT: «365␤»\nsay DateTime.new(date =&gt; Date.new('2015-03-24'), hour =&gt; 1).day-of-year; # OUTPUT: «83␤»</code></pre></p>","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method yyyy-mm-dd(Date:D: --&gt; Str:D)\n</code></pre></p><p>Returns the date in YYYY-MM-DD format (ISO 8601)</p><p><pre><code>say Date.new(\"2015-11-15\").yyyy-mm-dd;   # OUTPUT: «2015-11-15␤»\nsay DateTime.new(1470853583).yyyy-mm-dd; # OUTPUT: «2016-08-10␤»\n</code></pre></p>","m":0,"s":{"p":[{"n":"$sep?","t":"str"},{"n":"*%_","t":"Mu"}],"r":"Str:D"},"n":"yyyy-mm-dd","k":"m"},{"n":"dd-mm-yyyy","k":"m","m":0,"s":{"r":"Str:D","p":[{"n":"$sep?","t":"str"},{"n":"*%_","t":"Mu"}]}},{"n":"mm-dd-yyyy","k":"m","m":0,"s":{"r":"Str:D","p":[{"n":"$sep?","t":"str"},{"t":"Mu","n":"*%_"}]}},{"n":"earlier","m":0,"s":{"p":[{"n":"*%unit","t":"Associative"}],"r":"Mu"},"k":"m"},{"n":"!year-Str","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Str:D"},"k":"m"},{"n":"!calculate-daycount","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"t":"int","n":"$daycount"},{"t":"Any","n":"year"},{"n":"month","t":"Any"},{"t":"Any","n":"day"},{"n":"*%_","t":"Mu"}],"r":"Nil"},"n":"!ymd-from-daycount","m":0,"k":"m"},{"s":{"p":[{"t":"Any","n":"year"},{"n":"month","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Int:D"},"n":"!DAYS-IN-MONTH","m":0,"k":"m"},{"k":"m","s":{"r":"Mu","p":[{"t":"Any","n":"$what"},{"n":"$got","t":"Any"},{"n":"$range","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"!oor","m":0},{"m":0,"n":"!tif","k":"m","s":{"r":"Mu","p":[{"n":"$invalid-str","t":"Any"},{"n":"$target","t":"Any"},{"t":"Any","n":"$format"},{"t":"Mu","n":"*%_"}]}},{"n":"!SET-DAYCOUNT","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"$unit","t":"Cool"},{"t":"Associative","n":"%parts?"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"!truncate-ymd","k":"m"}],"a":[{"n":"$.year","t":"int","k":"v"},{"t":"int","k":"v","n":"$.month"},{"k":"v","t":"int","n":"$.day"},{"t":"int","k":"v","n":"$.daycount"},{"k":"v","n":"&.formatter","t":"Callable"}]},{"t":"Sub+{is-pure}","n":"&infix:<≽>","k":"v"},{"n":"infix:<≽>","m":1,"s":{"p":[{"n":"$a","t":"Any"},{"n":"$b","t":"Any"}],"r":"Bool:D"},"k":"s"},{"t":"Signal","k":"e","n":"SIGINT"},{"k":"v","t":"Sub+{is-pure}","n":"&infix:«<=»"},{"m":1,"n":"infix:«<=»","s":{"p":[{"t":"Any","n":"$?"}],"r":"Mu"},"k":"s"},{"n":"infix:«<=»","k":"s","m":1,"s":{"p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}],"r":"Mu"}},{"n":"infix:«<=»","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Real"},{"t":"Real","n":"b"}]},"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}],"r":"Bool:D"},"n":"infix:«<=»"},{"k":"s","m":1,"s":{"r":"Bool:D","p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}]},"n":"infix:«<=»"},{"s":{"r":"Bool:D","p":[{"t":"Num","n":"a"},{"t":"Num","n":"b"}]},"n":"infix:«<=»","k":"s","m":1},{"n":"infix:«<=»","k":"s","s":{"r":"Bool:D","p":[{"t":"num","n":"$a"},{"n":"$b","t":"num"}]},"m":1},{"k":"s","s":{"r":"Bool:D","p":[{"t":"Rational","n":"a"},{"t":"Rational","n":"b"}]},"n":"infix:«<=»","m":1},{"s":{"p":[{"n":"a","t":"Rational"},{"t":"Int","n":"b"}],"r":"Bool:D"},"k":"s","n":"infix:«<=»","m":1},{"m":1,"s":{"p":[{"n":"a","t":"Int"},{"n":"b","t":"Rational"}],"r":"Bool:D"},"n":"infix:«<=»","k":"s"},{"s":{"r":"Bool:D","p":[{"n":"$a","t":"Instant"},{"t":"Instant","n":"$b"}]},"k":"s","n":"infix:«<=»","m":1},{"k":"s","m":1,"n":"infix:«<=»","s":{"r":"Bool:D","p":[{"n":"a","t":"DateTime"},{"n":"b","t":"DateTime"}]}},{"m":1,"k":"s","s":{"r":"Bool:D","p":[{"n":"$a","t":"Date"},{"n":"$b","t":"Date"}]},"n":"infix:«<=»"},{"s":{"r":"Mu","p":[{"t":"Version","n":"a"},{"t":"Version","n":"b"}]},"n":"infix:«<=»","k":"s","m":1},{"k":"c","a":[{"n":"$!parts","k":"v","t":"Mu"},{"t":"int","n":"$!plus","k":"v"},{"k":"v","n":"$!whatever","t":"int"},{"k":"v","n":"$!string","t":"str"}],"b":"A","n":"Version","mro":["Any"],"d":"<p><pre><code>class Version { }</code></pre></p><p>Version objects identify version of software components (and potentially other entities). Raku uses them internally for versioning modules.</p><p></p><p>A version consists of several parts, which are visually represented by joining them with a dot. A version part is usually an integer, a string like alpha, or a Whatever-star *. The latter is used to indicate that any version part is acceptable in another version that is compared to the current one.</p><p><pre><code>say v1.0.1 ~~ v1.*;     # OUTPUT: «True␤»\nsay v1.0.1 ~~ v1.*.1;   # OUTPUT: «True␤»</code></pre></p><p>The first part of version literals contains v and a number; this might be followed by alphanumeric and Whatever parts and trailed by +. Multiple parts are separate with a dot .. A trailing + indicates that higher versions are OK in comparisons:</p><p><pre><code>say v1.2 ~~ v1.0;                 # OUTPUT: «False␤»\nsay v1.2 ~~ v1.0+;                # OUTPUT: «True␤»\nsay v0.and.anything.else ~~ v0+;  # OUTPUT: «True␤»</code></pre></p><p>In comparisons, order matters, and every part is compared in turn.</p><p><pre><code>say v1.2 cmp v2.1;      # OUTPUT: «Less␤»</code></pre></p><p>The + suffix is always taken into account in comparisons:</p><p><pre><code>say v1.0.1+ &lt;=&gt; v1.0.1; # OUTPUT: «More␤»</code></pre></p><p>And * (Whatever) is too, and considered always Less than whatever digit is in the corresponding part, even if * is trailed by +:</p><p><pre><code>say v1.* &lt;=&gt; v1.0;      # OUTPUT: «Less␤»\nsay v1.* &lt;= v1.0;       # OUTPUT: «True␤»\nsay v1.*+ &lt;= v1.0;      # OUTPUT: «True␤»</code></pre></p><p>Please note that method calls, including pseudo methods like WHAT, require version literals either to be enclosed with parentheses or use some other method to separate them from the dot that denotes a method call, like in these examples:</p><p><pre><code>say (v0.and.some.*.stuff).parts;  # OUTPUT: «(0 and some * stuff)␤»\nsay v0.and.some.*.stuff .parts;   # OUTPUT: «(0 and some * stuff)␤»</code></pre></p>","t":"Version","m":[{"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Capture","m":0},{"d":"<p><pre><code>method parts(Version:D: --&gt; List:D)</code></pre></p><p>Returns the list of parts that make up this Version object</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = v1.0.1+;\nsay $v1.parts;                                    # OUTPUT: «(1 0 1)␤»\nsay $v2.parts;                                    # OUTPUT: «(1 0 1)␤»</code></pre></p><p>The + suffix is not considered a part of the Version object, and thus not returned by this method, as shown above in the $v2 variable.</p>","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"parts","m":0},{"m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"d":"<p><pre><code>method plus(Version:D: --&gt; Bool:D)</code></pre></p><p>Returns True if comparisons against this version allow larger versions too.</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = v1.0.1+;\nsay $v1.plus;                                     # OUTPUT: «False␤»\nsay $v2.plus;                                     # OUTPUT: «True␤»</code></pre></p>","n":"plus","k":"m"},{"m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"whatever","k":"m"},{"n":"Version","k":"m","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"!SLOW-NEW","s":{"p":[{"n":"$s","t":"str"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"!SET-SELF","m":0,"k":"m","s":{"p":[{"n":"parts","t":"Any"},{"n":"plus","t":"Any"},{"n":"whatever","t":"Any"},{"n":"string","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}]},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:«=>»","k":"v"},{"k":"s","m":1,"n":"infix:«=>»","s":{"p":[{"t":"Mu","n":"$key"},{"t":"Mu","n":"value"}],"r":"Mu"}},{"k":"v","t":"Sub","n":"&chdir"},{"m":1,"n":"chdir","s":{"p":[{"t":"Any","n":"c"}],"r":"Mu"},"k":"s"},{"d":"<p><pre><code>class Lock {}</code></pre></p><p>A Lock is a low-level concurrency control construct. It provides mutual exclusion, meaning that only one thread may hold the lock at a time. Once the lock is unlocked, another thread may then lock it.</p><p>A Lock is typically used to protect access to one or more pieces of state. For example, in this program:</p><p><pre><code>my $x = 0;\nmy $l = Lock.new;\nawait (^10).map: {\n    start {\n        $l.protect({ $x++ });\n    }\n}\nsay $x;         # OUTPUT: «10␤»</code></pre></p><p>The Lock is used to protect operations on $x. An increment is not an atomic operation; without the lock, it would be possible for two threads to both read the number 5 and then both store back the number 6, thus losing an update. With the use of the Lock, only one thread may be running the increment at a time.</p><p>A Lock is re-entrant, meaning that a thread that holds the lock can lock it again without blocking. That thread must unlock the same number of times before the lock can be obtained by another thread (it works by keeping a recursion count).</p><p>It's important to understand that there is no direct connection between a Lock and any particular piece of data; it is up to the programmer to ensure that the Lock is held during all operations that involve the data in question. The OO::Monitors module, while not a complete solution to this problem, does provide a way to avoid dealing with the lock explicitly and encourage a more structured approach.</p><p>The Lock class is backed by operating-system provided constructs, and so a thread that is waiting to acquire a lock is, from the point of view of the operating system, blocked.</p><p>Code using high-level Raku concurrency constructs should avoid using Lock. Waiting to acquire a Lock blocks a real Thread, meaning that the thread pool (used by numerous higher-level Raku concurrency mechanisms) cannot use that thread in the meantime for anything else.</p><p>Any await performed while a Lock is held will behave in a blocking manner; the standard non-blocking behavior of await relies on the code following the `await` resuming on a different Thread from the pool, which is incompatible with the requirement that a Lock be unlocked by the same thread that locked it. See Lock::Async for an alternative mechanism that does not have this shortcoming.</p><p>By their nature, Locks are not composable, and it is possible to end up with hangs should circular dependencies on locks occur. Prefer to structure concurrent programs such that they communicate results rather than modify shared data structures, using mechanisms like Promise, Channel and Supply.</p>","k":"c","mro":["Any"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"new"},{"n":"lock","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","d":"<p>Defined as:</p><p><pre><code>method lock(Lock:D:)</code></pre></p><p>Acquires the lock. If it is currently not available, waits for it.</p><p><pre><code>my $l = Lock.new;\n$l.lock;</code></pre></p><p>Since a Lock is implemented using OS-provided facilities, a thread waiting for the lock will not be scheduled until the lock is available for it. Since Lock is re-entrant, if the current thread already holds the lock, calling lock will simply bump a recursion count.</p><p>While it's easy enough to use the lock method, it's more difficult to correctly use unlock. Instead, prefer to use the protect method instead, which takes care of making sure the lock/unlock calls always both occur.</p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method unlock(Lock:D:)</code></pre></p><p>Releases the lock.</p><p><pre><code>my $l = Lock.new;\n$l.lock;\n$l.unlock;</code></pre></p><p>It is important to make sure the Lock is always released, even if an exception is thrown. The safest way to ensure this is to use the protect method, instead of explicitly calling lock and unlock. Failing that, use a LEAVE phaser.</p><p><pre><code>my $l = Lock.new;\n{\n    $l.lock;\n    LEAVE $l.unlock;\n}</code></pre></p>","m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"unlock"},{"n":"protect","k":"m","d":"<p>Defined as:</p><p><pre><code>method protect(Lock:D: &amp;code)</code></pre></p><p>Obtains the lock, runs &amp;code, and releases the lock afterwards. Care is taken to make sure the lock is released even if the code is left through an exception.</p><p>Note that the Lock itself needs to be created outside the portion of the code that gets threaded and it needs to protect. In the first example below, Lock is first created and assigned to $lock, which is then used inside the Promises to protect the sensitive code. In the second example, a mistake is made: the Lock is created right inside the Promise, so the code ends up with a bunch of separate locks, created in a bunch of threads, and thus they don't actually protect the code we want to protect.</p><p><pre><code># Right: $lock is instantiated outside the portion of the\n# code that will get threaded and be in need of protection\nmy $lock = Lock.new;\nawait ^20 .map: {\n    start {\n        $lock.protect: {\n            print \"Foo\";\n            sleep rand;\n            say \"Bar\";\n        }\n    }\n}\n\n# !!! WRONG !!! Lock is created inside threaded area!\nawait ^20 .map: {\n    start {\n        Lock.new.protect: {\n            print \"Foo\"; sleep rand; say \"Bar\";\n        }\n    }\n}</code></pre></p>","m":1,"s":{"p":[{"n":"&code","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"condition"}],"t":"Lock","n":"Lock","b":"A"},{"a":[{"n":"$!holder","k":"v","t":"Lock::Async::Holder"}],"t":"Lock::Async","mro":["Any"],"n":"Lock::Async","k":"c","b":"A","d":"<p><pre><code>class Lock::Async {}</code></pre></p><p>A Lock::Async instance provides a mutual exclusion mechanism: when the lock is held, any other code wishing to lock must wait until the holder calls unlock.</p><p>Unlike Lock, which provides a traditional OS-backed mutual exclusion mechanism, Lock::Async works with the high-level concurrency features of Raku. The lock method returns a Promise, which will be kept when the lock is available. This Promise can be used with non-blocking await. This means that a thread from the thread pool need not be consumed while waiting for the Lock::Async to be available, and the code trying to obtain the lock will be resumed once it is available.</p><p>The result is that it's quite possible to have many thousands of outstanding Lock::Async lock requests, but just a small number of threads in the pool. Attempting that with a traditional Lock would not go so well!</p><p>There is no requirement that a Lock::Async is locked and unlocked by the same physical thread, meaning it is possible to do a non-blocking await while holding the lock. The flip side of this is Lock::Async is not re-entrant.</p><p>While Lock::Async works in terms of higher-level Raku concurrency mechanisms, it should be considered a building block. Indeed, it lies at the heart of the Supply concurrency model. Prefer to structure programs so that they communicate results rather than mutate shared data structures, using mechanisms like Promise, Channel and Supply.</p>","m":[{"k":"m","n":"lock","s":{"r":"Promise","p":[{"n":"*%_","t":"Mu"}]},"d":"<p>Defined as:</p><p><pre><code>method lock(Lock::Async:D: --&gt; Promise:D)</code></pre></p><p>Returns a Promise that will be kept when the lock is available. In the case that the lock is already available, an already kept Promise will be returned. Use await to wait for the lock to be available in a non-blocking manner.</p><p><pre><code>my $l = Lock::Async.new;\nawait $l.lock;</code></pre></p><p>Prefer to use protect instead of explicit calls to lock and unlock.</p>","m":0},{"d":"<p>Defined as:</p><p><pre><code>method unlock(Lock::Async:D: --&gt; Nil)</code></pre></p><p>Releases the lock. If there are any outstanding lock Promises, the one at the head of the queue will then be kept, and potentially code scheduled on the thread pool (so the cost of calling unlock is limited to the work needed to schedule another piece of code that wants to obtain the lock, but not to execute that code).</p><p><pre><code>my $l = Lock::Async.new;\nawait $l.lock;\n$l.unlock;</code></pre></p><p>Prefer to use protect instead of explicit calls to lock and unlock. However, if wishing to use the methods separately, it is wise to use a LEAVE block to ensure that unlock is reliably called. Failing to unlock will mean that nobody can ever lock this particular Lock::Async instance again.</p><p><pre><code>my $l = Lock::Async.new;\n{\n    await $l.lock;\n    LEAVE $l.unlock;\n}</code></pre></p>","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"unlock","k":"m"},{"d":"<p>Defined as:</p><p><pre><code>method protect(Lock::Async:D: &amp;code)</code></pre></p><p>Calls lock, does an await to wait for the lock to be available, and reliably calls unlock afterwards, even if the code throws an exception.</p><p>Note that the Lock::Async itself needs to be created outside the portion of the code that gets threaded and it needs to protect. In the first example below, Lock::Async is first created and assigned to $lock, which is then used inside the Promises to protect the sensitive code. In the second example, a mistake is made, the Lock::Async is created right inside the Promise, so the code ends up with a bunch of separate locks, created in a bunch of threads, and thus they don't actually protect the code we want to protect.</p><p><pre><code># Right: $lock is instantiated outside the portion of the\n# code that will get threaded and be in need of protection\nmy $lock = Lock::Async.new;\nawait ^20 .map: {\n    start {\n        $lock.protect: {\n            print \"Foo\";\n            sleep rand;\n            say \"Bar\";\n        }\n    }\n}\n\n# !!! WRONG !!! Lock::Async is instantiated inside threaded area!\nawait ^20 .map: {\n    start {\n        my $lock = Lock::Async.new;\n        $lock.protect: {\n            print \"Foo\"; sleep rand; say \"Bar\";\n        }\n    }\n}</code></pre></p>","n":"protect","m":1,"s":{"p":[{"n":"&code","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"&code","t":"Callable"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"protect-or-queue-on-recursion","k":"m","d":"<p>Defined as:</p><p><pre><code>method protect-or-queue-on-recursion(Lock::Async:D: &amp;code)</code></pre></p><p>When calling protect on a Lock::Async instance that is already locked, the method is forced to block until the lock gets unlocked. protect-or-queue-on-recursion avoids this issue by either behaving the same as protect if the lock is unlocked or the lock was locked by something outside the caller chain, returning Nil, or queueing the call to &amp;code and returning a Promise if the lock had already been locked at another point in the caller chain.</p><p><pre><code>my Lock::Async $lock .= new;\nmy Int         $count = 0;\n\n# The lock is unlocked, so the code runs instantly.\n$lock.protect-or-queue-on-recursion({\n    $count++\n});\n\n# Here, we have caller recursion. The outer call only returns a Promise\n# because the inner one does. If we try to await the inner call's Promise\n# from the outer call, the two calls will block forever since the inner\n# caller's Promise return value is just the outer's with a then block.\n$lock.protect-or-queue-on-recursion({\n    $lock.protect-or-queue-on-recursion({\n        $count++\n    }).then({\n        $count++\n    })\n});\n\n# Here, the lock is locked, but not by anything else on the caller chain.\n# This behaves just like calling protect would in this scenario.\nfor 0..^2 {\n    $lock.protect-or-queue-on-recursion({\n        $count++;\n    });\n}\n\nsay $count; # OUTPUT: 5</code></pre></p>","m":0},{"k":"m","n":"with-lock-hidden-from-recursion-check","m":0,"s":{"p":[{"t":"Callable","n":"&code"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"BUILDALL","k":"s"},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"IterationBuffer","n":"rec-list"},{"n":"*%_","t":"Mu"}]},"n":"!search-recursion-list"},{"n":"!run-with-updated-recursion-list","k":"m","s":{"p":[{"n":"&code","t":"Callable"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0},{"m":0,"k":"m","n":"!run-under-recursion-list","s":{"r":"Mu","p":[{"n":"$*LOCK-ASYNC-RECURSION-LIST","t":"IterationBuffer"},{"n":"&code","t":"Callable"},{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!on-recursion-list","k":"m","m":0},{"m":0,"n":"!hidden-in-recursion-list","k":"m","s":{"r":"Mu","p":[{"n":"current","t":"IterationBuffer"},{"n":"&code","t":"Callable"},{"n":"*%_","t":"Mu"}]}}]},{"n":"Lock::ConditionVariable","mro":["Any"],"k":"c","b":"A","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"new","m":0,"k":"m"},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"m","n":"wait"},{"n":"signal","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"n":"signal_all"}],"t":"Lock::ConditionVariable"},{"k":"c","n":"VM","t":"VM","m":[{"s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]},"n":"TWEAK","k":"s","m":0},{"s":{"p":[{"n":"$library","t":"IO::Path"},{"n":":$version","t":"Version"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0,"n":"platform-library-name"},{"n":"osname","k":"m","d":"<p>Defined as:</p><p><pre><code>multi method osname(VM:U:)\nmulti method osname(VM:D:)</code></pre></p><p>Instance / Class method returning the name of the Operating System, as known by the configuration of the VM object / currently running virtual machine.</p>","m":1,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"d":"<p>Defined as:</p><p><pre><code>multi method osname(VM:U:)\nmulti method osname(VM:D:)</code></pre></p><p>Instance / Class method returning the name of the Operating System, as known by the configuration of the VM object / currently running virtual machine.</p>","m":1,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"osname"},{"n":"request-garbage-collection","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Nil"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"config"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"prefix","m":0,"k":"m"},{"m":0,"d":"<p>Instance method returning a string of the extension that should be used for precompiled files of the VM object.</p>","n":"precomp-ext","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"precomp-target","d":"<p>Instance method returning a string of the value of the compilation target that should be used when precompiling source-files with the VM object.</p>"},{"n":"name","k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"m":0},{"k":"m","n":"auth","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0},{"m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"version","k":"m"},{"m":0,"n":"signature","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"desc"},{"n":"BUILDALL","m":0,"s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"s"}],"mro":["Systemic","Any"],"a":[{"n":"$.config","t":"Mu","k":"v"},{"t":"Mu","n":"$.prefix","k":"v"},{"n":"$.precomp-ext","k":"v","t":"Mu"},{"n":"$.precomp-target","k":"v","t":"Mu"},{"k":"v","t":"Str","n":"$.name"},{"k":"v","t":"Str","n":"$.auth"},{"t":"Version","n":"$.version","k":"v"},{"n":"$.signature","t":"Blob","k":"v"},{"k":"v","t":"Str","n":"$.desc"}],"d":"<p><pre><code>class VM does Systemic { }</code></pre></p><p>Built-in class for providing information about the virtual machine in which Raku is running. Usually accessed through the $*VM dynamic variable.</p>","b":"A"},{"d":"<p><pre><code>multi sub infix:&lt;(.)&gt;(**@p)\nmulti sub infix:&lt;⊍&gt;(**@p)</code></pre></p><p>Baggy multiplication operator.</p><p>Returns the Baggy multiplication of its arguments, i.e., a Bag that contains each element of the arguments with the weights of the element across the arguments multiplied together to get the new weight. Returns a Mix if any of the arguments is a Mixy.</p><p><pre><code>say &lt;a b c&gt; (.) &lt;a b c d&gt;; # OUTPUT: «Bag(a, b, c)␤»\n                           # Since 1 * 0 == 0, in the case of 'd'\nsay &lt;a a b c a d&gt; ⊍ bag(&lt;a a b c c&gt;); # OUTPUT: «Bag(a(6), b, c(2))␤»\n</code></pre></p><p>⊍ is equivalent to (.), at codepoint U+228D (MULTISET MULTIPLICATION).</p>","t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<(.)>"},{"s":{"p":[],"r":"Mu"},"n":"infix:<(.)>","k":"s","m":1},{"m":1,"k":"s","n":"infix:<(.)>","s":{"p":[{"t":"Setty","n":"a"}],"r":"Mu"}},{"s":{"p":[{"t":"Baggy","n":"a"}],"r":"Mu"},"k":"s","n":"infix:<(.)>","m":1},{"n":"infix:<(.)>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Setty"}]},"m":1},{"n":"infix:<(.)>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"t":"Mixy","n":"b"}]},"m":1},{"k":"s","n":"infix:<(.)>","m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}]}},{"m":1,"n":"infix:<(.)>","k":"s","s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Any"}],"r":"Mu"}},{"s":{"p":[{"n":"a","t":"Setty"},{"t":"Mixy","n":"b"}],"r":"Mu"},"n":"infix:<(.)>","m":1,"k":"s"},{"n":"infix:<(.)>","m":1,"k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"t":"Mixy","n":"b"}],"r":"Mu"}},{"k":"s","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Mixy"}],"r":"Mu"},"n":"infix:<(.)>"},{"m":1,"n":"infix:<(.)>","s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Baggy"}]},"k":"s"},{"s":{"r":"Mu","p":[{"n":"$","t":"Any"},{"n":"b","t":"Failure"}]},"m":1,"n":"infix:<(.)>","k":"s"},{"s":{"p":[{"n":"a","t":"Failure"},{"t":"Any","n":"$"}],"r":"Mu"},"m":1,"n":"infix:<(.)>","k":"s"},{"n":"infix:<(.)>","m":1,"s":{"p":[{"t":"Any","n":"a"},{"n":"b","t":"Any"}],"r":"Mu"},"k":"s"},{"n":"infix:<(.)>","s":{"r":"Mu","p":[{"n":"+@p","t":"Positional"}]},"k":"s","m":1},{"t":"Bool","n":"False","k":"e"},{"mro":["Associative"],"d":"<p><pre><code>role QuantHash does Associative { }</code></pre></p><p>The QuantHash role provides the basic functionality shared by the Setty, Baggy and Mixy roles. These provide object hashes of which the values are limited in some way.</p><p>QuantHashes are what set operators use internally.</p>","t":"QuantHash","b":"C","k":"ro","m":[{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","d":"<p><pre><code>method keyof()</code></pre></p><p>Returns the type of value a key of this QuantHash may have. This is typically Mu.</p>","n":"keyof","m":0},{"s":{"r":"Int:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Int","k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Num:D"},"n":"Num","m":0,"k":"m"},{"s":{"r":"Numeric:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Numeric","m":0,"k":"m"},{"m":0,"s":{"r":"Real:D","p":[{"n":"*%_","t":"Mu"}]},"n":"Real","k":"m"},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"Capture","m":0,"k":"m"},{"n":"fmt","s":{"p":[{"n":"$format?","t":"Cool"},{"n":"$sep?","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"d":"<p><pre><code>method hash()</code></pre></p><p>Coerces the QuantHash object to a Hash (by stringifying the objects for the keys) with the values of the hash limited to the same limitation as QuantHash, and returns that.</p>","m":0,"k":"m","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"hash"},{"n":"Hash","d":"<p><pre><code>method Hash()</code></pre></p><p>Coerces the QuantHash object to a Hash (by stringifying the objects for the keys) without any limitations on the values, and returns that.</p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m","m":0}],"n":"QuantHash"},{"k":"e","n":"SIGALRM","t":"Signal"},{"k":"c","n":"ObjAt","d":"<p><pre><code>class ObjAt is Any {}</code></pre></p><p>Objects of type ObjAt are the return value of .WHICH calls on other objects, and identify an object uniquely.</p><p>If two objects compare equally via ===, their .WHICH methods return the same ObjAt object.</p><p>See also ValueObjAt for value types.</p>","t":"ObjAt","mro":["Any"],"m":[{"m":0,"n":"new","k":"m","s":{"p":[{"n":"$s","t":"str"},{"n":"*%_","t":"Mu"}],"r":"Mu"}}],"b":"A"},{"t":"Sub+{is-pure}","n":"&acotan","k":"v"},{"n":"acotan","m":1,"s":{"p":[{"t":"Numeric","n":"x"}],"r":"Mu"},"k":"s"},{"k":"s","s":{"r":"Mu","p":[{"t":"Cool","n":"x"}]},"m":1,"n":"acotan"},{"m":1,"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"k":"s","n":"acotan"},{"t":"Sub","n":"&redo","k":"v"},{"m":1,"s":{"r":"Nil","p":[]},"k":"s","n":"redo"},{"s":{"p":[{"n":"x","t":"Label"}],"r":"Nil"},"k":"s","m":1,"n":"redo"},{"t":"Sub+{is-pure}","n":"&any","k":"v"},{"n":"any","m":1,"s":{"p":[{"n":"+values","t":"Any"}],"r":"Mu"},"k":"s"},{"d":"<p><pre><code>class Attribute { }</code></pre></p><p>In Raku lingo, an attribute refers to a per-instance/object storage slot. An Attribute is used to talk about classes' and roles' attributes at the metalevel.</p><p>Normal usage of attributes does not require the user to use this class explicitly.</p>","k":"c","m":[{"m":0,"k":"m","n":"compose","s":{"r":"Mu","p":[{"n":"$package","t":"Mu"},{"t":"Any","n":":$compiler_services"},{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"t":"Mu","n":"$pkg"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"apply_handles"},{"n":"get_value","k":"m","d":"<p>Defined as:</p><p><pre><code>method get_value(Mu $obj)</code></pre></p><p>Returns the value stored in this attribute of object $obj.</p><p><pre><code>class Violated {\n    has $!private-thing = 5;\n}\nmy $private = Violated.^attributes(:local)[0];\nsay $private.get_value(Violated.new); # OUTPUT: «5␤»</code></pre></p><p>Note that this method violates encapsulation of the object, and should be used with care. Here be dragons.</p>","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"$obj"},{"n":"*%_","t":"Mu"}]}},{"d":"<p>Defined as:</p><p><pre><code>method set_value(Mu $obj, Mu \\new_val)</code></pre></p><p>Binds the value new_val to this attribute of object $obj.</p><p><pre><code>class A {\n    has $!a = 5;\n    method speak() { say $!a; }\n}\nmy $attr = A.^attributes(:local)[0];\nmy $a = A.new;\n$a.speak; # OUTPUT: «5␤»\n$attr.set_value($a, 42);\n$a.speak; # OUTPUT: «42␤»</code></pre></p><p>Note that this method violates encapsulation of the object, and should be used with care. Here be dragons.</p>","m":0,"s":{"p":[{"t":"Mu","n":"$obj"},{"t":"Mu","n":"value"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"set_value"},{"k":"m","n":"container","m":0,"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"readonly","d":"<p>Defined as:</p><p><pre><code>method readonly(Attribute:D: --&gt; Bool:D)</code></pre></p><p>Returns True for readonly attributes, which is the default, or False for attributes marked as is rw.</p><p><pre><code>class Library {\n    has $.address; # Read-only value\n    has @.new-books is rw;\n}\nmy $addr = Library.^attributes(:local)[0];\nmy $new-books = Library.^attributes(:local)[1];\nsay $addr.readonly;      # OUTPUT: «True␤»\nsay $new-books.readonly; # OUTPUT: «False␤»</code></pre></p>"},{"k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"n":"package","d":"<p>Defined as:</p><p><pre><code>method package()</code></pre></p><p>Returns the package (class/grammar/role) to which this attribute belongs.</p><p><pre><code>class Boo {\n    has @!baz;\n}\nmy $a = Boo.^attributes(:local)[0];\nsay $a.package;         # OUTPUT: «(Boo)␤»</code></pre></p>","m":0},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"inlined","m":0,"k":"m"},{"m":0,"n":"dimensions","k":"m","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"k":"m","m":0,"n":"WHY","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"s":{"p":[{"n":"$why","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"set_why","k":"m","m":0}],"mro":["Any"],"b":"A","t":"Attribute","n":"Attribute"},{"k":"v","t":"Sub","n":"&push"},{"k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"},"m":1,"n":"push"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"a"},{"n":"*@b","t":"Positional"}],"r":"Mu"},"n":"push"},{"n":"NaN","mro":["Real","Numeric","Cool"],"k":"c","b":"C","t":"Num"},{"n":"&parse-base","k":"v","t":"Sub"},{"n":"parse-base","m":1,"s":{"p":[{"n":"$str","t":"Str"},{"n":"$radix","t":"Int"}],"r":"Mu"},"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<=:=>","d":"<p><pre><code>multi sub infix:&lt;=:=&gt;(Mu \\a, Mu \\b)</code></pre></p><p>Container identity operator. Returns True if both arguments are bound to the same container. If it returns True, it generally means that modifying one will also modify the other.</p><p><pre><code>my ($a, $b) = (1, 3);\nsay $a =:= $b;      # OUTPUT: «False␤»\n$b = 2;\nsay $a;             # OUTPUT: «1␤»\n$b := $a;\nsay $a =:= $b;      # OUTPUT: «True␤»\n$a = 5;\nsay $b;             # OUTPUT: «5␤»</code></pre></p><p></p>"},{"s":{"p":[{"t":"Any","n":"$?"}],"r":"Mu"},"k":"s","n":"infix:<=:=>","m":1},{"s":{"p":[{"n":"a","t":"Mu"},{"n":"b","t":"Mu"}],"r":"Mu"},"n":"infix:<=:=>","k":"s","m":1},{"k":"v","n":"&categorize","t":"Sub"},{"m":1,"n":"categorize","k":"s","s":{"p":[{"n":"$test","t":"Any"},{"n":"+items","t":"Any"},{"t":"Any","n":":$into!"},{"t":"Associative","n":"*%named"}],"r":"Mu"}},{"m":1,"s":{"p":[{"n":"$test","t":"Any"},{"t":"Any","n":"+items"},{"t":"Associative","n":"*%named"}],"r":"Mu"},"k":"s","n":"categorize"},{"n":"&rename","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[{"n":"$from","t":"Any"},{"t":"Any","n":"$to"},{"n":":$createonly","t":"Any"}]},"n":"rename","m":1,"k":"s"},{"mro":["Any"],"b":"A","d":"<p><pre><code>class Thread {}</code></pre></p><p>A thread is a sequence of instructions that can (potentially) run in parallel to others. Class Thread provides a bit of abstraction over threads provided by the underlying virtual machines (which in turn might or might not be operating system threads).</p><p>Since threads are fairly low-level, most applications should use other primitives, like start, which also runs in parallel and returns a Promise.</p><p><pre><code>my @threads = (^10).map: {\n    Thread.start(\n        name =&gt; \"Sleepsorter $_\",\n        sub {\n            my $rand = (^10).pick;\n            sleep $rand;\n            say $rand;\n        },\n    );\n}\n\n.finish for @threads;\n</code></pre></p><p>The current thread is available in the dynamic variable $*THREAD.</p>","k":"c","a":[{"n":"$!vm_thread","t":"Mu","k":"v"},{"n":"$.app_lifetime","k":"v","t":"Bool"},{"n":"$.name","k":"v","t":"Str"}],"m":[{"s":{"r":"Nil","p":[{"t":"Callable","n":":&code!"},{"n":":$!app_lifetime?","t":"Any"},{"t":"Any","n":":$!name?"},{"n":"*%_","t":"Mu"}]},"m":0,"n":"BUILD","k":"s"},{"d":"<p><pre><code>method start(Thread:U: &amp;code, Bool :$app_lifetime = False, Str :$name = '&lt;anon&gt;' --&gt; Thread:D)</code></pre></p><p>Creates, runs and returns a new Thread. Note that it can (and often does) return before the thread's code has finished running.</p>","m":0,"n":"start","k":"m","s":{"p":[{"t":"Callable","n":"&code"},{"t":"Associative","n":"*%adverbs"}],"r":"Mu"}},{"n":"run","d":"<p><pre><code>method run(Thread:D:)</code></pre></p><p>Runs the thread, and returns the invocant. It is an error to run a thread that has already been started.</p>","m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"id","k":"m","d":"<p><pre><code>method id(Thread:D: --&gt; Int:D)</code></pre></p><p>Returns a numeric, unique thread identifier.</p>","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","n":"finish","m":0,"d":"<p><pre><code>method finish(Thread:D)</code></pre></p><p>Waits for the thread to finish. This is called join in other programming systems.</p>"},{"m":0,"d":"<p><pre><code>method join(Thread:D)</code></pre></p><p>Waits for the thread to finish.</p>","n":"join","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"m":0,"n":"yield","k":"m","d":"<p><pre><code>method yield(Thread:U)</code></pre></p><p>Tells the scheduler to prefer another thread for now.</p><p><pre><code>Thread.yield;</code></pre></p>","s":{"r":"Nil","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Bool"},"d":"<p><pre><code>method is-initial-thread(--&gt; Bool)</code></pre></p><p>Returns a Bool indicating whether the current thread (if called as a class method) or the Thread object on which it is called, is the initial thread the program started on.</p><p><pre><code>say Thread.is-initial-thread;    # True if this is the initial thread\nsay $*THREAD.is-initial-thread;  # True if $*THREAD is the initial thread</code></pre></p><p>Please note there is no guarantee that this is actually the main thread from the OS's point of view. Also note that if you need this other than from a pure introspection / debugging point of view, that there are probably better ways to achieve what you're trying to achieve.</p>","m":0,"k":"m","n":"is-initial-thread"},{"n":"usage","m":0,"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"d":"<p><pre><code>method app_lifetime(Thread:D: --&gt; Bool:D)</code></pre></p><p>Returns False unless the named parameter :app_lifetime is specifically set to True during object creation. If the method returns False it means that the process will only terminate when the thread has finished while True means that the thread will be killed when the main thread of the process terminates.</p><p><pre><code>my $t1 = Thread.new(code =&gt; { for 1..5 -&gt; $v { say $v }});\nmy $t2 = Thread.new(code =&gt; { for 1..5 -&gt; $v { say $v }}, :app_lifetime);\n\nsay $t1.app_lifetime;                 # OUTPUT: «False␤»\nsay $t2.app_lifetime;                 # OUTPUT: «True␤»</code></pre></p>","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"app_lifetime","m":0,"k":"m"},{"d":"<p><pre><code>method name(Thread:D: --&gt; Str:D)</code></pre></p><p>Returns the user defined string, which can optionally be set during object creation in order to identify the Thread, or '&lt;anon&gt;' if no such string was specified.</p><p><pre><code>my $t1 = Thread.new(code =&gt; { for 1..5 -&gt; $v { say $v }});\nmy $t2 = Thread.new(code =&gt; { for 1..5 -&gt; $v { say $v }}, name =&gt; 'my thread');\n\nsay $t1.name;                 # OUTPUT: «&lt;anon&gt;␤»\nsay $t2.name;                 # OUTPUT: «my thread␤»</code></pre></p>","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"name","m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":[{"n":"@auto","t":"Any"},{"t":"Any","n":"%init"},{"t":"Mu","n":"*%_"}],"r":"Mu"}}],"t":"Thread","n":"Thread"},{"mro":["Stringy","Cool"],"m":[{"n":"!match-cursor","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"n":"$name","t":"str"},{"t":"Any","n":"$value"},{"n":"opts","t":"Any"},{"t":"Mu","n":"*%_"}]},"k":"m"},{"n":"!match-list","k":"m","m":0,"s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"n":"post","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"str","n":"$needle"},{"t":"Any","n":"overlap"},{"t":"int","n":"$start"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!indicesicim","k":"m","m":0},{"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!match-last"},{"k":"m","n":"!match-nth-tail","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"t":"int","n":"$tail"},{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"!match-nth","k":"m","s":{"p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"t":"Any","n":"move"},{"n":"post","t":"Any"},{"n":"$nth","t":"Any"},{"n":"%opts","t":"Associative"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"p":[{"t":"Any","n":"limit"},{"t":"Mu","n":"*%_"}],"r":"Nil"},"m":0,"n":"!ensure-limit-sanity","k":"m"},{"m":0,"n":"!parse-fail","s":{"p":[{"t":"Any","n":"$radix"},{"n":"$pos","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Failure"},"k":"m"},{"n":"!parse-rat","m":0,"s":{"p":[{"n":"$radix","t":"int"},{"n":"$whole","t":"Int"},{"t":"int","n":"$offset"},{"t":"Mu","n":"*%_"}],"r":"Numeric:D"},"k":"m"},{"n":"!ensure-split-sanity","m":0,"k":"m","s":{"p":[{"t":"Any","n":"v"},{"n":"k","t":"Any"},{"n":"kv","t":"Any"},{"n":"p","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"s":{"r":"Int:D","p":[{"t":"Any","n":"$egg"},{"n":"*%_","t":"Mu"}]},"n":"!eggify","k":"m"},{"m":0,"s":{"p":[{"n":"slash","t":"Any"},{"n":"cursor","t":"Any"},{"n":"move","t":"Any"},{"t":"Any","n":"post"},{"n":"$nth","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!match-nth-int","k":"m"},{"s":{"p":[{"n":"$from","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!SUBSTR-START-OOR","m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"$needle","t":"str"},{"n":"overlap","t":"Any"},{"n":"$start","t":"int"},{"n":"*%_","t":"Mu"}]},"k":"m","n":"!indicesim"},{"k":"m","m":0,"n":"!slow-parse-base","s":{"p":[{"n":"$radix","t":"int"},{"n":"whole","t":"Any"},{"t":"int","n":"$failed-at"},{"t":"Mu","n":"*%_"}],"r":"Numeric:D"}},{"s":{"p":[{"t":"int","n":"$i"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!hexify-at"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!rakufy"},{"m":0,"k":"m","s":{"p":[{"t":"Any","n":"slash"},{"n":"cursor","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!match-one"},{"m":0,"k":"m","n":"!match-x-range","s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"t":"Any","n":"iterator"},{"t":"Any","n":"$min"},{"t":"Any","n":"$max"},{"n":"*%_","t":"Mu"}]}},{"n":"!match-nth-range","k":"m","m":0,"s":{"p":[{"n":"slash","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Any","n":"$min"},{"n":"$max","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":[{"n":"$needle","t":"str"},{"t":"Any","n":"overlap"},{"n":"$start","t":"int"},{"t":"Mu","n":"*%_"}]},"n":"!indices"},{"k":"m","m":0,"n":"!match-as-one","s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"cursor"},{"n":"as","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"}},{"k":"m","n":"!match-x","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"slash"},{"t":"Any","n":"iterator"},{"n":"$x","t":"Any"},{"n":"*%_","t":"Mu"}]}},{"k":"m","n":"!fail-oor","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"$got"},{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"t":"Any","n":"$chars"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0,"n":"!SUBSTR-CHARS-OOR"},{"n":"!match-nth-iterator","m":0,"s":{"p":[{"t":"Any","n":"slash"},{"t":"Any","n":"source"},{"t":"Any","n":"indexes"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m"},{"n":"!match-pattern","s":{"r":"Mu","p":[{"n":"slash","t":"Any"},{"n":"$pattern","t":"Any"},{"n":"$name","t":"str"},{"t":"Any","n":"$value"},{"t":"Any","n":"opts"},{"t":"Mu","n":"*%_"}]},"k":"m","m":0},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"!combiners"},{"n":"!SUBST","m":0,"s":{"r":"Mu","p":[{"t":"Any","n":"caller_dollar_slash"},{"t":"Any","n":"$matcher"},{"t":"Any","n":"$replacement"},{"n":":$g","t":"Any"},{"t":"Any","n":":$samecase"},{"t":"Any","n":":$samespace"},{"n":":$samemark","t":"Any"},{"t":"Associative","n":"*%options"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"matches","t":"Any"},{"t":"Any","n":"$replacement"},{"n":"cds","t":"Any"},{"n":"SDS","t":"Any"},{"t":"Any","n":"word_by_word"},{"n":"space","t":"Any"},{"t":"Any","n":"case"},{"n":"mark","t":"Any"},{"n":"*%_","t":"Mu"}]},"m":0,"k":"m","n":"!APPLY-MATCHES"},{"k":"m","m":0,"s":{"p":[{"t":"str","n":"$needle"},{"t":"Any","n":"overlap"},{"n":"$start","t":"int"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!indicesic"}],"b":"C","t":"Str","k":"c","n":"Thread::THREAD_ERROR"},{"t":"Endian","n":"NativeEndian","k":"e"},{"a":[{"t":"num","n":"$.re","k":"v"},{"t":"num","k":"v","n":"$.im"}],"t":"Complex","m":[{"m":0,"s":{"p":[{"n":"re","t":"Any"},{"n":"im","t":"Any"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","n":"!SET-SELF"}],"mro":["Numeric","Cool"],"k":"c","n":"i","b":"C"},{"t":"Sub+{is-pure}","n":"&acos","k":"v"},{"m":1,"k":"s","n":"acos","s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"}},{"m":1,"s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"},"n":"acos","k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"num","n":"$x"}],"r":"num"},"n":"acos"},{"n":"&nodemap","t":"Sub","k":"v"},{"n":"nodemap","m":1,"s":{"r":"Mu","p":[{"n":"op","t":"Any"},{"t":"Any","n":"obj"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"op"},{"n":"h","t":"Associative"}]},"n":"nodemap","k":"s"},{"k":"v","t":"Sub","n":"&note"},{"m":1,"n":"note","k":"s","s":{"r":"Mu","p":[]}},{"m":1,"n":"note","s":{"p":[{"n":"x","t":"Any"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"n":"|","t":"Any"}],"r":"Mu"},"k":"s","n":"note"},{"b":"C","d":"<p><pre><code>class Sequence does PositionalBindFailover { }</code></pre></p><p>A Sequence implements a series of methods for converting high-level Seqs into different types of objects, from positional to other.</p>","mro":["PositionalBindFailover"],"m":[{"m":0,"n":"Numeric","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"s":{"p":[{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","n":"fmt"}],"k":"ro","t":"Sequence","n":"Sequence"},{"n":"&infix:<!~~>","k":"v","t":"Sub"},{"k":"s","s":{"p":[{"n":"topic","t":"Mu"},{"t":"Mu","n":"matcher"}],"r":"Mu"},"n":"infix:<!~~>","m":1},{"n":"&atomic-fetch-dec","k":"v","t":"Sub"},{"k":"s","n":"atomic-fetch-dec","s":{"p":[{"n":"$target","t":"atomicint"}],"r":"atomicint"},"m":1},{"t":"Sub","n":"&postfix:<⚛++>","k":"v"},{"m":1,"s":{"p":[{"t":"atomicint","n":"$target"}],"r":"atomicint"},"n":"postfix:<⚛++>","k":"s"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊖>"},{"n":"infix:<⊖>","k":"s","m":1,"s":{"r":"Mu","p":[]}},{"s":{"p":[{"n":"a","t":"QuantHash"}],"r":"Mu"},"n":"infix:<⊖>","k":"s","m":1},{"m":1,"n":"infix:<⊖>","k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Setty"}]}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Mixy"}]},"n":"infix:<⊖>","k":"s"},{"m":1,"n":"infix:<⊖>","k":"s","s":{"r":"Mu","p":[{"t":"Setty","n":"a"},{"t":"Baggy","n":"b"}]}},{"m":1,"s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Mixy"}]},"n":"infix:<⊖>","k":"s"},{"m":1,"n":"infix:<⊖>","s":{"r":"Mu","p":[{"n":"a","t":"Mixy"},{"t":"Baggy","n":"b"}]},"k":"s"},{"n":"infix:<⊖>","s":{"r":"Mu","p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Setty"}]},"m":1,"k":"s"},{"m":1,"n":"infix:<⊖>","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Baggy"}],"r":"Mu"},"n":"infix:<⊖>","k":"s"},{"n":"infix:<⊖>","m":1,"s":{"r":"Mu","p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Setty"}]},"k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"Map","n":"a"},{"t":"Map","n":"b"}],"r":"Mu"},"n":"infix:<⊖>"},{"s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}]},"m":1,"k":"s","n":"infix:<⊖>"},{"s":{"p":[{"t":"Any","n":"$"},{"n":"b","t":"Failure"}],"r":"Mu"},"k":"s","m":1,"n":"infix:<⊖>"},{"n":"infix:<⊖>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}],"r":"Mu"}},{"m":1,"n":"infix:<⊖>","s":{"r":"Mu","p":[{"n":"+@p","t":"Positional"}]},"k":"s"},{"d":"<p><pre><code>multi sub infix:&lt;lt&gt;(Mu,    Mu)\nmulti sub infix:&lt;lt&gt;(Str:D, Str:D)</code></pre></p><p>String less than operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is smaller than the second, as determined by lexicographic comparison.</p><p>Mnemonic: less than</p>","t":"Sub+{is-pure}+{Precedence}","k":"v","n":"&infix:<lt>"},{"k":"s","n":"infix:<lt>","s":{"r":"Mu","p":[{"n":"$x?","t":"Any"}]},"m":1},{"k":"s","m":1,"n":"infix:<lt>","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Any","n":"b"}]}},{"k":"s","m":1,"n":"infix:<lt>","s":{"r":"Mu","p":[{"n":"a","t":"Blob"},{"t":"Blob","n":"b"}]}},{"n":"infix:<lt>","m":1,"s":{"p":[{"n":"a","t":"Str"},{"n":"b","t":"Str"}],"r":"Bool:D"},"k":"s"},{"n":"infix:<lt>","k":"s","s":{"p":[{"n":"$a","t":"str"},{"t":"str","n":"$b"}],"r":"Bool:D"},"m":1},{"t":"utf16","n":"utf16","b":"A","m":[{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Str"},"n":"encoding","k":"m","m":0},{"k":"m","m":0,"n":"!fail-range","s":{"p":[{"n":"$got","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"action"},{"n":"to","t":"Any"},{"t":"Any","n":"from"},{"n":"*%_","t":"Mu"}]},"n":"!unshift-list","m":0,"k":"m"},{"s":{"p":[{"n":"action","t":"Any"},{"n":"to","t":"Any"},{"t":"Any","n":"from"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!push-list"},{"s":{"p":[{"n":"$action","t":"Any"},{"t":"Any","n":"$got"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!fail-typecheck","m":0,"k":"m"},{"n":"!spread","m":0,"s":{"p":[{"t":"Any","n":"to"},{"t":"Any","n":"from"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"s":{"p":[{"n":"action","t":"Any"},{"t":"Any","n":"i"},{"t":"Any","n":"got"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"!fail-typecheck-element","k":"m","m":0}],"mro":["Blob[uint16]","Positional[uint16]","Stringy","Any"],"k":"c"},{"t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:<⊆>","k":"v"},{"n":"infix:<⊆>","k":"s","m":1,"s":{"p":[{"n":"a","t":"Setty"},{"t":"Setty","n":"b"}],"r":"Bool:D"}},{"s":{"p":[{"t":"Setty","n":"a"},{"t":"Mixy","n":"b"}],"r":"Bool:D"},"m":1,"n":"infix:<⊆>","k":"s"},{"m":1,"s":{"p":[{"n":"a","t":"Setty"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"n":"infix:<⊆>","k":"s"},{"k":"s","m":1,"n":"infix:<⊆>","s":{"r":"Bool:D","p":[{"n":"a","t":"Setty"},{"n":"b","t":"Any"}]}},{"k":"s","m":1,"n":"infix:<⊆>","s":{"r":"Bool:D","p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Mixy"}]}},{"s":{"p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"m":1,"n":"infix:<⊆>","k":"s"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Mixy"},{"n":"b","t":"Setty"}]},"k":"s","n":"infix:<⊆>","m":1},{"n":"infix:<⊆>","m":1,"s":{"r":"Bool:D","p":[{"t":"Mixy","n":"a"},{"n":"b","t":"Any"}]},"k":"s"},{"m":1,"n":"infix:<⊆>","k":"s","s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Mixy"}],"r":"Bool:D"}},{"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Baggy"},{"t":"Baggy","n":"b"}]},"m":1,"n":"infix:<⊆>"},{"m":1,"k":"s","s":{"p":[{"t":"Baggy","n":"a"},{"n":"b","t":"Setty"}],"r":"Bool:D"},"n":"infix:<⊆>"},{"m":1,"s":{"p":[{"n":"a","t":"Baggy"},{"n":"b","t":"Any"}],"r":"Bool:D"},"n":"infix:<⊆>","k":"s"},{"n":"infix:<⊆>","m":1,"k":"s","s":{"r":"Bool:D","p":[{"n":"a","t":"Map"},{"n":"b","t":"Map"}]}},{"n":"infix:<⊆>","m":1,"s":{"p":[{"t":"Iterable","n":"a"},{"t":"Map","n":"b"}],"r":"Bool:D"},"k":"s"},{"k":"s","m":1,"n":"infix:<⊆>","s":{"p":[{"n":"a","t":"Any"},{"t":"Mixy","n":"b"}],"r":"Bool:D"}},{"m":1,"k":"s","s":{"p":[{"n":"a","t":"Any"},{"n":"b","t":"Baggy"}],"r":"Bool:D"},"n":"infix:<⊆>"},{"m":1,"n":"infix:<⊆>","s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"t":"Setty","n":"b"}]},"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"a","t":"Failure"},{"n":"$","t":"Any"}]},"n":"infix:<⊆>"},{"m":1,"n":"infix:<⊆>","s":{"r":"Mu","p":[{"t":"Any","n":"$"},{"t":"Failure","n":"b"}]},"k":"s"},{"s":{"r":"Bool:D","p":[{"n":"a","t":"Any"},{"n":"b","t":"Any"}]},"k":"s","m":1,"n":"infix:<⊆>"},{"t":"Sub+{is-pure}","n":"&mix","k":"v"},{"m":1,"s":{"p":[],"r":"Mu"},"n":"mix","k":"s"},{"s":{"r":"Mix:D","p":[{"t":"Positional","n":"*@a"}]},"m":1,"n":"mix","k":"s"},{"a":[{"n":"$.invocant","t":"Mu","k":"v"},{"t":"Mu","n":"$.is-quiet","k":"v"},{"t":"Mu","k":"v","n":"$!reified"},{"n":"$!todo","k":"v","t":"Mu"}],"b":"C","m":[{"m":1,"k":"m","n":"invoke","s":{"r":"Seq:D","p":[{"n":"$args","t":"Capture"},{"n":"*%_","t":"Mu"}]}},{"s":{"p":[{"t":"Any","n":"c"}],"r":"Seq:D"},"k":"m","n":"invoke","m":1},{"k":"m","m":0,"n":"quiet","s":{"p":[{"n":"$quiet?","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"WalkList"}},{"s":{"r":"WalkList","p":[{"n":"*%_","t":"Mu"}]},"n":"reverse","k":"m","m":0},{"n":"set_invocant","s":{"r":"Mu","p":[{"t":"Mu","n":"inv"},{"t":"Mu","n":"*%_"}]},"m":0,"k":"m"},{"m":0,"s":{"r":"Mu","p":[{"n":"c","t":"Any"}]},"n":"CALL-ME","k":"m"},{"m":0,"n":"invocant","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"m":0,"n":"is-quiet","s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]},"k":"m"},{"s":{"r":"Mu","p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"t":"Mu","n":"*%_"}]},"m":0,"n":"BUILDALL","k":"s"}],"t":"WalkList","mro":["Positional","Iterable","List"],"k":"c","n":"WalkList"},{"k":"c","b":"C","mro":["Real","Numeric","Cool"],"t":"Num","n":"τ"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<+|>","k":"v","d":"<p><pre><code>multi sub infix:&lt;+|&gt;($a, $b --&gt; Int:D)</code></pre></p><p>Integer bitwise OR operator: Coerces both arguments to Int and does a bitwise OR (inclusive OR) operation.</p>"},{"m":1,"s":{"p":[],"r":"Mu"},"k":"s","n":"infix:<+|>"},{"k":"s","s":{"r":"Mu","p":[{"n":"$x","t":"Any"}]},"m":1,"n":"infix:<+|>"},{"k":"s","s":{"r":"Mu","p":[{"n":"$x","t":"Any"},{"n":"$y","t":"Any"}]},"n":"infix:<+|>","m":1},{"n":"infix:<+|>","k":"s","s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"t":"Int","n":"b"}]},"m":1},{"n":"infix:<+|>","k":"s","m":1,"s":{"p":[{"n":"$a","t":"int"},{"n":"$b","t":"int"}],"r":"int"}},{"t":"num","n":"num","k":"n"},{"t":"Sub+{is-nodal}+{Precedence}+{is-nodal}","n":"&postcircumfix:<[ ]>","k":"v"},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$type","t":"Any"},{"n":"c","t":"Any"}]},"m":1,"n":"postcircumfix:<[ ]>","k":"s"},{"k":"s","n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"int","n":"$pos"}]},"m":1},{"n":"postcircumfix:<[ ]>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"int","n":"$pos"},{"n":"assignee","t":"Mu"}]},"k":"s"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"int"},{"t":"Mu","n":":$BIND!"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"int"},{"t":"Any","n":":$delete!"}]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"int"},{"n":":$delete!","t":"Any"},{"n":"*%other","t":"Associative"}]},"k":"s"},{"m":1,"n":"postcircumfix:<[ ]>","k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"int"},{"t":"Any","n":":$exists!"}]}},{"m":1,"k":"s","n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"t":"int","n":"$pos"},{"t":"Any","n":":$exists!"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$pos","t":"int"},{"n":":$kv!","t":"Any"},{"t":"Associative","n":"*%other"}]},"k":"s","n":"postcircumfix:<[ ]>","m":1},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"int"},{"t":"Any","n":":$p!"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<[ ]>","k":"s","m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"int","n":"$pos"},{"t":"Any","n":":$k!"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<[ ]>","k":"s"},{"k":"s","n":"postcircumfix:<[ ]>","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"t":"int","n":"$pos"},{"t":"Any","n":":$v!"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"Int"}]},"n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"n":"$pos","t":"Int"},{"t":"Mu","n":"assignee"}],"r":"Mu"},"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"Int"},{"n":":$BIND!","t":"Mu"}]},"n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"Int"},{"n":":$delete!","t":"Any"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Int","n":"$pos"},{"t":"Any","n":":$delete!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"k":"s","n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Int","n":"$pos"},{"n":":$exists!","t":"Any"}]},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"k":"s","n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"n":"$pos","t":"Int"},{"n":":$exists!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"m":1},{"k":"s","m":1,"n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Int","n":"$pos"},{"n":":$kv!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"Int"},{"t":"Any","n":":$p!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","m":1,"k":"s"},{"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Int","n":"$pos"},{"t":"Any","n":":$k!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","k":"s","m":1},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$pos","t":"Int"},{"n":":$v!","t":"Any"},{"n":"*%other","t":"Associative"}]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","k":"s","s":{"p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Any"}],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"pos"},{"n":"assignee","t":"Mu"}],"r":"Mu"},"k":"s"},{"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"pos"},{"t":"Mu","n":":$BIND!"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","m":1,"k":"s"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"pos","t":"Any"},{"n":":$delete!","t":"Any"}],"r":"Mu"},"k":"s","n":"postcircumfix:<[ ]>"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"pos"},{"t":"Any","n":":$delete!"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Any"},{"n":":$exists!","t":"Any"}]},"k":"s"},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Any"},{"n":":$exists!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Any","n":"pos"},{"t":"Any","n":":$kv!"},{"n":"*%other","t":"Associative"}]},"k":"s"},{"k":"s","m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Any"},{"n":":$p!","t":"Any"},{"t":"Associative","n":"*%other"}]}},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Any"},{"t":"Any","n":":$k!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","m":1,"k":"s"},{"k":"s","n":"postcircumfix:<[ ]>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Any","n":"pos"},{"n":":$v!","t":"Any"},{"n":"*%other","t":"Associative"}]}},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"pos","t":"Iterable"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Iterable"},{"t":"Mu","n":"val"}]},"n":"postcircumfix:<[ ]>","k":"s"},{"m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Iterable"},{"n":":$BIND!","t":"Any"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","k":"s"},{"m":1,"k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Iterable","n":"pos"},{"n":":$delete!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"s":{"p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Iterable"},{"n":":$exists!","t":"Any"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"m":1,"n":"postcircumfix:<[ ]>","k":"s"},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Iterable","n":"pos"},{"n":":$kv!","t":"Any"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<[ ]>","k":"s","m":1},{"k":"s","n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Iterable","n":"pos"},{"t":"Any","n":":$p!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"m":1},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"pos","t":"Iterable"},{"t":"Any","n":":$k!"},{"t":"Associative","n":"*%other"}]},"k":"s","n":"postcircumfix:<[ ]>"},{"k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Iterable","n":"pos"},{"n":":$v!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","m":1},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$block","t":"Callable"}]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"s":{"p":[{"t":"Any","n":"SELF"},{"n":"$block","t":"Callable"},{"n":"assignee","t":"Mu"}],"r":"Mu"},"k":"s","n":"postcircumfix:<[ ]>","m":1},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$block","t":"Callable"},{"t":"Any","n":":$BIND!"}]},"k":"s","m":1},{"m":1,"k":"s","n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Callable","n":"$block"},{"n":":$delete!","t":"Any"},{"n":"*%other","t":"Associative"}]}},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$block","t":"Callable"},{"t":"Any","n":":$exists!"},{"t":"Associative","n":"*%other"}]},"k":"s"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Callable","n":"$block"},{"t":"Any","n":":$kv!"},{"n":"*%other","t":"Associative"}]},"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":"$block","t":"Callable"},{"n":":$p!","t":"Any"},{"t":"Associative","n":"*%other"}]},"n":"postcircumfix:<[ ]>"},{"m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"n":"$block","t":"Callable"},{"n":":$k!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","k":"s"},{"n":"postcircumfix:<[ ]>","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"$block","t":"Callable"},{"t":"Any","n":":$v!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"}]},"k":"s"},{"m":1,"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"t":"Mu","n":"assignee"}]},"k":"s"},{"m":1,"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"},{"n":":$BIND!","t":"Any"}]},"n":"postcircumfix:<[ ]>","k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"n":":$delete!","t":"Any"},{"t":"Associative","n":"*%other"}]},"n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Whatever","n":"$"},{"t":"Any","n":":$exists!"},{"t":"Associative","n":"*%other"}]},"m":1,"n":"postcircumfix:<[ ]>","k":"s"},{"m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"t":"Any","n":":$kv!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s","n":"postcircumfix:<[ ]>"},{"m":1,"n":"postcircumfix:<[ ]>","k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$","t":"Whatever"},{"t":"Any","n":":$p!"},{"t":"Associative","n":"*%other"}]}},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"p":[{"n":"SELF","t":"Any"},{"t":"Whatever","n":"$"},{"t":"Any","n":":$k!"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"k":"s","m":1,"n":"postcircumfix:<[ ]>","s":{"p":[{"t":"Any","n":"SELF"},{"t":"Whatever","n":"$"},{"n":":$v!","t":"Any"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"m":1,"n":"postcircumfix:<[ ]>","k":"s","s":{"p":[{"t":"Any","n":"SELF"},{"t":"HyperWhatever","n":"$"},{"t":"Associative","n":"*%adv"}],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":"$","t":"HyperWhatever"},{"t":"Mu","n":"assignee"}]},"k":"s","m":1},{"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Any","n":":$BIND!"}],"r":"Mu"},"m":1,"n":"postcircumfix:<[ ]>","k":"s"},{"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":":$delete!"},{"n":"*%other","t":"Associative"}],"r":"Mu"},"n":"postcircumfix:<[ ]>","m":1,"k":"s"},{"n":"postcircumfix:<[ ]>","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"n":":$exists!","t":"Any"},{"t":"Associative","n":"*%other"}]},"k":"s"},{"n":"postcircumfix:<[ ]>","m":1,"s":{"p":[{"n":"SELF","t":"Any"},{"t":"Any","n":":$kv!"},{"t":"Associative","n":"*%other"}],"r":"Mu"},"k":"s"},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":":$p!","t":"Any"},{"n":"*%other","t":"Associative"}]},"n":"postcircumfix:<[ ]>","k":"s","m":1},{"s":{"r":"Mu","p":[{"n":"SELF","t":"Any"},{"n":":$k!","t":"Any"},{"n":"*%other","t":"Associative"}]},"m":1,"n":"postcircumfix:<[ ]>","k":"s"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":[{"t":"Any","n":"SELF"},{"t":"Any","n":":$v!"},{"n":"*%other","t":"Associative"}],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":[{"t":"Any","n":"SELF"},{"t":"Associative","n":"*%other"}]},"k":"s","m":1},{"k":"s","n":"postcircumfix:<[ ]>","s":{"p":[{"n":"SELF","t":"array"},{"t":"Range","n":"range"}],"r":"Mu"},"m":1},{"n":"SIGVTALRM","k":"e","t":"Signal"},{"t":"Sub","k":"v","n":"&flat"},{"m":1,"s":{"p":[{"t":"Positional","n":"**@list"}],"r":"Mu"},"n":"flat","k":"s"},{"s":{"r":"Mu","p":[{"t":"Iterable","n":"a"}]},"n":"flat","m":1,"k":"s"},{"t":"Sub","n":"&say","k":"v"},{"m":1,"s":{"p":[],"r":"Mu"},"n":"say","k":"s"},{"k":"s","s":{"p":[{"n":"x","t":"Any"}],"r":"Mu"},"n":"say","m":1},{"n":"say","m":1,"s":{"p":[{"t":"Any","n":"|"}],"r":"Mu"},"k":"s"},{"k":"e","t":"SocketType","n":"SOCK_PACKET"},{"k":"v","t":"Sub","n":"&srand"},{"s":{"p":[{"n":"$seed","t":"Int"}],"r":"Int:D"},"k":"s","m":1,"n":"srand"},{"b":"C","t":"Num","mro":["Real","Numeric","Cool"],"n":"\uD835\uDC52","k":"c"},{"n":"int32","k":"n","t":"int32"},{"t":"Sub+{is-pure}","k":"v","n":"&infix:«+<»"},{"s":{"p":[],"r":"Mu"},"n":"infix:«+<»","m":1,"k":"s"},{"m":1,"k":"s","s":{"p":[{"n":"$x","t":"Any"}],"r":"Mu"},"n":"infix:«+<»"},{"k":"s","n":"infix:«+<»","m":1,"s":{"p":[{"n":"$x","t":"Any"},{"t":"Any","n":"$y"}],"r":"Mu"}},{"m":1,"s":{"r":"Int:D","p":[{"t":"Int","n":"a"},{"n":"b","t":"Int"}]},"n":"infix:«+<»","k":"s"},{"s":{"p":[{"t":"int","n":"$a"},{"n":"$b","t":"int"}],"r":"int"},"n":"infix:«+<»","k":"s","m":1},{"n":"&uniprops","k":"v","t":"Sub"},{"n":"uniprops","s":{"p":[{"t":"Str","n":"$str"},{"n":"$propname?","t":"Stringy"}],"r":"Mu"},"m":1,"k":"s"},{"n":"Bag","b":"A","t":"Bag","d":"<p><pre><code>class Bag does Baggy { }</code></pre></p><p>A Bag is an immutable bag/multiset implementing Associative, meaning a collection of distinct elements in no particular order that each have an integer weight assigned to them signifying how many copies of that element are considered \"in the bag\". (For mutable bags, see BagHash instead.)</p><p>Bags are often used for performing weighted random selections - see .pick and .roll.</p><p>Objects/values of any type are allowed as bag elements. Within a Bag, items that would compare positively with the === operator are considered the same element, with the number of how many there are as its weight. But of course you can also easily get back the expanded list of items (without the order):</p><p><pre><code>my $breakfast = bag &lt;spam eggs spam spam bacon spam&gt;;\n\nsay $breakfast.elems;      # OUTPUT: «3␤»\nsay $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\nsay $breakfast.total;      # OUTPUT: «6␤»\nsay $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n</code></pre></p><p>Bags can be treated as object hashes using the { } postcircumfix operator, or the &lt; &gt;  operator for literal string keys, which returns the corresponding integer weight for keys that are elements of the bag, and 0 for keys that aren't:</p><p><pre><code>my $breakfast = bag &lt;spam eggs spam spam bacon spam&gt;;\nsay $breakfast&lt;bacon&gt;;    # OUTPUT: «1␤»\nsay $breakfast&lt;spam&gt;;     # OUTPUT: «4␤»\nsay $breakfast&lt;sausage&gt;;  # OUTPUT: «0␤»</code></pre></p>","mro":["Baggy","QuantHash","Associative","Any"],"a":[{"t":"ValueObjAt","n":"$!WHICH","k":"v"},{"t":"Int","k":"v","n":"$!total"},{"n":"$!elems","t":"Rakudo::Internals::IterationSet","k":"v"}],"k":"c","m":[{"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Int:D"},"m":0,"n":"total","k":"m"},{"m":1,"n":"classify-list","k":"m","s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"n":"list","t":"Any"},{"t":"Mu","n":"*%_"}]}},{"n":"classify-list","m":1,"s":{"p":[{"t":"Associative","n":"%test"},{"n":"c","t":"Any"}],"r":"Mu"},"k":"m"},{"m":1,"k":"m","n":"classify-list","s":{"r":"Mu","p":[{"t":"Positional","n":"@test"},{"t":"Any","n":"c"}]}},{"m":1,"s":{"p":[{"n":"&test","t":"Callable"},{"t":"Positional","n":"**@list"},{"n":"c","t":"Any"}],"r":"Mu"},"k":"m","n":"classify-list"},{"k":"m","s":{"r":"Mu","p":[{"n":"&test","t":"Callable"},{"n":"list","t":"Any"},{"n":"*%_","t":"Mu"}]},"n":"categorize-list","m":1},{"k":"m","n":"categorize-list","m":1,"s":{"r":"Mu","p":[{"t":"Associative","n":"%test"},{"t":"Any","n":"c"}]}},{"m":1,"n":"categorize-list","k":"m","s":{"p":[{"n":"@test","t":"Positional"},{"n":"c","t":"Any"}],"r":"Mu"}},{"k":"m","n":"categorize-list","m":1,"s":{"p":[{"n":"&test","t":"Callable"},{"n":"**@list","t":"Positional"},{"n":"c","t":"Any"}],"r":"Mu"}},{"n":"!create-from-iterator","s":{"p":[{"n":"type","t":"Any"},{"t":"Any","n":"iterator"},{"t":"Mu","n":"*%_"}],"r":"Baggy:D"},"k":"m","m":0},{"s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m","m":0,"n":"!WHICH"},{"s":{"p":[{"t":"Any","n":"type"},{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"!HASHIFY","k":"m","m":0}]},{"d":"<p><pre><code>class WhateverCode is Code { }</code></pre></p><p>WhateverCode objects are the result of Whatever-currying. See the Whatever documentation for details.</p><p>When you wish to control how a method or function interprets any Whatever star, you may use multi dispatch with Whatever and WhateverCode parameters to do so, as in the following example:</p><p><pre><code>class Cycle {\n      has $.pos;\n      has @.vals;\n}\n\nmulti sub get-val(Cycle $c, Int $idx) {\n      $c.vals[$idx % $c.vals.elems]\n}\n\n# Define what to do with a stand-alone * as the second argument\nmulti sub get-val(Cycle $c, Whatever $idx) {\n    get-val($c, $c.pos);\n}\n\n# Define what to do with a * WhateverCode in an expression\nmulti sub get-val(Cycle $c, WhateverCode $idx) {\n    get-val($c, $idx($c.pos));\n}\n\nmy Cycle $c .= new(:pos(2), :vals(0..^10));\n\nsay get-val($c, 3);   # OUTPUT: «3␤»\nsay get-val($c, *);   # OUTPUT: «2␤»\nsay get-val($c, *-1); # OUTPUT: «1␤»</code></pre></p><p>The WhateverCode does the Callable role, so it should be possible to introspect the type of Callable it contains; for instance, continuing the previous example, we can add a multi that handles a WhateverCode with two arguments via checking the signature:</p><p><pre><code># Define what to do with two * in an expression\nmulti sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {\n    get-val($c, $idx($c.pos, $c.vals.elems));\n}\n\nsay get-val($c, * + * div 2); # 2 + 10/2 = 7\n</code></pre></p><p>Note, though, that subexpressions may impose their own Whatever star rules:</p><p><pre><code>my @a = (0, 1, 2);\nsay get-val($c, @a[*-1]) # 2, because the star belongs to the Array class\n</code></pre></p><p>This can make the ownership of Whatever stars become confusing rather quickly, so be careful not to overdo it.</p><p>You may instead type-constrain using Callable type in order to accept any Callable, including WhateverCode:</p><p><pre><code>sub run-with-rand (Callable $code) { $code(rand) };\nrun-with-rand *.say;           # OUTPUT: «0.773672071688484␤»\nrun-with-rand {.say};          # OUTPUT: «0.38673179353983␤»\nrun-with-rand sub { $^v.say }; # OUTPUT: «0.0589543603685792␤»</code></pre></p><p>Type-constraining with &amp;-sigiled parameter works equally well and is shorter to type:</p><p><pre><code>sub run-with-rand (&amp;code) { code time };</code></pre></p>","k":"c","a":[{"t":"Code","n":"$!do","k":"v"},{"t":"Signature","k":"v","n":"$!signature"},{"n":"@!compstuff","k":"v","t":"List"}],"t":"WhateverCode","n":"WhateverCode","mro":["Callable","Code"],"b":"A"},{"k":"v","t":"Sub+{is-pure}","n":"&floor"},{"s":{"r":"Mu","p":[{"n":"$a","t":"Any"}]},"m":1,"n":"floor","k":"s"},{"m":1,"n":"floor","s":{"p":[{"n":"$a","t":"Numeric"}],"r":"Mu"},"k":"s"},{"m":1,"s":{"p":[{"t":"num","n":"$a"}],"r":"num"},"n":"floor","k":"s"},{"t":"Sub+{is-pure}","n":"&cotanh","k":"v"},{"s":{"p":[{"n":"x","t":"Numeric"}],"r":"Mu"},"n":"cotanh","m":1,"k":"s"},{"m":1,"k":"s","n":"cotanh","s":{"p":[{"t":"Cool","n":"x"}],"r":"Mu"}},{"s":{"p":[{"n":"$x","t":"num"}],"r":"num"},"k":"s","m":1,"n":"cotanh"},{"t":"SeekType","k":"e","n":"SeekType"},{"t":"SeekType","k":"e","n":"SeekType::SeekFromEnd"},{"k":"e","t":"SeekType","n":"SeekType::SeekFromCurrent"},{"t":"SeekType","n":"SeekType::SeekFromBeginning","k":"e"},{"k":"v","t":"Sub","n":"&return-rw"},{"m":1,"n":"return-rw","k":"s","s":{"r":"Nil","p":[]}},{"s":{"r":"Nil","p":[{"t":"Mu","n":"x"}]},"m":1,"k":"s","n":"return-rw"},{"m":1,"s":{"r":"Nil","p":[{"n":"**@x","t":"Positional"}]},"n":"return-rw","k":"s"},{"k":"v","t":"Sub","n":"&close"},{"n":"close","m":1,"s":{"p":[{"n":"$fh","t":"IO::Handle"}],"r":"Mu"},"k":"s"},{"m":1,"n":"close","s":{"p":[{"n":"$channel","t":"Channel"}],"r":"Mu"},"k":"s"},{"k":"c","b":"A","mro":["Callable","Routine"],"n":"Macro","t":"Macro","d":"<p><pre><code>class Macro is Routine { }</code></pre></p><p>A macro is a Routine whose invocation typically happens during parsing. By returning an AST, a macro can inject code into the calling location.</p>","a":[{"k":"v","t":"List","n":"@!dispatchees"},{"n":"$!dispatcher_cache","t":"Mu","k":"v"},{"k":"v","n":"$!dispatcher","t":"Mu"},{"n":"$!flags","t":"int","k":"v"},{"n":"$!inline_info","k":"v","t":"Mu"},{"n":"$!package","t":"Mu","k":"v"},{"k":"v","n":"$!onlystar","t":"int"},{"t":"List","k":"v","n":"@!dispatch_order"},{"t":"Mu","n":"$!dispatch_cache","k":"v"},{"k":"v","t":"Mu","n":"$!why"},{"n":"$!do","t":"Code","k":"v"},{"k":"v","t":"Signature","n":"$!signature"},{"t":"List","n":"@!compstuff","k":"v"}]},{"t":"Sub+{Precedence}","d":"<p><pre><code>multi sub prefix:&lt;++&gt;($x is rw) is assoc&lt;non&gt;</code></pre></p><p>This is the . Increments its argument by one and returns the updated value.</p><p><pre><code>my $x = 3;\nsay ++$x;   # OUTPUT: «4␤»\nsay $x;     # OUTPUT: «4␤»</code></pre></p><p>It works by calling the succ method (for successor) on its argument, which gives custom types the freedom to implement their own increment semantics.</p><p></p>","k":"v","n":"&prefix:<++>"},{"s":{"r":"Mu","p":[{"t":"Mu","n":"$a"}]},"n":"prefix:<++>","k":"s","m":1},{"m":1,"n":"prefix:<++>","s":{"p":[{"n":"$a","t":"Mu"}],"r":"Mu"},"k":"s"},{"k":"s","m":1,"s":{"p":[{"t":"Int","n":"$a"}],"r":"Int:D"},"n":"prefix:<++>"},{"k":"s","n":"prefix:<++>","s":{"r":"int","p":[{"n":"$a","t":"int"}]},"m":1},{"s":{"p":[{"t":"Bool","n":"$a"}],"r":"Mu"},"n":"prefix:<++>","m":1,"k":"s"},{"n":"prefix:<++>","k":"s","m":1,"s":{"p":[{"t":"Num","n":"$a"}],"r":"Mu"}},{"s":{"p":[{"t":"Num","n":"$a"}],"r":"Mu"},"n":"prefix:<++>","k":"s","m":1},{"n":"prefix:<++>","m":1,"k":"s","s":{"r":"num","p":[{"t":"num","n":"$a"}]}},{"k":"v","t":"Sub","n":"&trait_mod:<does>"},{"n":"trait_mod:<does>","k":"s","s":{"p":[{"n":"$doee","t":"Mu"},{"n":"$role","t":"Mu"}],"r":"Mu"},"m":1},{"n":"trait_mod:<does>","k":"s","s":{"r":"Mu","p":[{"n":"$a","t":"Attribute"},{"t":"Mu","n":"$role"}]},"m":1},{"s":{"p":[{"n":"$v","t":"Variable"},{"n":"$role","t":"Mu"}],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<does>"},{"mro":["Any"],"k":"c","a":[{"n":"$.file","t":"str","k":"v"},{"t":"str","k":"v","n":"$.type"},{"n":"$.package","k":"v","t":"str"},{"n":"$.name","k":"v","t":"str"},{"k":"v","t":"str","n":"$.alternative"},{"k":"v","t":"Associative","n":"%.callsites"},{"t":"Version","k":"v","n":"$.from"},{"n":"$.removed","k":"v","t":"Version"}],"n":"Deprecation","m":[{"m":1,"n":"report","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"k":"m"},{"n":"report","k":"m","m":1,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"m":0,"n":"file","k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"}},{"m":0,"n":"type","k":"m","s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]}},{"m":0,"k":"m","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"n":"package"},{"n":"name","s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"k":"m","m":0},{"m":0,"n":"alternative","s":{"p":[{"n":"*%_","t":"Mu"}],"r":"Mu"},"k":"m"},{"k":"m","n":"callsites","m":0,"s":{"r":"Mu","p":[{"t":"Mu","n":"*%_"}]}},{"s":{"r":"Mu","p":[{"n":"*%_","t":"Mu"}]},"n":"from","m":0,"k":"m"},{"k":"m","m":0,"s":{"p":[{"t":"Mu","n":"*%_"}],"r":"Mu"},"n":"removed"},{"n":"BUILDALL","s":{"p":[{"n":"@auto","t":"Any"},{"n":"%init","t":"Any"},{"n":"*%_","t":"Mu"}],"r":"Mu"},"m":0,"k":"s"}],"b":"A","t":"Deprecation"},{"k":"v","d":"<p>The andthen operator returns Empty upon encountering the first undefined argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as arguments if the right side is a Callable, whose count must be 0 or 1.</p><p>A handy use of this operator is to alias a routine's return value to $_ and to do additional manipulation with it, such as printing or returning it to caller. Since the andthen operator short-circuits, statements on the right-hand side won't get executed, unless left-hand side is defined (tip: Failures are never defined, so you can handle them with this operator).</p><p><pre><code>sub load-data {\n    rand  &gt; .5 or return; # simulated load data failure; return Nil\n    (rand &gt; .3 ?? 'error' !! 'good data') xx 10 # our loaded data\n}\nload-data.first: /good/ andthen say \"$_ is good\";\n# OUTPUT: «(good data is good)␤»\n\nload-data() andthen .return; # return loaded data, if it's defined\ndie \"Failed to load data!!\";</code></pre></p><p>The above example will print good data is good only if the subroutine returned any items that match /good/ and will die unless loading data returned a defined value. The aliasing behavior lets us pipe the values across the operator.</p><p>The andthen operator is a close relative of with statement modifier, and some compilers compile with to andthen, meaning these two lines have equivalent behavior:</p><p><pre><code>.say with 42;\n42 andthen .say;</code></pre></p>","n":"&infix:<andthen>","t":"Sub+{Precedence}"},{"n":"infix:<andthen>","k":"s","m":1,"s":{"r":"Mu","p":[{"t":"Any","n":"+a"}]}},{"k":"v","t":"Sub+{is-pure}","n":"&acotanh"},{"k":"s","n":"acotanh","m":1,"s":{"r":"Mu","p":[{"n":"x","t":"Numeric"}]}},{"s":{"p":[{"n":"x","t":"Cool"}],"r":"Mu"},"m":1,"n":"acotanh","k":"s"},{"s":{"r":"num","p":[{"n":"$x","t":"num"}]},"n":"acotanh","m":1,"k":"s"},{"t":"Sub","n":"&EVAL","k":"v"},{"k":"s","n":"EVAL","m":1,"s":{"p":[{"t":"Any","n":"$code"},{"n":":$lang","t":"Str"},{"t":"PseudoStash","n":":$context"},{"t":"Any","n":":$filename?"},{"t":"Any","n":":$check"}],"r":"Mu"}},{"t":"Sub+{Precedence}","n":"&infix:<^...^>","k":"v"},{"n":"infix:<^...^>","m":1,"k":"s","s":{"r":"Mu","p":[{"t":"Any","n":"a"},{"t":"Mu","n":"b"}]}},{"n":"infix:<^...^>","m":1,"s":{"p":[{"n":"lol","t":"Any"}],"r":"Mu"},"k":"s"}]
