[{"k":"e","t":"Signal","n":"SIGSTOP"},{"n":"Scheduler","a":[{"k":"v","n":"&.uncaught_handler","t":"Callable"}],"d":"TITLE\nrole Scheduler\n\nSUBTITLE\nScheme for automatically assigning tasks to threads\n\n    role Scheduler {\n        has &.uncaught_handler is rw\n    }\n\nCommon role for schedulers. A scheduler is a piece of code that determines\nwhich resources to use to run which task, and when.\n\nSome operations for example on Proc::Async, Promise, Supply allow you to\nspecify a scheduler explicitly; they generally expect those schedulers to\nfollow the interface defined by Scheduler\n\n","t":"Scheduler","mro":[],"k":"ro","m":[{"n":"handle_uncaught","s":{"p":["$exception","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"method cue(&code, Instant :$at, :$in, :$every, :$times = 1; :&catch --> Cancellation)\n\nSchedules a callable (&code) for execution and returns an instantiated\nCancellation object to cancel the scheduling of the code for execution\n(which is especially important if you specify the every = time> named\nparameter. The adverbs control when and how the code is run:\n\n$at can be an Instant before which the code won't be run. Alternatively $in\nis the number of seconds (possibly fractional) to wait before running the\ncode. If $at is in the past or $in is negative, the delay is treated as\nzero. Implementations may equate to zero very small values (e.g. lower than\n0.001s) of $in or result of $at - now.\n\nIf $every is specified, it is interpreted as the number of seconds\n(possibly fractional) to wait before re-executing the code. Implementations\nmay treat too-small values as lowest resolution they support, possibly\nwarning in such situations; e.g. treating 0.0001 as 0.001.\n\n$times tells the scheduler how many times to run the code.\n\n&catch is called with the Exception as its sole argument if &code dies.\n\nIf $at or $in are Inf, &code will never be run; if $every is Inf, &code\nwill only be run once. If any of the three are -Inf, &code will be run\nimmediately. If any of the three are NaN, an X::Scheduler::CueInNaNSeconds\nexception will be thrown. This only applies to releases 2019.05 and later.\n\nOne should call the cancel method on the returned Cancellation object to\ncancel the (possibly repeated) cueing of the code.","n":"cue","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"loads"}],"b":"C"},{"n":"&lc","t":"Sub","k":"v"},{"s":{"r":"Mu","p":["Cool $s"]},"k":"s","m":1,"n":"lc"},{"n":"Setty","d":"TITLE\nrole Setty\n\nSUBTITLE\nCollection of distinct objects\n\n    role Setty does QuantHash { }\n\nA role for collections which make sure that each element can only appear\nonce. See Set and SetHash.\n\n","a":[{"t":"Rakudo::Internals::IterationSet","n":"$!elems","k":"v"}],"t":"Setty","mro":[],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"of"},{"d":"Defined as:\n\n    method new-from-pairs(*@pairs --> Setty:D)\n\nConstructs a Setty object from a list of Pair objects given as positional\narguments:\n\n    say Set.new-from-pairs: 'butter' => 0.22, 'salt' => 0, 'sugar' => 0.02;\n    # OUTPUT: «set(butter, sugar)␤»\n\nNote: be sure you aren't accidentally passing the Pairs as positional\narguments; the quotes around the keys in the above example are\nsignificant.","n":"new-from-pairs","m":0,"k":"m","s":{"p":["*@pairs","*%_"],"r":"Setty:D"}},{"n":"default","d":"Defined as:\n\n    method default(--> False)\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen trying to access an element in the Setty object which has not been\npreviously initialized or when accessing an element which has explicitly\nbeen set to Nil or False.\n\n    my $s1 = SetHash.new(1, 2, 3);\n    say $s1{2};                                           # OUTPUT: «True␤»\n    $s1{2} = Nil;\n    say $s1{2};                                           # OUTPUT: «False␤»\n    # access non initialized element\n    say $s1{4};                                           # OUTPUT: «False␤»","s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]},"d":"method elems(--> Int)\n\nThe number of elements of the set.","n":"elems"},{"k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]},"d":"method total(--> Int)\n\nThe total of all the values of the QuantHash object. For a Setty object,\nthis is just the number of elements.","n":"total"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"RAW-HASH"},{"s":{"r":"Setty:D","p":["\\type","\\iterator","*%_"]},"k":"m","m":0,"n":"!create-from-iterator"},{"n":"!HASHIFY","k":"m","m":0,"s":{"p":["\\type","*%_"],"r":"Mu"}}],"k":"ro","b":"C"},{"k":"v","n":"&infix:<ge>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<ge>","s":{"r":"Mu","p":["$x?"]},"k":"s","m":1},{"n":"infix:<ge>","s":{"p":["\\a","\\b"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"n":"infix:<ge>"},{"n":"infix:<ge>","k":"s","m":1,"s":{"p":["Str:D \\a","Str:D \\b"],"r":"Bool:D"}},{"k":"v","t":"Sub","n":"&unique"},{"k":"s","m":1,"s":{"p":["+\\values is raw","|c is raw"],"r":"Mu"},"n":"unique"},{"n":"SeekFromCurrent","t":"SeekType","k":"e"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<&>"},{"s":{"r":"Mu","p":["+\\values is raw"]},"m":1,"k":"s","n":"infix:<&>"},{"k":"e","n":"SIGCHLD","t":"Signal"},{"t":"Sub","n":"&make","k":"v"},{"n":"make","k":"s","m":0,"s":{"r":"Mu","p":["Mu \\made"]}},{"n":"Stash","a":[{"k":"v","n":"$!longname","t":"str"},{"k":"v","t":"Mu","n":"$!descriptor"},{"k":"v","n":"$!storage","t":"Mu"}],"t":"Stash","d":"TITLE\nclass Stash\n\nSUBTITLE\nTable for \"our\"-scoped symbols\n\n    class Stash is Hash { }\n\nA Stash is a hash that is used for symbol tables at the package scoping\nlevel in Raku.\n\nTo get a Stash, you can call the .WHO pseudo-method on a package (because\nit answers the question who lives here?), or if you write the package name\nas a literal, append two colons:\n\n    class Boring {\n        class Nested { };\n        our sub package_sub { }\n        my sub lexical { };\n        method a_method() { }\n    }\n    say Boring::.^name;             # OUTPUT: «Stash␤»\n    say Boring.WHO === Boring::;    # OUTPUT: «True␤»\n\nSince it inherits from Hash, you can use all the usual hash functionality:\n\n    say Boring::.keys.sort;         # OUTPUT: «(&package_sub Nested)␤»\n    say Boring::<Nested>;           # OUTPUT: «(Nested)␤»\n\n\nAs the example above shows only \"our\"-scoped things appear in the Stash\n(nested classes are \"our\" by default, but can be excluded with \"my\".)\nLexicals and methods are not included in a Stash, since they do not live in\nthe package table. Lexicals live in a separate lexical pad, which is only\nvisible from inside the scope. Methods (in the case that the package is\nalso a class) have a separate method table, and are accessible through\nintrospection on the class itself, via .can and .^methods.","mro":["Associative","Iterable","Hash"],"k":"c","m":[{"n":"package_at_key","m":0,"k":"m","s":{"r":"Mu","p":["str $key","*%_"]}},{"n":"merge-symbols","s":{"p":["Hash $globalish","*%_"],"r":"Mu"},"k":"m","m":0}],"b":"C"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<lt>"},{"n":"infix:<lt>","k":"s","m":1,"s":{"p":["$x?"],"r":"Mu"}},{"s":{"r":"Mu","p":["\\a","\\b"]},"k":"s","m":1,"n":"infix:<lt>"},{"s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"k":"s","m":1,"n":"infix:<lt>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Str:D \\a","Str:D \\b"]},"n":"infix:<lt>"},{"n":"infix:<lt>","s":{"p":["str $a","str $b"],"r":"Bool:D"},"k":"s","m":1},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<===>"},{"n":"infix:<===>","m":1,"k":"s","s":{"p":["$?"],"r":"Bool"}},{"n":"infix:<===>","s":{"r":"Bool:D","p":["\\a","\\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["Enumeration:D \\a","Enumeration:D \\b"],"r":"Mu"},"n":"infix:<===>"},{"n":"infix:<===>","k":"s","m":1,"s":{"p":["Int:D $a","Int:D $b"],"r":"Bool:D"}},{"s":{"p":["int $a","int $b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<===>"},{"n":"infix:<===>","m":1,"k":"s","s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]}},{"n":"infix:<===>","m":1,"k":"s","s":{"r":"Bool:D","p":["num \\a","num \\b"]}},{"n":"infix:<===>","k":"s","m":1,"s":{"p":["Str:D \\a","Str:D \\b"],"r":"Bool:D"}},{"k":"s","m":1,"s":{"r":"Bool:D","p":["str $a","str $b"]},"n":"infix:<===>"},{"n":"infix:<===>","s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Complex:D \\a","Complex:D \\b"]},"n":"infix:<===>"},{"n":"infix:<===>","k":"s","m":1,"s":{"p":["IntStr:D $a","IntStr:D $b"],"r":"Mu"}},{"s":{"p":["RatStr:D $a","RatStr:D $b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<===>"},{"k":"s","m":1,"s":{"p":["NumStr:D $a","NumStr:D $b"],"r":"Mu"},"n":"infix:<===>"},{"m":1,"k":"s","s":{"r":"Mu","p":["ComplexStr:D $a","ComplexStr:D $b"]},"n":"infix:<===>"},{"k":"e","n":"SOCK_STREAM","t":"SocketType"},{"t":"Sub+{is-pure}","n":"&sin","k":"v"},{"s":{"r":"Mu","p":["Numeric \\x"]},"k":"s","m":1,"n":"sin"},{"n":"sin","m":1,"k":"s","s":{"r":"Mu","p":["Cool \\x"]}},{"m":1,"k":"s","s":{"r":"num","p":["num $x"]},"n":"sin"},{"t":"Sub","n":"&atomic-dec-fetch","k":"v"},{"s":{"p":["atomicint $target is rw"],"r":"atomicint"},"m":1,"k":"s","n":"atomic-dec-fetch"},{"k":"v","n":"&atan2","t":"Sub"},{"n":"atan2","s":{"p":["Real \\a","Real \\b = 1e0"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["\\a","\\b = 1e0"],"r":"Mu"},"k":"s","m":1,"n":"atan2"},{"s":{"r":"Mu","p":["Num:D $a","Num:D $b = 1e0"]},"k":"s","m":1,"n":"atan2"},{"n":"&infix:<xor>","t":"Sub+{Precedence}","k":"v"},{"n":"infix:<xor>","k":"s","m":1,"s":{"p":["Mu $x = Bool::False"],"r":"Mu"}},{"n":"infix:<xor>","s":{"p":["Mu \\a","&b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<xor>","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Mu","p":["|c is raw"]},"k":"s","m":1,"n":"infix:<xor>"},{"k":"v","t":"Sub+{is-pure}","n":"&acotanh"},{"s":{"p":["Numeric \\x"],"r":"Mu"},"m":1,"k":"s","n":"acotanh"},{"m":1,"k":"s","s":{"r":"Mu","p":["Cool \\x"]},"n":"acotanh"},{"n":"acotanh","k":"s","m":1,"s":{"p":["num $x"],"r":"num"}},{"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"clone"},{"s":{"r":"Nil","p":["Str:D \\key","Mu \\x","*%_"]},"m":1,"k":"m","n":"STORE_AT_KEY"},{"n":"STORE_AT_KEY","s":{"r":"Nil","p":["\\key","Mu \\x","*%_"]},"m":1,"k":"m"},{"n":"STORE","m":1,"k":"m","s":{"p":["\\to_store","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["\\keys","\\values","*%_"]},"k":"m","m":1,"n":"STORE"},{"s":{"p":["\\key","Mu \\bindval","*%_"],"r":"Mu"},"m":1,"k":"m","n":"BIND-KEY"},{"n":"BIND-KEY","k":"m","m":1,"s":{"r":"Mu","p":["Str:D \\key","Mu \\bindval","*%_"]}},{"d":"Defined as:\n\n    method keyof()\n\nReturns the type constraint for the keys of the invocant. For normal hashes\nthe method returns the coercion type (Str(Any)) while for non-string keys\nhashes the type used in the declaration of the Hash is returned.\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;  # (no key type specified)\n    say %h1.keyof;                           # OUTPUT: «(Str(Any))␤»\n\n    my %h2{Str} = 'oranges' => 7;            # (keys must be of type Str)\n    say %h2.keyof;                           # (Str)\n    %h2{3} = 'apples';                       # throws exception\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding: Type check failed in binding to key; expected Str but got Int (3)␤»\n\n    my %h3{Int};                             # (this time, keys must be of type Int)\n    %h3{42} = 4096;\n    say %h3.keyof;                           # (Int)","n":"keyof","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"of","d":"Defined as:\n\n    method of()\n\nReturns the type constraint for the values of the invocant. By default,\ni.e., if no type constraint is given during declaration, the method returns\n(Mu).\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;  # (no type constraint specified)\n    say %h1.of;                              # OUTPUT: «(Mu)␤»\n\n    my Int %h2 = 'oranges' => 7;             # (values must be of type Int)\n    say %h2.of;                              # OUTPUT: «(Int)␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"default","d":"Defined as:\n\n    method default()\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen a non existing key is used to access an element in the Hash. Unless\nthe Hash is declared as having a default value by using the is default\ntrait the method returns the type object (Any).\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;\n    say %h1.default;                                       # OUTPUT: «(Any)␤»\n    say %h1{'bananas'};                                    # OUTPUT: «(Any)␤»\n\n    my %h2 is default(1) = 'apples' => 3, 'oranges' => 7;\n    say %h2.default;                                       # OUTPUT: «1␤»\n    say %h2{'apples'} + %h2{'bananas'};                    # OUTPUT: «4␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method dynamic(--> Bool:D)\n\nReturns True if the invocant has been declared with the is dynamic trait.\n\n    my %a;\n    say %a.dynamic;                          # OUTPUT: «False␤»\n\n    my %b is dynamic;\n    say %b.dynamic;                          # OUTPUT: «True␤»\n\nIf you declare a variable with the * twigil is dynamic is implied.\n\n    my %*b;\n    say %*b.dynamic;                         # OUTPUT: «True␤»\n\nNote that in the Scalar case you have to use the VAR method in order to get\ncorrect information.\n\n    my $s is dynamic = %('apples' => 5);\n    say $s.dynamic;                   # OUTPUT: «False␤»  (wrong, don't do this)\n    say $s.VAR.dynamic;               # OUTPUT: «True␤»   (correct approach)\n\nSubscript Adverbs\n\nSome methods are implemented as adverbs on subscripts (consult the\noperators documentation for more information).\n\n  :exists\n\nThe adverb :exists returns Bool::True if a key exists in the Hash. If more\nthan one key is supplied it returns a List of Bool.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:exists;   # OUTPUT: «True␤»\n    say %h<a b>:exists; # OUTPUT: «(True True)␤»\n\n  :delete\n\nUse :delete to remove a Pair from the Hash.\n\n    my %h = a => 1;\n    say %h;         # OUTPUT: «{a => 1}␤»\n    say %h.elems;   # OUTPUT: «1␤»\n\n    %h<a>:delete;\n    say %h;         # OUTPUT: «{}␤»\n    say %h.elems;   # OUTPUT: «0␤»\n\n  :p\n\nThe adverb :p returns a Pair or a List of Pair instead of just the value.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:p;    # OUTPUT: «a => 1␤»\n    say %h<a b>:p;  # OUTPUT: «(a => 1 b=> 2)␤»\n\n  :v and :k\n\nThe adverbs :v and :k return the key or value or a list thereof.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:k;    # OUTPUT: «a␤»\n    say %h<a b>:k;  # OUTPUT: «(a b)␤»\n\nThe adverb :kv returns a list of keys and values.\n\n    my %h = a => 1, b => 2, c => 3;\n    say %h<a c>:kv;  # OUTPUT: «(a 1 c 3)␤»\n\nYou can also use the adverbs without knowing anything about the hash by\nusing empty angle brackets in which case all the keys and values will be\nlisted:\n\n    my %h1 = a => 1;\n    my %h2 = a => 1, b => 2;\n    say %h1<>:k; # OUTPUT: «(a)␤»\n    say %h1<>:v; # OUTPUT: «(1)␤»\n    say %h2<>:k; # OUTPUT: «(a b)␤»\n    say %h2<>:v; # OUTPUT: «(1 2)␤»","n":"dynamic","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    multi method push(Hash:D: *@new)\n\nAdds the @new elements to the hash with the same semantics as hash\nassignment, but with three exceptions:\n\n  * The hash isn't emptied first, i.e. old pairs are not deleted.\n\n  * If a key already exists in the hash, and the corresponding value is an\n  Array, the new value is pushed onto the array (instead of replacing it).\n\n  * If a key already exists in the hash, and the corresponding value is not an\n  Array, old and new value are both placed into an array in the place of the\n  old value.\n\nExample:\n\n    my %h  = a => 1;\n    %h.push: (a => 1);              # a => [1,1]\n    %h.push: (a => 1) xx 3 ;        # a => [1,1,1,1,1]\n    %h.push: (b => 3);              # a => [1,1,1,1,1], b => 3\n    %h.push('c' => 4);              # a => [1,1,1,1,1], b => 3, c => 4\n    push %h, 'd' => 5;              # a => [1,1,1,1,1], b => 3, c => 4, d => 5\n\nPlease note that Pairs or colon pairs as arguments to push will be treated\nas extra named arguments and as such wont end up the Hash. The same applies\nto the sub push.\n\n    my %h .= push(e => 6);\n    push %h, f => 7;\n    say %h.perl;\n    # OUTPUT: «{}␤»\n\nAlso note that push can be used as a replacement for assignment during hash\ninitialization very useful ways. Take for instance the case of an inverted\nindex:\n\n    my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\n    (my %inv).push: %wc.invert;\n    say %inv;                     # OUTPUT: «{322 => pair, 323 => [pipe hash]}␤»\n\nNote that such an initialization could also be written as\n\n    my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\n    my %inv .= push: %wc.invert;\n\nNote: Compared to append, push will add the given value as is, whereas\nappend will slip it in:\n\n    my %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\n    say %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»\n\n    my %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\n    say %hb; # OUTPUT: «{a => [42 a b c a]}␤»","n":"push","m":0,"k":"m","s":{"p":["+\\values is raw","*%_"],"r":"Mu"}},{"s":{"p":["+\\values is raw","*%_"],"r":"Mu"},"m":0,"k":"m","n":"append","d":"Defined as:\n\n    method append(+@values)\n\nAppend the provided Pairs or even sized list to the Hash. If a key already\nexists, turn the existing value into an Array and push new value onto that\nArray. Please note that you can't mix even sized lists and lists of Pairs.\nAlso, bare Pairs or colon pairs will be treated as named arguments to\n.append.\n\n    my %h = a => 1;\n    %h.append('b', 2, 'c', 3);\n    %h.append( %(d => 4) );\n    say %h;\n    # OUTPUT: «{a => 1, b => 2, c => 3, d => 4}␤»\n    %h.append('a', 2);\n    # OUTPUT: «{{a => [1 2], b => 2, c => 3, d => 4}␤»\n\nNote: Compared to push, append will slip in the given value, whereas push\nwill add it as is:\n\n    my %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\n    say %hb; # OUTPUT: «{a => [42 a b c a]}␤»\n\n    my %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\n    say %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»"},{"n":"classify-list","d":"Defined as:\n\n    multi method classify-list(&mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(%mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple classification\n\nIn simple classification mode, each mapper's value is any non-Iterable and\nrepresents a key to classify @list's item under:\n\n    say % .classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: «{even => [0 2 4 6 8], odd => [1 3 5 7 9]}␤»\n\n    my @mapper = <zero one two three four five>;\n    my %hash = foo => 'bar';\n    say %hash.classify-list: @mapper, 1, 2, 3, 4, 4;\n    # OUTPUT: «{foo => bar, four => [4 4], one => [1], three => [3], two => [2]}␤»\n\n\nThe mapper's value is used as the key of the Hash to which the @list's item\nwill be pushed. See .categorize-list if you wish to classify an item into\nmultiple categories at once.\n\n    Multi-level classification\n\nIn multi-level classification mode, each mapper's value is an Iterable that\nrepresents a tree of hash keys to classify @list's item under:\n\n    say % .classify-list: {\n        [\n            (.is-prime ?? 'prime' !! 'non-prime'),\n            ($_ %% 2   ?? 'even'  !! 'odd'      ),\n        ]\n    }, ^10;\n    # OUTPUT:\n    # {\n    #     non-prime => {\n    #         even => [0 4 6 8],\n    #         odd  => [1 9]\n    #     },\n    #     prime => {\n    #         even => [2],\n    #         odd  => [3 5 7]\n    #     }\n    # }\n\nNOTE: each of those Iterables must have the same number of elements, or the\nmethod will throw an exception. This restriction exists to avoid conflicts\nwhen the same key is a leaf of one value's classification but a node of\nanother value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .classify-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","s":{"r":"Mu","p":["&test","\\list",":&as","*%_"]},"k":"m","m":1},{"d":"Defined as:\n\n    multi method classify-list(&mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(%mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple classification\n\nIn simple classification mode, each mapper's value is any non-Iterable and\nrepresents a key to classify @list's item under:\n\n    say % .classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: «{even => [0 2 4 6 8], odd => [1 3 5 7 9]}␤»\n\n    my @mapper = <zero one two three four five>;\n    my %hash = foo => 'bar';\n    say %hash.classify-list: @mapper, 1, 2, 3, 4, 4;\n    # OUTPUT: «{foo => bar, four => [4 4], one => [1], three => [3], two => [2]}␤»\n\n\nThe mapper's value is used as the key of the Hash to which the @list's item\nwill be pushed. See .categorize-list if you wish to classify an item into\nmultiple categories at once.\n\n    Multi-level classification\n\nIn multi-level classification mode, each mapper's value is an Iterable that\nrepresents a tree of hash keys to classify @list's item under:\n\n    say % .classify-list: {\n        [\n            (.is-prime ?? 'prime' !! 'non-prime'),\n            ($_ %% 2   ?? 'even'  !! 'odd'      ),\n        ]\n    }, ^10;\n    # OUTPUT:\n    # {\n    #     non-prime => {\n    #         even => [0 4 6 8],\n    #         odd  => [1 9]\n    #     },\n    #     prime => {\n    #         even => [2],\n    #         odd  => [3 5 7]\n    #     }\n    # }\n\nNOTE: each of those Iterables must have the same number of elements, or the\nmethod will throw an exception. This restriction exists to avoid conflicts\nwhen the same key is a leaf of one value's classification but a node of\nanother value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .classify-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","n":"classify-list","k":"m","m":1,"s":{"p":["%test","|c is raw"],"r":"Mu"}},{"s":{"r":"Mu","p":["@test","|c is raw"]},"m":1,"k":"m","n":"classify-list","d":"Defined as:\n\n    multi method classify-list(&mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(%mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple classification\n\nIn simple classification mode, each mapper's value is any non-Iterable and\nrepresents a key to classify @list's item under:\n\n    say % .classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: «{even => [0 2 4 6 8], odd => [1 3 5 7 9]}␤»\n\n    my @mapper = <zero one two three four five>;\n    my %hash = foo => 'bar';\n    say %hash.classify-list: @mapper, 1, 2, 3, 4, 4;\n    # OUTPUT: «{foo => bar, four => [4 4], one => [1], three => [3], two => [2]}␤»\n\n\nThe mapper's value is used as the key of the Hash to which the @list's item\nwill be pushed. See .categorize-list if you wish to classify an item into\nmultiple categories at once.\n\n    Multi-level classification\n\nIn multi-level classification mode, each mapper's value is an Iterable that\nrepresents a tree of hash keys to classify @list's item under:\n\n    say % .classify-list: {\n        [\n            (.is-prime ?? 'prime' !! 'non-prime'),\n            ($_ %% 2   ?? 'even'  !! 'odd'      ),\n        ]\n    }, ^10;\n    # OUTPUT:\n    # {\n    #     non-prime => {\n    #         even => [0 4 6 8],\n    #         odd  => [1 9]\n    #     },\n    #     prime => {\n    #         even => [2],\n    #         odd  => [3 5 7]\n    #     }\n    # }\n\nNOTE: each of those Iterables must have the same number of elements, or the\nmethod will throw an exception. This restriction exists to avoid conflicts\nwhen the same key is a leaf of one value's classification but a node of\nanother value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .classify-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }"},{"n":"classify-list","d":"Defined as:\n\n    multi method classify-list(&mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(%mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple classification\n\nIn simple classification mode, each mapper's value is any non-Iterable and\nrepresents a key to classify @list's item under:\n\n    say % .classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: «{even => [0 2 4 6 8], odd => [1 3 5 7 9]}␤»\n\n    my @mapper = <zero one two three four five>;\n    my %hash = foo => 'bar';\n    say %hash.classify-list: @mapper, 1, 2, 3, 4, 4;\n    # OUTPUT: «{foo => bar, four => [4 4], one => [1], three => [3], two => [2]}␤»\n\n\nThe mapper's value is used as the key of the Hash to which the @list's item\nwill be pushed. See .categorize-list if you wish to classify an item into\nmultiple categories at once.\n\n    Multi-level classification\n\nIn multi-level classification mode, each mapper's value is an Iterable that\nrepresents a tree of hash keys to classify @list's item under:\n\n    say % .classify-list: {\n        [\n            (.is-prime ?? 'prime' !! 'non-prime'),\n            ($_ %% 2   ?? 'even'  !! 'odd'      ),\n        ]\n    }, ^10;\n    # OUTPUT:\n    # {\n    #     non-prime => {\n    #         even => [0 4 6 8],\n    #         odd  => [1 9]\n    #     },\n    #     prime => {\n    #         even => [2],\n    #         odd  => [3 5 7]\n    #     }\n    # }\n\nNOTE: each of those Iterables must have the same number of elements, or the\nmethod will throw an exception. This restriction exists to avoid conflicts\nwhen the same key is a leaf of one value's classification but a node of\nanother value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .classify-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","s":{"r":"Mu","p":["&test","**@list","|c is raw"]},"m":1,"k":"m"},{"k":"m","m":1,"s":{"p":["&test","\\list",":&as","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(%mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple categorization\n\nThe mapper's value is expected to be a possibly empty list of non-Iterables\nthat represent categories to place the value into:\n\n    say % .categorize-list: {\n        gather {\n            take 'prime'   if .is-prime;\n            take 'largish' if $_ > 5;\n            take $_ %% 2 ?? 'even' !! 'odd';\n        }\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     prime   => [2 3 5 7]\n    #     even    => [0 2 4 6 8],\n    #     odd     => [1 3 5 7 9],\n    #     largish => [6 7 8 9],\n    # }\n\nNotice how some items, e.g. 6 and 7, are present in several categories.\n\n    Multi-level categorization\n\nIn multi-level categorization, the categories produced by the mapper can\nare Iterables and categorization combines features of classify, by\nproducing nested hashes of classifications for each category.\n\n    say % .categorize-list: {\n        [\n            $_ > 5    ?? 'largish' !! 'smallish',\n            .is-prime ?? 'prime'   !! 'non-prime',\n        ],\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     largish => {\n    #         non-prime => [6 8 9],\n    #         prime     => [7]\n    #     },\n    #     smallish => {\n    #         non-prime => [0 1 4],\n    #         prime     => [2 3 5]\n    #     }\n    # }\n\nThe mapper in above snippet produces single-item list (note the significant\ntrailing comma) with a two-item Array in it. The first item in that array\nindicates the first level of classification: the largish/smallish\ncategories the routine produces. The second item in that array indicates\nfurther levels of classification, in our case the classification into\nprime/non-prime inside of each category.\n\nNOTE: each of category Iterables must have the same number of elements, or\nthe method will throw an exception. This restriction exists to avoid\nconflicts when the same key is a leaf of one value's classification but a\nnode of another value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .categorize-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","n":"categorize-list"},{"m":1,"k":"m","s":{"p":["%test","|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(%mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple categorization\n\nThe mapper's value is expected to be a possibly empty list of non-Iterables\nthat represent categories to place the value into:\n\n    say % .categorize-list: {\n        gather {\n            take 'prime'   if .is-prime;\n            take 'largish' if $_ > 5;\n            take $_ %% 2 ?? 'even' !! 'odd';\n        }\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     prime   => [2 3 5 7]\n    #     even    => [0 2 4 6 8],\n    #     odd     => [1 3 5 7 9],\n    #     largish => [6 7 8 9],\n    # }\n\nNotice how some items, e.g. 6 and 7, are present in several categories.\n\n    Multi-level categorization\n\nIn multi-level categorization, the categories produced by the mapper can\nare Iterables and categorization combines features of classify, by\nproducing nested hashes of classifications for each category.\n\n    say % .categorize-list: {\n        [\n            $_ > 5    ?? 'largish' !! 'smallish',\n            .is-prime ?? 'prime'   !! 'non-prime',\n        ],\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     largish => {\n    #         non-prime => [6 8 9],\n    #         prime     => [7]\n    #     },\n    #     smallish => {\n    #         non-prime => [0 1 4],\n    #         prime     => [2 3 5]\n    #     }\n    # }\n\nThe mapper in above snippet produces single-item list (note the significant\ntrailing comma) with a two-item Array in it. The first item in that array\nindicates the first level of classification: the largish/smallish\ncategories the routine produces. The second item in that array indicates\nfurther levels of classification, in our case the classification into\nprime/non-prime inside of each category.\n\nNOTE: each of category Iterables must have the same number of elements, or\nthe method will throw an exception. This restriction exists to avoid\nconflicts when the same key is a leaf of one value's classification but a\nnode of another value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .categorize-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","n":"categorize-list"},{"k":"m","m":1,"s":{"r":"Mu","p":["@test","|c is raw"]},"d":"Defined as:\n\n    multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(%mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple categorization\n\nThe mapper's value is expected to be a possibly empty list of non-Iterables\nthat represent categories to place the value into:\n\n    say % .categorize-list: {\n        gather {\n            take 'prime'   if .is-prime;\n            take 'largish' if $_ > 5;\n            take $_ %% 2 ?? 'even' !! 'odd';\n        }\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     prime   => [2 3 5 7]\n    #     even    => [0 2 4 6 8],\n    #     odd     => [1 3 5 7 9],\n    #     largish => [6 7 8 9],\n    # }\n\nNotice how some items, e.g. 6 and 7, are present in several categories.\n\n    Multi-level categorization\n\nIn multi-level categorization, the categories produced by the mapper can\nare Iterables and categorization combines features of classify, by\nproducing nested hashes of classifications for each category.\n\n    say % .categorize-list: {\n        [\n            $_ > 5    ?? 'largish' !! 'smallish',\n            .is-prime ?? 'prime'   !! 'non-prime',\n        ],\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     largish => {\n    #         non-prime => [6 8 9],\n    #         prime     => [7]\n    #     },\n    #     smallish => {\n    #         non-prime => [0 1 4],\n    #         prime     => [2 3 5]\n    #     }\n    # }\n\nThe mapper in above snippet produces single-item list (note the significant\ntrailing comma) with a two-item Array in it. The first item in that array\nindicates the first level of classification: the largish/smallish\ncategories the routine produces. The second item in that array indicates\nfurther levels of classification, in our case the classification into\nprime/non-prime inside of each category.\n\nNOTE: each of category Iterables must have the same number of elements, or\nthe method will throw an exception. This restriction exists to avoid\nconflicts when the same key is a leaf of one value's classification but a\nnode of another value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .categorize-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","n":"categorize-list"},{"s":{"p":["&test","**@list","|c is raw"],"r":"Mu"},"m":1,"k":"m","n":"categorize-list","d":"Defined as:\n\n    multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(%mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple categorization\n\nThe mapper's value is expected to be a possibly empty list of non-Iterables\nthat represent categories to place the value into:\n\n    say % .categorize-list: {\n        gather {\n            take 'prime'   if .is-prime;\n            take 'largish' if $_ > 5;\n            take $_ %% 2 ?? 'even' !! 'odd';\n        }\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     prime   => [2 3 5 7]\n    #     even    => [0 2 4 6 8],\n    #     odd     => [1 3 5 7 9],\n    #     largish => [6 7 8 9],\n    # }\n\nNotice how some items, e.g. 6 and 7, are present in several categories.\n\n    Multi-level categorization\n\nIn multi-level categorization, the categories produced by the mapper can\nare Iterables and categorization combines features of classify, by\nproducing nested hashes of classifications for each category.\n\n    say % .categorize-list: {\n        [\n            $_ > 5    ?? 'largish' !! 'smallish',\n            .is-prime ?? 'prime'   !! 'non-prime',\n        ],\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     largish => {\n    #         non-prime => [6 8 9],\n    #         prime     => [7]\n    #     },\n    #     smallish => {\n    #         non-prime => [0 1 4],\n    #         prime     => [2 3 5]\n    #     }\n    # }\n\nThe mapper in above snippet produces single-item list (note the significant\ntrailing comma) with a two-item Array in it. The first item in that array\nindicates the first level of classification: the largish/smallish\ncategories the routine produces. The second item in that array indicates\nfurther levels of classification, in our case the classification into\nprime/non-prime inside of each category.\n\nNOTE: each of category Iterables must have the same number of elements, or\nthe method will throw an exception. This restriction exists to avoid\nconflicts when the same key is a leaf of one value's classification but a\nnode of another value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .categorize-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }"},{"n":"!AT_KEY_CONTAINER","s":{"p":["Str:D \\key","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!_push_construct","s":{"p":["Mu $key","Mu \\value","*%_"],"r":"Nil"},"m":0,"k":"m"},{"n":"!_append_construct","s":{"p":["Mu $key","Mu \\value","*%_"],"r":"Nil"},"m":0,"k":"m"},{"n":"!STORE_MAP","m":0,"k":"m","s":{"r":"Nil","p":["\\map","*%_"]}}],"k":"c","mro":["Associative","Iterable","Map"],"a":[{"n":"$!descriptor","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!storage"}],"d":"TITLE\nclass Hash\n\nSUBTITLE\nMapping from strings to itemized values\n\n    class Hash is Map { }\n\nA Hash is a mutable Map; it implements Associative through its inheritance\nof Map and as such provides support for looking up values using keys,\nproviding support for associative subscripting.\n\nAlthough the order of the hashes is guaranteed to be random in every single\ncall, still successive calls to .keys and .values are guaranteed to return\nthem in the same order:\n\n    my %orig = :1a, :2b; my %new = :5b, :6c;\n    %orig{ %new.keys } = %new.values;\n    say %orig.perl; # OUTPUT: «{:a(1), :b(5), :c(6)}␤»\n\nIn this case, b will always be associated to 5 and c to 6; even if two\nsuccessive calls to keys will return them in different order. Successive\ncalls to any of them separately and repeatedly will always return the same\norder in any program invocation.\n\nPlease see the section on hash literals for different ways to declare a\nhash. Additionally, they can be declared using curly braces as long as\nthese rules are followed:\n\n  * Empty curly braces will always declare an empty hash.\n\n  * A reference to $_ (even implicit) will instead declare a block.\n\n  * A Pair or variable with % as the first element will declare a hash.\n\n    given 3 { say WHAT {3 => 4, :b}  };     # OUTPUT: «(Hash)␤»\n    given 3 { say WHAT {3 => 4, :b($_)} };  # OUTPUT: «(Block)␤»\n    given 3 { say WHAT {3 => 4, :b(.Num)} };# OUTPUT: «(Block)␤»\n    say { 'a',:b(3), 'c' }.^name;           # OUTPUT: «Block␤»\n\n\nThe next-to-last two cases are examples of the generation of Blocks in the\npresence of the topic variable $_. The last case does not meet the third\ncriterium for generating a hash, and thus generates a Block.\n\nA % in front of parentheses or square brackets will generate a Hash as long\nas the elements can be paired.\n\n    say %( 'a', 3, :b(3), 'c', 3 ).^name; # OUTPUT: «Hash␤»\n\nElements in this hash can be paired both sides of the Pair :b(3).\n\n    say %(«a b c 1 2 3»).^name;           # OUTPUT: «Hash␤»\n\nAn empty hash can be initialized either with empty curly braces or, since\n6.d, %().\n\n    say %().^name; # OUTPUT: «Hash␤»\n    say {}.^name;  # OUTPUT: «Hash␤»\n\n","t":"Hash","n":"Hash","b":"C"},{"t":"Sub+{Precedence}","n":"&infix:<...>","k":"v"},{"n":"infix:<...>","k":"s","m":1,"s":{"p":["\\a","Mu \\b"],"r":"Mu"}},{"s":{"p":["|lol is raw"],"r":"Mu"},"m":1,"k":"s","n":"infix:<...>"},{"n":"&infix:<**>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<**>","s":{"p":["$x = 1"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<**>","m":1,"k":"s","s":{"r":"Mu","p":["\\a","\\b"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"n":"infix:<**>"},{"n":"infix:<**>","s":{"r":"Real:D","p":["Int:D \\a","Int:D \\b"]},"m":1,"k":"s"},{"n":"infix:<**>","k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"}},{"n":"infix:<**>","s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]},"m":1,"k":"s"},{"n":"infix:<**>","m":1,"k":"s","s":{"r":"num","p":["num $a","num $b"]}},{"n":"infix:<**>","s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<**>","s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Complex:D"},"m":1,"k":"s"},{"s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Complex:D"},"k":"s","m":1,"n":"infix:<**>"},{"n":"infix:<**>","m":1,"k":"s","s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Complex:D"}},{"t":"Sub+{is-pure}","n":"&infix:«+<»","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"infix:«+<»"},{"n":"infix:«+<»","s":{"r":"Mu","p":["$x"]},"m":1,"k":"s"},{"n":"infix:«+<»","s":{"r":"Mu","p":["$x","$y"]},"k":"s","m":1},{"s":{"r":"Int:D","p":["Int:D \\a","Int:D \\b"]},"k":"s","m":1,"n":"infix:«+<»"},{"k":"s","m":1,"s":{"r":"int","p":["int $a","int $b"]},"n":"infix:«+<»"},{"n":"e","t":"Num","mro":["Real","Numeric","Cool"],"k":"c","b":"C"},{"t":"Signal","n":"SIGPROF","k":"e"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<leg>","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<leg>"},{"n":"infix:<leg>","m":1,"k":"s","s":{"p":["Str:D \\a","Str:D \\b"],"r":"Order:D"}},{"n":"infix:<leg>","s":{"r":"Order:D","p":["str $a","str $b"]},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&substr"},{"n":"substr","k":"s","m":1,"s":{"p":["\\what"],"r":"Str:D"}},{"s":{"r":"Str:D","p":["\\what","\\from"]},"m":1,"k":"s","n":"substr"},{"n":"substr","k":"s","m":1,"s":{"p":["\\what","\\from","\\chars"],"r":"Str:D"}},{"k":"v","n":"&infix:<=~=>","t":"Sub"},{"n":"infix:<=~=>","s":{"r":"Mu","p":["$?"]},"m":1,"k":"s"},{"s":{"p":["\\a","\\b",":$tolerance = { ... }"],"r":"Mu"},"m":1,"k":"s","n":"infix:<=~=>"},{"n":"infix:<≅>","m":1,"k":"s","s":{"p":["Inf","Inf"],"r":"Mu"}},{"n":"infix:<≅>","s":{"r":"Mu","p":["-Inf","-Inf"]},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Complex:D \\a","Complex:D \\b"]},"n":"infix:<≅>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Complex:D \\a","Num(Real) \\b"]},"n":"infix:<≅>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Num(Real) \\a","Complex:D \\b"]},"n":"infix:<≅>"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∩>","k":"v"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<(&)>"},{"s":{"r":"Mu","p":["QuantHash:D \\a"]},"k":"s","m":1,"n":"infix:<(&)>"},{"n":"infix:<(&)>","m":1,"k":"s","s":{"r":"Mu","p":["\\a"]}},{"n":"infix:<(&)>","k":"s","m":1,"s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]}},{"n":"infix:<(&)>","s":{"r":"Mu","p":["Setty:D \\a","Baggy:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","Setty:D \\b"]},"n":"infix:<(&)>"},{"n":"infix:<(&)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]}},{"n":"infix:<(&)>","s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Baggy:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(&)>"},{"s":{"r":"Mu","p":["Mixy:D \\a","Baggy:D \\b"]},"k":"s","m":1,"n":"infix:<(&)>"},{"n":"infix:<(&)>","k":"s","m":1,"s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"}},{"n":"infix:<(&)>","s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(&)>","s":{"r":"Mu","p":["Baggy:D \\a","Any:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Any:D \\a","Baggy:D \\b"],"r":"Mu"},"n":"infix:<(&)>"},{"n":"infix:<(&)>","m":1,"k":"s","s":{"r":"Mu","p":["Mixy:D \\a","Any:D \\b"]}},{"n":"infix:<(&)>","s":{"r":"Mu","p":["Any:D \\a","Mixy:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(&)>","m":1,"k":"s","s":{"p":["Map:D \\a","Map:D \\b"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["$","Failure:D \\b"]},"n":"infix:<(&)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Failure:D \\a","$"]},"n":"infix:<(&)>"},{"k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"},"n":"infix:<(&)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["**@p"]},"n":"infix:<(&)>"},{"a":[{"k":"v","n":"@!dispatchees","t":"List"},{"k":"v","n":"$!dispatcher_cache","t":"Mu"},{"n":"$!dispatcher","t":"Mu","k":"v"},{"t":"int","n":"$!rw","k":"v"},{"k":"v","n":"$!inline_info","t":"Mu"},{"n":"$!yada","t":"int","k":"v"},{"k":"v","t":"Mu","n":"$!package"},{"t":"int","n":"$!onlystar","k":"v"},{"n":"@!dispatch_order","t":"List","k":"v"},{"t":"Mu","n":"$!dispatch_cache","k":"v"},{"n":"$!why","t":"Mu","k":"v"},{"k":"v","t":"Code","n":"$!do"},{"k":"v","t":"Signature","n":"$!signature"},{"k":"v","t":"List","n":"@!compstuff"}],"d":"TITLE\nclass Method\n\nSUBTITLE\nMember function\n\n    class Method is Routine { }\n\nA type for methods that behave the same way then Routine with some\nexceptions listed in the following. For details of a method's parameter\nlist see Signature.\n\nTo create a method outside a class definition, use the declarators my and\nmethod. If an identifier is provided the methods name will be injected into\nthe scope specified by the declarator.\n\n    my $m = method ($invocant: $param) {\n        say \"$invocant: '$param'\";\n    }\n    \"greeting\".$m(\"hello\");  # OUTPUT: «greeting: 'hello'␤»\n\n    <a b c>.&(my method (List:D:) { say self.perl; self }).say;\n    # OUTPUT: «(\"a\", \"b\", \"c\")␤(a b c)␤»\n\nThe invocant of a method defaults to self. A type constraint including a\ntype-smiley can be used and is honored both for methods defined in a class\nand for free floating methods. Call the latter with .& on an object.\n\n    my method m(Int:D: $b){\n        say self.^name\n    }\n    my $i = 1;\n    $i.&m(<a>);\n    # OUTPUT: «Int␤»\n\n Methods will ignore extra named arguments where other types of Routine\nwill throw at runtime. Extra arguments will be forwarded by nextsame and\nfriends.\n\n    class A {\n        multi method m(:$a, :$b) { say \"2 named\" }\n    }\n\n    class B is A {\n        method m(:$a) { say \"1 named\"; nextsame }\n    }\n    B.m( :1a, :2b );\n    # OUTPUT: «1 named␤2 named␤»\n\n  sub lastcall\n\n    sub lastcall(--> True)\n\nTruncates the current dispatch chain, which means any calls to nextsame,\ncallsame, nextwith, and callwith will not find any of the next candidates.\nNote that since samewith restarts the dispatch from the start, it's not\naffected by the truncation of current chain with lastcall.\n\nConsider example below. foo(6) uses nextsame when lastcall hasn't been\ncalled, and so it reaches the Any candidate. foo(2) calls nextsame as well,\nbut since lastcall was called first, the dispatch chain was truncated and\nthe Any candidate was not reached. The last call, foo(1), calls lastcall\ntoo, however, it then uses samewith, which isn't affected by it, and so the\ndispatch re-starts from scratch, hits the Int candidate with the new\nargument 6, and then proceeds to the Any candidate via nextsame (which\nisn't affected by the lastcall that was used before the samewith was\ncalled):\n\n    multi foo (Int $_) {\n        say \"Int: $_\";\n        lastcall   when *.is-prime;\n        nextsame   when *  %% 2;\n        samewith 6 when * !%% 2;\n    }\n    multi foo (Any $x) { say \"Any $x\" }\n\n    foo 6; say '----';\n    foo 2; say '----';\n    foo 1;\n\n    # OUTPUT:\n    # Int: 6\n    # Any 6\n    # ----\n    # Int: 2\n    # ----\n    # Int: 1\n    # Int: 6\n    # Any 6","t":"Method","n":"Method","k":"c","mro":["Callable","Routine"],"b":"A"},{"t":"Sub+{is-pure}","n":"&any","k":"v"},{"n":"any","k":"s","m":1,"s":{"r":"Mu","p":["+\\values is raw"]}},{"k":"v","t":"Sub","n":"&infix:<!~~>"},{"m":1,"k":"s","s":{"p":["Mu \\topic","Mu \\matcher"],"r":"Mu"},"n":"infix:<!~~>"},{"n":"&infix:<⊇>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","\\b"]},"n":"infix:<⊇>"},{"b":"A","a":[{"k":"v","n":"$!WHICH","t":"ValueObjAt"},{"k":"v","n":"$!total","t":"Int"},{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"d":"TITLE\nclass Bag\n\nSUBTITLE\nImmutable collection of distinct objects with integer weights\n\n    class Bag does Baggy { }\n\nA Bag is an immutable bag/multiset implementing Associative, meaning a\ncollection of distinct elements in no particular order that each have an\ninteger weight assigned to them signifying how many copies of that element\nare considered \"in the bag\". (For mutable bags, see BagHash instead.)\n\nBags are often used for performing weighted random selections - see .pick\nand .roll.\n\nObjects/values of any type are allowed as bag elements. Within a Bag, items\nthat would compare positively with the === operator are considered the same\nelement, with the number of how many there are as its weight. But of course\nyou can also easily get back the expanded list of items (without the\norder):\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBags can be treated as object hashes using the { } postcircumfix operator,\nor the < >  operator for literal string keys, which returns the\ncorresponding integer weight for keys that are elements of the bag, and 0\nfor keys that aren't:\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n    say $breakfast<bacon>;    # OUTPUT: «1␤»\n    say $breakfast<spam>;     # OUTPUT: «4␤»\n    say $breakfast<sausage>;  # OUTPUT: «0␤»\n\nCreating Bag objects\n\nBags can be composed using the bag subroutine (or Bag.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the bag:\n\n    my $n = bag \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:c(2), :b(1), :a(0)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n    say $n.values.perl;      # OUTPUT: «(2, 1, 1).Seq␤»\n\nAlternatively, the .Bag coercer (or its functional form, Bag()) can be\ncalled on an existing object to coerce it to a Bag. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a bag with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the bag, and the (cumulative) values become the associated integer\nweights:\n\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).Bag;\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nFurthermore, you can get a Bag by using bag operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Bag on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (+) 4;  # OUTPUT: «bag(1, 2, 3, 4(2), 5)␤»\n\nOf course, you can also create a Bag with the .new method.\n\n    my $breakfast = Bag.new( <spam eggs spam spam bacon spam> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Bag, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Bag\n    my $breakfast = Bag[Str].new( <spam eggs spam spam bacon spam> );\n\n    # only allow whole numbers (Int) in the Bag\n    my $breakfast = Bag[Int].new( <spam eggs spam spam bacon spam> );\n    # Type check failed in binding; expected Int but got Str (\"spam\")\n\nFinally, you can create Bag masquerading as a hash by using the is trait:\n\n    my %b is Bag = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %b is Bag[Str] = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\n    # limit to whole numbers\n    my %b is Bag[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set and bag operators, which can take Bags (or any\nother collections) as input, and return result as Bool, Set or Bag values.\nFor example:\n\n    my ($a, $b) = bag(2, 2, 4), bag(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nSubroutines\n\n  sub bag\n\n    sub bag(*@args --> Bag)\n\nCreates a new Bag from @args.\n\nNote on reverse and ordering\n\nThis method is inherited from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nSee also\n\nSets, Bags, and Mixes","t":"Bag","n":"Bag","m":[{"n":"total","m":0,"k":"m","s":{"p":["*%_"],"r":"Int:D"}},{"n":"classify-list","s":{"p":["&test","\\list","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"classify-list","s":{"p":["%test","|c is raw"],"r":"Mu"},"k":"m","m":1},{"n":"classify-list","s":{"r":"Mu","p":["@test","|c is raw"]},"k":"m","m":1},{"n":"classify-list","m":1,"k":"m","s":{"r":"Mu","p":["&test","**@list","|c is raw"]}},{"s":{"p":["&test","\\list","*%_"],"r":"Mu"},"m":1,"k":"m","n":"categorize-list"},{"k":"m","m":1,"s":{"p":["%test","|c is raw"],"r":"Mu"},"n":"categorize-list"},{"s":{"r":"Mu","p":["@test","|c is raw"]},"m":1,"k":"m","n":"categorize-list"},{"k":"m","m":1,"s":{"r":"Mu","p":["&test","**@list","|c is raw"]},"n":"categorize-list"},{"k":"m","m":0,"s":{"p":["\\type","*%_"],"r":"Mu"},"n":"!HASHIFY"},{"n":"!create-from-iterator","s":{"p":["\\type","\\iterator","*%_"],"r":"Baggy:D"},"m":0,"k":"m"}],"k":"c","mro":["Baggy","QuantHash","Associative","Any"]},{"n":"HyperSeq","d":"TITLE\nclass HyperSeq\n\nSUBTITLE\nAn object for performing batches of work in parallel with ordered output\n\n    class HyperSeq does Iterable does Sequence { }\n\nAn HyperSeq is the intermediate object used when the operator hyper is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n","a":[{"n":"$.configuration","t":"HyperConfiguration","k":"v"},{"n":"$!work-stage-head","t":"Rakudo::Internals::HyperWorkStage","k":"v"},{"k":"v","t":"Mu","n":"$!list"}],"t":"HyperSeq","mro":["Sequence","PositionalBindFailover","Iterable","Any"],"k":"c","m":[{"n":"BUILD","k":"s","m":0,"s":{"p":[":configuration($!configuration)!",":work-stage-head($!work-stage-head)!","*%_"],"r":"Mu"}},{"d":"method iterator(HyperSeq:D: --> Iterator:D)\n\nReturns the underlying iterator.","n":"iterator","m":0,"k":"m","s":{"r":"Iterator","p":["*%_"]}},{"s":{"r":"Mu","p":["$matcher","*%options"]},"m":0,"k":"m","n":"grep","d":"method grep(HyperSeq:D: $matcher, *%options)\n\nApplies grep to the HyperSeq similarly to how it would do it on a Seq.\n\n    my @hyped = (^10000).map(*²).hyper;\n    @hyped.grep( * %% 3 ).say;\n    # OUTPUT: «(0 9 36 81 144…»\n\n\nWhen you use hyper on a Seq, this is the method that is actually called."},{"d":"method map(HyperSeq:D: $matcher, *%options)\n\nUses maps on the HyperSeq, generally created by application of hyper to a\npreexisting Seq.","n":"map","m":0,"k":"m","s":{"p":["$matcher","*%options"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"invert","d":"method invert(HyperSeq:D:)\n\nInverts the HyperSeq created from a Seq by .hyper."},{"d":"method hyper(HyperSeq:D:)\n\nReturns the object.","n":"hyper","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method race(HyperSeq:D:)\n\nCreates a RaceSeq object out of the current one.","n":"race"},{"n":"is-lazy","d":"method is-lazy(--> False )\n\nReturns False.","s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method sink(--> Nil)\n\nSinks the underlying data structure, producing any side effects.","n":"sink","k":"m","m":0,"s":{"r":"Nil","p":["*%_"]}},{"n":"configuration","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"t":"Sub","n":"&getc","k":"v"},{"n":"getc","k":"s","m":1,"s":{"r":"Mu","p":["IO::Handle:D $fh = { ... }"]}},{"mro":["Mixy","Baggy","QuantHash","Associative","Any"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"total"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"clone"},{"n":"!create-from-iterator","k":"m","m":0,"s":{"p":["\\type","\\iterator","*%_"],"r":"Baggy:D"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"!total-positive"},{"s":{"r":"Mu","p":["\\type","*%_"]},"k":"m","m":0,"n":"!HASHIFY"}],"n":"MixHash","t":"MixHash","a":[{"n":"$!elems","t":"Rakudo::Internals::IterationSet","k":"v"}],"d":"TITLE\nclass MixHash\n\nSUBTITLE\nMutable collection of distinct objects with Real weights\n\n    class MixHash does Mixy { }\n\nA MixHash is a mutable mix, meaning a collection of distinct elements in no\nparticular order that each have a real-number weight assigned to them. (For\nimmutable mixes, see Mix instead.)\n\nObjects/values of any type are allowed as mix elements. Within a MixHash,\nitems that would compare positively with the === operator are considered\nthe same element, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding numeric weight for keys that are\nelements of the mix, and 0 for keys that aren't. It can also be used to\nmodify weights; Setting a weight to 0 automatically removes that element\nfrom the mix, and setting a weight to a non-zero number adds that element\nif it didn't already exist:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\n    $recipe<butter> = 0;\n    $recipe<chocolate> = 0.30;\n    say $recipe.pairs;       # OUTPUT: «\"sugar\" => 0.12 \"flour\" => 0.275 \"chocolate\" => 0.3␤»\n\n\nCreating MixHash objects\n\nMixHashes can be composed using MixHash.new. Any positional parameters,\nregardless of their type, become elements of the mix - with a weight of 1\nfor each time the parameter occurred:\n\n    my $n = MixHash.new: \"a\", \"a\", \"b\" => 0, \"c\" => 3.14;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Pair) (Pair))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 (c => 3.14) => 1 (b => 0) => 1)␤»\n\nAlternatively, the .MixHash coercer (or its functional form, MixHash()) can\nbe called on an existing object to coerce it to a MixHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a mix with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the mix, and the (cumulative) values become the\nassociated numeric weights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).MixHash;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a MixHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = MixHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %mh is MixHash[Str] = <a b b c c c>;\n    say %mh<b>;  # 2\n    say %mh<d>;  # 0\n\n    # only allow whole numbers\n    my %mh is MixHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\n    my ($a, $b) = MixHash(2 => 2, 4), MixHash(2 => 1.5, 3 => 2, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a (+) $b;   # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a ⊎ $b;  # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nMixHash inherits reverse from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a MixHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = MixHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «MixHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\n","b":"A"},{"b":"C","k":"ro","m":[{"n":"name","d":"method name(--> Str)\n\nAbstract method that would return the primary name of the encoding.","s":{"r":"Str","p":["*%_"]},"m":0,"k":"m"},{"n":"alternative-names","d":"method alternative-names()\n\nAbstract methods that should get a list of alternative names for the\nencoding.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method encoder(*%options --> Encoding::Encoder)\n\nGets a character encoder instance for this encoding, configured with the\nprovided options. Options vary by encoding. The built-in encodings all\nsupport both replacement (either a Str replacement sequence or True to use\na default replacement sequence for unencodable characters) and translate-nl\n(when set to True, turns \\n into \\r\\n if the current platform is Windows).","n":"encoder","k":"m","m":0,"s":{"r":"Encoding::Encoder","p":["*%options"]}},{"n":"decoder","d":"method decoder(*%options --> Encoding::Decoder)\n\nShould get a character decoder instance for this encoding, configured with\nthe provided options. Options vary by encoding. The built-in encodings all\nsupport translate-nl, which if True will translate \\r\\n into \\n while\ndecoding.","s":{"r":"Encoding::Decoder","p":["*%options"]},"m":0,"k":"m"}],"mro":[],"d":"TITLE\nrole Encoding\n\nSUBTITLE\nSupport for character encodings.\n\n    role Encoding { ... }\n\nThe Encoding role is implemented by classes that provide a character\nencoding, such as ASCII or UTF-8. Besides being used by the built-in\ncharacter encodings, it may also be implemented by users to provide new\nencodings. Instances of objects doing this role are typically obtained\nusing Encoding::Registry. For a list of supported encodings, see\nIO::Handle.\n\nAll methods provided by this role are stubs; they should be implemented by\nconsumers of the role.\n\n","t":"Encoding","n":"Encoding"},{"b":"A","k":"c","m":[{"n":"new","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["\\name","\\alternatives","*%_"],"r":"Mu"},"k":"m","m":0,"n":"SET-SELF"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"alternative-names"},{"m":0,"k":"m","s":{"p":[":$replacement",":$translate-nl",":$strict","*%_"],"r":"Encoding::Decoder"},"n":"decoder"},{"k":"m","m":0,"s":{"p":[":$replacement",":$translate-nl",":$strict","*%_"],"r":"Encoding::Encoder"},"n":"encoder"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"name"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"!buf-type"},{"s":{"r":"Mu","p":["$replacement","*%_"]},"k":"m","m":0,"n":"!rep-char"}],"mro":["Encoding","Any"],"a":[{"n":"$.name","t":"Str","k":"v"},{"k":"v","t":"Mu","n":"$!alternative-names"}],"t":"Encoding::Builtin","n":"Encoding::Builtin"},{"n":"Encoding::Registry","t":"Encoding::Registry","d":"TITLE\nclass Encoding::Registry\n\nSUBTITLE\nManagement of available encodings\n\n    class Encoding::Registry {}\n\nEncoding::Registry is initialized with a list of encoding that is available\nfor any Raku application, namely:\n\n  * utf8\n\n  * utf8-c8\n\n  * utf16\n\n  * utf16le\n\n  * utf16be\n\n  * utf32, utf-32\n\n  * ascii\n\n  * iso-8859-1, iso_8859-1:1987, iso_8859-1, iso-ir-100, latin1, latin-1,\n  csisolatin1, l1, ibm819, cp819\n\n  * windows-1251\n\n  * windows-1252\n\n  * windows-932\n\n","mro":["Any"],"k":"c","m":[{"n":"register","m":0,"k":"m","s":{"p":["Encoding $enc","*%_"],"r":"Nil"}},{"s":{"r":"Mu","p":["$name","*%_"]},"m":0,"k":"m","n":"find","d":"method find(Str() $name)\n\nFinds an encoding by its name. Returns an Encoding::Encoder or\nEncoding::Decoder, depending on what had been registered."}],"b":"A"},{"t":"Encoding::Encoder","n":"Encoding::Encoder","m":[{"m":0,"k":"m","s":{"r":"Blob:D","p":["Str:D $","*%_"]},"n":"encode-chars"}],"k":"ro","mro":[],"b":"C"},{"m":[{"n":"new","s":{"r":"Mu","p":["Str $encoding","Blob:U $type",":$replacement",":$strict","*%_"]},"k":"m","m":0},{"s":{"r":"Blob:D","p":["str $str","*%_"]},"k":"m","m":0,"n":"encode-chars"},{"n":"!setup","s":{"r":"Mu","p":["$encoding","$type",":$replacement",":$strict","*%_"]},"m":0,"k":"m"}],"k":"c","mro":["Encoding::Encoder","Any"],"a":[{"n":"$!encoding","t":"str","k":"v"},{"t":"Blob","n":"$!type","k":"v"},{"k":"v","n":"$!replacement","t":"Mu"},{"k":"v","t":"int","n":"$!config"}],"t":"Encoding::Encoder::Builtin","n":"Encoding::Encoder::Builtin","b":"A"},{"b":"A","k":"c","m":[{"n":"new","s":{"p":["Encoding::Encoder $delegate","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Blob:D","p":["Str:D $str","*%_"]},"k":"m","m":0,"n":"encode-chars"},{"s":{"p":["Encoding::Encoder $delegate","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!setup"}],"mro":["Encoding::Encoder","Any"],"t":"Encoding::Encoder::TranslateNewlineWrapper","a":[{"t":"Encoding::Encoder","n":"$!delegate","k":"v"}],"n":"Encoding::Encoder::TranslateNewlineWrapper"},{"b":"C","mro":[],"k":"ro","m":[{"s":{"r":"Nil","p":["Blob:D $bytes","*%_"]},"m":0,"k":"m","n":"add-bytes"},{"n":"consume-available-chars","s":{"p":["*%_"],"r":"Str:D"},"m":0,"k":"m"},{"n":"consume-all-chars","s":{"r":"Str:D","p":["*%_"]},"k":"m","m":0},{"s":{"p":["int $chars","Bool:D :$eof = Bool::False","*%_"],"r":"Str"},"k":"m","m":0,"n":"consume-exactly-chars"},{"s":{"r":"Nil","p":["@seps","*%_"]},"k":"m","m":0,"n":"set-line-separators"},{"n":"consume-line-chars","s":{"r":"Str","p":["Bool:D :$chomp = Bool::False","Bool:D :$eof = Bool::False","*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Bool","p":["*%_"]},"n":"is-empty"},{"m":0,"k":"m","s":{"r":"Int:D","p":["*%_"]},"n":"bytes-available"},{"n":"consume-exactly-bytes","s":{"p":["int $bytes","*%_"],"r":"Blob"},"m":0,"k":"m"}],"n":"Encoding::Decoder","t":"Encoding::Decoder"},{"b":"A","t":"Encoding::Decoder::Builtin","n":"Encoding::Decoder::Builtin","m":[{"n":"new","m":0,"k":"m","s":{"p":["str $encoding",":$translate-nl",":$replacement",":$strict","*%_"],"r":"Mu"}},{"s":{"p":["Blob:D $bytes","*%_"],"r":"Nil"},"k":"m","m":0,"n":"add-bytes"},{"n":"consume-available-chars","k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]}},{"n":"consume-all-chars","k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]}},{"n":"consume-exactly-chars","s":{"r":"Str","p":["int $chars","Bool:D :$eof = Bool::False","*%_"]},"m":0,"k":"m"},{"s":{"r":"Nil","p":["@seps","*%_"]},"k":"m","m":0,"n":"set-line-separators"},{"n":"consume-line-chars","k":"m","m":0,"s":{"p":["Bool:D :$chomp = Bool::False","Bool:D :$eof = Bool::False","*%_"],"r":"Str"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-empty"},{"n":"bytes-available","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"consume-exactly-bytes","s":{"r":"Blob","p":["int $bytes","*%_"]},"m":0,"k":"m"}],"k":"c","mro":["Encoding::Decoder","Any"]},{"t":"Signal","n":"SIGEMT","k":"e"},{"t":"Sub","n":"&infix:<=~>","k":"v"},{"s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":0,"n":"infix:<=~>"},{"k":"v","n":"&cosh","t":"Sub+{is-pure}"},{"m":1,"k":"s","s":{"p":["Numeric \\x"],"r":"Mu"},"n":"cosh"},{"s":{"r":"Mu","p":["Cool \\x"]},"m":1,"k":"s","n":"cosh"},{"k":"s","m":1,"s":{"p":["num $x"],"r":"num"},"n":"cosh"},{"n":"&prefix:<++⚛>","t":"Sub","k":"v"},{"n":"prefix:<++⚛>","m":1,"k":"s","s":{"r":"atomicint","p":["atomicint $target is rw"]}},{"b":"A","m":[{"n":"BUILD","s":{"r":"Nil","p":[":on-close(&!on-close)","*%_"]},"m":0,"k":"s"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Bool"},"d":"method close(Tap:D:)\n\nCloses the tap.","n":"close"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["Any"],"t":"Tap","a":[{"k":"v","n":"&!on-close","t":"Callable"}],"d":"TITLE\nclass Tap\n\nSUBTITLE\nSubscription to a Supply\n\n    class Tap {}\n\nA Tap is a subscription to a Supply.\n\n    my $s = Supplier.new;\n    my $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n        -> $v { say \"the value is $v\" },\n        done    => { say \"Supply is done\" },\n        quit    => -> $ex { say \"Supply finished with error $ex\" },\n    );\n\n    # later\n    $tap.close;\n\n","n":"Tap"},{"k":"v","t":"Sub+{is-pure}","n":"&chars"},{"m":1,"k":"s","s":{"p":["Cool $x"],"r":"Mu"},"n":"chars"},{"n":"chars","m":1,"k":"s","s":{"p":["Str:D $x"],"r":"Mu"}},{"s":{"p":["str $x"],"r":"int"},"m":1,"k":"s","n":"chars"},{"b":"A","k":"c","m":[{"n":"total","m":0,"k":"m","s":{"p":["*%_"],"r":"Real:D"}},{"n":"classify-list","s":{"p":["&test","\\list","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"classify-list","k":"m","m":1,"s":{"p":["%test","|c is raw"],"r":"Mu"}},{"n":"classify-list","k":"m","m":1,"s":{"r":"Mu","p":["@test","|c is raw"]}},{"m":1,"k":"m","s":{"p":["&test","**@list","|c is raw"],"r":"Mu"},"n":"classify-list"},{"n":"categorize-list","m":1,"k":"m","s":{"p":["&test","\\list","*%_"],"r":"Mu"}},{"n":"categorize-list","s":{"p":["%test","|c is raw"],"r":"Mu"},"m":1,"k":"m"},{"n":"categorize-list","s":{"r":"Mu","p":["@test","|c is raw"]},"m":1,"k":"m"},{"n":"categorize-list","s":{"p":["&test","**@list","|c is raw"],"r":"Mu"},"k":"m","m":1},{"s":{"r":"Mu","p":["\\type","*%_"]},"k":"m","m":0,"n":"!HASHIFY"},{"n":"!create-from-iterator","s":{"p":["\\type","\\iterator","*%_"],"r":"Baggy:D"},"m":0,"k":"m"},{"n":"!total-positive","s":{"p":["*%_"],"r":"Real:D"},"m":0,"k":"m"}],"mro":["Mixy","Baggy","QuantHash","Associative","Any"],"t":"Mix","a":[{"t":"ValueObjAt","n":"$!WHICH","k":"v"},{"n":"$!total","t":"Real","k":"v"},{"k":"v","n":"$!total-positive","t":"Real"},{"n":"$!elems","t":"Rakudo::Internals::IterationSet","k":"v"}],"d":"TITLE\nclass Mix\n\nSUBTITLE\nImmutable collection of distinct objects with Real weights\n\n    class Mix does Mixy { }\n\nA Mix is an immutable collection of distinct elements in no particular\norder that each have a real-number weight assigned to them. (For mutable\nmixes, see MixHash instead.)\n\nMixes are often used for performing weighted random selections - see\n.roll.\n\nObjects/values of any type are allowed as mix elements. Within a Mix, items\nthat would compare positively with the === operator are considered the same\nelement, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixes can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the corresponding numeric weight for keys that are elements\nof the mix, and 0 for keys that aren't:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\nCreating Mix objects\n\nMixes can be composed using the mix subroutine (or Mix.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the mix - with a weight of 1 for each time the parameter\noccurred:\n\n    my $n = mix \"a\", \"a\", \"b\" => 0, 3.14, π, π; # The Pair is a single element\n    say $n.keys.map: *.^name; # OUTPUT: «(Rat Pair Num Str)␤»\n    say $n.pairs;\n    # OUTPUT: «(3.14 => 1 (b => 0) => 1 3.141592653589793 => 2 a => 2)␤»\n\nAlternatively, the .Mix coercer (or its functional form, Mix()) can be\ncalled on an existing object to coerce it to a Mix. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a mix with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the mix, and the (cumulative) values become the associated numeric\nweights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).Mix;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nElements with a 0 value, as b above, are simply eliminated from the Mix.\n\nAlternatively, since Mixes are Associative, we can use the % sigil to\ndeclare them; in that case, we can employ is to declare their type:\n\n    my %n is Mix = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14);\n    say %n.^name; # OUTPUT: «Mix␤»\n    say %n;       # OUTPUT: «Mix(a(2), c(3.14))␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a Mix. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = Mix[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %m is Mix[Str] = <a b b c c c>;\n    say %m<b>;  # 2\n    say %m<d>;  # 0\n\n    # only allow whole numbers\n    my %m is Mix[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nMixes can use all kind of set operators returning either Bool or other\nMixes:\n\n    my $this-mix = (sugar => ⅓, spice => ¼, all-things-nice => ¾);\n    my $that-mix = ( sugar => 1, spice => 2);\n\n    say $that-mix (<) $this-mix;     # OUTPUT: «True␤»\n    say $that-mix (^) $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix (+) $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nWith their equivalent Unicode operators:\n\n    say $that-mix ⊂ $this-mix;     # OUTPUT: «True␤»\n    say $that-mix ⊖ $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix ⊎ $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\n  sub mix\n\n    sub mix(*@args --> Mix)\n\nCreates a new Mix from @args.\n\n","n":"Mix"},{"k":"e","n":"SOCK_DGRAM","t":"SocketType"},{"t":"Sub","n":"&succeed","k":"v"},{"s":{"p":[],"r":"Nil"},"m":1,"k":"s","n":"succeed"},{"n":"succeed","k":"s","m":1,"s":{"p":["\\x"],"r":"Nil"}},{"k":"s","m":1,"s":{"p":["|"],"r":"Nil"},"n":"succeed"},{"k":"v","t":"Sub","n":"&repeated"},{"s":{"p":["+\\values is raw","|c is raw"],"r":"Mu"},"m":1,"k":"s","n":"repeated"},{"b":"C","a":[{"t":"List","n":"@!list","k":"v"},{"n":"%!hash","t":"Hash","k":"v"}],"t":"Match","n":"Cursor","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"ast"},{"n":"made","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"STR","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"MATCH","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"CURSOR_NEXT","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"CURSOR_OVERLAP"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"CURSOR_MORE"},{"n":"INTERPOLATE","m":1,"k":"m","s":{"p":["Callable:D \\var","$","$","$","$","$","*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"p":["Iterable:D \\var","int \\im","int \\monkey","int \\s","$","\\context","*%_"],"r":"Mu"},"n":"INTERPOLATE"},{"s":{"r":"Mu","p":["Associative:D \\var","int \\im","$","$","$","\\context","*%_"]},"m":1,"k":"m","n":"INTERPOLATE"},{"n":"INTERPOLATE","m":1,"k":"m","s":{"p":["Regex:D \\var","int \\im","int \\monkey","$","$","$","*%_"],"r":"Mu"}},{"n":"INTERPOLATE","k":"m","m":1,"s":{"p":["Mu:D \\var","int \\im","int \\monkey","$","$","\\context","*%_"],"r":"Mu"}},{"n":"INTERPOLATE","s":{"p":["Mu:U \\var","$","$","$","$","$","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"INTERPOLATE_ASSERTION","k":"m","m":1,"s":{"p":["Associative:D $","$","$","$","$","$","*%_"],"r":"Mu"}},{"n":"INTERPOLATE_ASSERTION","s":{"p":["Iterable:D \\var","int \\im","int \\monkey","int \\s","$","\\context","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"INTERPOLATE_ASSERTION","s":{"r":"Mu","p":["Mu:D \\var","int \\im","int \\monkey","$","$","\\context","*%_"]},"k":"m","m":1},{"n":"CALL_SUBRULE","m":0,"k":"m","s":{"r":"Mu","p":["$rule","|c is raw"]}},{"n":"DYNQUANT_LIMITS","s":{"p":["$mm","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["$grammar","$name","|"],"r":"Mu"},"k":"m","m":0,"n":"OTHERGRAMMAR"},{"n":"INDMETHOD","s":{"p":["$name","|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["$rule","|c is raw"],"r":"Mu"},"n":"INDRULE"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"RECURSE"},{"s":{"r":"Mu","p":[":$orig = \"\"",":$from = 0",":to(:$pos)",":ast(:$made)",":$shared",":$braid",":$list",":$hash","*%_"]},"k":"s","m":0,"n":"BUILD"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"clone"},{"n":"Bool","k":"m","m":1,"s":{"p":["*%_"],"r":"Bool"}},{"n":"Bool","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"n":"prematch","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"postmatch"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"caps"},{"n":"chunks","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"!MATCH-EMPTY"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"!MATCH"},{"n":"!MATCH-PASS","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"!MATCH-CAPTURES","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}}],"mro":["NQPMatchRole","Capture","Cool"]},{"k":"v","t":"Sub","n":"&nextsame"},{"n":"nextsame","k":"s","m":0,"s":{"r":"Mu","p":[]}},{"k":"c","m":[{"s":{"p":["|"],"r":"Mu"},"k":"m","m":0,"n":"new"},{"n":"NFD","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}}],"mro":["Stringy","Positional[uint32]","Uni"],"d":"TITLE\nclass NFD\n\nSUBTITLE\nCodepoint string in Normal Form D (decomposed)\n\n    class NFD is Uni {}\n\nA Codepoint string in the \"D\" Unicode Normalization Form","t":"NFD","n":"NFD","b":"A"},{"n":"&infix:<⊅>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Bool:D","p":["\\a","\\b"]},"m":1,"k":"s","n":"infix:<⊅>"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊎>","k":"v"},{"n":"infix:<(+)>","s":{"r":"Mu","p":[]},"k":"s","m":1},{"n":"infix:<(+)>","k":"s","m":1,"s":{"r":"Mu","p":["Bag:D \\a"]}},{"s":{"p":["Mix:D \\a"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(+)>"},{"s":{"r":"Mu","p":["MixHash:D \\a"]},"k":"s","m":1,"n":"infix:<(+)>"},{"s":{"p":["\\a"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(+)>"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","QuantHash:D \\b"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Map:D \\b"]},"n":"infix:<(+)>"},{"s":{"r":"Mu","p":["Mixy:D \\a","QuantHash:D \\b"]},"m":1,"k":"s","n":"infix:<(+)>"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","QuantHash:D \\b"]}},{"n":"infix:<(+)>","s":{"p":["Map:D \\a","Map:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(+)>","s":{"p":["Iterable:D \\a","Iterable:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(+)>","k":"s","m":1,"s":{"p":["$","Failure:D \\b"],"r":"Mu"}},{"n":"infix:<(+)>","s":{"p":["Failure:D \\a","$"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(+)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["**@p"]},"n":"infix:<(+)>"},{"k":"v","n":"&trait_mod:<does>","t":"Sub"},{"n":"trait_mod:<does>","m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $doee","Mu:U $role"]}},{"n":"trait_mod:<does>","k":"s","m":1,"s":{"p":["Attribute:D $a","Mu:U $role"],"r":"Mu"}},{"n":"trait_mod:<does>","s":{"p":["Variable:D $v","Mu:U $role"],"r":"Mu"},"k":"s","m":1},{"k":"v","n":"&acotan","t":"Sub+{is-pure}"},{"m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]},"n":"acotan"},{"m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"},"n":"acotan"},{"n":"acotan","s":{"p":["num $x"],"r":"num"},"m":1,"k":"s"},{"mro":[],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"self","d":"method self(--> Mu)\n\nReturns the object it is called on."},{"s":{"r":"Nil","p":["*%_"]},"m":0,"k":"m","n":"sink"},{"n":"ACCEPTS","d":"multi method ACCEPTS(Mu:U: $other)\n\nACCEPTS is the method that smartmatching with the infix ~~ operator and\ngiven/when invokes on the right-hand side (the matcher).\n\nThe Mu:U multi performs a type check. Returns True if $other conforms to\nthe invocant (which is always a type object or failure).\n\n    say 42 ~~ Mu;           # OUTPUT: «True␤»\n    say 42 ~~ Int;          # OUTPUT: «True␤»\n    say 42 ~~ Str;          # OUTPUT: «False␤»\n\nNote that there is no multi for defined invocants; this is to allow\nautothreading of junctions, which happens as a fallback mechanism when no\ndirect candidate is available to dispatch to.","s":{"r":"Mu","p":["\\topic","*%_"]},"m":1,"k":"m"},{"d":"multi method ACCEPTS(Mu:U: $other)\n\nACCEPTS is the method that smartmatching with the infix ~~ operator and\ngiven/when invokes on the right-hand side (the matcher).\n\nThe Mu:U multi performs a type check. Returns True if $other conforms to\nthe invocant (which is always a type object or failure).\n\n    say 42 ~~ Mu;           # OUTPUT: «True␤»\n    say 42 ~~ Int;          # OUTPUT: «True␤»\n    say 42 ~~ Str;          # OUTPUT: «False␤»\n\nNote that there is no multi for defined invocants; this is to allow\nautothreading of junctions, which happens as a fallback mechanism when no\ndirect candidate is available to dispatch to.","n":"ACCEPTS","m":1,"k":"m","s":{"r":"Mu","p":["Mu:U \\topic","*%_"]}},{"n":"WHERE","d":"method WHERE(--> Int)\n\nReturns an Int representing the memory address of the object.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"ValueObjAt:D"},"k":"m","m":1,"n":"WHICH","d":"multi method WHICH(--> ObjAt:D)\n\nReturns an object of type ObjAt which uniquely identifies the object. Value\ntypes override this method which makes sure that two equivalent objects\nreturn the same return value from WHICH.\n\n    say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»"},{"s":{"r":"ObjAt:D","p":["*%_"]},"k":"m","m":1,"n":"WHICH","d":"multi method WHICH(--> ObjAt:D)\n\nReturns an object of type ObjAt which uniquely identifies the object. Value\ntypes override this method which makes sure that two equivalent objects\nreturn the same return value from WHICH.\n\n    say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»"},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"iterator","d":"Defined as:\n\n    method iterator(--> Iterator)\n\nCoerces the invocant to a list by applying its .list method and uses\niterator on it.\n\n    my $it = Mu.iterator;\n    say $it.pull-one; # OUTPUT: «(Mu)␤»\n    say $it.pull-one; # OUTPUT: «IterationEnd␤»"},{"n":"emit","d":"method emit()\n\nEmits the invocant into the enclosing supply or react block.\n\n    react { whenever supply { .emit for \"foo\", 42, .5 } {\n        say \"received {.^name} ($_)\";\n    }}\n\n    # OUTPUT:\n    # received Str (foo)\n    # received Int (42)\n    # received Rat (0.5)","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"take","d":"sub take(\\item)\n\nTakes the given item and passes it to the enclosing gather block.\n\n    #| randomly select numbers for lotto\n    my $num-selected-numbers = 6;\n    my $max-lotto-numbers = 49;\n    gather for ^$num-selected-numbers {\n        take (1 .. $max-lotto-numbers).pick(1);\n    }.say;    # six random values"},{"d":"Same as method return except that return-rw returns a writable container to\nthe invocant (see more details here: return-rw).","n":"return-rw","m":0,"k":"m","s":{"p":["|"],"r":"Mu"}},{"n":"return","d":"method return()\n\nThe method return will stop execution of a subroutine or method, run all\nrelevant phasers and provide invocant as a return value to the caller. If a\nreturn type constraint is provided it will be checked unless the return\nvalue is Nil. A control exception is raised and can be caught with\nCONTROL.\n\n    sub f { (1|2|3).return };\n    say f(); # OUTPUT: «any(1, 2, 3)␤»","s":{"r":"Mu","p":["|"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"WHY","d":"multi method WHY(--> Pod::Block::Declarator)\n\nReturns the attached Pod::Block::Declarator.\n\nFor instance:\n\n    #| Initiate a specified spell normally\n    sub cast(Spell $s) {\n      do-raw-magic($s);\n    }\n    #= (do not use for class 7 spells)\n    say &cast.WHY;\n    # OUTPUT: «Initiate a specified spell normally␤(do not use for class 7 spells)␤»\n\n\nSee Pod declarator blocks for details about attaching Pod to variables,\nclasses, functions, methods, etc.\n\n  trait is export\n\n    multi sub trait_mod:<is>(Mu:U \\type, :$export!)\n\nMarks a type as being exported, that is, available to external users.\n\n    my class SomeClass is export { }\n\nA user of a module or class automatically gets all the symbols imported\nthat are marked as is export.\n\nSee Exporting and Selective Importing Modules for more details."},{"s":{"r":"Mu","p":["$why","*%_"]},"m":0,"k":"m","n":"set_why"},{"d":"multi sub    Bool(Mu --> Bool:D)\n    multi method Bool(   --> Bool:D)\n\nReturns False on the type object, and True otherwise.\n\nMany built-in types override this to be False for empty collections, the\nempty string or numerical zeros\n\n    say Mu.Bool;                    # OUTPUT: «False␤»\n    say Mu.new.Bool;                # OUTPUT: «True␤»\n    say [1, 2, 3].Bool;             # OUTPUT: «True␤»\n    say [].Bool;                    # OUTPUT: «False␤»\n    say %( hash => 'full' ).Bool;   # OUTPUT: «True␤»\n    say {}.Bool;                    # OUTPUT: «False␤»\n    say \"\".Bool;                    # OUTPUT: «False␤»\n    say 0.Bool;                     # OUTPUT: «False␤»\n    say 1.Bool;                     # OUTPUT: «True␤»\n    say \"0\".Bool;                   # OUTPUT: «True␤»","n":"Bool","k":"m","m":1,"s":{"r":"Bool","p":["*%_"]}},{"n":"Bool","d":"multi sub    Bool(Mu --> Bool:D)\n    multi method Bool(   --> Bool:D)\n\nReturns False on the type object, and True otherwise.\n\nMany built-in types override this to be False for empty collections, the\nempty string or numerical zeros\n\n    say Mu.Bool;                    # OUTPUT: «False␤»\n    say Mu.new.Bool;                # OUTPUT: «True␤»\n    say [1, 2, 3].Bool;             # OUTPUT: «True␤»\n    say [].Bool;                    # OUTPUT: «False␤»\n    say %( hash => 'full' ).Bool;   # OUTPUT: «True␤»\n    say {}.Bool;                    # OUTPUT: «False␤»\n    say \"\".Bool;                    # OUTPUT: «False␤»\n    say 0.Bool;                     # OUTPUT: «False␤»\n    say 1.Bool;                     # OUTPUT: «True␤»\n    say \"0\".Bool;                   # OUTPUT: «True␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method so()\n\nEvaluates the item in boolean context (and thus, for instance, collapses\nJunctions), and returns the result. It is the opposite of not, and\nequivalent to the ? operator.\n\nOne can use this method similarly to the English sentence: \"If that is so,\nthen do this thing\". For instance,\n\n    my @args = <-a -e -b -v>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if $verbose-selected.so {\n        say \"Verbose option detected in arguments\";\n    } # OUTPUT: «Verbose option detected in arguments␤»\n\nThe $verbose-selected variable in this case contains a Junction, whose\nvalue is any(any(False, False), any(False, False), any(False, False),\nany(True, False)). That is actually a truish value; thus, negating it will\nyield False. The negation of that result will be True. so is performing all\nthose operations under the hood.","n":"so"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"not","d":"method not()\n\nEvaluates the item in boolean context (leading to final evaluation of\nJunctions, for instance), and negates the result. It is the opposite of so\nand its behavior is equivalent to the ! operator.\n\n    my @args = <-a -e -b>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if $verbose-selected.not {\n        say \"Verbose option not present in arguments\";\n    } # OUTPUT: «Verbose option not present in arguments␤»\n\nSince there is also a prefix version of not, this example reads better as:\n\n    my @args = <-a -e -b>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if not $verbose-selected {\n        say \"Verbose option not present in arguments\";\n    } # OUTPUT: «Verbose option not present in arguments␤»"},{"d":"Declared as\n\n    multi sub defined(Mu --> Bool:D)\n\ninvokes the .defined method on the object and returns its result.","n":"defined","m":1,"k":"m","s":{"r":"Bool","p":["*%_"]}},{"n":"defined","d":"Declared as\n\n    multi sub defined(Mu --> Bool:D)\n\ninvokes the .defined method on the object and returns its result.","s":{"p":["*%_"],"r":"Bool"},"m":1,"k":"m"},{"s":{"p":["*%attrinit"],"r":"Mu"},"k":"m","m":1,"n":"new","d":"multi method new(*%attrinit)\n    multi method new($, *@)\n\nDefault method for constructing (create + initialize) new objects of a\nclass. This method expects only named arguments which are then used to\ninitialize attributes with accessors of the same name.\n\nClasses may provide their own new method to override this default.\n\nnew triggers an object construction mechanism that calls submethods named\nBUILD in each class of an inheritance hierarchy, if they exist. See the\ndocumentation on object construction for more information."},{"m":1,"k":"m","s":{"r":"Mu","p":["$","*@","*%_"]},"d":"multi method new(*%attrinit)\n    multi method new($, *@)\n\nDefault method for constructing (create + initialize) new objects of a\nclass. This method expects only named arguments which are then used to\ninitialize attributes with accessors of the same name.\n\nClasses may provide their own new method to override this default.\n\nnew triggers an object construction mechanism that calls submethods named\nBUILD in each class of an inheritance hierarchy, if they exist. See the\ndocumentation on object construction for more information.","n":"new"},{"k":"m","m":1,"s":{"r":"Bool","p":["*%_"]},"n":"is-lazy"},{"n":"CREATE","d":"method CREATE(--> Mu:D)\n\nAllocates a new object of the same type as the invocant, without\ninitializing any attributes.\n\n    say Mu.CREATE.defined;  # OUTPUT: «True␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%attrinit"],"r":"Mu"},"k":"m","m":0,"n":"bless","d":"method bless(*%attrinit --> Mu:D)\n\nLow-level object construction method, usually called from within new,\nimplicitly from the default constructor, or explicitly if you create your\nown constructor. bless creates a new object of the same type as the\ninvocant, using the named arguments to initialize attributes and returns\nthe created object.\n\nIt is usually invoked within custom new method implementations:\n\n    class Point {\n        has $.x;\n        has $.y;\n        multi method new($x, $y) {\n            self.bless(:$x, :$y);\n        }\n    }\n    my $p = Point.new(-1, 1);\n\n\nIn this case we are declaring new as a multi method so that we can still\nuse the default constructor like this: Point.new( x => 3, y => 8 ). In this\ncase we are declaring this new method simply to avoid the extra syntax of\nusing pairs when creating the object. self.bless returns the object, which\nis in turn returned by new.\n\nHowever, in general, implementing a customized new method might not be the\nbest way of initializing a class, even more so if the default constructor\nis disabled, since it can make it harder to correctly initialize the class\nfrom a subclass. For instance, in the above example, the new implementation\ntakes two positional arguments that must be passed from the subclass to the\nsuperclass in the exact order. That is not a real problem if it's\ndocumented, but take into account bless will eventually be calling BUILD in\nthe class that is being instantiated. This might result in some unwanted\nproblems, like having to create a BUILD submethod to serve it correctly:\n\n    class Point {\n        has Int $.x;\n        has Int $.y;\n        multi method new($x, $y) {\n            self.bless(:$x, :$y);\n        }\n    }\n\n    class Point-with-ID is Point {\n        has Int $.ID  is rw = 0;\n\n        submethod BUILD( *%args ) {\n            say %args;                # OUTPUT: «{x => 1, y => 2}␤»\n            for self.^attributes -> $attr {\n                if $attr.Str ~~ /ID/ {\n                    $attr.set_value( self, \"*\" ~ %args<x> ~ \"-\" ~ %args<y> ) ;\n                }\n            }\n        }\n    }\n\n    my $p = Point-with-ID.new(1,2);\n    say $p.perl;\n    # OUTPUT: «Point-with-ID.new(ID => \"*1-2\", x => 1, y => 2)␤»\n\n\nIn this code, bless, called within Point.new, is eventually calling BUILD\nwith the same parameters. We have to create a convoluted way of using the\n$.ID attribute using the metaobject protocol so that we can instantiate it\nand thus serve that new constructor, which can be called on Point-with-ID\nsince it is a subclass.\n\nWe might have to use something similar if we want to instantiate\nsuperclasses. bless will help us with that, since it is calling across all\nthe hierarchy:\n\n    class Str-with-ID is Str {\n        my $.counter = 0;\n        has Int $.ID  is rw = 0;\n\n        multi method new( $str ) {\n            self.bless( value => $str, ID => $.counter++ );\n        }\n\n        submethod BUILD( *%args ) {\n            for self.^attributes -> $attr {\n                if $attr.Str ~~ /ID/ {\n                    $attr.set_value( self, %args<ID> ) ;\n                }\n            }\n        }\n    }\n\n    say Str-with-ID.new(\"1.1,2e2\").ID;                  # OUTPUT: «0␤»\n    my $enriched-str = Str-with-ID.new(\"3,4\");\n    say \"$enriched-str, {$enriched-str.^name}, {$enriched-str.ID}\";\n    # OUTPUT: «3,4, Str-with-ID, 1␤»\n\n\nWe are enriching Str with an auto-incrementing ID. We create a new since we\nwant to initialize it with a string and, besides, we need to instantiate\nthe superclass. We do so using bless from within new. bless is going to\ncall Str.BUILD. It will *capture* the value it's looking for, the pair\nvalue = $str> and initialize itself. But we have to initialize also the\nproperties of the subclass, which is why within BUILD we use the previously\nexplained method to initialize $.ID with the value that is in the %args\nvariable. As shown in the output, the objects will be correctly initialized\nwith its ID, and will correctly behave as Str, converting themselves in\njust the string in the say statement, and including the ID property as\nrequired.\n\nFor more details see the documentation on object construction."},{"k":"m","m":0,"s":{"p":["@autovivs","%attrinit","*%_"],"r":"Mu"},"n":"BUILDALL"},{"n":"BUILD_LEAST_DERIVED","m":0,"k":"m","s":{"p":["%attrinit","*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"n":"Numeric"},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"n":"Real"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"Str","d":"multi method Str(--> Str)\n\nReturns a string representation of the invocant, intended to be machine\nreadable. Method Str warns on type objects, and produces the empty string.\n\n    say Mu.Str;   # Use of uninitialized value of type Mu in string context.\n    my @foo = [2,3,1];\n    say @foo.Str  # OUTPUT: «2 3 1␤»"},{"d":"multi method Str(--> Str)\n\nReturns a string representation of the invocant, intended to be machine\nreadable. Method Str warns on type objects, and produces the empty string.\n\n    say Mu.Str;   # Use of uninitialized value of type Mu in string context.\n    my @foo = [2,3,1];\n    say @foo.Str  # OUTPUT: «2 3 1␤»","n":"Str","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"Stringy"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"Stringy"},{"n":"item","d":"method item(Mu \\item:) is raw\n\nForces the invocant to be evaluated in item context and returns the value\nof it.\n\n    say [1,2,3].item.perl;          # OUTPUT: «$[1, 2, 3]␤»\n    say %( apple => 10 ).item.perl; # OUTPUT: «${:apple(10)}␤»\n    say \"abc\".item.perl;            # OUTPUT: «\"abc\"␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"say","d":"multi method say()\n\nWill say to standard output.\n\n    say 42;                 # OUTPUT: «42␤»\n\nWhat say actually does is, thus, deferred to the actual subclass. In most\ncases it calls .gist on the object, returning a compact string\nrepresentation.\n\nIn non-sink context, say will always return True.\n\n    say (1,[1,2],\"foo\",Mu).map: so *.say ;\n    # OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»\n\nHowever, this behavior is just conventional and you shouldn't trust it for\nyour code. It's useful, however, to explain certain behaviors.\n\nsay is first printing out in *.say, but the outermost say is printing the\nTrue values returned by the so operation."},{"d":"multi method print(--> Bool:D)\n\nPrints value to $*OUT after stringification using .Str method without\nadding a newline at end.\n\n    \"abc\\n\".print;          # RESULT: «abc␤»","n":"print","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"multi method put(--> Bool:D)\n\nPrints value to $*OUT, adding a newline at end, and if necessary,\nstringifying non-Str object using the .Str method.\n\n    \"abc\".put;              # RESULT: «abc␤»","n":"put","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"note"},{"n":"gistseen","m":0,"k":"m","s":{"p":["$id","$gist","*%named"],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"multi sub    gist(+args --> Str)\n    multi method gist(   --> Str)\n\nReturns a string representation of the invocant, optimized for fast\nrecognition by humans. As such lists will be truncated at 100 elements. Use\n.perl to get all elements.\n\nThe default gist method in Mu re-dispatches to the perl method for defined\ninvocants, and returns the type name in parenthesis for type object\ninvocants. Many built-in classes override the case of instances to\nsomething more specific that may truncate output.\n\ngist is the method that say calls implicitly, so say $something and say\n$something.gist generally produce the same output.\n\n    say Mu.gist;        # OUTPUT: «(Mu)␤»\n    say Mu.new.gist;    # OUTPUT: «Mu.new␤»","n":"gist"},{"n":"gist","d":"multi sub    gist(+args --> Str)\n    multi method gist(   --> Str)\n\nReturns a string representation of the invocant, optimized for fast\nrecognition by humans. As such lists will be truncated at 100 elements. Use\n.perl to get all elements.\n\nThe default gist method in Mu re-dispatches to the perl method for defined\ninvocants, and returns the type name in parenthesis for type object\ninvocants. Many built-in classes override the case of instances to\nsomething more specific that may truncate output.\n\ngist is the method that say calls implicitly, so say $something and say\n$something.gist generally produce the same output.\n\n    say Mu.gist;        # OUTPUT: «(Mu)␤»\n    say Mu.new.gist;    # OUTPUT: «Mu.new␤»","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"k":"m","m":0,"s":{"p":["$id","$perl","*%named"],"r":"Mu"},"n":"perlseen"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"multi method perl(--> Str)\n\nReturns a Perlish representation of the object (i.e., can usually be\nre-evaluated with EVAL to regenerate the object). The exact output of perl\nis implementation specific, since there are generally many ways to write a\nPerl expression that produces a particular value.","n":"perl"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"multi method perl(--> Str)\n\nReturns a Perlish representation of the object (i.e., can usually be\nre-evaluated with EVAL to regenerate the object). The exact output of perl\nis implementation specific, since there are generally many ways to write a\nPerl expression that produces a particular value.","n":"perl"},{"n":"DUMP","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"DUMP","s":{"p":[":$indent-step = 4",":%ctx","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"DUMP-PIECES","m":0,"k":"m","s":{"r":"Mu","p":["$before","$after = \")\"",":$indent = { ... }",":$indent-step","*%_"]}},{"s":{"p":["|args is raw (*@args, Any :$indent-step, :%ctx, Any :$flags)"],"r":"Mu"},"k":"m","m":0,"n":"DUMP-OBJECT-ATTRS"},{"d":"multi method isa(Mu $type     --> Bool:D)\n    multi method isa(Str:D $type  --> Bool:D)\n\nReturns True if the invocant is an instance of class $type, a subset type\nor a derived class (through inheritance) of $type. does is similar, but\nincludes roles.\n\n    my $i = 17;\n    say $i.isa(\"Int\");   # OUTPUT: «True␤»\n    say $i.isa(Any);     # OUTPUT: «True␤»\n    role Truish {};\n    my $but-true = 0 but Truish;\n    say $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\n    say $but-true.does(Truish); # OUTPUT: «True␤»\n    say $but-true.isa(Truish);  # OUTPUT: «False␤»","n":"isa","k":"m","m":1,"s":{"p":["Mu $type","*%_"],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":["Str:D $name","*%_"]},"m":1,"k":"m","n":"isa","d":"multi method isa(Mu $type     --> Bool:D)\n    multi method isa(Str:D $type  --> Bool:D)\n\nReturns True if the invocant is an instance of class $type, a subset type\nor a derived class (through inheritance) of $type. does is similar, but\nincludes roles.\n\n    my $i = 17;\n    say $i.isa(\"Int\");   # OUTPUT: «True␤»\n    say $i.isa(Any);     # OUTPUT: «True␤»\n    role Truish {};\n    my $but-true = 0 but Truish;\n    say $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\n    say $but-true.does(Truish); # OUTPUT: «True␤»\n    say $but-true.isa(Truish);  # OUTPUT: «False␤»"},{"n":"does","d":"method does(Mu $type --> Bool:D)\n\nReturns True if and only if the invocant conforms to type $type.\n\n    my $d = Date.new('2016-06-03');\n    say $d.does(Dateish);             # True    (Date does role Dateish)\n    say $d.does(Any);                 # True    (Date is a subclass of Any)\n    say $d.does(DateTime);            # False   (Date is not a subclass of DateTime)\n\n\nUnlike isa, which returns True only for superclasses, does includes both\nsuperclasses and roles.\n\n    say $d.isa(Dateish); # OUTPUT: «False␤»\n\n\nUsing the smartmatch operator ~~ is a more idiomatic alternative.\n\n    my $d = Date.new('2016-06-03');\n    say $d ~~ Dateish;                # OUTPUT: «True␤»\n    say $d ~~ Any;                    # OUTPUT: «True␤»\n    say $d ~~ DateTime;               # OUTPUT: «False␤»","s":{"p":["Mu $type","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"can","m":0,"k":"m","s":{"p":["$name","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%twiddles"]},"m":1,"k":"m","n":"clone","d":"multi method clone(Mu:U: *%twiddles)\n    multi method clone(Mu:D: *%twiddles)\n\nThis method will clone type objects, or die if it's invoked with any\nargument.\n\n    say Num.clone( :yes )\n    # OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block <unit>␤␤»\n\n\nIf invoked with value objects, it creates a shallow clone of the invocant,\nincluding shallow cloning of private attributes. Alternative values for\npublic attributes can be provided via named arguments with names matching\nthe attributes' names.\n\n    class Point2D {\n        has ($.x, $.y);\n        multi method gist(Point2D:D:) {\n            \"Point($.x, $.y)\";\n        }\n    }\n\n    my $p = Point2D.new(x => 2, y => 3);\n\n    say $p;                     # OUTPUT: «Point(2, 3)␤»\n    say $p.clone(y => -5);      # OUTPUT: «Point(2, -5)␤»\n\n\nNote that .clone does not go the extra mile to shallow-copy @. and %.\nsigiled attributes and, if modified, the modifications will still be\navailable in the original object:\n\n    class Foo {\n        has $.foo is rw = 42;\n        has &.boo is rw = { say \"Hi\" };\n        has @.bar       = <a b>;\n        has %.baz       = <a b c d>;\n    }\n\n    my $o1 = Foo.new;\n    with my $o2 = $o1.clone {\n        .foo = 70;\n        .bar = <Z Y>;\n        .baz = <Z Y X W>;\n        .boo = { say \"Bye\" };\n    }\n\n    # Hash and Array attribute modifications in clone appear in original as well:\n    say $o1;\n    # OUTPUT: «Foo.new(foo => 42, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    say $o2;\n    # OUTPUT: «Foo.new(foo => 70, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    $o1.boo.(); # OUTPUT: «Hi␤»\n    $o2.boo.(); # OUTPUT: «Bye␤»\n\n\nTo clone those, you could implement your own .clone that clones the\nappropriate attributes and passes the new values to Mu.clone, for example,\nvia nextwith.\n\n    class Bar {\n        has $.quux;\n        has @.foo = <a b>;\n        has %.bar = <a b c d>;\n        method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n    }\n\n    my $o1 = Bar.new( :42quux );\n    with my $o2 = $o1.clone {\n        .foo = <Z Y>;\n        .bar = <Z Y X W>;\n    }\n\n    # Hash and Array attribute modifications in clone do not affect original:\n    say $o1;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"a\", \"b\"], bar => {:a(\"b\"), :c(\"d\")})␤»\n    say $o2;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"Z\", \"Y\"], bar => {:X(\"W\"), :Z(\"Y\")})␤»\n\n\nThe |%_ is needed to slurp the rest of the attributes that would have been\ncopied via shallow copy."},{"n":"clone","d":"multi method clone(Mu:U: *%twiddles)\n    multi method clone(Mu:D: *%twiddles)\n\nThis method will clone type objects, or die if it's invoked with any\nargument.\n\n    say Num.clone( :yes )\n    # OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block <unit>␤␤»\n\n\nIf invoked with value objects, it creates a shallow clone of the invocant,\nincluding shallow cloning of private attributes. Alternative values for\npublic attributes can be provided via named arguments with names matching\nthe attributes' names.\n\n    class Point2D {\n        has ($.x, $.y);\n        multi method gist(Point2D:D:) {\n            \"Point($.x, $.y)\";\n        }\n    }\n\n    my $p = Point2D.new(x => 2, y => 3);\n\n    say $p;                     # OUTPUT: «Point(2, 3)␤»\n    say $p.clone(y => -5);      # OUTPUT: «Point(2, -5)␤»\n\n\nNote that .clone does not go the extra mile to shallow-copy @. and %.\nsigiled attributes and, if modified, the modifications will still be\navailable in the original object:\n\n    class Foo {\n        has $.foo is rw = 42;\n        has &.boo is rw = { say \"Hi\" };\n        has @.bar       = <a b>;\n        has %.baz       = <a b c d>;\n    }\n\n    my $o1 = Foo.new;\n    with my $o2 = $o1.clone {\n        .foo = 70;\n        .bar = <Z Y>;\n        .baz = <Z Y X W>;\n        .boo = { say \"Bye\" };\n    }\n\n    # Hash and Array attribute modifications in clone appear in original as well:\n    say $o1;\n    # OUTPUT: «Foo.new(foo => 42, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    say $o2;\n    # OUTPUT: «Foo.new(foo => 70, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    $o1.boo.(); # OUTPUT: «Hi␤»\n    $o2.boo.(); # OUTPUT: «Bye␤»\n\n\nTo clone those, you could implement your own .clone that clones the\nappropriate attributes and passes the new values to Mu.clone, for example,\nvia nextwith.\n\n    class Bar {\n        has $.quux;\n        has @.foo = <a b>;\n        has %.bar = <a b c d>;\n        method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n    }\n\n    my $o1 = Bar.new( :42quux );\n    with my $o2 = $o1.clone {\n        .foo = <Z Y>;\n        .bar = <Z Y X W>;\n    }\n\n    # Hash and Array attribute modifications in clone do not affect original:\n    say $o1;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"a\", \"b\"], bar => {:a(\"b\"), :c(\"d\")})␤»\n    say $o2;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"Z\", \"Y\"], bar => {:X(\"W\"), :Z(\"Y\")})␤»\n\n\nThe |%_ is needed to slurp the rest of the attributes that would have been\ncopied via shallow copy.","s":{"p":["*%twiddles"],"r":"Mu"},"k":"m","m":1},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Capture","d":"Declared as:\n\n    method Capture(Mu:D: --> Capture:D)\n\nReturns a Capture with named arguments corresponding to invocant's public\nattributes:\n\n    class Foo {\n        has $.foo = 42;\n        has $.bar = 70;\n        method bar { 'something else' }\n    }.new.Capture.say; # OUTPUT: «\\(:bar(\"something else\"), :foo(42))␤»"},{"n":"dispatch:<var>","s":{"p":["$var","|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["$name","Mu $type","|c is raw"]},"m":0,"k":"m","n":"dispatch:<::>"},{"m":0,"k":"m","s":{"p":["\\name","Mu \\type","|c is raw"],"r":"Mu"},"n":"dispatch:<!>"},{"n":"dispatch:<.=>","s":{"r":"Mu","p":["$name","|c is raw"]},"k":"m","m":0},{"n":"dispatch:<.?>","s":{"r":"Mu","p":["$name","|c is raw"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["$name","|c is raw"],"r":"Mu"},"n":"dispatch:<.+>"},{"n":"dispatch:<.*>","s":{"p":["\\name","|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"n":"dispatch:<hyper>","m":0,"k":"m","s":{"r":"Mu","p":["$nodality","Str $meth-name","|c is raw"]}},{"k":"m","m":0,"s":{"r":"Mu","p":[":$name!",":$canonical",":$ascendant",":$descendant",":$preorder",":$breadth",":$super",":$omit",":$include","*%_"]},"n":"WALK"}],"n":"Mu","d":"TITLE\nclass Mu\n\nSUBTITLE\nThe root of the Raku type hierarchy.\n\n    class Mu { }\n\nThe root of the Raku type hierarchy. For the origin of the name, see\nhttps://en.wikipedia.org/wiki/Mu_%28negative%29. One can also say that\nthere are many undefined values in Raku, and Mu is the most undefined\nvalue.\n\nNote that most classes do not derive from Mu directly, but rather from\nAny.\n\n","t":"Mu","b":"M"},{"k":"e","n":"SIGSEGV","t":"Signal"},{"k":"v","n":"&goto","t":"Sub"},{"s":{"r":"Nil","p":["Label:D \\x"]},"k":"s","m":1,"n":"goto"},{"mro":[],"m":[{"n":"meta","d":"method meta(--> Hash:D) { ... }\n\nReturns a Hash with the representation of the metadata. Please note that an\nactual META6.json file does not need to exist, just a representation in\nthat format.","s":{"p":["*%_"],"r":"Hash"},"m":0,"k":"m"},{"s":{"p":["$content-id","*%_"],"r":"IO::Handle"},"k":"m","m":0,"n":"content","d":"method content($name-path --> IO::Handle:D) { ... }\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt."}],"k":"ro","n":"Distribution","t":"Distribution","d":"TITLE\nrole Distribution\n\nSUBTITLE\nDistribution\n\n    role Distribution { }\n\nInterface for objects that provide API access mapping META6 data to the\nfiles its represents. Objects that fulfill the Distribution role can be\nread by e.g. CompUnit::Repository::Installation. Generally a Distribution\nprovides read access to a set of modules and metadata. These may be backed\nby the filesystem (Distribution::Path, Distribution::Hash) but could also\nread from an e.g. tar file or socket.\n\nRequired ","b":"C"},{"n":"Distribution::Path","a":[{"k":"v","n":"$!meta","t":"Mu"},{"k":"v","n":"$!meta-file","t":"Mu"},{"k":"v","t":"IO::Path","n":"$.prefix"}],"d":"TITLE\nclass Distribution::Path\n\nSUBTITLE\nDistribution::Path\n\n        class Distribution::Path does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It requires a\nMETA6.json file at its root.\n\n","t":"Distribution::Path","mro":["Distribution::Locally","Distribution","Any"],"k":"c","m":[{"s":{"p":[":meta($!meta)",":prefix($!prefix)",":meta-file($!meta-file)","*%_"],"r":"Nil"},"m":0,"k":"s","n":"BUILD"},{"m":0,"k":"m","s":{"p":["IO::Path $prefix","IO::Path :$meta-file = IO::Path","*%_"],"r":"Mu"},"d":"method new(IO::Path $prefix, IO::Path :$meta-file = IO::Path)\n\nCreates a new Distribution::Path instance from the META6.json file found at\nthe given $prefix, and from which all paths in the metadata will be\nprefixed with. :$meta-file may optionally be passed if a filename other\nthan META6.json needs to be used.","n":"new"},{"n":"meta","d":"method meta()\n\nReturns a Hash with the representation of the metadata.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"perl"},{"n":"prefix","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"b":"A"},{"n":"Distribution::Resources","t":"Distribution::Resources","a":[{"k":"v","t":"Str","n":"$.dist-id"},{"n":"$.repo","t":"Str","k":"v"},{"k":"v","t":"Str","n":"$.repo-name"}],"mro":["Associative","Any"],"k":"c","m":[{"n":"BUILD","k":"m","m":1,"s":{"p":[":dist-id($!dist-id)","CompUnit::Repository :$repo","*%_"],"r":"Nil"}},{"n":"BUILD","k":"m","m":1,"s":{"p":[":dist-id($!dist-id)",":$repo","Str :repo-name($!repo-name)","*%_"],"r":"Nil"}},{"n":"BUILD","m":1,"k":"m","s":{"p":[":dist-id($!dist-id)","Str :repo($!repo)",":$repo-name","*%_"],"r":"Nil"}},{"n":"from-precomp","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"AT-KEY","s":{"p":["$key","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"Str","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"dist-id"},{"n":"repo","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"repo-name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"d":"TITLE\nclass Distribution::Locally\n\nSUBTITLE\nDistribution::Locally\n\n    role Distribution::Locally does Distribution { }\n\nProvides read access to specific files pointed at by a distributions\nmetadata, providing the Distribution#method_content method for\nDistribution::Path and Distribution::Hash.\n\n","a":[{"t":"IO::Path","n":"$.prefix","k":"v"}],"t":"Distribution::Locally","n":"Distribution::Locally","m":[{"n":"content","d":"Provides Distribution#method_content\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt, and these paths will be prefixed with\nDistribution#method_prefix.","s":{"r":"Mu","p":["$address","*%_"]},"m":0,"k":"m"}],"k":"ro","mro":[],"b":"C"},{"b":"A","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"IO"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"platform-library-name"},{"n":"absolute","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"n":"is-absolute","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"n":"relative","s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0,"n":"is-relative"},{"s":{"r":"Mu","p":["|c is raw"]},"m":0,"k":"m","n":"parts"},{"n":"volume","s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"n":"dirname"},{"n":"basename","s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0},{"n":"extension","k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"n":"open"},{"s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0,"n":"resolve"},{"m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]},"n":"slurp"},{"n":"lines","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"n":"comb","k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"n":"split"},{"n":"words","s":{"r":"Mu","p":["|c is raw"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"n":"copy"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"repo"},{"n":"repo-name","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"dist-id"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"key"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Any"],"a":[{"t":"Mu","n":"$.repo","k":"v"},{"n":"$.repo-name","t":"Mu","k":"v"},{"n":"$.dist-id","t":"Mu","k":"v"},{"n":"$.key","t":"Mu","k":"v"}],"t":"Distribution::Resource","n":"Distribution::Resource"},{"b":"A","n":"Distribution::Hash","a":[{"n":"$!meta","t":"Mu","k":"v"},{"k":"v","n":"$.prefix","t":"IO::Path"}],"t":"Distribution::Hash","d":"TITLE\nclass Distribution::Hash\n\nSUBTITLE\nDistribution::Hash\n\n        class Distribution::Hash does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It does not require\na META6.json file, essentially providing a lower level Distribution::Path.\n\n","mro":["Distribution::Locally","Distribution","Any"],"m":[{"n":"BUILD","s":{"p":[":meta($!meta)",":prefix($!prefix)","*%_"],"r":"Nil"},"k":"s","m":0},{"n":"new","d":"method new($hash, :$prefix)\n\nCreates a new Distribution::Hash instance from the metadata contained in\n$hash. All paths in the metadata will be prefixed with :$prefix.","s":{"r":"Mu","p":["$hash",":$prefix","*%_"]},"k":"m","m":0},{"n":"meta","d":"method meta()\n\nReturns a Hash with the representation of the metadata.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"perl"},{"n":"prefix","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c"},{"n":"SIGPIPE","t":"Signal","k":"e"},{"t":"Sub","n":"&return","k":"v"},{"s":{"r":"Nil","p":[]},"k":"s","m":1,"n":"return"},{"s":{"r":"Nil","p":["Mu \\x"]},"k":"s","m":1,"n":"return"},{"m":1,"k":"s","s":{"r":"Nil","p":["**@x is raw"]},"n":"return"},{"k":"e","t":"Order","n":"Same"},{"t":"Sub","n":"&trim-trailing","k":"v"},{"s":{"p":["Cool:D $s"],"r":"Str:D"},"m":1,"k":"s","n":"trim-trailing"},{"n":"&infix:<⊉>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Bool:D","p":["\\a","\\b"]},"k":"s","m":1,"n":"infix:<⊉>"},{"a":[{"k":"v","n":"$!do","t":"Code"},{"n":"$!signature","t":"Signature","k":"v"},{"t":"List","n":"@!compstuff","k":"v"}],"t":"Code","d":"TITLE\nclass Code\n\nSUBTITLE\nCode object\n\n    class Code is Any does Callable {}\n\nCode is the ultimate base class of all code objects in Raku. It exposes\nfunctionality that all code objects have. While thunks are directly of type\nCode, most code objects (such as those resulting from blocks, subroutines\nor methods) will belong to some subclass of Code.\n\n","n":"Code","k":"c","m":[{"d":"Defined as:\n\n    method arity(Code:D: --> Int:D)\n\nReturns the minimum number of positional arguments that must be passed in\norder to call the code object. Any optional or slurpy parameters in the\ncode object's Signature do not contribute, nor do named parameters.\n\n    sub argless() { }\n    sub args($a, $b?) { }\n    sub slurpy($a, $b, *@c) { }\n    say &argless.arity;             # OUTPUT: «0␤»\n    say &args.arity;                # OUTPUT: «1␤»\n    say &slurpy.arity;              # OUTPUT: «2␤»","n":"arity","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method count(Code:D: --> Real:D)\n\nReturns the maximum number of positional arguments that may be passed when\ncalling the code object. For code objects that can accept any number of\npositional arguments (that is, they have a slurpy parameter), count will\nreturn Inf. Named parameters do not contribute.\n\n    sub argless() { }\n    sub args($a, $b?) { }\n    sub slurpy($a, $b, *@c) { }\n    say &argless.count;             # OUTPUT: «0␤»\n    say &args.count;                # OUTPUT: «2␤»\n    say &slurpy.count;              # OUTPUT: «Inf␤»","n":"count"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method signature(Code:D: --> Signature:D)\n\nReturns the Signature object for this code object, which describes its\nparameters.\n\n    sub a(Int $one, Str $two) {};\n    say &a.signature; # OUTPUT: «(Int $one, Str $two)␤»","n":"signature"},{"s":{"r":"Mu","p":["Capture:D $c","*%_"]},"k":"m","m":0,"n":"cando","d":"method cando(Capture $c)\n\nReturns a list of candidates that can be called with the given Capture.\nSince Code objects do not have any multiple dispatch, this either returns a\nlist with the object, or an empty list.\n\n    my $single = \\'a';         # a single argument Capture\n    my $plural = \\('a', 42);   # a two argument Capture\n    my &block = { say $^a };   # a Block object, that is a subclass of Code, taking one argument\n    say &block.cando($single); # OUTPUT: «(-> $a { #`(Block|94212856419136) ... })␤»\n    say &block.cando($plural); # OUTPUT: «()␤»"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"prec"},{"n":"prec","s":{"p":["Str:D $","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"outer","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"static_id"},{"d":"Defined as:\n\n    method file(Code:D: --> Str:D)\n\nReturns the name of the file in which the code object was declared.\n\n    say &infix:<+>.file;","n":"file","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as\n\n    method line(Code:D: --> Int:D)\n\nReturns the line number in which the code object was declared.\n\n    say &infix:<+>.line;","n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"method assuming(Callable:D $self: |primers)\n\nReturns a Callable that implements the same behavior as the original, but\nhas the values passed to .assuming already bound to the corresponding\nparameters.\n\n    my sub slow($n){ my $i = 0; $i++ while $i < $n; $i };\n\n    # takes only one parameter and as such wont forward $n\n    sub bench(&c){ c, now - ENTER now };\n\n    say &slow.assuming(10000000).&bench; # OUTPUT: «(10000000 7.5508834)␤»\n\nFor a sub with arity greater than one, you can use Whatever * for all of\nthe positional parameters that are not \"assumed\".\n\n    sub first-and-last ( $first, $last ) {\n        say \"Name is $first $last\";\n    }\n\n    my &surname-smith = &first-and-last.assuming( *, 'Smith' );\n\n    &surname-smith.( 'Joe' ); # OUTPUT: «Name is Joe Smith␤»\n\nYou can handle any combination of assumed and not assumed positional\nparameters:\n\n    sub longer-names ( $first, $middle, $last, $suffix ) {\n        say \"Name is $first $middle $last $suffix\";\n    }\n\n    my &surname-public = &longer-names.assuming( *, *, 'Public', * );\n\n    &surname-public.( 'Joe', 'Q.', 'Jr.'); # OUTPUT: «Name is Joe Q. Public Jr.␤»\n\n\nNamed parameters can be assumed as well:\n\n    sub foo { say \"$^a $^b $:foo $:bar\" }\n    &foo.assuming(13, :42foo)(24, :72bar); # OUTPUT: «13 24 42 72␤»\n\nAnd you can use .assuming on all types of Callables, including Methods and\nBlocks:\n\n    # We use a Whatever star for the invocant:\n    my &comber = Str.^lookup('comb').assuming: *, /P \\w+/;\n    say comber 'Perl is awesome! Python is great! And PHP is OK too';\n    # OUTPUT: «(Perl Python PHP)␤»\n\n    my &learner = {\n        \"It took me $:months months to learn $^lang\"\n    }.assuming: 'Raku';\n    say learner :6months;  # OUTPUT: «It took me 6 months to learn Raku␤»","n":"assuming","k":"m","m":0,"s":{"r":"Mu","p":["|primers is raw"]}}],"mro":["Callable","Any"],"b":"A"},{"k":"v","t":"Sub","n":"&subbuf-rw"},{"s":{"r":"Mu","p":["Buf:D \\b"]},"m":1,"k":"s","n":"subbuf-rw"},{"n":"subbuf-rw","s":{"p":["Buf:D \\b","$from"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Buf:D \\b","$from","$elems"],"r":"Mu"},"n":"subbuf-rw"},{"n":"PromiseStatus","t":"PromiseStatus","k":"e"},{"n":"PromiseStatus::Broken","t":"PromiseStatus","k":"e"},{"k":"e","n":"PromiseStatus::Kept","t":"PromiseStatus"},{"t":"PromiseStatus","n":"PromiseStatus::Planned","k":"e"},{"t":"Sub+{is-pure}","n":"&max","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["+\\args is raw",":&by!"]},"n":"max"},{"k":"s","m":1,"s":{"r":"Mu","p":["+\\args is raw"]},"n":"max"},{"m":[{"k":"m","m":0,"s":{"p":["Awaitable:D $a","*%_"],"r":"Mu"},"n":"await"},{"s":{"r":"Mu","p":["Iterable:D $i","*%_"]},"m":0,"k":"m","n":"await-all"}],"k":"ro","mro":[],"t":"Awaiter","n":"Awaiter","b":"C"},{"b":"A","n":"Awaiter::Blocking","t":"Awaiter::Blocking","mro":["Awaiter","Any"],"m":[{"s":{"p":["Awaitable:D $a","*%_"],"r":"Mu"},"m":0,"k":"m","n":"await"},{"s":{"r":"Mu","p":["Iterable:D \\i","*%_"]},"m":0,"k":"m","n":"await-all"}],"k":"c"},{"b":"A","mro":["Mu"],"k":"c","m":[{"s":{"p":["$","*%_"],"r":"Bool"},"m":1,"k":"m","n":"EXISTS-KEY"},{"m":1,"k":"m","s":{"p":["$","*%_"],"r":"Bool"},"n":"EXISTS-KEY"},{"m":1,"k":"m","s":{"r":"Nil","p":["$","*%_"]},"n":"DELETE-KEY"},{"n":"DELETE-KEY","s":{"r":"Mu","p":["$","*%_"]},"m":1,"k":"m"},{"s":{"r":"Nil","p":["$pos","*%_"]},"k":"m","m":1,"n":"DELETE-POS"},{"s":{"p":["$pos","*%_"],"r":"Mu"},"m":1,"k":"m","n":"DELETE-POS"},{"n":"DELETE-POS","s":{"p":["\\one","\\two","*%_"],"r":"Mu"},"k":"m","m":1},{"s":{"r":"Mu","p":["\\one","\\two","\\three","*%_"]},"k":"m","m":1,"n":"DELETE-POS"},{"n":"DELETE-POS","m":1,"k":"m","s":{"p":["**@indices","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"cache","d":"Defined as:\n\n    method cache()\n\nProvides a List representation of the object itself, calling the method\nlist on the instance."},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"list","d":"Defined as:\n\n    multi method list(Any:U: --> List)\n    multi method list(Any:D \\SELF: --> List)\n\nApplies the infix , operator to the invocant and returns the resulting\nList:\n\n    say 42.list.^name;           # OUTPUT: «List␤»\n    say 42.list.elems;           # OUTPUT: «1␤»\n\nSubclasses of Any may choose to return any core type that does the\nPositional role from .list. Use .List to coerce specifically to List.\n\n @ can also be used as a list or Positional contextualizer:\n\n    my $not-a-list-yet = $[1,2,3];\n    say $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\n    my @maybe-a-list = @$not-a-list-yet;\n    say @maybe-a-list.^name;              # OUTPUT: «Array␤»\n\n\nIn the first case, the list is itemized. @ as a prefix puts the initial\nscalar in a list context by calling .list and turning it into an Array."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"list","d":"Defined as:\n\n    multi method list(Any:U: --> List)\n    multi method list(Any:D \\SELF: --> List)\n\nApplies the infix , operator to the invocant and returns the resulting\nList:\n\n    say 42.list.^name;           # OUTPUT: «List␤»\n    say 42.list.elems;           # OUTPUT: «1␤»\n\nSubclasses of Any may choose to return any core type that does the\nPositional role from .list. Use .List to coerce specifically to List.\n\n @ can also be used as a list or Positional contextualizer:\n\n    my $not-a-list-yet = $[1,2,3];\n    say $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\n    my @maybe-a-list = @$not-a-list-yet;\n    say @maybe-a-list.^name;              # OUTPUT: «Array␤»\n\n\nIn the first case, the list is itemized. @ as a prefix puts the initial\nscalar in a list context by calling .list and turning it into an Array."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"flat","d":"Defined as:\n\n    method flat() is nodal\n\nInterprets the invocant as a list, flattens non-containerized Iterables\ninto a flat list, and returns that list. Keep in mind Map and Hash types\nare Iterable and so will be flattened into lists of pairs.\n\n    say ((1, 2), (3), %(:42a));      # OUTPUT: «((1 2) 3 {a => 42})␤»\n    say ((1, 2), (3), %(:42a)).flat; # OUTPUT: «(1 2 3 a => 42)␤»\n\nNote that Arrays containerize their elements by default, and so flat will\nnot flatten them. You can use hyper method call to call .List method on all\nthe inner Iterables and so de-containerize them, so that flat can flatten\nthem:\n\n    say [[1, 2, 3], [(4, 5), 6, 7]]      .flat; # OUTPUT: «([1 2 3] [(4 5) 6 7])␤»\n    say [[1, 2, 3], [(4, 5), 6, 7]]».List.flat; # OUTPUT: «(1 2 3 4 5 6 7)␤»\n\nFor more fine-tuned options, see deepmap, duckmap, and signature\ndestructuring"},{"d":"Defined as:\n\n    method eager() is nodal\n\nInterprets the invocant as a List, evaluates it eagerly, and returns that\nList.\n\n    my  $range = 1..5;\n    say $range;         # OUTPUT: «1..5␤»\n    say $range.eager;   # OUTPUT: «(1 2 3 4 5)␤»","n":"eager","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as\n\n    multi method serial()\n\nThis method is Rakudo specific, and is not included in the Raku spec.\n\nThe method returns the self-reference to the instance itself:\n\n    my $b;                 # defaults to Any\n    say $b.serial.^name;   # OUTPUT: «Any␤»\n    say $b.^name;          # OUTPUT: «Any␤»\n    my $breakfast = 'food';\n    $breakfast.serial.say; # OUTPUT: «food␤»\n\n\nThis is apparently a no-op, as exemplified by the third example above.\nHowever, in HyperSeqs and RaceSeqs it returns a serialized Seq, so it can\nbe considered the opposite of the hyper/race methods. As such, it ensures\nthat we are in serial list-processing mode, as opposed to the autothreading\nmode of those methods.","n":"serial","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method List(--> List:D) is nodal\n\nCoerces the invocant to List, using the list method.","n":"List"},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"Slip","d":"Defined as:\n\n    method Slip(--> Slip:D) is nodal\n\nCoerces the invocant to Slip."},{"n":"Array","d":"Defined as:\n\n    method Array(--> Array:D) is nodal\n\nCoerces the invocant to an Array.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"n":"Seq","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"hash","d":"Defined as:\n\n    multi method hash(Any:U:)\n    multi method hash(Any:D:)\n\nWhen called on a type object, returns an empty Hash. On instances, it is\nequivalent to assigning the invocant to a %-sigiled variable and returning\nthat.\n\nSubclasses of Any may choose to return any core type that does the\nAssociative role from .hash. Use .Hash to coerce specifically to Hash.\n\n    my $d; # $d is Any\n    say $d.hash; # OUTPUT: {}\n\n    my %m is Map = a => 42, b => 666;\n    say %m.hash;  # Map.new((a => 42, b => 666))\n    say %m.Hash;  # {a => 42, b => 666}"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"hash","d":"Defined as:\n\n    multi method hash(Any:U:)\n    multi method hash(Any:D:)\n\nWhen called on a type object, returns an empty Hash. On instances, it is\nequivalent to assigning the invocant to a %-sigiled variable and returning\nthat.\n\nSubclasses of Any may choose to return any core type that does the\nAssociative role from .hash. Use .Hash to coerce specifically to Hash.\n\n    my $d; # $d is Any\n    say $d.hash; # OUTPUT: {}\n\n    my %m is Map = a => 42, b => 666;\n    say %m.hash;  # Map.new((a => 42, b => 666))\n    say %m.Hash;  # {a => 42, b => 666}"},{"n":"Hash","d":"Defined as:\n\n    multi method Hash( --> Hash:D)\n\nCoerces the invocant to Hash.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"Map","d":"Defined as:\n\n    method Map(--> Map:D) is nodal\n\nCoerces the invocant to Map."},{"d":"Defined as:\n\n    multi method elems(Any:U: --> 1)\n    multi method elems(Any:D:)\n\nInterprets the invocant as a list, and returns the number of elements in\nthe list.\n\n    say 42.elems;                   # OUTPUT: «1␤»\n    say <a b c>.elems;              # OUTPUT: «3␤»\n    say Whatever.elems ;            # OUTPUT: «1␤»\n\nIt will also return 1 for classes.","n":"elems","m":1,"k":"m","s":{"p":["*%_"],"r":"Int"}},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method elems(Any:U: --> 1)\n    multi method elems(Any:D:)\n\nInterprets the invocant as a list, and returns the number of elements in\nthe list.\n\n    say 42.elems;                   # OUTPUT: «1␤»\n    say <a b c>.elems;              # OUTPUT: «3␤»\n    say Whatever.elems ;            # OUTPUT: «1␤»\n\nIt will also return 1 for classes.","n":"elems"},{"s":{"r":"Int","p":["*%_"]},"m":1,"k":"m","n":"end","d":"multi method end(Any:U: --> 0)\n    multi method end(Any:D:)\n\nInterprets the invocant as a list, and returns the last index of that\nlist.\n\n    say 6.end;                      # OUTPUT: «0␤»\n    say <a b c>.end;                # OUTPUT: «2␤»"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"end","d":"multi method end(Any:U: --> 0)\n    multi method end(Any:D:)\n\nInterprets the invocant as a list, and returns the last index of that\nlist.\n\n    say 6.end;                      # OUTPUT: «0␤»\n    say <a b c>.end;                # OUTPUT: «2␤»"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method keys(Any:U: --> List)\n    multi method keys(Any:D: --> List)\n\nFor defined Any returns its keys after calling list on it, otherwise calls\nlist and returns it.\n\n    my $setty = Set(<Þor Oðin Freija>);\n    say $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»\n\nSee also List.keys.\n\nTrying the same on a class will return an empty list, since most of them\ndon't really have keys.","n":"keys"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"keys","d":"Defined as:\n\n    multi method keys(Any:U: --> List)\n    multi method keys(Any:D: --> List)\n\nFor defined Any returns its keys after calling list on it, otherwise calls\nlist and returns it.\n\n    my $setty = Set(<Þor Oðin Freija>);\n    say $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»\n\nSee also List.keys.\n\nTrying the same on a class will return an empty list, since most of them\ndon't really have keys."},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method kv(Any:U:)\n    multi method kv(Any:D:)\n    multi sub    kv($x)\n\nReturns an empty List if the invocant is a type object:\n\n    Sub.kv.say ;# OUTPUT: «()␤»\n\nIt calls list on the invocant for value objects and returns the result of\nList.kv on it as a list where keys and values will be ordered and\ncontiguous\n\n    <1 2 3>.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»\n\nIn the case of Positionals, the indices will be considered keys.","n":"kv"},{"n":"kv","d":"Defined as:\n\n    multi method kv(Any:U:)\n    multi method kv(Any:D:)\n    multi sub    kv($x)\n\nReturns an empty List if the invocant is a type object:\n\n    Sub.kv.say ;# OUTPUT: «()␤»\n\nIt calls list on the invocant for value objects and returns the result of\nList.kv on it as a list where keys and values will be ordered and\ncontiguous\n\n    <1 2 3>.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»\n\nIn the case of Positionals, the indices will be considered keys.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method values(Any:U:)\n    multi method values(Any:D:)\n\nWill return an empty list for undefined or class arguments, and the object\nconverted to a list otherwise.\n\n    say (1..3).values; # OUTPUT: «(1 2 3)␤»\n    say List.values;   # OUTPUT: «()␤»","n":"values"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"values","d":"Defined as:\n\n    multi method values(Any:U:)\n    multi method values(Any:D:)\n\nWill return an empty list for undefined or class arguments, and the object\nconverted to a list otherwise.\n\n    say (1..3).values; # OUTPUT: «(1 2 3)␤»\n    say List.values;   # OUTPUT: «()␤»"},{"d":"Defined as:\n\n    multi method pairs(Any:U:)\n    multi method pairs(Any:D:)\n\nReturns an empty List if the invocant is a type object:\n\n    say Num.pairs; # OUTPUT: «()␤»\n\nFor a value object, it converts the invocant to a List via the list method\nand returns the result of List.pairs on it.\n\n    <1 2 2 3 3 3>.Bag.pairs.say;# OUTPUT: «(1 => 1 3 => 3 2 => 2)␤»\n\nIn this case, every element (with weight) in a bag is converted to a pair.","n":"pairs","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pairs","d":"Defined as:\n\n    multi method pairs(Any:U:)\n    multi method pairs(Any:D:)\n\nReturns an empty List if the invocant is a type object:\n\n    say Num.pairs; # OUTPUT: «()␤»\n\nFor a value object, it converts the invocant to a List via the list method\nand returns the result of List.pairs on it.\n\n    <1 2 2 3 3 3>.Bag.pairs.say;# OUTPUT: «(1 => 1 3 => 3 2 => 2)␤»\n\nIn this case, every element (with weight) in a bag is converted to a pair.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"d":"Defined as:\n\n    multi method antipairs(Any:U:)\n    multi method antipairs(Any:D:)\n\nReturns an empty List if the invocant is a type object\n\n    Range.antipairs.say; # OUTPUT: «()␤»\n\nIf it's a value object, it returns the inverted list of pairs after\nconverting it to a list of pairs; the values will become keys and the other\nway round.\n\n    %(s => 1, t=> 2, u => 3).antipairs.say ;# OUTPUT: «(2 => t 1 => s 3 => u)␤»","n":"antipairs","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method antipairs(Any:U:)\n    multi method antipairs(Any:D:)\n\nReturns an empty List if the invocant is a type object\n\n    Range.antipairs.say; # OUTPUT: «()␤»\n\nIf it's a value object, it returns the inverted list of pairs after\nconverting it to a list of pairs; the values will become keys and the other\nway round.\n\n    %(s => 1, t=> 2, u => 3).antipairs.say ;# OUTPUT: «(2 => t 1 => s 3 => u)␤»","n":"antipairs"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method invert(Any:U:)\n    multi method invert(Any:D:)\n\nApplied to a type object will return an empty list; applied to an object\nwill convert it to a list and apply List.invert to it, that is, interchange\nkey with value in every Pair. The resulting list needs to be a list of\nPairs.\n\n    \"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 => c 3 => a 2 => b)␤»\n\nIn this case, a Bag can be converted to a list of Pairs. If the result of\nconverting the object to a list is not a list of pairs, the method will\nfail.","n":"invert"},{"d":"Defined as:\n\n    multi method invert(Any:U:)\n    multi method invert(Any:D:)\n\nApplied to a type object will return an empty list; applied to an object\nwill convert it to a list and apply List.invert to it, that is, interchange\nkey with value in every Pair. The resulting list needs to be a list of\nPairs.\n\n    \"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 => c 3 => a 2 => b)␤»\n\nIn this case, a Bag can be converted to a list of Pairs. If the result of\nconverting the object to a list is not a list of pairs, the method will\nfail.","n":"invert","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"pick","d":"Defined as:\n\n    multi method pick(--> Any)\n    multi method pick($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.pick on it.\n\n    my Range $rg = 'α'..'ω';\n    say $rg.pick(3); # OUTPUT: «(β α σ)␤»"},{"d":"Defined as:\n\n    multi method pick(--> Any)\n    multi method pick($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.pick on it.\n\n    my Range $rg = 'α'..'ω';\n    say $rg.pick(3); # OUTPUT: «(β α σ)␤»","n":"pick","k":"m","m":1,"s":{"r":"Mu","p":["$n","*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m","n":"roll","d":"Defined as:\n\n    multi method roll(--> Any)\n    multi method roll($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.roll on it.\n\n    my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\n    say $m.roll;    # OUTPUT: «ð␤»\n    say $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»\n\n$m, in this case, is converted into a list and then a (weighted in this\ncase) dice is rolled on it. See also List.roll for more information."},{"d":"Defined as:\n\n    multi method roll(--> Any)\n    multi method roll($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.roll on it.\n\n    my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\n    say $m.roll;    # OUTPUT: «ð␤»\n    say $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»\n\n$m, in this case, is converted into a list and then a (weighted in this\ncase) dice is rolled on it. See also List.roll for more information.","n":"roll","m":1,"k":"m","s":{"p":["$n","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["|"]},"m":0,"k":"m","n":"match"},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method classify()\n    multi method classify(Whatever)\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nThe two first forms will fail. The rest include a $test, which is a\nfunction that will return a scalar for every input; these will be used as\nkeys of a hash whose values will be arrays with the elements that output\nthat key for the test function.\n\n    my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.classify( *.is-leap-year , into => my %leap-years );\n    say %leap-years;\n    # OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n    #           True => [2004-01-01 2008-01-01]}␤»\n\n\nSimilarly to .categorize, elements can be normalized by the Callable passed\nwith the :as argument, and it can use the :into named argument to pass a\nHash the results will be classified into; in the example above, it's\ndefined on the fly.\n\nFrom version 6.d, .classify will also work with Junctions.","n":"classify"},{"s":{"p":["Whatever $","*%_"],"r":"Mu"},"m":1,"k":"m","n":"classify","d":"Defined as:\n\n    multi method classify()\n    multi method classify(Whatever)\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nThe two first forms will fail. The rest include a $test, which is a\nfunction that will return a scalar for every input; these will be used as\nkeys of a hash whose values will be arrays with the elements that output\nthat key for the test function.\n\n    my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.classify( *.is-leap-year , into => my %leap-years );\n    say %leap-years;\n    # OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n    #           True => [2004-01-01 2008-01-01]}␤»\n\n\nSimilarly to .categorize, elements can be normalized by the Callable passed\nwith the :as argument, and it can use the :into named argument to pass a\nHash the results will be classified into; in the example above, it's\ndefined on the fly.\n\nFrom version 6.d, .classify will also work with Junctions."},{"s":{"p":["$test",":$into!",":&as","*%_"],"r":"Mu"},"m":1,"k":"m","n":"classify","d":"Defined as:\n\n    multi method classify()\n    multi method classify(Whatever)\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nThe two first forms will fail. The rest include a $test, which is a\nfunction that will return a scalar for every input; these will be used as\nkeys of a hash whose values will be arrays with the elements that output\nthat key for the test function.\n\n    my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.classify( *.is-leap-year , into => my %leap-years );\n    say %leap-years;\n    # OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n    #           True => [2004-01-01 2008-01-01]}␤»\n\n\nSimilarly to .categorize, elements can be normalized by the Callable passed\nwith the :as argument, and it can use the :into named argument to pass a\nHash the results will be classified into; in the example above, it's\ndefined on the fly.\n\nFrom version 6.d, .classify will also work with Junctions."},{"d":"Defined as:\n\n    multi method classify()\n    multi method classify(Whatever)\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nThe two first forms will fail. The rest include a $test, which is a\nfunction that will return a scalar for every input; these will be used as\nkeys of a hash whose values will be arrays with the elements that output\nthat key for the test function.\n\n    my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.classify( *.is-leap-year , into => my %leap-years );\n    say %leap-years;\n    # OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n    #           True => [2004-01-01 2008-01-01]}␤»\n\n\nSimilarly to .categorize, elements can be normalized by the Callable passed\nwith the :as argument, and it can use the :into named argument to pass a\nHash the results will be classified into; in the example above, it's\ndefined on the fly.\n\nFrom version 6.d, .classify will also work with Junctions.","n":"classify","m":1,"k":"m","s":{"r":"Mu","p":["$test",":&as","*%_"]}},{"n":"categorize","d":"Defined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThe two first forms fail with an error message.\n\nIn its simplest form, it uses a $test whose result will be used as a key;\nthe values of the key will be an array of the elements that produced that\nkey as a result of the test.\n\n    say (1..13).categorize( * %% 3);\n    say categorize( * %% 3, 1..13)\n    # OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n\n\nThe :as argument will normalize before categorizing\n\n    say categorize( * %% 3, -5..5, as => &abs )\n    # OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n\n\nThe $into associative argument can be used to put the result instead of\nreturning a new Hash\n\n    my %leap-years;\n    my @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.categorize( *.is-leap-year , into => %leap-years );\n    say %leap-years\n    # OUTPUT:\n    # «{ False\n    # => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n    #    True => [2004-01-01 2008-01-01]}␤»\n\n\nThe function used to categorize can return an array indicating all possible\nbins their argument can be put into:\n\n    sub divisible-by( Int $n --> Array(Seq) ) {\n        gather {\n            for <2 3 5 7> {\n                take $_ if $n %% $_;\n            }\n        }\n    }\n\n    say (3..13).categorize( &divisible-by );\n    # OUTPUT:\n    # «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n\n\nIn this case, every number in the range is classified in as many bins as it\ncan be divided by.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"k":"m","m":1,"s":{"r":"Mu","p":["Whatever $","*%_"]},"d":"Defined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThe two first forms fail with an error message.\n\nIn its simplest form, it uses a $test whose result will be used as a key;\nthe values of the key will be an array of the elements that produced that\nkey as a result of the test.\n\n    say (1..13).categorize( * %% 3);\n    say categorize( * %% 3, 1..13)\n    # OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n\n\nThe :as argument will normalize before categorizing\n\n    say categorize( * %% 3, -5..5, as => &abs )\n    # OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n\n\nThe $into associative argument can be used to put the result instead of\nreturning a new Hash\n\n    my %leap-years;\n    my @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.categorize( *.is-leap-year , into => %leap-years );\n    say %leap-years\n    # OUTPUT:\n    # «{ False\n    # => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n    #    True => [2004-01-01 2008-01-01]}␤»\n\n\nThe function used to categorize can return an array indicating all possible\nbins their argument can be put into:\n\n    sub divisible-by( Int $n --> Array(Seq) ) {\n        gather {\n            for <2 3 5 7> {\n                take $_ if $n %% $_;\n            }\n        }\n    }\n\n    say (3..13).categorize( &divisible-by );\n    # OUTPUT:\n    # «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n\n\nIn this case, every number in the range is classified in as many bins as it\ncan be divided by.","n":"categorize"},{"n":"categorize","d":"Defined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThe two first forms fail with an error message.\n\nIn its simplest form, it uses a $test whose result will be used as a key;\nthe values of the key will be an array of the elements that produced that\nkey as a result of the test.\n\n    say (1..13).categorize( * %% 3);\n    say categorize( * %% 3, 1..13)\n    # OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n\n\nThe :as argument will normalize before categorizing\n\n    say categorize( * %% 3, -5..5, as => &abs )\n    # OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n\n\nThe $into associative argument can be used to put the result instead of\nreturning a new Hash\n\n    my %leap-years;\n    my @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.categorize( *.is-leap-year , into => %leap-years );\n    say %leap-years\n    # OUTPUT:\n    # «{ False\n    # => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n    #    True => [2004-01-01 2008-01-01]}␤»\n\n\nThe function used to categorize can return an array indicating all possible\nbins their argument can be put into:\n\n    sub divisible-by( Int $n --> Array(Seq) ) {\n        gather {\n            for <2 3 5 7> {\n                take $_ if $n %% $_;\n            }\n        }\n    }\n\n    say (3..13).categorize( &divisible-by );\n    # OUTPUT:\n    # «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n\n\nIn this case, every number in the range is classified in as many bins as it\ncan be divided by.","s":{"r":"Mu","p":["$test",":$into!",":&as","*%_"]},"k":"m","m":1},{"d":"Defined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThe two first forms fail with an error message.\n\nIn its simplest form, it uses a $test whose result will be used as a key;\nthe values of the key will be an array of the elements that produced that\nkey as a result of the test.\n\n    say (1..13).categorize( * %% 3);\n    say categorize( * %% 3, 1..13)\n    # OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n\n\nThe :as argument will normalize before categorizing\n\n    say categorize( * %% 3, -5..5, as => &abs )\n    # OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n\n\nThe $into associative argument can be used to put the result instead of\nreturning a new Hash\n\n    my %leap-years;\n    my @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.categorize( *.is-leap-year , into => %leap-years );\n    say %leap-years\n    # OUTPUT:\n    # «{ False\n    # => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n    #    True => [2004-01-01 2008-01-01]}␤»\n\n\nThe function used to categorize can return an array indicating all possible\nbins their argument can be put into:\n\n    sub divisible-by( Int $n --> Array(Seq) ) {\n        gather {\n            for <2 3 5 7> {\n                take $_ if $n %% $_;\n            }\n        }\n    }\n\n    say (3..13).categorize( &divisible-by );\n    # OUTPUT:\n    # «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n\n\nIn this case, every number in the range is classified in as many bins as it\ncan be divided by.","n":"categorize","k":"m","m":1,"s":{"r":"Mu","p":["$test",":&as","*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"reverse","d":"Defined as:\n\n    multi sub    reverse(*@list  --> Seq:D)\n    multi method reverse(List:D: --> Seq:D)\n\nReturns a Seq with the same elements in reverse order.\n\nNote that reverse always refers to reversing elements of a list; to reverse\nthe characters in a string, use flip.\n\nExamples:\n\n    say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\n    say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»"},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    method combinations(|c)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.combinations on it.\n\n    say (^3).combinations; # OUTPUT: «(() (0) (1) (2) (0 1) (0 2) (1 2) (0 1 2))␤»","n":"combinations"},{"n":"permutations","d":"Defined as:\n\n    method permutations(|c)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.permutations on it.\n\n    say <a b c>.permutations;\n    # OUTPUT: «((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»\n    say set(1,2).permutations;\n    # OUTPUT: «((2 => True 1 => True) (1 => True 2 => True))␤»","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"n":"join","d":"Defined as\n\n    method join($separator = '') is nodal\n\nConverts the object to a list by calling self.list, and calls .join on the\nlist. Can take a separator, which is an empty string by default.\n\n    (1..3).join.say;       # OUTPUT: «123␤»\n    <a b c>.join(\"❧\").put; # OUTPUT: «a❧b❧c␤»","s":{"p":["$separator = \"\"","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["&block","*%_"],"r":"Mu"},"m":0,"k":"m","n":"nodemap","d":"Defined as:\n\n    method nodemap(&block --> List) is nodal\n\nnodemap will apply &block to each element and return a new List with the\nreturn values of &block. In contrast to deepmap it will not descend\nrecursively into sublists if it finds elements which do the Iterable role.\n\n    say [[1,2,3], [[4,5],6,7], 7].nodemap(*+1);\n    # OUTPUT: «(4, 4, 8)␤»\n\n    say [[2, 3], [4, [5, 6]]]».nodemap(*+1)\n    # OUTPUT: «((3 4) (5 3))␤»\n\nThe examples above would have produced the exact same results if we had\nused map instead of nodemap. The difference between the two lies in the\nfact that map flattens out slips while nodemap doesn't.\n\n    say [[2,3], [[4,5],6,7], 7].nodemap({.elems == 1 ?? $_ !! slip});\n    # OUTPUT: «(() () 7)␤»\n    say [[2,3], [[4,5],6,7], 7].map({.elems == 1 ?? $_ !! slip});\n    # OUTPUT: «(7)␤»\n\nWhen applied to Associatives, it will act on the values:\n\n    { what => \"is\", this => \"thing\" }.nodemap( *.flip ).say;\n    # OUTPUT: «{this => gniht, what => si}␤»"},{"n":"duckmap","d":"Defined as:\n\n    method duckmap(&block) is rw is nodal\n\nduckmap will apply &block on each element that behaves in such a way that\n&block can be applied. If it fails, it will descend recursively if\npossible, or otherwise return the item without any transformation. It will\nact on values if the object is Associative.\n\n    <a b c d e f g>.duckmap(-> $_ where <c d e>.any { .uc }).say;\n    # OUTPUT: «(a b C D E f g)␤»\n    (('d', 'e'), 'f').duckmap(-> $_ where <e f>.any { .uc }).say;\n    # OUTPUT: «((d E) F)␤»\n    { first => ('d', 'e'), second => 'f'}.duckmap(-> $_ where <e f>.any { .uc }).say;\n    # OUTPUT: «{first => (d E), second => F}␤»\n\n\nIn the first case, it is applied to c, d and e which are the ones that meet\nthe conditions for the block ({ .uc }) to be applied; the rest are returned\nas is.\n\nIn the second case, the first item is a list that does not meet the\ncondition, so it's visited; that flat list will behave in the same way as\nthe first one. In this case:\n\n    say [[1,2,3],[[4,5],6,7]].duckmap( *² ); # OUTPUT: «[9 9]␤»\n\nYou can square anything as long as it behaves like a number. In this case,\nthere are two arrays with 3 elements each; these arrays will be converted\ninto the number 3 and squared. In the next case, however\n\n    say [[1,2,3],[[4,5],6.1,7.2]].duckmap( -> Rat $_ { $_²} );\n    # OUTPUT: «[[1 2 3] [[4 5] 37.21 51.84]]␤»\n\n3-item lists are not Rat, so it descends recursively, but eventually only\napplies the operation to those that walk (or slither, as the case may be)\nlike a Rat.\n\nAlthough on the surface (and name), duckmap might look similar to deepmap,\nthe latter is applied recursively regardless of the type of the item.","s":{"r":"Mu","p":["&block","*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["&block","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method deepmap(&block --> List) is nodal\n\ndeepmap will apply &block to each element and return a new List with the\nreturn values of &block, unless the element does the Iterable role. For\nthose elements deepmap will descend recursively into the sublist.\n\n    say [[1,2,3],[[4,5],6,7]].deepmap(* + 1);\n    # OUTPUT: «[[2 3 4] [[5 6] 7 8]]␤»\n\nIn the case of Associatives, it will be applied to its values:\n\n    { what => \"is\", this => \"thing\", a => <real list> }.deepmap( *.flip ).say\n    # OUTPUT: «{a => (laer tsil), this => gniht, what => si}␤»","n":"deepmap"},{"n":"tree","d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"tree","d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"k":"m","m":1,"s":{"r":"Mu","p":["Whatever $","*%_"]},"d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","n":"tree"},{"s":{"p":["Int(Cool) $count","*%_"],"r":"Mu"},"k":"m","m":1,"n":"tree","d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures."},{"m":1,"k":"m","s":{"p":["@ (&first, *@rest)","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","n":"tree"},{"n":"tree","d":"Defined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","s":{"r":"Mu","p":["&first","*@rest","*%_"]},"m":1,"k":"m"},{"n":"push","d":"Defined as:\n\n    method push(|values --> Positional:D)\n\nThe method push is defined for undefined invocants and allows for\nautovivifying undefined to an empty Array, unless the undefined value\nimplements Positional already. The argument provided will then be pushed\ninto the newly created Array.\n\n    my %h;\n    say %h<a>;     # OUTPUT: «(Any)␤»      <-- Undefined\n    %h<a>.push(1); # .push on Any\n    say %h;        # OUTPUT: «{a => [1]}␤» <-- Note the Array","s":{"p":["|values is raw"],"r":"Mu"},"m":1,"k":"m"},{"n":"append","d":"Defined as:\n\n    multi method append(Any:U \\SELF: |values --> Array)\n\nIn the case the instance is not a positional-thing, it instantiates it as a\nnew Array, otherwise clone the current instance. After that, it appends the\nvalues passed as arguments to the array obtained calling Array.append on\nit.\n\n    my $a;\n    say $a.append; # OUTPUT: «[]␤»\n    my $b;\n    say $b.append((1,2,3)); # OUTPUT: «[1 2 3]␤»","s":{"r":"Mu","p":["|values is raw"]},"k":"m","m":1},{"k":"m","m":1,"s":{"p":["|values is raw"],"r":"Mu"},"d":"Defined as:\n\n    multi method unshift(--> Array)\n    multi method unshift(@values --> Array)\n\nInitializes Any variable as empty Array and calls Array.unshift on it.\n\n    my $a;\n    say $a.unshift; # OUTPUT: «[]␤»\n    say $a;         # OUTPUT: «[]␤»\n    my $b;\n    say $b.unshift([1,2,3]); # OUTPUT: «[[1 2 3]]␤»","n":"unshift"},{"k":"m","m":1,"s":{"r":"Mu","p":["|values is raw"]},"d":"Defined as:\n\n    multi method prepend(--> Array)\n    multi method prepend(@values --> Array)\n\nCalled with no arguments on an empty variable, it initializes it as an\nempty Array; if called with arguments, it creates an array and then applies\nArray.prepend on it.\n\n    my $a;\n    say $a.prepend; # OUTPUT: «[]␤»\n    say $a;         # OUTPUT: «[]␤»\n    my $b;\n    say $b.prepend(1,2,3); # OUTPUT: «[1 2 3]␤»","n":"prepend"},{"s":{"p":["Any:D $","*%_"],"r":"Bool"},"m":1,"k":"m","n":"EXISTS-POS"},{"k":"m","m":1,"s":{"r":"Mu","p":["Any:U $pos","*%_"]},"n":"EXISTS-POS"},{"m":1,"k":"m","s":{"r":"Bool:D","p":["int \\pos","*%_"]},"n":"EXISTS-POS"},{"n":"EXISTS-POS","s":{"p":["Int:D \\pos","*%_"],"r":"Bool:D"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["Num:D \\pos","*%_"],"r":"Bool:D"},"n":"EXISTS-POS"},{"m":1,"k":"m","s":{"p":["Any:D \\pos","*%_"],"r":"Bool:D"},"n":"EXISTS-POS"},{"n":"EXISTS-POS","m":1,"k":"m","s":{"p":["Any:U \\pos","*%_"],"r":"Mu"}},{"s":{"p":["\\one","\\two","*%_"],"r":"Bool:D"},"k":"m","m":1,"n":"EXISTS-POS"},{"n":"EXISTS-POS","s":{"p":["\\one","\\two","\\three","*%_"],"r":"Bool:D"},"k":"m","m":1},{"n":"EXISTS-POS","s":{"r":"Bool:D","p":["**@indices","*%_"]},"m":1,"k":"m"},{"n":"AT-POS","s":{"p":["int \\pos","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"AT-POS","m":1,"k":"m","s":{"p":["Int:D \\pos","*%_"],"r":"Mu"}},{"n":"AT-POS","s":{"r":"Mu","p":["Num:D \\pos","*%_"]},"k":"m","m":1},{"n":"AT-POS","s":{"p":["Any:D \\pos","*%_"],"r":"Mu"},"m":1,"k":"m"},{"s":{"p":["int \\pos","*%_"],"r":"Mu"},"m":1,"k":"m","n":"AT-POS"},{"s":{"p":["Int:D \\pos","*%_"],"r":"Mu"},"m":1,"k":"m","n":"AT-POS"},{"n":"AT-POS","s":{"p":["Num:D \\pos","*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["Any:D \\pos","*%_"]},"n":"AT-POS"},{"k":"m","m":1,"s":{"r":"Mu","p":["Any:U \\pos","*%_"]},"n":"AT-POS"},{"n":"AT-POS","k":"m","m":1,"s":{"r":"Mu","p":["\\one","\\two","*%_"]}},{"s":{"r":"Mu","p":["\\one","\\two","\\three","*%_"]},"m":1,"k":"m","n":"AT-POS"},{"n":"AT-POS","s":{"p":["**@indices","*%_"],"r":"Mu"},"k":"m","m":1},{"k":"m","m":1,"s":{"p":["*%unexpected"],"r":"Mu"},"n":"ZEN-POS"},{"n":"ZEN-KEY","s":{"r":"Mu","p":["*%unexpected"]},"k":"m","m":1},{"n":"ASSIGN-POS","s":{"r":"Mu","p":["\\pos","Mu \\assignee","*%_"]},"k":"m","m":1},{"n":"ASSIGN-POS","s":{"r":"Mu","p":["int \\pos","Mu \\assignee","*%_"]},"m":1,"k":"m"},{"n":"ASSIGN-POS","s":{"p":["Int:D \\pos","Mu \\assignee","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"ASSIGN-POS","k":"m","m":1,"s":{"r":"Mu","p":["Num:D \\pos","Mu \\assignee","*%_"]}},{"n":"ASSIGN-POS","s":{"r":"Mu","p":["Any:D \\pos","Mu \\assignee","*%_"]},"k":"m","m":1},{"n":"ASSIGN-POS","s":{"r":"Mu","p":["Any:U \\pos","Mu \\assignee","*%_"]},"k":"m","m":1},{"k":"m","m":1,"s":{"p":["\\one","\\two","Mu \\assignee","*%_"],"r":"Mu"},"n":"ASSIGN-POS"},{"n":"ASSIGN-POS","s":{"r":"Mu","p":["\\one","\\two","\\three","Mu \\assignee","*%_"]},"m":1,"k":"m"},{"n":"ASSIGN-POS","m":1,"k":"m","s":{"p":["**@indices","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["**@indices is raw","*%_"]},"m":1,"k":"m","n":"BIND-POS"},{"n":"all","d":"Defined as:\n\n    method all(--> Junction:D)\n\nInterprets the invocant as a list and creates an all-Junction from it.\n\n    say so 1 < <2 3 4>.all;         # OUTPUT: «True␤»\n    say so 3 < <2 3 4>.all;         # OUTPUT: «False␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"any","d":"Defined as:\n\n    method any(--> Junction:D)\n\nInterprets the invocant as a list and creates an any-Junction from it.\n\n    say so 2 == <1 2 3>.any;        # OUTPUT: «True␤»\n    say so 5 == <1 2 3>.any;        # OUTPUT: «False␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method one(--> Junction:D)\n\nInterprets the invocant as a list and creates a one-Junction from it.\n\n    say so 1 == (1, 2, 3).one;      # OUTPUT: «True␤»\n    say so 1 == (1, 2, 1).one;      # OUTPUT: «False␤»","n":"one"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"none","d":"Defined as:\n\n    method none(--> Junction:D)\n\nInterprets the invocant as a list and creates a none-Junction from it.\n\n    say so 1 == (1, 2, 3).none;     # OUTPUT: «False␤»\n    say so 4 == (1, 2, 3).none;     # OUTPUT: «True␤»"},{"s":{"r":"Mu","p":["$key","*%_"]},"m":1,"k":"m","n":"AT-KEY"},{"n":"AT-KEY","s":{"p":["\\key","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"BIND-KEY","s":{"r":"Mu","p":["\\k","\\v","*%_"]},"m":1,"k":"m"},{"n":"BIND-KEY","m":1,"k":"m","s":{"r":"Mu","p":["$key","$BIND","*%_"]}},{"k":"m","m":1,"s":{"p":["\\key","Mu \\assignee","*%_"],"r":"Mu"},"n":"ASSIGN-KEY"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"FLATTENABLE_LIST"},{"n":"FLATTENABLE_HASH","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":1,"k":"m","s":{"r":"Set:D","p":["*%_"]},"d":"Defined as:\n\n    method Set(--> Set:D) is nodal\n\nCoerces the invocant to Set, whereby Positionals are treated as lists of\nvalues.","n":"Set"},{"s":{"r":"SetHash:D","p":["*%_"]},"k":"m","m":1,"n":"SetHash","d":"Defined as:\n\n    method SetHash(--> SetHash:D) is nodal\n\nCoerces the invocant to SetHash, whereby Positionals are treated as lists\nof values."},{"s":{"r":"Bag:D","p":["*%_"]},"k":"m","m":1,"n":"Bag","d":"Defined as:\n\n    method Bag(--> Bag:D) is nodal\n\nCoerces the invocant to Bag, whereby Positionals are treated as lists of\nvalues."},{"d":"Defined as:\n\n    method BagHash(--> BagHash:D) is nodal\n\nCoerces the invocant to BagHash, whereby Positionals are treated as lists\nof values.","n":"BagHash","k":"m","m":1,"s":{"r":"BagHash:D","p":["*%_"]}},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mix:D"},"d":"Defined as:\n\n    method Mix(--> Mix:D) is nodal\n\nCoerces the invocant to Mix, whereby Positionals are treated as lists of\nvalues.","n":"Mix"},{"d":"Defined as:\n\n    method MixHash(--> MixHash:D) is nodal\n\nCoerces the invocant to MixHash, whereby Positionals are treated as lists\nof values.","n":"MixHash","m":1,"k":"m","s":{"r":"MixHash:D","p":["*%_"]}},{"d":"Defined as:\n\n    method Supply(--> Supply:D) is nodal\n\nFirst, it coerces the invocant to a list by applying its .list method, and\nthen to a Supply.","n":"Supply","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method nl-out(--> Str)\n\nReturns Str with the value of \"\\n\". See IO::Handle.nl-out for the details.\n\n    Num.nl-out.print;     # OUTPUT: «␤»\n    Whatever.nl-out.print;# OUTPUT: «␤»\n    33.nl-out.print;      # OUTPUT: «␤»","n":"nl-out","k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"print-nl"},{"n":"lazy-if","s":{"r":"Mu","p":["$flag","*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method sum() is nodal\n\nIf the content is iterable, it returns the sum of the values after pulling\nthem one by one.\n\n    (3,2,1).sum; # OUTPUT: «6␤»\n    say 3.sum;   # OUTPUT: «3␤»\n\n\nIt will fail if any of the elements cannot be converted to a number.","n":"sum","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["Hash:D \\hash","*%_"]},"m":1,"k":"m","n":"map","d":"Defined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nmap will iterate over the invocant and apply the number of positional\nparameters of the code object from the invocant per call. The returned\nvalues of the code object will become elements of the returned Seq.\n\nThe :$label and :$item are useful only internally, since for loops get\nconverted to maps. The :$label takes an existing Label to label the .map's\nloop with and :$item controls whether the iteration will occur over (SELF,)\n(if :$item is set) or SELF.\n\nIn sub form, will apply the code block to the values, which will be used as\ninvocant.\n\nThe form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will\nfail with X::Cannot::Map, and are mainly meant to catch common traps."},{"n":"map","d":"Defined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nmap will iterate over the invocant and apply the number of positional\nparameters of the code object from the invocant per call. The returned\nvalues of the code object will become elements of the returned Seq.\n\nThe :$label and :$item are useful only internally, since for loops get\nconverted to maps. The :$label takes an existing Label to label the .map's\nloop with and :$item controls whether the iteration will occur over (SELF,)\n(if :$item is set) or SELF.\n\nIn sub form, will apply the code block to the values, which will be used as\ninvocant.\n\nThe form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will\nfail with X::Cannot::Map, and are mainly meant to catch common traps.","s":{"p":["Iterable:D \\iterable","*%_"],"r":"Mu"},"m":1,"k":"m"},{"d":"Defined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nmap will iterate over the invocant and apply the number of positional\nparameters of the code object from the invocant per call. The returned\nvalues of the code object will become elements of the returned Seq.\n\nThe :$label and :$item are useful only internally, since for loops get\nconverted to maps. The :$label takes an existing Label to label the .map's\nloop with and :$item controls whether the iteration will occur over (SELF,)\n(if :$item is set) or SELF.\n\nIn sub form, will apply the code block to the values, which will be used as\ninvocant.\n\nThe form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will\nfail with X::Cannot::Map, and are mainly meant to catch common traps.","n":"map","k":"m","m":1,"s":{"r":"Mu","p":["|c is raw"]}},{"s":{"r":"Mu","p":["&block",":$label",":$item","*%_"]},"m":1,"k":"m","n":"map","d":"Defined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nmap will iterate over the invocant and apply the number of positional\nparameters of the code object from the invocant per call. The returned\nvalues of the code object will become elements of the returned Seq.\n\nThe :$label and :$item are useful only internally, since for loops get\nconverted to maps. The :$label takes an existing Label to label the .map's\nloop with and :$item controls whether the iteration will occur over (SELF,)\n(if :$item is set) or SELF.\n\nIn sub form, will apply the code block to the values, which will be used as\ninvocant.\n\nThe form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will\nfail with X::Cannot::Map, and are mainly meant to catch common traps."},{"k":"m","m":1,"s":{"r":"Mu","p":["&block",":$label","*%_"]},"d":"Defined as:\n\n    method flatmap(&block, :$label)\n\nDEPRECATION NOTICE: This method is deprecated in 6.d and will be removed in\n6.e. Use .map followed by .flat instead.\n\nApplies map to every element with the block and Label used as an argument\nand flattens out the result using .flat.\n\n    say \"aabbccc\".comb.Mix.flatmap: \"→ \" ~ *; # OUTPUT: «(→ b␉2 → c␉3 → a␉2)␤»\n\nIn this case, the elements of the Mix are itemized to key␉value, and then\nmapped and flattened. Same result as\n\n    say \"aabbccc\".comb.Mix.map( \"→ \" ~ * ).flat\n\nWhich is why it is deprecated in 6.d and will be eventually eliminated in\n6.e.","n":"flatmap"},{"n":"grep","d":"Defined as:\n\n    method grep(Mu $matcher, :$k, :$kv, :$p, :$v --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.grep on it.\n\nBased on $matcher value can be either ((Any)) or empty List.\n\n    my $a;\n    say $a.grep({ True }); # OUTPUT: «((Any))␤»\n    say $a.grep({ $_ });   # OUTPUT: «()␤»","s":{"p":["Bool:D $t","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"grep","d":"Defined as:\n\n    method grep(Mu $matcher, :$k, :$kv, :$p, :$v --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.grep on it.\n\nBased on $matcher value can be either ((Any)) or empty List.\n\n    my $a;\n    say $a.grep({ True }); # OUTPUT: «((Any))␤»\n    say $a.grep({ $_ });   # OUTPUT: «()␤»","s":{"r":"Mu","p":["Mu $t","*%_"]},"m":1,"k":"m"},{"k":"m","m":1,"s":{"p":["Bool:D $t","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»","n":"first"},{"s":{"p":["Regex:D $test",":$end","*%a"],"r":"Mu"},"k":"m","m":1,"n":"first","d":"Defined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»"},{"k":"m","m":1,"s":{"p":["Callable:D $test",":$end","*%a is copy"],"r":"Mu"},"d":"Defined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»","n":"first"},{"m":1,"k":"m","s":{"p":["Mu $test",":$end","*%a"],"r":"Mu"},"d":"Defined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»","n":"first"},{"n":"first","d":"Defined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»","s":{"r":"Mu","p":[":$end","*%a"]},"m":1,"k":"m"},{"d":"Defined as:\n\n    multi method min()\n    multi method min(&by)\n    multi sub min(+args, :&by!)\n    multi sub min(+args)\n\nCoerces the invocant to Iterable and returns the numerically smallest\nelement; in the case of Hashes, it returns the Pair with the lowest value.\nIn sub form, the invocant is passed as an argument.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original value is still the one returned from min.\n\n    say (1,7,3).min();              # OUTPUT:«1␤»\n    say (1,7,3).min({1/$_});        # OUTPUT:«7␤»\n    say min(1,7,3);                 # OUTPUT: «1␤»\n    say min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\n    min( %(a => 3, b=> 7 ) ).say ;  # OUTPUT: «a => 3␤»","n":"min","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["&by","*%_"]},"m":1,"k":"m","n":"min","d":"Defined as:\n\n    multi method min()\n    multi method min(&by)\n    multi sub min(+args, :&by!)\n    multi sub min(+args)\n\nCoerces the invocant to Iterable and returns the numerically smallest\nelement; in the case of Hashes, it returns the Pair with the lowest value.\nIn sub form, the invocant is passed as an argument.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original value is still the one returned from min.\n\n    say (1,7,3).min();              # OUTPUT:«1␤»\n    say (1,7,3).min({1/$_});        # OUTPUT:«7␤»\n    say min(1,7,3);                 # OUTPUT: «1␤»\n    say min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\n    min( %(a => 3, b=> 7 ) ).say ;  # OUTPUT: «a => 3␤»"},{"d":"Defined as:\n\n    multi method max()\n    multi method max(&by)\n    multi sub max(+args, :&by!)\n    multi sub max(+args)\n\nCoerces the invocant to Iterable and returns the numerically largest\nelement; in the case of Hashes, the Pair with the highest value.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and the return value is compared instead of the original value.\nThe original value is still the one returned from max.\n\n    say (1,7,3).max();                # OUTPUT:«7␤»\n    say (1,7,3).max({1/$_});          # OUTPUT:«1␤»\n    say max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\n    say max(1,7,3);                   # OUTPUT: «7␤»\n    max( %(a => 'B', b=> 'C' ) ).say; # OUTPUT: «b => C␤»","n":"max","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["&by","*%_"],"r":"Mu"},"m":1,"k":"m","n":"max","d":"Defined as:\n\n    multi method max()\n    multi method max(&by)\n    multi sub max(+args, :&by!)\n    multi sub max(+args)\n\nCoerces the invocant to Iterable and returns the numerically largest\nelement; in the case of Hashes, the Pair with the highest value.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and the return value is compared instead of the original value.\nThe original value is still the one returned from max.\n\n    say (1,7,3).max();                # OUTPUT:«7␤»\n    say (1,7,3).max({1/$_});          # OUTPUT:«1␤»\n    say max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\n    say max(1,7,3);                   # OUTPUT: «7␤»\n    max( %(a => 'B', b=> 'C' ) ).say; # OUTPUT: «b => C␤»"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"minmax","d":"Defined as:\n\n    multi method minmax()\n    multi method minmax(&by)\n    multi sub minmax(+args, :&by!)\n    multi sub minmax(+args)\n\nReturns a Range from the smallest to the largest element.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original values are still used in the returned Range.\n\n    say (1,7,3).minmax();        # OUTPUT:«1..7␤»\n    say (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\n    say minmax(1,7,3);           # OUTPUT: «1..7␤»\n    say minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»"},{"m":1,"k":"m","s":{"p":["&by","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method minmax()\n    multi method minmax(&by)\n    multi sub minmax(+args, :&by!)\n    multi sub minmax(+args)\n\nReturns a Range from the smallest to the largest element.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original values are still used in the returned Range.\n\n    say (1,7,3).minmax();        # OUTPUT:«1..7␤»\n    say (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\n    say minmax(1,7,3);           # OUTPUT: «1..7␤»\n    say minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»","n":"minmax"},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method sort()\n    multi method sort(&custom-routine-to-use)\n\nSorts iterables with cmp or given code object and returns a new Seq.\nOptionally, takes a Callable as a positional parameter, specifying how to\nsort.\n\nExamples:\n\n    say <b c a>.sort;                           # OUTPUT: «(a b c)␤»\n    say 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\n    say 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\n    say '231'.comb.sort(&infix:«<=>»).join;     # OUTPUT: «123␤»","n":"sort"},{"m":1,"k":"m","s":{"p":["&by","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method sort()\n    multi method sort(&custom-routine-to-use)\n\nSorts iterables with cmp or given code object and returns a new Seq.\nOptionally, takes a Callable as a positional parameter, specifying how to\nsort.\n\nExamples:\n\n    say <b c a>.sort;                           # OUTPUT: «(a b c)␤»\n    say 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\n    say 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\n    say '231'.comb.sort(&infix:«<=>»).join;     # OUTPUT: «123␤»","n":"sort"},{"d":"Defined as:\n\n    method collate()\n\nCollate sorts taking into account Unicode grapheme characteristics; that\nis, sorting more or less as one would expect instead of using the order in\nwhich their codepoints appear. collate will behave this way if the object\nit is applied to is Iterable.\n\n    say ('a', 'Z').sort; # (Z a)\n    say ('a', 'Z').collate; # (a Z)\n    say <ä a o ö>.collate; # (a ä o ö)\n    my %hash = 'aa' => 'value', 'Za' => 'second';\n    say %hash.collate; # (aa => value Za => second);\n\n\nThis method is affected by the $*COLLATION variable, which configures the\nfour collation levels. While the Primary, Secondary and Tertiary mean\ndifferent things for different scripts, for the Latin script used in\nEnglish they mostly correspond with Primary being Alphabetic, Secondary\nbeing Diacritics and Tertiary being Case.\n\nIn the example below you can see how when we disable tertiary collation\nwhich in Latin script generally is for case, and also disable quaternary\nwhich breaks any ties by checking the codepoint values of the strings, we\nget Same back for A and a:\n\n    $*COLLATION.set(:quaternary(False), :tertiary(False));\n    say 'a' coll 'A'; #OUTPUT: «Same␤»\n    say ('a','A').collate == ('A','a').collate; # OUTPUT: «True␤»\n\nThe variable affects the coll operator as shown as well as this method.","n":"collate","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Nil","p":["&","*%_"]},"d":"Defined as:\n\n    multi method reduce(Any:U: & --> Nil)\n    multi method reduce(Any:D: &with)\n    multi sub reduce (&with, +list)\n\nApplying it to a class will always produce Nil. Applies its argument (or\nfirst argument, in case it's a sub) as an operator to all the elements in\nthe object (or second argument), producing a single result. The argument\nmust be an infix operator or take, in any case, two positional arguments.\n\n    (1..13).reduce( &[*] ).say; # OUTPUT: «6227020800␤»","n":"reduce"},{"s":{"r":"Mu","p":["&with","*%_"]},"m":1,"k":"m","n":"reduce","d":"Defined as:\n\n    multi method reduce(Any:U: & --> Nil)\n    multi method reduce(Any:D: &with)\n    multi sub reduce (&with, +list)\n\nApplying it to a class will always produce Nil. Applies its argument (or\nfirst argument, in case it's a sub) as an operator to all the elements in\nthe object (or second argument), producing a single result. The argument\nmust be an infix operator or take, in any case, two positional arguments.\n\n    (1..13).reduce( &[*] ).say; # OUTPUT: «6227020800␤»"},{"n":"produce","d":"Defined as:\n\n    multi method produce(Any:U: & --> Nil)\n    multi method produce(Any:D: &with)\n    multi sub produce (&with, +list)\n\nThis is similar to reduce, but returns a list with the accumulated values\ninstead of a single result.\n\n    <10 5 3>.reduce( &[*] ).say ; # OUTPUT: «150␤»\n    <10 5 3>.produce( &[*] ).say; # OUTPUT: «(10 50 150)␤»\n\n\nThe last element of the produced list would be the output produced by the\n.reduce method.\n\nIf it's a class, it will simply return Nil.","s":{"r":"Nil","p":["&","*%_"]},"k":"m","m":1},{"d":"Defined as:\n\n    multi method produce(Any:U: & --> Nil)\n    multi method produce(Any:D: &with)\n    multi sub produce (&with, +list)\n\nThis is similar to reduce, but returns a list with the accumulated values\ninstead of a single result.\n\n    <10 5 3>.reduce( &[*] ).say ; # OUTPUT: «150␤»\n    <10 5 3>.produce( &[*] ).say; # OUTPUT: «(10 50 150)␤»\n\n\nThe last element of the produced list would be the output produced by the\n.reduce method.\n\nIf it's a class, it will simply return Nil.","n":"produce","m":1,"k":"m","s":{"r":"Mu","p":["&with","*%_"]}},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method unique()\n    multi method unique( :&as!, :&with! )\n    multi method unique( :&as! )\n    multi method unique( :&with! )\n\nCreates a sequence of unique elements either of the object or of values in\nthe case it's called as a sub.\n\n    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\n    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»\n\nThe :as and :with parameters receive functions that are used for\ntransforming the item before checking equality, and for checking equality,\nsince by default the === operator is used:\n\n    (\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»\n\nPlease see unique for additional examples that use its sub form.","n":"unique"},{"d":"Defined as:\n\n    multi method unique()\n    multi method unique( :&as!, :&with! )\n    multi method unique( :&as! )\n    multi method unique( :&with! )\n\nCreates a sequence of unique elements either of the object or of values in\nthe case it's called as a sub.\n\n    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\n    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»\n\nThe :as and :with parameters receive functions that are used for\ntransforming the item before checking equality, and for checking equality,\nsince by default the === operator is used:\n\n    (\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»\n\nPlease see unique for additional examples that use its sub form.","n":"unique","m":1,"k":"m","s":{"p":[":&as!",":&with!","*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"r":"Mu","p":[":&as!","*%_"]},"d":"Defined as:\n\n    multi method unique()\n    multi method unique( :&as!, :&with! )\n    multi method unique( :&as! )\n    multi method unique( :&with! )\n\nCreates a sequence of unique elements either of the object or of values in\nthe case it's called as a sub.\n\n    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\n    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»\n\nThe :as and :with parameters receive functions that are used for\ntransforming the item before checking equality, and for checking equality,\nsince by default the === operator is used:\n\n    (\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»\n\nPlease see unique for additional examples that use its sub form.","n":"unique"},{"d":"Defined as:\n\n    multi method unique()\n    multi method unique( :&as!, :&with! )\n    multi method unique( :&as! )\n    multi method unique( :&with! )\n\nCreates a sequence of unique elements either of the object or of values in\nthe case it's called as a sub.\n\n    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\n    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»\n\nThe :as and :with parameters receive functions that are used for\ntransforming the item before checking equality, and for checking equality,\nsince by default the === operator is used:\n\n    (\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»\n\nPlease see unique for additional examples that use its sub form.","n":"unique","m":1,"k":"m","s":{"p":[":&with!","*%_"],"r":"Mu"}},{"n":"repeated","d":"Defined as:\n\n    multi method repeated()\n    multi method repeated( :&as!, :&with! )\n    multi method repeated( :&as! )\n    multi method repeated( :&with! )\n\nSimilarly to unique, finds repeated elements in values (as a routine) or in\nthe object, using the :as associative argument as a normalizing function\nand :with as equality function.\n\n    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»\n\nIt returns the last repeated element before normalization, as shown in the\nexample above. See repeated for more examples that use its sub form.","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":[":&as!",":&with!","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method repeated()\n    multi method repeated( :&as!, :&with! )\n    multi method repeated( :&as! )\n    multi method repeated( :&with! )\n\nSimilarly to unique, finds repeated elements in values (as a routine) or in\nthe object, using the :as associative argument as a normalizing function\nand :with as equality function.\n\n    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»\n\nIt returns the last repeated element before normalization, as shown in the\nexample above. See repeated for more examples that use its sub form.","n":"repeated"},{"d":"Defined as:\n\n    multi method repeated()\n    multi method repeated( :&as!, :&with! )\n    multi method repeated( :&as! )\n    multi method repeated( :&with! )\n\nSimilarly to unique, finds repeated elements in values (as a routine) or in\nthe object, using the :as associative argument as a normalizing function\nand :with as equality function.\n\n    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»\n\nIt returns the last repeated element before normalization, as shown in the\nexample above. See repeated for more examples that use its sub form.","n":"repeated","m":1,"k":"m","s":{"r":"Mu","p":[":&as!","*%_"]}},{"n":"repeated","d":"Defined as:\n\n    multi method repeated()\n    multi method repeated( :&as!, :&with! )\n    multi method repeated( :&as! )\n    multi method repeated( :&with! )\n\nSimilarly to unique, finds repeated elements in values (as a routine) or in\nthe object, using the :as associative argument as a normalizing function\nand :with as equality function.\n\n    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»\n\nIt returns the last repeated element before normalization, as shown in the\nexample above. See repeated for more examples that use its sub form.","s":{"p":[":&with!","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"squish","d":"Defined as:\n\n    multi method squish( :&as!, :&with = &[===] )\n    multi method squish( :&with = &[===] )\n\nSimilar to .repeated, returns the sequence of first elements of contiguous\nsequences of equal elements, after normalization by the function :as, if\npresent, and using as an equality operator the :with argument or === by\ndefault.\n\n    \"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n    \"aABbccdDaa\".comb.squish( :as(&lc) ).say; # OUTPUT: «(a B c d a)␤»\n    (3+2i,3+3i,4+0i).squish( as => *.re, with => &[==]).put; #OUTPUT: «3+2i 4+0i␤»\n\n\nAs shown in the last example, a sequence can contain a single element. See\nsquish for additional sub examples.","s":{"r":"Mu","p":[":&as!",":&with = { ... }","*%_"]},"k":"m","m":1},{"s":{"p":[":&with = { ... }","*%_"],"r":"Mu"},"k":"m","m":1,"n":"squish","d":"Defined as:\n\n    multi method squish( :&as!, :&with = &[===] )\n    multi method squish( :&with = &[===] )\n\nSimilar to .repeated, returns the sequence of first elements of contiguous\nsequences of equal elements, after normalization by the function :as, if\npresent, and using as an equality operator the :with argument or === by\ndefault.\n\n    \"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n    \"aABbccdDaa\".comb.squish( :as(&lc) ).say; # OUTPUT: «(a B c d a)␤»\n    (3+2i,3+3i,4+0i).squish( as => *.re, with => &[==]).put; #OUTPUT: «3+2i 4+0i␤»\n\n\nAs shown in the last example, a sequence can contain a single element. See\nsquish for additional sub examples."},{"n":"pairup","d":"Defined as:\n\n    multi method pairup(Any:U:)\n    multi method pairup(Any:D:)\n\nReturns an empty Seq if the invocant is a type object\n\n    Range.pairup.say; # OUTPUT: «()␤»\n\nInterprets the invocant as a list, and constructs a list of pairs from it,\nin the same way that assignment to a Hash does. That is, it takes two\nconsecutive elements and constructs a pair from them, unless the item in\nthe key position already is a pair (in which case the pair is passed\nthrough, and the next list item, if any, is considered to be a key again).\nIt returns a Seq of Pairs.\n\n    say (a => 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»\n\n  sub item\n\nDefined as:\n\n    multi item(\\x)\n    multi item(|c)\n    multi item(Mu $a)\n\nForces given object to be evaluated in item context and returns the value\nof it.\n\n    say item([1,2,3]).perl;              # OUTPUT: «$[1, 2, 3]␤»\n    say item( %( apple => 10 ) ).perl;   # OUTPUT: «${:apple(10)}␤»\n    say item(\"abc\").perl;                # OUTPUT: «\"abc\"␤»\n\nYou can also use $ as item contextualizer.\n\n    say $[1,2,3].perl;                   # OUTPUT: «$[1, 2, 3]␤»\n    say $(\"abc\").perl;                   # OUTPUT: «\"abc\"␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"d":"Defined as:\n\n    multi method pairup(Any:U:)\n    multi method pairup(Any:D:)\n\nReturns an empty Seq if the invocant is a type object\n\n    Range.pairup.say; # OUTPUT: «()␤»\n\nInterprets the invocant as a list, and constructs a list of pairs from it,\nin the same way that assignment to a Hash does. That is, it takes two\nconsecutive elements and constructs a pair from them, unless the item in\nthe key position already is a pair (in which case the pair is passed\nthrough, and the next list item, if any, is considered to be a key again).\nIt returns a Seq of Pairs.\n\n    say (a => 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»\n\n  sub item\n\nDefined as:\n\n    multi item(\\x)\n    multi item(|c)\n    multi item(Mu $a)\n\nForces given object to be evaluated in item context and returns the value\nof it.\n\n    say item([1,2,3]).perl;              # OUTPUT: «$[1, 2, 3]␤»\n    say item( %( apple => 10 ) ).perl;   # OUTPUT: «${:apple(10)}␤»\n    say item(\"abc\").perl;                # OUTPUT: «\"abc\"␤»\n\nYou can also use $ as item contextualizer.\n\n    say $[1,2,3].perl;                   # OUTPUT: «$[1, 2, 3]␤»\n    say $(\"abc\").perl;                   # OUTPUT: «\"abc\"␤»","n":"pairup","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)\n\nIterates over the invocant, producing a Seq, toggling whether the received\nvalues are propagated to the result on and off, depending on the results of\ncalling Callables in @conditions:\n\n    say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\n    say (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n\n\nImagine a switch that's either on or off (True or False), and values are\nproduced if it's on. By default, the initial state of that switch is in\n\"on\" position, unless :$off is set to a true value, in which case the\ninitial state will be \"off\".\n\nA Callable from the head of @conditions is taken (if any are available) and\nit becomes the current tester. Each value from the original sequence is\ntested by calling the tester Callable with that value. The state of our\nimaginary switch is set to the return value from the tester: if it's\ntruthy, set switch to \"on\", otherwise set it to \"off\".\n\nWhenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from\n\"on\" to \"off\"), the current tester Callable is replaced by the next\nCallable in @conditions, if available, which will be used to test any\nfurther values. If no more tester Callables are available, the switch will\nremain in its current state until the end of iteration.\n\n    # our original sequence of elements:\n    say list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n    # toggled result:\n    say ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n    # First tester Callable is `* < 4` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 < 4 === True  switch is on, value gets into result, switch is\n    #                      toggled, so we keep using the same Callable:\n    # 1 => 1 < 4 === True  same\n    # 2 => 2 < 4 === True  same\n    # 3 => 3 < 4 === True  same\n    # 4 => 4 < 4 === False switch is now off, \"4\" does not make it into the\n    #                      result. In addition, our switch got toggled, so\n    #                      we're switching to the next tester Callable\n    # 5 => 5 %% 2 === False  switch is still off, keep trying to find a value\n    # 6 => 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n    #                        toggled, so we'll use the next tester Callable\n    # 7 => is-prime(7) === True  switch is still on, take value and keep going\n    # 8 => is-prime(8) === False switch is now off, \"8\" does not make it into\n    #                            the result. The switch got toggled, but we\n    #                            don't have any more tester Callables, so it\n    #                            will remain off for the rest of the sequence.\n\n\nSince the toggle of the switch's state loads the next tester Callable,\nsetting :$off to a True value affects when first tester is discarded:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                      In addition, switch got toggled, so we change the\n    #                      tester Callable, and since we don't have any more\n    #                      of them, the switch will remain \"off\" until the end\n\n\nThe behavior changes when :off is used:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"off\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                       The switch did NOT get toggled this time, so we\n    #                       keep using our current tester Callable\n    # 1 => 1 > 1 === False  same\n    # 2 => 2 > 1 === True   switch is on, \"2\" makes it into the result","n":"toggle","m":1,"k":"m","s":{"r":"Mu","p":["Callable:D \\condition",":$off!","*%_"]}},{"s":{"r":"Mu","p":["Callable:D \\condition","*%_"]},"k":"m","m":1,"n":"toggle","d":"Defined as:\n\n    method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)\n\nIterates over the invocant, producing a Seq, toggling whether the received\nvalues are propagated to the result on and off, depending on the results of\ncalling Callables in @conditions:\n\n    say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\n    say (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n\n\nImagine a switch that's either on or off (True or False), and values are\nproduced if it's on. By default, the initial state of that switch is in\n\"on\" position, unless :$off is set to a true value, in which case the\ninitial state will be \"off\".\n\nA Callable from the head of @conditions is taken (if any are available) and\nit becomes the current tester. Each value from the original sequence is\ntested by calling the tester Callable with that value. The state of our\nimaginary switch is set to the return value from the tester: if it's\ntruthy, set switch to \"on\", otherwise set it to \"off\".\n\nWhenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from\n\"on\" to \"off\"), the current tester Callable is replaced by the next\nCallable in @conditions, if available, which will be used to test any\nfurther values. If no more tester Callables are available, the switch will\nremain in its current state until the end of iteration.\n\n    # our original sequence of elements:\n    say list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n    # toggled result:\n    say ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n    # First tester Callable is `* < 4` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 < 4 === True  switch is on, value gets into result, switch is\n    #                      toggled, so we keep using the same Callable:\n    # 1 => 1 < 4 === True  same\n    # 2 => 2 < 4 === True  same\n    # 3 => 3 < 4 === True  same\n    # 4 => 4 < 4 === False switch is now off, \"4\" does not make it into the\n    #                      result. In addition, our switch got toggled, so\n    #                      we're switching to the next tester Callable\n    # 5 => 5 %% 2 === False  switch is still off, keep trying to find a value\n    # 6 => 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n    #                        toggled, so we'll use the next tester Callable\n    # 7 => is-prime(7) === True  switch is still on, take value and keep going\n    # 8 => is-prime(8) === False switch is now off, \"8\" does not make it into\n    #                            the result. The switch got toggled, but we\n    #                            don't have any more tester Callables, so it\n    #                            will remain off for the rest of the sequence.\n\n\nSince the toggle of the switch's state loads the next tester Callable,\nsetting :$off to a True value affects when first tester is discarded:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                      In addition, switch got toggled, so we change the\n    #                      tester Callable, and since we don't have any more\n    #                      of them, the switch will remain \"off\" until the end\n\n\nThe behavior changes when :off is used:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"off\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                       The switch did NOT get toggled this time, so we\n    #                       keep using our current tester Callable\n    # 1 => 1 > 1 === False  same\n    # 2 => 2 > 1 === True   switch is on, \"2\" makes it into the result"},{"s":{"p":["*@conditions",":$off","*%_"],"r":"Mu"},"k":"m","m":1,"n":"toggle","d":"Defined as:\n\n    method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)\n\nIterates over the invocant, producing a Seq, toggling whether the received\nvalues are propagated to the result on and off, depending on the results of\ncalling Callables in @conditions:\n\n    say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\n    say (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n\n\nImagine a switch that's either on or off (True or False), and values are\nproduced if it's on. By default, the initial state of that switch is in\n\"on\" position, unless :$off is set to a true value, in which case the\ninitial state will be \"off\".\n\nA Callable from the head of @conditions is taken (if any are available) and\nit becomes the current tester. Each value from the original sequence is\ntested by calling the tester Callable with that value. The state of our\nimaginary switch is set to the return value from the tester: if it's\ntruthy, set switch to \"on\", otherwise set it to \"off\".\n\nWhenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from\n\"on\" to \"off\"), the current tester Callable is replaced by the next\nCallable in @conditions, if available, which will be used to test any\nfurther values. If no more tester Callables are available, the switch will\nremain in its current state until the end of iteration.\n\n    # our original sequence of elements:\n    say list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n    # toggled result:\n    say ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n    # First tester Callable is `* < 4` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 < 4 === True  switch is on, value gets into result, switch is\n    #                      toggled, so we keep using the same Callable:\n    # 1 => 1 < 4 === True  same\n    # 2 => 2 < 4 === True  same\n    # 3 => 3 < 4 === True  same\n    # 4 => 4 < 4 === False switch is now off, \"4\" does not make it into the\n    #                      result. In addition, our switch got toggled, so\n    #                      we're switching to the next tester Callable\n    # 5 => 5 %% 2 === False  switch is still off, keep trying to find a value\n    # 6 => 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n    #                        toggled, so we'll use the next tester Callable\n    # 7 => is-prime(7) === True  switch is still on, take value and keep going\n    # 8 => is-prime(8) === False switch is now off, \"8\" does not make it into\n    #                            the result. The switch got toggled, but we\n    #                            don't have any more tester Callables, so it\n    #                            will remain off for the rest of the sequence.\n\n\nSince the toggle of the switch's state loads the next tester Callable,\nsetting :$off to a True value affects when first tester is discarded:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                      In addition, switch got toggled, so we change the\n    #                      tester Callable, and since we don't have any more\n    #                      of them, the switch will remain \"off\" until the end\n\n\nThe behavior changes when :off is used:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"off\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                       The switch did NOT get toggled this time, so we\n    #                       keep using our current tester Callable\n    # 1 => 1 > 1 === False  same\n    # 2 => 2 > 1 === True   switch is on, \"2\" makes it into the result"},{"d":"Defined as:\n\n    multi method head(Any:D:) is raw\n    multi method head(Any:D: Callable:D $w)\n    multi method head(Any:D: $n)\n\nReturns either the first element in the object, or the first $n if that's\nused.\n\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\n    say ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\n    say ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\n    say ^10 .head;              # OUTPUT: «0␤»\n    say ^∞ .head;               # OUTPUT: «0␤»\n\nIn the first two cases, the results are different since there's no defined\norder in Mixes. In the other cases, it returns a Seq. A Callable can be\nused to return all but the last elements:\n\n    say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»","n":"head","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    multi method head(Any:D:) is raw\n    multi method head(Any:D: Callable:D $w)\n    multi method head(Any:D: $n)\n\nReturns either the first element in the object, or the first $n if that's\nused.\n\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\n    say ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\n    say ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\n    say ^10 .head;              # OUTPUT: «0␤»\n    say ^∞ .head;               # OUTPUT: «0␤»\n\nIn the first two cases, the results are different since there's no defined\norder in Mixes. In the other cases, it returns a Seq. A Callable can be\nused to return all but the last elements:\n\n    say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»","n":"head","m":1,"k":"m","s":{"r":"Mu","p":["Callable:D $w","*%_"]}},{"k":"m","m":1,"s":{"p":["$n","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method head(Any:D:) is raw\n    multi method head(Any:D: Callable:D $w)\n    multi method head(Any:D: $n)\n\nReturns either the first element in the object, or the first $n if that's\nused.\n\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\n    say ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\n    say ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\n    say ^10 .head;              # OUTPUT: «0␤»\n    say ^∞ .head;               # OUTPUT: «0␤»\n\nIn the first two cases, the results are different since there's no defined\norder in Mixes. In the other cases, it returns a Seq. A Callable can be\nused to return all but the last elements:\n\n    say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»","n":"head"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"tail","d":"Defined as:\n\n    multi method tail() is raw\n    multi method tail($n)\n\nReturns the last or the list of the $n last elements of an object. $n can\nbe a Callable, usually a WhateverCode, which will be used to get all but\nthe first n elements of the object.\n\n    say (^12).reverse.tail ;     # OUTPUT: «0␤»\n    say (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\n    say (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»"},{"k":"m","m":1,"s":{"r":"Mu","p":["$n","*%_"]},"d":"Defined as:\n\n    multi method tail() is raw\n    multi method tail($n)\n\nReturns the last or the list of the $n last elements of an object. $n can\nbe a Callable, usually a WhateverCode, which will be used to get all but\nthe first n elements of the object.\n\n    say (^12).reverse.tail ;     # OUTPUT: «0␤»\n    say (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\n    say (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»","n":"tail"},{"n":"skip","d":"Defined as:\n\n    multi method skip()\n    multi method skip(Whatever)\n    multi method skip(Callable:D $w)\n    multi method skip(Int() $n)\n\nCreates a Seq from 1-item list's iterator and uses Seq.skip on it, please\ncheck that document for real use cases; calling skip without argument is\nequivalent to skip(1).\n\nCalling it with Whatever will return an empty iterator:\n\n    say <1 2 3>.skip(*);   # OUTPUT: «()␤»\n\nThe multi that uses a Callable is intended mainly to be used this way:\n\n    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»\n\nInstead of throwing away the first $n elements, it throws away everything\nbut the elements indicated by the WhateverCode, in this case all but the\nlast one.","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"s":{"r":"Mu","p":["Whatever $","*%_"]},"m":1,"k":"m","n":"skip","d":"Defined as:\n\n    multi method skip()\n    multi method skip(Whatever)\n    multi method skip(Callable:D $w)\n    multi method skip(Int() $n)\n\nCreates a Seq from 1-item list's iterator and uses Seq.skip on it, please\ncheck that document for real use cases; calling skip without argument is\nequivalent to skip(1).\n\nCalling it with Whatever will return an empty iterator:\n\n    say <1 2 3>.skip(*);   # OUTPUT: «()␤»\n\nThe multi that uses a Callable is intended mainly to be used this way:\n\n    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»\n\nInstead of throwing away the first $n elements, it throws away everything\nbut the elements indicated by the WhateverCode, in this case all but the\nlast one."},{"s":{"r":"Mu","p":["Callable:D $w","*%_"]},"k":"m","m":1,"n":"skip","d":"Defined as:\n\n    multi method skip()\n    multi method skip(Whatever)\n    multi method skip(Callable:D $w)\n    multi method skip(Int() $n)\n\nCreates a Seq from 1-item list's iterator and uses Seq.skip on it, please\ncheck that document for real use cases; calling skip without argument is\nequivalent to skip(1).\n\nCalling it with Whatever will return an empty iterator:\n\n    say <1 2 3>.skip(*);   # OUTPUT: «()␤»\n\nThe multi that uses a Callable is intended mainly to be used this way:\n\n    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»\n\nInstead of throwing away the first $n elements, it throws away everything\nbut the elements indicated by the WhateverCode, in this case all but the\nlast one."},{"s":{"r":"Mu","p":["$n","*%_"]},"k":"m","m":1,"n":"skip","d":"Defined as:\n\n    multi method skip()\n    multi method skip(Whatever)\n    multi method skip(Callable:D $w)\n    multi method skip(Int() $n)\n\nCreates a Seq from 1-item list's iterator and uses Seq.skip on it, please\ncheck that document for real use cases; calling skip without argument is\nequivalent to skip(1).\n\nCalling it with Whatever will return an empty iterator:\n\n    say <1 2 3>.skip(*);   # OUTPUT: «()␤»\n\nThe multi that uses a Callable is intended mainly to be used this way:\n\n    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»\n\nInstead of throwing away the first $n elements, it throws away everything\nbut the elements indicated by the WhateverCode, in this case all but the\nlast one."},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method minpairs(Any:D:)\n\nCalls .pairs and returns a Seq with all of the Pairs with minimum values,\nas judged by the cmp operator:\n\n    <a b c a b c>.minpairs.perl.put; # OUTPUT: «(0 => \"a\", 3 => \"a\").Seq␤»\n    %(:42a, :75b).minpairs.perl.put; # OUTPUT: «(:a(42),).Seq␤»","n":"minpairs"},{"d":"Defined as:\n\n    multi method maxpairs(Any:D:)\n\nCalls .pairs and returns a Seq with all of the Pairs with maximum values,\nas judged by the cmp operator:\n\n    <a b c a b c>.maxpairs.perl.put; # OUTPUT: «(2 => \"c\", 5 => \"c\").Seq␤»\n    %(:42a, :75b).maxpairs.perl.put; # OUTPUT: «(:b(75),).Seq␤»","n":"maxpairs","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    multi method batch(Int:D $batch)\n    multi method batch(Int:D :$elems!)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.batch on it.","n":"batch","k":"m","m":1,"s":{"p":["Int:D :$elems!","*%_"],"r":"Mu"}},{"n":"batch","d":"Defined as:\n\n    multi method batch(Int:D $batch)\n    multi method batch(Int:D :$elems!)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.batch on it.","s":{"p":["Int:D $batch","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"rotor","d":"Defined as:\n\n    multi method rotor(Any:D: Int:D $batch, :$partial)\n    multi method rotor(Any:D: *@cycle, :$partial)\n\nGroups the elements of the object in lists of $batch elements.\n\n    say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»\n\nWith the :partial named argument, it will also include lists that do not\nget to be the $batch size:\n\n    say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»\n\n.rotor can be called with an array of integers and pairs, which will be\napplied in turn. While integers will establish the batch size, as above,\nPairs will use the key as batch size and the value as number of elements to\nskip if it's positive, or overlap if it's negative.\n\n    say (3..11).rotor(3, 2 => 1, 3 => -2, :partial);\n    # OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»\n\nIn this case, the first batch (ruled by an integer) has 3 elements; the\nsecond one has 2 elements (key of the pair), but skips one (the number 8);\nthe third one has size 2 (because partials are allowed), and an overlap of\n2 also.\n\nPlease see also list.rotor for examples applied to lists.","s":{"r":"Mu","p":["Int:D $batch",":$partial","*%_"]},"m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["*@cycle",":$partial","*%_"]},"d":"Defined as:\n\n    multi method rotor(Any:D: Int:D $batch, :$partial)\n    multi method rotor(Any:D: *@cycle, :$partial)\n\nGroups the elements of the object in lists of $batch elements.\n\n    say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»\n\nWith the :partial named argument, it will also include lists that do not\nget to be the $batch size:\n\n    say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»\n\n.rotor can be called with an array of integers and pairs, which will be\napplied in turn. While integers will establish the batch size, as above,\nPairs will use the key as batch size and the value as number of elements to\nskip if it's positive, or overlap if it's negative.\n\n    say (3..11).rotor(3, 2 => 1, 3 => -2, :partial);\n    # OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»\n\nIn this case, the first batch (ruled by an integer) has 3 elements; the\nsecond one has 2 elements (key of the pair), but skips one (the number 8);\nthe third one has size 2 (because partials are allowed), and an overlap of\n2 also.\n\nPlease see also list.rotor for examples applied to lists.","n":"rotor"},{"n":"!minmax-range-init","k":"m","m":0,"s":{"r":"Nil","p":["\\value","\\mi","\\exmi","\\ma","\\exma","*%_"]}},{"n":"!cmp-minmax-range-check","k":"m","m":0,"s":{"p":["\\value","$cmp","\\mi","\\exmi","\\ma","\\exma","*%_"],"r":"Nil"}},{"k":"m","m":0,"s":{"p":["Callable:D $test","*%_"],"r":"Mu"},"n":"!grep-kv"},{"m":0,"k":"m","s":{"p":["Mu $test","%a","*%_"],"r":"Mu"},"n":"!first-accepts-end"},{"n":"!grep-callable","m":0,"k":"m","s":{"p":["Callable:D $test","*%_"],"r":"Mu"}},{"s":{"p":["\\value","\\mi","\\exmi","\\ma","\\exma","*%_"],"r":"Nil"},"m":0,"k":"m","n":"!minmax-range-check"},{"s":{"r":"Mu","p":["$test","*%_"]},"m":0,"k":"m","n":"!wrap-callable-for-grep"},{"k":"m","m":0,"s":{"p":["Mu $test","*%_"],"r":"Mu"},"n":"!grep-accepts"},{"n":"!grep-p","m":0,"k":"m","s":{"r":"Mu","p":["Callable:D $test","*%_"]}},{"n":"!grep-k","s":{"p":["Callable:D $test","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!first-result","m":0,"k":"m","s":{"p":["\\index","\\value","$what","%a","*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["$action","\\first","*%_"],"r":"Mu"},"n":"!iterator-and-first"},{"m":0,"k":"m","s":{"p":["Mu $test","%a","*%_"],"r":"Mu"},"n":"!first-accepts"}],"n":"Any","t":"Any","d":"TITLE\nclass Any\n\nSUBTITLE\nThing/object\n\n    class Any is Mu {}\n\nWhile Mu is the root of the Raku class hierarchy, Any is the class that\nserves as a default base class for new classes, and as the base class for\nmost built-in classes.\n\nSince Raku intentionally confuses items and single-element lists, most\nmethods in Any are also present on class List, and coerce to List or a\nlist-like type.\n\n"},{"m":[{"n":"new","m":0,"k":"m","s":{"p":["\\list","Mu \\test","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-lazy"},{"n":"!SET-SELF","k":"m","m":0,"s":{"p":["\\list","Mu \\test","*%_"],"r":"Mu"}}],"k":"ro","mro":[],"t":"Any::Grepper","a":[{"n":"$!iter","t":"Mu","k":"v"},{"t":"Mu","n":"$!test","k":"v"}],"n":"Any::Grepper","b":"C"},{"b":"A","mro":["Iterator","Any"],"k":"c","m":[{"s":{"r":"Mu","p":["\\list","&as","*%_"]},"m":0,"k":"m","n":"new"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pull-one"},{"n":"push-all","s":{"p":["\\target","*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-lazy"},{"s":{"r":"Mu","p":["\\list","&!as","*%_"]},"m":0,"k":"m","n":"!SET-SELF"}],"n":"Any::Repeated-As","a":[{"n":"$!iter","t":"Mu","k":"v"},{"k":"v","t":"Callable","n":"&!as"},{"k":"v","n":"$!seen","t":"Mu"}],"t":"Any::Repeated-As"},{"n":"&prefix:<so>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["Bool:D \\a"]},"n":"prefix:<so>"},{"s":{"r":"Mu","p":["Bool:U \\a"]},"m":1,"k":"s","n":"prefix:<so>"},{"s":{"p":["Mu \\a"],"r":"Mu"},"k":"s","m":1,"n":"prefix:<so>"},{"k":"v","n":"&infix:<lcm>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<lcm>","s":{"p":["Int:D $x = 1"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<lcm>","k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"}},{"s":{"r":"Int:D","p":["Int:D \\a","Int:D \\b"]},"m":1,"k":"s","n":"infix:<lcm>"},{"k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"},"n":"infix:<lcm>"},{"b":"C","t":"NumericEnumeration","n":"NumericEnumeration","k":"ro","mro":[]},{"n":"&infix:<⊆>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Bool:D","p":["Setty:D \\a","Setty:D \\b"]},"k":"s","m":1,"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":["Setty:D \\a","Mixy:D \\b"]},"k":"s","m":1},{"s":{"r":"Bool:D","p":["Setty:D \\a","Baggy:D \\b"]},"k":"s","m":1,"n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"p":["Setty:D \\a","\\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":["Mixy:D \\a","Mixy:D \\b"]},"m":1,"k":"s"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":["Mixy:D \\a","Baggy:D \\b"]},"m":1,"k":"s"},{"s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Mixy:D \\a","\\b"]},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","m":1,"k":"s","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Bool:D"}},{"s":{"r":"Bool:D","p":["Baggy:D \\a","Baggy:D \\b"]},"m":1,"k":"s","n":"infix:«(<=)»"},{"k":"s","m":1,"s":{"p":["Baggy:D \\a","Setty:D \\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","s":{"p":["Baggy:D \\a","\\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"infix:«(<=)»","s":{"r":"Bool:D","p":["Map:D \\a","Map:D \\b"]},"k":"s","m":1},{"s":{"r":"Bool:D","p":["Iterable:D \\a","Map:D \\b"]},"k":"s","m":1,"n":"infix:«(<=)»"},{"s":{"r":"Bool:D","p":["\\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"p":["\\a","Baggy:D \\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"s":{"p":["\\a","Setty:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"p":["Failure:D \\a","$"],"r":"Mu"},"n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"r":"Mu","p":["$","Failure:D \\b"]},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","\\b"]}},{"k":"v","n":"&infix:<−>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<->","m":1,"k":"s","s":{"p":["$x = 0"],"r":"Mu"}},{"n":"infix:<->","s":{"p":["\\a","\\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"m":1,"k":"s","n":"infix:<->"},{"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"k":"s","m":1,"n":"infix:<->"},{"n":"infix:<->","s":{"p":["int $a","int $b"],"r":"int"},"m":1,"k":"s"},{"s":{"p":["Num:D \\a","Num:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"r":"num","p":["num $a","num $b"]}},{"n":"infix:<->","m":1,"k":"s","s":{"r":"Mu","p":["Range:D \\r","Real:D \\v"]}},{"s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]},"m":1,"k":"s","n":"infix:<->"},{"s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]},"m":1,"k":"s","n":"infix:<->"},{"k":"s","m":1,"s":{"r":"Mu","p":["Int:D \\a","Rational:D \\b"]},"n":"infix:<->"},{"s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Complex:D"},"k":"s","m":1,"n":"infix:<->"},{"s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Complex:D"},"k":"s","m":1,"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Complex:D"}},{"n":"infix:<->","k":"s","m":1,"s":{"p":["Instant:D $a","Instant:D $b"],"r":"Duration:D"}},{"s":{"p":["Instant:D $a","Real:D $b"],"r":"Instant:D"},"k":"s","m":1,"n":"infix:<->"},{"k":"s","m":1,"s":{"r":"Duration:D","p":["Duration:D $a","Real $b"]},"n":"infix:<->"},{"s":{"r":"Duration:D","p":["Duration:D $a","Duration:D $b"]},"m":1,"k":"s","n":"infix:<->"},{"n":"infix:<->","s":{"r":"Duration:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"DateTime:D","p":["DateTime:D \\a","Duration:D \\b"]},"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"p":["Date:D $d","Int:D $x"],"r":"Date:D"}},{"n":"infix:<->","s":{"r":"Int:D","p":["Date:D $a","Date:D $b"]},"m":1,"k":"s"},{"k":"v","n":"&infix:<∖>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<(-)>","m":1,"k":"s","s":{"r":"Mu","p":[]}},{"n":"infix:<(-)>","s":{"r":"Mu","p":["QuantHash:D \\a"]},"m":1,"k":"s"},{"s":{"r":"Mu","p":["SetHash:D \\a"]},"m":1,"k":"s","n":"infix:<(-)>"},{"s":{"r":"Mu","p":["BagHash:D \\a"]},"k":"s","m":1,"n":"infix:<(-)>"},{"s":{"r":"Mu","p":["MixHash:D \\a"]},"k":"s","m":1,"n":"infix:<(-)>"},{"s":{"p":["\\a"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"n":"infix:<(-)>","s":{"p":["Setty:D \\a","Setty:D \\b"],"r":"Mu"},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Map:D \\b"]},"n":"infix:<(-)>"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":["Setty:D \\a","Iterable:D \\b"]}},{"s":{"r":"Mu","p":["Mixy:D \\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:<(-)>"},{"s":{"p":["Mixy:D \\a","QuantHash:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"s":{"r":"Mu","p":["QuantHash:D \\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:<(-)>"},{"k":"s","m":1,"s":{"p":["Mixy:D \\a","Map:D \\b"],"r":"Mu"},"n":"infix:<(-)>"},{"n":"infix:<(-)>","m":1,"k":"s","s":{"r":"Mu","p":["Mixy:D \\a","Any:D \\b"]}},{"n":"infix:<(-)>","s":{"r":"Mu","p":["Any:D \\a","Mixy:D \\b"]},"k":"s","m":1},{"n":"infix:<(-)>","m":1,"k":"s","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"}},{"n":"infix:<(-)>","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a","QuantHash:D \\b"]},"n":"infix:<(-)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["QuantHash:D \\a","Baggy:D \\b"]},"n":"infix:<(-)>"},{"s":{"p":["Baggy:D \\a","Map:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(-)>"},{"n":"infix:<(-)>","m":1,"k":"s","s":{"p":["Baggy:D \\a","Any:D \\b"],"r":"Mu"}},{"n":"infix:<(-)>","m":1,"k":"s","s":{"p":["\\a","Baggy:D \\b"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a","Map:D \\b"]},"n":"infix:<(-)>"},{"n":"infix:<(-)>","s":{"p":["\\a","Iterable:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(-)>","s":{"r":"Mu","p":["$","Failure:D \\b"]},"k":"s","m":1},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":["Failure:D \\a","$"]}},{"n":"infix:<(-)>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"}},{"n":"infix:<(-)>","m":1,"k":"s","s":{"r":"Mu","p":["**@p"]}},{"b":"C","mro":[],"k":"ro","m":[{"n":"soft","s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m"}],"n":"SoftRoutine","t":"SoftRoutine"},{"k":"n","n":"str","t":"str"},{"n":"Str","t":"Str","d":"TITLE\nclass Str\n\nSUBTITLE\nString of characters\n\n    class Str is Cool does Stringy { }\n\nBuilt-in class for strings. Objects of type Str are immutable, but read the\nFAQ to understand precisely what this means.\n\n","mro":["Stringy","Cool"],"m":[{"s":{"p":[":$value = \"\"","*%_"],"r":"Nil"},"k":"s","m":0,"n":"BUILD"},{"n":"Capture","d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"Int","d":"Defined as:\n\n    method Int(Str:D: --> Int:D)\n\nCoerces the string to Int, using the same rules as Str.Numeric.","s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m"},{"n":"Num","k":"m","m":0,"s":{"p":["*%_"],"r":"Num:D"}},{"n":"chomp","d":"Defined as:\n\n    multi sub    chomp(Str:D  --> Str:D)\n    multi method chomp(Str:D: --> Str:D)\n\nReturns the string with a logical newline (any codepoint that has the\nNEWLINE property) removed from the end.\n\nExamples:\n\n    say chomp(\"abc\\n\");       # OUTPUT: «abc␤»\n    say \"def\\r\\n\".chomp;      # OUTPUT: «def␤» NOTE: \\r\\n is a single grapheme!\n    say \"foo\\r\".chomp;        # OUTPUT: «foo␤»","s":{"p":["*%_"],"r":"Str:D"},"k":"m","m":0},{"n":"starts-with","d":"multi method starts-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or starts with $needle.\n\n    say \"Hello, World\".starts-with(\"Hello\");     # OUTPUT: «True␤»\n    say \"https://perl6.org/\".starts-with('ftp'); # OUTPUT: «False␤»","s":{"r":"Bool:D","p":["Cool:D $needle","*%_"]},"m":1,"k":"m"},{"d":"multi method starts-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or starts with $needle.\n\n    say \"Hello, World\".starts-with(\"Hello\");     # OUTPUT: «True␤»\n    say \"https://perl6.org/\".starts-with('ftp'); # OUTPUT: «False␤»","n":"starts-with","k":"m","m":1,"s":{"p":["Str:D $needle","*%_"],"r":"Bool:D"}},{"n":"ends-with","d":"multi method ends-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or ends with $needle.\n\n    say \"Hello, World\".ends-with('Hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".ends-with('ld');         # OUTPUT: «True␤»","s":{"r":"Bool:D","p":["Cool:D $suffix","*%_"]},"m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Bool:D","p":["Str:D $suffix","*%_"]},"d":"multi method ends-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or ends with $needle.\n\n    say \"Hello, World\".ends-with('Hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".ends-with('ld');         # OUTPUT: «True␤»","n":"ends-with"},{"m":1,"k":"m","s":{"r":"Bool:D","p":["Cool:D $needle","*%_"]},"d":"multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\n    multi method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)\n\nReturns True if the $test-string exactly matches the String object,\nstarting from the given initial index $from. For example, beginning with\nthe string \"foobar\", the substring \"bar\" will match from index 3:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»\n\nHowever, the substring \"barz\" starting from index 3 won't match even though\nthe first three letters of the substring do match:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»\n\nNaturally, to match the entire string, one merely matches from index 0:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»\n\nSince this method is inherited from the Cool type, it also works on\nintegers. Thus the integer 42 will match the value 342 starting from index\n1:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 1);      # OUTPUT: «True␤»\n\nAs expected, one can match the entire value by starting at index 0:\n\n    my $integer = 342;\n    say $integer.substr-eq(342, 0);     # OUTPUT: «True␤»\n\nAlso using a different value or an incorrect starting index won't match:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\n    say $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»","n":"substr-eq"},{"m":1,"k":"m","s":{"r":"Bool:D","p":["Str:D $needle","*%_"]},"d":"multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\n    multi method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)\n\nReturns True if the $test-string exactly matches the String object,\nstarting from the given initial index $from. For example, beginning with\nthe string \"foobar\", the substring \"bar\" will match from index 3:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»\n\nHowever, the substring \"barz\" starting from index 3 won't match even though\nthe first three letters of the substring do match:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»\n\nNaturally, to match the entire string, one merely matches from index 0:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»\n\nSince this method is inherited from the Cool type, it also works on\nintegers. Thus the integer 42 will match the value 342 starting from index\n1:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 1);      # OUTPUT: «True␤»\n\nAs expected, one can match the entire value by starting at index 0:\n\n    my $integer = 342;\n    say $integer.substr-eq(342, 0);     # OUTPUT: «True␤»\n\nAlso using a different value or an incorrect starting index won't match:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\n    say $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»","n":"substr-eq"},{"k":"m","m":1,"s":{"p":["Cool:D $needle","Int:D $pos","*%_"],"r":"Bool:D"},"d":"multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\n    multi method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)\n\nReturns True if the $test-string exactly matches the String object,\nstarting from the given initial index $from. For example, beginning with\nthe string \"foobar\", the substring \"bar\" will match from index 3:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»\n\nHowever, the substring \"barz\" starting from index 3 won't match even though\nthe first three letters of the substring do match:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»\n\nNaturally, to match the entire string, one merely matches from index 0:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»\n\nSince this method is inherited from the Cool type, it also works on\nintegers. Thus the integer 42 will match the value 342 starting from index\n1:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 1);      # OUTPUT: «True␤»\n\nAs expected, one can match the entire value by starting at index 0:\n\n    my $integer = 342;\n    say $integer.substr-eq(342, 0);     # OUTPUT: «True␤»\n\nAlso using a different value or an incorrect starting index won't match:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\n    say $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»","n":"substr-eq"},{"n":"substr-eq","d":"multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\n    multi method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)\n\nReturns True if the $test-string exactly matches the String object,\nstarting from the given initial index $from. For example, beginning with\nthe string \"foobar\", the substring \"bar\" will match from index 3:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»\n\nHowever, the substring \"barz\" starting from index 3 won't match even though\nthe first three letters of the substring do match:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»\n\nNaturally, to match the entire string, one merely matches from index 0:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»\n\nSince this method is inherited from the Cool type, it also works on\nintegers. Thus the integer 42 will match the value 342 starting from index\n1:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 1);      # OUTPUT: «True␤»\n\nAs expected, one can match the entire value by starting at index 0:\n\n    my $integer = 342;\n    say $integer.substr-eq(342, 0);     # OUTPUT: «True␤»\n\nAlso using a different value or an incorrect starting index won't match:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\n    say $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»","s":{"r":"Bool:D","p":["Str:D $needle","Int:D $pos","*%_"]},"m":1,"k":"m"},{"s":{"p":["Cool:D $needle","*%_"],"r":"Bool:D"},"k":"m","m":1,"n":"contains","d":"Defined as:\n\n    multi method contains(Str:D: Cool:D $needle --> Bool:D)\n    multi method contains(Str:D: Str:D $needle --> Bool:D)\n    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\n    multi method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)\n\nCoerces the invocant (represented in the signature by Str:D:, that would be\nthe haystack) and first argument (which we are calling $needle) to Str (if\nit's not already, that is, in the first and third multi forms), and\nsearches for $needle in the invocant (or haystack) starting from $pos\ncharacters into the string, if that is included as an argument. Returns\nTrue if $needle is found. $pos is an optional parameter, and if it's not\npresent, contains will search from the beginning of the string (using the\nfirst two forms of the multi).\n\n    say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\n    say \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\n    say \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\n    say \"Hello, World\".contains(',');          # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»\n\nIn the first example, coercion is used to convert a List to a Str. In the\n4th case, the 'Hello' string is not found since we have started looking at\nthe second position in it (index 1). Note that because of how a List or\nArray is coerced into a Str, the results may sometimes be surprising. See\ntraps."},{"d":"Defined as:\n\n    multi method contains(Str:D: Cool:D $needle --> Bool:D)\n    multi method contains(Str:D: Str:D $needle --> Bool:D)\n    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\n    multi method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)\n\nCoerces the invocant (represented in the signature by Str:D:, that would be\nthe haystack) and first argument (which we are calling $needle) to Str (if\nit's not already, that is, in the first and third multi forms), and\nsearches for $needle in the invocant (or haystack) starting from $pos\ncharacters into the string, if that is included as an argument. Returns\nTrue if $needle is found. $pos is an optional parameter, and if it's not\npresent, contains will search from the beginning of the string (using the\nfirst two forms of the multi).\n\n    say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\n    say \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\n    say \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\n    say \"Hello, World\".contains(',');          # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»\n\nIn the first example, coercion is used to convert a List to a Str. In the\n4th case, the 'Hello' string is not found since we have started looking at\nthe second position in it (index 1). Note that because of how a List or\nArray is coerced into a Str, the results may sometimes be surprising. See\ntraps.","n":"contains","m":1,"k":"m","s":{"p":["Str:D $needle","*%_"],"r":"Bool:D"}},{"m":1,"k":"m","s":{"r":"Bool:D","p":["Cool:D $needle","Int(Cool:D) $pos","*%_"]},"d":"Defined as:\n\n    multi method contains(Str:D: Cool:D $needle --> Bool:D)\n    multi method contains(Str:D: Str:D $needle --> Bool:D)\n    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\n    multi method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)\n\nCoerces the invocant (represented in the signature by Str:D:, that would be\nthe haystack) and first argument (which we are calling $needle) to Str (if\nit's not already, that is, in the first and third multi forms), and\nsearches for $needle in the invocant (or haystack) starting from $pos\ncharacters into the string, if that is included as an argument. Returns\nTrue if $needle is found. $pos is an optional parameter, and if it's not\npresent, contains will search from the beginning of the string (using the\nfirst two forms of the multi).\n\n    say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\n    say \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\n    say \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\n    say \"Hello, World\".contains(',');          # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»\n\nIn the first example, coercion is used to convert a List to a Str. In the\n4th case, the 'Hello' string is not found since we have started looking at\nthe second position in it (index 1). Note that because of how a List or\nArray is coerced into a Str, the results may sometimes be surprising. See\ntraps.","n":"contains"},{"m":1,"k":"m","s":{"p":["Str:D $needle","Int:D $pos","*%_"],"r":"Bool:D"},"d":"Defined as:\n\n    multi method contains(Str:D: Cool:D $needle --> Bool:D)\n    multi method contains(Str:D: Str:D $needle --> Bool:D)\n    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\n    multi method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)\n\nCoerces the invocant (represented in the signature by Str:D:, that would be\nthe haystack) and first argument (which we are calling $needle) to Str (if\nit's not already, that is, in the first and third multi forms), and\nsearches for $needle in the invocant (or haystack) starting from $pos\ncharacters into the string, if that is included as an argument. Returns\nTrue if $needle is found. $pos is an optional parameter, and if it's not\npresent, contains will search from the beginning of the string (using the\nfirst two forms of the multi).\n\n    say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\n    say \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\n    say \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\n    say \"Hello, World\".contains(',');          # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»\n\nIn the first example, coercion is used to convert a List to a Str. In the\n4th case, the 'Hello' string is not found since we have started looking at\nthe second position in it (index 1). Note that because of how a List or\nArray is coerced into a Str, the results may sometimes be surprising. See\ntraps.","n":"contains"},{"s":{"p":["Cool:D $needle","*%pars"],"r":"Mu"},"m":1,"k":"m","n":"indices","d":"Defined as:\n\n    multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\n    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)\n\nSearches for all occurrences of $needle in the string starting from\nposition $start, or zero if it is not specified, and returns a List with\nall offsets in the string where $needle was found, or an empty list if it\nwas not found.\n\nIf the optional parameter :overlap is specified the search continues from\nthe index directly following the previous match, otherwise the search will\ncontinue after the previous match.\n\n    say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\n    say \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\n    say \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\n    say \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»"},{"d":"Defined as:\n\n    multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\n    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)\n\nSearches for all occurrences of $needle in the string starting from\nposition $start, or zero if it is not specified, and returns a List with\nall offsets in the string where $needle was found, or an empty list if it\nwas not found.\n\nIf the optional parameter :overlap is specified the search continues from\nthe index directly following the previous match, otherwise the search will\ncontinue after the previous match.\n\n    say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\n    say \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\n    say \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\n    say \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»","n":"indices","k":"m","m":1,"s":{"p":["Str:D $needle",":$overlap","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\n    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)\n\nSearches for all occurrences of $needle in the string starting from\nposition $start, or zero if it is not specified, and returns a List with\nall offsets in the string where $needle was found, or an empty list if it\nwas not found.\n\nIf the optional parameter :overlap is specified the search continues from\nthe index directly following the previous match, otherwise the search will\ncontinue after the previous match.\n\n    say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\n    say \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\n    say \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\n    say \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»","n":"indices","m":1,"k":"m","s":{"p":["Cool:D $needle","Cool:D $start","*%pars"],"r":"Mu"}},{"s":{"p":["Str:D $needle","Int:D $start",":$overlap","*%_"],"r":"Mu"},"m":1,"k":"m","n":"indices","d":"Defined as:\n\n    multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\n    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)\n\nSearches for all occurrences of $needle in the string starting from\nposition $start, or zero if it is not specified, and returns a List with\nall offsets in the string where $needle was found, or an empty list if it\nwas not found.\n\nIf the optional parameter :overlap is specified the search continues from\nthe index directly following the previous match, otherwise the search will\ncontinue after the previous match.\n\n    say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\n    say \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\n    say \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\n    say \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»"},{"n":"index","d":"multi method index(Str:D: Cool:D $needle --> Int:D)\n    multi method index(Str:D: Str:D $needle --> Int:D)\n    multi method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\n    multi method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)\n\nSearches for $needle in the string starting from $pos (if present). It\nreturns the offset into the string where $needle was found, and Nil if it\nwas not found.\n\nExamples:\n\n    say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\n    say index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\n    say index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\n    say index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\n    say index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\n    say index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»\n\nOther forms of index, including a sub, are inherited from Cool. Check them\nthere.","s":{"p":["Cool:D $needle","*%_"],"r":"Int:D"},"k":"m","m":1},{"m":1,"k":"m","s":{"p":["Str:D $needle","*%_"],"r":"Int:D"},"d":"multi method index(Str:D: Cool:D $needle --> Int:D)\n    multi method index(Str:D: Str:D $needle --> Int:D)\n    multi method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\n    multi method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)\n\nSearches for $needle in the string starting from $pos (if present). It\nreturns the offset into the string where $needle was found, and Nil if it\nwas not found.\n\nExamples:\n\n    say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\n    say index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\n    say index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\n    say index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\n    say index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\n    say index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»\n\nOther forms of index, including a sub, are inherited from Cool. Check them\nthere.","n":"index"},{"n":"index","d":"multi method index(Str:D: Cool:D $needle --> Int:D)\n    multi method index(Str:D: Str:D $needle --> Int:D)\n    multi method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\n    multi method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)\n\nSearches for $needle in the string starting from $pos (if present). It\nreturns the offset into the string where $needle was found, and Nil if it\nwas not found.\n\nExamples:\n\n    say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\n    say index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\n    say index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\n    say index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\n    say index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\n    say index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»\n\nOther forms of index, including a sub, are inherited from Cool. Check them\nthere.","s":{"p":["Cool:D $needle","Cool:D $pos","*%_"],"r":"Int:D"},"k":"m","m":1},{"m":1,"k":"m","s":{"p":["Str:D $needle","Int:D $pos","*%_"],"r":"Int:D"},"d":"multi method index(Str:D: Cool:D $needle --> Int:D)\n    multi method index(Str:D: Str:D $needle --> Int:D)\n    multi method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\n    multi method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)\n\nSearches for $needle in the string starting from $pos (if present). It\nreturns the offset into the string where $needle was found, and Nil if it\nwas not found.\n\nExamples:\n\n    say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\n    say index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\n    say index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\n    say index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\n    say index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\n    say index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»\n\nOther forms of index, including a sub, are inherited from Cool. Check them\nthere.","n":"index"},{"n":"rindex","d":"multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\n    multi method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)\n\nReturns the last position of $needle in $haystack not after $startpos.\nReturns Nil if $needle wasn't found.\n\nExamples:\n\n    say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\n    say rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»","s":{"p":["Cool:D $needle","*%_"],"r":"Int:D"},"m":1,"k":"m"},{"s":{"r":"Int:D","p":["Str:D $needle","*%_"]},"k":"m","m":1,"n":"rindex","d":"multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\n    multi method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)\n\nReturns the last position of $needle in $haystack not after $startpos.\nReturns Nil if $needle wasn't found.\n\nExamples:\n\n    say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\n    say rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»"},{"n":"rindex","d":"multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\n    multi method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)\n\nReturns the last position of $needle in $haystack not after $startpos.\nReturns Nil if $needle wasn't found.\n\nExamples:\n\n    say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\n    say rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»","s":{"p":["Cool:D $needle","Cool:D $pos","*%_"],"r":"Int:D"},"k":"m","m":1},{"n":"rindex","d":"multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\n    multi method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)\n\nReturns the last position of $needle in $haystack not after $startpos.\nReturns Nil if $needle wasn't found.\n\nExamples:\n\n    say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\n    say rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»","s":{"p":["Str:D $needle","Int:D $pos","*%_"],"r":"Int:D"},"m":1,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Str:D"},"d":"method pred(Str:D: --> Str:D)\n\nReturns the string decremented by one.\n\nString decrementing is \"magical\" just like string increment (see succ). It\nfails on underflow\n\n    'b0'.pred;           # RESULT: «a9»\n    'a0'.pred;           # Failure\n    'img002.png'.pred;   # RESULT: «img001.png»","n":"pred"},{"n":"succ","d":"method succ(Str:D --> Str:D)\n\nReturns the string incremented by one.\n\nString increment is \"magical\". It searches for the last alphanumeric\nsequence that is not preceded by a dot, and increments it.\n\n    '12.34'.succ;      # RESULT: «13.34»\n    'img001.png'.succ; # RESULT: «img002.png»\n\nThe actual increment step works by mapping the last alphanumeric character\nto a character range it belongs to, and choosing the next character in that\nrange, carrying to the previous letter on overflow.\n\n    'aa'.succ;   # RESULT: «ab»\n    'az'.succ;   # RESULT: «ba»\n    '109'.succ;  # RESULT: «110»\n    'α'.succ;    # RESULT: «β»\n    'a9'.succ;   # RESULT: «b0»\n\nString increment is Unicode-aware, and generally works for scripts where a\ncharacter can be uniquely classified as belonging to one range of\ncharacters.","s":{"p":["*%_"],"r":"Str:D"},"m":0,"k":"m"},{"d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture.","n":"comb","k":"m","m":1,"s":{"r":"Seq:D","p":["*%_"]}},{"s":{"r":"Seq:D","p":["Int:D $size is copy","$limit = *","*%_"]},"k":"m","m":1,"n":"comb","d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture."},{"n":"comb","d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture.","s":{"r":"Seq:D","p":["Str $pat","*%_"]},"m":1,"k":"m"},{"s":{"r":"Seq:D","p":["Str $pat","$limit","*%_"]},"k":"m","m":1,"n":"comb","d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture."},{"d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture.","n":"comb","m":1,"k":"m","s":{"p":["Regex:D $pattern",":$match","*%_"],"r":"Seq:D"}},{"m":1,"k":"m","s":{"p":["Regex:D $pattern","$limit",":$match","*%_"],"r":"Seq:D"},"d":"multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture.","n":"comb"},{"s":{"r":"Mu","p":["Cool:D $pattern","|c is raw"]},"k":"m","m":1,"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»"},{"m":1,"k":"m","s":{"r":"Mu","p":["Regex:D $pattern",":continue(:$c)!","*%_"]},"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match"},{"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","s":{"r":"Mu","p":["Regex:D $pattern",":pos(:$p)!","*%_"]},"m":1,"k":"m"},{"k":"m","m":1,"s":{"p":["Regex:D $pattern",":global(:$g)!","*%_"],"r":"Mu"},"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match"},{"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","s":{"r":"Mu","p":["Regex:D $pattern",":overlap(:$ov)!","*%_"]},"m":1,"k":"m"},{"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match","k":"m","m":1,"s":{"r":"Mu","p":["Regex:D $pattern",":exhaustive(:$ex)!","*%_"]}},{"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","s":{"p":["Regex:D $pattern",":$x!","*%_"],"r":"Mu"},"k":"m","m":1},{"s":{"p":["Regex:D $pattern",":$st!","*%_"],"r":"Mu"},"k":"m","m":1,"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»"},{"s":{"p":["Regex:D $pattern",":$nd!","*%_"],"r":"Mu"},"k":"m","m":1,"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»"},{"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match","m":1,"k":"m","s":{"p":["Regex:D $pattern",":$rd!","*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"p":["Regex:D $pattern",":$th!","*%_"],"r":"Mu"},"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match"},{"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","s":{"p":["Regex:D $pattern",":$nth!","*%_"],"r":"Mu"},"k":"m","m":1},{"d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","n":"match","m":1,"k":"m","s":{"p":["Regex:D $pattern",":$as!","*%_"],"r":"Mu"}},{"n":"match","d":"method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","s":{"r":"Mu","p":["Regex:D $pattern","*%_"]},"k":"m","m":1},{"d":"NOTE: .subst-mutate is deprecated in the 6.d version, and will be removed\nin future ones. You can use subst with .= method call assignment operator\nor s/// substitution operator instead. \n\nWhere subst returns the modified string and leaves the original unchanged,\nit is possible to mutate the original string by using subst-mutate. If the\nmatch is successful, the method returns a Match object representing the\nsuccessful match, otherwise returns Nil. If :nth (or one of its aliases)\nwith Iterable value, :g, :global, or :x arguments are used, returns a List\nof Match objects, or an empty List if no matches occurred.\n\n    my $some-string = \"Some foo\";\n    my $match = $some-string.subst-mutate(/foo/, \"string\");\n    say $some-string;  # OUTPUT: «Some string␤»\n    say $match;        # OUTPUT: «｢foo｣␤»\n    $some-string.subst-mutate(/<[oe]>/, '', :g); # remove every o and e, notice the :g named argument from .subst\n\nIf a Regex $matcher is used, the $/ special variable will be set to Nil (if\nno matches occurred), a Match object, or a List of Match objects (if\nmulti-match options like :g are used).","n":"subst-mutate","k":"m","m":1,"s":{"r":"Mu","p":["Any:D $matcher","$replacement",":ii(:$samecase)",":ss(:$samespace)",":mm(:$samemark)","*%options"]}},{"n":"subst","d":"multi method subst(Str:D: $matcher, $replacement, *%opts)\n\nReturns the invocant string where $matcher is replaced by $replacement (or\nthe original string, if no match was found).\n\nThere is an in-place syntactic variant of subst spelled\ns/matcher/replacement/ and with adverb following the s or inside the\nmatcher.\n\n$matcher can be a Regex, or a literal Str. Non-Str matcher arguments of\ntype Cool are coerced to Str for literal matching. If a Regex $matcher is\nused, the $/ special variable will be set to Nil (if no matches occurred),\na Match object, or a List of Match objects (if multi-match options like :g\nare used).\n\n    Literal replacement substitution\n\n    my $some-string = \"Some foo\";\n    my $another-string = $some-string.subst(/foo/, \"string\"); # gives 'Some string'\n    $some-string.=subst(/foo/, \"string\"); # in-place substitution. $some-string is now 'Some string'\n\n    Callable\n\nThe replacement can be a Callable in which the current Match object will be\nplaced in the $/ variable, as well as the $_ topic variable. Using a\nCallable as replacement is how you can refer to any of the captures created\nin the regex:\n\n    # Using capture from $/ variable (the $0 is the first positional capture)\n    say 'abc123defg'.subst(/(\\d+)/, { \" before $0 after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using capture from $/ variable (the $<foo> is a named capture)\n    say 'abc123defg'.subst(/$<foo>=\\d+/, { \" before $<foo> after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using WhateverCode to operate on the Match given in $_:\n    say 'abc123defg'.subst(/(\\d+)/, \"[ \" ~ *.flip ~ \" ]\");\n    # OUTPUT: «abc[ 321 ]defg␤»\n\n    # Using a Callable to generate substitution without involving current Match:\n    my $i = 41;\n    my $str = \"The answer is secret.\";\n    say $str.subst(/secret/, {++$i}); # The answer to everything\n    # OUTPUT: «The answer is 42.␤»\n\n    Adverbs\n\nThe following adverbs are supported\n\n  short                        long        meaning\n  :g                           :global     tries to match as often as possible\n  :nth(Int|Callable|Whatever)              only substitute the nth match; aliases: :st, :nd, :rd, and :th\n  :ss                          :samespace  preserves whitespace on substitution\n  :ii                          :samecase   preserves case on substitution\n  :mm                          :samemark   preserves character marks (e.g. 'ü' replaced with 'o' will result in 'ö')\n  :x(Int|Range|Whatever)                   substitute exactly $x matches\n\n\nNote that only in the s/// form :ii implies :i and :ss implies :s. In the\nmethod form, the :s and :i modifiers must be added to the regex, not the\nsubst method call.\n\n    More Examples\n\nHere are other examples of usage:\n\n    my $str = \"Hey foo foo foo\";\n    $str.subst(/foo/, \"bar\", :g); # global substitution - returns Hey bar bar bar\n\n    $str.subst(/foo/, \"no subst\", :x(0)); # targeted substitution. Number of times to substitute. Returns back unmodified.\n    $str.subst(/foo/, \"bar\", :x(1)); #replace just the first occurrence.\n\n    $str.subst(/foo/, \"bar\", :nth(3)); # replace nth match alone. Replaces the third foo. Returns Hey foo foo bar\n\nThe :nth adverb has readable English-looking variants:\n\n    say 'ooooo'.subst: 'o', 'x', :1st; # OUTPUT: «xoooo␤»\n    say 'ooooo'.subst: 'o', 'x', :2nd; # OUTPUT: «oxooo␤»\n    say 'ooooo'.subst: 'o', 'x', :3rd; # OUTPUT: «ooxoo␤»\n    say 'ooooo'.subst: 'o', 'x', :4th; # OUTPUT: «oooxo␤»","s":{"p":["Str:D $original","Str:D $final","*%options"],"r":"Mu"},"m":1,"k":"m"},{"s":{"r":"Mu","p":["$matcher","$replacement","*%options"]},"m":1,"k":"m","n":"subst","d":"multi method subst(Str:D: $matcher, $replacement, *%opts)\n\nReturns the invocant string where $matcher is replaced by $replacement (or\nthe original string, if no match was found).\n\nThere is an in-place syntactic variant of subst spelled\ns/matcher/replacement/ and with adverb following the s or inside the\nmatcher.\n\n$matcher can be a Regex, or a literal Str. Non-Str matcher arguments of\ntype Cool are coerced to Str for literal matching. If a Regex $matcher is\nused, the $/ special variable will be set to Nil (if no matches occurred),\na Match object, or a List of Match objects (if multi-match options like :g\nare used).\n\n    Literal replacement substitution\n\n    my $some-string = \"Some foo\";\n    my $another-string = $some-string.subst(/foo/, \"string\"); # gives 'Some string'\n    $some-string.=subst(/foo/, \"string\"); # in-place substitution. $some-string is now 'Some string'\n\n    Callable\n\nThe replacement can be a Callable in which the current Match object will be\nplaced in the $/ variable, as well as the $_ topic variable. Using a\nCallable as replacement is how you can refer to any of the captures created\nin the regex:\n\n    # Using capture from $/ variable (the $0 is the first positional capture)\n    say 'abc123defg'.subst(/(\\d+)/, { \" before $0 after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using capture from $/ variable (the $<foo> is a named capture)\n    say 'abc123defg'.subst(/$<foo>=\\d+/, { \" before $<foo> after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using WhateverCode to operate on the Match given in $_:\n    say 'abc123defg'.subst(/(\\d+)/, \"[ \" ~ *.flip ~ \" ]\");\n    # OUTPUT: «abc[ 321 ]defg␤»\n\n    # Using a Callable to generate substitution without involving current Match:\n    my $i = 41;\n    my $str = \"The answer is secret.\";\n    say $str.subst(/secret/, {++$i}); # The answer to everything\n    # OUTPUT: «The answer is 42.␤»\n\n    Adverbs\n\nThe following adverbs are supported\n\n  short                        long        meaning\n  :g                           :global     tries to match as often as possible\n  :nth(Int|Callable|Whatever)              only substitute the nth match; aliases: :st, :nd, :rd, and :th\n  :ss                          :samespace  preserves whitespace on substitution\n  :ii                          :samecase   preserves case on substitution\n  :mm                          :samemark   preserves character marks (e.g. 'ü' replaced with 'o' will result in 'ö')\n  :x(Int|Range|Whatever)                   substitute exactly $x matches\n\n\nNote that only in the s/// form :ii implies :i and :ss implies :s. In the\nmethod form, the :s and :i modifiers must be added to the regex, not the\nsubst method call.\n\n    More Examples\n\nHere are other examples of usage:\n\n    my $str = \"Hey foo foo foo\";\n    $str.subst(/foo/, \"bar\", :g); # global substitution - returns Hey bar bar bar\n\n    $str.subst(/foo/, \"no subst\", :x(0)); # targeted substitution. Number of times to substitute. Returns back unmodified.\n    $str.subst(/foo/, \"bar\", :x(1)); #replace just the first occurrence.\n\n    $str.subst(/foo/, \"bar\", :nth(3)); # replace nth match alone. Replaces the third foo. Returns Hey foo foo bar\n\nThe :nth adverb has readable English-looking variants:\n\n    say 'ooooo'.subst: 'o', 'x', :1st; # OUTPUT: «xoooo␤»\n    say 'ooooo'.subst: 'o', 'x', :2nd; # OUTPUT: «oxooo␤»\n    say 'ooooo'.subst: 'o', 'x', :3rd; # OUTPUT: «ooxoo␤»\n    say 'ooooo'.subst: 'o', 'x', :4th; # OUTPUT: «oooxo␤»"},{"s":{"p":[":$count!","*%_"],"r":"Int:D"},"m":1,"k":"m","n":"lines","d":"Defined as:\n\n    multi method lines(Str:D: $limit)\n    multi method lines(Str:D:)\n\nReturns a list of lines (without trailing newline characters), i.e. the\nsame as a call to $input.comb( / ^^ \\N* /, $limit ) would.\n\nExamples:\n\n    say lines(\"a\\nb\").perl;    # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say lines(\"a\\nb\").elems;   # OUTPUT: «2␤»\n    say \"a\\nb\".lines.elems;    # OUTPUT: «2␤»\n    say \"a\\n\".lines.elems;     # OUTPUT: «1␤»\n\nYou can limit the number of lines returned by setting the $limit variable\nto a non-zero, non-Infinity value:\n\n    say <not there yet>.join(\"\\n\").lines( 2 ); # OUTPUT: «(not there)␤»\n\nDEPRECATED as of 6.d language, the :count argument was used to return the\ntotal number of lines:\n\n    say <not there yet>.join(\"\\n\").lines( :count ); # OUTPUT: «3␤»\n\nUse elems call on the returned Seq instead:\n\n    say <not there yet>.join(\"\\n\").lines.elems; # OUTPUT: «3␤»"},{"n":"lines","d":"Defined as:\n\n    multi method lines(Str:D: $limit)\n    multi method lines(Str:D:)\n\nReturns a list of lines (without trailing newline characters), i.e. the\nsame as a call to $input.comb( / ^^ \\N* /, $limit ) would.\n\nExamples:\n\n    say lines(\"a\\nb\").perl;    # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say lines(\"a\\nb\").elems;   # OUTPUT: «2␤»\n    say \"a\\nb\".lines.elems;    # OUTPUT: «2␤»\n    say \"a\\n\".lines.elems;     # OUTPUT: «1␤»\n\nYou can limit the number of lines returned by setting the $limit variable\nto a non-zero, non-Infinity value:\n\n    say <not there yet>.join(\"\\n\").lines( 2 ); # OUTPUT: «(not there)␤»\n\nDEPRECATED as of 6.d language, the :count argument was used to return the\ntotal number of lines:\n\n    say <not there yet>.join(\"\\n\").lines( :count ); # OUTPUT: «3␤»\n\nUse elems call on the returned Seq instead:\n\n    say <not there yet>.join(\"\\n\").lines.elems; # OUTPUT: «3␤»","s":{"p":["$limit","*%_"],"r":"Seq:D"},"m":1,"k":"m"},{"d":"Defined as:\n\n    multi method lines(Str:D: $limit)\n    multi method lines(Str:D:)\n\nReturns a list of lines (without trailing newline characters), i.e. the\nsame as a call to $input.comb( / ^^ \\N* /, $limit ) would.\n\nExamples:\n\n    say lines(\"a\\nb\").perl;    # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say lines(\"a\\nb\").elems;   # OUTPUT: «2␤»\n    say \"a\\nb\".lines.elems;    # OUTPUT: «2␤»\n    say \"a\\n\".lines.elems;     # OUTPUT: «1␤»\n\nYou can limit the number of lines returned by setting the $limit variable\nto a non-zero, non-Infinity value:\n\n    say <not there yet>.join(\"\\n\").lines( 2 ); # OUTPUT: «(not there)␤»\n\nDEPRECATED as of 6.d language, the :count argument was used to return the\ntotal number of lines:\n\n    say <not there yet>.join(\"\\n\").lines( :count ); # OUTPUT: «3␤»\n\nUse elems call on the returned Seq instead:\n\n    say <not there yet>.join(\"\\n\").lines.elems; # OUTPUT: «3␤»","n":"lines","k":"m","m":1,"s":{"r":"Seq:D","p":["*%_"]}},{"d":"multi sub    parse-base(Str:D $num, Int:D $radix --> Numeric)\n    multi method parse-base(Str:D $num: Int:D $radix --> Numeric)\n\nPerforms the reverse of base by converting a string with a base-$radix\nnumber to its Numeric equivalent. Will fail if radix is not in range 2..36\nor if the string being parsed contains characters that are not valid for\nthe specified base.\n\n    1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n    'Perl6'.parse-base(30).say;       # OUTPUT: «20652936␤»\n    'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»\n\nSee also: :16<FF> syntax for number literals","n":"parse-base","k":"m","m":0,"s":{"p":["Int:D $radix","*%_"],"r":"Numeric:D"}},{"n":"samecase","m":0,"k":"m","s":{"r":"Str:D","p":["Str:D $pattern","*%_"]}},{"d":"multi sub samemark(Str:D $string, Str:D $pattern --> Str:D)\n    method    samemark(Str:D: Str:D $pattern --> Str:D)\n\nReturns a copy of $string with the mark/accent information for each\ncharacter changed such that it matches the mark/accent of the corresponding\ncharacter in $pattern. If $string is longer than $pattern, the remaining\ncharacters in $string receive the same mark/accent as the last character in\n$pattern. If $pattern is empty no changes will be made.\n\nExamples:\n\n    say 'åäö'.samemark('aäo');                        # OUTPUT: «aäo␤»\n    say 'åäö'.samemark('a');                          # OUTPUT: «aao␤»\n\n    say samemark('Pêrl', 'a');                        # OUTPUT: «Perl␤»\n    say samemark('aöä', '');                          # OUTPUT: «aöä␤»","n":"samemark","k":"m","m":0,"s":{"p":["Str:D $pattern","*%_"],"r":"Str:D"}},{"m":0,"k":"m","s":{"r":"Mu","p":["Str:D $pattern","*%_"]},"n":"samespace"},{"s":{"r":"Mu","p":["Str:D $pattern","&filter?","Bool :$samespace","*%_"]},"m":0,"k":"m","n":"word-by-word"},{"s":{"p":["*%_"],"r":"Str:D"},"m":0,"k":"m","n":"trim-leading","d":"method trim-leading(Str:D: --> Str)\n\nRemoves the whitespace characters from the beginning of a string. See also\ntrim."},{"n":"trim-trailing","d":"method trim-trailing(Str:D: --> Str)\n\nRemoves the whitespace characters from the end of a string. See also trim.","s":{"r":"Str:D","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Str:D"},"m":0,"k":"m","n":"trim","d":"method trim(Str:D: --> Str)\n\nRemove leading and trailing whitespace. It can be used both as a method on\nstrings and as a function. When used as a method it will return the trimmed\nstring. In order to do in-place trimming, one needs to write .=trim\n\n    my $line = '   hello world    ';\n    say '<' ~ $line.trim ~ '>';        # OUTPUT: «<hello world>␤»\n    say '<' ~ trim($line) ~ '>';       # OUTPUT: «<hello world>␤»\n    $line.trim;\n    say '<' ~ $line ~ '>';             # OUTPUT: «<   hello world    >␤»\n    $line.=trim;\n    say '<' ~ $line ~ '>';             # OUTPUT: «<hello world>␤»\n\nSee also trim-trailing and trim-leading."},{"s":{"r":"Seq:D","p":["$limit","*%_"]},"k":"m","m":1,"n":"words","d":"multi method words(Str:D: $limit)\n    multi method words(Str:D:)\n\nReturns a list of non-whitespace bits, i.e. the same as a call to\n$input.comb( / \\S+ /, $limit ) would.\n\nExamples:\n\n    say \"a\\nb\\n\".words.perl;       # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say \"hello world\".words.perl;  # OUTPUT: «(\"hello\", \"world\").Seq␤»\n    say \"foo:bar\".words.perl;      # OUTPUT: «(\"foo:bar\",).Seq␤»\n    say \"foo:bar\\tbaz\".words.perl; # OUTPUT: «(\"foo:bar\", \"baz\").Seq␤»\n\nIt can also be used as a subroutine, turning the first argument into the\ninvocant. $limit is optional, but if it is provided (and not equal to Inf),\nit will return only the first $limit words.\n\n    say words(\"I will be very brief here\", 2); # OUTPUT: «(I will)␤»"},{"m":1,"k":"m","s":{"r":"Seq:D","p":["*%_"]},"d":"multi method words(Str:D: $limit)\n    multi method words(Str:D:)\n\nReturns a list of non-whitespace bits, i.e. the same as a call to\n$input.comb( / \\S+ /, $limit ) would.\n\nExamples:\n\n    say \"a\\nb\\n\".words.perl;       # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say \"hello world\".words.perl;  # OUTPUT: «(\"hello\", \"world\").Seq␤»\n    say \"foo:bar\".words.perl;      # OUTPUT: «(\"foo:bar\",).Seq␤»\n    say \"foo:bar\\tbaz\".words.perl; # OUTPUT: «(\"foo:bar\", \"baz\").Seq␤»\n\nIt can also be used as a subroutine, turning the first argument into the\ninvocant. $limit is optional, but if it is provided (and not equal to Inf),\nit will return only the first $limit words.\n\n    say words(\"I will be very brief here\", 2); # OUTPUT: «(I will)␤»","n":"words"},{"n":"WORDS_AUTODEREF","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Blob:D","p":["Str:D $encoding = \"utf8\"",":$replacement",":$translate-nl = Bool::False",":$strict","*%_"]},"d":"multi method encode(Str:D $encoding = 'utf8', :$replacement, Bool() :$translate-nl = False, :$strict)\n\nReturns a Blob which represents the original string in the given encoding\nand normal form. The actual return type is as specific as possible, so\n$str.encode('UTF-8') returns a utf8 object, $str.encode('ISO-8859-1') a\nbuf8. If :translate-nl is set to True, it will translate newlines from \\n\nto \\n\\r, but only in Windows. $replacement indicates how characters are\ngoing to be replaced in the case they are not available in the current\nencoding, while $strict indicates whether unmapped codepoints will still\ndecode; for instance, codepoint 129 which does not exist in windows-1252.\n\n    my $str = \"Þor is mighty\";\n    say $str.encode(\"ascii\", :replacement( 'Th') ).decode(\"ascii\");\n    # OUTPUT: «Thor is mighty␤»\n\nIn this case, any unknown character is going to be substituted by Th. We\nknow in advance that the character that is not known in the ascii encoding\nis Þ, so we substitute it by its latin equivalent, Th. In the absence of\nany replacement set of characters, :replacement is understood as a Bool:\n\n    say $str.encode(\"ascii\", :replacement).decode(\"ascii\"); # OUTPUT: «?or is mighty␤»\n\n\nIf :replacement is not set or assigned a value, the error Error encoding\nASCII string: could not encode codepoint 222 will be issued (in this case,\nsince þ is codepoint 222).\n\nSince the Blob returned by encode is the original string in normal form,\nand every element of a Blob is a byte, you can obtain the length in bytes\nof a string by calling a method that returns the size of the Blob on it:\n\n    say \"þor\".encode.bytes; # OUTPUT: «4␤»\n    say \"þor\".encode.elems; # OUTPUT: «4␤»","n":"encode"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"NFC:D"},"d":"method NFC(Str:D: --> NFC:D)\n\nReturns a codepoint string in NFC format (Unicode Normalization Form C /\nComposed).","n":"NFC"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"NFD:D"},"d":"method NFD(Str:D: --> NFD:D)\n\nReturns a codepoint string in NFD format (Unicode Normalization Form D /\nDecomposed).","n":"NFD"},{"n":"NFKC","d":"method NFKC(Str:D: --> NFKC:D)\n\nReturns a codepoint string in NFKC format (Unicode Normalization Form KC /\nCompatibility Composed).","s":{"p":["*%_"],"r":"NFKC:D"},"k":"m","m":0},{"s":{"r":"NFKD:D","p":["*%_"]},"k":"m","m":0,"n":"NFKD","d":"method NFKD(Str:D: --> NFKD:D)\n\nReturns a codepoint string in NFKD format (Unicode Normalization Form KD /\nCompatibility Decomposed)."},{"d":"multi method unival(Str:D --> Numeric)\n\nReturns the numeric value that the first codepoint in the invocant\nrepresents, or NaN if it's not numeric.\n\n    say '4'.unival;     # OUTPUT: «4␤»\n    say '¾'.unival;     # OUTPUT: «0.75␤»\n    say 'a'.unival;     # OUTPUT: «NaN␤»","n":"unival","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"multi method univals(Str:D --> List)\n\nReturns a list of numeric values represented by each codepoint in the\ninvocant string, and NaN for non-numeric characters.\n\n    say \"4a¾\".univals;  # OUTPUT: «(4 NaN 0.75)␤»","n":"univals"},{"d":"multi sub    wordcase(Cool $x  --> Str)\n    multi sub    wordcase(Str:D $x --> Str)\n    multi method wordcase(Str:D: :&filter = &tclc, Mu :$where = True --> Str)\n\n\nReturns a string in which &filter has been applied to all the words that\nmatch $where. By default, this means that the first letter of every word is\ncapitalized, and all the other letters lowercased.","n":"wordcase","m":0,"k":"m","s":{"p":[":&filter = { ... }","Mu :$where = Bool::True","*%_"],"r":"Str:D"}},{"n":"trans","d":"multi method trans(Str:D: Pair:D \\what, *%n --> Str)\n    multi method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --> Str)\n\nReplaces one or many characters with one or many characters. Ranges are\nsupported, both for keys and values. Regexes work as keys. In case a list\nof keys and values is used, substrings can be replaced as well. When called\nwith :complement anything but the matched value or range is replaced with a\nsingle value; with :delete the matched characters without corresponding\nreplacement are removed. Combining :complement and :delete will remove\nanything but the matched values, unless replacement characters have been\nspecified, in which case, :delete would be ignored. The adverb :squash will\nreduce repeated matched characters to a single character.\n\nExample:\n\n    my $str = 'say $x<b> && $y<a>';\n    $str.=trans( '<' => '«' );\n    $str.=trans( '<' => '«', '>' => '»' );\n\n    $str.=trans( [ '<'   , '>'   , '&' ] =>\n                 [ '&lt;', '&gt;', '&amp;' ]);\n\n    $str.=trans( ['a'..'y'] => ['A'..'z'] );\n\n    \"abcdefghij\".trans(/<[aeiou]> \\w/ => '');                     # RESULT: «cdgh»\n\n    \"a123b123c\".trans(['a'..'z'] => 'x', :complement);            # RESULT: «axxxbxxxc»\n    \"aaa1123bb123c\".trans('a'..'z' => 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n    \"aaa1123bb123c\".trans('a'..'z' => 'x', :complement, :squash); # RESULT: «aaaxbbxc»\n\nIn general, the strings will have the same length after the substitution:\n\n    say \"a123b123c\".trans('23' => '4');   # OUTPUT: «a144b144c␤»\n    say \"a123b123c\".trans('123' => 'þð'); # OUTPUT: «aþðþbþðþc␤»\n\n:squash and :delete will have the same effect in this case making it a\nstrict substitution:\n\n    say \"a123b123c\".trans('123' => 'þð', :squash); # OUTPUT: «aþðbþðc␤»\n    say \"a123b123c\".trans('123' => 'þð', :delete); # OUTPUT: «aþðbþðc␤»\n\n:delete will also remove non-matched characters from the original string:\n\n    say \"abc\".trans(\"abc\".comb => 1..2, :delete);  # OUTPUT: «12␤»\n\nPlease note that the behavior of the two versions of the multi method is\nslightly different. The first form will transpose only one character if the\norigin is also one character:\n\n    say \"abcd\".trans( \"a\" => \"zz\" );  # OUTPUT: «zbcd␤»\n    say \"abcd\".trans( \"ba\" => \"yz\" ); # OUTPUT: «zycd␤»\n\n\nIn the second case, behavior is as expected, since the origin is more than\none char long. However, if the Pair in the multi method does not have a Str\nas an origin or target, it is handled to the second multi method, and\nbehavior changes:\n\n    say \"abcd\".trans: [\"a\"] => [\"zz\"]; # OUTPUT: «zzbcd␤»\n\nIn this case, neither origin nor target in the Pair are Str; the method\nwith the Pair signature then calls the second, making this call above\nequivalent to \"abcd\".trans: [\"a\"] => [\"zz\"],  (with the comma behind,\nmaking it a Positional, instead of a Pair), resulting in the behavior shown\nas output.","s":{"p":["Pair:D \\what","*%n"],"r":"Str:D"},"k":"m","m":1},{"d":"multi method trans(Str:D: Pair:D \\what, *%n --> Str)\n    multi method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --> Str)\n\nReplaces one or many characters with one or many characters. Ranges are\nsupported, both for keys and values. Regexes work as keys. In case a list\nof keys and values is used, substrings can be replaced as well. When called\nwith :complement anything but the matched value or range is replaced with a\nsingle value; with :delete the matched characters without corresponding\nreplacement are removed. Combining :complement and :delete will remove\nanything but the matched values, unless replacement characters have been\nspecified, in which case, :delete would be ignored. The adverb :squash will\nreduce repeated matched characters to a single character.\n\nExample:\n\n    my $str = 'say $x<b> && $y<a>';\n    $str.=trans( '<' => '«' );\n    $str.=trans( '<' => '«', '>' => '»' );\n\n    $str.=trans( [ '<'   , '>'   , '&' ] =>\n                 [ '&lt;', '&gt;', '&amp;' ]);\n\n    $str.=trans( ['a'..'y'] => ['A'..'z'] );\n\n    \"abcdefghij\".trans(/<[aeiou]> \\w/ => '');                     # RESULT: «cdgh»\n\n    \"a123b123c\".trans(['a'..'z'] => 'x', :complement);            # RESULT: «axxxbxxxc»\n    \"aaa1123bb123c\".trans('a'..'z' => 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n    \"aaa1123bb123c\".trans('a'..'z' => 'x', :complement, :squash); # RESULT: «aaaxbbxc»\n\nIn general, the strings will have the same length after the substitution:\n\n    say \"a123b123c\".trans('23' => '4');   # OUTPUT: «a144b144c␤»\n    say \"a123b123c\".trans('123' => 'þð'); # OUTPUT: «aþðþbþðþc␤»\n\n:squash and :delete will have the same effect in this case making it a\nstrict substitution:\n\n    say \"a123b123c\".trans('123' => 'þð', :squash); # OUTPUT: «aþðbþðc␤»\n    say \"a123b123c\".trans('123' => 'þð', :delete); # OUTPUT: «aþðbþðc␤»\n\n:delete will also remove non-matched characters from the original string:\n\n    say \"abc\".trans(\"abc\".comb => 1..2, :delete);  # OUTPUT: «12␤»\n\nPlease note that the behavior of the two versions of the multi method is\nslightly different. The first form will transpose only one character if the\norigin is also one character:\n\n    say \"abcd\".trans( \"a\" => \"zz\" );  # OUTPUT: «zbcd␤»\n    say \"abcd\".trans( \"ba\" => \"yz\" ); # OUTPUT: «zycd␤»\n\n\nIn the second case, behavior is as expected, since the origin is more than\none char long. However, if the Pair in the multi method does not have a Str\nas an origin or target, it is handled to the second multi method, and\nbehavior changes:\n\n    say \"abcd\".trans: [\"a\"] => [\"zz\"]; # OUTPUT: «zzbcd␤»\n\nIn this case, neither origin nor target in the Pair are Str; the method\nwith the Pair signature then calls the second, making this call above\nequivalent to \"abcd\".trans: [\"a\"] => [\"zz\"],  (with the comma behind,\nmaking it a Positional, instead of a Pair), resulting in the behavior shown\nas output.","n":"trans","m":1,"k":"m","s":{"r":"Str:D","p":["*@changes",":c(:$complement)",":s(:$squash)",":d(:$delete)","*%_"]}},{"s":{"r":"Str:D","p":["*%_"]},"m":0,"k":"m","n":"parse-names","d":"sub    parse-names(Str:D $names  --> Str:D)\n    method parse-names(Str:D $names: --> Str:D)\n\nDEPRECATED. Use uniparse instead. Existed in Rakudo implementation as a\nproof of viability implementation before being renamed and will be removed\nwhen 6.e language is released."},{"s":{"p":["*%_"],"r":"Str:D"},"m":0,"k":"m","n":"uniparse","d":"sub    uniparse(Str:D $names  --> Str:D)\n    method uniparse(Str:D $names: --> Str:D)\n\nTakes string with comma-separated Unicode names of characters and returns a\nstring composed of those characters. Will fail if any of the characters'\nnames are empty or not recognized. Whitespace around character names is\nignored.\n\n    say \"I {uniparse 'TWO HEARTS'} Perl\"; # OUTPUT: «I \uD83D\uDC95 Perl␤»\n    'TWO HEARTS, BUTTERFLY'.uniparse.say; # OUTPUT: «\uD83D\uDC95\uD83E\uDD8B␤»\n\nNote that unlike \\c[...] construct available in string interpolation,\nuniparse does not accept decimal numerical values. Use chr routine to\nconvert those:\n\n    say \"\\c[1337]\"; # OUTPUT: «Թ␤»\n    say '1337'.chr; # OUTPUT: «Թ␤»\n\nNote: before being standardized in 2017.12, this routine was known under\nits working name of parse-names. This denomination will be removed in the\n6.e version."},{"m":1,"k":"m","s":{"r":"Mu","p":["$steps where { ... }","*%_"]},"d":"multi method indent(Int $steps where { $_ == 0 } )\n    multi method indent(Int $steps where { $_ > 0  } )\n    multi method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )\n\nIndents each line of the string by $steps. If $steps is negative, it\noutdents instead. If $steps is *, then the string is outdented to the\nmargin:\n\n    \"  indented by 2 spaces\\n    indented even more\".indent(*)\n        eq \"indented by 2 spaces\\n  indented even more\"","n":"indent"},{"d":"multi method indent(Int $steps where { $_ == 0 } )\n    multi method indent(Int $steps where { $_ > 0  } )\n    multi method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )\n\nIndents each line of the string by $steps. If $steps is negative, it\noutdents instead. If $steps is *, then the string is outdented to the\nmargin:\n\n    \"  indented by 2 spaces\\n    indented even more\".indent(*)\n        eq \"indented by 2 spaces\\n  indented even more\"","n":"indent","k":"m","m":1,"s":{"r":"Mu","p":["$steps where { ... }","*%_"]}},{"s":{"p":["$steps where { ... }","*%_"],"r":"Mu"},"m":1,"k":"m","n":"indent","d":"multi method indent(Int $steps where { $_ == 0 } )\n    multi method indent(Int $steps where { $_ > 0  } )\n    multi method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )\n\nIndents each line of the string by $steps. If $steps is negative, it\noutdents instead. If $steps is *, then the string is outdented to the\nmargin:\n\n    \"  indented by 2 spaces\\n    indented even more\".indent(*)\n        eq \"indented by 2 spaces\\n  indented even more\""},{"n":"indent","d":"multi method indent(Int $steps where { $_ == 0 } )\n    multi method indent(Int $steps where { $_ > 0  } )\n    multi method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )\n\nIndents each line of the string by $steps. If $steps is negative, it\noutdents instead. If $steps is *, then the string is outdented to the\nmargin:\n\n    \"  indented by 2 spaces\\n    indented even more\".indent(*)\n        eq \"indented by 2 spaces\\n  indented even more\"","s":{"p":["Whatever $steps","*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Int:D"},"n":"codes"},{"s":{"p":["*%_"],"r":"Int:D"},"m":1,"k":"m","n":"codes"},{"d":"multi sub    chars(Cool  $x --> Int:D)\n    multi sub    chars(Str:D $x --> Int:D)\n    multi sub    chars(str   $x --> int)\n    multi method chars(Str:D:   --> Int:D)\n\nReturns the number of characters in the string in graphemes. On the JVM,\nthis currently erroneously returns the number of codepoints instead.","n":"chars","m":1,"k":"m","s":{"p":["*%_"],"r":"Int:D"}},{"n":"chars","d":"multi sub    chars(Cool  $x --> Int:D)\n    multi sub    chars(Str:D $x --> Int:D)\n    multi sub    chars(str   $x --> int)\n    multi method chars(Str:D:   --> Int:D)\n\nReturns the number of characters in the string in graphemes. On the JVM,\nthis currently erroneously returns the number of codepoints instead.","s":{"r":"Int:D","p":["*%_"]},"m":1,"k":"m"},{"s":{"p":["*%_"],"r":"Str:D"},"m":1,"k":"m","n":"uc","d":"multi sub    uc(Str:D  --> Str:D)\n    multi method uc(Str:D: --> Str:D)\n\nReturns an uppercase version of the string."},{"s":{"r":"Str:D","p":["*%_"]},"m":1,"k":"m","n":"uc","d":"multi sub    uc(Str:D  --> Str:D)\n    multi method uc(Str:D: --> Str:D)\n\nReturns an uppercase version of the string."},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Str:D"},"d":"Defined as:\n\n    multi sub    lc(Str:D  --> Str:D)\n    multi method lc(Str:D: --> Str:D)\n\nReturns a lower-case version of the string.\n\nExamples:\n\n    lc(\"A\"); # RESULT: «\"a\"»\n    \"A\".lc;  # RESULT: «\"a\"»","n":"lc"},{"d":"Defined as:\n\n    multi sub    lc(Str:D  --> Str:D)\n    multi method lc(Str:D: --> Str:D)\n\nReturns a lower-case version of the string.\n\nExamples:\n\n    lc(\"A\"); # RESULT: «\"a\"»\n    \"A\".lc;  # RESULT: «\"a\"»","n":"lc","m":1,"k":"m","s":{"r":"Str:D","p":["*%_"]}},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Str:D"},"d":"multi sub    tc(Str:D  --> Str:D)\n    multi method tc(Str:D: --> Str:D)\n\nDoes a Unicode \"titlecase\" operation, that is changes the first character\nin the string to title case, or to upper case if the character has no title\ncase mapping","n":"tc"},{"n":"tc","d":"multi sub    tc(Str:D  --> Str:D)\n    multi method tc(Str:D: --> Str:D)\n\nDoes a Unicode \"titlecase\" operation, that is changes the first character\nin the string to title case, or to upper case if the character has no title\ncase mapping","s":{"r":"Str:D","p":["*%_"]},"k":"m","m":1},{"d":"multi sub    fc(Str:D  --> Str:D)\n    multi method fc(Str:D: --> Str:D)\n\nDoes a Unicode \"fold case\" operation suitable for doing caseless string\ncomparisons. (In general, the returned string is unlikely to be useful for\nany purpose other than comparison.)","n":"fc","m":1,"k":"m","s":{"r":"Str:D","p":["*%_"]}},{"n":"fc","d":"multi sub    fc(Str:D  --> Str:D)\n    multi method fc(Str:D: --> Str:D)\n\nDoes a Unicode \"fold case\" operation suitable for doing caseless string\ncomparisons. (In general, the returned string is unlikely to be useful for\nany purpose other than comparison.)","s":{"r":"Str:D","p":["*%_"]},"k":"m","m":1},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Str:D"},"d":"multi sub    tclc(Str:D  --> Str:D)\n    multi method tclc(Str:D: --> Str:D)\n\nTurns the first character to title case, and all other characters to lower\ncase","n":"tclc"},{"s":{"p":["*%_"],"r":"Str:D"},"k":"m","m":1,"n":"tclc","d":"multi sub    tclc(Str:D  --> Str:D)\n    multi method tclc(Str:D: --> Str:D)\n\nTurns the first character to title case, and all other characters to lower\ncase"},{"d":"multi sub    flip(Str:D  --> Str:D)\n    multi method flip(Str:D: --> Str:D)\n\nReturns the string reversed character by character.\n\nExamples:\n\n    \"Perl\".flip;  # RESULT: «lreP»\n    \"ABBA\".flip;  # RESULT: «ABBA»","n":"flip","k":"m","m":1,"s":{"r":"Str:D","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Str:D"},"k":"m","m":1,"n":"flip","d":"multi sub    flip(Str:D  --> Str:D)\n    multi method flip(Str:D: --> Str:D)\n\nReturns the string reversed character by character.\n\nExamples:\n\n    \"Perl\".flip;  # RESULT: «lreP»\n    \"ABBA\".flip;  # RESULT: «ABBA»"},{"n":"ord","d":"multi sub    ord(Str:D  --> Int:D)\n    multi method ord(Str:D: --> Int:D)\n\nReturns the codepoint number of the base characters of the first grapheme\nin the string.\n\nExample:\n\n    ord(\"A\"); # 65\n    \"«\".ord;  # 171","s":{"r":"Int:D","p":["*%_"]},"m":1,"k":"m"},{"s":{"p":["*%_"],"r":"Nil"},"k":"m","m":1,"n":"ord","d":"multi sub    ord(Str:D  --> Int:D)\n    multi method ord(Str:D: --> Int:D)\n\nReturns the codepoint number of the base characters of the first grapheme\nin the string.\n\nExample:\n\n    ord(\"A\"); # 65\n    \"«\".ord;  # 171"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"},{"n":"!match-x","m":0,"k":"m","s":{"p":["\\slash","\\iterator","$x","*%_"],"r":"Mu"}},{"s":{"p":["\\slash","\\cursor","str $name","$value","\\opts","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!match-cursor"},{"n":"!match-pattern","m":0,"k":"m","s":{"r":"Mu","p":["\\slash","$pattern","str $name","$value","\\opts","*%_"]}},{"n":"!match-nth-int","s":{"r":"Mu","p":["\\slash","\\cursor","\\move","\\post","int $nth","*%_"]},"k":"m","m":0},{"n":"!match-x-range","m":0,"k":"m","s":{"p":["\\slash","\\iterator","$min","$max","*%_"],"r":"Mu"}},{"n":"!SUBST","s":{"p":["\\caller_dollar_slash","$matcher","$replacement",":global(:$g)",":ii(:$samecase)",":ss(:$samespace)",":mm(:$samemark)","*%options"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["\\limit","*%_"],"r":"Nil"},"n":"!ensure-limit-sanity"},{"n":"!match-nth-range","s":{"r":"Mu","p":["\\slash","\\iterator","$min","$max","*%_"]},"k":"m","m":0},{"n":"!match-nth-iterator","k":"m","m":0,"s":{"r":"Mu","p":["\\slash","\\source","\\indexes","*%_"]}},{"s":{"p":["\\slash","\\cursor","\\move","\\post","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!match-list"},{"m":0,"k":"m","s":{"p":["\\slash","\\cursor","\\as","*%_"],"r":"Mu"},"n":"!match-as-one"},{"s":{"p":["$pos","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!RINDEX-OOR"},{"n":"!INDEX-OOR","k":"m","m":0,"s":{"r":"Mu","p":["$pos","*%_"]}},{"n":"!match-nth","m":0,"k":"m","s":{"r":"Mu","p":["\\slash","\\cursor","\\move","\\post","$nth","%opts","*%_"]}},{"m":0,"k":"m","s":{"p":["\\slash","\\cursor","\\move","int $tail","*%_"],"r":"Mu"},"n":"!match-nth-tail"},{"n":"!match-last","m":0,"k":"m","s":{"r":"Mu","p":["\\slash","\\cursor","\\move","*%_"]}},{"s":{"p":["\\matches","$replacement","\\cds","\\SDS","\\word_by_word","\\space","\\case","\\mark","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!APPLY-MATCHES"},{"k":"m","m":0,"s":{"r":"Mu","p":["\\slash","\\cursor","*%_"]},"n":"!match-one"},{"m":0,"k":"m","s":{"r":"Mu","p":["\\v","\\k","\\kv","\\p","*%_"]},"n":"!ensure-split-sanity"}],"k":"c","b":"C"},{"t":"Str::CURSOR-ITERATOR","a":[{"k":"v","n":"$!cursor","t":"Mu"},{"k":"v","t":"Mu","n":"$!move"}],"n":"Str::CURSOR-ITERATOR","k":"c","m":[{"n":"new","m":0,"k":"m","s":{"r":"Mu","p":["\\c","\\t","*%_"]}},{"n":"pull-one","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"skip-one","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["\\target","*%_"],"r":"Mu"},"n":"push-all"},{"k":"m","m":0,"s":{"p":["\\cursor","\\move","*%_"],"r":"Mu"},"n":"!SET-SELF"}],"mro":["Iterator","Any"],"b":"A"},{"b":"A","a":[{"t":"Mu","n":"$!cursor","k":"v"},{"t":"Mu","n":"$!move","k":"v"},{"k":"v","t":"Mu","n":"$!post"}],"t":"Str::POST-ITERATOR","n":"Str::POST-ITERATOR","m":[{"s":{"r":"Mu","p":["\\c","\\t","\\p","*%_"]},"k":"m","m":0,"n":"new"},{"n":"pull-one","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"skip-one","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"push-all","s":{"r":"Mu","p":["\\target","*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["\\cursor","\\move","\\post","*%_"]},"n":"!SET-SELF"}],"k":"c","mro":["Iterator","Any"]},{"mro":["Scheduler","Any"],"m":[{"n":"handle_uncaught","m":0,"k":"m","s":{"r":"Mu","p":["$exception","*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["&code",":$at",":$in",":$every",":$times = 1",":&catch is copy","*%_"]},"n":"cue"},{"k":"m","m":0,"s":{"r":"Int","p":["*%_"]},"n":"loads"},{"n":"uncaught_handler","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"CurrentThreadScheduler","a":[{"t":"Callable","n":"&.uncaught_handler","k":"v"}],"d":"TITLE\nclass CurrentThreadScheduler\n\nSUBTITLE\nScheduler that synchronously executes code on the current thread\n\n    class CurrentThreadScheduler does Scheduler {}\n\n\nCurrentThreadScheduler executes tasks on the current threads. This means\nthat method cue blocks until the code has finished executing.","t":"CurrentThreadScheduler","b":"A"},{"t":"Sub+{is-pure}","n":"&floor","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["$a"]},"n":"floor"},{"n":"floor","s":{"p":["Numeric $a"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"num","p":["num $a"]},"n":"floor"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&cross"},{"s":{"r":"Seq:D","p":["+\\lol is raw",":&with!"]},"m":1,"k":"s","n":"infix:<X>"},{"n":"infix:<X>","s":{"r":"Seq:D","p":["+\\lol is raw"]},"m":1,"k":"s"},{"k":"v","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:«(<)»"},{"s":{"r":"Bool:D","p":["Setty:D \\a","Setty:D \\b"]},"m":1,"k":"s","n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"p":["Setty:D \\a","Mixy:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Bool:D"},"n":"infix:«(<)»"},{"s":{"r":"Bool:D","p":["Setty:D \\a","\\b"]},"k":"s","m":1,"n":"infix:«(<)»"},{"s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«(<)»"},{"m":1,"k":"s","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Bool:D"},"n":"infix:«(<)»"},{"n":"infix:«(<)»","m":1,"k":"s","s":{"r":"Bool:D","p":["Mixy:D \\a","\\b"]}},{"m":1,"k":"s","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Bool:D"},"n":"infix:«(<)»"},{"n":"infix:«(<)»","m":1,"k":"s","s":{"p":["Baggy:D \\a","Baggy:D \\b"],"r":"Bool:D"}},{"n":"infix:«(<)»","k":"s","m":1,"s":{"r":"Bool:D","p":["Baggy:D \\a","\\b"]}},{"s":{"r":"Bool:D","p":["\\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:«(<)»"},{"s":{"p":["\\a","Baggy:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"r":"Mu","p":["Failure:D \\a","$"]},"m":1,"k":"s"},{"n":"infix:«(<)»","s":{"r":"Mu","p":["$","Failure:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Bool:D"},"n":"infix:«(<)»"},{"a":[{"k":"v","n":"$.text","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"JSONException","n":"JSONException","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"text"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"b":"A"},{"b":"A","n":"NFKC","d":"TITLE\nclass NFKC\n\nSUBTITLE\nCodepoint string in Normal Form KC (compatibility composed)\n\n    class NFKC is Uni {}\n\nA Codepoint string in Unicode Normalization Form KC. It is created by\nCompatibility Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15.","t":"NFKC","mro":["Stringy","Positional[uint32]","Uni"],"k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"NFKC"},{"n":"new","s":{"p":["|"],"r":"Mu"},"m":0,"k":"m"}]},{"n":"&infix:<gcd>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"infix:<gcd>"},{"m":1,"k":"s","s":{"p":["Int:D $x"],"r":"Mu"},"n":"infix:<gcd>"},{"n":"infix:<gcd>","s":{"r":"Mu","p":["\\a","\\b"]},"k":"s","m":1},{"n":"infix:<gcd>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"m":1,"k":"s"},{"s":{"r":"int","p":["int $a","int $b"]},"m":1,"k":"s","n":"infix:<gcd>"},{"n":"&chrs","t":"Sub","k":"v"},{"m":1,"k":"s","s":{"r":"Str:D","p":["*@c"]},"n":"chrs"},{"k":"v","t":"Sub","n":"&val"},{"n":"val","s":{"p":["*@maybevals"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Mu $"],"r":"Mu"},"n":"val"},{"n":"val","s":{"p":["List:D $maybevals"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Pair:D \\ww-thing"],"r":"Mu"},"m":1,"k":"s","n":"val"},{"n":"val","k":"s","m":1,"s":{"r":"Mu","p":["\\one-thing"]}},{"s":{"p":["Str:D $MAYBEVAL",":$val-or-fail"],"r":"Mu"},"k":"s","m":1,"n":"val"},{"b":"A","mro":["Any"],"m":[{"n":"RAKUDO_VERBOSE_STACKFRAME","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["$pos","*%_"]},"n":"AT-POS"},{"s":{"p":["Int $idx is copy = 0",":$named",":$noproto",":$setting","*%_"],"r":"Mu"},"k":"m","m":0,"n":"next-interesting-index","d":"Defined as:\n\n    method next-interesting-index(Backtrace:D: Int $idx = 0, :$named, :$noproto, :$setting)\n\nReturns the index of the next interesting frame, once hidden and other\nsettings are taken into account. $named will decide whether to printed only\nthose with a name, $noproto will hide protos, and $setting will hide those\nare considered setting.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.next-interesting-index;           # OUTPUT: «2␤»\n    say $!.backtrace.next-interesting-index( :named ); #  OUTPUT: «4␤»"},{"d":"Defined as:\n\n    method outer-caller-idx(Backtrace:D: Int $startidx)\n\nReturns as a list the index of the frames that called the current one.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.outer-caller-idx( 4 ); # OUTPUT: «[6]␤»","n":"outer-caller-idx","m":0,"k":"m","s":{"p":["Int $startidx","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":[":$oneline","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method nice(Backtrace:D: :$oneline)\n\nReturns the backtrace as a list of interesting frames. If :$oneline is set,\nwill stop after the first frame.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.nice( :oneline ) if $!;\n    # OUTPUT: «  in sub zipi at /tmp/... line 1␤␤»","n":"nice"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"first-none-setting-line"},{"d":"Defined as:\n\n    method concise(Backtrace:D:)\n\nReturns a concise string representation of the backtrace, filtered by\n!.is-hidden && .is-routine && !.is-setting.\n\nThis program:\n\n    sub inner { say Backtrace.new.concise }\n    sub outer { inner; }\n    outer;\n\nresults in:\n\n    in sub inner at test.p6 line 1\n    in sub outer at test.p6 line 2","n":"concise","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"full","d":"Defined as:\n\n    multi method full(Backtrace:D:)\n\nReturns a full string representation of the backtrace, including hidden\nframes, compiler-specific frames, and those from the setting.\n\n    my $backtrace = Backtrace.new;\n    say $backtrace.full;","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"summary","d":"Defined as:\n\n    method summary(Backtrace:D: --> Str:D)\n\nReturns a summary string representation of the backtrace, filtered by\n!.is-hidden && (.is-routine || !.is-setting).\n\nThis program:\n\n    sub inner { say Backtrace.new.summary }\n    sub outer { inner; }\n    outer;\n\nresults in:\n\n    in method new at SETTING::src/core/Backtrace.pm6 line 85\n    in sub inner at test.p6 line 1\n    in sub outer at test.p6 line 2\n    in block <unit> at test.p6 line 3","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-runtime"},{"s":{"p":["$!bt","$!bt-next","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!SET-SELF"}],"k":"c","n":"Backtrace","d":"TITLE\nclass Backtrace\n\nSUBTITLE\nSnapshot of the dynamic call stack\n\n    class Backtrace {}\n\nA backtrace contains the dynamic call stack, usually leading up to a point\nwhere an exception was thrown, and is a List of Backtrace::Frame objects.\nIts default stringification excludes backtrace frames that are deemed\nunnecessary or confusing; for example routines like &die are hidden by\ndefault. Being a list, you can also access individual elements.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try {\n        zipi;\n    }\n    if ($!) {\n        say $!.backtrace[*-1].perl;\n    }\n\n\nThis will print the last frame in the list, pointing at the line where it's\nhappened.\n\n","a":[{"k":"v","n":"$!bt","t":"Mu"},{"n":"$!frames","t":"Mu","k":"v"},{"n":"$!bt-next","t":"Int","k":"v"}],"t":"Backtrace"},{"b":"A","n":"Backtrace::Frame","d":"TITLE\nclass Backtrace::Frame\n\nSUBTITLE\nSingle frame of a Backtrace\n\n    class Backtrace::Frame { }\n\nA single backtrace frame. It identifies a location in the source code.\n\n","a":[{"n":"$.file","t":"Str","k":"v"},{"k":"v","n":"$.line","t":"Int"},{"k":"v","t":"Mu","n":"$.code"},{"k":"v","t":"Str","n":"$.subname"}],"t":"Backtrace::Frame","mro":["Any"],"m":[{"n":"subtype","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"package"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-hidden","d":"Defined as:\n\n    method is-hidden(Backtrace::Frame:D --> Bool:D)\n\nReturns True if the frame is marked as hidden with the is\nhidden-from-backtrace trait.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-hidden;"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method is-routine(Backtrace::Frame:D --> Bool:D)\n\nReturn True if the frame points into a routine (and not into a mere\nBlock).\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-routine;","n":"is-routine"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method is-setting(Backtrace::Frame:D --> Bool:D)\n\nReturns True if the frame is part of a setting.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-setting; # OUTPUT: «True␤»","n":"is-setting"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"file","d":"Defined as:\n\n    method file(Backtrace::Frame:D --> Str)\n\nReturns the file name.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.file;"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line","d":"Defined as:\n\n    method line(Backtrace::Frame:D --> Int)\n\nReturns the line number (line numbers start counting from 1).\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.line;"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method code(Backtrace::Frame:D)\n\nReturns the code object into which .file and .line point, if available.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.code;","n":"code"},{"d":"Defined as:\n\n    method subname(Backtrace::Frame:D --> Str)\n\nReturns the name of the enclosing subroutine.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.subname;","n":"subname","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"},{"n":"!SET-SELF","k":"m","m":0,"s":{"r":"Mu","p":["$!file","$!line","\\code","$!subname","*%_"]}}],"k":"c"},{"n":"&infix:«=>»","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"r":"Mu","p":["Mu $key","Mu \\value"]},"k":"s","m":1,"n":"infix:«=>»"},{"mro":["Callable","Code"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"of"},{"n":"returns","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"add_phaser","k":"m","m":0,"s":{"r":"Nil","p":["Str:D \\name","&block","*%_"]}},{"n":"fire_if_phasers","s":{"p":["Str $name","*%_"],"r":"Nil"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Nil","p":["Str $name","*%_"]},"n":"fire_phasers"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"has-phasers"},{"n":"has-phaser","k":"m","m":0,"s":{"r":"Mu","p":["Str:D \\name","*%_"]}},{"n":"phasers","k":"m","m":0,"s":{"r":"Mu","p":["Str:D $name","*%_"]}},{"n":"WHY","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Nil","p":["$why","*%_"]},"n":"set_why"}],"n":"Block","a":[{"t":"Mu","n":"$!why","k":"v"},{"k":"v","t":"Code","n":"$!do"},{"n":"$!signature","t":"Signature","k":"v"},{"k":"v","t":"List","n":"@!compstuff"}],"d":"TITLE\nclass Block\n\nSUBTITLE\nCode object with its own lexical scope\n\n    class Block is Code { }\n\nA Block is a code object meant for small-scale code reuse. A block is\ncreated syntactically by a list of statements enclosed in curly braces.\n\nWithout an explicit signature or placeholder arguments, a block has $_ as a\npositional argument\n\n    my $block = { uc $_; };\n    say $block.^name;           # OUTPUT: «Block␤»\n    say $block('hello');        # OUTPUT: «HELLO␤»\n\nA block can have a Signature between ->  or <->  and the block:\n\n    my $add = -> $a, $b = 2 { $a + $b };\n    say $add(40);               # OUTPUT: «42␤»\n\nIf the signature is introduced with <-> , then the parameters are marked as\nrw by default: \n\n    my $swap = <-> $a, $b { ($a, $b) = ($b, $a) };\n    my ($a, $b) = (2, 4);\n    $swap($a, $b);\n    say $a;                     # OUTPUT: «4␤»\n\nBlocks that aren't of type Routine (which is a subclass of Block) are\ntransparent to return.\n\n    sub f() {\n        say <a b c>.map: { return 42 };\n                       #   ^^^^^^   exits &f, not just the block\n    }\n\nThe last statement is the implicit return value of the block.\n\n    say {1}.(); # OUTPUT: «1␤»\n\nBare blocks are automatically executed in the order they appear:\n\n    say 1;                # OUTPUT: «1␤»\n    {\n        say 2;            # OUTPUT: «2␤»; executed directly, not a Block object\n    }\n    say 3;                # OUTPUT: «3␤»","t":"Block","b":"A"},{"n":"&asech","t":"Sub+{is-pure}","k":"v"},{"m":1,"k":"s","s":{"p":["Numeric \\x"],"r":"Mu"},"n":"asech"},{"m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"},"n":"asech"},{"n":"asech","k":"s","m":1,"s":{"r":"num","p":["num $x"]}},{"k":"v","t":"Sub","n":"&return-rw"},{"k":"s","m":1,"s":{"p":[],"r":"Nil"},"n":"return-rw"},{"n":"return-rw","s":{"p":["Mu \\x"],"r":"Nil"},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["**@x is raw"],"r":"Nil"},"n":"return-rw"},{"k":"v","n":"&atomic-add-fetch","t":"Sub"},{"s":{"r":"atomicint","p":["atomicint $target is rw","int $add"]},"m":1,"k":"s","n":"atomic-add-fetch"},{"k":"s","m":1,"s":{"r":"atomicint","p":["atomicint $target is rw","Int:D $add"]},"n":"atomic-add-fetch"},{"k":"s","m":1,"s":{"r":"atomicint","p":["atomicint $target is rw","$add"]},"n":"atomic-add-fetch"},{"t":"Sub","n":"&duckmap","k":"v"},{"s":{"r":"Mu","p":["\\op","\\obj"]},"m":1,"k":"s","n":"duckmap"},{"n":"duckmap","s":{"p":["\\op","Associative \\h"],"r":"Mu"},"m":1,"k":"s"},{"t":"Sub","n":"&put","k":"v"},{"n":"put","s":{"p":[],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Junction:D \\j"],"r":"Mu"},"m":1,"k":"s","n":"put"},{"n":"put","s":{"r":"Mu","p":["Str:D \\x"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["\\x"],"r":"Mu"},"n":"put"},{"n":"put","k":"s","m":1,"s":{"p":["**@args is raw"],"r":"Mu"}},{"b":"C","t":"Int","n":"UINT64_UPPER","k":"c","mro":["Real","Numeric","Cool"]},{"mro":["Any"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"DEPRECATIONS"},{"n":"report","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"n":"report"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"file"},{"n":"type","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"package","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"name"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"alternative"},{"n":"callsites","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"from","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"removed","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"n":"Deprecation","t":"Deprecation","a":[{"t":"str","n":"$.file","k":"v"},{"k":"v","n":"$.type","t":"str"},{"t":"str","n":"$.package","k":"v"},{"k":"v","t":"str","n":"$.name"},{"n":"$.alternative","t":"str","k":"v"},{"k":"v","n":"%.callsites","t":"Associative"},{"k":"v","n":"$.from","t":"Version"},{"k":"v","n":"$.removed","t":"Version"}],"b":"A"},{"b":"A","n":"Distro","t":"Distro","a":[{"k":"v","t":"Str","n":"$.release"},{"k":"v","t":"Bool","n":"$.is-win"},{"t":"Str","n":"$.path-sep","k":"v"},{"k":"v","n":"$.name","t":"Str"},{"k":"v","t":"Str","n":"$.auth"},{"n":"$.version","t":"Version","k":"v"},{"n":"$.signature","t":"Blob","k":"v"},{"t":"Str","n":"$.desc","k":"v"}],"d":"TITLE\nclass Distro\n\nSUBTITLE\nDistribution related information\n\n    class Distro does Systemic { }\n\nBuilt-in class for providing distribution related information. Usually\naccessed through the $*DISTRO dynamic variable.\n\n","mro":["Systemic","Any"],"m":[{"n":"BUILD","s":{"p":[":$name",":$version",":release($!release)",":auth($!auth)",":path-sep($!path-sep)",":signature($!signature) = Blob",":desc($!desc) = Str","*%_"],"r":"Nil"},"k":"s","m":0},{"n":"cur-sep","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Instance method returning the release information of the Distro object.\nDies if the release information could not be established.","n":"release"},{"d":"Instance method returning a Bool indicating whether the distribution is a\nversion of the Windows operating system.","n":"is-win","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Instance method returning the string that can be used to delimit elements\nin a path specification.","n":"path-sep"},{"n":"name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"auth","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"version","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"signature","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"desc","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c"},{"k":"v","t":"Sub","n":"&produce"},{"m":1,"k":"s","s":{"p":["&with","+\\list is raw"],"r":"Mu"},"n":"produce"},{"n":"&infix:<|>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<|>","s":{"r":"Mu","p":["+\\values is raw"]},"k":"s","m":1},{"k":"v","t":"Sub","n":"&callwith"},{"k":"s","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"n":"callwith"},{"k":"v","t":"Sub","n":"&uniparse"},{"m":1,"k":"s","s":{"r":"Str:D","p":["Str:D \\names"]},"n":"uniparse"},{"k":"v","t":"Sub","n":"&prefix:<let>"},{"n":"prefix:<let>","s":{"p":["Mu \\cont"],"r":"Mu"},"k":"s","m":0},{"k":"v","n":"&postfix:<-->","t":"Sub+{Precedence}"},{"s":{"r":"Mu","p":["Mu:D $a is rw"]},"k":"s","m":1,"n":"postfix:<-->"},{"s":{"p":["Mu:U $a is rw"],"r":"Mu"},"k":"s","m":1,"n":"postfix:<-->"},{"n":"postfix:<-->","k":"s","m":1,"s":{"r":"Int:D","p":["Int:D $a is rw"]}},{"n":"postfix:<-->","s":{"r":"int","p":["int $a is rw"]},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":["Bool:U $a is rw"]},"n":"postfix:<-->"},{"n":"postfix:<-->","m":1,"k":"s","s":{"p":["Bool:D $a is rw"],"r":"Mu"}},{"s":{"r":"Mu","p":["Num:D $a is rw"]},"k":"s","m":1,"n":"postfix:<-->"},{"n":"postfix:<-->","k":"s","m":1,"s":{"p":["Num:U $a is rw"],"r":"Num"}},{"n":"postfix:<-->","m":1,"k":"s","s":{"r":"num","p":["num $a is rw"]}},{"k":"v","t":"Sub","n":"&mkdir"},{"n":"mkdir","k":"s","m":1,"s":{"r":"Mu","p":["$path","$mode = 511"]}},{"b":"C","d":"TITLE\nclass NumStr\n\nSUBTITLE\nDual value floating-point number and string\n\n    class NumStr is Num is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1e0>; say $f.^name; # OUTPUT: «NumStr␤»\n\nAs a subclass of both Num and Str, a NumStr will be accepted where either\nis expected. However, NumStr does not share object identity with Num- or\nStr-only variants:\n\n    my $num-str = <42e10>;\n    my Num $num = $num-str; # OK!\n    my Str $str = $num-str; # OK!\n    say 42e10 ∈ <42e10  55  1>; # False; ∈ operator cares about object identity\n\n","t":"NumStr","n":"NumStr","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["Num $n","Str $s","*%_"]},"d":"method new(Num $i, Str $s)\n\nThe constructor requires both the Num and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = NumStr.new(42.1e0, \"forty two and a bit\");\n    say +$f; # OUTPUT: «42.1␤»\n    say ~$f; # OUTPUT: «\"forty two and a bit\"␤»","n":"new"},{"n":"Num","d":"method Num\n\nReturns the Num value of the NumStr.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["Real","Numeric","Stringy","Num","Str"]},{"t":"Sub+{is-pure}","n":"&sign","k":"v"},{"s":{"p":["Numeric \\x"],"r":"Mu"},"m":1,"k":"s","n":"sign"},{"n":"sign","k":"s","m":1,"s":{"p":["Cool \\x"],"r":"Mu"}},{"t":"Sub+{Precedence}","n":"&prefix:<-->","k":"v"},{"k":"s","m":1,"s":{"p":["Mu:D $a is rw"],"r":"Mu"},"n":"prefix:<-->"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $a is rw"]},"n":"prefix:<-->"},{"s":{"r":"Int:D","p":["Int:D $a is rw"]},"m":1,"k":"s","n":"prefix:<-->"},{"n":"prefix:<-->","k":"s","m":1,"s":{"p":["int $a is rw"],"r":"int"}},{"k":"s","m":1,"s":{"p":["Bool $a is rw"],"r":"Mu"},"n":"prefix:<-->"},{"s":{"r":"Mu","p":["Num:D $a is rw"]},"k":"s","m":1,"n":"prefix:<-->"},{"n":"prefix:<-->","k":"s","m":1,"s":{"r":"Mu","p":["Num:U $a is rw"]}},{"n":"prefix:<-->","m":1,"k":"s","s":{"r":"num","p":["num $a is rw"]}},{"k":"v","n":"&infix:«~<»","t":"Sub"},{"s":{"p":["Str:D \\a","Int:D \\b"],"r":"Str:D"},"m":1,"k":"s","n":"infix:«~<»"},{"s":{"p":["str $a","int $b"],"r":"Mu"},"m":1,"k":"s","n":"infix:«~<»"},{"t":"Sub","n":"&open","k":"v"},{"n":"open","s":{"r":"Mu","p":["$path","|c is raw"]},"k":"s","m":1},{"n":"Label","a":[{"t":"Str","n":"$!name","k":"v"},{"k":"v","t":"Str","n":"$!file"},{"k":"v","t":"Int","n":"$!line"},{"k":"v","n":"$!prematch","t":"Str"},{"n":"$!postmatch","t":"Str","k":"v"}],"d":"TITLE\nclass Label\n\nSUBTITLE\nTagged location in the source code\n\n    class Label {}\n\nLabels are used in Raku to tag loops so that you can specify the one you\nwant to jump to with statements such as last. You can use it to jump out of\nloops and get to outer ones, instead of just exiting the current loop or\ngoing to the statement before.\n\n    USERS:          # the label\n    for @users -> $u {\n        for $u.pets -> $pet {\n            # usage of a label\n            next USERS if $pet.barks;\n        }\n        say \"None of {$u}'s pets barks\";\n    }\n    say USERS.^name;        # OUTPUT: «Label␤»\n\n\nThose label are objects of type Label, as shown in the last statement.\nLabels can be used in any loop construct, as long as they appear right\nbefore the loop statement.\n\n    my $x = 0;\n    my $y = 0;\n    my $t = '';\n    A: while $x++ < 2 {\n        $t ~= \"A$x\";\n        B: while $y++ < 2 {\n            $t ~= \"B$y\";\n            redo A if $y++ == 1;\n            last A\n        }\n    }\n    say $t; # OUTPUT: «A1B1A1A2»\n\n\nPutting them on the line before the loop or the same line is optional.\nLabels must follow the syntax of ordinary identifiers, although\ntraditionally we will use the latin alphabet in uppercase so that they\nstand out in the source. You can use, however, other alphabets like here:\n\n    駱駝道: while True {\n      say 駱駝道.name;\n      last 駱駝道;\n    }\n\n","t":"Label","mro":["Any"],"m":[{"m":0,"k":"m","s":{"p":[":$name",":$line",":$prematch",":$postmatch","*%_"],"r":"Mu"},"n":"new"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method name()\n\nNot terribly useful, returns the name of the defined label:\n\n    A: while True {\n      say A.name; # OUTPUT: «A»\n      last A;\n    }","n":"name"},{"n":"goto","s":{"p":["*@","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*@","*%_"]},"k":"m","m":0,"n":"leave"},{"n":"Int","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method next(Label:)\n\nBegin the next iteration of the loop associated with the label.\n\n    MY-LABEL:\n    for 1..10 {\n        next MY-LABEL if $_ < 5;\n        print \"$_ \";\n    }\n\n    # OUTPUT: «5 6 7 8 9 10 »","n":"next"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"redo","d":"Defined as:\n\n    method redo(Label:)\n\nRepeat the same iteration of the loop associated with the label.\n\n    my $has-repeated = False;\n\n    MY-LABEL:\n    for 1..10 {\n        print \"$_ \";\n        if $_ == 5 {\n            LEAVE $has-repeated = True;\n            redo MY-LABEL unless $has-repeated;\n        }\n    }\n\n    # OUTPUT: «1 2 3 4 5 5 6 7 8 9 10 »"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method last(Label:)\n\nTerminate the execution of the loop associated with the label.\n\n    MY-LABEL:\n    for 1..10 {\n        last MY-LABEL if $_ > 5;\n        print \"$_ \";\n    }\n\n    # OUTPUT: «1 2 3 4 5 »","n":"last"}],"k":"c","b":"A"},{"t":"Sub+{is-pure}","n":"&sec","k":"v"},{"n":"sec","m":1,"k":"s","s":{"p":["Numeric \\x"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"},"n":"sec"},{"n":"sec","s":{"r":"num","p":["num $x"]},"m":1,"k":"s"},{"b":"C","mro":["Positional","Iterable","List"],"k":"c","n":"Empty","t":"Slip","a":[{"k":"v","n":"$!reified","t":"Mu"},{"k":"v","n":"$!todo","t":"Mu"}]},{"k":"v","n":"&infix:<cmp>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<cmp>","s":{"p":["\\a","\\b"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["Real:D \\a","\\b"]},"n":"infix:<cmp>"},{"m":1,"k":"s","s":{"p":["\\a","Real:D \\b"],"r":"Mu"},"n":"infix:<cmp>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Real:D \\a","Real:D \\b"]},"n":"infix:<cmp>"},{"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<cmp>"},{"s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]},"k":"s","m":1,"n":"infix:<cmp>"},{"n":"infix:<cmp>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["int $a","int $b"]},"m":1,"k":"s","n":"infix:<cmp>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]},"n":"infix:<cmp>"},{"m":1,"k":"s","s":{"p":["num $a","num $b"],"r":"Mu"},"n":"infix:<cmp>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"n":"infix:<cmp>"},{"k":"s","m":1,"s":{"p":["Str:D \\a","Str:D \\b"],"r":"Order:D"},"n":"infix:<cmp>"},{"n":"infix:<cmp>","s":{"p":["str $a","str $b"],"r":"Order:D"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Order:D","p":["Range:D \\a","Range:D \\b"]},"n":"infix:<cmp>"},{"n":"infix:<cmp>","s":{"p":["Num(Real) \\a","Range:D \\b"],"r":"Order:D"},"k":"s","m":1},{"s":{"r":"Order:D","p":["Range:D \\a","Num(Real) \\b"]},"k":"s","m":1,"n":"infix:<cmp>"},{"n":"infix:<cmp>","s":{"p":["Positional \\a","Range:D \\b"],"r":"Order:D"},"m":1,"k":"s"},{"n":"infix:<cmp>","s":{"r":"Order:D","p":["Range:D \\a","Positional \\b"]},"k":"s","m":1},{"n":"infix:<cmp>","m":1,"k":"s","s":{"p":["@a","@b"],"r":"Order:D"}},{"n":"infix:<cmp>","s":{"r":"Mu","p":["Pair:D \\a","Pair:D \\b"]},"m":1,"k":"s"},{"n":"infix:<cmp>","m":1,"k":"s","s":{"r":"Order:D","p":["Complex:D \\a","Complex:D \\b"]}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Order:D"}},{"n":"infix:<cmp>","s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Order:D"},"k":"s","m":1},{"n":"infix:<cmp>","s":{"r":"Mu","p":["IntStr:D $a","IntStr:D $b"]},"m":1,"k":"s"},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":["IntStr:D $a","RatStr:D $b"],"r":"Mu"}},{"s":{"r":"Mu","p":["IntStr:D $a","NumStr:D $b"]},"k":"s","m":1,"n":"infix:<cmp>"},{"k":"s","m":1,"s":{"p":["IntStr:D $a","ComplexStr:D $b"],"r":"Mu"},"n":"infix:<cmp>"},{"s":{"r":"Mu","p":["RatStr:D $a","IntStr:D $b"]},"m":1,"k":"s","n":"infix:<cmp>"},{"s":{"r":"Mu","p":["RatStr:D $a","RatStr:D $b"]},"m":1,"k":"s","n":"infix:<cmp>"},{"s":{"r":"Mu","p":["RatStr:D $a","NumStr:D $b"]},"k":"s","m":1,"n":"infix:<cmp>"},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":["RatStr:D $a","ComplexStr:D $b"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["NumStr:D $a","IntStr:D $b"],"r":"Mu"},"n":"infix:<cmp>"},{"n":"infix:<cmp>","k":"s","m":1,"s":{"r":"Mu","p":["NumStr:D $a","RatStr:D $b"]}},{"n":"infix:<cmp>","s":{"p":["NumStr:D $a","NumStr:D $b"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":["NumStr:D $a","ComplexStr:D $b"],"r":"Mu"},"n":"infix:<cmp>"},{"m":1,"k":"s","s":{"p":["ComplexStr:D $a","IntStr:D $b"],"r":"Mu"},"n":"infix:<cmp>"},{"k":"s","m":1,"s":{"r":"Mu","p":["ComplexStr:D $a","RatStr:D $b"]},"n":"infix:<cmp>"},{"n":"infix:<cmp>","s":{"r":"Mu","p":["ComplexStr:D $a","NumStr:D $b"]},"m":1,"k":"s"},{"n":"infix:<cmp>","s":{"r":"Mu","p":["ComplexStr:D $a","ComplexStr:D $b"]},"k":"s","m":1},{"s":{"r":"Order:D","p":["Instant:D $a","Instant:D $b"]},"k":"s","m":1,"n":"infix:<cmp>"},{"m":1,"k":"s","s":{"r":"Order:D","p":["DateTime:D \\a","DateTime:D \\b"]},"n":"infix:<cmp>"},{"n":"infix:<cmp>","k":"s","m":1,"s":{"r":"Order:D","p":["Date:D $a","Date:D $b"]}},{"n":"infix:<cmp>","m":1,"k":"s","s":{"p":["Version:D \\a","Version:D \\b"],"r":"Mu"}},{"n":"infix:<cmp>","k":"s","m":1,"s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Mu"}},{"k":"e","t":"Signal","n":"SIGINFO"},{"t":"Signal","n":"SIGTTOU","k":"e"},{"k":"v","n":"&samecase","t":"Sub"},{"s":{"p":["Cool:D $string","Cool:D $pattern"],"r":"Mu"},"m":1,"k":"s","n":"samecase"},{"n":"&uc","t":"Sub","k":"v"},{"n":"uc","s":{"r":"Mu","p":["Cool $s"]},"m":1,"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<,>","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"List:D"},"n":"infix:<,>"},{"n":"infix:<,>","k":"s","m":1,"s":{"p":["Slip:D \\a","Slip:D \\b"],"r":"List:D"}},{"k":"s","m":1,"s":{"r":"List:D","p":["\\a","Slip:D \\b"]},"n":"infix:<,>"},{"n":"infix:<,>","m":1,"k":"s","s":{"p":["Slip:D \\a","\\b"],"r":"List:D"}},{"n":"infix:<,>","s":{"r":"List:D","p":["\\a","\\b"]},"m":1,"k":"s"},{"n":"infix:<,>","m":1,"k":"s","s":{"r":"Mu","p":["|"]}},{"t":"atomicint","n":"atomicint","k":"n"},{"k":"v","t":"Sub+{is-pure}","n":"&acosh"},{"n":"acosh","m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]}},{"n":"acosh","s":{"p":["Cool \\x"],"r":"Mu"},"k":"s","m":1},{"n":"acosh","m":1,"k":"s","s":{"p":["num $x"],"r":"num"}},{"t":"int32","n":"int32","k":"n"},{"n":"&parse-base","t":"Sub","k":"v"},{"n":"parse-base","s":{"p":["Str:D $str","Int:D $radix"],"r":"Mu"},"k":"s","m":1},{"k":"v","n":"&not","t":"Sub"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu $x"]},"n":"not"},{"b":"A","k":"c","m":[{"n":"BUILD","s":{"r":"Nil","p":[":$in = \"-\"",":$out = \"-\"",":$err = \"-\"",":$exitcode","Bool :$bin","Bool :$chomp = Bool::True","Bool :$merge",":$command","Str :$enc","Str:D :$nl = \"\\n\"",":$signal","*%_"]},"k":"s","m":0},{"k":"m","m":0,"s":{"p":["*@args where { ... }",":$cwd = { ... }",":$env","*%_"],"r":"Bool:D"},"d":"method spawn(*@args ($, *@), :$cwd = $*CWD, Hash() :$env = %*ENV --> Bool:D)\n\nRuns the Proc object with the given command, argument list, working\ndirectory, and environment.","n":"spawn"},{"m":0,"k":"m","s":{"r":"Bool:D","p":["$cmd",":$cwd = { ... }",":$env","*%_"]},"d":"method shell($cmd, :$cwd = $*CWD, :$env --> Bool:D)\n\nRuns the Proc object with the given command and environment which are\npassed through to the shell for parsing and execution. See shell for an\nexplanation of which shells are used by default in the most common\noperating systems.","n":"shell"},{"n":"status","k":"m","m":1,"s":{"p":["$new_status","*%_"],"r":"Mu"}},{"n":"status","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"d":"method exitcode(Proc:D: --> Int:D)\n\nReturns the exit code of the external process, or -1 if it has not exited\nyet.","n":"exitcode","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    method sink(--> Nil)\n\nWhen sunk, the Proc object will throw X::Proc::Unsuccessful if the process\nit ran exited unsuccessfully.\n\n    shell 'ls /qqq';\n    # OUTPUT: «(exit code 1) ls: cannot access '/qqq': No such file or directory␤The spawned command 'ls /qqq' exited unsuccessfully (exit code: 2)␤\n    n block <unit> at /tmp/3169qXElwq line 1␤␤»","n":"sink","m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"}},{"n":"in","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"out"},{"n":"err","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"signal","d":"method signal(Proc:D:)\n\nReturns the signal number with which the external process was killed, or 0\nor an undefined value otherwise.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method pid()\n\nReturns the PID value of the process if available, or Nil.","n":"pid"},{"n":"command","d":"method command(Proc:D: --> List:D)\n\nThe command method is an accessor to a list containing the arguments that\nwere passed when the Proc object was executed via spawn or shell or run.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"!await-if-last-handle"},{"n":"!status","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Bool:D","p":["@args","$cwd","$env","*%_"]},"k":"m","m":0,"n":"!spawn-internal"},{"n":"!wait-for-finish","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"!set-status","s":{"r":"Mu","p":["$new_status","*%_"]},"k":"m","m":0}],"mro":["Any"],"t":"Proc","a":[{"k":"v","t":"IO::Pipe","n":"$.in"},{"n":"$.out","t":"IO::Pipe","k":"v"},{"t":"IO::Pipe","n":"$.err","k":"v"},{"n":"$.exitcode","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.signal"},{"t":"Mu","n":"$.pid","k":"v"},{"t":"Positional","n":"@.command","k":"v"},{"t":"Proc::Async","n":"$!proc","k":"v"},{"t":"Bool","n":"$!w","k":"v"},{"t":"Positional","n":"@!pre-spawn","k":"v"},{"t":"Positional","n":"@!post-spawn","k":"v"},{"t":"Mu","n":"$!active-handles","k":"v"},{"n":"&!start-stdout","t":"Callable","k":"v"},{"k":"v","n":"&!start-stderr","t":"Callable"},{"t":"Mu","n":"$!finished","k":"v"}],"d":"TITLE\nclass Proc\n\nSUBTITLE\nRunning process (filehandle-based interface)\n\n    class Proc {}\n\nProc is a representation of an invocation of an external process. It\nprovides access to the input, output and error stream as well as the exit\ncode. It is typically created through the run subroutine:\n\n    my $proc = run 'echo', 'Hallo world', :out;\n    my $captured-output = $proc.out.slurp: :close;\n    say \"Output was $captured-output.perl()\";# OUTPUT: «Output was \"Hallo world\\n\"␤»\n\n\nPiping several commands is easy too. To achieve the equivalent of the pipe\necho \"Hello, world\" | cat -n in Raku, and capture the output from the\nsecond command, you can do\n\n    my $p1 = run 'echo', 'Hello, world', :out;\n    my $p2 = run 'cat', '-n', :in($p1.out), :out;\n    say $p2.out.get;\n\n\nYou can also feed the :in (standard input) pipe directly from your program,\nby setting it to True, which will make the pipe available via .in method on\nthe Proc:\n\n    my $p = run \"cat\", \"-n\", :in, :out;\n    $p.in.say: \"Hello,\\nworld!\";\n    $p.in.close;\n    say $p.out.slurp: :close;\n    # OUTPUT: «1  Hello,␤\n    #          2  world!␤»\n\n\nIn order to capture the standard error, :err can be supplied:\n\n    my $p = run \"ls\", \"-l\", \".\", \"qqrq\", :out, :err;\n    my $captured-output = $p.out.slurp: :close;\n    my $captured-error  = $p.err.slurp: :close;\n    my $exit-code       = $p.exitcode;\n\n\nIn sink context, a Proc will call its sink method, throwing an exception if\nthe process has exited with an exit code different from zero:\n\n    shell 'exit 1'\n    # OUTPUT: «(exit code 1) The spawned command 'exit 1' exited unsuccessfully (exit code: 1)␤»\n\n\nNote: Versions of Rakudo older than 2017.04 do not have .slurp available on\nIO::Pipe objects; use .slurp-rest instead.\n\nUse Proc::Async for non-blocking operations.\n\n","n":"Proc"},{"mro":["Any"],"m":[{"s":{"r":"Mu","p":["*@args where { ... }","*%_"]},"m":1,"k":"m","n":"new","d":"multi method new(*@ ($path, *@args), :$w, :$enc, :$translate-nl --> Proc::Async:D)\n    multi method new(   :$path, :@args,  :$w, :$enc, :$translate-nl --> Proc::Async:D)\n\nCreates a new Proc::Async object with external program name or path $path\nand the command line arguments @args.\n\nIf :w is passed to new, then a pipe to the external program's standard\ninput stream (stdin) is opened, to which you can write with write and say.\n\nThe :enc specifies the encoding for streams (can still be overridden in\nindividual methods) and defaults to utf8.\n\nIf :translate-nl is set to True (default value), OS-specific newline\nterminators (e.g. \\r\\n on Windows) will be automatically translated to \\n."},{"m":0,"k":"s","s":{"p":["*%_"],"r":"Nil"},"n":"TWEAK"},{"k":"m","m":1,"s":{"r":"Mu","p":[":$bin!","*%_"]},"d":"method stdout(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard output stream. If\n:bin is passed, the standard output is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stdout.tap( -> $str {\n        say \"Got output '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stdout before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stdout is not called, the external program's standard output is not\ncaptured at all.\n\nNote that you cannot call stdout both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR.","n":"stdout"},{"s":{"r":"Mu","p":[":$enc",":$translate-nl","*%_"]},"m":1,"k":"m","n":"stdout","d":"method stdout(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard output stream. If\n:bin is passed, the standard output is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stdout.tap( -> $str {\n        say \"Got output '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stdout before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stdout is not called, the external program's standard output is not\ncaptured at all.\n\nNote that you cannot call stdout both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR."},{"m":1,"k":"m","s":{"r":"Mu","p":[":$bin!","*%_"]},"d":"method stderr(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard error stream. If\n:bin is passed, the standard error is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stderr.tap( -> $str {\n        say \"Got error '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stderr before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stderr is not called, the external program's standard error stream is\nnot captured at all.\n\nNote that you cannot call stderr both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR.","n":"stderr"},{"d":"method stderr(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard error stream. If\n:bin is passed, the standard error is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stderr.tap( -> $str {\n        say \"Got error '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stderr before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stderr is not called, the external program's standard error stream is\nnot captured at all.\n\nNote that you cannot call stderr both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR.","n":"stderr","m":1,"k":"m","s":{"r":"Mu","p":[":$enc",":$translate-nl","*%_"]}},{"s":{"p":[":$bin!","*%_"],"r":"Mu"},"m":1,"k":"m","n":"Supply","d":"multi method Supply(Proc::Async:D: :$bin!)\n    multi method Supply(Proc::Async:D: :$enc, :$translate-nl)\n\nReturns a Supply of merged stdout and stderr streams. If :$bin named\nargument is provided, the Supply will be binary, producing Buf objects,\notherwise, it will be in character mode, producing Str objects and :$enc\nnamed argument can specify encoding to use. The :$translate-nl option\nspecifies whether new line endings should be translated for to match those\nused by the current operating system (e.g. \\r\\n on Windows).\n\n    react {\n        with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n            whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n            whenever .start {}\n        }\n    }\n\n\nIt is an error to create both binary and non-binary .Supply. It is also an\nerror to use both .Supply and either stderr or stdout supplies."},{"s":{"p":[":$enc",":$translate-nl","*%_"],"r":"Mu"},"k":"m","m":1,"n":"Supply","d":"multi method Supply(Proc::Async:D: :$bin!)\n    multi method Supply(Proc::Async:D: :$enc, :$translate-nl)\n\nReturns a Supply of merged stdout and stderr streams. If :$bin named\nargument is provided, the Supply will be binary, producing Buf objects,\notherwise, it will be in character mode, producing Str objects and :$enc\nnamed argument can specify encoding to use. The :$translate-nl option\nspecifies whether new line endings should be translated for to match those\nused by the current operating system (e.g. \\r\\n on Windows).\n\n    react {\n        with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n            whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n            whenever .start {}\n        }\n    }\n\n\nIt is an error to create both binary and non-binary .Supply. It is also an\nerror to use both .Supply and either stderr or stdout supplies."},{"s":{"r":"Nil","p":["IO::Handle:D $handle","*%_"]},"k":"m","m":1,"n":"bind-stdin","d":"multi method bind-stdin(IO::Handle:D $handle)\n    multi method bind-stdin(Proc::Async::Pipe:D $pipe)\n\nSets a handle (which must be opened) or a Pipe as a source of STDIN. The\nSTDIN of the target process must be writable or X::Proc::Async::BindOrUse\nwill be thrown.\n\n    my $p = Proc::Async.new(\"cat\", :in);\n    my $h = \"/etc/profile\".IO.open;\n    $p.bind-stdin($h);\n    $p.start;\n\nThis is equivalent to\n\n    cat < /etc/profile\n\n\nand will print the content of /etc/profile to standard output."},{"d":"multi method bind-stdin(IO::Handle:D $handle)\n    multi method bind-stdin(Proc::Async::Pipe:D $pipe)\n\nSets a handle (which must be opened) or a Pipe as a source of STDIN. The\nSTDIN of the target process must be writable or X::Proc::Async::BindOrUse\nwill be thrown.\n\n    my $p = Proc::Async.new(\"cat\", :in);\n    my $h = \"/etc/profile\".IO.open;\n    $p.bind-stdin($h);\n    $p.start;\n\nThis is equivalent to\n\n    cat < /etc/profile\n\n\nand will print the content of /etc/profile to standard output.","n":"bind-stdin","m":1,"k":"m","s":{"p":["Proc::Async::Pipe:D $pipe","*%_"],"r":"Nil"}},{"d":"method bind-stdout(IO::Handle:D $handle)\n\nRedirects STDOUT of the target process to a handle (which must be opened).\nIf STDOUT is closed X::Proc::Async::BindOrUse will be thrown.\n\n    my $p = Proc::Async.new(\"ls\", :out);\n    my $h = \"ls.out\".IO.open(:w);\n    $p.bind-stdout($h);\n    $p.start;\n\nThis program will pipe the output of the ls shell command to a file called\nls.out, which we are opened for reading.","n":"bind-stdout","k":"m","m":0,"s":{"p":["IO::Handle:D $handle","*%_"],"r":"Nil"}},{"k":"m","m":0,"s":{"r":"Nil","p":["IO::Handle:D $handle","*%_"]},"d":"method bind-stderr(IO::Handle:D $handle)\n\nRedirects STDERR of the target process to a handle (which must be opened).\nIf STDERR is closed X::Proc::Async::BindOrUse will be thrown.\n\n    my $p = Proc::Async.new(\"ls\", \"--foo\", :err);\n    my $h = \"ls.err\".IO.open(:w);\n    $p.bind-stderr($h);\n    $p.start;","n":"bind-stderr"},{"n":"ready","d":"method ready(Proc::Async:D: --> Promise:D)\n\nReturns a Promise that will be kept once the process has successfully\nstarted. Promise will be broken if the program fails to start.\n\nImplementation-specific note: Starting from Rakudo 2018.04, the returned\npromise will hold the process id (PID).","s":{"p":["*%_"],"r":"Promise"},"m":0,"k":"m"},{"n":"pid","d":"method pid(Proc::Async:D: --> Promise:D)\n\nEquivalent to ready.\n\nReturns a Promise that will be kept once the process has successfully\nstarted. Promise will be broken if the program fails to start. Returned\npromise will hold the process id (PID).\n\nImplementation-specific note: Available starting from Rakudo 2018.04.","s":{"r":"Promise","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[":$scheduler = { ... }",":$ENV",":$cwd = { ... }","*%_"]},"d":"method start(Proc::Async:D: :$scheduler = $*SCHEDULER, :$ENV, :$cwd = $*CWD)\n\nInitiates spawning of the external program. Returns a Promise that will be\nkept with a Proc object once the external program exits or broken if the\nprogram cannot be started. Optionally, you can use a scheduler instead of\nthe default $*SCHEDULER, or change the environment the process is going to\nrun in via the named argument :$ENV or the directory via the named argument\n:$cwd.\n\nIf start is called on a Proc::Async object on which it has already been\ncalled before, an exception of type X::Proc::Async::AlreadyStarted is\nthrown.\n\nNote: If you wish to await the Promise and discard its result, using\n\n    try await $p.start;\n\n\nwill throw if the program exited with non-zero status, as the Proc returned\nas the result of the Promise throws when sunk and in this case it will get\nsunk outside the try. To avoid that, sink it yourself inside the try:\n\n    try sink await $p.start;","n":"start"},{"k":"m","m":0,"s":{"r":"Mu","p":["$str",":$scheduler = { ... }","*%_"]},"d":"method print(Proc::Async:D: Str(Any) $str, :$scheduler = $*SCHEDULER)\n\nWrite the text data in $str to the standard input stream of the external\nprogram, encoding it as UTF-8.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method print, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","n":"print"},{"n":"put","k":"m","m":0,"s":{"p":["\\x","|c is raw"],"r":"Mu"}},{"n":"say","d":"method say(Proc::Async:D: $output, :$scheduler = $*SCHEDULER)\n\nCalls method gist on the $output, adds a newline, encodes it as UTF-8, and\nsends it to the standard input stream of the external program, encoding it\nas UTF-8.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method say, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","s":{"p":["\\x","|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"d":"method write(Proc::Async:D: Blob:D $b, :$scheduler = $*SCHEDULER --> Promise:D)\n\nWrite the binary data in $b to the standard input stream of the external\nprogram.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method write, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","n":"write","m":0,"k":"m","s":{"r":"Mu","p":["Blob:D $b",":$scheduler = { ... }","*%_"]}},{"d":"method close-stdin(Proc::Async:D: --> True)\n\nCloses the standard input stream of the external program. Programs that\nread from STDIN often only terminate when their input stream is closed. So\nif waiting for the promise from #method start hangs (for a program opened\nfor writing), it might be a forgotten close-stdin.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method close-stdin, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","n":"close-stdin","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"method kill(Proc::Async:D: $signal = \"HUP\")\n\nSends a signal to the running program. The signal can be a signal name\n(\"KILL\" or \"SIGKILL\"), an integer (9) or an element of the Signal enum\n(Signal::SIGKILL).","n":"kill","m":1,"k":"m","s":{"r":"Mu","p":["Signal:D \\signal = Signal::SIGHUP","*%_"]}},{"s":{"r":"Mu","p":["Int:D \\signal","*%_"]},"k":"m","m":1,"n":"kill","d":"method kill(Proc::Async:D: $signal = \"HUP\")\n\nSends a signal to the running program. The signal can be a signal name\n(\"KILL\" or \"SIGKILL\"), an integer (9) or an element of the Signal enum\n(Signal::SIGKILL)."},{"d":"method kill(Proc::Async:D: $signal = \"HUP\")\n\nSends a signal to the running program. The signal can be a signal name\n(\"KILL\" or \"SIGKILL\"), an integer (9) or an element of the Signal enum\n(Signal::SIGKILL).","n":"kill","m":1,"k":"m","s":{"r":"Mu","p":["Str:D \\signal","*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method path(Proc::Async:D:)\n\nDeprecated as of v6.d. Use command instead.\n\nReturns the name and/or path of the external program that was passed to the\nnew method as first argument.","n":"path"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method args(Proc::Async:D: --> Positional:D)\n\nDeprecated as of v6.d. Use command instead.\n\nReturns the command line arguments for the external programs, as passed to\nthe new method.","n":"args"},{"d":"method command(Proc::Async:D: --> List:D)\n\nAvailable as of v6.d.\n\nReturns the command and arguments used for this Proc::Async object:\n\n    my $p := Proc::Async.new: 'cat', 'some', 'files';\n    $p.command.say; # OUTPUT: «(cat some files)␤»","n":"command","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"w","d":"method w(Proc::Async:D:)\n\nReturns a true value if :w was passed to the constructor, that is, if the\nexternal program is started with its input stream made available to output\nto the program through the .print, .say and .write methods.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"enc","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"translate-nl","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"started","d":"method started(Proc::Async:D: --> Bool:D)\n\nReturns False before .start has been called, and True afterwards.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"},{"s":{"p":[":$scheduler",":$ENV",":$cwd","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!start-internal"},{"n":"!wrap-decoder","m":0,"k":"m","s":{"r":"Mu","p":["Supply:D $bin-supply","$enc","\\fd-vow","\\permit-channel",":$translate-nl","*%_"]}},{"n":"!pipe-cbs","m":0,"k":"m","s":{"r":"Mu","p":["\\channel","*%_"]}},{"n":"!capture","s":{"r":"Mu","p":["\\callbacks","\\std","\\the-supply","*%_"]},"k":"m","m":0},{"n":"!pipe","k":"m","m":0,"s":{"r":"Mu","p":["\\what","\\the-supply","\\type","\\value","\\fd-vow","\\permit-channel","*%_"]}}],"k":"c","n":"Proc::Async","d":"TITLE\nclass Proc::Async\n\nSUBTITLE\nRunning process (asynchronous interface)\n\n    class Proc::Async {}\n\n\nProc::Async allows you to run external commands asynchronously, capturing\nstandard output and error handles, and optionally write to its standard\ninput.\n\n    my $file = ‘foo’.IO;\n    spurt $file, “and\\nCamelia\\n♡\\nme\\n”;\n\n    my $proc = Proc::Async.new: :w, ‘tac’, ‘--’, $file, ‘-’;\n    # my $proc = Proc::Async.new: :w, ‘sleep’, 15; # uncomment to try timeouts\n\n    react {\n        whenever $proc.stdout.lines { # split input on \\r\\n, \\n, and \\r\n            say ‘line: ’, $_\n        }\n        whenever $proc.stderr { # chunks\n            say ‘stderr: ’, $_\n        }\n        whenever $proc.ready {\n            say ‘PID: ’, $_ # Only in Rakudo 2018.04 and newer, otherwise Nil\n        }\n        whenever $proc.start {\n            say ‘Proc finished: exitcode=’, .exitcode, ‘ signal=’, .signal;\n            done # gracefully jump from the react block\n        }\n        whenever $proc.print: “I\\n♥\\nCamelia\\n” {\n            $proc.close-stdin\n        }\n        whenever signal(SIGTERM).merge: signal(SIGINT) {\n            once {\n                say ‘Signal received, asking the process to stop’;\n                $proc.kill; # sends SIGHUP, change appropriately\n                whenever signal($_).zip: Promise.in(2).Supply {\n                    say ‘Kill it!’;\n                    $proc.kill: SIGKILL\n                }\n            }\n        }\n        whenever Promise.in(5) {\n            say ‘Timeout. Asking the process to stop’;\n            $proc.kill; # sends SIGHUP, change appropriately\n            whenever Promise.in(2) {\n                say ‘Timeout. Forcing the process to stop’;\n                $proc.kill: SIGKILL\n            }\n        }\n    }\n\n    say ‘Program finished’;\n\n\nExample above produces the following output:\n\n    line: me\n    line: ♡\n    line: Camelia\n    line: and\n    line: Camelia\n    line: ♥\n    line: I\n    Proc finished. Exit code: 0\n    Program finished\n\n\nAlternatively, you can use Proc::Async without using a react block:\n\n    # command with arguments\n    my $proc = Proc::Async.new('echo', 'foo', 'bar');\n\n    # subscribe to new output from out and err handles:\n    $proc.stdout.tap(-> $v { print \"Output: $v\" }, quit => { say 'caught exception ' ~ .^name });\n    $proc.stderr.tap(-> $v { print \"Error:  $v\" });\n\n    say \"Starting...\";\n    my $promise = $proc.start;\n\n    # wait for the external program to terminate\n    await $promise;\n    say \"Done.\";\n\nThis produces the following output:\n\n    Starting...\n    Output: foo bar\n    Done.\n\n\nAn example that opens an external program for writing:\n\n    my $prog = Proc::Async.new(:w, 'hexdump', '-C');\n    my $promise = $prog.start;\n    await $prog.write(Buf.new(12, 42));\n    $prog.close-stdin;\n    await $promise;\n\nAn example of piping several commands like echo \"Hello, world\" | cat -n:\n\n    my $proc-echo = Proc::Async.new: 'echo', 'Hello, world';\n    my $proc-cat = Proc::Async.new: 'cat', '-n';\n    $proc-cat.bind-stdin: $proc-echo.stdout;\n    await $proc-echo.start, $proc-cat.start;\n\n","a":[{"k":"v","n":"$!ready_promise","t":"Mu"},{"n":"$!ready_vow","t":"Mu","k":"v"},{"t":"Mu","n":"$!handle_available_promise","k":"v"},{"t":"Mu","n":"$!stdout_descriptor_vow","k":"v"},{"t":"Mu","n":"$!stderr_descriptor_vow","k":"v"},{"t":"Mu","n":"$!stdout_descriptor_used","k":"v"},{"t":"Mu","n":"$!stderr_descriptor_used","k":"v"},{"k":"v","n":"$.path","t":"Mu"},{"k":"v","n":"@.args","t":"Positional"},{"t":"List","n":"@.command","k":"v"},{"k":"v","n":"$.w","t":"Mu"},{"t":"Mu","n":"$.enc","k":"v"},{"n":"$.translate-nl","t":"Mu","k":"v"},{"k":"v","n":"$.started","t":"Bool"},{"k":"v","t":"Mu","n":"$!stdout_supply"},{"k":"v","n":"$!stdout_type","t":"CharsOrBytes"},{"k":"v","t":"Mu","n":"$!stderr_supply"},{"t":"CharsOrBytes","n":"$!stderr_type","k":"v"},{"t":"Mu","n":"$!merge_supply","k":"v"},{"k":"v","t":"CharsOrBytes","n":"$!merge_type"},{"k":"v","n":"$!stdin-fd","t":"Mu"},{"t":"Mu","n":"$!stdout-fd","k":"v"},{"n":"$!stderr-fd","t":"Mu","k":"v"},{"n":"$!process_handle","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!exit_promise"},{"n":"@!promises","t":"Positional","k":"v"},{"n":"$!encoder","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@!close-after-exit"}],"t":"Proc::Async","b":"A"},{"k":"c","m":[{"n":"BUILD","s":{"p":[":native-descriptor($!native-descriptor)!",":on-nd-used(&!on-nd-used)","*%_"],"r":"Mu"},"k":"s","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"native-descriptor"},{"n":"new","k":"m","m":0,"s":{"r":"Mu","p":["$delegate","$native-descriptor","&on-tap","&on-nd-used","*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Awaitable","Supply"],"t":"Proc::Async::Pipe","a":[{"t":"Promise","n":"$.native-descriptor","k":"v"},{"t":"Callable","n":"&!on-nd-used","k":"v"},{"k":"v","t":"Tappable","n":"$!tappable"}],"n":"Proc::Async::Pipe","b":"A"},{"mro":["Any"],"k":"c","m":[{"n":"Capture","d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"n":"Whatever","d":"TITLE\nclass Whatever\n\nSUBTITLE\nPlaceholder for the value of an unspecified argument\n\n    class Whatever { }\n\nWhatever is a class whose objects don't have any explicit meaning; it gets\nits semantics from other routines that accept Whatever-objects as markers\nto do something special. Using the * literal as an operand creates a\nWhatever object.\n\nMuch of *'s charm comes from Whatever-currying. When * is used in term\nposition, that is, as an operand, in combination with most operators, the\ncompiler will transform the expression into a closure of type WhateverCode,\nwhich is actually a Block that can be used wherever Callables are\naccepted.\n\n    my $c = * + 2;          # same as   -> $x { $x + 2 };\n    say $c(4);              # OUTPUT: «6␤»\n\nMultiple * in one expression generate closures with as many arguments:\n\n    my $c = * + *;          # same as   -> $x, $y { $x + $y }\n\nUsing * in complex expressions will also generate closures:\n\n    my $c = 4 * * + 5;      # same as   -> $x { 4 * $x + 5 }\n\nCalling a method on * also creates a closure:\n\n    <a b c>.map: *.uc;      # same as    <a b c>.map: -> $char { $char.uc }\n\n\nAs mentioned before, not all operators and syntactic constructs curry * (or\nWhatever-stars) to WhateverCode. In the following cases, * will remain a\nWhatever object.\n\n  Exception        Example  What it does\n  comma            1, *, 2  generates a List with a * element\n  range operators  1 .. *   Range.new(:from(1), :to(*));\n  series operator  1 ... *  infinite list\n  assignment       $x = *   assign * to $x\n  binding          $x := *  bind * to $x\n  list repetition  1 xx *   generates an infinite list\n\n\nThe range operators are handled specially. They do not curry with\nWhatever-stars, but they do curry with WhateverCode\n\n    say (1..*).^name;       # OUTPUT: «Range␤»\n    say ((1..*-1)).^name;   # OUTPUT: «WhateverCode␤»\n\nThis allows all these constructs to work:\n\n    .say for 1..*;          # infinite loop\n\n\nand\n\n    my @a = 1..4;\n    say @a[0..*];           # OUTPUT: «(1 2 3 4)␤»\n    say @a[0..*-2];         # OUTPUT: «(1 2 3)␤»\n\nBecause Whatever-currying is a purely syntactic compiler transform, you\nwill get no runtime currying of stored Whatever-stars into WhateverCodes.\n\n    my $x = *;\n    $x + 2;   # Not a closure, dies because it can't coerce $x to Numeric\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller Numeric(Whatever: );\n    # none of these signatures match:␤\n    # (Mu:U \\v: *%_)»\n\n\nThe use cases for stored Whatever-stars involve those curry-exception cases\nmentioned above. For example, if you want an infinite series by default.\n\n    my $max    = potential-upper-limit() // *;\n    my $series = known-lower-limit() ... $max;\n\n\nA stored * will also result in the generation of a WhateverCode in the\nspecific case of smartmatch. Note that this is not actually the stored *\nwhich is being curried, but rather the * on the left-hand side.\n\n    my $constraint           = find-constraint() // *;\n    my $maybe-always-matcher = * ~~ $constraint;\n\n\nIf this hypothetical find-constraint were to have found no constraint,\n$maybe-always-matcher would evaluate to True for anything.\n\n    $maybe-always-matcher(555);      # True\n    $maybe-always-matcher(Any);      # True\n\n\nHyperWhatever's functionality is similar to Whatever, except it refers to\nmultiple values, instead of a single one.\n\n","t":"Whatever","b":"A"},{"k":"v","n":"&roundrobin","t":"Sub"},{"n":"roundrobin","s":{"r":"Seq:D","p":["+\\lol is raw"]},"k":"s","m":1},{"n":"CX::Return","t":"CX::Return","a":[{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nrole CX::Return\n\nSUBTITLE\nReturn control exception\n\n    role CX::Next does X::Control { }\n\nA control exception to be used when return is called from within a sub.\n\n","mro":["X::Control","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<return control exception>\""}],"k":"c","b":"A"},{"a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nrole CX::Done\n\nSUBTITLE\nDone control exception\n\n    role CX::Done does X::Control { }\n\nA control exception to be used to indicate a supply block is finished by\ncalling done.\n\n","t":"CX::Done","n":"CX::Done","k":"c","m":[{"n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<done control exception>\"","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"mro":["X::Control","Exception"],"b":"A"},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<last control exception>\". Since this type of exception is to be\nconsumed by type and not really by the content of the message, this is a\ngeneric message, similar to all other CX::* exceptions."}],"mro":["X::Control","Exception"],"a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"CX::Last","d":"TITLE\nrole CX::Last\n\nSUBTITLE\nLast control exception\n\n    role CX::Last does X::Control { }\n\nA control exception that is thrown when last is called.\n\n","n":"CX::Last","b":"A"},{"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<next control exception>\""}],"mro":["X::Control","Exception"],"d":"TITLE\nrole CX::Succeed\n\nSUBTITLE\nSucceed control exception\n\n    role CX::Succeed does X::Control { }\n\nA control exception thrown when succeed is called from a when or default\nblock.\n\n","a":[{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"CX::Succeed","n":"CX::Succeed","b":"A"},{"b":"A","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method message()\n\nReturns \"<proceed control exception>\"","n":"message"}],"mro":["X::Control","Exception"],"d":"TITLE\nrole CX::Proceed\n\nSUBTITLE\nProceed control exception\n\n    role CX::Proceed does X::Control { }\n\nA control exception to be used when proceed is used within when or default\nblocks.\n\n","a":[{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"CX::Proceed","n":"CX::Proceed"},{"b":"A","mro":["X::Control","Exception"],"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method message()\n\nReturns \"<emit control exception>\"","n":"message"}],"k":"c","n":"CX::Emit","a":[{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"CX::Emit","d":"TITLE\nrole CX::Emit\n\nSUBTITLE\nEmit control exception\n\n    role CX::Emit does X::Control { }\n\nA control exception to be used when emit is used inside a Supply block.\n\n"},{"mro":["X::Control","Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method message()\n\nReturns \"<take control exception>\".","n":"message"}],"k":"c","n":"CX::Take","a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nrole CX::Take\n\nSUBTITLE\nTake control exception\n\n    role CX::Take does X::Control { }\n\nA control exception triggered by take.\n\n","t":"CX::Take","b":"A"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"CX::Next","d":"TITLE\nrole CX::Next\n\nSUBTITLE\nNext control exception\n\n    role CX::Next does X::Control { }\n\nA control exception that is triggered when next is called.\n\n    for ^10 {\n        CONTROL {\n          when CX::Next { say \"We're next\" };\n        }\n        next if $_ %% 2;\n        say \"We're in $_\";\n    }\n\n\nThis will print:\n\n    We're next\n    We're in 1\n    We're next\n    We're in 3\n    We're next\n    We're in 5\n    We're next\n    We're in 7\n    We're next\n    We're in 9\n\n\n","n":"CX::Next","k":"c","m":[{"n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<next control exception>\"","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"mro":["X::Control","Exception"]},{"n":"CX::Redo","a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"CX::Redo","d":"TITLE\nrole CX::Redo\n\nSUBTITLE\nRedo control exception\n\n    role CX::Redo does X::Control { }\n\nA control exception thrown when redo is called.\n\n","mro":["X::Control","Exception"],"k":"c","m":[{"n":"message","d":"Defined as:\n\n    method message()\n\nReturns \"<redo control exception>\".","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"b":"A"},{"b":"A","n":"CX::Warn","d":"TITLE\nrole CX::Warn\n\nSUBTITLE\nControl exception warning\n\n    role CX::Warn does X::Control { }\n\nA control exception triggered when warn is called to warn about any\nincidence.\n\n","a":[{"t":"Mu","n":"$.message","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"CX::Warn","mro":["X::Control","Exception"],"m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c"},{"k":"v","n":"&split","t":"Sub"},{"n":"split","s":{"r":"Mu","p":["$pat","Cool:D $target","|c is raw"]},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&sum"},{"n":"sum","s":{"r":"Mu","p":[]},"k":"s","m":1},{"n":"sum","k":"s","m":1,"s":{"r":"Mu","p":["\\SELF"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["+\\SELF is raw"]},"n":"sum"},{"k":"c","mro":["Real","Numeric","Cool"],"t":"Num","n":"Inf","b":"C"},{"k":"v","n":"&EVAL","t":"Sub"},{"s":{"p":["$code","Str :$lang where { ... }","PseudoStash :$context",":$filename = Str",":$check = Bool::False"],"r":"Mu"},"k":"s","m":1,"n":"EVAL"},{"t":"Sub","n":"&trait_mod:<returns>","k":"v"},{"k":"s","m":1,"s":{"p":["Routine:D $target","Mu:U $type"],"r":"Mu"},"n":"trait_mod:<returns>"},{"k":"v","n":"&nodemap","t":"Sub"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\op","\\obj"]},"n":"nodemap"},{"s":{"r":"Mu","p":["\\op","Associative \\h"]},"k":"s","m":1,"n":"nodemap"},{"k":"v","n":"&infix:<after>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<after>","s":{"p":["$x?"],"r":"Bool"},"k":"s","m":1},{"n":"infix:<after>","s":{"p":["\\a","\\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"&copy","t":"Sub","k":"v"},{"s":{"p":["$from","$to",":$createonly"],"r":"Mu"},"k":"s","m":1,"n":"copy"},{"k":"v","t":"Sub","n":"&trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Mu:U $child","Mu:U $parent"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu:U \\child","Mu:U \\parent","@subtypes"]},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Mu:U $child",":$DEPRECATED!"]},"m":1,"k":"s"},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $type",":$rw!"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu:U $type",":$nativesize!"]},"n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $type",":$ctype!"]},"n":"trait_mod:<is>"},{"s":{"p":["Mu:U $type",":$unsigned!"],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"p":["Mu:U $type",":$hidden!"],"r":"Mu"},"n":"trait_mod:<is>"},{"s":{"p":["Mu:U $type","Mu :$array_type!"],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $type","Mu:U $parent","Block $"]}},{"s":{"p":["Mu:U $type","Mu:U $parent","Hash $"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"k":"s","m":1,"s":{"p":["Mu:U $type","*%fail"],"r":"Mu"},"n":"trait_mod:<is>"},{"s":{"r":"Mu","p":["Attribute:D $attr","|c is raw"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Attribute:D $attr",":$rw!"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["Attribute:D $attr",":$readonly!"]},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Attribute:D $attr",":$required!"],"r":"Mu"}},{"s":{"r":"Mu","p":["Attribute:D $attr","Mu :$default!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Attribute:D $attr",":$box_target!"]},"k":"s","m":1},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"r":"Mu","p":["Attribute:D $attr",":$DEPRECATED!"]}},{"k":"s","m":1,"s":{"p":["Attribute:D $attr",":$leading_docs!"],"r":"Mu"},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Attribute:D $attr",":$trailing_docs!"],"r":"Mu"}},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Routine:D $r","|c is raw"]},"m":1,"k":"s"},{"s":{"p":["Routine:D $r",":$rw!"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Routine:D $r",":$raw!"]},"m":1,"k":"s"},{"n":"trait_mod:<is>","s":{"p":["Routine:D $r",":$default!"],"r":"Mu"},"m":1,"k":"s"},{"n":"trait_mod:<is>","s":{"p":["Routine:D $r",":$DEPRECATED!"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":["Routine:D $r","Mu :$inlinable!"],"r":"Mu"},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Routine:D $r",":$onlystar!"],"r":"Mu"}},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Routine:D $r",":prec(%spec)!"]},"k":"s","m":1},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Routine:D $r",":&equiv!"]},"k":"s","m":1},{"s":{"r":"Mu","p":["Routine:D $r",":&tighter!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Routine:D $r",":&looser!"],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Mu","p":["Routine:D $r",":$assoc!"]},"m":1,"k":"s","n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Parameter:D $param","|c is raw"]},"n":"trait_mod:<is>"},{"s":{"p":["Parameter:D $param",":$readonly!"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Parameter:D $param",":$rw!"]},"n":"trait_mod:<is>"},{"m":1,"k":"s","s":{"p":["Parameter:D $param",":$copy!"],"r":"Mu"},"n":"trait_mod:<is>"},{"k":"s","m":1,"s":{"p":["Parameter:D $param",":$required!"],"r":"Mu"},"n":"trait_mod:<is>"},{"s":{"r":"Mu","p":["Parameter:D $param",":$raw!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Parameter:D $param",":$onearg!"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["Parameter:D $param",":$leading_docs!"]},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Parameter:D $param",":$trailing_docs!"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["Routine:D \\r",":$export!",":$SYMBOL = { ... }"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"s":{"r":"Mu","p":["Mu:U \\type",":$export!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Mu \\sym",":$export!",":$SYMBOL!"],"r":"Mu"},"m":1,"k":"s"},{"n":"trait_mod:<is>","s":{"p":["Block:D $r",":$leading_docs!"],"r":"Mu"},"k":"s","m":1},{"n":"trait_mod:<is>","s":{"r":"Mu","p":["Block:D $r",":$trailing_docs!"]},"k":"s","m":1},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"r":"Mu","p":["Routine:D $r",":$leading_docs!"]}},{"s":{"r":"Mu","p":["Routine:D $r",":$trailing_docs!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"s":{"p":["Mu:U $docee",":$leading_docs!"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<is>"},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"p":["Mu:U $docee",":$trailing_docs!"],"r":"Mu"}},{"k":"s","m":1,"s":{"p":["Routine:D $r",":$hidden-from-backtrace!"],"r":"Mu"},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"p":["Routine:D $r",":$hidden-from-USAGE!"],"r":"Mu"}},{"n":"trait_mod:<is>","m":1,"k":"s","s":{"r":"Mu","p":["Routine:D $r",":$pure!"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Routine:D $r",":$nodal!"]},"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","s":{"p":["Variable:D $v","|c is raw"],"r":"Mu"},"k":"s","m":1},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Variable:D $v","Mu :$default!"],"r":"Mu"}},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Variable:D $v",":$dynamic!"],"r":"Mu"}},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Variable:D $v",":$export!"],"r":"Mu"}},{"s":{"r":"Mu","p":["Routine $r","Str :$equiv!"]},"k":"s","m":1,"n":"trait_mod:<is>"},{"n":"trait_mod:<is>","k":"s","m":1,"s":{"p":["Routine $r","Str :$tighter!"],"r":"Mu"}},{"k":"s","m":1,"s":{"p":["Routine $r","Str :$looser!"],"r":"Mu"},"n":"trait_mod:<is>"},{"b":"A","m":[{"m":0,"k":"s","s":{"r":"Mu","p":[":$method","*%_"]},"n":"TWEAK"},{"n":"batch","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"degree","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["Any"],"a":[{"k":"v","n":"$.batch","t":"int"},{"k":"v","t":"Int","n":"$.degree"}],"t":"HyperConfiguration","n":"HyperConfiguration"},{"t":"int","n":"int","k":"n"},{"b":"A","n":"Channel","a":[{"n":"$!queue","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!closed_promise"},{"k":"v","t":"Mu","n":"$!closed_promise_vow"},{"t":"int","n":"$!closed","k":"v"},{"k":"v","n":"$!async-notify","t":"Mu"}],"t":"Channel","d":"TITLE\nclass Channel\n\nSUBTITLE\nThread-safe queue for sending values from producers to consumers\n\n    class Channel {}\n\nA Channel is a thread-safe queue that helps you to send a series of objects\nfrom one or more producers to one or more consumers. Each object will\narrive at only one such consumer, selected by the scheduler. If there is\nonly one consumer and one producer, the order of objects is guaranteed to\nbe preserved. Sending on a Channel is non-blocking.\n\n    my $c = Channel.new;\n    await (^10).map: {\n        start {\n            my $r = rand;\n            sleep $r;\n            $c.send($r);\n        }\n    }\n    $c.close;\n    say $c.list;\n\nFurther examples can be found in the concurrency page\n\n","mro":["Awaitable","Any"],"k":"c","m":[{"s":{"r":"Nil","p":["*%_"]},"m":0,"k":"s","n":"BUILD"},{"k":"m","m":0,"s":{"r":"Nil","p":["\\item","*%_"]},"d":"Defined as:\n\n    method send(Channel:D: \\item)\n\nEnqueues an item into the Channel. Throws an exception of type\nX::Channel::SendOnClosed if the channel has been closed already. This call\nwill not block waiting for a consumer to take the object. There is no set\nlimit on the number of items that may be queued, so care should be taken to\nprevent runaway queueing.\n\n    my $c = Channel.new;\n    $c.send(1);\n    $c.send([2, 3, 4, 5]);\n    $c.close;\n    say $c.list; # OUTPUT: «(1 [2 3 4 5])␤»","n":"send"},{"n":"receive","d":"Defined as:\n\n    method receive(Channel:D:)\n\nReceives and removes an item from the channel. It blocks if no item is\npresent, waiting for a send from another thread.\n\nThrows an exception of type X::Channel::ReceiveOnClosed if the channel has\nbeen closed, and the last item has been removed already, or if close is\ncalled while receive is waiting for an item to arrive.\n\nIf the channel has been marked as erratic with method fail, and the last\nitem has been removed, throws the argument that was given to fail as an\nexception.\n\nSee method poll for a non-blocking version that won't throw exceptions.\n\n    my $c = Channel.new;\n    $c.send(1);\n    say $c.receive; # OUTPUT: «1␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"poll","d":"Defined as:\n\n    method poll(Channel:D:)\n\nReceives and removes an item from the channel. If no item is present,\nreturns Nil instead of waiting.\n\n    my $c = Channel.new;\n    Promise.in(2).then: { $c.close; }\n    ^10 .map({ $c.send($_); });\n    loop {\n        if $c.poll -> $item { $item.say };\n        if $c.closed  { last };\n        sleep 0.1;\n    }\n\nSee method receive for a blocking version that properly responds to channel\nclosing and failure."},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method Capture(Channel:D --> Capture:D)\n\nEquivalent to calling .List.Capture on the invocant.","n":"Capture"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"iterator"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method list(Channel:D: --> List:D)\n\nReturns a list based on the Seq which will iterate items in the queue and\nremove each item from it as it iterates. This can only terminate once the\nclose method has been called.\n\n    my $c = Channel.new; $c.send(1); $c.send(2);\n    $c.close;\n    say $c.list; # OUTPUT: «(1 2)␤»","n":"list"},{"s":{"p":["*%_"],"r":"Awaitable::Handle:D"},"m":0,"k":"m","n":"get-await-handle"},{"s":{"p":["*%_"],"r":"Nil"},"m":0,"k":"m","n":"close","d":"Defined as:\n\n    method close(Channel:D:)\n\nClose the Channel, normally. This makes subsequent send calls die with\nX::Channel::SendOnClosed. Subsequent calls of .receive may still drain any\nremaining items that were previously sent, but if the queue is empty, will\nthrow an X::Channel::ReceiveOnClosed exception. Since you can produce a Seq\nfrom a Channel by contextualizing to array with @() or by calling the .list\nmethod, these methods will not terminate until the channel has been closed.\nA whenever-block will also terminate properly on a closed channel.\n\n    my $c = Channel.new;\n    $c.close;\n    $c.send(1);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n\n\nPlease note that any exception thrown may prevent .close from being called,\nthis may hang the receiving thread. Use a LEAVE phaser to enforce the\n.close call in this case."},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"elems"},{"n":"fail","d":"Defined as:\n\n    method fail(Channel:D: $error)\n\nCloses the Channel (that is, makes subsequent send calls die), and enqueues\nthe error to be thrown as the final element in the channel. Method receive\nwill throw that error as an exception. Does nothing if the channel has\nalready been closed or .fail has already been called on it.\n\n    my $c = Channel.new;\n    $c.fail(\"Bad error happens!\");\n    $c.receive;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::AdHoc: Bad error happens!␤»","s":{"p":["$error is copy","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method closed(Channel:D: --> Promise:D)\n\nReturns a promise that will be kept once the channel is closed by a call to\nmethod close.\n\n    my $c = Channel.new;\n    $c.closed.then({ say \"It's closed!\" });\n    $c.close;\n    sleep 1;","n":"closed","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"!peek"}]},{"k":"e","n":"Less","t":"Order"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<..>"},{"n":"infix:<..>","k":"s","m":1,"s":{"p":["$min","$max"],"r":"Mu"}},{"n":"&cache","t":"Sub","k":"v"},{"n":"cache","s":{"r":"Mu","p":["+@l"]},"m":1,"k":"s"},{"b":"A","n":"Cancellation","a":[{"k":"v","t":"Mu","n":"$.cancelled"},{"t":"Mu","n":"$!lock","k":"v"},{"k":"v","t":"Positional","n":"@!async_handles"}],"t":"Cancellation","d":"TITLE\nclass Cancellation\n\nSUBTITLE\nRemoval of a task from a Scheduler before normal completion\n\n    my class Cancellation {}\n\nA low level part of the Raku concurrency system. Some Scheduler objects\nreturn a Cancellation with the .cue method which can be used to cancel the\nscheduled execution before normal completion. Cancellation.cancelled is a\nboolean that is true after #cancel is called.\n\n","mro":["Any"],"k":"c","m":[{"m":0,"k":"s","s":{"r":"Nil","p":[":async_handles(@!async_handles)","*%_"]},"n":"BUILD"},{"n":"cancel","d":"Defined as:\n\n    method cancel()\n\nUsage:\n\n    Cancellation.cancel\n\n\nCancels the scheduled execution of a task before normal completion.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"cancelled"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}]},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<le>"},{"n":"infix:<le>","k":"s","m":1,"s":{"r":"Mu","p":["$x?"]}},{"s":{"r":"Mu","p":["\\a","\\b"]},"m":1,"k":"s","n":"infix:<le>"},{"m":1,"k":"s","s":{"p":["Blob:D \\a","Blob:D \\b"],"r":"Mu"},"n":"infix:<le>"},{"n":"infix:<le>","s":{"r":"Bool:D","p":["Str:D \\a","Str:D \\b"]},"k":"s","m":1},{"n":"infix:<le>","s":{"r":"Bool:D","p":["str $a","str $b"]},"m":1,"k":"s"},{"s":{"p":["str $a","str $b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<le>"},{"n":"FileRenamed","t":"FileChangeEvent","k":"e"},{"t":"ProtocolType","n":"PROTO_TCP","k":"e"},{"b":"A","t":"Sub","a":[{"n":"@!dispatchees","t":"List","k":"v"},{"k":"v","n":"$!dispatcher_cache","t":"Mu"},{"n":"$!dispatcher","t":"Mu","k":"v"},{"k":"v","t":"int","n":"$!rw"},{"t":"Mu","n":"$!inline_info","k":"v"},{"n":"$!yada","t":"int","k":"v"},{"n":"$!package","t":"Mu","k":"v"},{"n":"$!onlystar","t":"int","k":"v"},{"k":"v","t":"List","n":"@!dispatch_order"},{"k":"v","t":"Mu","n":"$!dispatch_cache"},{"t":"Mu","n":"$!why","k":"v"},{"n":"$!do","t":"Code","k":"v"},{"n":"$!signature","t":"Signature","k":"v"},{"k":"v","t":"List","n":"@!compstuff"}],"d":"TITLE\nclass Sub\n\nSUBTITLE\nSubroutine\n\n    class Sub is Routine { }\n\nA type for subroutines and operators. Subs are created with the sub\ndeclarator keyword followed by an optional identifier. This short tutorial\nexplains how operators are declared. For details of a sub's parameter list,\nsee Signature.\n\nNote that subs that go by the same name as coercers will not take\nprecedence over them. Use the &-sigil to call them.\n\n    sub Int(Str $s){'what?'};\n    say [Int, Int('42'),&Int('42')];\n    # OUTPUT: «[(Int) 42 what?]␤»\n\n Subs can be nested and scoped with my and our, whereby my is the default.\nA sub declared with my cannot be reached from any outer scope. An our\nscoped sub will not redefine a sub of the same name in the outer scope. Any\nsub can be accessed via a closure from any outer scope. For instance, in\nthis example\n\n    sub can-be-seener( $whatever ) {\n      my sub can-be-seen ( $objection ) {\n        return $whatever but $objection;\n      }\n      return &can-be-seen\n    }\n\n    my $objectioner = can-be-seener( \"Really?\");\n    say $objectioner(42).Int; # OUTPUT: «42␤»\n\n$objectioner will contain the can-be-seen subroutine, even if it has been\ndeclared in another scope; calling it with 42 will return \"Really?\" with\nthe number 42 mixed in, as shown in the last sentence.\n\nOperators\n\nOperators are also Subs. Their definition includes the category they belong\nto and their code, precedence and associativity. The syntax used in their\ndefinition is an example of extended identifiers.\n\nTraits \n\nA Trait is a sub that is applied at compile time to various objects like\nclasses, routines or containers. It is declared with the trait_mod\ndeclarator followed by a colon and a string literal containing the name of\nthe trait. A single positional parameter defines the type of the object\nthat the trait is applied to. A single named argument defines the secondary\nname and may carry arguments when the trait is called. Traits are a special\ngrammar category and are allowed to be placed after most language object\nnames or parameter lists.\n\n    say 'start';\n    multi sub trait_mod:<is>(Sub $s, :$foo){\n        say \"⟨is foo⟩ has been called with ⟨$foo⟩ on {$s.WHICH}\";\n    }\n    sub bar() is foo<oi‽> {\n        say 'bar has been called'\n    }\n    bar();\n    # OUTPUT: «⟨is foo⟩ has been called with ⟨oi‽⟩ on Sub|47563000␤start␤bar has been called␤»\n\nUse destructuring to call traits with complex arguments.\n\n    multi trait_mod:<is>(Variable $a, :@foo [$firstpos, *@restpos, :$named, *%restnameds]) {\n        say [$firstpos, @restpos, $named, %restnameds]\n    }\n    my $x is foo[1,2,3,:named<a>, :2b, :3c] = 1\n    # OUTPUT: «[1 [2 3] a {b => 2, c => 3}]␤»\n\nDespite its funky syntax, a trait is just a normal Sub. We can apply traits\nto it (or even themselves) and we can apply traits to objects at runtime.\n\n    multi sub trait_mod:<is> (Sub $s, :$foo) is foo {\n        say 'is foo called'\n    }\n    sub bar {}\n    &trait_mod:<is>(&bar, :foo);\n    # OUTPUT: «is foo called␤is foo called␤»","n":"Sub","k":"c","mro":["Callable","Routine"]},{"k":"c","m":[{"n":"new","d":"method new(Iterator:D $iter --> Seq:D)\n\nCreates a new Seq object from the iterator passed as the single argument.","s":{"p":["Iterator:D $iter","*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"new-consumed"},{"d":"method iterator(Seq:D: --> Iterator:D)\n\nReturns the underlying iterator, and marks the invocant as consumed. If\ncalled on an already consumed sequence, throws an error of type\nX::Seq::Consumed.","n":"iterator","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"Capture","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method elems(Seq:D:)\n\nIf the caller Seq is not lazy, consumes and caches its values, returning\ntheir length. Otherwise, throws an error of type X::Cannot::Lazy.","n":"elems"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Numeric"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"Int"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"Bool"},{"n":"join","s":{"p":["$separator = \"\"","*%_"],"r":"Str:D"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Nil"},"m":0,"k":"m","n":"sink","d":"Defined as:\n\n    method sink(--> Nil)\n\nCalls sink-all if it is an Iterator, sink if the Sequence is a list.\n\n    say (1 ... 1000).sink; # OUTPUT: «Nil␤»\n\nThis is something you might want to do for the side effects of producing\nthose values."},{"m":1,"k":"m","s":{"p":["&body","*%_"],"r":"Mu"},"d":"multi method from-loop(&body --> Seq:D)\n    multi method from-loop(&body, &cond, :$repeat --> Seq:D)\n    multi method from-loop(&body, &cond, &afterward --> Seq:D)\n\nThese methods create new Seq-based callbacks.\n\nThe first form produces an infinite Seq by calling &body each time a new\nelement is requested, using the return value from &body as the item. This\nemulates (or implements) a loop { body } construct.\n\nThe second form calls &cond before each call to &body, and terminates the\nsequence if &cond returns a false value. If $repeat is set to a true value,\nthe first call to &cond is omitted, and &body called right away. This\nemulates (or implements) while cond { body } and repeat { body } while cond\nloops.\n\nThe third form enables C-style looping by calling a third callback,\n&afterward, after each call to &body.","n":"from-loop"},{"m":1,"k":"m","s":{"p":["&body","&cond",":$repeat!","*%_"],"r":"Mu"},"d":"multi method from-loop(&body --> Seq:D)\n    multi method from-loop(&body, &cond, :$repeat --> Seq:D)\n    multi method from-loop(&body, &cond, &afterward --> Seq:D)\n\nThese methods create new Seq-based callbacks.\n\nThe first form produces an infinite Seq by calling &body each time a new\nelement is requested, using the return value from &body as the item. This\nemulates (or implements) a loop { body } construct.\n\nThe second form calls &cond before each call to &body, and terminates the\nsequence if &cond returns a false value. If $repeat is set to a true value,\nthe first call to &cond is omitted, and &body called right away. This\nemulates (or implements) while cond { body } and repeat { body } while cond\nloops.\n\nThe third form enables C-style looping by calling a third callback,\n&afterward, after each call to &body.","n":"from-loop"},{"m":1,"k":"m","s":{"p":["&body","&cond","*%_"],"r":"Mu"},"d":"multi method from-loop(&body --> Seq:D)\n    multi method from-loop(&body, &cond, :$repeat --> Seq:D)\n    multi method from-loop(&body, &cond, &afterward --> Seq:D)\n\nThese methods create new Seq-based callbacks.\n\nThe first form produces an infinite Seq by calling &body each time a new\nelement is requested, using the return value from &body as the item. This\nemulates (or implements) a loop { body } construct.\n\nThe second form calls &cond before each call to &body, and terminates the\nsequence if &cond returns a false value. If $repeat is set to a true value,\nthe first call to &cond is omitted, and &body called right away. This\nemulates (or implements) while cond { body } and repeat { body } while cond\nloops.\n\nThe third form enables C-style looping by calling a third callback,\n&afterward, after each call to &body.","n":"from-loop"},{"n":"from-loop","d":"multi method from-loop(&body --> Seq:D)\n    multi method from-loop(&body, &cond, :$repeat --> Seq:D)\n    multi method from-loop(&body, &cond, &afterward --> Seq:D)\n\nThese methods create new Seq-based callbacks.\n\nThe first form produces an infinite Seq by calling &body each time a new\nelement is requested, using the return value from &body as the item. This\nemulates (or implements) a loop { body } construct.\n\nThe second form calls &cond before each call to &body, and terminates the\nsequence if &cond returns a false value. If $repeat is set to a true value,\nthe first call to &cond is omitted, and &body called right away. This\nemulates (or implements) while cond { body } and repeat { body } while cond\nloops.\n\nThe third form enables C-style looping by calling a third callback,\n&afterward, after each call to &body.","s":{"r":"Mu","p":["&body","&cond","&afterwards","*%_"]},"k":"m","m":1}],"mro":["Sequence","PositionalBindFailover","Iterable","Cool"],"a":[{"n":"$!iter","t":"Iterator","k":"v"},{"k":"v","n":"$!list","t":"Mu"}],"t":"Seq","d":"TITLE\nclass Seq\n\nSUBTITLE\nAn iterable, lazy sequence of values\n\n    class Seq is Cool does Iterable does PositionalBindFailover { }\n\nA Seq represents anything that can lazily produce a sequence of values. A\nSeq is born in a state where iterating it will consume the values. However,\ncalling .cache on a Seq will return a List that is still lazy, but stores\nthe generated values for later access. However, assigning a Seq to an array\nconsumes the Seq; alternatively, you can use the lazy statement prefix to\navoid it from being iterated during the assignment:\n\n    # The Seq created by gather ... take is consumed on the spot here.\n    my @a = gather do { say 'consuming...'; take 'one' };  # OUTPUT: «consuming...␤»\n\n    # The Seq here is only consumed as we iterate over @a later.\n    my @a = lazy gather do { say 'consuming...'; take 'one' };  # outputs nothing.\n    .say for @a;  # OUTPUT: «consuming...␤one␤»\n\n\nA typical use case is method lines in IO::Handle, which could use a lot of\nmemory if it stored all the lines read from the file. So\n\n    for open('README.md').lines -> $line {\n        say $line;\n    }\n\n\nwon't keep all lines from the file in memory.\n\nThis implies that you cannot iterate the same Seq object twice (otherwise\nit couldn't throw away old values), so this dies:\n\n    my @a = 1, 2, 3;\n    my @b = <a b c>;\n    my \\c = @a Z=> @b;\n    .say for c;\n    .say for c; # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Seq::Consumed: This Seq has already been iterated, and its values consumed\n    # (you might solve this by adding .cache on usages of the Seq, or\n    # by assigning the Seq into an array)»\n\nA high-level construct to generate a Seq is gather/take, as well as many\nbuilt-in methods like map and grep, low-level constructors to create a Seq\nfrom an iterator or from looping constructs are available too.\n\nCaution: No program should ever assume a Seq may only be iterated once even\nif not cached by the program. Caching is a volatile state exposed to the\ndeveloper as an optimization. The Seq may become cached by many operations,\nincluding calling perl on the Seq (if called prior to a non-cached\niteration). From version 6.d, you .perl can be called on consumed <Seq>. If\na program assumes a Seq can only iterate once, but then is later changed to\ncall one of these operations during the loop, that assumption will fail.\n\n","n":"Seq","b":"C"},{"t":"Sub","n":"&end","k":"v"},{"n":"end","k":"s","m":1,"s":{"p":["$a"],"r":"Mu"}},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(&)>"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"infix:<(&)>"},{"s":{"r":"Mu","p":["QuantHash:D \\a"]},"m":1,"k":"s","n":"infix:<(&)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a"]},"n":"infix:<(&)>"},{"n":"infix:<(&)>","k":"s","m":1,"s":{"p":["Setty:D \\a","Setty:D \\b"],"r":"Mu"}},{"n":"infix:<(&)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Baggy:D \\b"]}},{"m":1,"k":"s","s":{"p":["Baggy:D \\a","Setty:D \\b"],"r":"Mu"},"n":"infix:<(&)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"n":"infix:<(&)>"},{"n":"infix:<(&)>","s":{"r":"Mu","p":["Mixy:D \\a","Setty:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(&)>","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(&)>","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"n":"infix:<(&)>"},{"n":"infix:<(&)>","k":"s","m":1,"s":{"r":"Mu","p":["Mixy:D \\a","Mixy:D \\b"]}},{"s":{"p":["Baggy:D \\a","Any:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(&)>"},{"n":"infix:<(&)>","k":"s","m":1,"s":{"r":"Mu","p":["Any:D \\a","Baggy:D \\b"]}},{"m":1,"k":"s","s":{"p":["Mixy:D \\a","Any:D \\b"],"r":"Mu"},"n":"infix:<(&)>"},{"n":"infix:<(&)>","m":1,"k":"s","s":{"p":["Any:D \\a","Mixy:D \\b"],"r":"Mu"}},{"n":"infix:<(&)>","m":1,"k":"s","s":{"p":["Map:D \\a","Map:D \\b"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["$","Failure:D \\b"],"r":"Mu"},"n":"infix:<(&)>"},{"s":{"p":["Failure:D \\a","$"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(&)>"},{"n":"infix:<(&)>","k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"}},{"s":{"r":"Mu","p":["**@p"]},"m":1,"k":"s","n":"infix:<(&)>"},{"k":"ro","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"log10","d":"multi sub    log10(Numeric:D  --> Numeric:D)\n    multi method log10(Numeric:D: --> Numeric:D)\n\nCalculates the logarithm to base 10. Returns NaN for negative arguments and\n-Inf for 0."},{"d":"multi method roots(Numeric:D: Int:D $n --> Positional)\n\nReturns a list of the $n complex roots, which evaluate to the original\nnumber when raised to the $nth power.","n":"roots","m":0,"k":"m","s":{"r":"Mu","p":["Cool $n","*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"FatRat"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"succ","d":"method succ(Numeric:D:)\n\nReturns the number incremented by one (successor)."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method pred(Numeric:D:)\n\nReturns the number decremented by one (predecessor).","n":"pred"}],"mro":[],"d":"TITLE\nrole Numeric\n\nSUBTITLE\nNumber or object that can act as a number\n\n    role Numeric { ... }\n\nCommon role for numbers and types that can act as numbers.\n\nBinary numeric operations return an object of the \"wider\" type:\n\n    Int         narrowest\n    Rat\n    FatRat\n    Num\n    Complex     widest\n\n\nSo for example the product of a Rat and an Int is a Rat.\n\nUnary operations that in pure math usually return an irrational number\ngenerally return Num in Raku.\n\n","t":"Numeric","n":"Numeric","b":"C"},{"n":"PF_UNIX","t":"ProtocolFamily","k":"e"},{"k":"v","n":"&unlink","t":"Sub"},{"k":"s","m":1,"s":{"r":"Mu","p":["*@filenames"]},"n":"unlink"},{"mro":["Rational[Int,Int]","Real","Numeric","Cool"],"k":"c","m":[{"n":"Rat","m":0,"k":"m","s":{"r":"Rat:D","p":["Real $?","*%_"]}},{"n":"FatRat","k":"m","m":0,"s":{"r":"FatRat:D","p":["Real $?","*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"numerator"},{"n":"denominator","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"},{"s":{"p":["\\whole","\\fract","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!SLOW-STR"},{"n":"!STRINGIFY","m":0,"k":"m","s":{"p":["\\whole","\\fract","Int:D $precision","*%_"],"r":"Mu"}}],"n":"Rat","d":"TITLE\nclass Rat\n\nSUBTITLE\nRational number (limited-precision)\n\n    class Rat is Cool does Rational[Int, uint64] { }\n\nRat objects store rational numbers as a pair of a numerator and\ndenominator. Number literals with a dot but without exponent produce Rats.\n\n    say 3.1;          # OUTPUT: «3.1␤»      (same as: Rat.new(31, 10))\n    say 3.1.^name;    # OUTPUT: «Rat␤»\n    say 3.1.nude;     # OUTPUT: «(31 10)␤»\n\n    say <1/2>;        # OUTPUT: «0.5␤»      (same as: Rat.new(1, 2))\n    say <1/2>.^name;  # OUTPUT: «Rat␤»\n    say <1/2>.nude;   # OUTPUT: «(1 2)␤»\n\nThus arithmetic with short dotted-decimal numbers does not suffer from\nfloating point errors.\n\nTo prevent the numerator and denominator from becoming pathologically\nlarge, the denominator is limited to 64 bit storage. On overflow of the\ndenominator a Num (floating-point number) is returned instead.\n\nFor example this function crudely approximates a square root, and overflows\nthe denominator quickly:\n\n    sub approx-sqrt($n, $iterations) {\n        my $x = $n;\n        $x = ($x + $n / $x) / 2 for ^$iterations;\n        return $x;\n    }\n    say approx-sqrt(2, 5).^name;     # OUTPUT: «Rat␤»\n    say approx-sqrt(2, 10).^name;    # OUTPUT: «Num␤»\n\nIf you want arbitrary precision arithmetic with rational numbers, use the\nFatRat type instead.\n\nRat objects are immutable.\n\n","a":[{"n":"$.numerator","t":"Int","k":"v"},{"k":"v","t":"Int","n":"$.denominator"}],"t":"Rat","b":"C"},{"n":"REPL","a":[{"k":"v","n":"$.compiler","t":"Mu"},{"k":"v","t":"Bool","n":"$!multi-line-enabled"},{"t":"IO::Path","n":"$!history-file","k":"v"},{"t":"Mu","n":"$!save_ctx","k":"v"},{"n":"$!need-more-input","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!control-not-allowed"},{"k":"v","t":"Positional","n":"@!completions"}],"t":"REPL","mro":["Completions","Any"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["Mu \\compiler","Mu \\adverbs","*%_"]},"n":"new"},{"n":"init","m":0,"k":"m","s":{"p":["Mu \\compiler","$multi-line-enabled","*%_"],"r":"Nil"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"teardown"},{"s":{"p":["$code","\\exception","*%adverbs"],"r":"Mu"},"k":"m","m":0,"n":"repl-eval"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"interactive_prompt"},{"n":"repl-loop","k":"m","m":0,"s":{"p":["*%adverbs"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"n":"ctxsave"},{"m":0,"k":"m","s":{"p":["Mu $value","*%_"],"r":"Bool:D"},"n":"input-incomplete"},{"n":"input-toplevel-control","k":"m","m":0,"s":{"r":"Bool:D","p":["Mu $value","*%_"]}},{"s":{"r":"Nil","p":["Mu $value","*%_"]},"k":"m","m":0,"n":"repl-print"},{"n":"history-file","s":{"r":"Str:D","p":["*%_"]},"m":0,"k":"m"},{"n":"compiler","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","b":"A"},{"k":"v","n":"&trait_mod:<of>","t":"Sub"},{"n":"trait_mod:<of>","k":"s","m":1,"s":{"r":"Mu","p":["Mu:U $target","Mu:U $type"]}},{"n":"trait_mod:<of>","s":{"r":"Mu","p":["Routine:D $target","Mu:U $type"]},"m":1,"k":"s"},{"b":"A","mro":["Callable","Routine"],"k":"c","n":"Submethod","d":"TITLE\nclass Submethod\n\nSUBTITLE\nMember function that is not inherited by subclasses\n\n    class Submethod is Routine {}\n\nA Submethod is a method that is not inherited by child classes. They are\ntypically used for per-class initialization and tear-down tasks which are\ncalled explicitly per class in an inheritance tree, usually for enforcing a\nparticular order. For example object construction with the BUILD submethod\nhappens from the least-derived to most-derived, so that the most-derived\n(child) classes can depend on the parent already being initialized.\n\nSubmethods are of type Submethod, and are declared with the submethod\ndeclarator:\n\n    class Area {\n        has $.size;\n        submethod BUILD(:$x, :$y, :$z) {\n            $!size = $x * $y * $z;\n        }\n    }\n\n","a":[{"t":"List","n":"@!dispatchees","k":"v"},{"k":"v","t":"Mu","n":"$!dispatcher_cache"},{"k":"v","t":"Mu","n":"$!dispatcher"},{"t":"int","n":"$!rw","k":"v"},{"n":"$!inline_info","t":"Mu","k":"v"},{"k":"v","t":"int","n":"$!yada"},{"k":"v","t":"Mu","n":"$!package"},{"k":"v","t":"int","n":"$!onlystar"},{"n":"@!dispatch_order","t":"List","k":"v"},{"k":"v","n":"$!dispatch_cache","t":"Mu"},{"t":"Mu","n":"$!why","k":"v"},{"t":"Code","n":"$!do","k":"v"},{"k":"v","t":"Signature","n":"$!signature"},{"t":"List","n":"@!compstuff","k":"v"}],"t":"Submethod"},{"k":"e","n":"Bool","t":"Bool"},{"k":"e","n":"Bool::False","t":"Bool"},{"k":"e","t":"Bool","n":"Bool::True"},{"n":"Metamodel::Primitives","t":"Metamodel::Primitives","d":"TITLE\nclass Metamodel::Primitives\n\nSUBTITLE\nMetaobject that supports low-level type operations\n\n    class Metamodel::Primitives {}\n\nMetamodel::Primitives provides low-level operations for working with types,\nwhich are otherwise only available as implementation-dependent directives.\nThese primitives are available as class methods.\n\nHere is an example that steals the metamodel instance from the Int class to\ncreate a custom type (usually you would create your own metaclass if you\nmess with something as low-level), which allows calling of just one method\ncalled why:\n\n    my Mu $type := Metamodel::Primitives.create_type(Int.HOW, 'P6opaque');\n    $type.^set_name('why oh why?');\n    my %methods =  why => sub ($) { say 42 };\n    Metamodel::Primitives.install_method_cache($type, %methods, :authoritative);\n    $type.why;      # 42\n    $type.list;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::NotFound: Method 'list' not found for invocant of class 'why oh why?'␤»\n\n","mro":["Any"],"k":"c","m":[{"n":"create_type","d":"method create_type(Mu $how, $repr = 'P6opaque')\n\nCreates and returns a new type from a metaobject $how and a representation\nname.","s":{"p":["Mu $how","$repr = \"P6opaque\"",":$mixin = Bool::False","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"set_package","d":"method set_package(Mu $type, $package)\n\nSets the package associated with the type.","s":{"r":"Mu","p":["Mu $type","$package","*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["Mu $type","%cache",":$authoritative = Bool::True","*%_"],"r":"Mu"},"d":"method install_method_cache( Mu $type, %cache, :$authoritative = True)\n\nInstalls a method cache, that is, a mapping from method names to code\nobjects. If :authoritative is missing, or set to True, then calls of\nmethods that do not exist in the cache will throw an exception of type\nX::Method::NotFound. If :authoritative is set to False, the usual fallback\nmechanism are tried.","n":"install_method_cache"},{"s":{"p":["Mu $type","@cache",":$authoritative = Bool::True",":$call_accepts = Bool::False","*%_"],"r":"Mu"},"k":"m","m":0,"n":"configure_type_checking","d":"method configure_type_checking( Mu $type, @cache, :$authoritative = True,   :$call_accepts = False )\n\nConfigures the type checking for $type. @cache is a list of known types\nagainst which $type checks positively (so in a classical class-based\nsystem, the type itself and all recursive superclasses). If :authoritative\nis missing or True, this type will fail checks against all types not in\n@cache. If :call_accepts is True, the method ACCEPTS will be called for\ntype checks against this type."},{"n":"configure_destroy","d":"method configure_destroy(Mu $type, $destroy)\n\nConfigures whether DESTROY methods are called (if present) when the garbage\ncollector collects an object of this type (if $destroy is set to a true\nvalue). This comes with a performance overhead, so should only be set to a\ntrue value if necessary.","s":{"p":["Mu $type","$destroy","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"compose_type","d":"method compose_type(Mu $type, $configuration)\n\nComposes $type (that is, finalizes it to be ready for instantiation). See\nhttps://github.com/perl6/nqp/blob/master/docs/6model/repr-compose-protocol.markdown\nfor what $configuration can contain (until we have better docs, sorry).","s":{"r":"Mu","p":["Mu $type","$configuration","*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["Mu $obj","Mu $type","*%_"],"r":"Mu"},"d":"method rebless(Mu $object, Mu $type)\n\nChanges $obj to be of type $type. This only works if $type type-checks\nagainst the current type of $obj, and if the storage of $object is a subset\nof that of $type.","n":"rebless"},{"n":"is_type","d":"method is_type(Mu \\obj, Mu \\type --> Bool:D)\n\nType-checks obj against type","s":{"p":["Mu \\obj","Mu \\type","*%_"],"r":"Mu"},"m":0,"k":"m"}],"b":"A"},{"k":"v","t":"Sub","n":"&combinations"},{"k":"s","m":1,"s":{"r":"Seq:D","p":["\\n","\\k"]},"n":"combinations"},{"n":"combinations","k":"s","m":1,"s":{"p":["\\n","Range:D \\k"],"r":"Seq:D"}},{"s":{"r":"Seq:D","p":["Iterable \\n","\\k"]},"m":1,"k":"s","n":"combinations"},{"n":"combinations","s":{"p":["\\n"],"r":"Seq:D"},"k":"s","m":1},{"n":"&postfix:<ⁿ>","t":"Sub+{is-pure}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a","\\b"]},"n":"postfix:<ⁿ>"},{"k":"v","n":"&prefix:<|>","t":"Sub+{Precedence}"},{"k":"s","m":1,"s":{"p":["\\x"],"r":"Slip:D"},"n":"prefix:<|>"},{"k":"v","n":"&atan","t":"Sub+{is-pure}"},{"m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]},"n":"atan"},{"n":"atan","s":{"r":"Mu","p":["Cool \\x"]},"k":"s","m":1},{"n":"atan","m":1,"k":"s","s":{"p":["num $x"],"r":"num"}},{"t":"Sub+{Precedence}","n":"&infix:<andthen>","k":"v"},{"n":"infix:<andthen>","k":"s","m":1,"s":{"p":["+\\a is raw"],"r":"Mu"}},{"t":"Sub+{Precedence}","n":"&infix:<=>","k":"v"},{"n":"infix:<=>","m":0,"k":"s","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"}},{"t":"QuantHash","d":"TITLE\nrole QuantHash\n\nSUBTITLE\nObject hashes with limitation on type of value\n\n    role QuantHash does Associative { }\n\nThe QuantHash role provides the basic functionality shared by the Setty,\nBaggy and Mixy roles. These provide object hashes of which the values are\nlimited in some way.\n\nQuantHashes are what set operators use internally.\n\n","n":"QuantHash","k":"ro","m":[{"d":"method keyof()\n\nReturns the type of value a key of this QuantHash may have. This is\ntypically Mu.","n":"keyof","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["\\elems","*%_"]},"m":0,"k":"m","n":"SET-SELF"},{"n":"Int","m":0,"k":"m","s":{"p":["*%_"],"r":"Int:D"}},{"n":"Num","k":"m","m":0,"s":{"p":["*%_"],"r":"Num:D"}},{"m":0,"k":"m","s":{"r":"Numeric:D","p":["*%_"]},"n":"Numeric"},{"n":"Real","k":"m","m":0,"s":{"p":["*%_"],"r":"Real:D"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Capture"},{"n":"fmt","m":0,"k":"m","s":{"p":["Cool $format = \"\\%s\\t\\%s\"","$sep = \"\\n\"","*%_"],"r":"Mu"}},{"n":"hash","d":"method hash()\n\nCoerces the QuantHash object to a Hash (by stringifying the objects for the\nkeys) with the values of the hash limited to the same limitation as\nQuantHash, and returns that.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"Hash","d":"method Hash()\n\nCoerces the QuantHash object to a Hash (by stringifying the objects for the\nkeys) without any limitations on the values, and returns that."}],"mro":[],"b":"C"},{"t":"Endian","n":"BigEndian","k":"e"},{"t":"Awaitable","n":"Awaitable","k":"ro","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"get-await-handle"}],"mro":[],"b":"C"},{"b":"C","n":"Awaitable::Handle","t":"Awaitable::Handle","a":[{"k":"v","n":"$.already","t":"Bool"},{"k":"v","t":"Bool","n":"$.success"},{"k":"v","n":"$.result","t":"Mu"},{"k":"v","n":"$.cause","t":"Exception"}],"mro":[],"m":[{"n":"already-success","s":{"p":["Mu \\result","*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["Mu \\cause","*%_"],"r":"Mu"},"n":"already-failure"},{"n":"subscribe-awaiter","k":"m","m":0,"s":{"p":["&subscriber","*%_"],"r":"Mu"}},{"n":"!ALREADY_FAILURE","s":{"r":"Mu","p":["Mu \\cause","*%_"]},"m":0,"k":"m"},{"n":"!ALREADY_SUCCESS","m":0,"k":"m","s":{"p":["Mu \\result","*%_"],"r":"Mu"}}],"k":"ro"},{"k":"v","t":"Sub","n":"&tclc"},{"s":{"p":["Cool $s"],"r":"Mu"},"m":1,"k":"s","n":"tclc"},{"k":"v","n":"&atomic-fetch-sub","t":"Sub"},{"n":"atomic-fetch-sub","s":{"p":["atomicint $target is rw","int $add"],"r":"atomicint"},"m":1,"k":"s"},{"n":"atomic-fetch-sub","s":{"r":"atomicint","p":["atomicint $target is rw","Int:D $add"]},"m":1,"k":"s"},{"n":"atomic-fetch-sub","s":{"r":"atomicint","p":["atomicint $target is rw","$add"]},"k":"s","m":1},{"k":"v","t":"Sub+{is-nodal}+{Precedence}+{is-nodal}","n":"&postcircumfix:<{ }>"},{"m":1,"k":"s","s":{"p":["\\SELF","\\key"],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"s":{"p":["\\SELF","\\key","Mu \\ASSIGN"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<{ }>"},{"s":{"r":"Mu","p":["\\SELF","\\key","Mu :$BIND! is raw"]},"k":"s","m":1,"n":"postcircumfix:<{ }>"},{"k":"s","m":1,"s":{"p":["\\SELF","\\key",":$delete!"],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":["\\SELF","\\key",":$delete!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","\\key",":$exists!"]},"k":"s","m":1},{"s":{"p":["\\SELF","\\key",":$exists!","*%other"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF","\\key",":$kv!","*%other"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","\\key",":$p!","*%other"]}},{"m":1,"k":"s","s":{"p":["\\SELF","\\key",":$k!","*%other"],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":["\\SELF","\\key",":$v!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Iterable \\key"]}},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Iterable \\key","Mu \\ASSIGN"]},"k":"s","m":1},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF","Iterable \\key",":$BIND!"],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Iterable \\key",":$delete!","*%other"]},"k":"s","m":1},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Iterable \\key",":$exists!","*%other"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Iterable \\key",":$kv!","*%other"]},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":["\\SELF","Iterable \\key",":$p!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF","Iterable \\key",":$k!","*%other"],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Iterable \\key",":$v!","*%other"]}},{"m":1,"k":"s","s":{"p":["\\SELF","Whatever $"],"r":"Mu"},"n":"postcircumfix:<{ }>"},{"s":{"r":"Mu","p":["\\SELF","Whatever $","Mu \\ASSIGN"]},"k":"s","m":1,"n":"postcircumfix:<{ }>"},{"s":{"p":["\\SELF","Whatever $",":$BIND!"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":["\\SELF","Whatever $",":$delete!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Whatever $",":$exists!","*%other"]},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Whatever $",":$kv!","*%other"]},"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF","Whatever $",":$p!","*%other"],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF","Whatever $",":$k!","*%other"],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Whatever $",":$p!","*%other"]},"k":"s","m":1},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF","Whatever $",":$v!","*%other"]},"k":"s","m":1},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF",":$BIND!"],"r":"Mu"},"m":1,"k":"s"},{"n":"postcircumfix:<{ }>","s":{"p":["\\SELF",":$delete!","*%other"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<{ }>","k":"s","m":1,"s":{"p":["\\SELF",":$exists!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["\\SELF",":$kv!","*%other"]},"k":"s","m":1},{"n":"postcircumfix:<{ }>","k":"s","m":1,"s":{"r":"Mu","p":["\\SELF",":$p!","*%other"]}},{"n":"postcircumfix:<{ }>","m":1,"k":"s","s":{"p":["\\SELF",":$k!","*%other"],"r":"Mu"}},{"s":{"p":["\\SELF",":$p!","*%other"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<{ }>"},{"s":{"p":["\\SELF",":$v!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<{ }>"},{"n":"postcircumfix:<{ }>","s":{"r":"Mu","p":["Mu \\SELF","*%other"]},"m":1,"k":"s"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<%>"},{"n":"infix:<%>","m":1,"k":"s","s":{"p":[],"r":"Mu"}},{"n":"infix:<%>","m":1,"k":"s","s":{"p":["$x"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<%>"},{"n":"infix:<%>","m":1,"k":"s","s":{"p":["Real \\a","Real \\b"],"r":"Mu"}},{"n":"infix:<%>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"k":"s","m":1},{"n":"infix:<%>","m":1,"k":"s","s":{"r":"int","p":["int $a","int $b"]}},{"n":"infix:<%>","m":1,"k":"s","s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]}},{"k":"s","m":1,"s":{"p":["num $a","num $b"],"r":"num"},"n":"infix:<%>"},{"n":"infix:<%>","s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<%>","s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]},"k":"s","m":1,"n":"infix:<%>"},{"s":{"r":"Duration:D","p":["Duration:D $a","Real $b"]},"m":1,"k":"s","n":"infix:<%>"},{"t":"Sub","n":"&atomic-fetch-inc","k":"v"},{"n":"atomic-fetch-inc","m":1,"k":"s","s":{"p":["atomicint $target is rw"],"r":"atomicint"}},{"m":[{"n":"Capture","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}}],"k":"c","mro":["Any"],"t":"HyperWhatever","d":"TITLE\nclass HyperWhatever\n\nSUBTITLE\nPlaceholder for multiple unspecified values/arguments\n\n    class HyperWhatever { }\n\nHyperWhatever is very similar in functionality to Whatever. The difference\nlies in HyperWhatever standing in for multiple values, rather than a single\none.\n\nStandalone term\n\nJust like with Whatever, if a HyperWhatever is used as a term on its own,\nno currying is done and the HyperWhatever object will be used as-is:\n\n    sub foo ($arg) { say $arg.^name }\n    foo **; # OUTPUT: «HyperWhatever␤»\n\nYou can choose to interpret such a value as standing for multiple values in\nyour own routines. In core, a HyperWhatever can be used with this meaning\nwhen smartmatching with Lists:\n\n    say (1, 8)                ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 4, 5, 6, 7, 8) ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 8, 9)          ~~ (1, **, 8); # OUTPUT: «False␤»\n\nWherever a HyperWhatever appears in the list on the right-hand side means\nany number of elements can fill that space in the list being smartmatched.\n\nCurrying\n\nWhen it comes to currying, the HyperWhatever follows the same rules as\nWhatever. The only difference is HyperWhatever produces a Callable with a\n*@ slurpy as a signature:\n\n    say (**²)(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nA HyperWhatever closure can be imagined as a Whatever closure with another\nsub wrapped around it that simply maps each element in the arguments over:\n\n    my &hyper-whatever = sub (*@args) { map *², @args }\n    say hyper-whatever(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nWhen currying, mixing HyperWhatever with Whatever is not permitted.","n":"HyperWhatever","b":"A"},{"mro":["Any"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["|"],"r":"Mu"},"n":"new"},{"n":"name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"of","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"default"},{"n":"dynamic","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"n":"Scalar","d":"TITLE\nclass Scalar\n\nSUBTITLE\nA mostly transparent container used for indirections\n\n    class Scalar {}\n\nA Scalar is an internal indirection which is for most purposes invisible\nduring ordinary use of Raku. It is the default container type associated\nwith the $ sigil. A literal Scalar may be placed around a literal value by\nenclosing the value in $(…). This notation will appear in the output of a\n.perl method in certain places where it is important to note the presence\nof Scalars.\n\nWhen a value is assigned to a $-sigiled variable, the variable will\nactually bind to a Scalar, which in turn will bind to the value. When a\nScalar is assigned to a $-sigiled variable, the value bound to by that\nScalar will be bound to the Scalar which that variable was bound to (a new\none will be created if necessary.)\n\nIn addition, Scalars delegate all method calls to the value which they\ncontain. As such, Scalars are for the most part invisible. There is,\nhowever, one important place where Scalars have a visible impact: a Scalar\nwill shield its content from flattening by most Raku core list operations.\n\nA $-sigiled variable may be bound directly to a value with no intermediate\nScalar using the binding operator :=. You can tell if this has been done by\nexamining the output of the introspective pseudo-method .VAR:\n\n    my $a = 1;\n    $a.^name.say;     # OUTPUT: «Int␤»\n    $a.VAR.^name.say; # OUTPUT: «Scalar␤»\n    my $b := 1;\n    $b.^name.say;     # OUTPUT: «Int␤»\n    $b.VAR.^name.say; # OUTPUT: «Int␤»\n\nThis same thing happens when values are assigned to an element of an Array,\nhowever, Lists directly contain their values:\n\n    my @a = 1, 2, 3;\n    @a[0].^name.say;            # OUTPUT: «Int␤»\n    @a[0].VAR.^name.say;        # OUTPUT: «Scalar␤»\n    [1, 2, 3][0].^name.say;     # OUTPUT: «Int␤»\n    [1, 2, 3][0].VAR.^name.say; # OUTPUT: «Scalar␤»\n    (1, 2, 3)[0].^name.say;     # OUTPUT: «Int␤»\n    (1, 2, 3)[0].VAR.^name.say; # OUTPUT: «Int␤»\n\nArray elements may be bound directly to values using := as well; however,\nthis is discouraged as it may lead to confusion. Doing so will break exact\nround-tripping of .perl output – since Arrays are assumed to place Scalars\naround each element, Scalars are not denoted with $ in the output of\nArray.perl.\n\n    [1, $(2, 3)].perl.say;     # OUTPUT: «[1, (2, 3)]␤»\n    (1, $(2, 3)).perl.say;     # OUTPUT: «(1, $(2, 3))␤»\n\nBinding a Scalar to a $-sigiled variable replaces the existing Scalar in\nthat variable, if any, with the given Scalar. That means more than one\nvariable may refer to the same Scalar. Because the Scalar may be mutated,\nthis makes it possible to alter the value of both variables by altering\nonly one of them:\n\n    my $a = 1;\n    my $b := $a;\n    $b = 2;\n    $a.say;       # OUTPUT: «2␤»\n\n SSA-style constants bind directly to their value with no intervening\nScalar, even when assignment (=) is used. They may be forced to use a\nScalar by assigning a $-sigiled variable to them, at which point, they\nbehave entirely like $-sigiled variables.\n\n    my \\c = 1;\n    c.^name.say;             # OUTPUT: «Int␤»\n    c.VAR.^name.say;         # OUTPUT: «Int␤»\n    my $a = 1;\n    my \\d = $a;              # just \"my \\d = $ = 1\" works, too\n    d.^name.say;             # OUTPUT: «Int␤»\n    d.VAR.^name.say;         # OUTPUT: «Scalar␤»\n    d = 2;                   # ok\n    c = 2;                   # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»\n\nAtomic operations on Scalar\n\nA Scalar can have its value changed using a hardware-supported atomic\ncompare and swap operation. This is useful when implementing lock free data\nstructures and algorithms. It may also be fetched and assigned to in an\n\"atomic\" fashion, which ensures appropriate memory barriering and prevents\nunwanted optimizations of memory accesses.\n\nA Scalar that will be used with an atomic operation should always be\nexplicitly initialized with a value before any atomic operations are\nperformed upon it. This is to avoid races with lazy allocation and\nauto-vivification. For example:\n\n    cas(@a[5], $expected, $value)\n\n\nWill work in principle since an Array consists of Scalar containers.\nHowever, the container is only bound into the array upon initial\nassignment. Therefore, there would be a race to do that binding. The Scalar\natomic operations will never check for or do any such auto-vivification, so\nas to make such bugs much more evident (rather than only observed under\nstress).\n\nIntrospection\n\n  method of\n\n    method of(Scalar:D: --> Mu)\n\nReturns the type constraint of the container.\n\nExample:\n\n    my Cool $x = 42;\n    say $x.VAR.of;                  # OUTPUT: «(Cool)»\n\n  method default\n\n    method default(Scalar:D: --> Str)\n\nReturns the default value associated with the container.\n\nExample:\n\n    my $x is default(666) = 42;\n    say $x.VAR.default;             # OUTPUT: «666»\n\n  method name\n\n    method name(Scalar:D: --> Str)\n\nReturns the name associated with the container.\n\nExample:\n\n    my $x = 42;\n    say $x.VAR.name;                # OUTPUT: «$x»\n\n  method dynamic\n\n    method dynamic(Scalar:D: --> Bool)\n\nReturns whether the variable is visible in dynamic variable lookups.\n\nExample:\n\n    my $*FOO = 42;\n    say $*FOO.VAR.dynamic;          # OUTPUT: «True»\n\nRoutines\n\n  sub atomic-assign\n\nDefined as:\n\n    multi sub atomic-assign($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The\natomic-assign routine ensures that any required barriers are performed such\nthat the changed value will be \"published\" to other threads.\n\n  sub atomic-fetch\n\n    multi sub atomic-fetch($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this routine instead of simply using the variable ensures\nthat the latest update to the variable from other threads will be seen,\nboth by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until atomic-fetch($started) { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  sub cas\n\nDefined as:\n\n    multi sub cas($target is rw, $expected, $value)\n    multi sub cas($target is rw, &operation)\n\nPerforms an atomic compare and swap of the value in the Scalar $target. The\nfirst form has semantics like:\n\n    my $seen = $target;\n    if $seen<> =:= $expected<> {\n        $target = $value;\n    }\n    return $seen;\n\n\nExcept it is performed as a single hardware-supported atomic instruction,\nas if all memory access to $target were blocked while it took place.\nTherefore it is safe to attempt the operation from multiple threads without\nany other synchronization. Since it is a reference comparison, this\noperation is usually not sensible on value types.\n\nFor example:\n\n    constant NOT_STARTED = Any.new;\n    constant STARTED = Any.new;\n    my $master = NOT_STARTED;\n    await start {\n        if cas($master, NOT_STARTED, STARTED) === NOT_STARTED {\n            say \"Master!\"\n        }\n    } xx 4\n\nWill reliably only ever print Master! one time, as only one of the threads\nwill be successful in changing the Scalar from NOT_STARTED to STARTED.\n\nThe second form, taking a code object, will first do an atomic fetch of the\ncurrent value and invoke the code object with it. It will then try to do an\natomic compare and swap of the target, using the value passed to the code\nobject as $expected and the result of the code object as $value. If this\nfails, it will read the latest value, and retry, until a CAS operation\nsucceeds.\n\nTherefore, an item could be added to the head of a linked list in a lock\nfree manner as follows:\n\n    class Node {\n        has $.value;\n        has Node $.next;\n    }\n    my Node $head = Node;\n    await start {\n        for ^1000 -> $value {\n            cas $head, -> $next { Node.new(:$value, :$next) }\n        }\n    } xx 4;\n\nThis will reliably build up a linked list of 4000 items, with 4 nodes with\neach value ranging from 0 up to 999.\n\nOperators\n\n  infix ⚛=\n\n    multi sub infix:<⚛=>($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The ⚛=\noperator ensures that any required barriers are performed such that the\nchanged value will be \"published\" to other threads.\n\n  prefix ⚛\n\n    multi sub prefix:<⚛>($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this operator instead of simply using the variable\nensures that the latest update to the variable from other threads will be\nseen, both by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until ⚛$started { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate.","t":"Scalar","b":"A"},{"k":"v","n":"&msb","t":"Sub"},{"s":{"p":["Int:D \\i"],"r":"Int:D"},"k":"s","m":1,"n":"msb"},{"t":"Sub","n":"&indices","k":"v"},{"n":"indices","s":{"r":"Mu","p":["Cool $s","|c is raw"]},"k":"s","m":1},{"k":"v","n":"&infix:«~>»","t":"Sub"},{"n":"infix:«~>»","s":{"r":"Mu","p":["Str:D \\a","Int:D \\b"]},"k":"s","m":1},{"n":"infix:«~>»","s":{"p":["str $a","int $b"],"r":"Mu"},"k":"s","m":1},{"k":"v","t":"Sub+{is-pure}","n":"&defined"},{"m":1,"k":"s","s":{"p":["Mu \\x"],"r":"Mu"},"n":"defined"},{"n":"&infix:<~>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"Str"},"n":"infix:<~>"},{"n":"infix:<~>","s":{"p":["$x"],"r":"Str:D"},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"Mu","p":["Str:D $a","Junction:D $b"]},"n":"infix:<~>"},{"n":"infix:<~>","s":{"p":["Junction:D $a","Str:D $b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<~>","m":1,"k":"s","s":{"r":"Mu","p":["Junction:D \\a","Junction:D \\b"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Blob:D \\a"]},"n":"infix:<~>"},{"n":"infix:<~>","s":{"p":["Blob:D $a","Blob:D $b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<~>","m":1,"k":"s","s":{"p":["str $a","str $b"],"r":"str"}},{"m":1,"k":"s","s":{"r":"str","p":["Str:D \\a","str $b"]},"n":"infix:<~>"},{"m":1,"k":"s","s":{"r":"str","p":["str $a","Str:D \\b"]},"n":"infix:<~>"},{"s":{"r":"Str:D","p":["Str:D \\a","Str:D \\b"]},"m":1,"k":"s","n":"infix:<~>"},{"n":"infix:<~>","s":{"p":["Cool:D \\a","Str:D \\b"],"r":"Str:D"},"m":1,"k":"s"},{"s":{"p":["Str:D \\a","Cool:D \\b"],"r":"Str:D"},"m":1,"k":"s","n":"infix:<~>"},{"n":"infix:<~>","s":{"p":["Cool:D \\a","Cool:D \\b"],"r":"Str:D"},"m":1,"k":"s"},{"n":"infix:<~>","s":{"r":"Str:D","p":["Any:D \\a","Str:D \\b"]},"k":"s","m":1},{"s":{"p":["Str:D \\a","Any:D \\b"],"r":"Str:D"},"k":"s","m":1,"n":"infix:<~>"},{"s":{"p":["str @args"],"r":"str"},"k":"s","m":1,"n":"infix:<~>"},{"s":{"p":["@args"],"r":"Mu"},"k":"s","m":1,"n":"infix:<~>"},{"k":"s","m":1,"s":{"p":["*@args"],"r":"Mu"},"n":"infix:<~>"},{"t":"FileChangeEvent","n":"FileChangeEvent","k":"e"},{"t":"FileChangeEvent","n":"FileChangeEvent::FileChanged","k":"e"},{"t":"FileChangeEvent","n":"FileChangeEvent::FileRenamed","k":"e"},{"n":"uint","t":"uint","k":"n"},{"t":"Bool","n":"False","k":"e"},{"n":"&prefix:<~>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a"]},"n":"prefix:<~>"},{"n":"prefix:<~>","k":"s","m":1,"s":{"p":["int $a"],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["num $a"]},"n":"prefix:<~>"},{"k":"s","m":1,"s":{"p":["Str:D \\a"],"r":"Str:D"},"n":"prefix:<~>"},{"s":{"p":["str $a"],"r":"str"},"k":"s","m":1,"n":"prefix:<~>"},{"n":"&infix:«>=»","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":["$?"]},"k":"s","m":1,"n":"infix:«>=»"},{"s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:«>=»"},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Mu","p":["Real \\a","Real \\b"]}},{"n":"infix:«>=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Int:D \\a","Int:D \\b"]}},{"s":{"p":["int $a","int $b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«>=»"},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Bool:D","p":["Num:D \\a","Num:D \\b"]}},{"n":"infix:«>=»","k":"s","m":1,"s":{"p":["num $a","num $b"],"r":"Bool:D"}},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Bool:D","p":["Rational:D \\a","Rational:D \\b"]}},{"n":"infix:«>=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Rational:D \\a","Int:D \\b"]}},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Int:D \\a","Rational:D \\b"]},"n":"infix:«>=»"},{"n":"infix:«>=»","s":{"p":["Instant:D $a","Instant:D $b"],"r":"Bool:D"},"k":"s","m":1},{"s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1,"n":"infix:«>=»"},{"n":"infix:«>=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Date:D $a","Date:D $b"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"n":"infix:«>=»"},{"t":"Sub","n":"&truncate","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["Real:D $x"]},"n":"truncate"},{"k":"s","m":1,"s":{"r":"Mu","p":["Cool:D $x"]},"n":"truncate"},{"k":"v","n":"&shift","t":"Sub"},{"n":"shift","m":1,"k":"s","s":{"p":["@a"],"r":"Mu"}},{"k":"v","t":"Sub+{Precedence}","n":"&infix:<//>"},{"s":{"p":["Mu $x = Any"],"r":"Mu"},"m":1,"k":"s","n":"infix:<//>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu \\a","&b"]},"n":"infix:<//>"},{"k":"s","m":1,"s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"n":"infix:<//>"},{"b":"C","a":[{"k":"v","t":"Rat","n":"$.tai"}],"t":"Duration","d":"TITLE\nclass Duration\n\nSUBTITLE\nLength of time\n\n    class Duration is Cool does Real { }\n\nA Duration represents a length of time in atomic seconds, with fractions.\nLike an Instant, it is epoch-agnostic.\n\nDurations can be subtracted from or added to Instants to yield another, new\nInstant. Subtracting one Instant from another yields a Duration. A Duration\ncan also result from mathematical operations between two Durations when it\nmakes sense (namely, the addition, subtraction, or modulus of two\nDurations). It can also be added, subtracted or divided modulo Real\nnumbers.\n\nThe type of object returned for other numeric operations is currently\nunspecified.","n":"Duration","m":[{"s":{"p":["*%_"],"r":"Num:D"},"m":0,"k":"m","n":"Bridge"},{"n":"Num","k":"m","m":0,"s":{"p":["*%_"],"r":"Num:D"}},{"m":0,"k":"m","s":{"r":"Rat:D","p":["*%_"]},"n":"Rat"},{"n":"narrow","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"tai","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["Real","Numeric","Cool"]},{"k":"n","t":"int64","n":"int64"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<div>","k":"v"},{"n":"infix:<div>","s":{"r":"Int:D","p":["Int:D \\a","Int:D \\b"]},"k":"s","m":1},{"n":"infix:<div>","k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"}},{"k":"v","n":"&infix:«(<=)»","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}"},{"s":{"p":["Setty:D \\a","Setty:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«(<=)»"},{"k":"s","m":1,"s":{"p":["Setty:D \\a","Mixy:D \\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"k":"s","m":1,"s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Setty:D \\a","\\b"]},"n":"infix:«(<=)»"},{"s":{"r":"Bool:D","p":["Mixy:D \\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:«(<=)»"},{"n":"infix:«(<=)»","k":"s","m":1,"s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Bool:D"}},{"n":"infix:«(<=)»","s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:«(<=)»","m":1,"k":"s","s":{"p":["Mixy:D \\a","\\b"],"r":"Bool:D"}},{"n":"infix:«(<=)»","m":1,"k":"s","s":{"r":"Bool:D","p":["Baggy:D \\a","Mixy:D \\b"]}},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Baggy:D \\a","Baggy:D \\b"]},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","k":"s","m":1,"s":{"r":"Bool:D","p":["Baggy:D \\a","Setty:D \\b"]}},{"k":"s","m":1,"s":{"p":["Baggy:D \\a","\\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","k":"s","m":1,"s":{"r":"Bool:D","p":["Map:D \\a","Map:D \\b"]}},{"s":{"r":"Bool:D","p":["Iterable:D \\a","Map:D \\b"]},"m":1,"k":"s","n":"infix:«(<=)»"},{"n":"infix:«(<=)»","k":"s","m":1,"s":{"p":["\\a","Mixy:D \\b"],"r":"Bool:D"}},{"n":"infix:«(<=)»","s":{"p":["\\a","Baggy:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"s":{"p":["\\a","Setty:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<=)»"},{"n":"infix:«(<=)»","m":1,"k":"s","s":{"r":"Mu","p":["Failure:D \\a","$"]}},{"n":"infix:«(<=)»","s":{"p":["$","Failure:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Bool:D"},"n":"infix:«(<=)»"},{"t":"Sub","n":"&samewith","k":"v"},{"s":{"p":["|c is raw"],"r":"Mu"},"k":"s","m":0,"n":"samewith"},{"n":"ProtocolType","t":"ProtocolType","k":"e"},{"n":"ProtocolType::PROTO_UDP","t":"ProtocolType","k":"e"},{"n":"ProtocolType::PROTO_TCP","t":"ProtocolType","k":"e"},{"b":"C","a":[{"n":"$!ctx","t":"Mu","k":"v"},{"n":"$!mode","t":"int","k":"v"},{"n":"$!storage","t":"Mu","k":"v"}],"t":"PseudoStash","d":"TITLE\nclass PseudoStash\n\nSUBTITLE\nStash type for pseudo-packages\n\n    class PseudoStash is Map { }\n\nPseudoStash is the stash type (hanging off .WHO) that backs various\npseudo-packages. So, when you do MY:: or CALLER::, that gives back a\nPseudoStash. In most cases, Package:: gives back a Stash. Neither of these\nare objects the user is expected to create by themselves, but in case you\nhave one, you can just use it like a hash.\n\n    my $a = 42;\n    my $b = q/$a/;\n    say MY::{$b};\n    #OUTPUT: «42␤»\n\n\nThis shows how you can use a PseudoStash to look up variables, by name, at\nruntime.","n":"PseudoStash","m":[{"n":"new","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BIND-KEY","s":{"r":"Mu","p":["$key","\\value","*%_"]},"k":"m","m":0},{"n":"EXISTS-KEY","s":{"p":["$key","*%_"],"r":"Mu"},"k":"m","m":0}],"k":"c","mro":["Associative","Iterable","Map"]},{"n":"&signal","t":"Sub","k":"v"},{"n":"signal","s":{"r":"Mu","p":["Signal $signal","*@signals",":$scheduler = { ... }"]},"k":"s","m":1},{"k":"e","t":"Signal","n":"SIGUSR1"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<+>"},{"n":"infix:<+>","s":{"r":"Mu","p":["$x = 0"]},"k":"s","m":1},{"n":"infix:<+>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"}},{"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"k":"s","m":1,"n":"infix:<+>"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"n":"infix:<+>"},{"n":"infix:<+>","k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"}},{"m":1,"k":"s","s":{"p":["Num:D \\a","Num:D \\b"],"r":"Mu"},"n":"infix:<+>"},{"n":"infix:<+>","s":{"p":["num $a","num $b"],"r":"num"},"k":"s","m":1},{"s":{"p":["Range:D \\r","Real:D \\v"],"r":"Mu"},"m":1,"k":"s","n":"infix:<+>"},{"k":"s","m":1,"s":{"p":["Real:D \\v","Range:D \\r"],"r":"Mu"},"n":"infix:<+>"},{"n":"infix:<+>","s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]},"k":"s","m":1},{"n":"infix:<+>","k":"s","m":1,"s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]}},{"n":"infix:<+>","m":1,"k":"s","s":{"r":"Mu","p":["Int:D \\a","Rational:D \\b"]}},{"k":"s","m":1,"s":{"r":"Complex:D","p":["Complex:D \\a","Complex:D \\b"]},"n":"infix:<+>"},{"k":"s","m":1,"s":{"r":"Complex:D","p":["Complex:D \\a","Num(Real) \\b"]},"n":"infix:<+>"},{"s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Complex:D"},"k":"s","m":1,"n":"infix:<+>"},{"s":{"r":"Mu","p":["Instant:D $a","Instant:D $b"]},"m":1,"k":"s","n":"infix:<+>"},{"k":"s","m":1,"s":{"p":["Instant:D $a","Real:D $b"],"r":"Instant:D"},"n":"infix:<+>"},{"n":"infix:<+>","m":1,"k":"s","s":{"p":["Real:D $a","Instant:D $b"],"r":"Instant:D"}},{"n":"infix:<+>","m":1,"k":"s","s":{"p":["Instant:D $a","Duration:D $b"],"r":"Instant:D"}},{"n":"infix:<+>","m":1,"k":"s","s":{"r":"Instant:D","p":["Duration:D $a","Instant:D $b"]}},{"n":"infix:<+>","k":"s","m":1,"s":{"p":["Duration:D $a","Real $b"],"r":"Duration:D"}},{"m":1,"k":"s","s":{"p":["Real $a","Duration:D $b"],"r":"Duration:D"},"n":"infix:<+>"},{"n":"infix:<+>","s":{"r":"Duration:D","p":["Duration:D $a","Duration:D $b"]},"k":"s","m":1},{"n":"infix:<+>","m":1,"k":"s","s":{"p":["DateTime:D \\a","Duration:D \\b"],"r":"DateTime:D"}},{"m":1,"k":"s","s":{"r":"DateTime:D","p":["Duration:D \\a","DateTime:D \\b"]},"n":"infix:<+>"},{"n":"infix:<+>","k":"s","m":1,"s":{"p":["Date:D $d","Int:D $x"],"r":"Date:D"}},{"n":"infix:<+>","k":"s","m":1,"s":{"p":["Int:D $x","Date:D $d"],"r":"Date:D"}},{"k":"v","n":"&cotanh","t":"Sub+{is-pure}"},{"m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]},"n":"cotanh"},{"n":"cotanh","m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"}},{"n":"cotanh","m":1,"k":"s","s":{"p":["num $x"],"r":"num"}},{"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Str"},"n":"encoding"},{"k":"m","m":0,"s":{"p":["\\action","\\to","\\from","*%_"],"r":"Mu"},"n":"!push-list"},{"s":{"r":"Mu","p":["\\to","\\from","*%_"]},"k":"m","m":0,"n":"!spread"},{"s":{"r":"Mu","p":["$got","*%_"]},"m":0,"k":"m","n":"!fail-range"},{"n":"!fail-typecheck","s":{"p":["$action","$got","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["\\action","\\to","\\from","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!unshift-list"},{"n":"!fail-typecheck-element","k":"m","m":0,"s":{"r":"Mu","p":["\\action","\\i","\\got","*%_"]}}],"k":"c","mro":["Blob[uint8]","Positional[uint8]","Stringy","Any"],"t":"utf8","d":"TITLE\nclass utf8\n\nSUBTITLE\nMutable uint8 buffer for utf8 binary data\n\n    class utf8 does Blob[uint8] is repr('VMArray') {}\n\nA utf8 is a subtype of Blob which is specifically uint8 data for holding\nUTF-8 encoded text.\n\n    my utf8 $b = \"hello\".encode;\n    say $b[1].fmt(\"0x%X\"); # OUTPUT: «0x65␤»","n":"utf8","b":"A"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(+)>","k":"v"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"p":[],"r":"Mu"}},{"s":{"r":"Mu","p":["Bag:D \\a"]},"m":1,"k":"s","n":"infix:<(+)>"},{"m":1,"k":"s","s":{"p":["Mix:D \\a"],"r":"Mu"},"n":"infix:<(+)>"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"r":"Mu","p":["MixHash:D \\a"]}},{"n":"infix:<(+)>","k":"s","m":1,"s":{"p":["\\a"],"r":"Mu"}},{"n":"infix:<(+)>","s":{"p":["Setty:D \\a","QuantHash:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"p":["Setty:D \\a","Map:D \\b"],"r":"Mu"}},{"s":{"p":["Mixy:D \\a","QuantHash:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(+)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","QuantHash:D \\b"]},"n":"infix:<(+)>"},{"n":"infix:<(+)>","s":{"p":["Map:D \\a","Map:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"r":"Mu","p":["Iterable:D \\a","Iterable:D \\b"]}},{"n":"infix:<(+)>","s":{"r":"Mu","p":["$","Failure:D \\b"]},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Failure:D \\a","$"]},"m":1,"k":"s","n":"infix:<(+)>"},{"n":"infix:<(+)>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"}},{"n":"infix:<(+)>","m":1,"k":"s","s":{"p":["**@p"],"r":"Mu"}},{"k":"v","n":"&lines","t":"Sub"},{"n":"lines","s":{"p":["$what = { ... }","|c is raw"],"r":"Mu"},"k":"s","m":1},{"n":"&mix","t":"Sub+{is-pure}","k":"v"},{"n":"mix","s":{"r":"Mu","p":[]},"k":"s","m":1},{"s":{"r":"Mix:D","p":["*@a"]},"m":1,"k":"s","n":"mix"},{"k":"v","t":"Sub","n":"&from-json"},{"n":"from-json","k":"s","m":0,"s":{"r":"Mu","p":["$text"]}},{"n":"&trait_mod:<hides>","t":"Sub","k":"v"},{"n":"trait_mod:<hides>","s":{"r":"Mu","p":["Mu:U $child","Mu:U $parent"]},"k":"s","m":1},{"k":"v","n":"&atomic-fetch-add","t":"Sub"},{"m":1,"k":"s","s":{"p":["atomicint $target is rw","int $add"],"r":"atomicint"},"n":"atomic-fetch-add"},{"n":"atomic-fetch-add","m":1,"k":"s","s":{"r":"atomicint","p":["atomicint $target is rw","Int:D $add"]}},{"n":"atomic-fetch-add","s":{"r":"atomicint","p":["atomicint $target is rw","$add"]},"k":"s","m":1},{"t":"Sub+{Precedence}","n":"&infix:<xx>","k":"v"},{"k":"s","m":1,"s":{"p":[],"r":"Mu"},"n":"infix:<xx>"},{"n":"infix:<xx>","s":{"r":"Mu","p":["Mu \\x"]},"m":1,"k":"s"},{"n":"infix:<xx>","k":"s","m":1,"s":{"p":["&x","Num:D(Any):D $n"],"r":"Mu"}},{"n":"infix:<xx>","s":{"p":["&x","Whatever $"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["&x","Bool:D $b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<xx>"},{"n":"infix:<xx>","s":{"p":["&x","Int:D $n"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":["Mu \\x","Num:D(Any):D $n"],"r":"Mu"},"n":"infix:<xx>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu \\x","Whatever $"]},"n":"infix:<xx>"},{"s":{"r":"Mu","p":["Mu \\x","Bool:D $b"]},"k":"s","m":1,"n":"infix:<xx>"},{"s":{"r":"Mu","p":["Mu \\x","Int:D $n"]},"k":"s","m":1,"n":"infix:<xx>"},{"b":"A","d":"TITLE\nclass Uni\n\nSUBTITLE\nA string of Unicode codepoints\n\n    class Uni does Positional[uint32] does Stringy { }\n\nUnlike Str, which is made of Grapheme clusters, Uni is string strictly made\nof Unicode codepoints. That is, base characters and combining characters\nare separate elements of a Uni instance.\n\nUni presents itself with a list-like interface of integer Codepoints.\n\nTypical usage of Uni is through one of its subclasses, NFC, NFD, NFKD and\nNFKC, which represent strings in one of the Unicode Normalization Forms of\nthe same name.\n\n","t":"Uni","n":"Uni","m":[{"s":{"r":"Mu","p":["*@codes","*%_"]},"m":0,"k":"m","n":"new","d":"method new(*@codes --> Uni:D)\n\nCreates a new Uni instance from the given codepoint numbers."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"list"},{"n":"Uni","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"d":"method NFC(Uni:D: --> NFC:D)\n\nReturns a NFC (Normal Form Composed)-converted version of the invocant.","n":"NFC","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"method NFD(Uni:D: --> NFD:D)\n\nReturns a NFD (Normal Form Decomposed)-converted version of the invocant.","n":"NFD","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"NFKC","d":"method NFKC(Uni:D: --> NFKC:D)\n\nReturns a NFKC (Normal Form Compatibility Composed)-converted version of\nthe invocant.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"d":"method NFKD(Uni:D: --> NFKD:D)\n\nReturns a NFKD (Normal Form Compatibility Decomposed)-converted version of\nthe invocant.","n":"NFKD","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"method codes(Uni:D: --> Int:D)\n\nReturns the number of codepoints in the invocant.","n":"codes","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"elems","d":"method elems(Uni:D: --> Int:D)\n\nReturns the number of codepoints in the invocant."},{"n":"Numeric","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"Int"}],"k":"c","mro":["Stringy","Positional[uint32]","Any"]},{"k":"v","n":"&exit","t":"Sub"},{"n":"exit","s":{"p":[],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["$status"],"r":"Mu"},"n":"exit"},{"t":"Sub+{is-pure}+{Precedence}","n":"&zip","k":"v"},{"m":1,"k":"s","s":{"p":["+\\lol is raw",":&with!"],"r":"Seq:D"},"n":"infix:<Z>"},{"s":{"p":["+\\lol is raw"],"r":"Seq:D"},"m":1,"k":"s","n":"infix:<Z>"},{"t":"Sub+{is-pure}","n":"&min","k":"v"},{"s":{"r":"Mu","p":["+\\args is raw",":&by!"]},"k":"s","m":1,"n":"min"},{"k":"s","m":1,"s":{"r":"Mu","p":["+\\args is raw"]},"n":"min"},{"t":"Sub","n":"&tc","k":"v"},{"s":{"r":"Mu","p":["Cool $s"]},"k":"s","m":1,"n":"tc"},{"b":"A","n":"CallFrame","d":"TITLE\nclass CallFrame\n\nSUBTITLE\nCaptures the current frame state\n\n    class CallFrame {}\n\nA CallFrame will be usually captured from the current state of a program\nusing the callframe subroutine.\n\n    my $frame = callframe;\n    say \"The above line of code ran at {$frame.file}:{$frame.line}.\";\n\nWith no arguments the callframe will give you frame information for the\nline calling callframe. The file and line annotations will be identical to\nthose in $?FILE and $?LINE.\n\nYou may, however, pass a number to callframe to specify a different frame\nlevel. A positive number will move upward through the levels of frame. A\nnegative number will move downward into the callframe method and class\nitself at the point at which they are running to construct this information\nfor you.\n\nThe frames themselves do not necessarily match only method or subroutine\ncalls. Perl constructs a frames for blocks and such as well, so if you need\na callframe for a particular method call, do not assume it is a fixed\nnumber of levels up.\n\nEach frame stores annotations, including the file and line annotations,\nwhich have convenience methods for accessing them directly. You can also\nretrieve a reference to the code block of the currently executing frame\nusing the code method. The frame also captures all lexical variables stored\nwith the frame, which are available by calling my on the frame object.\n\nHere's a short example that will find the calling routine and print the\npackage of the caller using the callframe interface.\n\n    sub calling-frame() {\n        for 1..* -> $level {\n            given callframe($level) -> $frame {\n                when $frame ~~ CallFrame {\n                        next unless $frame.code ~~ Routine;\n                        say $frame.code.package;\n                        last;\n                }\n                default {\n                        say \"no calling routine or method found\";\n                        last;\n                }\n            }\n        }\n    }\n\n    calling-frame;\n\nIf you just need to trace caller information, Backtrace may provide a\nbetter means of getting it. CallFrame contains more information about a\nspecific frame, but provides a tedious interface for enumerating a call\nstack.\n\n","a":[{"k":"v","n":"$.annotations","t":"Mu"},{"t":"Mu","n":"$.my","k":"v"}],"t":"CallFrame","mro":["Any"],"k":"c","m":[{"n":"SET-SELF","s":{"p":["\\level","Mu \\ctx","Mu \\bt","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"new","m":0,"k":"m","s":{"r":"Mu","p":["Int:D $level = 0","*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method line()\n\nThis is a shortcut for looking up the line annotation. For example, the\nfollowing two calls are identical.\n\n    say callframe(1).line;\n    say callframe(1).annotations<line>;","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"file","d":"method file()\n\nThis is a shortcut for looking up the file annotation. Therefore, the\nfollowing code prints True.\n\n    my $frame = callframe(0);\n    say $frame.file eq $frame.annotations<file>;"},{"n":"code","d":"method code()\n\nReturn the callable code for the current block. When called on the object\nreturned by callframe(0), this will be the same value found in &?BLOCK.\n\n    my $frame;\n    for ^3 { FIRST $frame = callframe; say $_ * 3 };\n    say $frame.code()\n\n\nThe $frame variable will hold the Code for the block inside the loop in\nthis case.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"callframe","k":"m","m":0,"s":{"r":"Mu","p":["Int:D $?","*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method annotations()\n\nReturns a Map containing the invocants annotations, i.e. line and file. An\neasier way to get hold of the annotation information is to use one of the\nconvenience methods instead.\n\n    say callframe.annotations.^name;                   # OUTPUT: «Map␤»\n    say callframe.annotations<file> eq callframe.file; # OUTPUT: «True␤»","n":"annotations"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method my()\n\nReturn a Hash that names all the variables and their values associated with\nthe lexical scope of the frame.\n\n    sub some-value {\n        my $the-answer = 42;\n        callframe(0);\n    }\n\n    my $frame = some-value();\n    say $frame.my<$the-answer>; # OUTPUT: «42␤»\n\nRoutines\n\n  sub callframe\n\n    sub callframe(Int:D $level = 0)\n\nReturns a CallFrame object for the given level. If no level is given, the\ndefault level is 0. Positive levels move up the frame stack and negative\nlevels move down (into the call to callframe and deeper).\n\nReturns Mu if there is no call information for the given level. Negative\nlevels may result in an exception.","n":"my"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}]},{"k":"v","t":"Sub+{is-pure}","n":"&wordcase"},{"n":"wordcase","k":"s","m":1,"s":{"p":["Str:D $x"],"r":"Mu"}},{"n":"wordcase","s":{"r":"Mu","p":["Cool $x"]},"m":1,"k":"s"},{"n":"SeekFromBeginning","t":"SeekType","k":"e"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∉>","k":"v"},{"n":"infix:<∉>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Bool:D"}},{"k":"v","n":"&uniprop","t":"Sub"},{"n":"uniprop","m":1,"k":"s","s":{"p":["Str:D $str","|c is raw"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["Int:D $code"]},"n":"uniprop"},{"k":"s","m":1,"s":{"r":"Mu","p":["Int:D $code","Stringy:D $propname"]},"n":"uniprop"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<≼>","k":"v"},{"n":"infix:<≼>","m":1,"k":"s","s":{"p":["$a","$b"],"r":"Bool:D"}},{"k":"v","n":"&ceiling","t":"Sub+{is-pure}"},{"m":1,"k":"s","s":{"p":["$a"],"r":"Mu"},"n":"ceiling"},{"s":{"p":["Numeric $a"],"r":"Mu"},"m":1,"k":"s","n":"ceiling"},{"m":1,"k":"s","s":{"r":"num","p":["num $a"]},"n":"ceiling"},{"k":"v","n":"&uniprop-int","t":"Sub"},{"k":"s","m":1,"s":{"p":["Str:D $str","Stringy:D $propname"],"r":"Mu"},"n":"uniprop-int"},{"n":"uniprop-int","k":"s","m":1,"s":{"p":["Int:D $code","Stringy:D $propname"],"r":"Mu"}},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<?^>","k":"v"},{"n":"infix:<?^>","s":{"r":"Mu","p":["Mu $x = Bool::False"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"n":"infix:<?^>"},{"k":"v","n":"&infix:«<=»","t":"Sub+{is-pure}"},{"n":"infix:«<=»","s":{"r":"Mu","p":["$?"]},"k":"s","m":1},{"n":"infix:«<=»","k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]}},{"n":"infix:«<=»","s":{"p":["Real \\a","Real \\b"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Int:D \\a","Int:D \\b"]},"n":"infix:«<=»"},{"n":"infix:«<=»","m":1,"k":"s","s":{"p":["int $a","int $b"],"r":"Bool:D"}},{"n":"infix:«<=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Num:D \\a","Num:D \\b"]}},{"n":"infix:«<=»","k":"s","m":1,"s":{"p":["num $a","num $b"],"r":"Bool:D"}},{"s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«<=»"},{"n":"infix:«<=»","k":"s","m":1,"s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Bool:D"}},{"n":"infix:«<=»","s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"infix:«<=»","s":{"p":["Instant:D $a","Instant:D $b"],"r":"Bool:D"},"k":"s","m":1},{"s":{"p":["DateTime:D \\a","DateTime:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«<=»"},{"n":"infix:«<=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Date:D $a","Date:D $b"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"n":"infix:«<=»"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<!=>"},{"s":{"p":["$?"],"r":"Mu"},"k":"s","m":1,"n":"infix:<!=>"},{"n":"infix:<!=>","m":1,"k":"s","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"}},{"s":{"r":"Bool:D","p":["int $a","int $b"]},"k":"s","m":1,"n":"infix:<!=>"},{"n":"infix:<!=>","s":{"r":"Bool:D","p":["Int:D \\a","Int:D \\b"]},"m":1,"k":"s"},{"s":{"r":"Bool:D","p":["num $a","num $b"]},"k":"s","m":1,"n":"infix:<!=>"},{"n":"infix:<!=>","k":"s","m":1,"s":{"r":"Bool:D","p":["Instant:D $a","Instant:D $b"]}},{"n":"infix:<!=>","s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1},{"n":"infix:<!=>","s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"k":"s","m":1},{"k":"v","n":"&prepend","t":"Sub"},{"s":{"r":"Mu","p":["\\a","|elems is raw"]},"m":1,"k":"s","n":"prepend"},{"k":"n","t":"int16","n":"int16"},{"mro":[],"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"slip-one"}],"k":"ro","n":"SlippyIterator","a":[{"k":"v","n":"$!slipping","t":"int"},{"n":"$!slip-iter","t":"Mu","k":"v"}],"t":"SlippyIterator","b":"C"},{"k":"e","n":"SOCK_RAW","t":"SocketType"},{"k":"v","t":"Sub","n":"&symlink"},{"n":"symlink","s":{"p":["$target","$name"],"r":"Mu"},"k":"s","m":1},{"n":"&infix:<⊍>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<(.)>","m":1,"k":"s","s":{"p":[],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["Setty:D \\a"]},"n":"infix:<(.)>"},{"s":{"r":"Mu","p":["Baggy:D \\a"]},"k":"s","m":1,"n":"infix:<(.)>"},{"n":"infix:<(.)>","m":1,"k":"s","s":{"p":["\\a"],"r":"Mu"}},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Mu"},"n":"infix:<(.)>"},{"s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(.)>"},{"n":"infix:<(.)>","s":{"p":["Mixy:D \\a","\\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"k":"s","m":1},{"n":"infix:<(.)>","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["\\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:<(.)>"},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["$","Failure:D \\b"],"r":"Mu"},"n":"infix:<(.)>"},{"s":{"r":"Mu","p":["Failure:D \\a","$"]},"k":"s","m":1,"n":"infix:<(.)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<(.)>"},{"n":"infix:<(.)>","s":{"r":"Mu","p":["**@p"]},"m":1,"k":"s"},{"n":"Slip","d":"TITLE\nclass Slip\n\nSUBTITLE\nA kind of List that automatically flattens into an outer container\n\n    class Slip is List {}\n\nA Slip is a List that automatically flattens into an outer List (or other\nlist-like container or iterable).\n\nFor example it allows you to write a map that produces more than one value\ninto the result without nesting:\n\n    say <a b c>.map({ ($_, $_.uc).Slip }).join('|');        # OUTPUT: «a|A|b|B|c|C␤»\n\n\nIn contrast, when returning an ordinary List, the resulting list is\nnested:\n\n    say <a b c>.map({ $_, $_.uc }).join('|');               # OUTPUT: «a A|b B|c C␤»\n\n\nTo create a Slip, either coerce another list-like type to it by calling the\nSlip method, or use the slip subroutine:\n\n    # This says \"1\" and then says \"2\", rather than saying \"(1 2)\"\n    .say for gather {\n        take slip(1, 2);\n    }\n\nA Slip may also be created by using the prefix:<|> operator. This differs\nfrom the slip subroutine in both precedence and treatment of single\narguments. In fact, prefix:<|> only takes a single argument, so in that\nway, it behaves closer to the .Slip method than the slip subroutine.\n\n    my $l = (1, 2, 3);\n    say (1, slip 2, 3).perl;  # says (1, 2, 3)      , slips 2, 3 into (1, …)\n    say (0, slip $l).perl;    # says (0, $(1, 2, 3)), $l does not break apart\n    say (0, $l.Slip).perl;    # says (0, 1, 2, 3)   , slips from $l into (0, …)\n    say (|$l).perl;           # says slip(1, 2, 3)  , breaks apart $l\n    say (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n    say (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n\n\nLoops that do not want to produce a value for an iteration use Slips,\nrather than empty Lists to do so, as do if statements that do not run their\nblocks.\n\nPlease note that prefix:<|> will also apply parameters in a slippy manner\nto a routine call. It does not forward a Slip to the called routine, that\nincludes return and take.\n\n    my \\l = gather for 1..10 -> $a, $b { take |($a, $b) }; say l.perl;\n    # OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»\n    my \\m= gather for 1..10 -> $a, $b { take ($a, $b).Slip }; say m.perl;\n    # OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»\n\n","a":[{"t":"Mu","n":"$!reified","k":"v"},{"k":"v","n":"$!todo","t":"Mu"}],"t":"Slip","mro":["Positional","Iterable","List"],"m":[{"k":"m","m":0,"s":{"p":["+\\args is raw","*%_"],"r":"Mu"},"n":"CALL-ME"}],"k":"c","b":"C"},{"k":"v","n":"&lsb","t":"Sub"},{"s":{"p":["Int:D \\i"],"r":"Int:D"},"m":1,"k":"s","n":"lsb"},{"k":"v","n":"&chdir","t":"Sub"},{"k":"s","m":1,"s":{"p":["|c is raw"],"r":"Mu"},"n":"chdir"},{"k":"v","n":"&infix:<eqv>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<eqv>","s":{"r":"Mu","p":["$?"]},"k":"s","m":1},{"n":"infix:<eqv>","s":{"p":["Any:U \\a","Any:U \\b"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":["Any:D \\a","Any:U \\b"],"r":"Bool"},"n":"infix:<eqv>"},{"s":{"p":["Any:U \\a","Any:D \\b"],"r":"Bool"},"k":"s","m":1,"n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"r":"Mu","p":["Any:D \\a","Any:D \\b"]},"k":"s","m":1},{"n":"infix:<eqv>","k":"s","m":1,"s":{"r":"Mu","p":["Iterable:D \\a","Iterable:D \\b"]}},{"s":{"p":["Stringy:D \\a","Stringy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"p":["Numeric:D \\a","Numeric:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<eqv>","m":1,"k":"s","s":{"p":["Int:D $a","Int:D $b"],"r":"Bool:D"}},{"n":"infix:<eqv>","s":{"r":"Bool:D","p":["int $a","int $b"]},"k":"s","m":1},{"n":"infix:<eqv>","s":{"p":["Blob:D \\a","Blob:D \\b"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["Str:D \\a","Str:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<eqv>"},{"s":{"p":["Capture:D \\a","Capture:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"r":"Mu","p":["Seq:D \\a","Seq:D \\b"]},"k":"s","m":1},{"n":"infix:<eqv>","s":{"r":"Mu","p":["Range:D \\a","Range:D \\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["Pair:D \\a","Pair:D \\b"],"r":"Mu"},"n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"p":["Map:D \\a","Map:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<eqv>","m":1,"k":"s","s":{"p":["Parameter:D \\a","Parameter:D \\b"],"r":"Mu"}},{"n":"infix:<eqv>","s":{"r":"Mu","p":["Signature:D \\a","Signature:D \\b"]},"k":"s","m":1},{"n":"infix:<eqv>","m":1,"k":"s","s":{"p":["Match:D \\a","Match:D \\b"],"r":"Mu"}},{"n":"infix:<eqv>","m":1,"k":"s","s":{"p":["IntStr:D $a","IntStr:D $b"],"r":"Mu"}},{"n":"infix:<eqv>","m":1,"k":"s","s":{"r":"Bool","p":["IntStr:D $a","RatStr:D $b"]}},{"k":"s","m":1,"s":{"r":"Bool","p":["IntStr:D $a","NumStr:D $b"]},"n":"infix:<eqv>"},{"n":"infix:<eqv>","m":1,"k":"s","s":{"p":["IntStr:D $a","ComplexStr:D $b"],"r":"Bool"}},{"n":"infix:<eqv>","k":"s","m":1,"s":{"p":["RatStr:D $a","IntStr:D $b"],"r":"Bool"}},{"k":"s","m":1,"s":{"p":["RatStr:D $a","RatStr:D $b"],"r":"Mu"},"n":"infix:<eqv>"},{"s":{"r":"Bool","p":["RatStr:D $a","NumStr:D $b"]},"m":1,"k":"s","n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"p":["RatStr:D $a","ComplexStr:D $b"],"r":"Bool"},"m":1,"k":"s"},{"s":{"p":["NumStr:D $a","IntStr:D $b"],"r":"Bool"},"m":1,"k":"s","n":"infix:<eqv>"},{"k":"s","m":1,"s":{"r":"Bool","p":["NumStr:D $a","RatStr:D $b"]},"n":"infix:<eqv>"},{"n":"infix:<eqv>","k":"s","m":1,"s":{"p":["NumStr:D $a","NumStr:D $b"],"r":"Mu"}},{"s":{"r":"Bool","p":["NumStr:D $a","ComplexStr:D $b"]},"m":1,"k":"s","n":"infix:<eqv>"},{"s":{"p":["ComplexStr:D $a","IntStr:D $b"],"r":"Bool"},"k":"s","m":1,"n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"p":["ComplexStr:D $a","RatStr:D $b"],"r":"Bool"},"m":1,"k":"s"},{"s":{"p":["ComplexStr:D $a","NumStr:D $b"],"r":"Bool"},"k":"s","m":1,"n":"infix:<eqv>"},{"n":"infix:<eqv>","s":{"p":["ComplexStr:D $a","ComplexStr:D $b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<eqv>","m":1,"k":"s","s":{"r":"Bool:D","p":["Setty:D \\a","Setty:D \\b"]}},{"n":"infix:<eqv>","m":1,"k":"s","s":{"r":"Bool:D","p":["Baggy:D \\a","Baggy:D \\b"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["ObjAt:D $a","ObjAt:D $b"]},"n":"infix:<eqv>"},{"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"m":1,"k":"s","n":"infix:<eqv>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Promise:D \\a","Promise:D \\b"]},"n":"infix:<eqv>"},{"b":"C","k":"ro","m":[{"n":"BUILD","s":{"p":[":name($!name) = \"unknown\"",":auth($!auth) = \"unknown\"",":version($!version) = { ... }","*%_"],"r":"Nil"},"m":0,"k":"s"},{"n":"Str","d":"method Str\n\nInstance method returning the name of the object.\n\n    say $*PERL.Str; # OUTPUT: «Raku␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"mro":[],"a":[{"t":"Str","n":"$.name","k":"v"},{"t":"Str","n":"$.auth","k":"v"},{"t":"Version","n":"$.version","k":"v"},{"k":"v","t":"Blob","n":"$.signature"},{"k":"v","n":"$.desc","t":"Str"}],"d":"TITLE\nrole Systemic\n\nSUBTITLE\nInformation related to the build system\n\nBuilt-in class for providing built system related information. Usually\naccessed through dynamic variables mixing this role such as the $*KERNEL,\n$*VM, or $*PERL.\n\n","t":"Systemic","n":"Systemic"},{"k":"v","t":"Sub","n":"&classify"},{"s":{"r":"Mu","p":["$test","+\\items is raw",":$into!","*%named"]},"m":1,"k":"s","n":"classify"},{"s":{"p":["$test","+\\items is raw","*%named"],"r":"Mu"},"k":"s","m":1,"n":"classify"},{"k":"v","n":"&infix:<(-)>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<(-)>","s":{"r":"Mu","p":[]},"k":"s","m":1},{"n":"infix:<(-)>","s":{"r":"Mu","p":["QuantHash:D \\a"]},"m":1,"k":"s"},{"s":{"p":["SetHash:D \\a"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"s":{"r":"Mu","p":["BagHash:D \\a"]},"k":"s","m":1,"n":"infix:<(-)>"},{"s":{"p":["MixHash:D \\a"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(-)>"},{"n":"infix:<(-)>","s":{"p":["\\a"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(-)>","s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(-)>","s":{"p":["Setty:D \\a","Map:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":["Setty:D \\a","Iterable:D \\b"]}},{"n":"infix:<(-)>","s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Mixy:D \\a","QuantHash:D \\b"]},"k":"s","m":1,"n":"infix:<(-)>"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":["QuantHash:D \\a","Mixy:D \\b"]}},{"n":"infix:<(-)>","s":{"p":["Mixy:D \\a","Map:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(-)>","s":{"p":["Mixy:D \\a","Any:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(-)>","k":"s","m":1,"s":{"r":"Mu","p":["Any:D \\a","Mixy:D \\b"]}},{"n":"infix:<(-)>","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Baggy:D \\a","Baggy:D \\b"],"r":"Mu"},"n":"infix:<(-)>"},{"n":"infix:<(-)>","s":{"r":"Mu","p":["Baggy:D \\a","QuantHash:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(-)>","s":{"p":["QuantHash:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Baggy:D \\a","Map:D \\b"],"r":"Mu"},"n":"infix:<(-)>"},{"m":1,"k":"s","s":{"p":["Baggy:D \\a","Any:D \\b"],"r":"Mu"},"n":"infix:<(-)>"},{"s":{"p":["\\a","Baggy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"s":{"p":["\\a","Map:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"n":"infix:<(-)>","m":1,"k":"s","s":{"p":["\\a","Iterable:D \\b"],"r":"Mu"}},{"s":{"p":["$","Failure:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(-)>"},{"m":1,"k":"s","s":{"p":["Failure:D \\a","$"],"r":"Mu"},"n":"infix:<(-)>"},{"m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"},"n":"infix:<(-)>"},{"n":"infix:<(-)>","s":{"p":["**@p"],"r":"Mu"},"k":"s","m":1},{"b":"C","n":"Sequence","t":"Sequence","d":"TITLE\nclass Sequence\n\nSUBTITLE\nOperations for higher-level sequences\n\n    class Sequence does PositionalBindFailover { }\n\nA Sequence implements a series of methods for converting hight-level Seqs\ninto different types of objects, from positional to other.\n\n","mro":[],"k":"ro","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Numeric"},{"n":"fmt","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}}]},{"n":"Broken","t":"PromiseStatus","k":"e"},{"t":"Sub+{is-pure}","n":"&expmod","k":"v"},{"n":"expmod","k":"s","m":1,"s":{"p":["Int:D \\base","Int:D \\exp","Int:D \\mod"],"r":"Int:D"}},{"n":"expmod","m":1,"k":"s","s":{"r":"Int:D","p":["\\base","\\exp","\\mod"]}},{"k":"e","t":"ProtocolFamily","n":"PF_INET6"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["Str:D $name is copy = \"\"","Int:D $flags is copy = 0","Bool:D $named is copy = Bool::False","Bool:D $optional is copy = Bool::False","Bool:D $mandatory is copy = Bool::False","Bool:D $is-copy = Bool::False","Bool:D $is-raw = Bool::False","Bool:D $is-rw = Bool::False","Bool:D $multi-invocant = Bool::True","*%args"]},"k":"s","m":0,"n":"BUILD"},{"d":"Returns the variable name, which includes all sigils and twigils. This name\nis used internally when applied to code, or in a declaration determines the\nname declared. This name is not necessarily usable by a caller – if it is,\nit will also appear as an alias. Often, the name will chosen descriptively\nas a form of self-documentation.\n\nIf the parameter is anonymous, Nil will be returned.","n":"name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"usage-name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"sigil","d":"Defined as:\n\n    method sigil(Parameter:D: --> Str:D)\n\nReturns a string containing the parameter's sigil, for a looser definition\nof \"sigil\" than what is considered part of the variable's name|method name.\nStill returns a sigil even if the parameter is anonymous.\n\nThis \"sigil\" is actually an introspection used to help determine the normal\nbinding style of a parameter, if it has not been altered through a trait.\n\n  Sigil  Will bind to            Default behavior\n  $      Scalar                  Generate new Scalar, use instead of Scalar in argument, if any\n  @      Positional              Bind directly to the argument\n  @      PositionalBindFailover  If binding failed, call argument's .cache method, bind to result\n  %      Associative             Bind directly to the argument\n  &      Callable                Bind directly to the argument\n  \\      (anything)              Bind directly to the argument, keep existing Scalar, if any\n\n\nAlso, | will bind to all remaining arguments and make new Capture if\nneeded.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"twigil","d":"Defined as:\n\n    method twigil(Parameter:D: --> Str:D)\n\nReturns a string containing the twigil part of the parameter's name."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modifier"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"constraint_list"},{"d":"Returns additional constraints on the parameter (usually as an\nall-Junction).","n":"constraints","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Returns the nominal type constraint of the parameter.","n":"type"},{"n":"coerce_type","d":"Returns the coercion type of the parameter.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method named_names(Parameter:D: --> List:D)\n\nReturns the list of externally usable names/aliases for a named parameter.","n":"named_names","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method named(Parameter:D: --> Bool:D)\n\nReturns True if it's a named parameter.\n\n    my Signature $sig = :(Str $x, Bool :$is-named);\n    say $sig.params[0].named;                          # OUTPUT: «False␤»\n    say $sig.params[1].named;                          # OUTPUT: «True␤»","n":"named","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"positional","d":"Defined as:\n\n    method positional(Parameter:D: --> Bool:D)\n\nReturns True if the parameter is positional.\n\n    my Signature $sig = :(Str $x, Bool :$is-named);\n    say $sig.params[0].positional;                     # OUTPUT: «True␤»\n    say $sig.params[1].positional;                     # OUTPUT: «False␤»"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"slurpy","d":"Defined as:\n\n    method slurpy(Parameter:D: --> Bool:D)\n\nReturns True for slurpy parameters."},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"optional","d":"Defined as:\n\n    method optional(Parameter:D: --> Bool:D)\n\nReturns True for optional parameters."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method raw(Parameter:D: --> Bool:D)\n\nReturns True for raw parameters.\n\n    sub f($a, $b is raw, \\c) {\n        my $sig = &?ROUTINE.signature;\n        for ^$sig.params.elems {\n            say $sig.params[$_].raw;\n        }\n    }\n    f(17, \"4711\", 42); OUTPUT: «False␤True␤True␤»\n\nRaw parameters bind either a variable or a value passed to it, with no\ndecontainerization taking place. That means that if a variable was passed\nto it, you can assign to the parameter. This is different from rw-parameter\nwhich can only bind to variables, never to values.\n\nThis is the normal behavior for parameters declared with a sigil of '\\',\nwhich is not really a sigil insofar as it is only used on the parameter.\n\n    sub f(\\x) {\n        x = 5;\n    }\n    f(my $x);   # works\n    f(42);      # dies\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»\n\nOther parameters may become raw through use of the 'is raw' trait. These\nstill use their sigil in code.\n\n    sub f($x is raw) {\n        $x = 5;\n    }","n":"raw"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"capture","d":"Defined as:\n\n    method capture(Parameter:D: --> Bool:D)\n\nReturns True for parameters that capture the rest of the argument list into\na single Capture object.\n\n    sub how_many_extra_positionals($!, |capture) { capture.elems.say }\n    how_many_extra_positionals(0, 1, 2, 3);                        # RESULT: «3»\n    say &how_many_extra_positionals.signature.params[1].capture;   # OUTPUT: «True␤»\n\nLike raw parameters, Capture parameters do not force any context on the\nvalues bound to them, which is why their sigils are only used in\ndeclarations."},{"n":"rw","d":"Defined as:\n\n    method rw(Parameter:D: --> Bool:D)\n\nReturns True for is rw parameters.\n\n    my Signature $sig = :(Str $x is rw, Bool :$is-named);\n    say $sig.params[0].rw;                             # OUTPUT: «True␤»\n    say $sig.params[1].rw;                             # OUTPUT: «False␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"onearg"},{"d":"Defined as:\n\n    method copy(Parameter:D: --> Bool:D)\n\nReturns True for is copy parameters.\n\n    my Signature $sig = :(Str $x, Bool :$is-named is copy);\n    say $sig.params[0].copy;                           # OUTPUT: «False␤»\n    say $sig.params[1].copy;                           # OUTPUT: «True␤»","n":"copy","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method readonly(Parameter:D: --> Bool:D)\n\nReturns True for read-only parameters (the default).\n\n    my Signature $sig = :(Str $x is rw, Bool :$is-named);\n    say $sig.params[0].readonly;                       # OUTPUT: «False␤»\n    say $sig.params[1].readonly;                       # OUTPUT: «True␤»","n":"readonly"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"invocant","d":"Defined as:\n\n    method invocant(Parameter:D: --> Bool:D)\n\nReturns True if the parameter is the invocant parameter."},{"n":"multi-invocant","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Returns a closure that upon invocation returns the default value for this\nparameter, or Any if no default was provided.","n":"default"},{"n":"type_captures","d":"Defined as:\n\n    method type_captures(Parameter:D: --> List:D)\n\nReturns a list of variable names of type captures associated with this\nparameter. Type captures define a type name within the attached code, which\nis an alias to the type gleaned from the argument during a call.\n\n    sub a(::T ::U $x) { T.say }\n    a(8);                                       # OUTPUT: «(Int)␤»\n    say &a.signature.params[0].type_captures;   # OUTPUT: «(T U)␤»\n    sub b($x) { $x.^name.say }\n    a(8);                                       # OUTPUT: «Int␤»\n\nThe type used may change from call to call. Once they are defined, type\ncaptures can be used wherever you would use a type, even later in same the\nsignature:\n\n    sub c(::T $x, T $y, $z) { my T $zz = $z };\n    c(4, 5, 6);          # OK\n    c(4, 5, \"six\");      # Fails when assigning to $zz, wants Int not Str\n    c(\"four\", 5, \"six\"); # Fails when binding $y, wants Str, not Int\n\n\nType captures may be used at the same time as type constraints.\n\n    sub d(::T Numeric $x, T $y) {};\n    d(4, 5);            # OK\n    d(4e0, 5e0);        # OK\n    d(4e0, 5);          # Fails when binding $y\n    d(\"four\", \"five\");  # Fails when binding $x","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"sub_signature","d":"If the parameter has a sub-signature, returns a Signature object for it.\nOtherwise returns Any.\n\nRuntime creation of Parameter objects (6.d, 2019.03 and later)\n\n    Parameter.new( ... )\n\nIn some situations, specifically when working with the MetaObject Protocol,\nit makes sense to create Parameter objects programmatically. For this\npurpose, you can call the new method with the following named parameters:\n\n  * name\n\nOptional. The name of the variable, if any. Can be specified in the same\nway as in a Signature. So it may contain specific additional information,\nsuch as a sigil ($, @, % or &), a : prefix to indicate a named parameter, a\ntwigil (. or !) to indicate public / private attribute binding, a postfix !\nor ? to indicate an optional / mandatory parameter, and the various\ncombinations of +, *, ** prefixes to indicate slurpiness types and | to\nindicate a Capture.\n\n  * type\n\nOptional. The type of the parameter. Assumes Any if not specified.\n\n  * default\n\nOptional. The value of the parameter if the parameter is optional and no\nargument has been given for that parameter. Assumes not initialization if\nno argument has been given, which would fall back to the (implicit) type of\nthe parameter.\n\n  * where\n\nOptional. Additional constraints to be applied to any argument to match\nwith this parameter. Does not set any additional constraints by default.\n\n  * is-copy\n\nOptional. Allows one to set the \"is copy\" flag on the parameter. Does not\nset the flag by default.\n\n  * is-raw\n\nOptional. Allows one to set the \"is raw\" flag on the parameter. Does not\nset the flag by default.\n\n  * is-rw\n\nOptional. Allows one to set the \"is rw\" flag on the parameter. Does not set\nthe flag by default.\n\n  * named\n\nOptional. Indicates whether the parameter is a named parameter or not.\nShould only be specified if the : prefix is not specified in the name and a\nnamed parameter is required.\n\n  * optional\n\nOptional. Indicates whether the parameter is optional or not. Should only\nbe specified if the ? postfix is not specified in the name and an optional\nparameter is required.\n\n  * mandatory\n\nOptional. Indicates whether the parameter is mandatory or not. Should only\nbe specified if the ! postfix is not specified in the name and a mandatory\nparameter is required.\n\n  * multi-invocant\n\nOptional. Indicates whether the parameter should be considered in\nmulti-dispatch or not. Defaults to True, so one would need to do\n:!multi-invocant to make the parameter not be considered in\nmulti-dispatch.\n\n  * sub-signature\n\nOptional. Specifies any Signature that should be applied to the parameter\nto deconstruct it. By default, no signature is to be applied."},{"s":{"p":["$why","*%_"],"r":"Nil"},"k":"m","m":0,"n":"set_why"},{"n":"set_default","k":"m","m":0,"s":{"r":"Nil","p":["Code:D $default","*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!flags"}],"mro":["Any"],"a":[{"t":"str","n":"$!variable_name","k":"v"},{"n":"@!named_names","t":"Mu","k":"v"},{"n":"@!type_captures","t":"Mu","k":"v"},{"n":"$!flags","t":"int","k":"v"},{"t":"Mu","n":"$!nominal_type","k":"v"},{"t":"List","n":"@!post_constraints","k":"v"},{"k":"v","t":"Mu","n":"$!coerce_type"},{"n":"$!coerce_method","t":"str","k":"v"},{"n":"$!sub_signature","t":"Signature","k":"v"},{"k":"v","n":"$!default_value","t":"Code"},{"t":"Mu","n":"$!container_descriptor","k":"v"},{"k":"v","t":"Mu","n":"$!attr_package"},{"k":"v","n":"$!why","t":"Mu"}],"d":"TITLE\nclass Parameter\n\nSUBTITLE\nElement of a Signature\n\n    class Parameter { }\n\nRepresents a parameter, for purpose of introspection.\n\nThe usual way to obtain a Parameter object is to create a signature, and\ncall .params on it to obtain a list of the Parameters.\n\n    my $sig   = :(Str $x);\n    my $param = $sig.params[0];\n    say $param.type;              # OUTPUT: «Str()␤»\n\nSee Signature for more information, and also for an explanation on what\nmost of the concepts related to parameters mean.\n\n","t":"Parameter","n":"Parameter"},{"k":"v","n":"&infix:<X>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<X>","k":"s","m":1,"s":{"r":"Seq:D","p":["+\\lol is raw",":&with!"]}},{"n":"infix:<X>","m":1,"k":"s","s":{"r":"Seq:D","p":["+\\lol is raw"]}},{"b":"C","t":"Num","n":"tau","k":"c","mro":["Real","Numeric","Cool"]},{"k":"v","n":"&trim","t":"Sub"},{"k":"s","m":1,"s":{"r":"Str:D","p":["Cool:D $s"]},"n":"trim"},{"k":"v","t":"Sub","n":"&chomp"},{"n":"chomp","k":"s","m":1,"s":{"r":"Str:D","p":["Cool $s"]}},{"k":"v","n":"&infix:<…^>","t":"Sub"},{"n":"infix:<…^>","s":{"r":"Mu","p":["|c is raw"]},"k":"s","m":1},{"k":"c","m":[{"n":"total","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"clone"},{"m":0,"k":"m","s":{"r":"Mu","p":["\\type","*%_"]},"n":"!HASHIFY"},{"n":"!create-from-iterator","s":{"r":"Baggy:D","p":["\\type","\\iterator","*%_"]},"k":"m","m":0}],"mro":["Baggy","QuantHash","Associative","Any"],"d":"TITLE\nclass BagHash\n\nSUBTITLE\nMutable collection of distinct objects with integer weights\n\n    class BagHash does Baggy { }\n\nA BagHash is a mutable bag/multiset, meaning a collection of distinct\nelements in no particular order that each have an integer weight assigned\nto them signifying how many copies of that element are considered \"in the\nbag\". (For immutable bags, see Bag instead.)\n\nObjects/values of any type are allowed as bag elements. Within a BagHash,\nitems that would compare positively with the === operator are considered\nthe same element, with the number of how many there were as its weight. But\nof course you can also easily get back the expanded list of items (without\nthe order):\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBagHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding integer weight for keys that are\nelements of the bag, and 0 for keys that aren't. It can also be used to\nmodify weights; setting a weight to 0 automatically removes that element\nfrom the bag, and setting a weight to a positive number adds that element\nif it didn't already exist:\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n    say $breakfast<bacon>;     # OUTPUT: «1␤»\n    say $breakfast<spam>;      # OUTPUT: «4␤»\n    say $breakfast<sausage>;   # OUTPUT: «0␤»\n\n    $breakfast<sausage> = 2;\n    $breakfast<bacon>--;\n    say $breakfast.kxxv.sort;  # OUTPUT: «eggs sausage sausage spam spam spam spam␤»\n\n\nCreating BagHash objects\n\nBagHashes can be composed using BagHash.new. Any positional parameters,\nregardless of their type, become elements of the bag:\n\n    my $n = BagHash.new: \"a\", \"b\", \"c\", \"c\";\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"a\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 1, 2).Seq␤»\n\nBesides, BagHash.new-from-pairs can create a BagHash with items and their\noccurrences.\n\n    my $n = BagHash.new-from-pairs: \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nAlternatively, the .BagHash coercer (or its functional form, BagHash()) can\nbe called on an existing object to coerce it to a BagHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a bag with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the bag, and the (cumulative) values become the\nassociated integer weights:\n\n    my $m = (\"a\", \"b\", \"c\", \"c\").BagHash;\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).BagHash;\n    say $m.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n\nYou can also create BagHash masquerading as a hash by using the is trait:\n\n    my %bh is BagHash = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a BagHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = BagHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %bh is BagHash[Str] = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\n    # only allow whole numbers\n    my %bh is BagHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set and bag operators, which can take BagHashes (or\nany other collections) as input, and return result as Bool, Set or Bag\nvalues. For example:\n\n    my ($a, $b) = BagHash.new(2, 2, 4), BagHash.new(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nBagHash inherits reverse from Any, however, Bags do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a BagHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = BagHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «BagHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\nSee Also\n\nSets, Bags, and Mixes","a":[{"n":"$!elems","t":"Rakudo::Internals::IterationSet","k":"v"}],"t":"BagHash","n":"BagHash","b":"A"},{"k":"v","n":"&await","t":"Sub"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"await"},{"m":1,"k":"s","s":{"r":"Mu","p":["Any:U $x"]},"n":"await"},{"n":"await","s":{"p":["Any:D $x"],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Mu","p":["Promise:D $p"]},"k":"s","m":1,"n":"await"},{"m":1,"k":"s","s":{"p":["Channel:D $c"],"r":"Mu"},"n":"await"},{"s":{"r":"Mu","p":["Supply:D $s"]},"k":"s","m":1,"n":"await"},{"k":"s","m":1,"s":{"p":["Iterable:D $i"],"r":"Mu"},"n":"await"},{"n":"await","s":{"p":["*@awaitables"],"r":"Mu"},"m":1,"k":"s"},{"n":"uint64","t":"uint64","k":"n"},{"t":"Sub","n":"&trait_mod:<trusts>","k":"v"},{"n":"trait_mod:<trusts>","k":"s","m":1,"s":{"p":["Mu:U $truster","Mu:U $trustee"],"r":"Mu"}},{"k":"v","n":"&prefix:<~^>","t":"Sub+{is-pure}+{Precedence}"},{"n":"prefix:<~^>","s":{"p":["\\a"],"r":"Mu"},"k":"s","m":1},{"n":"prefix:<~^>","s":{"p":["Blob:D \\a"],"r":"Mu"},"k":"s","m":1},{"n":"prefix:<~^>","m":1,"k":"s","s":{"p":["Str \\a"],"r":"Mu"}},{"k":"v","n":"&infix:<^^>","t":"Sub+{Precedence}"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu $x = Bool::False"]},"n":"infix:<^^>"},{"s":{"p":["Mu \\a","&b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<^^>"},{"s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<^^>"},{"n":"infix:<^^>","s":{"r":"Mu","p":["+@a"]},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&circumfix:<{ }>"},{"s":{"p":["*@elems"],"r":"Mu"},"k":"s","m":1,"n":"circumfix:<{ }>"},{"n":"uint8","t":"uint8","k":"n"},{"n":"&infix:<+^>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"k":"s","m":1,"s":{"p":[],"r":"Mu"},"n":"infix:<+^>"},{"s":{"r":"Mu","p":["$x"]},"m":1,"k":"s","n":"infix:<+^>"},{"k":"s","m":1,"s":{"r":"Mu","p":["$x","$y"]},"n":"infix:<+^>"},{"n":"infix:<+^>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"k":"s","m":1},{"n":"infix:<+^>","s":{"r":"int","p":["int $a","int $b"]},"m":1,"k":"s"},{"n":"&slip","t":"Sub","k":"v"},{"n":"slip","k":"s","m":1,"s":{"r":"Slip","p":[]}},{"n":"slip","s":{"r":"Slip:D","p":["@args"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Slip:D","p":["+\\args is raw"]},"n":"slip"},{"k":"v","n":"&infix:<->","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<->","m":1,"k":"s","s":{"r":"Mu","p":["$x = 0"]}},{"s":{"r":"Mu","p":["\\a","\\b"]},"k":"s","m":1,"n":"infix:<->"},{"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"m":1,"k":"s","n":"infix:<->"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"n":"infix:<->"},{"k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"},"n":"infix:<->"},{"n":"infix:<->","s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["num $a","num $b"],"r":"num"},"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"r":"Mu","p":["Range:D \\r","Real:D \\v"]}},{"n":"infix:<->","m":1,"k":"s","s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]},"n":"infix:<->"},{"n":"infix:<->","s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Complex:D","p":["Complex:D \\a","Complex:D \\b"]},"n":"infix:<->"},{"n":"infix:<->","m":1,"k":"s","s":{"r":"Complex:D","p":["Complex:D \\a","Num(Real) \\b"]}},{"k":"s","m":1,"s":{"r":"Complex:D","p":["Num(Real) \\a","Complex:D \\b"]},"n":"infix:<->"},{"m":1,"k":"s","s":{"r":"Duration:D","p":["Instant:D $a","Instant:D $b"]},"n":"infix:<->"},{"s":{"p":["Instant:D $a","Real:D $b"],"r":"Instant:D"},"m":1,"k":"s","n":"infix:<->"},{"s":{"p":["Duration:D $a","Real $b"],"r":"Duration:D"},"m":1,"k":"s","n":"infix:<->"},{"k":"s","m":1,"s":{"p":["Duration:D $a","Duration:D $b"],"r":"Duration:D"},"n":"infix:<->"},{"n":"infix:<->","s":{"r":"Duration:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["DateTime:D \\a","Duration:D \\b"],"r":"DateTime:D"},"n":"infix:<->"},{"n":"infix:<->","k":"s","m":1,"s":{"p":["Date:D $d","Int:D $x"],"r":"Date:D"}},{"n":"infix:<->","s":{"r":"Int:D","p":["Date:D $a","Date:D $b"]},"m":1,"k":"s"},{"k":"v","n":"&map","t":"Sub"},{"n":"map","s":{"p":["&code","+\\values is raw"],"r":"Mu"},"m":1,"k":"s"},{"t":"utf32","n":"utf32","m":[{"n":"encoding","s":{"r":"Str","p":["*%_"]},"k":"m","m":0},{"n":"!fail-typecheck-element","k":"m","m":0,"s":{"r":"Mu","p":["\\action","\\i","\\got","*%_"]}},{"n":"!unshift-list","s":{"r":"Mu","p":["\\action","\\to","\\from","*%_"]},"m":0,"k":"m"},{"s":{"p":["\\to","\\from","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!spread"},{"k":"m","m":0,"s":{"r":"Mu","p":["$got","*%_"]},"n":"!fail-range"},{"n":"!push-list","m":0,"k":"m","s":{"p":["\\action","\\to","\\from","*%_"],"r":"Mu"}},{"n":"!fail-typecheck","s":{"p":["$action","$got","*%_"],"r":"Mu"},"k":"m","m":0}],"k":"c","mro":["Blob[uint32]","Positional[uint32]","Stringy","Any"],"b":"A"},{"n":"PositionalBindFailover","t":"PositionalBindFailover","a":[{"n":"$!list","t":"Mu","k":"v"}],"d":"TITLE\nrole PositionalBindFailover\n\nSUBTITLE\nFailover for binding to a Positional\n\n    role PositionalBindFailover { ... }\n\nThis role provides an interface by which an object can be coerced into a\nPositional when binding to Positional parameters.\n\nFor example, Seq type is not Positional, but you can still write the\nfollowing, because it does PositionalBindFailover role:\n\n    sub fifths(@a) {        # @a is constraint to Positional\n        @a[4];\n    }\n    my $seq := gather {     # a Seq, which is not Positional\n        take $_ for 1..*;\n    }\n    say fifths($seq);       # OUTPUT: «5␤»\n\nThe invocation of fifths in the example above would ordinarily give a type\nerror, because $seq is of type Seq, which doesn't do the Positional\ninterface that the @-sigil implies.\n\nBut the signature binder recognizes that Seq does the\nPositionalBindFailover role, and calls its cache method to coerce it to a\nList, which does the Positional role.\n\nThe same happens with custom classes that do the role; they simply need to\nprovide an iterator method that produces an Iterator:\n\n    class Foo does PositionalBindFailover {\n        method iterator {\n            class :: does Iterator {\n                method pull-one {\n                    return 42 unless $++;\n                    IterationEnd\n                }\n            }.new\n        }\n    }\n\n    sub first-five (@a) { @a[^5].say }\n    first-five Foo.new; # OUTPUT: # OUTPUT: «(42 Nil Nil Nil Nil)␤»\n\n","mro":[],"m":[{"n":"cache","d":"method cache(PositionalBindFailover:D: --> List:D)\n\nReturns a List based on the iterator method, and caches it. Subsequent\ncalls to cache always return the same List object.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"iterator","d":"method iterator(PositionalBindFailover:D:) { ... }\n\nThis method stub ensure that a class implementing role\nPositionalBindFailover provides an iterator method.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0}],"k":"ro","b":"C"},{"b":"C","m":[{"n":"Rat","d":"method Rat(Real:D: Real $epsilon = 1e-6)\n\nConverts the number to a Rat with the precision $epsilon.","s":{"r":"Mu","p":["Real $epsilon = 1e-06","*%_"]},"m":0,"k":"m"},{"n":"abs","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"sign","d":"method sign(Real:D:)\n\nReturns -1 if the number is negative, 0 if it is zero and 1 otherwise.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"conj"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"sqrt"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"sub term:<rand> (--> Num:D)\n    method rand(Real:D: --> Real:D)\n\nReturns a pseudo-random number between zero (inclusive) and the number\n(non-inclusive). The Bridge method is used to coerce the Real to a numeric\nthat supports rand method.\n\nThe term form returns a pseudo-random Num between 0e0 (inclusive) and 1e0\n(non-inclusive.)","n":"rand"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"sin"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"asin"},{"n":"cos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"acos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"tan"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"atan"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"sec"},{"n":"asec","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"cosec","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"acosec","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"cotan"},{"n":"acotan","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"sinh","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"asinh"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"cosh"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"acosh"},{"n":"tanh","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"atanh","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"sech"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"asech"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"cosech"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"acosech"},{"n":"cotanh","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"acotanh","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"floor","d":"method floor(Real:D --> Int:D)\n\nReturn the largest integer not greater than the number.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"d":"method ceiling(Real:D --> Int:D)\n\nReturns the smallest integer not less than the number.","n":"ceiling","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"unpolar","s":{"p":["Real $angle","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"cis"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method Complex(Real:D: --> Complex:D)\n\nConverts the number to a Complex with the number converted to a Num as its\nreal part and 0e0 as the imaginary part.","n":"Complex"},{"n":"truncate","d":"method truncate(Real:D --> Int:D)\n\nRounds the number towards zero.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"isNaN"},{"n":"polymod","d":"method polymod(Real:D: +@mods)\n\nReturns the remainders after applying sequentially all divisors in the\n@mods argument; the last element of the array will be the last remainder.\n\n    say (1e8+1).polymod(10 xx 8);  # OUTPUT: «(1 0 0 0 0 0 0 0 1)␤»\n\n10 xx 8 is simply an array with eight number 10s; the first division by 10\nwill return 1 as a remainder, while the rest, up to the last, will return\n0. With 8 divisors, as above, the result will have one more elements, in\nthis case for the last remainder.","s":{"r":"Mu","p":["+@mods","*%_"]},"m":0,"k":"m"},{"s":{"p":["Int:D $base","$digits? is copy","*%_"],"r":"Mu"},"k":"m","m":0,"n":"base","d":"method base(Real:D: Int:D $base where 2..36, $digits? --> Str:D)\n\nConverts the number to a string, using $base as base. For $base larger than\nten, capital Latin letters are used.\n\n    255.base(16);            # 'FF'\n\nThe optional $digits argument asks for that many digits of fraction (which\nmay not be negative). If omitted, a reasonable default is chosen based on\ntype. For Int this default is 0. For Num, the default is 8. For Rational,\nthe number of places is scaled to the size of the denominator, with a\nminimum of 6.\n\nA special value of Whatever (*) can be given as $digits, which functions\nthe same as when $digits is not specified for all Real types except the\nRationals. For Rationals, the Whatever indicates that you wish all of the\npossible digits of the fractional part, but use caution: since there's no\ndetection of repeating fractional parts (the algorithm will eventually stop\nafter generating 2**63 digits).\n\nThe final digit produced is always rounded.\n\n    say pi.base(10, 3);      # OUTPUT: «3.142␤»\n    say (1/128).base(10, *); # OUTPUT: «0.0078125␤»\n    say (1/100).base(10, *); # OUTPUT: «0.01␤»\n    say (1/3)  .base(10, *); # WRONG: endlessly repeating fractional part\n\nFor reverse operation, see parse-base"},{"d":"Defined as:\n\n    method Bridge(Real:D:)\n\nDefault implementation coerces the invocant to Num and that's the behavior\nof this method in core Real types. This method primarily exist to make it\neasy to implement custom Real types by users, with the Bridge method\nreturning one of the core Real types (NOT necessarily a Num) that best\nrepresent the custom Real type. In turn, this lets all the core operators\nand methods obtain a usable value they can work with.\n\nAs an example, we can implement a custom Temperature type. It has a unit of\nmeasure and the value, which are given during instantiation. We can\nimplement custom operators or conversion methods that work with this type.\nWhen it comes to regular mathematical operators, however, we can simply use\nthe .Bridge method to convert the Temperature to Kelvin expressed in one of\nthe core numeric types:\n\n    class Temperature is Real {\n        has Str:D  $.unit  is required where any <K F C>;\n        has Real:D $.value is required;\n        method new ($value, :$unit = 'K') { self.bless :$value :$unit }\n        # Note: implementing .new() that handles $value of type Temperature is left as an exercise\n\n        method Bridge {\n            when $!unit eq 'F' { ($!value + 459.67) × 5/9 }\n            when $!unit eq 'C' {  $!value + 273.15 }\n            $!value\n        }\n        method gist { self.Str }\n        method Str  { \"$!value degrees $!unit\" }\n    }\n\n    sub postfix:<℃> { Temperature.new: $^value, :unit<C> }\n    sub postfix:<℉> { Temperature.new: $^value, :unit<F> }\n    sub postfix:<K> { Temperature.new: $^value, :unit<K> }\n\n    my $human := 36.6℃;\n    my $book  := 451℉;\n    my $sun   := 5778K;\n    say $human;                # OUTPUT: «36.6 degrees C␤»\n    say $human + $book + $sun; # OUTPUT: «6593.677777777778␤»\n    say 123K + 456K;           # OUTPUT: «579␤»\n\nAs we can see from the last two lines of the output, the type of the\nbridged result is not forced to be any particular core type. It is a Rat,\nwhen we instantiated Temperature with a Rat or when conversion was\ninvolved, and it is an Int when we instantiated Temperature with an Int.","n":"Bridge","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"Int"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"Num"}],"k":"ro","mro":[],"t":"Real","d":"TITLE\nrole Real\n\nSUBTITLE\nNon-complex number\n\n    role Real does Numeric { ... }\n\nCommon role for non-Complex numbers.\n\n","n":"Real"},{"k":"v","n":"&cis","t":"Sub"},{"s":{"r":"Mu","p":["Real $a"]},"k":"s","m":1,"n":"cis"},{"k":"v","n":"&hash","t":"Sub"},{"s":{"p":["*%h"],"r":"Mu"},"m":1,"k":"s","n":"hash"},{"n":"hash","s":{"p":["*@a","*%h"],"r":"Mu"},"k":"s","m":1},{"b":"A","m":[{"n":"BUILD","s":{"p":["Int :initial_threads($!initial_threads) = 0","Int :max_threads($!max_threads) = { ... }","*%_"],"r":"Nil"},"m":0,"k":"s"},{"n":"queue","m":0,"k":"m","s":{"p":["Bool :$hint-time-sensitive",":$hint-affinity","*%_"],"r":"Mu"}},{"n":"cue","k":"m","m":1,"s":{"r":"Mu","p":["&code",":$every!",":$times = 1","*%_"]}},{"s":{"p":["&code",":$times!","*%_"],"r":"Mu"},"k":"m","m":1,"n":"cue"},{"m":1,"k":"m","s":{"r":"Mu","p":["&code",":$at!","*%_"]},"n":"cue"},{"s":{"r":"Mu","p":["&code",":$in!","*%_"]},"k":"m","m":1,"n":"cue"},{"s":{"p":["&code",":&catch!","*%_"],"r":"Nil"},"m":1,"k":"m","n":"cue"},{"n":"cue","s":{"p":["&code","*%_"],"r":"Nil"},"m":1,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"loads"},{"n":"usage","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"n":"usage","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"n":"initial_threads","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"max_threads"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"uncaught_handler"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"!general-queue"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"n":"!maybe-start-supervisor"},{"m":0,"k":"m","s":{"p":["\\queue","\\worker-list","&add-worker","$cores","$per-core-util","*%_"],"r":"Mu"},"n":"!tweak-workers"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"!affinity-queue"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"!timer-queue"},{"s":{"r":"Mu","p":["&code","int $delay","int $times","%args","*%_"]},"k":"m","m":0,"n":"!CUE_DELAY_TIMES"}],"k":"c","mro":["Scheduler","Any"],"t":"ThreadPoolScheduler","a":[{"n":"$.initial_threads","t":"Int","k":"v"},{"t":"Int","n":"$.max_threads","k":"v"},{"k":"v","n":"$!state-lock","t":"Lock"},{"k":"v","t":"ThreadPoolScheduler::Queue","n":"$!general-queue"},{"n":"$!timer-queue","t":"ThreadPoolScheduler::Queue","k":"v"},{"k":"v","t":"Mu","n":"$!general-workers"},{"n":"$!timer-workers","t":"Mu","k":"v"},{"n":"$!affinity-workers","t":"Mu","k":"v"},{"n":"$!supervisor","t":"Thread","k":"v"},{"k":"v","t":"Callable","n":"&.uncaught_handler"}],"d":"TITLE\nclass ThreadPoolScheduler\n\nSUBTITLE\nScheduler that distributes work among a pool of threads\n\n    class ThreadPoolScheduler does Scheduler {}\n\n\nThe ThreadPoolScheduler has a range of number of threads that it maintains,\nand it distributes work among those threads. When the upper limit of\nthreads isn't reached yet, and there is work pending, it spawns new threads\nto handle the work.\n\n","n":"ThreadPoolScheduler"},{"m":[{"n":"BUILD","s":{"p":[":$queue!","*%_"],"r":"Mu"},"m":0,"k":"s"},{"n":"await","s":{"p":["Awaitable:D $a","*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["Iterable:D \\i","*%_"],"r":"Mu"},"n":"await-all"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0},{"s":{"r":"Mu","p":["Iterable:D \\i","*%_"]},"k":"m","m":0,"n":"!do-await-all"},{"n":"!do-await","s":{"p":["Awaitable:D $a","*%_"],"r":"Mu"},"m":0,"k":"m"}],"k":"c","mro":["Awaiter","Any"],"a":[{"k":"v","n":"$!queue","t":"Mu"}],"t":"ThreadPoolScheduler::ThreadPoolAwaiter","n":"ThreadPoolScheduler::ThreadPoolAwaiter","b":"A"},{"t":"Signal","n":"SIGTHR","k":"e"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<==>"},{"n":"infix:<==>","m":1,"k":"s","s":{"r":"Mu","p":["$?"]}},{"n":"infix:<==>","s":{"r":"Mu","p":["\\a","\\b"]},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"m":1,"k":"s","n":"infix:<==>"},{"m":1,"k":"s","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Bool:D"},"n":"infix:<==>"},{"n":"infix:<==>","s":{"r":"Bool:D","p":["int $a","int $b"]},"k":"s","m":1},{"s":{"r":"Bool:D","p":["Num:D \\a","Num:D \\b"]},"k":"s","m":1,"n":"infix:<==>"},{"n":"infix:<==>","m":1,"k":"s","s":{"p":["num $a","num $b"],"r":"Bool:D"}},{"n":"infix:<==>","s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Rational:D \\a","Int:D \\b"]},"n":"infix:<==>"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Bool:D"},"n":"infix:<==>"},{"s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<==>"},{"s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<==>"},{"s":{"r":"Bool:D","p":["Num(Real) \\a","Complex:D \\b"]},"k":"s","m":1,"n":"infix:<==>"},{"s":{"p":["Instant:D $a","Instant:D $b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<==>"},{"n":"infix:<==>","s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1},{"n":"infix:<==>","m":1,"k":"s","s":{"p":["Date:D $a","Date:D $b"],"r":"Bool:D"}},{"k":"s","m":1,"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"n":"infix:<==>"},{"t":"Sub","n":"&sleep-timer","k":"v"},{"s":{"p":[],"r":"Duration:D"},"k":"s","m":1,"n":"sleep-timer"},{"n":"sleep-timer","s":{"p":["$seconds"],"r":"Duration:D"},"m":1,"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<~|>","k":"v"},{"s":{"p":["$x = \"\""],"r":"Mu"},"k":"s","m":1,"n":"infix:<~|>"},{"n":"infix:<~|>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"n":"infix:<~|>"},{"k":"s","m":1,"s":{"r":"Str:D","p":["Str:D \\a","Str:D \\b"]},"n":"infix:<~|>"},{"n":"infix:<~|>","s":{"r":"str","p":["str $a","str $b"]},"m":1,"k":"s"},{"n":"&run","t":"Sub","k":"v"},{"n":"run","k":"s","m":1,"s":{"r":"Mu","p":["*@args where { ... }",":$in = \"-\"",":$out = \"-\"",":$err = \"-\"","Bool :$bin","Bool :$chomp = Bool::True","Bool :$merge","Str :$enc","Str:D :$nl = \"\\n\"",":$cwd = { ... }",":$env"]}},{"k":"e","t":"Signal","n":"SIGABRT"},{"d":"TITLE\nrole Blob\n\nSUBTITLE\nImmutable buffer for binary data ('Binary Large OBject')\n\n    role Blob[::T = uint8] does Positional[T] does Stringy { }\n\nThe Blob role is an immutable interface to binary types, and offers a\nlist-like interface to lists of integers, typically unsigned integers.\n\n","t":"Blob","n":"Blob","k":"ro","m":[{"n":"read-int8","d":"Defined as:\n\n    method read-int8(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native int value for the byte at the given position. The $endian\nparameter has no meaning, but is available for consistency.","s":{"r":"int","p":["int $offset","Endian $?","*%_"]},"m":0,"k":"m"},{"n":"read-int16","d":"Defined as:\n\n    method read-int16(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native int value for the two bytes starting at the given\nposition.","s":{"r":"int","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    method read-int32(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native int value for the four bytes starting at the given\nposition.","n":"read-int32","k":"m","m":0,"s":{"p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"],"r":"int"}},{"d":"Defined as:\n\n    method read-int64(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native int value for the eight bytes starting at the given\nposition.","n":"read-int64","k":"m","m":0,"s":{"r":"int","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]}},{"s":{"r":"Int","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]},"k":"m","m":0,"n":"read-int128","d":"Defined as:\n\n    method read-int128(blob8:D: uint $pos, $endian = NativeEndian --> Int:D)\n\nReturns an integer value for the sixteen bytes starting at the given\nposition."},{"d":"Defined as:\n\n    method read-uint8(blob8:D: uint $pos, $endian = NativeEndian --> uint)\n\nReturns an unsigned native integer value for the byte at the given\nposition. The $endian parameter has no meaning, but is available for\nconsistency.","n":"read-uint8","m":0,"k":"m","s":{"r":"uint","p":["int $offset","Endian $?","*%_"]}},{"n":"read-uint16","d":"Defined as:\n\n    method read-uint16(blob8:D: uint $pos, $endian = NativeEndian --> uint)\n\nReturns a native uint value for the two bytes starting at the given\nposition.","s":{"r":"uint","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]},"k":"m","m":0},{"n":"read-uint32","d":"Defined as:\n\n    method read-uint32(blob8:D: uint $pos, $endian = NativeEndian --> uint)\n\nReturns a native uint value for the four bytes starting at the given\nposition.","s":{"r":"uint","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]},"m":0,"k":"m"},{"n":"read-uint64","d":"Defined as:\n\n    method read-uint64(blob8:D: uint $pos, $endian = NativeEndian --> UInt:D)\n\nReturns an unsigned integer value for the eight bytes starting at the given\nposition.","s":{"p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"],"r":"uint"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method read-uint128(blob8:D: uint $pos, $endian = NativeEndian --> UInt:D)\n\nReturns an unsigned integer value for the sixteen bytes starting at the\ngiven position.","n":"read-uint128","m":0,"k":"m","s":{"p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"],"r":"uint"}},{"n":"read-num32","d":"Defined as:\n\n    method read-num32(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native num value for the four bytes starting at the given\nposition.","s":{"p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"],"r":"num"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"num","p":["int $offset","Endian $endian = Endian::NativeEndian","*%_"]},"d":"Defined as:\n\n    method read-num64(blob8:D: uint $pos, $endian = NativeEndian --> int)\n\nReturns a native num value for the eight bytes starting at the given\nposition.\n\nMethods on blob8 only (6.d, 2019.03 and later)","n":"read-num64"},{"n":"read-bits","d":"Defined as:\n\n    method read-bits(blob8:D: uint $pos, uint $bits --> Int:D)\n\nReturns a signed integer value for the bits from the given bit offset and\ngiven number of bits. The endianness of the bits is assumed to be\nBigEndian.","s":{"r":"Int:D","p":["int $pos","Int:D $bits","*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method read-ubits(blob8:D: uint $pos, uint $bits --> UInt:D)\n\nReturns an unsigned integer value for the bits from the given bit offset\nand given number of bits. The endianness of the bits is assumed to be\nBigEndian.","n":"read-ubits","m":0,"k":"m","s":{"p":["int $pos","Int:D $bits","*%_"],"r":"UInt:D"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method Capture(Blob:D)\n\nEquivalent to calling .List.Capture on the invocant.","n":"Capture"},{"n":"Numeric","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"Int"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method bytes(Blob:D: --> Int:D)\n\nReturns the number of bytes used by the elements in the buffer.\n\n    say Blob.new([1, 2, 3]).bytes;      # OUTPUT: «3␤»\n    say blob16.new([1, 2, 3]).bytes;    # OUTPUT: «6␤»\n    say blob64.new([1, 2, 3]).bytes;    # OUTPUT: «24␤»","n":"bytes"},{"d":"Defined as:\n\n    method chars(Blob:D:)\n\nThrows X::Buf::AsStr with chars as payload.","n":"chars","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"reverse","d":"Defined as:\n\n    method reverse(Blob:D: --> Blob:D)\n\nReturns a Blob with all elements in reversed order.\n\n    say Blob.new([1, 2, 3]).reverse;    # OUTPUT: «Blob:0x<03 02 01>␤»\n    say blob16.new([2]).reverse;        # OUTPUT: «Blob[uint16]:0x<02>␤»\n    say buf32.new([16, 32]).reverse;    # OUTPUT: «Buf[uint32]:0x<20 10>␤»\n\nMethods on blob8 only (6.d, 2018.12 and later)\n\nThese methods are available on the blob8 (and buf8) types only. They allow\nlow level access to reading bytes from the underlying data and interpreting\nthem in different ways with regards to type (integer or floating point\n(num)), size (8, 16, 32, 64 or 128 bits), signed or unsigned (for integer\nvalues) and endianness (native, little and big endianness). The returned\nvalues are always expanded to a 64 bit native value where possible, and to\na (big) integer value if that is not possible.\n\nEndianness must be indicated by using values of the Endian enum as the\nsecond parameter to these methods. If no endianness is specified,\nNativeEndian will be assumed. Other values are LittleEndian and BigEndian."},{"s":{"p":["Blob:D \\other","*%_"],"r":"Mu"},"k":"m","m":0,"n":"COMPARE"},{"n":"SAME","k":"m","m":0,"s":{"r":"Mu","p":["Blob:D \\other","*%_"]}},{"s":{"r":"Mu","p":["$delim = \"\"","*%_"]},"m":0,"k":"m","n":"join"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"contents"},{"n":"encoding","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"!fail-typecheck","s":{"p":["$action","$got","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!spread","m":0,"k":"m","s":{"r":"Mu","p":["\\to","\\from","*%_"]}},{"n":"!fail-range","s":{"p":["$got","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!push-list","s":{"p":["\\action","\\to","\\from","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!fail-typecheck-element","k":"m","m":0,"s":{"r":"Mu","p":["\\action","\\i","\\got","*%_"]}},{"s":{"p":["\\action","\\to","\\from","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!unshift-list"}],"mro":[],"b":"C"},{"t":"Sub+{is-pure}","n":"&all","k":"v"},{"s":{"r":"Mu","p":["@values"]},"k":"s","m":1,"n":"all"},{"s":{"p":["+\\values is raw"],"r":"Mu"},"m":1,"k":"s","n":"all"},{"b":"C","t":"Mixy","d":"TITLE\nrole Mixy\n\nSUBTITLE\nCollection of distinct objects with Real weights\n\n    role Mixy does Baggy { }\n\nA role for collections of weighted values. See Mix and MixHash. Mixy\nobjects differ from Baggy objects in that the weights of Mixy are Reals\nrather than Ints.\n\n","n":"Mixy","k":"ro","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"of"},{"n":"new-from-pairs","s":{"p":["*@pairs","*%_"],"r":"Mixy:D"},"k":"m","m":0}],"mro":[]},{"n":"&infix:</>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"s":{"p":[],"r":"Mu"},"m":1,"k":"s","n":"infix:</>"},{"n":"infix:</>","s":{"p":["$x"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:</>","s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"n":"infix:</>"},{"n":"infix:</>","k":"s","m":1,"s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]}},{"s":{"r":"num","p":["num $a","num $b"]},"k":"s","m":1,"n":"infix:</>"},{"n":"infix:</>","k":"s","m":1,"s":{"p":["Range:D \\r","Real:D \\v"],"r":"Mu"}},{"n":"infix:</>","m":1,"k":"s","s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]}},{"n":"infix:</>","s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Mu"},"n":"infix:</>"},{"n":"infix:</>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:</>","s":{"r":"Complex:D","p":["Complex:D \\a","Complex:D \\b"]},"m":1,"k":"s"},{"s":{"p":["Complex:D \\a","Real \\b"],"r":"Complex:D"},"m":1,"k":"s","n":"infix:</>"},{"n":"infix:</>","s":{"p":["Real \\a","Complex:D \\b"],"r":"Complex:D"},"m":1,"k":"s"},{"t":"Sub","n":"&prompt","k":"v"},{"n":"prompt","s":{"r":"Mu","p":[]},"k":"s","m":1},{"n":"prompt","k":"s","m":1,"s":{"p":["$msg"],"r":"Mu"}},{"k":"v","t":"Sub","n":"&unival"},{"s":{"p":["Str:D $str"],"r":"Mu"},"k":"s","m":1,"n":"unival"},{"k":"s","m":1,"s":{"r":"Mu","p":["Int:D $code"]},"n":"unival"},{"b":"A","mro":["Stringy","Positional[uint32]","Uni"],"m":[{"n":"new","s":{"p":["|"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"NFKD"}],"k":"c","n":"NFKD","d":"TITLE\nclass NFKD\n\nSUBTITLE\nCodepoint string in Normal Form KD (compatibility decomposed)\n\n    class NFKD is Uni {}\n\nA Codepoint string in Unicode Normalization Form KD. It is created by\nCompatibility Decomposition. For more information on what this means, see\nUnicode TR15.","t":"NFKD"},{"n":"&done","t":"Sub+{Callable[Nil]}","k":"v"},{"n":"done","s":{"p":[],"r":"Nil"},"k":"s","m":0},{"n":"&infix:«<=>»","t":"Sub+{is-pure}","k":"v"},{"n":"infix:«<=>»","s":{"p":["\\a","\\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:«<=>»","s":{"r":"Mu","p":["Real \\a","Real \\b"]},"k":"s","m":1},{"n":"infix:«<=>»","k":"s","m":1,"s":{"r":"Mu","p":["Int:D \\a","Int:D \\b"]}},{"s":{"r":"Mu","p":["int $a","int $b"]},"m":1,"k":"s","n":"infix:«<=>»"},{"n":"infix:«<=>»","s":{"p":["Num:D \\a","Num:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["num $a","num $b"],"r":"Mu"},"k":"s","m":1,"n":"infix:«<=>»"},{"m":1,"k":"s","s":{"r":"Order:D","p":["Rational:D \\a","Rational:D \\b"]},"n":"infix:«<=>»"},{"s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Order:D"},"k":"s","m":1,"n":"infix:«<=>»"},{"n":"infix:«<=>»","k":"s","m":1,"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Order:D"}},{"s":{"r":"Order:D","p":["Complex:D \\a","Complex:D \\b"]},"k":"s","m":1,"n":"infix:«<=>»"},{"s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Order:D"},"m":1,"k":"s","n":"infix:«<=>»"},{"n":"infix:«<=>»","k":"s","m":1,"s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Order:D"}},{"s":{"r":"Order:D","p":["Instant:D $a","Instant:D $b"]},"k":"s","m":1,"n":"infix:«<=>»"},{"s":{"r":"Order:D","p":["DateTime:D \\a","DateTime:D \\b"]},"k":"s","m":1,"n":"infix:«<=>»"},{"s":{"r":"Order:D","p":["Date:D $a","Date:D $b"]},"m":1,"k":"s","n":"infix:«<=>»"},{"n":"infix:«<=>»","s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"m":1,"k":"s"},{"t":"Sub","n":"&last","k":"v"},{"s":{"r":"Nil","p":[]},"m":1,"k":"s","n":"last"},{"k":"s","m":1,"s":{"p":["Label:D \\x"],"r":"Nil"},"n":"last"},{"k":"v","n":"&pop","t":"Sub"},{"n":"pop","k":"s","m":1,"s":{"r":"Mu","p":["@a"]}},{"n":"SIGALRM","t":"Signal","k":"e"},{"k":"e","n":"SIGFPE","t":"Signal"},{"k":"v","n":"&univals","t":"Sub"},{"n":"univals","s":{"r":"Mu","p":["Str:D $str"]},"k":"s","m":1},{"n":"SIGTSTP","t":"Signal","k":"e"},{"k":"c","mro":["Real","Numeric","Cool"],"t":"Num","n":"τ","b":"C"},{"t":"Signal","n":"Signal","k":"e"},{"k":"e","n":"Signal::SIGKILL","t":"Signal"},{"t":"Signal","n":"Signal::SIGSTKFLT","k":"e"},{"n":"Signal::SIGPWR","t":"Signal","k":"e"},{"t":"Signal","n":"Signal::SIGCONT","k":"e"},{"k":"e","n":"Signal::SIGXFSZ","t":"Signal"},{"t":"Signal","n":"Signal::SIGTTIN","k":"e"},{"n":"Signal::SIGWINCH","t":"Signal","k":"e"},{"k":"e","t":"Signal","n":"Signal::SIGIO"},{"t":"Signal","n":"Signal::SIGHUP","k":"e"},{"k":"e","t":"Signal","n":"Signal::SIGXCPU"},{"t":"Signal","n":"Signal::SIGTRAP","k":"e"},{"k":"e","t":"Signal","n":"Signal::SIGTERM"},{"k":"e","n":"Signal::SIGSYS","t":"Signal"},{"k":"e","n":"Signal::SIGBREAK","t":"Signal"},{"k":"e","n":"Signal::SIGBUS","t":"Signal"},{"t":"Signal","n":"Signal::SIGINT","k":"e"},{"k":"e","n":"Signal::SIGILL","t":"Signal"},{"k":"e","t":"Signal","n":"Signal::SIGQUIT"},{"t":"Signal","n":"Signal::SIGVTALRM","k":"e"},{"k":"e","n":"Signal::SIGUSR2","t":"Signal"},{"k":"e","n":"Signal::SIGURG","t":"Signal"},{"t":"Signal","n":"Signal::SIGTSTP","k":"e"},{"k":"e","n":"Signal::SIGTHR","t":"Signal"},{"n":"Signal::SIGALRM","t":"Signal","k":"e"},{"k":"e","t":"Signal","n":"Signal::SIGFPE"},{"k":"e","t":"Signal","n":"Signal::SIGABRT"},{"k":"e","n":"Signal::SIGUSR1","t":"Signal"},{"n":"Signal::SIGTTOU","t":"Signal","k":"e"},{"k":"e","n":"Signal::SIGINFO","t":"Signal"},{"k":"e","n":"Signal::SIGPROF","t":"Signal"},{"k":"e","t":"Signal","n":"Signal::SIGSTOP"},{"k":"e","n":"Signal::SIGSEGV","t":"Signal"},{"k":"e","n":"Signal::SIGCHLD","t":"Signal"},{"k":"e","n":"Signal::SIGPIPE","t":"Signal"},{"k":"e","n":"Signal::SIGEMT","t":"Signal"},{"t":"Collation","a":[{"n":"$.collation-level","t":"int","k":"v"},{"k":"v","n":"$!Country","t":"Mu"}],"d":"TITLE\nclass Collation\n\nSUBTITLE\nEncapsulates how strings are sorted\n\n    class Collation { }\n\n\nCollation is the class that allows proper sorting, taking into account all\nUnicode characteristics. It's the class the object $*COLLATION is\ninstantiated to, and thus includes collation levels, that is, what kind of\nfeatures should be looked up when comparing two strings and in which\norder.\n\n","n":"Collation","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"gist"},{"s":{"p":["Int :$primary = 1","Int :$secondary = 1","Int :$tertiary = 1","Int :$quaternary = 1","*%_"],"r":"Mu"},"m":0,"k":"m","n":"set"},{"n":"check","s":{"r":"Mu","p":["$more","$less","*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method primary\n\nReturns the state of the primary collation level.","n":"primary"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method secondary\n\nReturns the state of the secondary collation level.","n":"secondary"},{"n":"tertiary","d":"Defined as:\n\n    method tertiary\n\nReturns the state of the tertiary collation level.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"quaternary","d":"Defined as:\n\n    method quaternary\n\nReturns the state of the quaternary collation level."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"collation-level"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Any"],"b":"A"},{"k":"v","n":"&rmdir","t":"Sub"},{"m":1,"k":"s","s":{"r":"Mu","p":["*@filenames"]},"n":"rmdir"},{"b":"A","mro":["Any"],"m":[{"n":"new","s":{"p":["Str :$short-name is copy","Version :$version","Str :$auth","Str :$from = { ... }","CompUnit::Handle :$handle = CompUnit::Handle","CompUnit::Repository :$repo","Str :$repo-id","Bool :$precompiled = Bool::False","Distribution :$distribution","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"unit","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method from(--> Str:D)\n\nReturns the name of the language with which the CompUnit object was created\n(if any). It will be Perl6 by default.","n":"from"},{"d":"method short-name(--> Str:D)\n\nReturns The short name with which the CompUnit object was created (if\nany).","n":"short-name","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"method version(--> Version:D)\n\nReturns the version information with which the CompUnit object was created\n(if any).","n":"version","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"auth","d":"method auth(--> Str:D)\n\nReturns the authority information with which the CompUnit object was\ncreated (if any)."},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"repo","d":"method repo(--> CompUnit::Repository:D)\n\nReturns the CompUnit::Repository object with which the CompUnit object was\ncreated."},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method repo-id(--> Str:D)\n\nReturns the identification string with which the CompUnit object can be\nidentified in the associated repo.","n":"repo-id"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"handle"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method precompiled(--> Bool:D)\n\nReturns whether the CompUnit object originated from a precompiled source.","n":"precompiled"},{"n":"distribution","d":"method distribution(--> Distribution:D)\n\nReturns the Distribution object with which the CompUnit object was created\n(if any).","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","n":"CompUnit","d":"TITLE\nclass CompUnit\n\nSUBTITLE\nCompUnit\n\n    class CompUnit {}\n\nThe CompUnit represents the metainformation about a compilation unit. This\nusually relates to source code that resides in a file on a filesystem,\nrather than code that is executed using an EVAL statement.\n\n","a":[{"t":"Str","n":"$.from","k":"v"},{"t":"Str","n":"$.short-name","k":"v"},{"n":"$.version","t":"Version","k":"v"},{"n":"$.auth","t":"Str","k":"v"},{"k":"v","n":"$!WHICH","t":"Str"},{"k":"v","t":"CompUnit::Repository","n":"$.repo"},{"k":"v","n":"$.repo-id","t":"Str:D"},{"n":"$.handle","t":"CompUnit::Handle","k":"v"},{"k":"v","n":"$.precompiled","t":"Bool"},{"t":"Distribution","n":"$.distribution","k":"v"}],"t":"CompUnit"},{"mro":[],"k":"ro","m":[{"s":{"r":"CompUnit::PrecompilationUnit:D","p":["|"]},"m":0,"k":"m","n":"new-unit"},{"n":"load-unit","m":0,"k":"m","s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"],"r":"Mu"}},{"n":"load-repo-id","s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","IO::Path:D $path",":$extension = \"\"","*%_"]},"m":0,"k":"m","n":"store-file"},{"s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","CompUnit::PrecompilationUnit $unit","*%_"]},"k":"m","m":0,"n":"store-unit"},{"n":"store-repo-id","s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id",":$repo-id!","*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"]},"n":"delete"},{"k":"m","m":0,"s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","*%_"]},"n":"delete-by-compiler"}],"n":"CompUnit::PrecompilationStore","t":"CompUnit::PrecompilationStore","b":"C"},{"k":"c","m":[{"n":"BUILD","k":"s","m":0,"s":{"p":["IO::Path :prefix($!prefix)","*%_"],"r":"Nil"}},{"n":"new-unit","m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","Str :$extension = \"\"","*%_"]},"n":"path"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"unlock"},{"n":"load-unit","m":0,"k":"m","s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"]}},{"s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"],"r":"Mu"},"k":"m","m":0,"n":"load-repo-id"},{"s":{"p":["CompUnit::PrecompilationId $precomp-id","*%_"],"r":"Mu"},"m":0,"k":"m","n":"remove-from-cache"},{"m":0,"k":"m","s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","Str :$extension = \"\"","*%_"],"r":"IO::Path:D"},"n":"destination"},{"k":"m","m":0,"s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","IO::Path:D $path",":$extension = \"\"","*%_"],"r":"Mu"},"n":"store-file"},{"n":"store-unit","s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","CompUnit::PrecompilationUnit $unit","*%_"]},"k":"m","m":0},{"s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id",":$repo-id!","*%_"],"r":"Mu"},"k":"m","m":0,"n":"store-repo-id"},{"n":"delete","m":0,"k":"m","s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","Str :$extension = \"\"","*%_"]}},{"s":{"r":"Mu","p":["CompUnit::PrecompilationId $compiler-id","*%_"]},"m":0,"k":"m","n":"delete-by-compiler"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"prefix"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"},{"m":0,"k":"m","s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","Str :$extension = \"\"","*%_"],"r":"IO::Path:D"},"n":"!file"},{"s":{"p":["CompUnit::PrecompilationId $compiler-id","CompUnit::PrecompilationId $precomp-id","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!dir"},{"n":"!lock","s":{"p":["*%_"],"r":"Nil"},"m":0,"k":"m"}],"mro":["CompUnit::PrecompilationStore","Any"],"t":"CompUnit::PrecompilationStore::File","a":[{"k":"v","n":"$.prefix","t":"IO::Path"},{"n":"$!lock","t":"IO::Handle","k":"v"},{"t":"int","n":"$!lock-count","k":"v"},{"k":"v","t":"Associative","n":"%!loaded"},{"k":"v","t":"Associative","n":"%!compiler-cache"},{"t":"Associative","n":"%!dir-cache","k":"v"},{"k":"v","n":"$!update-lock","t":"Lock"}],"n":"CompUnit::PrecompilationStore::File","b":"A"},{"n":"CompUnit::PrecompilationUnit","t":"CompUnit::PrecompilationUnit","mro":[],"m":[{"n":"id","s":{"p":["*%_"],"r":"CompUnit::PrecompilationId:D"},"k":"m","m":0},{"n":"path","s":{"r":"IO::Path:D","p":["*%_"]},"k":"m","m":0},{"n":"modified","s":{"p":["*%_"],"r":"Instant:D"},"m":0,"k":"m"},{"n":"dependencies","m":0,"k":"m","s":{"p":["*%_"],"r":"Array[CompUnit::PrecompilationDependency]"}},{"s":{"p":["*%_"],"r":"Buf:D"},"m":0,"k":"m","n":"bytecode"},{"n":"checksum","k":"m","m":0,"s":{"p":["*%_"],"r":"Str:D"}},{"n":"source-checksum","k":"m","m":0,"s":{"p":["*%_"],"r":"Str:D"}},{"m":0,"k":"m","s":{"r":"IO::Handle:D","p":["*%_"]},"n":"bytecode-handle"},{"n":"close","k":"m","m":0,"s":{"r":"Nil","p":["*%_"]}},{"s":{"r":"Bool","p":["CompUnit::PrecompilationDependency $dependency","Bool :$check-source","*%_"]},"m":0,"k":"m","n":"is-up-to-date"}],"k":"ro","b":"C"},{"n":"CompUnit::PrecompilationUnit::File","a":[{"n":"$.id","t":"CompUnit::PrecompilationId","k":"v"},{"k":"v","t":"IO::Path","n":"$.path"},{"k":"v","n":"$!file","t":"IO::Handle"},{"t":"Positional[CompUnit::PrecompilationDependency]","n":"@!dependencies","k":"v"},{"k":"v","t":"Mu","n":"$!initialized"},{"t":"Mu","n":"$.checksum","k":"v"},{"t":"Mu","n":"$.source-checksum","k":"v"},{"k":"v","t":"Mu","n":"$!bytecode"},{"k":"v","n":"$!store","t":"Mu"},{"k":"v","n":"$!update-lock","t":"Lock"}],"t":"CompUnit::PrecompilationStore::File::CompUnit::PrecompilationUnit::File","mro":["CompUnit::PrecompilationUnit","Any"],"m":[{"n":"BUILD","s":{"p":["CompUnit::PrecompilationId :id($!id)","IO::Path :path($!path)",":source-checksum($!source-checksum)",":dependencies(@!dependencies)",":bytecode($!bytecode)",":store($!store)","*%_"],"r":"Nil"},"m":0,"k":"s"},{"s":{"r":"Instant:D","p":["*%_"]},"k":"m","m":0,"n":"modified"},{"s":{"p":["*%_"],"r":"Array[CompUnit::PrecompilationDependency]"},"m":0,"k":"m","n":"dependencies"},{"n":"bytecode","k":"m","m":0,"s":{"p":["*%_"],"r":"Buf:D"}},{"s":{"p":["*%_"],"r":"IO::Handle:D"},"m":0,"k":"m","n":"bytecode-handle"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"source-checksum"},{"n":"checksum","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"Str","k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]}},{"n":"close","m":0,"k":"m","s":{"r":"Nil","p":["*%_"]}},{"n":"save-to","k":"m","m":0,"s":{"p":["IO::Path $precomp-file","*%_"],"r":"Mu"}},{"s":{"r":"Bool","p":["CompUnit::PrecompilationDependency $dependency","Bool :$check-source","*%_"]},"k":"m","m":0,"n":"is-up-to-date"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"id"},{"n":"path","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"!open"},{"n":"!read-dependencies","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"}],"k":"c","b":"A"},{"b":"C","mro":[],"m":[{"s":{"p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"],"r":"CompUnit:D"},"k":"m","m":0,"n":"need","d":"Loads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec."},{"n":"resolve","d":"method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec.","s":{"r":"CompUnit:D","p":["CompUnit::DependencySpecification $spec","*%_"]},"k":"m","m":0},{"s":{"p":["IO::Path:D $file","*%_"],"r":"CompUnit:D"},"m":0,"k":"m","n":"load","d":"method load(IO::Path:D $file --> CompUnit:D)\n\nLoad the $file and return a CompUnit object representing it."},{"s":{"r":"Iterable:D","p":["*%_"]},"k":"m","m":0,"n":"loaded","d":"method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded."},{"n":"id","k":"m","m":0,"s":{"p":["*%_"],"r":"Str:D"}},{"s":{"p":["*%_"],"r":"CompUnit::PrecompilationStore"},"m":0,"k":"m","n":"precomp-store"},{"n":"precomp-repository","s":{"p":["*%_"],"r":"CompUnit::PrecompilationRepository"},"k":"m","m":0},{"n":"repo-chain","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0}],"k":"ro","n":"CompUnit::Repository","d":"TITLE\nrole CompUnit::Repository\n\nSUBTITLE\nCompUnit::Repository\n\nThe CompUnit::Repository role defines the interface of the implementation\nof CompUnit::Repositories such as CompUnit::Repository::Installation and\nCompUnit::Repository::FileSystem.\n\n","a":[{"n":"$.next-repo","t":"CompUnit::Repository","k":"v"}],"t":"CompUnit::Repository"},{"b":"C","n":"CompUnit::Repository::Installable","t":"CompUnit::Repository::Installable","mro":[],"m":[{"n":"install","s":{"r":"Mu","p":["Distribution $dist","*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Bool:D"},"m":0,"k":"m","n":"can-install"},{"s":{"p":["*%_"],"r":"Iterable:D"},"k":"m","m":0,"n":"installed"}],"k":"ro"},{"b":"A","a":[{"k":"v","n":"$.short-id","t":"Mu"},{"n":"%.options","t":"Associative","k":"v"},{"n":"$.path","t":"Mu","k":"v"},{"t":"Mu","n":"$.Str","k":"v"}],"t":"CompUnit::Repository::Spec","n":"CompUnit::Repository::Spec","k":"c","m":[{"n":"from-string","s":{"r":"Mu","p":["Str:D $spec",":$default-short-id = \"file\"","*%_"]},"m":0,"k":"m"},{"n":"short-id","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"options"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"path"},{"n":"Str","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"mro":["Any"]},{"n":"CompUnit::Repository::Locally","a":[{"k":"v","n":"$.abspath","t":"Str"},{"t":"IO::Path","n":"$.prefix","k":"v"},{"k":"v","t":"ValueObjAt","n":"$.WHICH"}],"t":"CompUnit::Repository::Locally","mro":[],"m":[{"s":{"p":["Any:D :$prefix is copy","*%_"],"r":"Mu"},"m":0,"k":"m","n":"new"},{"n":"path-spec","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["Str $name","*%_"],"r":"IO::Path:D"},"n":"source-file"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"id"},{"n":"short-id","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}],"k":"ro","b":"C"},{"k":"c","m":[{"s":{"r":"CompUnit:D","p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","*%_"]},"m":0,"k":"m","n":"need"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"loaded"},{"n":"id","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"path-spec","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"next-repo","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"mro":["CompUnit::Repository","Any"],"a":[{"k":"v","t":"CompUnit::Repository","n":"$.next-repo"}],"t":"CompUnit::Repository::Perl5","n":"CompUnit::Repository::Perl5","b":"A"},{"b":"A","a":[{"t":"Associative","n":"%!loaded","k":"v"},{"t":"CompUnit::Repository","n":"$.next-repo","k":"v"}],"t":"CompUnit::Repository::AbsolutePath","n":"CompUnit::Repository::AbsolutePath","k":"c","m":[{"k":"m","m":0,"s":{"p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","*%_"],"r":"CompUnit:D"},"n":"need"},{"n":"load","k":"m","m":0,"s":{"r":"CompUnit:D","p":["IO::Path:D $file","*%_"]}},{"s":{"p":["*%_"],"r":"Iterable:D"},"m":0,"k":"m","n":"loaded"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"id"},{"n":"path-spec","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"next-repo"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["CompUnit::Repository","Any"]},{"b":"A","mro":["CompUnit::Repository","Any"],"m":[{"n":"need","s":{"p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","*%_"],"r":"CompUnit:D"},"k":"m","m":0},{"n":"loaded","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"id","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"path-spec","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"next-repo","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","n":"CompUnit::Repository::NQP","a":[{"k":"v","t":"CompUnit::Repository","n":"$.next-repo"}],"t":"CompUnit::Repository::NQP"},{"b":"A","n":"CompUnit::Repository::Installation","a":[{"k":"v","t":"Mu","n":"$!lock"},{"n":"$!cver","t":"Mu","k":"v"},{"t":"Associative","n":"%!loaded","k":"v"},{"n":"%!seen","t":"Associative","k":"v"},{"t":"Mu","n":"$!precomp","k":"v"},{"k":"v","t":"Mu","n":"$!id"},{"k":"v","n":"$!version","t":"Int"},{"k":"v","t":"Associative","n":"%!dist-metas"},{"n":"$!precomp-stores","t":"Mu","k":"v"},{"k":"v","n":"$!precomp-store","t":"Mu"},{"t":"CompUnit::Repository","n":"$.next-repo","k":"v"},{"n":"$.abspath","t":"Str","k":"v"},{"k":"v","t":"IO::Path","n":"$.prefix"},{"k":"v","t":"ValueObjAt","n":"$.WHICH"}],"t":"CompUnit::Repository::Installation","d":"TITLE\nclass CompUnit::Repository::Installation\n\nSUBTITLE\nCompUnit::Repository::Installation\n\n    class CompUnit::Repository::Installation\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository::Installable\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem, but uses an\ninternal storage format to:\n\n  * Handle case sensitivity issues on filesystems that may conflict as a\n  CompUnit::Repository::FileSystem.\n\n  * Handle allowable filename issues (e.g. unicode) on filesystems that don't\n  support them.\n\n  * Allow multiple distributions with the same name, but with different ver\n  and/or auth and/or api values, to be installed and separately accessible in\n  a single repository.\n\n  * Enable faster module loading by providing module precompilation.\n\nBecause of the internal storage format the usual way to add a distribution\nis not by copying files but by calling\nCompUnit::Repository::Installation#method_install.\n\n","mro":["CompUnit::Repository::Installable","CompUnit::Repository","CompUnit::Repository::Locally","Any"],"m":[{"n":"writeable-path","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"can-install"},{"n":"name","m":0,"k":"m","s":{"r":"Str:D","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"upgrade-repository"},{"d":"method install(Distribution $distribution, Bool :$force)\n\nCopies modules into a special location so that they can be loaded\nafterwards.\n\n:$force will allow installing over an existing distribution that has the\nsame name, auth, api, and ver. Otherwise such a situation will result in\nFailure.\n\n    my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n    my $dist = Distribution::Path.new(...);\n    $inst-repo.install($dist);","n":"install","k":"m","m":0,"s":{"r":"Mu","p":["Distribution $distribution","Bool :$force","*%_"]}},{"s":{"p":["Distribution $distribution","*%_"],"r":"Mu"},"k":"m","m":0,"n":"uninstall","d":"method uninstall(Distribution $distribution)\n\nRemoves the $distribution from the repository. $distribution should be\nobtained from the repository it is being removed from:\n\n    my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n    my $dist = $inst-repo.candidates(\"Acme::Unused\").head;\n    $inst-repo.uninstall($dist);"},{"n":"files","d":"multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming Zef is installed to the default location...\n    my $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","s":{"p":["$file","Str:D :$name!",":$auth",":$ver",":$api","*%_"],"r":"Mu"},"m":1,"k":"m"},{"d":"multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming Zef is installed to the default location...\n    my $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","n":"files","m":1,"k":"m","s":{"r":"Mu","p":["$file",":$auth",":$ver",":$api","*%_"]}},{"d":"multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\n    my $inst-repo = CompUnit::Repository::Installation.new(prefix => $inst-repo-path);\n    my $dist = $inst-repo.candidates(\"Test\").head;\n    say \"Test version: \" ~ $dist.meta<ver>; # OUTPUT: «6.d␤»","n":"candidates","m":1,"k":"m","s":{"r":"Mu","p":["Str:D $name",":$auth",":$ver",":$api","*%_"]}},{"d":"multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\n    my $inst-repo = CompUnit::Repository::Installation.new(prefix => $inst-repo-path);\n    my $dist = $inst-repo.candidates(\"Test\").head;\n    say \"Test version: \" ~ $dist.meta<ver>; # OUTPUT: «6.d␤»","n":"candidates","m":1,"k":"m","s":{"p":["CompUnit::DependencySpecification $spec","*%_"],"r":"Mu"}},{"s":{"p":["CompUnit::DependencySpecification $spec","*%_"],"r":"CompUnit:D"},"k":"m","m":0,"n":"resolve","d":"method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec."},{"m":0,"k":"m","s":{"r":"CompUnit:D","p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"]},"d":"method need(\n        CompUnit::DependencySpecification $spec,\n        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n        --> CompUnit:D)\n\n\nLoads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec.","n":"need"},{"s":{"r":"Mu","p":["$dist-id","$key","*%_"]},"k":"m","m":0,"n":"resource"},{"n":"id","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"short-id","d":"method short-id()\n\nReturns the repo short-id, which for this repository is inst."},{"s":{"r":"Iterable:D","p":["*%_"]},"k":"m","m":0,"n":"loaded","d":"method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded."},{"n":"distribution","s":{"p":["Str $id","*%_"],"r":"Distribution"},"k":"m","m":0},{"n":"installed","m":0,"k":"m","s":{"r":"Iterable:D","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"CompUnit::PrecompilationStore:D","p":["*%_"]},"n":"precomp-store"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"CompUnit::PrecompilationRepository:D"},"n":"precomp-repository"},{"n":"next-repo","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"abspath","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"prefix"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"},{"n":"!lazy-distribution","s":{"p":["$dist-id",":$meta","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["CompUnit::DependencySpecification $spec","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!matching-dist"},{"s":{"r":"Nil","p":["$dist","*%_"]},"k":"m","m":0,"n":"!remove-dist-from-short-name-lookup-files"},{"n":"!repo-prefix","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"!precomp-stores"},{"n":"!writeable-path","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m","n":"!repository-version"},{"n":"!file-id","m":0,"k":"m","s":{"p":["Str $name","Str $dist-id","*%_"],"r":"Mu"}},{"n":"!add-short-name","m":0,"k":"m","s":{"p":["$name","$dist","$source?","$checksum?","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["$id","*%_"],"r":"Mu"},"n":"!read-dist"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"!resources-dir"},{"n":"!short-dir","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"!sources-dir"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!bin-dir"},{"n":"!dist-dir","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}],"k":"c"},{"b":"A","n":"CompUnit::Repository::Unknown","a":[{"k":"v","n":"$.path-spec","t":"Mu"},{"k":"v","t":"Mu","n":"$.short-name"},{"k":"v","n":"$.next-repo","t":"CompUnit::Repository"}],"t":"CompUnit::Repository::Unknown","mro":["CompUnit::Repository","Any"],"k":"c","m":[{"n":"need","m":0,"k":"m","s":{"p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp?","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"],"r":"CompUnit:D"}},{"n":"loaded","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"id"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"Str"},{"n":"path-spec","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"short-name"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"next-repo"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}]},{"b":"A","a":[{"k":"v","n":"%!loaded","t":"Associative"},{"t":"Associative","n":"%!seen","k":"v"},{"k":"v","t":"Mu","n":"$!precomp"},{"k":"v","t":"Mu","n":"$!id"},{"n":"$!precomp-stores","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!precomp-store"},{"n":"$!distribution","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!files-prefix"},{"k":"v","t":"CompUnit::Repository","n":"$.next-repo"},{"t":"Str","n":"$.abspath","k":"v"},{"t":"IO::Path","n":"$.prefix","k":"v"},{"k":"v","n":"$.WHICH","t":"ValueObjAt"}],"d":"TITLE\nclass CompUnit::Repository::FileSystem\n\nSUBTITLE\nCompUnit::Repository::FileSystem\n\n    class CompUnit::Repository::FileSystem\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem typically\nused in development situations. This is what is used by -I . / -I lib\n(which are actually -I file#. and -I file#lib) or use lib \".\" / use lib\n\"lib\". Unlike CompUnit::Repository::Installation, this represents a single\ndistribution.\n\n","t":"CompUnit::Repository::FileSystem","n":"CompUnit::Repository::FileSystem","k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"id"},{"m":0,"k":"m","s":{"r":"CompUnit:D","p":["CompUnit::DependencySpecification $spec","*%_"]},"d":"method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec.","n":"resolve"},{"m":0,"k":"m","s":{"r":"CompUnit:D","p":["CompUnit::DependencySpecification $spec","CompUnit::PrecompilationRepository $precomp = { ... }","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"]},"d":"method need(\n            CompUnit::DependencySpecification $spec,\n            CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n            CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n            --> CompUnit:D)\n\n\nLoads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec.","n":"need"},{"k":"m","m":0,"s":{"r":"CompUnit:D","p":["IO::Path:D $file","*%_"]},"d":"method load(IO::Path:D $file --> CompUnit:D)\n\nLoad the $file and return a CompUnit object representing it.","n":"load"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"short-id","d":"method short-id()\n\nReturns the repo short-id, which for this repository is file."},{"s":{"p":["*%_"],"r":"Iterable:D"},"k":"m","m":0,"n":"loaded","d":"method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded."},{"d":"multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    with $repo.candidates(\"Zef\").head -> $dist {\n        say \"Zef version: \" ~ $dist.meta<version>;\n    }\n    else {\n        say \"No candidates for 'Zef' found\";\n    }","n":"candidates","m":1,"k":"m","s":{"r":"Mu","p":["Str:D $name",":$auth",":$ver",":$api","*%_"]}},{"d":"multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    with $repo.candidates(\"Zef\").head -> $dist {\n        say \"Zef version: \" ~ $dist.meta<version>;\n    }\n    else {\n        say \"No candidates for 'Zef' found\";\n    }","n":"candidates","m":1,"k":"m","s":{"r":"Mu","p":["CompUnit::DependencySpecification $spec","*%_"]}},{"n":"files","d":"multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","s":{"p":["$file","Str:D :$name!",":$auth",":$ver",":$api","*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["$file",":$auth",":$ver",":$api","*%_"]},"d":"multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","n":"files"},{"s":{"p":["$dist-id","$key","*%_"],"r":"Mu"},"k":"m","m":0,"n":"resource"},{"s":{"p":["Str $id?","*%_"],"r":"Distribution"},"m":0,"k":"m","n":"distribution"},{"s":{"r":"CompUnit::PrecompilationStore:D","p":["*%_"]},"m":0,"k":"m","n":"precomp-store"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"CompUnit::PrecompilationRepository:D"},"n":"precomp-repository"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"next-repo"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"abspath"},{"n":"prefix","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"!files-prefix"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"!distribution"},{"k":"m","m":0,"s":{"p":["$name","*%_"],"r":"Mu"},"n":"!comp-unit-id"},{"n":"!precomp-stores","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["CompUnit::DependencySpecification $spec","*%_"]},"m":0,"k":"m","n":"!matching-dist"}],"mro":["CompUnit::Repository","CompUnit::Repository::Locally","Any"]},{"t":"CompUnit::Repository::Distribution","a":[{"t":"Distribution","n":"$!dist","k":"v"},{"k":"v","t":"Mu","n":"$!meta"},{"t":"Mu","n":"$.repo","k":"v"},{"n":"$.dist-id","t":"Mu","k":"v"},{"t":"Mu","n":"$.repo-name","k":"v"}],"n":"CompUnit::Repository::Distribution","k":"c","m":[{"m":0,"k":"s","s":{"r":"Mu","p":["|"]},"n":"TWEAK"},{"n":"BUILD","s":{"p":[":dist($!dist)",":repo($!repo)",":dist-id($!dist-id)",":repo-name($!repo-name)","*%_"],"r":"Nil"},"k":"s","m":0},{"s":{"p":["Distribution $dist","*%_"],"r":"Mu"},"m":0,"k":"m","n":"new"},{"n":"meta","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"Str","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"id","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"from-precomp","m":0,"k":"m","s":{"p":["*%_"],"r":"CompUnit::Repository::Distribution"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"serialize"},{"n":"perl","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"repo","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"dist-id"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"repo-name"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Distribution","Any"],"b":"A"},{"t":"CompUnit::RepositoryRegistry","n":"CompUnit::RepositoryRegistry","k":"c","m":[{"n":"repository-for-spec","m":1,"k":"m","s":{"r":"Mu","p":["Str $spec","CompUnit::Repository :$next-repo","*%_"]}},{"n":"repository-for-spec","s":{"p":["CompUnit::Repository::Spec $spec","CompUnit::Repository :$next-repo","*%_"],"r":"Mu"},"m":1,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"setup-repositories"},{"n":"use-repository","m":0,"k":"m","s":{"r":"Mu","p":["CompUnit::Repository $repo","CompUnit::Repository :$current = { ... }","*%_"]}},{"n":"repository-for-name","s":{"p":["Str:D \\name","*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["$name","CompUnit::Repository $repo","*%_"]},"n":"register-name"},{"n":"name-for-repository","s":{"r":"Mu","p":["CompUnit::Repository $repo","*%_"]},"k":"m","m":0},{"n":"file-for-spec","m":0,"k":"m","s":{"r":"Mu","p":["Str $spec","*%_"]}},{"s":{"p":["$script",":$name",":$auth",":$ver",":$api","*%_"],"r":"Mu"},"m":0,"k":"m","n":"run-script"},{"n":"head","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"resolve-unknown-repos","s":{"r":"Mu","p":["$repo is copy","*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["@conflicts","*%_"]},"k":"m","m":0,"n":"resolve_repossession_conflicts"},{"n":"!register-repository","m":0,"k":"m","s":{"r":"Mu","p":["$id","CompUnit::Repository $repo","*%_"]}},{"s":{"p":["CompUnit::Repository $repo","CompUnit::Repository :$current = { ... }","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!remove-from-chain"}],"mro":["Any"],"b":"A"},{"n":"CompUnit::DependencySpecification","a":[{"k":"v","n":"$.short-name","t":"str"},{"k":"v","t":"int","n":"$.source-line-number"},{"n":"$.from","t":"str","k":"v"},{"n":"$.version-matcher","t":"Mu","k":"v"},{"n":"$.auth-matcher","t":"Mu","k":"v"},{"k":"v","n":"$.api-matcher","t":"Mu"}],"t":"CompUnit::DependencySpecification","mro":["Any"],"m":[{"n":"Str","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"short-name","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"source-line-number","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"from"},{"n":"version-matcher","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"auth-matcher","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"api-matcher"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","b":"A"},{"b":"A","n":"CompUnit::PrecompilationId","t":"CompUnit::PrecompilationId","a":[{"t":"Mu","n":"$.id","k":"v"}],"mro":["Any"],"k":"c","m":[{"m":0,"k":"m","s":{"p":["Str:D $id","*%_"],"r":"Mu"},"n":"new"},{"n":"new-from-string","k":"m","m":0,"s":{"p":["Str:D $id","*%_"],"r":"Mu"}},{"n":"new-without-check","k":"m","m":0,"s":{"r":"Mu","p":["Str:D $id","*%_"]}},{"n":"Str","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"IO","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"n":"substr"},{"n":"id","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}]},{"t":"CompUnit::PrecompilationRepository","n":"CompUnit::PrecompilationRepository","m":[{"k":"m","m":0,"s":{"r":"CompUnit::Handle:D","p":["CompUnit::PrecompilationDependency::File $dependency","IO::Path :$source","CompUnit::PrecompilationStore :@precomp-stores","*%_"]},"n":"try-load"},{"n":"load","k":"m","m":0,"s":{"r":"Nil","p":["CompUnit::PrecompilationId $id","*%_"]}},{"s":{"r":"Bool:D","p":["*%_"]},"m":0,"k":"m","n":"may-precomp"}],"k":"ro","mro":[],"b":"C"},{"m":[{"m":0,"k":"m","s":{"r":"CompUnit::Handle:D","p":["CompUnit::PrecompilationDependency::File $dependency","IO::Path :$source = { ... }","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"]},"n":"try-load"},{"s":{"p":["Str $id","Instant :$since","IO::Path :$source","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"],"r":"Mu"},"k":"m","m":1,"n":"load"},{"k":"m","m":1,"s":{"r":"Mu","p":["CompUnit::PrecompilationId $id","IO::Path :$source","Str :$checksum is copy","Instant :$since","CompUnit::PrecompilationStore :@precomp-stores = { ... }","*%_"]},"n":"load"},{"n":"precompile","k":"m","m":1,"s":{"p":["IO::Path:D $path","Str $id","Bool :$force = Bool::False",":$source-name = { ... }","*%_"],"r":"Mu"}},{"n":"precompile","s":{"p":["IO::Path:D $path","CompUnit::PrecompilationId $id","Bool :$force = Bool::False",":$source-name = { ... }","*%_"],"r":"Mu"},"k":"m","m":1},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"store"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"},{"n":"!load-file","s":{"p":["CompUnit::PrecompilationStore @precomp-stores","CompUnit::PrecompilationId $id",":$repo-id","*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["CompUnit::PrecompilationUnit $unit","*%_"],"r":"Mu"},"n":"!load-handle-for-path"},{"n":"!load-dependencies","m":0,"k":"m","s":{"r":"Mu","p":["CompUnit::PrecompilationUnit:D $precomp-unit","@precomp-stores","*%_"]}}],"k":"c","mro":["CompUnit::PrecompilationRepository","Any"],"a":[{"t":"CompUnit::PrecompilationStore","n":"$.store","k":"v"}],"t":"CompUnit::PrecompilationRepository::Default","n":"CompUnit::PrecompilationRepository::Default","b":"A"},{"b":"A","k":"c","mro":["CompUnit::PrecompilationRepository","Any"],"t":"CompUnit::PrecompilationRepository","n":"CompUnit::PrecompilationRepository::None"},{"t":"CompUnit::Handle","a":[{"n":"$!module_ctx","t":"Mu","k":"v"},{"k":"v","n":"$!unit","t":"Mu"}],"n":"CompUnit::Handle","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"ctxsave"},{"s":{"r":"Mu","p":["Stash $unit","*%_"]},"m":0,"k":"s","n":"from-unit"},{"n":"export-sub","m":0,"k":"m","s":{"r":"Callable:D","p":["*%_"]}},{"s":{"r":"Stash:D","p":["*%_"]},"k":"m","m":0,"n":"export-package"},{"n":"export-how-package","k":"m","m":0,"s":{"p":["*%_"],"r":"Stash:D"}},{"n":"globalish-package","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"unit","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"k":"c","mro":["Any"],"b":"A"},{"b":"C","mro":[],"k":"ro","m":[{"s":{"p":["*%_"],"r":"CompUnit::PrecompilationId:D"},"k":"m","m":0,"n":"id"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Str:D"},"n":"src"},{"n":"spec","k":"m","m":0,"s":{"r":"CompUnit::DependencySpecification:D","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Str:D","p":["*%_"]},"n":"checksum"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"Str"},{"n":"serialize","s":{"p":["*%_"],"r":"Str:D"},"k":"m","m":0},{"n":"deserialize","s":{"p":["Str $","*%_"],"r":"CompUnit::PrecompilationDependency:D"},"m":0,"k":"m"}],"n":"CompUnit::PrecompilationDependency","t":"CompUnit::PrecompilationDependency"},{"mro":["CompUnit::PrecompilationDependency","Any"],"k":"c","m":[{"n":"source-name","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["str $str","*%_"],"r":"Mu"},"n":"deserialize"},{"n":"spec","m":0,"k":"m","s":{"p":["*%_"],"r":"CompUnit::DependencySpecification:D"}},{"k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]},"n":"serialize"},{"n":"Str","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"id","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"src","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"checksum"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"n":"CompUnit::PrecompilationDependency::File","a":[{"n":"$.id","t":"CompUnit::PrecompilationId","k":"v"},{"t":"Str","n":"$.src","k":"v"},{"n":"$.checksum","t":"Str","k":"v"},{"n":"$!serialized-spec","t":"Str","k":"v"},{"k":"v","n":"$.spec","t":"CompUnit::DependencySpecification"}],"t":"CompUnit::PrecompilationDependency::File","b":"A"},{"mro":["Any"],"k":"c","m":[{"n":"load-source-file","k":"m","m":0,"s":{"p":["IO::Path $path","*%_"],"r":"CompUnit::Handle"}},{"n":"load-source","m":0,"k":"m","s":{"p":["Blob:D $bytes","*%_"],"r":"CompUnit::Handle:D"}},{"s":{"r":"CompUnit::Handle:D","p":["IO::Path $path","*%_"]},"k":"m","m":1,"n":"load-precompilation-file"},{"m":1,"k":"m","s":{"p":["IO::Handle $file","*%_"],"r":"CompUnit::Handle:D"},"n":"load-precompilation-file"},{"m":0,"k":"m","s":{"p":["Blob:D $bytes","*%_"],"r":"CompUnit::Handle:D"},"n":"load-precompilation"}],"n":"CompUnit::Loader","t":"CompUnit::Loader","b":"A"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<≠>","k":"v"},{"n":"infix:<!=>","m":1,"k":"s","s":{"r":"Mu","p":["$?"]}},{"k":"s","m":1,"s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"n":"infix:<!=>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["int $a","int $b"]},"n":"infix:<!=>"},{"n":"infix:<!=>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"infix:<!=>","m":1,"k":"s","s":{"r":"Bool:D","p":["num $a","num $b"]}},{"n":"infix:<!=>","m":1,"k":"s","s":{"r":"Bool:D","p":["Instant:D $a","Instant:D $b"]}},{"m":1,"k":"s","s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"n":"infix:<!=>"},{"n":"infix:<!=>","s":{"p":["Version:D \\a","Version:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&atomic-assign"},{"m":1,"k":"s","s":{"p":["$target is rw","\\value"],"r":"Mu"},"n":"atomic-assign"},{"n":"atomic-assign","k":"s","m":1,"s":{"p":["atomicint $target is rw","int $value"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["atomicint $target is rw","Int:D $value"]},"n":"atomic-assign"},{"s":{"r":"Mu","p":["atomicint $target is rw","$value"]},"k":"s","m":1,"n":"atomic-assign"},{"t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<+^>","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["$x"]},"n":"prefix:<+^>"},{"s":{"r":"Int:D","p":["Int:D \\a"]},"m":1,"k":"s","n":"prefix:<+^>"},{"s":{"r":"int","p":["int $a"]},"k":"s","m":1,"n":"prefix:<+^>"},{"k":"v","t":"Sub","n":"&trait_mod:<handles>"},{"s":{"p":["Attribute:D $target","$thunk"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<handles>"},{"s":{"r":"Mu","p":["Method:D $m","&thunk"]},"k":"s","m":1,"n":"trait_mod:<handles>"},{"a":[{"t":"Mu","n":"$.target","k":"v"},{"t":"Positional","n":"@.contents","k":"v"}],"t":"Pod::Raw","n":"Pod::Raw","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"target"},{"n":"contents","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["Any"],"b":"A"},{"mro":["Pod::Block"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method type(--> Mu)","n":"type"},{"n":"meta","d":"method meta(--> Positional)","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"n":"Pod::FormattingCode","t":"Pod::FormattingCode","a":[{"k":"v","t":"Mu","n":"$.type"},{"t":"Positional","n":"@.meta","k":"v"},{"k":"v","n":"%.config","t":"Associative"},{"k":"v","t":"Positional","n":"@.contents"}],"d":"TITLE\nclass Pod::FormattingCode\n\nSUBTITLE\nPod formatting code\n\n    class Pod::FormattingCode is Pod::Block { }\n\nClass for formatting codes in a Pod document.\n\n","b":"A"},{"n":"Pod::Defn","t":"Pod::Defn","a":[{"n":"$.term","t":"Mu","k":"v"},{"k":"v","n":"%.config","t":"Associative"},{"k":"v","t":"Positional","n":"@.contents"}],"d":"TITLE\nclass Pod::Defn\n\nSUBTITLE\nPod definition list\n\n    class Pod::Defn is Pod::Block { }\n\nClass for definition lists in a Pod document.\n\n","mro":["Pod::Block"],"k":"c","m":[{"d":"method term(--> Mu)","n":"term","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"b":"A"},{"n":"Pod::Config","a":[{"k":"v","n":"$.type","t":"Mu"},{"n":"%.config","t":"Associative","k":"v"}],"t":"Pod::Config","mro":["Any"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"type"},{"n":"config","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"mro":["Any"],"m":[{"m":0,"k":"s","s":{"p":[":config(%!config)",":contents(@!contents)","*%_"],"r":"Nil"},"n":"BUILD"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method config(--> Map:D)\n\nReturns a hash of configs.","n":"config"},{"n":"contents","d":"method contents(--> Positional:D)\n\nReturns a list of contents of this block.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"Pod::Block","a":[{"t":"Associative","n":"%.config","k":"v"},{"k":"v","n":"@.contents","t":"Positional"}],"t":"Pod::Block","d":"TITLE\nclass Pod::Block\n\nSUBTITLE\nBlock in a Pod document\n\n    class Pod::Block { }\n\nClass for a Pod block, and base class for most other Pod classes.\n\nA Pod block has contents (more pod blocks or strings) and a config hash.\n\nUseful subclasses:\n\n  Class                   Used for\n  Pod::Block::Para        paragraphs\n  Pod::Block::Named       named blocks\n  Pod::Block::Declarator  declarator blocks\n  Pod::Block::Code        code blocks\n  Pod::Block::Comment     comments\n  Pod::Block::Table       =begin/end table\n                          tabular data\n  Pod::Heading            =head1 etc. headings\n  Pod::Item               list items\n  Pod::Defn               definition lists\n  Pod::FormattingCode     formatting codes\n\n\n","b":"A"},{"b":"A","mro":["Pod::Block"],"k":"c","m":[{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"n":"Pod::Block::Code","d":"TITLE\nclass Pod::Block::Code\n\nSUBTITLE\nVerbatim code block in a Pod document\n\n    class Pod::Block::Code is Pod::Block { }\n\nClass for a code (verbatim) Pod block.\n\n","a":[{"n":"%.config","t":"Associative","k":"v"},{"n":"@.contents","t":"Positional","k":"v"}],"t":"Pod::Block::Code"},{"b":"A","t":"Pod::Block::Declarator","a":[{"k":"v","n":"$.WHEREFORE","t":"Mu"},{"t":"Positional","n":"@!leading","k":"v"},{"n":"@!trailing","t":"Positional","k":"v"},{"k":"v","n":"%.config","t":"Associative"},{"k":"v","t":"Positional","n":"@.contents"}],"d":"TITLE\nclass Pod::Block::Declarator\n\nSUBTITLE\nDeclarator block in a Pod document\n\n    class Pod::Block::Declarator is Pod::Block { }\n\nClass for a declarator Pod block\n\n","n":"Pod::Block::Declarator","k":"c","m":[{"k":"s","m":0,"s":{"r":"Nil","p":[":leading(@!leading)",":trailing(@!trailing)","*%_"]},"n":"BUILD"},{"s":{"r":"Mu","p":["$d","*%_"]},"m":0,"k":"m","n":"set_docee"},{"n":"Str","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"contents","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"leading","d":"method leading(--> Str)\n\nReturns the leading Pod comment attached to the declarator","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"trailing","d":"method trailing(--> Str)\n\nReturns the trailing Pod comment attached to the declarator","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["$addition","*%_"]},"n":"_add_leading"},{"m":0,"k":"m","s":{"r":"Mu","p":["$addition","*%_"]},"n":"_add_trailing"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"WHEREFORE","d":"method WHEREFORE(--> Mu)\n\nReturns the code object or metaobject to which the Pod block is attached\nto"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Pod::Block"]},{"b":"A","mro":["Pod::Block"],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method name(--> Str:D)\n\nReturns the name of the block.","n":"name"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"Pod::Block::Named","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"%.config","t":"Associative"},{"k":"v","n":"@.contents","t":"Positional"}],"t":"Pod::Block::Named","d":"TITLE\nclass Pod::Block::Named\n\nSUBTITLE\nNamed block in a Pod document\n\n    class Pod::Block::Named is Pod::Block { }\n\nClass for a named Pod block. For example\n\n    =begin MySection\n    ...\n    =end MySection\n\n\ncreates a Pod::Block::Named with name MySection.\n\n"},{"b":"A","m":[{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["Pod::Block"],"d":"TITLE\nclass Pod::Block::Comment\n\nSUBTITLE\nComment in a Pod document\n\n    class Pod::Block::Comment is Pod::Block { }\n\nClass for a Pod comment.","a":[{"n":"%.config","t":"Associative","k":"v"},{"k":"v","n":"@.contents","t":"Positional"}],"t":"Pod::Block::Comment","n":"Pod::Block::Comment"},{"n":"Pod::Block::Table","a":[{"k":"v","n":"$.caption","t":"Mu"},{"n":"@.headers","t":"Positional","k":"v"},{"t":"Associative","n":"%.config","k":"v"},{"k":"v","n":"@.contents","t":"Positional"}],"d":"TITLE\nclass Pod::Block::Table\n\nSUBTITLE\nTable in a Pod document\n\n    class Pod::Block::Table is Pod::Block { }\n\nClass for a table in a Pod document.\n\n","t":"Pod::Block::Table","mro":["Pod::Block"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"caption","d":"method caption(--> Str:D)\n\nReturns the associated caption of the table."},{"d":"method headers(--> Positional:D)\n\nReturns a list of table headers. If no headers have been defined the list\nis empty.","n":"headers","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"b":"A"},{"b":"A","k":"c","m":[{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Pod::Block"],"t":"Pod::Block::Para","a":[{"t":"Associative","n":"%.config","k":"v"},{"n":"@.contents","t":"Positional","k":"v"}],"d":"TITLE\nclass Pod::Block::Para\n\nSUBTITLE\nParagraph in a Pod document\n\n    class Pod::Block::Para is Pod::Block { }\n\nClass for a Pod paragraph.","n":"Pod::Block::Para"},{"n":"Pod::Item","d":"TITLE\nclass Pod::Item\n\nSUBTITLE\nItem in a Pod enumeration list\n\n    class Pod::Item is Pod::Block { }\n\nClass for items in Pod enumeration lists.\n\n","a":[{"k":"v","t":"Mu","n":"$.level"},{"k":"v","n":"%.config","t":"Associative"},{"t":"Positional","n":"@.contents","k":"v"}],"t":"Pod::Item","mro":["Pod::Block"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"level","d":"method level(--> Int)\n\nReturns the level of the enumeration list, starting at 1."},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"b":"A"},{"b":"A","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method level(--> Int)\n\nReturns the level of the heading, starting at 1.","n":"level"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["Pod::Block"],"t":"Pod::Heading","a":[{"k":"v","n":"$.level","t":"Mu"},{"t":"Associative","n":"%.config","k":"v"},{"n":"@.contents","t":"Positional","k":"v"}],"d":"TITLE\nclass Pod::Heading\n\nSUBTITLE\nHeading in a Pod document\n\n    class Pod::Heading is Pod::Block { }\n\nClass for headings in a Pod document.\n\n","n":"Pod::Heading"},{"k":"v","n":"&infix:<&&>","t":"Sub+{Precedence}"},{"n":"infix:<&&>","m":1,"k":"s","s":{"r":"Mu","p":["Mu $x = Bool::True"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu \\a","&b"]},"n":"infix:<&&>"},{"k":"s","m":1,"s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"n":"infix:<&&>"},{"k":"v","n":"&rand","t":"Sub"},{"n":"rand","s":{"p":[],"r":"Num:D"},"m":1,"k":"s"},{"k":"v","n":"&infix:«(>+)»","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":["$a","$b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«(>+)»"},{"k":"v","n":"&prefix:<temp>","t":"Sub"},{"n":"prefix:<temp>","k":"s","m":0,"s":{"p":["Mu \\cont"],"r":"Mu"}},{"k":"v","t":"Sub+{is-pure}","n":"&none"},{"n":"none","m":1,"k":"s","s":{"p":["@values"],"r":"Mu"}},{"n":"none","k":"s","m":1,"s":{"r":"Mu","p":["+\\values is raw"]}},{"k":"e","n":"SIGUSR2","t":"Signal"},{"b":"A","k":"c","mro":["Callable","Code"],"a":[{"t":"Code","n":"$!do","k":"v"},{"k":"v","n":"$!signature","t":"Signature"},{"t":"List","n":"@!compstuff","k":"v"}],"t":"WhateverCode","d":"TITLE\nclass WhateverCode\n\nSUBTITLE\nCode object constructed by Whatever-currying\n\n    class WhateverCode is Code { }\n\nWhateverCode objects are the result of Whatever-currying. See the Whatever\ndocumentation for details.\n\nWhen you wish to control how a method or function interprets any Whatever\nstar, you may use multi dispatch with Whatever and WhateverCode parameters\nto do so, as in the following example:\n\n    class Cycle {\n          has $.pos;\n          has @.vals;\n    }\n\n    multi sub get-val(Cycle $c, Int $idx) {\n          $c.vals[$idx % $c.vals.elems]\n    }\n\n    # Define what to do with a stand-alone * as the second argument\n    multi sub get-val(Cycle $c, Whatever $idx) {\n        get-val($c, $c.pos);\n    }\n\n    # Define what to do with a * WhateverCode in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx) {\n        get-val($c, $idx($c.pos));\n    }\n\n    my Cycle $c .= new(:pos(2), :vals(0..^10));\n\n    say get-val($c, 3);   # OUTPUT: «3␤»\n    say get-val($c, *);   # OUTPUT: «2␤»\n    say get-val($c, *-1); # OUTPUT: «1␤»\n\nThe WhateverCode does the Callable role, so it should be possible to\nintrospect the type of Callable it contains; for instance, continuing the\nprevious example, we can add a multi that handles a WhateverCode with two\narguments via checking the signature:\n\n    # Define what to do with two * in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {\n        get-val($c, $idx($c.pos, $c.vals.elems));\n    }\n\n    say get-val($c, * + * div 2); # 2 + 10/2 = 7\n\n\nNote, though, that subexpressions may impose their own Whatever star\nrules:\n\n    my @a = (0, 1, 2);\n    say get-val($c, @a[*-1]) # 2, because the star belongs to the Array class\n\n\nThis can make the ownership of Whatever stars become confusing rather\nquickly, so be careful not to overdo it.\n\nYou may instead type-constrain using Callable type in order to accept any\nCallable, including WhateverCode:\n\n    sub run-with-rand (Callable $code) { $code(rand) };\n    run-with-rand *.say;           # OUTPUT: «0.773672071688484␤»\n    run-with-rand {.say};          # OUTPUT: «0.38673179353983␤»\n    run-with-rand sub { $^v.say }; # OUTPUT: «0.0589543603685792␤»\n\nType-constraining with &-sigiled parameter works equally well and is\nshorter to type:\n\n    sub run-with-rand (&code) { code time };","n":"WhateverCode"},{"n":"&infix:<≽>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<≽>","m":1,"k":"s","s":{"p":["$a","$b"],"r":"Bool:D"}},{"n":"Signature","d":"TITLE\nclass Signature\n\nSUBTITLE\nParameter list pattern\n\n    class Signature { }\n\nA signature is a static description of the parameter list of a code object.\nThat is, it describes what and how many arguments you need to pass to the\ncode or function in order to call it.\n\nPassing arguments to a signature binds the arguments, contained in a\nCapture, to the signature.\n\n \n\nSignature literals\n\nSignatures appear inside parentheses after subroutine and method names, on\nblocks after a ->  or <->  arrow, as the input to variable declarators like\nmy, or as a separate term starting with a colon.\n\n    sub f($x) { }\n    #    ^^^^ Signature of sub f\n    my method x() { }\n    #          ^^ Signature of a method\n    my $s = sub (*@a) { }\n    #           ^^^^^ Signature of an anonymous function\n\n    for <a b c> -> $x { }\n    #              ^^   Signature of a Block\n\n    my ($a, @b) = 5, (6, 7, 8);\n    #  ^^^^^^^^ Signature of a variable declarator\n\n    my $sig = :($a, $b);\n    #          ^^^^^^^^ Standalone Signature object\n\nSignature literals can be used to define the signature of a callback or a\nclosure.\n\n    sub f(&c:(Int)) { }\n    sub will-work(Int) { }\n    sub won't-work(Str) { }\n    f(&will-work);\n\n    f(&won't-work);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding::Parameter: Constraint type check failed in binding to parameter '&c'␤»\n\n    f(-> Int { 'this works too' } );\n\nSmartmatching signatures against a List is supported.\n\n    my $sig = :(Int $i, Str $s);\n    say (10, 'answer') ~~ $sig;\n    # OUTPUT: «True␤»\n    my $sub = sub ( Str $s, Int $i ) { return $s xx $i };\n    say $sub.signature ~~ :( Str, Int );\n    # OUTPUT: «True␤»\n    given $sig {\n        when :(Str, Int) { say 'mismatch' }\n        when :($, $)     { say 'match' }\n        default          { say 'no match' }\n    }\n    # OUTPUT: «match␤»\n\nIt matches the second when clause since :($, $) represents a Signature with\ntwo scalar, anonymous, arguments, which is a more general version of $sig.\n\nWhen smartmatching against a Hash, the signature is assumed to consist of\nthe keys of the Hash.\n\n    my %h = left => 1, right => 2;\n    say %h ~~ :(:$left, :$right);\n    # OUTPUT: «True␤»\n\nSignature literals can contain string/numeric literals\n\n    my $sig = :('Þor', Str, Int);\n    say <Þor Hammer 1> ~~ $sig; # OUTPUT: «True␤»\n\nAnd they can also contain the invocant marker\n\n    class Foo {\n        method bar( $self: ){ \"baz\" }\n    };\n    say Foo.^methods.first(*.name eq 'bar').signature ~~ :($: *%) ;\n    # OUTPUT: «True␤»\n\n  Parameter separators\n\nA signature consists of zero or more parameters, separated by commas.\n\n    my $sig = :($a, @b, %c);\n    sub add($a, $b) { $a + $b };\n\nAs an exception the first parameter may be followed by a colon instead of a\ncomma to mark the invocant of a method. The invocant is the object that was\nused to call the method, which is usually bound to self. By specifying it\nin the signature, you can change the variable name it is bound to.\n\n    method ($a: @b, %c) {};       # first argument is the invocant\n\n    class Foo {\n        method whoami($me:) {\n            \"Well I'm class $me.^name(), of course!\"\n        }\n    }\n    say Foo.whoami; # OUTPUT: «Well I'm class Foo, of course!␤»\n\n \n\n  Type constraints\n\nParameters can optionally have a type constraint (the default is Any).\nThese can be used to restrict the allowed input to a function.\n\n    my $sig = :(Int $a, Str $b);\n\n\nType constraints can have any compile-time defined value\n\n    subset Positive-integer of Int where * > 0;\n    sub divisors(Positive-integer $n) { $_ if $n %% $_ for 1..$n };\n    divisors 2.5;\n    # ERROR «Type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Rat (2.5) $n)»\n    divisors -3;\n    # ERROR: «Constraint type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Int (-3)»\n\n\nPlease note that in the code above type constraints are enforced at two\ndifferent levels: the first level checks if it belongs to the type in which\nthe subset is based, in this case Int. If it fails, a Type check error is\nproduced. Once that filter is cleared, the constraint that defined the\nsubset is checked, producing a Constraint type check error if it fails.\n\n Anonymous arguments are fine too, if you don't actually need to refer to a\nparameter by name, for instance to distinguish between different signatures\nin a multi or to check the signature of a Callable.\n\n    my $sig = :($, @, %a);          # two anonymous and a \"normal\" parameter\n    $sig = :(Int, Positional);      # just a type is also fine (two parameters)\n    sub baz(Str) { \"Got passed a Str\" }\n\nType constraints may also be type captures.\n\n In addition to those nominal types, additional constraints can be placed\non parameters in the form of code blocks which must return a true value to\npass the type check\n\n    sub f(Real $x where { $x > 0 }, Real $y where { $y >= $x }) { }\n\nThe code in where clauses has some limitations: anything that produces\nside-effects (e.g., printing output, pulling from an iterator, or\nincreasing a state variable) is not supported and may produce surprising\nresults if used. Also, the code of the where clause may run more than once\nfor a single typecheck in some implementations.\n\nThe where clause doesn't need to be a code block, anything on the right of\nthe where-clause will be used to smartmatch the argument against it. So you\ncan also write:\n\n    multi factorial(Int $ where 0) { 1 }\n    multi factorial(Int $x)        { $x * factorial($x - 1) }\n\nThe first of those can be shortened to\n\n    multi factorial(0) { 1 }\n\ni.e., you can use a literal directly as a type and value constraint on an\nanonymous parameter.\n\nTip: pay attention to not accidentally leave off a block when you, say,\nhave several conditions:\n\n    -> $y where   .so && .name    {}( sub one   {} ); # WRONG!!\n    -> $y where { .so && .name }  {}( sub two   {} ); # OK!\n    -> $y where   .so &  .name.so {}( sub three {} ); # Also good\n\nThe first version is wrong and will issue a warning about a sub object\ncoerced to string. The reason is the expression is equivalent to ($y ~~\n($y.so && $y.name)); that is \"call .so, and if that is True, call .name; if\nthat is also True use its value for smartmatching…\". It's the result of\n(.so && .name) it will be smartmatched against, but we want to check that\nboth .so and .name are truthy values. That is why an explicit Block or a\nJunction is the right version.\n\nAll previous arguments that are not part of a sub-signature in a Signature\nare accessible in a where-clause that follows an argument. Therefore, the\nwhere-clause of the last argument has access to all arguments of a\nsignature that are not part of a sub-signature. For a sub-signature place\nthe where-clause inside the sub-signature.\n\n    sub foo($a, $b where * == $a ** 2) { say \"$b is a square of $a\" }\n    foo 2, 4; # OUTPUT: «4 is a square of 2␤»»\n    # foo 2, 3;\n    # OUTPUT: «Constraint type check failed in binding to parameter '$b'…»\n\n    Constraining optional arguments\n\nOptional arguments can have constraints, too. Any where clause on any\nparameter will be executed, even if it's optional and not provided by the\ncaller. In that case you may have to guard against undefined values within\nthe where clause.\n\n    sub f(Int $a, UInt $i? where { !$i.defined or $i > 5 }) { ... }\n\n    Constraining slurpy arguments\n\nSlurpy arguments can not have type constraints. A where-clause in\nconjunction with a Junction can be used to that effect.\n\n    sub f(*@a where {$_.all ~~ Int}) { say @a };\n    f(42);\n    f(<a>);\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «[42]␤Constraint type check failed in binding to parameter '@a' ...»\n\n\n    Constraining named arguments\n\nConstraints against Named arguments apply to the value part of the\ncolon-pair.\n\n    sub f(Int :$i){};\n    f :i<forty-two>;\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «X::TypeCheck::Binding::Parameter ==> Type check failed in\n    # binding to parameter '$i'; expected Int but got Str (\"forty-two\")␤»\n\n  \n\n    Constraining argument definiteness\n\nNormally, a type constraint only checks whether the value of the parameter\nis of the correct type. Crucially, both object instances and type objects\nwill satisfy such a constraint as illustrated below:\n\n    say  42.^name;    # OUTPUT: «Int␤»\n    say  42 ~~ Int;   # OUTPUT: «True␤»\n    say Int ~~ Int;   # OUTPUT: «True␤»\n\nNote how both 42 and Int satisfy the match.\n\nSometimes we need to distinguish between these object instances (42) and\ntype objects (Int). Consider the following code:\n\n    sub limit-lines(Str $s, Int $limit) {\n        my @lines = $s.lines;\n        @lines[0 .. min @lines.elems, $limit].join(\"\\n\")\n    }\n    say (limit-lines \"a \\n b \\n c \\n d \\n\", 3).perl; # \"a \\n b \\n c \\n d \"\n    say limit-lines Str, 3;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller lines(Str: );\n    # none of these signatures match:\n    #     (Str:D $: :$count!, *%_)\n    #     (Str:D $: $limit, *%_)\n    #     (Str:D $: *%_)»\n    say limit-lines \"a \\n b\", Int; # Always returns the max number of lines\n\nHere we really only want to deal with string instances, not type objects.\nTo do this, we can use the :D type constraint. This constraint checks that\nthe value passed is an object instance, in a similar fashion to calling its\nDEFINITE (meta)method.\n\nTo warm up, let's apply :D to the right-hand side of our humble Int\nexample:\n\n    say  42 ~~ Int:D;  # OUTPUT: «True␤»\n    say Int ~~ Int:D;  # OUTPUT: «False␤»\n\nNote how only 42 matches Int:D in the above.\n\nReturning to limit-lines, we can now amend its signature to catch the error\nearly:\n\n    sub limit-lines(Str:D $s, Int $limit) { };\n    say limit-lines Str, 3;\n    CATCH { default { put .^name ~ '--' ~ .Str } };\n    # OUTPUT: «Parameter '$s' of routine 'limit-lines' must be an object instance of type 'Str',\n    #          not a type object of type 'Str'.  Did you forget a '.new'?»\n\nThis is much better than the way the program failed before, since here the\nreason for failure is clearer.\n\nIt's also possible that type objects are the only ones that make sense for\na routine to accept. This can be done with the :U type constraint, which\nchecks whether the value passed is a type object rather than an object\ninstance. Here's our Int example again, this time with :U applied:\n\n    say  42 ~~ Int:U;  # OUTPUT: «False␤»\n    say Int ~~ Int:U;  # OUTPUT: «True␤»\n\nNow 42 fails to match Int:U while Int succeeds.\n\nHere's a more practical example:\n\n    sub can-turn-into(Str $string, Any:U $type) {\n       return so $string.$type;\n    }\n    say can-turn-into(\"3\", Int);        # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Int);      # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Num);      # OUTPUT: «True␤»\n    say can-turn-into(\"a string\", Num); # OUTPUT: «False␤»\n\nCalling can-turn-into with an object instance as its second parameter will\nyield a constraint violation as intended:\n\n    say can-turn-into(\"a string\", 123);\n    # OUTPUT: «Parameter '$type' of routine 'can-turn-into' must be a type object\n    # of type 'Any', not an object instance of type 'Int'...»\n\n\nFor explicitly indicating the normal behavior, that is, not constraining\nwhether the argument will be an instance or a type object, :_ can be used,\nbut this is unnecessary. :(Num:_ $) is the same as :(Num $).\n\nTo recap, here is a quick illustration of these type constraints, also\nknown collectively as type smileys:\n\n    # Checking a type object\n    say Int ~~ Any:D;    # OUTPUT: «False␤»\n    say Int ~~ Any:U;    # OUTPUT: «True␤»\n    say Int ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an object instance\n    say 42 ~~ Any:D;     # OUTPUT: «True␤»\n    say 42 ~~ Any:U;     # OUTPUT: «False␤»\n    say 42 ~~ Any:_;     # OUTPUT: «True␤»\n\n    # Checking a user-supplied class\n    class Foo {};\n    say Foo ~~ Any:D;    # OUTPUT: «False␤»\n    say Foo ~~ Any:U;    # OUTPUT: «True␤»\n    say Foo ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an instance of a class\n    my $f = Foo.new;\n    say $f  ~~ Any:D;    # OUTPUT: «True␤»\n    say $f  ~~ Any:U;    # OUTPUT: «False␤»\n    say $f  ~~ Any:_;    # OUTPUT: «True␤»\n\nThe Classes and Objects document further elaborates on the concepts of\ninstances and type objects and discovering them with the .DEFINITE method.\n\nKeep in mind all parameters have values; even optional ones have default\nvalues that are the type object of the constrained type for explicit type\nconstraints. If no explicit type constraint exists, the default value is an\nAny type object for methods, submethods, and subroutines, and a Mu type\nobject for blocks. This means that if you use the :D type smiley, you'd\nneed to provide a default value or make the parameter required. Otherwise,\nthe default value would be a type object, which would fail the definiteness\nconstraint.\n\n    sub divide (Int:D :$a = 2, Int:D :$b!) { say $a/$b }\n    divide :1a, :2b; # OUTPUT: «0.5␤»\n\nThe default value will kick in when that particular parameter, either\npositional or named, gets no value at all.\n\n    sub f($a = 42){\n      my $b is default('answer');\n      say $a;\n      $b = $a;\n      say $b\n    };\n    f;     # OUTPUT: «42␤42␤»\n    f Nil; # OUTPUT: «Nil␤answer␤»\n\n$a has 42 as its default value. With no value, $a will be assigned the\ndefault value declared in the Signature. However, in the second case, it\ndoes receive a value, which happens to be Nil. Assigning Nil to any\nvariable resets it to its default value, which has been declared as\n'answer' by use of the default trait. That explains what happens the second\ntime we call f. Routine parameters and variables deal differently with\ndefault value, which is in part clarified by the different way default\nvalues are declared in each case (using = for parameters, using the default\ntrait for variables).\n\nNote: in 6.c language, the default value of :U/:D constrained variables was\na type object with such a constraint, which is not initializable, thus you\ncannot use the .= operator, for example.\n\n    use v6.c;\n    my Int:D $x .= new: 42;\n    # OUTPUT: You cannot create an instance of this type (Int:D)\n    # in block <unit> at -e line 1\n\n\nIn the 6.d language, the default default is the type object without the\nsmiley constraint:\n\n    use v6.d;\n    my Int:D $x .= new: 42; # OUTPUT: «42␤»\n\n\nA closing remark on terminology: this section is about the use of the type\nsmileys :D and :U to constrain the definiteness of arguments. Occasionally\ndefinedness is used as a synonym for definiteness; this may be confusing,\nsince the terms have subtly different meanings.\n\nAs explained above, definiteness is concerned with the distinction between\ntype objects and object instances. A type object is always indefinite,\nwhile an object instance is always definite. Whether an object is a type\nobject/indefinite or an object instance/definite can be verified using the\nDEFINITE (meta)method.\n\nDefiniteness should be distinguished from definedness, which is concerned\nwith the difference between defined and undefined objects. Whether an\nobject is defined or undefined can be verified using the defined-method,\nwhich is implemented in class Mu. By default a type object is considered\nundefined, while an object instance is considered defined; that is:\n.defined returns False on a type object, and True otherwise. But this\ndefault behavior may be overridden by subclasses. An example of a subclass\nthat overrides the default .defined behavior is Failure, so that even an\ninstantiated Failure acts as an undefined value:\n\n    my $a = Failure;                # Initialize with type object\n    my $b = Failure.new(\"foo\");     # Initialize with object instance\n    say $a.DEFINITE;                # Output: «False␤» : indefinite type object\n    say $b.DEFINITE;                # Output: «True␤»  : definite object instance\n    say $a.defined;                 # Output: «False␤» : default response\n    say $b.defined;                 # Output: «False␤» : .defined override\n\n    Constraining signatures of Callables\n\nThe signature of a Callable parameter can be constrained by specifying a\nSignature literal right after the parameter (no whitespace allowed):\n\n    sub f(&c:(Int, Str))  { say c(10, 'ten') };\n    sub g(Int $i, Str $s) { $s ~ $i };\n    f(&g);\n    # OUTPUT: «ten10␤»\n\nThis shorthand syntax is available only for parameters with the & sigil.\nFor others, you need to use the long version:\n\n    sub f($c where .signature ~~ :(Int, Str))  { say $c(10, 'ten') }\n    sub g(Num $i, Str $s) { $s ~ $i }\n    sub h(Int $i, Str $s) { $s ~ $i }\n    # f(&g); # Constraint type check failed\n    f(&h);   # OUTPUT: «ten10␤»\n\n    Constraining return types\n\nThere are multiple ways to constrain return types on a Routine. All\nversions below are currently valid and will force a type check on\nsuccessful execution of a routine.\n\nNil and Failure are always allowed as return types, regardless of any type\nconstraint. This allows Failure to be returned and passed on down the call\nchain.\n\n    sub foo(--> Int) { Nil };\n    say foo.perl; # OUTPUT: «Nil␤»\n\nType captures are not supported.\n\n \n\n    Return type arrow: -->\n\nThis form of indicating return types (or constants) in the signature is\npreferred, since it can handle constant values while the others can't. For\nconsistency, it is the only form accepted on this site.\n\nThe return type arrow has to be placed at the end of the parameter list,\nwith or without a , before it.\n\n    sub greeting1(Str $name  --> Str) { say \"Hello, $name\" } # Valid\n    sub greeting2(Str $name, --> Str) { say \"Hello, $name\" } # Valid\n\n    sub favorite-number1(--> 42) {        } # OUTPUT: 42\n    sub favorite-number2(--> 42) { return } # OUTPUT: 42\n\n\nIf the type constraint is a constant expression, it is used as the return\nvalue of the routine. Any return statement in that routine has to be\nargumentless.\n\n    sub foo(Str $word --> 123) { say $word; return; }\n    my $value = foo(\"hello\"); # OUTPUT: hello\n    say $value;               # OUTPUT: 123\n\n\n    # The code below will not compile\n    sub foo(Str $word --> 123) { say $word; return $word; }\n    my $value = foo(\"hello\");\n    say $value;\n\n\n    returns\n\nThe keyword returns following a signature declaration has the same function\nas --> with the caveat that this form does not work with constant values.\nYou cannot use it in a block either. That is why the pointy arrow form is\nalways preferred.\n\n    sub greeting(Str $name) returns Str { say \"Hello, $name\" } # Valid\n\n\n    sub favorite-number returns 42 {        } # This will fail.\n\n\n    of\n\nof is just the real name of the returns keyword.\n\n    sub foo() of Int { 42 }; # Valid\n\n\n    sub foo() of 42 {  };    # This will fail.\n\n\n    prefix(C-like) form\n\nThis is similar to placing type constraints on variables like my Type $var\n= 20;, except the $var is a definition for a routine.\n\n    my Int sub bar { 1 };     # Valid\n\n\n    my 42 sub bad-answer {};  # This will fail.\n\n\n    Coercion type\n\nTo accept one type but coerce it automatically to another, use the accepted\ntype as an argument to the target type. If the accepted type is Any it can\nbe omitted.\n\n    sub f(Int(Str) $want-int, Str() $want-str) {\n        say $want-int.^name ~ ' ' ~ $want-str.^name\n    }\n    f '10', 10;\n    # OUTPUT: «Int Str␤»\n\n    use MONKEY;\n    augment class Str { method Date() { Date.new(self) } };\n    sub foo(Date(Str) $d) { say $d.^name; say $d };\n    foo \"2016-12-01\";\n    # OUTPUT: «Date␤2016-12-01␤»\n\nThe coercion is performed by calling the method with the name of the type\nto coerce to, if it exists (e.g. Foo(Bar) coercer, would call method Foo).\nThe method is assumed to return the correct type—no additional checks on\nthe result are currently performed.\n\nCoercion can also be performed on return types:\n\n    sub square-str (Int $x --> Str(Int)) {\n        $x²\n    }\n\n    for 2,4, *²  … 256 -> $a {\n        say $a, \"² is \", square-str( $a ).chars, \" figures long\";\n    }\n\n    # OUTPUT: «2² is 1 figures long␤\n    #          4² is 2 figures long␤\n    #          16² is 3 figures long␤\n    #          256² is 5 figures long␤»\n\n\nIn this example, coercing the return type to String allows us to directly\napply string methods, such as the number of characters.\n\n  \n\n  Slurpy (A.K.A. variadic) parameters\n\nA function is variadic if it can take a varying number of arguments; that\nis, its arity is not fixed. Therefore, optional, named, and slurpy\nparameters are variadic. An array or hash parameter can be marked as slurpy\nby leading single (*) or double asterisk (**) or a leading plus (+). A\nslurpy parameter can bind to an arbitrary number of arguments (zero or\nmore), and it will result in a type that is compatible with the sigil.\n\nThese are called \"slurpy\" because they slurp up any remaining arguments to\na function, like someone slurping up noodles.\n\n    $ = :($a, @b);  # exactly two arguments, where the second one must be Positional\n    $ = :($a, *@b); # at least one argument, @b slurps up any beyond that\n    $ = :(*%h);     # no positional arguments, but any number of named arguments\n\n    sub one-arg (@)  { }\n    sub slurpy  (*@) { }\n    one-arg (5, 6, 7); # ok, same as one-arg((5, 6, 7))\n    slurpy  (5, 6, 7); # ok\n    slurpy   5, 6, 7 ; # ok\n    # one-arg(5, 6, 7) ; # X::TypeCheck::Argument\n    # one-arg  5, 6, 7 ; # X::TypeCheck::Argument\n\n    sub named-names (*%named-args) { %named-args.keys };\n    say named-names :foo(42) :bar<baz>; # OUTPUT: «foo bar␤»\n\n\nPositional and named slurpies can be combined; named arguments (i.e.,\nPairs) are collected in the specified hash, positional arguments in the\narray:\n\n    sub combined-slurpy (*@a, *%h) { { array => @a, hash => %h } }\n    # or: sub combined-slurpy (*%h, *@a) { ... }\n\n    say combined-slurpy(one => 1, two => 2);\n    # OUTPUT: «{array => [], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4);\n    # OUTPUT: «{array => [3 4], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5);\n    # OUTPUT: «{array => [3 4], hash => {five => 5, one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5, 6);\n    # OUTPUT: «{array => [3 4 6], hash => {five => 5, one => 1, two => 2}}␤»\n\n\nNote that positional parameters aren't allowed after slurpy parameters:\n\n    :(*@args, $last);\n    # ===SORRY!=== Error while compiling:\n    # Cannot put required parameter $last after variadic parameters\n\n\nNormally a slurpy parameter will create an Array (or compatible type),\ncreate a new Scalar container for each argument, and assign the value from\neach argument to those Scalars. If the original argument also had an\nintermediary Scalar it is bypassed during this process, and is not\navailable inside the called function.\n\nSigiled parameters will always impose a context on the collected arguments.\nSigilless parameters can also be used slurpily, preceded by a + sign, to\nwork with whatever initial type they started with:\n\n    sub zipi( +zape ) {\n        zape.^name => zape\n    };\n    say zipi( \"Hey \"); # OUTPUT: «List => (Hey )␤»\n    say zipi( 1...* ); # OUTPUT: «Seq => (...)␤»\n\n\nSlurpy parameters have special behaviors when combined with some traits and\nmodifiers, as described in the section on slurpy array parameters.\n\n  Types of slurpy array parameters\n\nThere are three variations to slurpy array parameters.\n\n  * The single asterisk form flattens passed arguments.\n\n  * The double asterisk form does not flatten arguments.\n\n  * The plus form flattens according to the single argument rule.\n\nEach will be described in detail in the next few sections. As the\ndifference between each is a bit nuanced, examples are provided for each to\ndemonstrate how each slurpy convention varies from the others.\n\n    Flattened slurpy\n\nSlurpy parameters declared with one asterisk will flatten arguments by\ndissolving one or more layers of bare Iterables.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub a(*@a)  { @a.perl.say };\n    a(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]»\n    a(1, $list, [2, 3]);       # OUTPUT: «[1, \"d\", \"e\", \"f\", 2, 3]»\n    a([1, 2]);                 # OUTPUT: «[1, 2]»\n    a(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, 1, 2, 3, 4, 5]»\n    a(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]»\n\n\nA single asterisk slurpy flattens all given iterables, effectively hoisting\nany object created with commas up to the top level.\n\n    Unflattened slurpy\n\nSlurpy parameters declared with two stars do not flatten any Iterable\narguments within the list, but keep the arguments more or less as-is:\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub b(**@b) { @b.perl.say };\n    b(@array);                 # OUTPUT: «[[\"a\", \"b\", \"c\"],]␤»\n    b(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    b([1, 2]);                 # OUTPUT: «[[1, 2],]␤»\n    b(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    b(($_ for 1, 2, 3));       # OUTPUT: «[(1, 2, 3),]␤»\n\n\nThe double asterisk slurpy hides the nested comma objects and leaves them\nas-is in the slurpy array.\n\n    Single argument rule slurpy\n\nA slurpy parameter created using a plus engages the \"single argument rule\",\nwhich decides how to handle the slurpy argument based upon context.\nBasically, if only a single argument is passed and that argument is\nIterable, that argument is used to fill the slurpy parameter array. In any\nother case, +@ works like **@.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub c(+@b) { @b.perl.say };\n    c(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]␤»\n    c(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    c([1, 2]);                 # OUTPUT: «[1, 2]␤»\n    c(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    c(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]␤»\n\n\nFor additional discussion and examples, see Slurpy Conventions for\nFunctions.\n\n  Type captures\n\nType captures allow deferring the specification of a type constraint to the\ntime the function is called. They allow referring to a type both in the\nsignature and the function body.\n\n    sub f(::T $p1, T $p2, ::C){\n        # $p1 and $p2 are of the same type T, that we don't know yet\n        # C will hold a type we derive from a type object or value\n        my C $division = $p1 / $p2;\n        return sub (T $p1) {\n            $division * $p1;\n        }\n    }\n\n    # The first parameter is Int and so must be the 2nd.\n    # We derive the 3rd type from calling the operator that is used in &f.\n    my &s = f(10, 2, Int.new / Int.new);\n    say s(2); # 10 / 2 * 2 == 10\n\n \n\n  Positional vs. named arguments\n\nAn argument can be positional or named. By default, arguments are\npositional, except slurpy hash and arguments marked with a leading colon :.\nThe latter is called a colon-pair. Check the following signatures and what\nthey denote:\n\n    $ = :($a);               # a positional argument\n    $ = :(:$a);              # a named argument of name 'a'\n    $ = :(*@a);              # a slurpy positional argument\n    $ = :(*%h);              # a slurpy named argument\n\nOn the caller side, positional arguments are passed in the same order as\nthe arguments are declared.\n\n    sub pos($x, $y) { \"x=$x y=$y\" }\n    pos(4, 5);                          # OUTPUT: «x=4 y=5»\n\nIn the case of named arguments and parameters, only the name is used for\nmapping arguments to parameters. If a fat arrow is used to construct a Pair\nonly those with valid identifiers as keys are recognized as named\narguments.\n\n    sub named(:$x, :$y) { \"x=$x y=$y\" }\n    named( y => 5, x => 4);             # OUTPUT: «x=4 y=5»\n\n\nYou can invoke the routine using a variable with the same name as the named\nargument; in that case : will be used for the invocation so that the name\nof the variable is understood as the key of the argument.\n\n    sub named-shortcut( :$shortcut ) {\n        say \"Looks like $shortcut\"\n    }\n    named-shortcut( shortcut => \"to here\"); # OUTPUT: «Looks like to here␤»\n    my $shortcut = \"Þor is mighty\";\n    named-shortcut( :$shortcut );           # OUTPUT: «Looks like Þor is mighty␤»\n\nIt is possible to have a different name for a named argument than the\nvariable name:\n\n    sub named(:official($private)) { \"Official business!\" if $private }\n    named :official;\n\n  Argument aliases\n\nThe colon-pair syntax can be used to provide aliases for arguments:\n\n    sub alias-named(:color(:$colour), :type(:class($kind))) {\n        say $colour ~ \" \" ~ $kind\n    }\n    alias-named(color => \"red\", type => \"A\");    # both names can be used\n    alias-named(colour => \"green\", type => \"B\"); # more than two names are ok\n    alias-named(color => \"white\", class => \"C\"); # every alias is independent\n\nThe presence of the colon : will decide whether we are creating a new named\nargument or not. :$colour will not only be the name of the aliased\nvariable, but also a new named argument (used in the second invocation).\nHowever, $kind will just be the name of the aliased variable, that does not\ncreate a new named argument. More uses of aliases can be found in sub\nMAIN.\n\nA function with named arguments can be called dynamically, dereferencing a\nPair with | to turn it into a named argument.\n\n    multi f(:$named) { note &?ROUTINE.signature };\n    multi f(:$also-named) { note &?ROUTINE.signature };\n    for 'named', 'also-named' -> $n {\n        f(|($n => rand))                # OUTPUT: «(:$named)␤(:$also-named)␤»\n    }\n\n    my $pair = :named(1);\n    f |$pair;                           # OUTPUT: «(:$named)␤»\n\nThe same can be used to convert a Hash into named arguments.\n\n    sub f(:$also-named) { note &?ROUTINE.signature };\n    my %pairs = also-named => 4;\n    f |%pairs;                              # OUTPUT: «(:$also-named)␤»\n\nA Hash that contains a list may prove problematic when slipped into named\narguments. To avoid the extra layer of containers coerce to Map before\nslipping.\n\n    class C { has $.x; has $.y; has @.z };\n    my %h = <x y z> Z=> (5, 20, [1,2]);\n    say C.new(|%h.Map);\n    # OUTPUT: «C.new(x => 5, y => 20, z => [1, 2])␤»\n\nYou can create as many aliases to a named argument as you want:\n\n    sub alias-named(:color(:$colour),\n                    :variety(:style(:sort(:type(:class($kind)))))) {\n        return $colour ~ \" \" ~ $kind\n    }\n    say alias-named(color => \"red\", style => \"A\");\n    say alias-named(colour => \"green\", variety => \"B\");\n    say alias-named(color => \"white\", class => \"C\");\n\n\n  Optional and mandatory arguments\n\nPositional parameters are mandatory by default, and can be made optional\nwith a default value or a trailing question mark:\n\n    $ = :(Str $id);         # required parameter\n    $ = :($base = 10);      # optional parameter, default value 10\n    $ = :(Int $x?);         # optional parameter, default is the Int type object\n\n Named parameters are optional by default, and can be made mandatory with a\ntrailing exclamation mark:\n\n    $ = :(:%config);        # optional parameter\n    $ = :(:$debug = False); # optional parameter, defaults to False\n    $ = :(:$name!);         # mandatory 'name' named parameter\n\nDefault values can depend on previous parameters, and are (at least\nnotionally) computed anew for each call\n\n    $ = :($goal, $accuracy = $goal / 100);\n    $ = :(:$excludes = ['.', '..']);        # a new Array for every call\n\n  Dynamic variables\n\nDynamic variables are allowed in signatures although they don't provide\nspecial behavior because argument binding does connect two scopes anyway.\n\n  Destructuring arguments\n\nNon-scalar parameters can be followed or substituted by a sub-signature in\nparentheses, which will destructure the argument given. The destructuring\nof a list is just its elements:\n\n    sub first(@array ($first, *@rest)) { $first }\n\nor\n\n    sub first([$f, *@]) { $f }\n\nWhile the destructuring of a hash is its pairs:\n\n    sub all-dimensions(% (:length(:$x), :width(:$y), :depth(:$z))) {\n        $x andthen $y andthen $z andthen True\n    }\n\nPointy loops can also destructure hashes, allowing assignment to\nvariables:\n\n    my %hhgttu = (:40life, :41universe, :42everything);\n    for %hhgttu -> (:$key, :$value) {\n      say \"$key → $value\";\n    }\n    # OUTPUT: «universe → 41␤life → 40␤everything → 42␤»\n\nIn general, an object is destructured based on its attributes. A common\nidiom is to unpack a Pair's key and value in a for loop:\n\n    for <Peter Paul Merry>.pairs -> (:key($index), :value($guest)) { }\n\nHowever, this unpacking of objects as their attributes is only the default\nbehavior. To make an object get destructured differently, change its\nCapture method.\n\n  Sub-signatures\n\nTo match against a compound parameter use a sub-signature following the\nargument name in parentheses.\n\n    sub foo(|c(Int, Str)){\n       put \"called with {c.perl}\"\n    };\n    foo(42, \"answer\");\n    # OUTPUT: «called with \\(42, \"answer\")␤»\n\n  Long names\n\nTo exclude certain parameters from being considered in multiple dispatch,\nseparate them with a double semicolon.\n\n    multi sub f(Int $i, Str $s;; :$b) { say \"$i, $s, {$b.perl}\" };\n    f(10, 'answer');\n    # OUTPUT: «10, answer, Any␤»\n\n  Capture parameters\n\nPrefixing a parameter with a vertical bar | makes the parameter a Capture,\nusing up all the remaining positional and named arguments.\n\nThis is often used in proto definitions (like proto foo (|) {*}) to\nindicate that the routine's multi definitions can have any type\nconstraints. See proto for an example.\n\nIf bound to a variable arguments can be forwarded as a whole using the slip\noperator |.\n\n    sub a(Int $i, Str $s) { say $i.^name ~ ' ' ~ $s.^name }\n    sub b(|c) { say c.^name; a(|c) }\n    b(42, \"answer\");\n    # OUTPUT: «Capture␤Int Str␤»\n\n  Parameter traits and modifiers\n\nBy default, parameters are bound to their argument and marked as read-only.\nOne can change that with traits on the parameter.\n\n The is copy trait causes the argument to be copied, and allows it to be\nmodified inside the routine\n\n    sub count-up($x is copy) {\n        $x = ∞ if $x ~~ Whatever;\n        .say for 1..$x;\n    }\n\n The is rw trait, which stands for is read-write, makes the parameter bind\nto a variable (or other writable container). Assigning to the parameter\nchanges the value of the variable at the caller side.\n\n    sub swap($x is rw, $y is rw) {\n        ($x, $y) = ($y, $x);\n    }\n\nOn slurpy parameters, is rw is reserved for future use by language\ndesigners.\n\n The is raw trait is automatically applied to parameters declared with a\nbackslash as a \"sigil\", and may also be used to make normally sigiled\nparameters behave like these do. In the special case of slurpies, which\nnormally produce an Array full of Scalars as described above, is raw will\ninstead cause the parameter to produce a List. Each element of that list\nwill be bound directly as raw parameter.\n\n To explicitly ask for a read-only parameter use the is readonly trait.\nPlease note that this applies only to the container. The object inside can\nvery well have mutator methods and Raku will not enforce immutability on\nthe attributes of the object.\n\nTraits can be followed by the where clause:\n\n    sub ip-expand-ipv6($ip is copy where m:i/^<[a..f\\d\\:]>**3..39$/) { }\n\n","a":[{"k":"v","n":"@!params","t":"List"},{"t":"Mu","n":"$!returns","k":"v"},{"k":"v","n":"$!arity","t":"int"},{"k":"v","n":"$!count","t":"Num"},{"n":"$!code","t":"Code","k":"v"}],"t":"Signature","mro":["Any"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.\n\nRuntime creation of Signature objects (6.d, 2019.03 and later)\n\n    Signature.new(params => (...), returns => Type, arity => 1, count => 1)\n\n\nIn some situations, specifically when working with the MetaObject Protocol,\nit makes sense to create Signature objects programmatically. For this\npurpose, you can call the new method with the following named parameters:\n\n  * params\n\nA list of Parameter objects for this signature.\n\n  * returns\n\nAny constraint the return value should match. Defaults to Mu, which\neffectively implies no return value constraint check.\n\n  * arity\n\nThe minimal number of positional arguments required to satisfy the\nsignature. Defaults to the number of Parameter objects given with the\nparams parameter.\n\n  * count\n\nThe maximal number of positional arguments which can be bound to the\nsignature. Defaults to the arity if not specified. Specify Inf if there is\na slurpy positional parameter.","n":"Capture"},{"d":"method arity(Signature:D: --> Int:D)\n\nReturns the minimal number of positional arguments required to satisfy the\nsignature.","n":"arity","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"method count(Signature:D: --> Real:D)\n\nReturns the maximal number of positional arguments which can be bound to\nthe signature. Returns Inf if there is a slurpy positional parameter.","n":"count","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"params","d":"method params(Signature:D: --> Positional)\n\nReturns the list of Parameter objects that make up the signature.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!gistperl","s":{"p":["$perl","Mu:U :$elide-type = Mu","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"!deftype"},{"s":{"r":"Mu","p":["@params","Mu $returns","$arity","$count","*%_"]},"m":0,"k":"m","n":"!SET-SELF"}],"k":"c","b":"A"},{"k":"e","n":"SIGURG","t":"Signal"},{"n":"&take","t":"Sub","k":"v"},{"s":{"r":"Mu","p":[]},"m":1,"k":"s","n":"take"},{"m":1,"k":"s","s":{"p":["\\x"],"r":"Mu"},"n":"take"},{"n":"take","k":"s","m":1,"s":{"r":"Mu","p":["|"]}},{"k":"v","n":"&slurp","t":"Sub"},{"m":1,"k":"s","s":{"r":"Mu","p":["IO::Handle:D $fh = { ... }","|c is raw"]},"n":"slurp"},{"n":"slurp","s":{"r":"Mu","p":["$path","|c is raw"]},"m":1,"k":"s"},{"n":"&sleep","t":"Sub","k":"v"},{"n":"sleep","s":{"p":[],"r":"Nil"},"m":1,"k":"s"},{"s":{"p":["$seconds"],"r":"Nil"},"m":1,"k":"s","n":"sleep"},{"n":"&print","t":"Sub","k":"v"},{"n":"print","k":"s","m":1,"s":{"r":"Bool","p":[]}},{"s":{"r":"Mu","p":["Junction:D \\j"]},"k":"s","m":1,"n":"print"},{"s":{"r":"Mu","p":["Str:D \\x"]},"m":1,"k":"s","n":"print"},{"n":"print","s":{"p":["\\x"],"r":"Mu"},"k":"s","m":1},{"n":"print","m":1,"k":"s","s":{"r":"Mu","p":["**@args is raw"]}},{"k":"v","n":"&infix:<=:=>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":["$?"]},"m":1,"k":"s","n":"infix:<=:=>"},{"n":"infix:<=:=>","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"k":"s","m":1},{"n":"&fc","t":"Sub","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["Cool $s"]},"n":"fc"},{"k":"v","n":"&values","t":"Sub"},{"s":{"p":["$x"],"r":"Mu"},"m":1,"k":"s","n":"values"},{"n":"&infix:<∈>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<(elem)>","s":{"r":"Bool:D","p":["Str:D \\a","Map:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(elem)>","s":{"p":["\\a","Map:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<(elem)>","m":1,"k":"s","s":{"p":["Int:D \\a","Range:D \\b"],"r":"Bool:D"}},{"n":"infix:<(elem)>","m":1,"k":"s","s":{"p":["\\a","Iterable:D \\b"],"r":"Bool:D"}},{"n":"infix:<(elem)>","s":{"p":["\\a","Iterator:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<(elem)>","k":"s","m":1,"s":{"p":["\\a","QuantHash:D \\b"],"r":"Bool:D"}},{"s":{"p":["$","Failure:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(elem)>"},{"n":"infix:<(elem)>","k":"s","m":1,"s":{"r":"Mu","p":["Failure:D \\a","$"]}},{"s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(elem)>"},{"k":"v","t":"Sub","n":"&kv"},{"n":"kv","m":1,"k":"s","s":{"p":["$x"],"r":"Mu"}},{"n":"SIGQUIT","t":"Signal","k":"e"},{"n":"SIGVTALRM","t":"Signal","k":"e"},{"k":"v","t":"Sub+{is-pure}","n":"&cosech"},{"n":"cosech","s":{"p":["Numeric \\x"],"r":"Mu"},"k":"s","m":1},{"n":"cosech","k":"s","m":1,"s":{"r":"Mu","p":["Cool \\x"]}},{"n":"cosech","s":{"p":["num $x"],"r":"num"},"k":"s","m":1},{"k":"v","n":"&infix:<+|>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<+|>"},{"s":{"p":["$x"],"r":"Mu"},"k":"s","m":1,"n":"infix:<+|>"},{"n":"infix:<+|>","m":1,"k":"s","s":{"r":"Mu","p":["$x","$y"]}},{"n":"infix:<+|>","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"},"k":"s","m":1},{"n":"infix:<+|>","k":"s","m":1,"s":{"p":["int $a","int $b"],"r":"int"}},{"k":"n","t":"num","n":"num"},{"k":"v","n":"&prefix:<^>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","m":1,"s":{"p":["$max"],"r":"Mu"},"n":"prefix:<^>"},{"n":"&infix:<⊃>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<⊃>","m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","\\b"]}},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∌>","k":"v"},{"n":"infix:<∌>","s":{"r":"Bool:D","p":["\\a","\\b"]},"m":1,"k":"s"},{"k":"v","n":"&infix:<orelse>","t":"Sub+{Precedence}"},{"k":"s","m":1,"s":{"r":"Mu","p":["+$"]},"n":"infix:<orelse>"},{"k":"v","t":"Sub","n":"&ords"},{"n":"ords","m":1,"k":"s","s":{"p":["Cool:D $s"],"r":"Mu"}},{"mro":[],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"iterator","d":"Defined as:\n\n    method iterator(--> Iterator:D)\n\nMethod stub that ensures all classes doing the Iterable role have a method\niterator.\n\nIt is supposed to return an Iterator.\n\n    say (1..10).iterator;"},{"n":"item","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"flat","d":"Defined as:\n\n    method flat(--> Iterable)\n\nReturns another Iterable that flattens out all iterables that the first one\nreturns.\n\nFor example\n\n    say (<a b>, 'c').elems;         # OUTPUT: «2␤»\n    say (<a b>, 'c').flat.elems;    # OUTPUT: «3␤»\n\nbecause <a b>  is a List and thus iterable, so  (<a b>, 'c').flat  returns\n('a', 'b', 'c'), which has three elems.\n\nNote that the flattening is recursive, so (((\"a\", \"b\"), \"c\"), \"d\").flat\nreturns (\"a\", \"b\", \"c\", \"d\"), but it does not flatten itemized sublists:\n\n    say ($('a', 'b'), 'c').perl;    # OUTPUT: «($(\"a\", \"b\"), \"c\")␤»"},{"m":0,"k":"m","s":{"p":["$flag","*%_"],"r":"Mu"},"n":"lazy-if"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method lazy(--> Iterable)\n\nReturns a lazy iterable wrapping the invocant.\n\n    say (1 ... 1000).is-lazy;      # OUTPUT: «False␤»\n    say (1 ... 1000).lazy.is-lazy; # OUTPUT: «True␤»","n":"lazy"},{"d":"Defined as:\n\n    method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4)\n\nReturns another Iterable that is potentially iterated in parallel, with a\ngiven batch size and degree of parallelism.\n\nThe order of elements is preserved.\n\n    say ([1..100].hyper.map({ $_ +1 }).list);\n\nUse hyper in situations where it is OK to do the processing of items in\nparallel, and the output order should be kept relative to the input order.\nSee race for situations where items are processed in parallel and the\noutput order does not matter.\n\n    Options degree and batch\n\nThe degree option (short for \"degree of parallelism\") configures how many\nparallel workers should be started. To start 4 workers (e.g. to use at most\n4 cores), pass :4degree to the hyper or race method. Note that in some\ncases, choosing a degree higher than the available CPU cores can make\nsense, for example I/O bound work or latency-heavy tasks like web crawling.\nFor CPU-bound work, however, it makes no sense to pick a number higher than\nthe CPU core count.\n\nThe batch size option configures the number of items sent to a given\nparallel worker at once. It allows for making a throughput/latency\ntrade-off. If, for example, an operation is long-running per item, and you\nneed the first results as soon as possible, set it to 1. That means every\nparallel worker gets 1 item to process at a time, and reports the result as\nsoon as possible. In consequence, the overhead for inter-thread\ncommunication is maximized. In the other extreme, if you have 1000 items to\nprocess and 10 workers, and you give every worker a batch of 100 items, you\nwill incur minimal overhead for dispatching the items, but you will only\nget the first results when 100 items are processed by the fastest worker\n(or, for hyper, when the worker getting the first batch returns.) Also, if\nnot all items take the same amount of time to process, you might run into\nthe situation where some workers are already done and sit around without\nbeing able to help with the remaining work. In situations where not all\nitems take the same time to process, and you don't want too much\ninter-thread communication overhead, picking a number somewhere in the\nmiddle makes sense. Your aim might be to keep all workers about evenly busy\nto make best use of the resources available.\n\nYou can also check out this blog post on the semantics of hyper and race","n":"hyper","k":"m","m":0,"s":{"r":"Mu","p":["Int(Cool) :$batch = 64","Int(Cool) :$degree = 4","*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["Int(Cool) :$batch = 64","Int(Cool) :$degree = 4","*%_"]},"d":"Defined as:\n\n    method race(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4 --> Iterable)\n\nReturns another Iterable that is potentially iterated in parallel, with a\ngiven batch size and degree of parallelism (number of parallel workers).\n\nUnlike hyper, race does not preserve the order of elements.\n\n    say ([1..100].race.map({ $_ +1 }).list);\n\nUse race in situations where it is OK to do the processing of items in\nparallel, and the output order does not matter. See hyper for situations\nwhere you want items processed in parallel and the output order should be\nkept relative to the input order.\n\nBlog post on the semantics of hyper and race\n\nSee hyper for an explanation of :$batch and :$degree.","n":"race"}],"k":"ro","n":"Iterable","t":"Iterable","d":"TITLE\nrole Iterable\n\nSUBTITLE\nInterface for container objects that can be iterated over\n\n    role Iterable { }\n\nIterable serves as an API for objects that can be iterated with for and\nrelated iteration constructs, like assignment to a Positional variable.\n\nIterable objects nested in other Iterable objects (but not within scalar\ncontainers) flatten in certain contexts, for example when passed to a\nslurpy parameter (*@a), or on explicit calls to flat.\n\nIts most important aspect is a method stub for iterator.\n\n    class DNA does Iterable {\n        has $.chain;\n        method new ($chain where { $chain ~~ /^^ <[ACGT]>+ $$ / } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator(DNA:D:) {\n            $!chain.comb.rotor(3).iterator;\n        }\n    }\n\n    my $a := DNA.new('GAATCC');\n    .say for $a; # OUTPUT: «(G A A)␤(T C C)␤»\n\n\nThis example mixes in the Iterable role to offer a new way of iterating\nover what is essentially a string (constrained by where to just the four\nDNA letters). In the last statement, for actually hooks to the iterator\nrole printing the letters in groups of 3.\n\n","b":"C"},{"b":"A","a":[{"k":"v","n":"$.name","t":"str"},{"k":"v","t":"str","n":"$.scope"},{"k":"v","t":"Mu","n":"$.var"},{"k":"v","t":"Mu","n":"$.block"},{"k":"v","t":"Mu","n":"$.slash"},{"n":"$.implicit-lexical-usage","t":"Mu","k":"v"}],"d":"TITLE\nclass Variable\n\nSUBTITLE\nObject representation of a variable for use in traits\n\n    class Variable {}\n\nVariables have a wealth of compile-time information, but at runtime,\naccesses to a variable usually act on the value stored inside it, not the\nvariable itself. The runtime class of a variable is Scalar.\n\nClass Variable holds the compile-time information that traits can use to\nintrospect and manipulate variables.\n\nTraits\n\n  trait is default\n\nSets the default value with which a variable is initialized, and to which\nit is reset when Nil is assigned to it. Trait arguments are evaluated at\ncompile time. Closures won't do what you expect: they are stored as is and\nneed to be called by hand.\n\n    my Int $x is default(42);\n    say $x;     # OUTPUT: «42␤»\n    $x = 5;\n    say $x;     # OUTPUT: «5␤»\n    # explicit reset:\n    $x = Nil;\n    say $x;     # OUTPUT: «42␤»\n\nThe trait is default can be used also with subscripting things like arrays\nand hashes:\n\n    my @array is default( 'N/A' );\n    @array[22].say;  # OUTPUT: N/A\n    @array = Nil;\n    @array.say;      # OUTPUT: [N/A]\n    @array[4].say;   # OUTPUT: N/A\n\n    my %hash is default( 'no-value-here' );\n    %hash<non-existent-key>.say; # OUTPUT: no-value-here\n    %hash<foo> = 'bar';\n    %hash<>.say;                 # OUTPUT: {foo => bar}\n    %hash<wrong-key>.say;        # OUTPUT: no-value-here\n\n\n  trait is dynamic\n\n    multi sub trait_mod:<is>(Variable:D, :$dynamic)\n\nMarks a variable as dynamic, that is, accessible from inner dynamic scopes\nwithout being in an inner lexical scope.\n\n    sub introspect() {\n        say $CALLER::x;\n    }\n    my $x is dynamic = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Caller::NotDynamic\n    }\n\n\nThe is dynamic trait is a rather cumbersome way of creating and accessing\ndynamic variables. A much easier way is to use the * twigil:\n\n    sub introspect() {\n        say $*x;\n    }\n    my $*x = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Dynamic::NotFound\n    }\n\n\n  trait of\n\n    multi sub trait_mod:<of>(Mu:U $target, Mu:U $type)\n\nSets the type constraint of a container bound to a variable.\n\n    my $i of Int = 42;\n    $i = \"forty plus two\";\n    CATCH { default { say .^name, ' ', .Str } }\n    # OUTPUT: «X::TypeCheck::Assignment Type check failed in assignment to $i; expected Int but got Str (\"forty plus two\")␤»\n\nYou can use any value defined in compile time as a type constraint,\nincluding constants:\n\n    constant \\T = Int;\n    my $i of T = 42;\n\nwhich would be equivalent to the previous definition.\n\n","t":"Variable","n":"Variable","k":"c","m":[{"n":"throw","s":{"p":["|c is raw"],"r":"Mu"},"k":"s","m":0},{"m":0,"k":"s","s":{"p":["&block","$caller-levels = 3","*%_"],"r":"Mu"},"n":"willdo"},{"s":{"p":["Mu $what","*%_"],"r":"Mu"},"k":"s","m":0,"n":"native"},{"n":"name","d":"method name(Variable:D: str)\n\nReturns the name of the variable, including the sigil.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"scope"},{"n":"var","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"block"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"slash"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"implicit-lexical-usage"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Any"]},{"k":"v","t":"Sub+{is-pure}","n":"&cos"},{"n":"cos","s":{"r":"Mu","p":["Numeric \\x"]},"m":1,"k":"s"},{"n":"cos","s":{"r":"Mu","p":["Cool \\x"]},"k":"s","m":1},{"n":"cos","s":{"r":"num","p":["num $x"]},"k":"s","m":1},{"mro":["Any"],"m":[{"n":"new","s":{"p":["str $s","*%_"],"r":"Mu"},"m":0,"k":"m"}],"k":"c","n":"ObjAt","t":"ObjAt","d":"TITLE\nclass ObjAt\n\nSUBTITLE\nUnique identification for an object\n\n    class ObjAt is Any {}\n\nObjects of type ObjAt are the return value of .WHICH calls on other\nobjects, and identify an object uniquely.\n\nIf two objects compare equally via ===, their .WHICH methods return the\nsame ObjAt object.\n\nSee also ValueObjAt for value types.\n\n","b":"A"},{"k":"v","n":"&infix:<(elem)>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}"},{"n":"infix:<(elem)>","s":{"p":["Str:D \\a","Map:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"s":{"p":["\\a","Map:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:<(elem)>"},{"s":{"p":["Int:D \\a","Range:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<(elem)>"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","Iterable:D \\b"]},"n":"infix:<(elem)>"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","Iterator:D \\b"]},"n":"infix:<(elem)>"},{"n":"infix:<(elem)>","m":1,"k":"s","s":{"r":"Bool:D","p":["\\a","QuantHash:D \\b"]}},{"s":{"r":"Mu","p":["$","Failure:D \\b"]},"m":1,"k":"s","n":"infix:<(elem)>"},{"n":"infix:<(elem)>","m":1,"k":"s","s":{"p":["Failure:D \\a","$"],"r":"Mu"}},{"n":"infix:<(elem)>","k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"}},{"k":"v","n":"&infix:<…>","t":"Sub"},{"s":{"p":["|c is raw"],"r":"Mu"},"k":"s","m":1,"n":"infix:<…>"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:«(>=)»"},{"s":{"r":"Bool:D","p":["\\a","\\b"]},"m":1,"k":"s","n":"infix:«(>=)»"},{"b":"A","n":"IterationBuffer","t":"IterationBuffer","mro":["Any"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Nil","p":["*%_"]},"n":"clear"},{"n":"elems","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["Mu \\value","*%_"]},"m":0,"k":"m","n":"push"},{"n":"append","s":{"r":"Mu","p":["IterationBuffer:D \\buffer","*%_"]},"m":0,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["int $pos","*%_"]},"n":"AT-POS"},{"n":"AT-POS","s":{"r":"Mu","p":["Int:D $pos","*%_"]},"m":1,"k":"m"},{"s":{"p":["int $pos","Mu \\value","*%_"],"r":"Mu"},"m":1,"k":"m","n":"BIND-POS"},{"s":{"r":"Mu","p":["Int:D $pos","Mu \\value","*%_"]},"m":1,"k":"m","n":"BIND-POS"},{"n":"List","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}]},{"t":"Sub","n":"&infix:<⚛−=>","k":"v"},{"n":"infix:<⚛-=>","m":1,"k":"s","s":{"p":["atomicint $target is rw","int $add"],"r":"atomicint"}},{"s":{"p":["atomicint $target is rw","Int:D $add"],"r":"atomicint"},"m":1,"k":"s","n":"infix:<⚛-=>"},{"s":{"p":["atomicint $target is rw","$add"],"r":"atomicint"},"k":"s","m":1,"n":"infix:<⚛-=>"},{"k":"v","t":"Sub","n":"&flip"},{"n":"flip","s":{"r":"Str:D","p":["Cool $s"]},"m":1,"k":"s"},{"n":"&join","t":"Sub","k":"v"},{"n":"join","m":1,"k":"s","s":{"p":["$sep = \"\"","*@values"],"r":"Mu"}},{"t":"Num","n":"NaN","k":"c","mro":["Real","Numeric","Cool"],"b":"C"},{"t":"Range","a":[{"t":"Mu","n":"$.min","k":"v"},{"k":"v","n":"$.max","t":"Mu"},{"k":"v","n":"$!excludes-min","t":"int"},{"k":"v","t":"int","n":"$!excludes-max"},{"k":"v","n":"$!infinite","t":"int"},{"k":"v","n":"$!is-int","t":"int"}],"d":"TITLE\nclass Range\n\nSUBTITLE\nInterval of ordered values\n\n    class Range is Cool does Iterable does Positional {}\n\nRanges serve two main purposes: to generate lists of consecutive numbers or\nstrings, and to act as a matcher to check if a number or string is within a\ncertain range.\n\nRanges are constructed using one of the four possible range operators,\nwhich consist of two dots, and optionally a caret which indicates that the\nendpoint marked with it is excluded from the range.\n\n    1 .. 5;  # 1 <= $x <= 5\n    1^.. 5;  # 1 <  $x <= 5\n    1 ..^5;  # 1 <= $x <  5\n    1^..^5;  # 1 <  $x <  5\n\nThe caret is also a prefix operator for constructing numeric ranges\nstarting from zero:\n\n    my $x = 10;\n    say ^$x;     # same as 0 ..^ $x.Numeric\n\nIterating a range (or calling the list method) uses the same semantics as\nthe ++ prefix and postfix operators, i.e., it calls the succ method on the\nstart point, and then the generated elements.\n\nRanges always go from small to larger elements; if the start point is\nbigger than the end point, the range is considered empty.\n\n    for 1..5 { .say };       # OUTPUT: «1␤2␤3␤4␤5␤»\n    ('a' ^..^ 'f').list;     # RESULT: «'b', 'c', 'd', 'e'»\n    5 ~~ ^5;                 # RESULT: «False»\n    4.5 ~~ 0..^5;            # RESULT: «True»\n    (1.1..5).list;           # RESULT: «(1.1, 2.1, 3.1, 4.1)»\n\nUse the ... sequence operator to produce lists of elements that go from\nlarger to smaller values, or to use offsets other than increment-by-1 and\nother complex cases.\n\nUse ∞ or * (Whatever) to indicate an end point to be open-ended.\n\n    for 1..* { .say };       # start from 1, continue until stopped\n    for 1..∞ { .say };       # the same\n\n\nBeware that a WhateverCode end point, instead of a plain Whatever, will go\nthrough the range operator and create another WhateverCode which returns a\nRange:\n\n    # A Whatever produces the 1..Inf range\n    say (1..*).^name;        # OUTPUT: «Range␤»\n    say (1..*);              # OUTPUT: «1..Inf␤»\n    # Upper end point is now a WhateverCode\n    say (1..*+20).^name;     # OUTPUT: «{ ... }␤»\n    say (1..*+20).WHAT;      # OUTPUT: «(WhateverCode)␤»\n    say (1..*+20).(22);      # OUTPUT: «1..42␤»\n\n\nRanges implement Positional interface, so its elements can be accessed\nusing an index. In a case when the index given is bigger than the Range\nobject's size, Nil object will be returned. The access works for lazy Range\nobjects as well.\n\n    say (1..5)[1];  # OUTPUT: «2␤»\n    say (1..5)[10]; # OUTPUT: «Nil␤»\n    say (1..*)[10]; # OUTPUT: «11␤»\n\n\n  Ranges in subscripts\n\nA Range can be used in a subscript to get a range of values. Please note\nthat assigning a Range to a scalar container turns the Range into an item.\nUse binding, @-sigiled containers or a slip to get what you mean.\n\n    my @numbers =  <4 8 15 16 23 42>;\n    my $range := 0..2;\n    .say for @numbers[$range]; # OUTPUT: «4␤8␤15␤»\n    my @range = 0..2;\n    .say for @numbers[@range]; # OUTPUT: «4␤8␤15␤»\n\n  Shifting and scaling intervals\n\nIt is possible to shift or scale the interval of a range:\n\n    say (1..10) + 1;       # OUTPUT: «2..11␤»\n    say (1..10) - 1;       # OUTPUT: «0..9␤»\n    say (1..10) * 2;       # OUTPUT: «2..20␤»\n    say (1..10) / 2;       # OUTPUT: «0.5..5.0␤»\n\n  Matching against Ranges\n\nYou can use smartmatch to match against Ranges.\n\n    say 3 ~~ 1..12;          # OUTPUT: «True␤»\n    say 2..3 ~~ 1..12;       # OUTPUT: «True␤»\n\n In Rakudo only, you can use the in-range method for matching against a\nrange, which in fact is equivalent to smartmatch except it will throw an\nexception when out of range, instead of returning False:\n\n    say ('א'..'ת').in-range('ע');  # OUTPUT: «True␤»\n\nHowever, if it is not included in the range:\n\n    say ('א'..'ת').in-range('p', \"Letter 'p'\");\n    # OUTPUT: «(exit code 1) Letter 'p' out of range. Is: \"p\", should be in \"א\"..\"ת\"␤\n\n\nThe second parameter to in-range is the optional message that will be\nprinted with the exception. It will print Value by default.\n\n","n":"Range","k":"c","m":[{"s":{"r":"Mu","p":["Range $min","\\max",":$excludes-min",":$excludes-max","*%_"]},"m":1,"k":"m","n":"new"},{"n":"new","k":"m","m":1,"s":{"r":"Mu","p":["\\min","Range $max",":$excludes-min",":$excludes-max","*%_"]}},{"n":"new","k":"m","m":1,"s":{"p":["Seq \\min","\\max",":$excludes-min",":$excludes-max","*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"p":["\\min","Seq \\max",":$excludes-min",":$excludes-max","*%_"],"r":"Mu"},"n":"new"},{"n":"new","k":"m","m":1,"s":{"r":"Mu","p":["Complex \\min","\\max",":$excludes-min",":$excludes-max","*%_"]}},{"s":{"p":["\\min","Complex \\max",":$excludes-min",":$excludes-max","*%_"],"r":"Mu"},"k":"m","m":1,"n":"new"},{"s":{"r":"Mu","p":["Whatever \\min","Whatever \\max",":$excludes-min",":$excludes-max","*%_"]},"m":1,"k":"m","n":"new"},{"n":"new","k":"m","m":1,"s":{"r":"Mu","p":["Whatever \\min","\\max",":$excludes-min",":$excludes-max","*%_"]}},{"n":"new","s":{"r":"Mu","p":["\\min","Whatever \\max",":$excludes-min",":$excludes-max","*%_"]},"k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":["Real \\min","$max",":$excludes-min",":$excludes-max","*%_"]},"n":"new"},{"s":{"r":"Mu","p":["List:D \\min","\\max",":$excludes-min",":$excludes-max","*%_"]},"m":1,"k":"m","n":"new"},{"s":{"r":"Mu","p":["Match:D \\min","\\max",":$excludes-min",":$excludes-max","*%_"]},"k":"m","m":1,"n":"new"},{"s":{"r":"Mu","p":["\\min","\\max",":$excludes-min",":$excludes-max!","*%_"]},"k":"m","m":1,"n":"new"},{"n":"new","s":{"p":["\\min","\\max",":$excludes-min!",":$excludes-max","*%_"],"r":"Mu"},"k":"m","m":1},{"s":{"p":["\\min","\\max","*%_"],"r":"Mu"},"k":"m","m":1,"n":"new"},{"d":"method excludes-min(Range:D: --> Bool:D)\n\nReturns True if the start point is excluded from the range, and False\notherwise.\n\n    say (1..5).excludes-min;                          # OUTPUT: «False␤»\n    say (1^..^5).excludes-min;                        # OUTPUT: «True␤»","n":"excludes-min","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"excludes-max","d":"method excludes-max(Range:D: --> Bool:D)\n\nReturns True if the end point is excluded from the range, and False\notherwise.\n\n    say (1..5).excludes-max;                          # OUTPUT: «False␤»\n    say (1^..^5).excludes-max;                        # OUTPUT: «True␤»"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method infinite(Range:D: --> Bool:D)\n\nReturns True if either end point was declared with ∞ or *.\n\n    say (1..5).infinite;                              # OUTPUT: «False␤»\n    say (1..*).infinite;                              # OUTPUT: «True␤»","n":"infinite"},{"n":"is-int","d":"method is-int(Range:D: --> Bool:D)\n\nReturns True if both end points are Int values.\n\n    say ('a'..'d').is-int;                            # OUTPUT: «False␤»\n    say (1..^5).is-int;                               # OUTPUT: «True␤»\n    say (1.1..5.5).is-int;                            # OUTPUT: «False␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"d":"method elems(Range:D: --> Numeric:D)\n\nReturns the number of elements in the range, e.g. when being iterated over,\nor when used as a List. Returns Inf if either end point was specified as\nInf or *.\n\n    say (1..5).elems;                                 # OUTPUT: «5␤»\n    say (1^..^5).elems;                               # OUTPUT: «3␤»","n":"elems","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"iterator","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"flat","d":"method flat(Range:D: --> List:D)\n\nGenerates the list of elements that the range represents.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"reverse","d":"method reverse(Range:D: --> Seq:D)\n\nReturns a Seq where all elements that the Range represents have been\nreversed. Note that reversing an infinite Range won't produce any\nmeaningful results.\n\n    say (1^..5).reverse;                            # OUTPUT: «(5 4 3 2)␤»\n    say ('a'..'d').reverse;                         # OUTPUT: «(d c b a)␤»\n    say (1..∞).reverse;                             # OUTPUT: «(Inf Inf Inf ...)␤»"},{"n":"first","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"bounds","d":"method bounds()\n\nReturns a list consisting of the start and end point.\n\n    say (1..5).bounds;                                # OUTPUT: «(1 5)␤»\n    say (1^..^5).bounds;                              # OUTPUT: «(1 5)␤»"},{"n":"int-bounds","d":"proto method int-bounds(|)\n    multi method int-bounds()\n    multi method int-bounds($from is rw, $to is rw)\n\nIf the Range is an integer range (as indicated by is-int), then this method\nreturns a list with the first and last value it will iterate over (taking\ninto account excludes-min and excludes-max). Returns a Failure if it is not\nan integer range.\n\n    say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\n    say (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»\n\nIf called with (writable) arguments, these will take the the values of the\nhigher and lower bound:\n\n    (3..5).int-bounds( my $min, my $max);\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»","s":{"p":["$from is rw","$to is rw","*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"proto method int-bounds(|)\n    multi method int-bounds()\n    multi method int-bounds($from is rw, $to is rw)\n\nIf the Range is an integer range (as indicated by is-int), then this method\nreturns a list with the first and last value it will iterate over (taking\ninto account excludes-min and excludes-max). Returns a Failure if it is not\nan integer range.\n\n    say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\n    say (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»\n\nIf called with (writable) arguments, these will take the the values of the\nhigher and lower bound:\n\n    (3..5).int-bounds( my $min, my $max);\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»","n":"int-bounds"},{"d":"Defined as\n\n    method fmt(|c)\n\nReturns a string where min and max in the Range have been formatted\naccording to |c.\n\nFor more information about formats strings, see sprintf.\n\n    say (1..2).fmt(\"Element: %d\", \",\") # OUTPUT: «Element: 1,Element: 2␤»","n":"fmt","k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"}},{"n":"ASSIGN-POS","s":{"p":["|"],"r":"Mu"},"m":0,"k":"m"},{"m":1,"k":"m","s":{"r":"Mu","p":["Whatever $","*%_"]},"d":"multi method roll(Range:D:         --> Any:D)\n    multi method roll(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.roll, but attempts to optimize by\nnot actually generating the list if it is not necessary.","n":"roll"},{"d":"multi method roll(Range:D:         --> Any:D)\n    multi method roll(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.roll, but attempts to optimize by\nnot actually generating the list if it is not necessary.","n":"roll","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["Int(Cool) $todo","*%_"],"r":"Mu"},"k":"m","m":1,"n":"roll","d":"multi method roll(Range:D:         --> Any:D)\n    multi method roll(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.roll, but attempts to optimize by\nnot actually generating the list if it is not necessary."},{"d":"multi method pick(Range:D:         --> Any:D)\n    multi method pick(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.pick, but attempts to optimize by\nnot actually generating the list if it is not necessary.","n":"pick","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pick","d":"multi method pick(Range:D:         --> Any:D)\n    multi method pick(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.pick, but attempts to optimize by\nnot actually generating the list if it is not necessary.","s":{"p":["Whatever $","*%_"],"r":"Mu"},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["Int(Cool) $todo","*%_"],"r":"Mu"},"d":"multi method pick(Range:D:         --> Any:D)\n    multi method pick(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.pick, but attempts to optimize by\nnot actually generating the list if it is not necessary.","n":"pick"},{"d":"Defined as:\n\n    method Capture(Range --> Capture:D)\n\nReturns a Capture with values of .min .max, .excludes-min, .excludes-max,\n.infinite, and .is-int as named arguments.","n":"Capture","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"push"},{"n":"append","s":{"p":["|"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"unshift"},{"n":"prepend","k":"m","m":0,"s":{"p":["|"],"r":"Mu"}},{"n":"shift","s":{"r":"Mu","p":["|"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["|"]},"n":"pop"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"sum","d":"multi method sum(--> Numeric:D)\n\nReturns the sum of all elements in the Range. Throws X::Str::Numeric if an\nelement can not be coerced into Numeric.\n\n    (1..10).sum                                       # 55"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"rand","d":"Defined as:\n\n    method rand(Range:D --> Num:D)\n\nReturns a pseudo-random value belonging to the range.\n\n    say (1^..5).rand;                              # OUTPUT: «1.02405550417031␤»\n    say (0.1..0.3).rand;                           # OUTPUT: «0.2130353370062␤»"},{"n":"in-range","m":0,"k":"m","s":{"p":["$got","$what?","*%_"],"r":"Mu"}},{"n":"min","d":"method min(Range:D:)\n\nReturns the start point of the range.\n\n    say (1..5).min;                                   # OUTPUT: «1␤»\n    say (1^..^5).min;                                 # OUTPUT: «1␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"method max(Range:D:)\n\nReturns the end point of the range.\n\n    say (1..5).max;                                   # OUTPUT: «5␤»\n    say (1^..^5).max;                                 # OUTPUT: «5␤»","n":"max","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"},{"n":"!IS-NATIVE-INT","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"!SET-SELF","m":0,"k":"m","s":{"p":["\\min","\\max","\\excludes-min","\\excludes-max","\\infinite","*%_"],"r":"Mu"}},{"n":"!reverse-iterator","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"}],"mro":["Positional","Iterable","Cool"],"b":"C"},{"mro":[],"m":[{"s":{"p":["&emit","&done","&quit","&tap","*%_"],"r":"Mu"},"m":0,"k":"m","n":"tap"},{"n":"live","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"serial","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"sane"}],"k":"ro","n":"Tappable","t":"Tappable","b":"C"},{"t":"Sub+{Callable[Nil]}","n":"&proceed","k":"v"},{"s":{"r":"Nil","p":[]},"m":0,"k":"s","n":"proceed"},{"n":"Thread","d":"TITLE\nclass Thread\n\nSUBTITLE\nConcurrent execution of code (low-level)\n\n    class Thread {}\n\nA thread is a sequence of instructions that can (potentially) run in\nparallel to others. Class Thread provides a bit of abstraction over threads\nprovided by the underlying virtual machines (which in turn might or might\nnot be operating system threads).\n\nSince threads are fairly low-level, most applications should use other\nprimitives, like start, which also runs in parallel and returns a Promise.\n\n    my @threads = (^10).map: {\n        Thread.start(\n            name => \"Sleepsorter $_\",\n            sub {\n                my $rand = (^10).pick;\n                sleep $rand;\n                say $rand;\n            },\n        );\n    }\n\n    .finish for @threads;\n\n\nThe current thread is available in the dynamic variable $*THREAD.\n\n","a":[{"t":"Mu","n":"$!vm_thread","k":"v"},{"n":"$.app_lifetime","t":"Bool","k":"v"},{"k":"v","t":"Str","n":"$.name"}],"t":"Thread","mro":["Any"],"m":[{"n":"BUILD","s":{"p":[":&code!",":app_lifetime($!app_lifetime) = Bool::False",":name($!name) = \"<anon>\"","*%_"],"r":"Nil"},"m":0,"k":"s"},{"k":"m","m":0,"s":{"r":"Mu","p":["&code","*%adverbs"]},"d":"method start(Thread:U: &code, Bool :$app_lifetime = False, Str :$name = '<anon>' --> Thread:D)\n\nCreates, runs and returns a new Thread. Note that it can (and often does)\nreturn before the thread's code has finished running.","n":"start"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"run","d":"method run(Thread:D:)\n\nRuns the thread, and returns the invocant. It is an error to run a thread\nthat has already been started."},{"d":"method id(Thread:D: --> Int:D)\n\nReturns a numeric, unique thread identifier.","n":"id","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method finish(Thread:D)\n\nWaits for the thread to finish. This is called join in other programming\nsystems.","n":"finish"},{"d":"method join(Thread:D)\n\nWaits for the thread to finish.","n":"join","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Nil","p":["*%_"]},"d":"method yield(Thread:U)\n\nTells the scheduler to prefer another thread for now.\n\n    Thread.yield;","n":"yield"},{"k":"m","m":0,"s":{"r":"Bool","p":["*%_"]},"d":"method is-initial-thread(--> Bool)\n\nReturns a Bool indicating whether the current thread (if called as a class\nmethod) or the Thread object on which it is called, is the initial thread\nthe program started on.\n\n    say Thread.is-initial-thread;    # True if this is the initial thread\n    say $*THREAD.is-initial-thread;  # True if $*THREAD is the initial thread\n\nPlease note there is no guarantee that this is actually the main thread\nfrom the OS's point of view. Also note that if you need this other than\nfrom a pure introspection / debugging point of view, that there are\nprobably better ways to achieve what you're trying to achieve.\n\nRoutines\n\n  sub full-barrier\n\n    sub full-barrier()\n\nPerforms a full memory barrier, preventing re-ordering of reads/writes.\nRequired for implementing some lock-free data structures and algorithms.","n":"is-initial-thread"},{"n":"usage","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"app_lifetime","d":"method app_lifetime(Thread:D: --> Bool:D)\n\nReturns False unless the named parameter :app_lifetime is specifically set\nto True during object creation. If the method returns False it means that\nthe process will only terminate when the thread has finished while True\nmeans that the thread will be killed when the main thread of the process\nterminates.\n\n    my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\n    my $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, :app_lifetime);\n\n    say $t1.app_lifetime;                 # OUTPUT: «False␤»\n    say $t2.app_lifetime;                 # OUTPUT: «True␤»"},{"d":"method name(Thread:D: --> Str:D)\n\nReturns the user defined string, which can optionally be set during object\ncreation in order to identify the Thread, or '<anon>' if no such string was\nspecified.\n\n    my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\n    my $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, name => 'my thread');\n\n    say $t1.name;                 # OUTPUT: «<anon>␤»\n    say $t2.name;                 # OUTPUT: «my thread␤»","n":"name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","b":"A"},{"b":"C","n":"Thread::THREAD_ERROR","t":"Str","mro":["Stringy","Cool"],"m":[{"n":"!match-x","k":"m","m":0,"s":{"r":"Mu","p":["\\slash","\\iterator","$x","*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["\\slash","\\cursor","str $name","$value","\\opts","*%_"]},"n":"!match-cursor"},{"s":{"r":"Mu","p":["\\slash","$pattern","str $name","$value","\\opts","*%_"]},"m":0,"k":"m","n":"!match-pattern"},{"n":"!match-nth-int","k":"m","m":0,"s":{"p":["\\slash","\\cursor","\\move","\\post","int $nth","*%_"],"r":"Mu"}},{"n":"!match-x-range","k":"m","m":0,"s":{"p":["\\slash","\\iterator","$min","$max","*%_"],"r":"Mu"}},{"s":{"p":["\\caller_dollar_slash","$matcher","$replacement",":global(:$g)",":ii(:$samecase)",":ss(:$samespace)",":mm(:$samemark)","*%options"],"r":"Mu"},"m":0,"k":"m","n":"!SUBST"},{"k":"m","m":0,"s":{"p":["\\limit","*%_"],"r":"Nil"},"n":"!ensure-limit-sanity"},{"n":"!match-nth-range","k":"m","m":0,"s":{"r":"Mu","p":["\\slash","\\iterator","$min","$max","*%_"]}},{"s":{"p":["\\slash","\\source","\\indexes","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!match-nth-iterator"},{"m":0,"k":"m","s":{"p":["\\slash","\\cursor","\\move","\\post","*%_"],"r":"Mu"},"n":"!match-list"},{"n":"!match-as-one","m":0,"k":"m","s":{"p":["\\slash","\\cursor","\\as","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["$pos","*%_"]},"k":"m","m":0,"n":"!RINDEX-OOR"},{"m":0,"k":"m","s":{"p":["$pos","*%_"],"r":"Mu"},"n":"!INDEX-OOR"},{"n":"!match-nth","s":{"r":"Mu","p":["\\slash","\\cursor","\\move","\\post","$nth","%opts","*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["\\slash","\\cursor","\\move","int $tail","*%_"]},"k":"m","m":0,"n":"!match-nth-tail"},{"s":{"r":"Mu","p":["\\slash","\\cursor","\\move","*%_"]},"m":0,"k":"m","n":"!match-last"},{"m":0,"k":"m","s":{"r":"Mu","p":["\\matches","$replacement","\\cds","\\SDS","\\word_by_word","\\space","\\case","\\mark","*%_"]},"n":"!APPLY-MATCHES"},{"n":"!match-one","s":{"r":"Mu","p":["\\slash","\\cursor","*%_"]},"k":"m","m":0},{"n":"!ensure-split-sanity","s":{"p":["\\v","\\k","\\kv","\\p","*%_"],"r":"Mu"},"k":"m","m":0}],"k":"c"},{"t":"Sub","n":"&nextcallee","k":"v"},{"s":{"p":[],"r":"Mu"},"k":"s","m":0,"n":"nextcallee"},{"mro":["Any"],"m":[{"n":"abs","d":"Defined as:\n\n    sub abs(Numeric() $x)\n    method abs()\n\nCoerces the invocant (or in the sub form, the argument) to Numeric and\nreturns the absolute value (that is, a non-negative number).\n\n    say (-2).abs;       # OUTPUT: «2␤»\n    say abs \"6+8i\";     # OUTPUT: «10␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"d":"Defined as:\n\n    method conj()\n\nCoerces the invocant to Numeric and returns the complex conjugate (that is,\nthe number with the sign of the imaginary part negated).\n\n    say (1+2i).conj;        # OUTPUT: «1-2i␤»","n":"conj","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"sqrt","d":"Defined as:\n\n    sub sqrt(Numeric(Cool) $x)\n    method sqrt()\n\nCoerces the invocant to Numeric (or in the sub form, the argument) and\nreturns the square root, that is, a non-negative number that, when\nmultiplied with itself, produces the original number.\n\n    say 4.sqrt;             # OUTPUT: «2␤»\n    say sqrt(2);            # OUTPUT: «1.4142135623731␤»"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method sign()\n\nCoerces the invocant to Numeric and returns its sign, that is, 0 if the\nnumber is 0, 1 for positive and -1 for negative values.\n\n    say 6.sign;             # OUTPUT: «1␤»\n    say (-6).sign;          # OUTPUT: «-1␤»\n    say \"0\".sign;           # OUTPUT: «0␤»","n":"sign"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"rand","d":"Defined as:\n\n    method rand()\n\nCoerces the invocant to Num and returns a pseudo-random value between zero\nand the number.\n\n    say 1e5.rand;           # OUTPUT: «33128.495184283␤»"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub sin(Numeric(Cool))\n    method sin()\n\nCoerces the invocant (or in the sub form, the argument) to Numeric,\ninterprets it as radians, returns its sine.\n\n    say sin(0);             # OUTPUT: «0␤»\n    say sin(pi/4);          # OUTPUT: «0.707106781186547␤»\n    say sin(pi/2);          # OUTPUT: «1␤»\n\nNote that Raku is no computer algebra system, so sin(pi) typically does not\nproduce an exact 0, but rather a very small floating-point number.","n":"sin"},{"n":"asin","d":"Defined as:\n\n    sub asin(Numeric(Cool))\n    method asin()\n\nCoerces the invocant (or in the sub form, the argument) to Numeric, and\nreturns its arc-sine in radians.\n\n    say 0.1.asin;               # OUTPUT: «0.10016742116156␤»\n    say asin(0.1);              # OUTPUT: «0.10016742116156␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"d":"Defined as:\n\n    sub cos(Numeric(Cool))\n    method cos()\n\nCoerces the invocant (or in sub form, the argument) to Numeric, interprets\nit as radians, returns its cosine.\n\n    say 0.cos;                  # OUTPUT: «1␤»\n    say pi.cos;                 # OUTPUT: «-1␤»\n    say cos(pi/2);              # OUTPUT: «6.12323399573677e-17␤»","n":"cos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub acos(Numeric(Cool))\n    method acos()\n\nCoerces the invocant (or in sub form, the argument) to Numeric, and returns\nits arc-cosine in radians.\n\n    say 1.acos;                 # OUTPUT: «0␤»\n    say acos(-1);               # OUTPUT: «3.14159265358979␤»","n":"acos"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"tan","d":"Defined as:\n\n    sub tan(Numeric(Cool))\n    method tan()\n\nCoerces the invocant (or in sub form, the argument) to Numeric, interprets\nit as radians, returns its tangent.\n\n    say tan(3);                 # OUTPUT: «-0.142546543074278␤»\n    say 3.tan;                  # OUTPUT: «-0.142546543074278␤»"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub atan(Numeric(Cool))\n    method atan()\n\nCoerces the invocant (or in sub form, the argument) to Numeric, and returns\nits arc-tangent in radians.\n\n    say atan(3);                # OUTPUT: «1.24904577239825␤»\n    say 3.atan;                 # OUTPUT: «1.24904577239825␤»","n":"atan"},{"n":"atan2","d":"Defined as:\n\n    method atan2($y = 1e0)\n\nCoerces self and argument to Numeric, using them to compute the\ntwo-argument arc-tangent in radians.\n\n    say 3.atan2;                # OUTPUT: «1.24904577239825␤»\n    say ⅔.atan2(⅓);             # OUTPUT: «1.1071487177940904␤»\n\nThe first argument defaults to 1, so in the first case the function will\nreturn the angle θ in radians between a vector that goes from origin to the\npoint (3, 1) and the x axis.","s":{"p":["$y = 1e0","*%_"],"r":"Mu"},"k":"m","m":0},{"d":"Defined as:\n\n    sub sec(Numeric(Cool))\n    method sec()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, interprets\nit as radians, returns its secant, that is, the reciprocal of its cosine.\n\n    say 45.sec;                 # OUTPUT: «1.90359440740442␤»\n    say sec(45);                # OUTPUT: «1.90359440740442␤»","n":"sec","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"asec","d":"Defined as:\n\n    sub asec(Numeric(Cool))\n    method asec()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits arc-secant in radians.\n\n    say 1.asec;                 # OUTPUT: «0␤»\n    say sqrt(2).asec;           # OUTPUT: «0.785398163397448␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"cosec","d":"Defined as:\n\n    sub cosec(Numeric(Cool))\n    method cosec()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, interprets\nit as radians, returns its cosecant, that is, the reciprocal of its sine.\n\n    say 0.45.cosec;             # OUTPUT: «2.29903273150897␤»\n    say cosec(0.45);            # OUTPUT: «2.29903273150897␤»"},{"n":"acosec","d":"Defined as:\n\n    sub acosec(Numeric(Cool))\n    method acosec()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits arc-cosecant in radians.\n\n    say 45.acosec;              # OUTPUT: «0.0222240516182672␤»\n    say acosec(45)              # OUTPUT: «0.0222240516182672␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"cotan","d":"Defined as:\n\n    sub cotan(Numeric(Cool))\n    method cotan()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, interprets\nit as radians, returns its cotangent, that is, the reciprocal of its\ntangent.\n\n    say 45.cotan;               # OUTPUT: «0.617369623783555␤»\n    say cotan(45);              # OUTPUT: «0.617369623783555␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"acotan","d":"Defined as:\n\n    sub acotan(Numeric(Cool))\n    method acotan()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits arc-cotangent in radians.\n\n    say 45.acotan;              # OUTPUT: «0.0222185653267191␤»\n    say acotan(45)              # OUTPUT: «0.0222185653267191␤»"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"sinh","d":"Defined as:\n\n    sub sinh(Numeric(Cool))\n    method sinh()\n\nCoerces the invocant (or in method form, its argument) to Numeric, and\nreturns its Sine hyperbolicus.\n\n    say 1.sinh;                 # OUTPUT: «1.1752011936438␤»\n    say sinh(1);                # OUTPUT: «1.1752011936438␤»"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub asinh(Numeric(Cool))\n    method asinh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse Sine hyperbolicus.\n\n    say 1.asinh;                # OUTPUT: «0.881373587019543␤»\n    say asinh(1);               # OUTPUT: «0.881373587019543␤»","n":"asinh"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub cosh(Numeric(Cool))\n    method cosh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Cosine hyperbolicus.\n\n    say cosh(0.5);              # OUTPUT: «1.12762596520638␤»","n":"cosh"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub acosh(Numeric(Cool))\n    method acosh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse Cosine hyperbolicus.\n\n    say acosh(45);              # OUTPUT: «4.4996861906715␤»","n":"acosh"},{"d":"Defined as:\n\n    sub tanh(Numeric(Cool))\n    method tanh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, interprets\nit as radians and returns its Tangent hyperbolicus.\n\n    say tanh(0.5);              # OUTPUT: «0.46211715726001␤»\n    say tanh(atanh(0.5));       # OUTPUT: «0.5␤»","n":"tanh","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"atanh","d":"Defined as:\n\n    sub atanh(Numeric(Cool))\n    method atanh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse tangent hyperbolicus.\n\n    say atanh(0.5);             # OUTPUT: «0.549306144334055␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"sech","d":"Defined as:\n\n    sub sech(Numeric(Cool))\n    method sech()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Secant hyperbolicus.\n\n    say 0.sech;                 # OUTPUT: «1␤»"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"asech","d":"Defined as:\n\n    sub asech(Numeric(Cool))\n    method asech()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse hyperbolic secant.\n\n    say 0.8.asech;              # OUTPUT: «0.693147180559945␤»"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub cosech(Numeric(Cool))\n    method cosech()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Hyperbolic cosecant.\n\n    say cosech(pi/2);           # OUTPUT: «0.434537208094696␤»","n":"cosech"},{"d":"Defined as:\n\n    sub acosech(Numeric(Cool))\n    method acosech()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse hyperbolic cosecant.\n\n    say acosech(4.5);           # OUTPUT: «0.220432720979802␤»","n":"acosech","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub cotanh(Numeric(Cool))\n    method cotanh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Hyperbolic cotangent.\n\n    say cotanh(pi);             # OUTPUT: «1.00374187319732␤»","n":"cotanh"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"acotanh","d":"Defined as:\n\n    sub acotanh(Numeric(Cool))\n    method acotanh()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\nits Inverse hyperbolic cotangent.\n\n    say acotanh(2.5);           # OUTPUT: «0.423648930193602␤»"},{"n":"cis","d":"Defined as:\n\n    sub cis(Numeric(Cool))\n    method cis()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and returns\ncos(argument) + i*sin(argument).\n\n    say cis(pi/4);              # OUTPUT: «0.707106781186548+0.707106781186547i␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-prime","k":"m","m":0,"s":{"r":"Bool:D","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"log","d":"Defined as:\n\n    multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)\n    multi method log(Cool:D: Cool:D $base?)\n\nCoerces the arguments (including the invocant in the method form) to\nNumeric, and returns its Logarithm to base $base, or to base e (Euler's\nNumber) if no base was supplied (Natural logarithm). Returns NaN if $base\nis negative. Throws an exception if $base is 1.\n\n    say (e*e).log;              # OUTPUT: «2␤»"},{"m":1,"k":"m","s":{"p":["$base","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)\n    multi method log(Cool:D: Cool:D $base?)\n\nCoerces the arguments (including the invocant in the method form) to\nNumeric, and returns its Logarithm to base $base, or to base e (Euler's\nNumber) if no base was supplied (Natural logarithm). Returns NaN if $base\nis negative. Throws an exception if $base is 1.\n\n    say (e*e).log;              # OUTPUT: «2␤»","n":"log"},{"d":"Defined as:\n\n    multi sub exp(Cool:D $pow, Cool:D $base?)\n    multi method exp(Cool:D: Cool:D $base?)\n\nCoerces the arguments (including the invocant in the method from) to\nNumeric, and returns $base raised to the power of the first number. If no\n$base is supplied, e (Euler's Number) is used.\n\n    say 0.exp;      # OUTPUT: «1␤»\n    say 1.exp;      # OUTPUT: «2.71828182845905␤»\n    say 10.exp;     # OUTPUT: «22026.4657948067␤»","n":"exp","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"r":"Mu","p":["$base","*%_"]},"d":"Defined as:\n\n    multi sub exp(Cool:D $pow, Cool:D $base?)\n    multi method exp(Cool:D: Cool:D $base?)\n\nCoerces the arguments (including the invocant in the method from) to\nNumeric, and returns $base raised to the power of the first number. If no\n$base is supplied, e (Euler's Number) is used.\n\n    say 0.exp;      # OUTPUT: «1␤»\n    say 1.exp;      # OUTPUT: «2.71828182845905␤»\n    say 10.exp;     # OUTPUT: «22026.4657948067␤»","n":"exp"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi sub round(Numeric(Cool))\n    multi method round(Cool:D: $unit = 1)\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and rounds\nit to the unit of $unit. If $unit is 1, rounds to the nearest integer.\n\n    say 1.7.round;          # OUTPUT: «2␤»\n    say 1.07.round(0.1);    # OUTPUT: «1.1␤»\n    say 21.round(10);       # OUTPUT: «20␤»\n\nAlways rounds up if the number is at mid-point:\n\n    say (−.5 ).round;       # OUTPUT: «0␤»\n    say ( .5 ).round;       # OUTPUT: «1␤»\n    say (−.55).round(.1);   # OUTPUT: «-0.5␤»\n    say ( .55).round(.1);   # OUTPUT: «0.6␤»\n\nPay attention to types when using this method, as ending up with the wrong\ntype may affect the precision you seek to achieve. For Real types, the type\nof the result is the type of the argument (Complex argument gets coerced to\nReal, ending up a Num). If rounding a Complex, the result is Complex as\nwell, regardless of the type of the argument.\n\n    9930972392403501.round(1)      .perl.say; # OUTPUT: «9930972392403501␤»\n    9930972392403501.round(1e0)    .perl.say; # OUTPUT: «9.9309723924035e+15␤»\n    9930972392403501.round(1e0).Int.perl.say; # OUTPUT: «9930972392403500␤»","n":"round"},{"s":{"p":["$base","*%_"],"r":"Mu"},"m":1,"k":"m","n":"round","d":"Defined as:\n\n    multi sub round(Numeric(Cool))\n    multi method round(Cool:D: $unit = 1)\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and rounds\nit to the unit of $unit. If $unit is 1, rounds to the nearest integer.\n\n    say 1.7.round;          # OUTPUT: «2␤»\n    say 1.07.round(0.1);    # OUTPUT: «1.1␤»\n    say 21.round(10);       # OUTPUT: «20␤»\n\nAlways rounds up if the number is at mid-point:\n\n    say (−.5 ).round;       # OUTPUT: «0␤»\n    say ( .5 ).round;       # OUTPUT: «1␤»\n    say (−.55).round(.1);   # OUTPUT: «-0.5␤»\n    say ( .55).round(.1);   # OUTPUT: «0.6␤»\n\nPay attention to types when using this method, as ending up with the wrong\ntype may affect the precision you seek to achieve. For Real types, the type\nof the result is the type of the argument (Complex argument gets coerced to\nReal, ending up a Num). If rounding a Complex, the result is Complex as\nwell, regardless of the type of the argument.\n\n    9930972392403501.round(1)      .perl.say; # OUTPUT: «9930972392403501␤»\n    9930972392403501.round(1e0)    .perl.say; # OUTPUT: «9.9309723924035e+15␤»\n    9930972392403501.round(1e0).Int.perl.say; # OUTPUT: «9930972392403500␤»"},{"n":"roots","d":"Defined as:\n\n    multi sub roots(Numeric(Cool) $x, Int(Cool) $n)\n    multi method roots(Int(Cool) $n)\n\nCoerces the first argument (and in method form, the invocant) to Numeric\nand the second ($n) to Int, and produces a list of $n Complex $n-roots,\nwhich means numbers that, raised to the $nth power, approximately produce\nthe original number.\n\nFor example\n\n    my $original = 16;\n    my @roots = $original.roots(4);\n    say @roots;\n\n    for @roots -> $r {\n        say abs($r ** 4 - $original);\n    }\n\n    # OUTPUT:«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2i␤»\n    # OUTPUT:«1.77635683940025e-15␤»\n    # OUTPUT:«4.30267170434156e-15␤»\n    # OUTPUT:«8.03651692704705e-15␤»\n    # OUTPUT:«1.04441561648202e-14␤»","s":{"p":["Cool $n","*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi sub log10(Cool(Numeric))\n    multi method log10()\n\nCoerces the invocant (or in the sub form, the invocant) to Numeric, and\nreturns its Logarithm to base 10, that is, a number that approximately\nproduces the original number when raised to the power of 10. Returns NaN\nfor negative arguments and -Inf for 0.\n\n    say log10(1001);            # OUTPUT: «3.00043407747932␤»","n":"log10"},{"m":0,"k":"m","s":{"r":"Mu","p":["$n","*%_"]},"d":"Defined as:\n\n    method unpolar(Numeric(Cool))\n\nCoerces the arguments (including the invocant in the method form) to\nNumeric, and returns a complex number from the given polar coordinates. The\ninvocant (or the first argument in sub form) is the magnitude while the\nargument (i.e. the second argument in sub form) is the angle. The angle is\nassumed to be in radians.\n\n    say sqrt(2).unpolar(pi/4);      # OUTPUT: «1+1i␤»","n":"unpolar"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"floor","d":"Defined as:\n\n    multi sub floor(Numeric(Cool))\n    multi method floor\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and rounds\nit downwards to the nearest integer.\n\n    say \"1.99\".floor;       # OUTPUT: «1␤»\n    say \"-1.9\".floor;       # OUTPUT: «-2␤»\n    say 0.floor;            # OUTPUT: «0␤»"},{"d":"Defined as:\n\n    multi sub ceiling(Numeric(Cool))\n    multi method ceiling\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and rounds\nit upwards to the nearest integer.\n\n    say \"1\".ceiling;        # OUTPUT: «1␤»\n    say \"-0.9\".ceiling;     # OUTPUT: «0␤»\n    say \"42.1\".ceiling;     # OUTPUT: «43␤»","n":"ceiling","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    multi sub truncate(Numeric(Cool))\n    multi method truncate()\n\nCoerces the invocant (or in sub form, its argument) to Numeric, and rounds\nit towards zero.\n\n    say 1.2.truncate;       # OUTPUT: «1␤»\n    say truncate -1.2;      # OUTPUT: «-1␤»","n":"truncate","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0,"n":"chars","d":"Defined as:\n\n    multi sub chars(Cool $x)\n    multi sub chars(Str:D $x)\n    multi sub chars(str $x --> int)\n    method chars(--> Int:D)\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nnumber of characters in the string. Please note that on the JVM, you\ncurrently get codepoints instead of graphemes.\n\n    say 'møp'.chars;    # OUTPUT: «3␤»\n    say 'ã̷̠̬̊'.chars;     # OUTPUT: «1␤»\n    say '\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF'.chars;    # OUTPUT: «1␤»\n\nIf the string is native, the number of chars will be also returned as a\nnative int.\n\nGraphemes are user visible characters. That is, this is what the user\nthinks of as a “character”.\n\nGraphemes can contain more than one codepoint. Typically the number of\ngraphemes and codepoints differs when Prepend or Extend characters are\ninvolved (also known as Combining characters), but there are many other\ncases when this may happen. Another example is \\c[ZWJ] (Zero-width\njoiner).\n\nYou can check Grapheme_Cluster_Break property of a character in order to\nsee how it is going to behave:\n\n    say ‘ã̷̠̬̊’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(Other Extend Extend Extend Extend)␤»\n    say ‘\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)␤»\n\nYou can read more about graphemes in the Unicode Standard, which Raku\ntightly follows, using a method called NFG, normal form graphemes for\nefficiently representing them."},{"d":"Defined as:\n\n    sub codes(Str(Cool))\n    method codes()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nnumber of Unicode code points.\n\n    say 'møp'.codes;    # OUTPUT: «3␤»\n\nThe same result will be obtained with\n\n    say +'møp'.ords;    # OUTPUT: «3␤»\n\nords first obtains the actual codepoints, so there might be a difference in\nspeed.","n":"codes","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"fmt","d":"Defined as:\n\n    method fmt($format = '%s')\n\nUses $format to return a formatted representation of the invocant;\nequivalent to calling sprintf with $format as format and the invocant as\nthe second argument. The $format will be coerced to Stringy and defaults to\n'%s'.\n\nFor more information about formats strings, see sprintf.\n\n    say 11.fmt('This Int equals %03d');         # OUTPUT: «This Int equals 011␤»\n    say '16'.fmt('Hexadecimal %x');             # OUTPUT: «Hexadecimal 10␤»","s":{"p":["$format = \"\\%s\"","*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub uc(Str(Cool))\n    method uc()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\ncase-folded to upper case (capital letters).\n\n    say \"Abc\".uc;       # OUTPUT: «ABC␤»","n":"uc"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub lc(Str(Cool))\n    method lc()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\ncase-folded to lower case.\n\n    say \"ABC\".lc;       # OUTPUT: «abc␤»","n":"lc"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub tc(Str(Cool))\n    method tc()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\nwith the first letter case-folded to title case (or where not available,\nupper case).\n\n    say \"abC\".tc;       # OUTPUT: «AbC␤»","n":"tc"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub fc(Str(Cool))\n    method fc()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nresult a Unicode \"case fold\" operation suitable for doing caseless string\ncomparisons. (In general, the returned string is unlikely to be useful for\nany purpose other than comparison.)\n\n    say \"groß\".fc;       # OUTPUT: «gross␤»","n":"fc"},{"n":"tclc","d":"Defined as:\n\n    sub tclc(Str(Cool))\n    method tclc()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\nwith the first letter case-folded to title case (or where not available,\nupper case), and the rest of the string case-folded to lower case.\n\n    say 'abC'.tclc;     # OUTPUT: «Abc␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub wordcase(Str(Cool) $input, :&filter = &tclc, Mu :$where = True)\n    method wordcase(:&filter = &tclc, Mu :$where = True)\n\nCoerces the invocant (or in sub form, the first argument) to Str, and\nfilters each word that smartmatches against $where through the &filter.\nWith the default filter (first character to upper case, rest to lower) and\nmatcher (which accepts everything), this title-cases each word:\n\n    say \"perl 6 programming\".wordcase;      # OUTPUT: «Raku Programming␤»\n\nWith a matcher:\n\n    say \"have fun working on perl\".wordcase(:where({ .chars > 3 }));\n                                            # Have fun Working on Perl\n\nWith a customer filter too:\n\n    say \"have fun working on perl\".wordcase(:filter(&uc), :where({ .chars > 3 }));\n                                            # HAVE fun WORKING on PERL","n":"wordcase"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"uniname","d":"Defined as:\n\n    sub uniname(Str(Cool) --> Str)\n    method uniname(--> Str)\n\nInterprets the invocant or first argument as a Str, and returns the Unicode\ncodepoint name of the first codepoint of the first character. See uninames\nfor a routine that works with multiple codepoints, and uniparse for the\nopposite direction.\n\n    # Camelia in Unicode\n    say ‘»ö«’.uniname;\n    # OUTPUT: «\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\"␤»\n    say \"Ḍ̇\".uniname; # Note, doesn't show \"COMBINING DOT ABOVE\"\n    # OUTPUT: «\"LATIN CAPITAL LETTER D WITH DOT BELOW\"␤»\n\n    # Find the char with the longest Unicode name.\n    say (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;\n    # OUTPUT: ««ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM␤»␤»"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"uninames","d":"Defined as:\n\n    sub uninames(Str:D)\n    method uninames()\n\nReturns of a Seq of Unicode names for the all the codepoints in the Str\nprovided.\n\n    say ‘»ö«’.uninames.perl;\n    # OUTPUT: «(\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\", \"LATIN SMALL LETTER O WITH DIAERESIS\", \"LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\").Seq␤»\n\nNote this example, which gets a Seq where each element is a Seq of all the\ncodepoints in that character.\n\n    say \"Ḍ̇'oh\".comb>>.uninames.perl;\n    # OUTPUT: «((\"LATIN CAPITAL LETTER D WITH DOT BELOW\", \"COMBINING DOT ABOVE\").Seq, (\"APOSTROPHE\",).Seq, (\"LATIN SMALL LETTER O\",).Seq, (\"LATIN SMALL LETTER H\",).Seq)␤»\n\nSee uniparse for the opposite direction."},{"n":"unival","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"univals"},{"d":"Defined as:\n\n    multi sub uniprop(Str:D, |c)\n    multi sub uniprop(Int:D $code)\n    multi sub uniprop(Int:D $code, Stringy:D $propname)\n    multi method uniprop(|c)\n\nReturns the unicode property of the first character. If no property is\nspecified returns the General Category. Returns a Bool for Boolean\nproperties. A uniprops routine can be used to get the property for every\ncharacter in a string.\n\n    say 'a'.uniprop;               # OUTPUT: «Ll␤»\n    say '1'.uniprop;               # OUTPUT: «Nd␤»\n    say 'a'.uniprop('Alphabetic'); # OUTPUT: «True␤»\n    say '1'.uniprop('Alphabetic'); # OUTPUT: «False␤»\n\n  sub uniprops\n\nDefined as:\n\n    sub uniprops(Str:D $str, Stringy:D $propname = \"General_Category\")\n\nInterprets the invocant as a Str, and returns the unicode property for each\ncharacter as a Seq. If no property is specified returns the General\nCategory. Returns a Bool for Boolean properties. Similar to uniprop, but\nfor each character in the passed string.","n":"uniprop","m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]}},{"s":{"r":"Mu","p":["|c is raw"]},"m":0,"k":"m","n":"uniprop-int"},{"n":"uniprop-bool","s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["|c is raw"]},"m":0,"k":"m","n":"uniprop-str"},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"n":"uniprops"},{"k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    multi sub unimatch(Str:D $str, |c)\n    multi unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)\n\nChecks if the given integer codepoint or the first letter of the string\ngiven have a unicode property equal to the value you give. If you supply\nthe Unicode property to be checked it will only return True if that\nproperty matches the given value.\n\n    say unimatch 'A', 'Latin';           # OUTPUT: «True␤»\n    say unimatch 'A', 'Latin', 'Script'; # OUTPUT: «True␤»\n    say unimatch 'A', 'Ll';              # OUTPUT: «True␤»","n":"unimatch"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub chomp(Str(Cool))\n    method chomp()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\nwith the last character removed, if it is a logical newline.\n\n    say 'ab'.chomp.chars;                   # OUTPUT: «2␤»\n    say \"a\\n\".chomp.chars;                  # OUTPUT: «1␤»","n":"chomp"},{"n":"chop","d":"Defined as:\n\n    sub chop(Str(Cool))\n    method chop()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\nwith the last character removed.\n\n    say 'perl'.chop;                        # OUTPUT: «per␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"n":"chop","d":"Defined as:\n\n    sub chop(Str(Cool))\n    method chop()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns it\nwith the last character removed.\n\n    say 'perl'.chop;                        # OUTPUT: «per␤»","s":{"r":"Mu","p":["$n","*%_"]},"k":"m","m":1},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Int:D"},"d":"Defined as:\n\n    sub ord(Str(Cool))\n    method ord()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nUnicode code point number of the first code point.\n\n    say 'a'.ord;            # OUTPUT: «97␤»\n\nThe inverse operation is chr.\n\nMnemonic: returns an ordinal number","n":"ord"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"chr","d":"Defined as:\n\n    sub chr(Int(Cool))\n    method chr()\n\nCoerces the invocant (or in sub form, its argument) to Int, interprets it\nas a Unicode code points, and returns a string made of that code point.\n\n    say '65'.chr;       # OUTPUT: «A␤»\n\nThe inverse operation is ord.\n\nMnemonic: turns an integer into a character."},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub chrs(*@codepoints --> Str:D)\n    method chrs()\n\nCoerces the invocant (or in the sub form, the argument list) to a list of\nintegers, and returns the string created by interpreting each integer as a\nUnicode codepoint, and joining the characters.\n\n    say <67 97 109 101 108 105 97>.chrs;   # OUTPUT: «Camelia␤»\n\nThis is the list-input version of chr. The inverse operation is ords.","n":"chrs"},{"d":"Defined as:\n\n    sub ords(Str(Cool) $str)\n    method ords()\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\nreturns a list of Unicode codepoints for each character.\n\n    say \"Camelia\".ords;              # OUTPUT: «67 97 109 101 108 105 97␤»\n    say ords 10;                     # OUTPUT: «49 48␤»\n\nThis is the list-returning version of ord. The inverse operation in chrs.\nIf you are only interested in the number of codepoints, codes is a possibly\nfaster option.","n":"ords","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"flip","d":"Defined as:\n\n    sub flip(Cool $s --> Str:D)\n    method flip()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns a\nreversed version.\n\n    say 421.flip;       # OUTPUT: «124␤»"},{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"d":"Defined as:\n\n    method trans(|)\n\nCoerces the invocant to Str and calls Str.trans","n":"trans"},{"n":"starts-with","s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0},{"n":"ends-with","s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"n":"substr","d":"Defined as:\n\n    sub substr(Str(Cool) $str, |c)\n    method substr(|c)\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\ncalls Str.substr with the arguments.","s":{"p":["\\from","*%_"],"r":"Mu"},"m":1,"k":"m"},{"s":{"p":["\\from","\\chars","*%_"],"r":"Mu"},"k":"m","m":1,"n":"substr","d":"Defined as:\n\n    sub substr(Str(Cool) $str, |c)\n    method substr(|c)\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\ncalls Str.substr with the arguments."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"substr-rw","d":"Defined as:\n\n    multi method substr-rw(|) is rw\n    multi sub substr-rw(|) is rw\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\ncalls Str.substr-rw with the arguments."},{"n":"substr-rw","d":"Defined as:\n\n    multi method substr-rw(|) is rw\n    multi sub substr-rw(|) is rw\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\ncalls Str.substr-rw with the arguments.","s":{"p":["\\from","*%_"],"r":"Mu"},"k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":["\\from","\\chars","*%_"]},"d":"Defined as:\n\n    multi method substr-rw(|) is rw\n    multi sub substr-rw(|) is rw\n\nCoerces the invocant (or in the sub form, the first argument) to Str, and\ncalls Str.substr-rw with the arguments.","n":"substr-rw"},{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"n":"substr-eq"},{"d":"Defined as:\n\n    method contains(Cool:D: |c)\n\nCoerces the invocant Str, and calls Str.contains on it. Please refer to\nthat version of the method for arguments and general syntax.\n\n    say 123.contains(\"2\")# OUTPUT: «True␤»\n\nSince Int is a subclass of Cool, 123 is coerced to a Str and then contains\nis called on it.\n\n    say (1,1, * + * … * > 250).contains(233)# OUTPUT: «True␤»\n\nSeqs are also subclasses of Cool, and they are stringified to a\ncomma-separated form. In this case we are also using an Int, which is going\nto be stringified also; \"233\" is included in that sequence, so it returns\nTrue. Please note that this sequence is not lazy; the stringification of\nlazy sequences does not include each and every one of their components for\nobvious reasons.","n":"contains","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]},"n":"indices"},{"d":"Defined as:\n\n    multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\n    method    index(Cool:D: |c)\n\nCoerces the first two arguments (in method form, also counting the\ninvocant) to a Str, and searches for $needle in the string $s starting from\n$startpos. It returns the offset into the string where $needle was found,\nand an undefined value if it was not found.\n\nSee the documentation in type Str for examples.","n":"index","m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]},"d":"Defined as:\n\n    multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\n    multi method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\n\nCoerces the first two arguments (including the invocant in method form) to\nStr and $startpos to Int, and returns the last position of $needle in\n$haystack not after $startpos. Returns an undefined value if $needle wasn't\nfound.\n\nSee the documentation in type Str for examples.","n":"rindex"},{"n":"split","d":"Defined as:\n\n    multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n    multi sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n    multi sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n    multi method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n    multi method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n    multi method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\n\nthe comb routine is a much better choice for many tasks that in other\nlanguages are handled by the split.\n\nCoerces the invocant (or in the sub form, the second argument) to Str, and\nsplits it into pieces based on delimiters found in the string.\n\nIf $delimiter is a string, it is searched for literally and not treated as\na regex. You can also provide multiple delimiters by specifying them as a\nlist; mixing Cool and Regex objects is OK.\n\n    say split(';', \"a;b;c\").perl;               # OUTPUT: «(\"a\", \"b\", \"c\")␤»\n    say split(';', \"a;b;c\", 2).perl;            # OUTPUT: «(\"a\", \"b;c\").Seq␤»\n\n    say split(';', \"a;b;c,d\").perl;             # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\n    say split(/\\;/, \"a;b;c,d\").perl;            # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\n    say split(/<[;,]>/, \"a;b;c,d\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\", \"d\")␤»\n\n    say split(['a', /b+/, 4], '1a2bb345').perl; # OUTPUT: «(\"1\", \"2\", \"3\", \"5\")␤»\n\nBy default, split omits the matches, and returns a list of only those parts\nof the string that did not match. Specifying one of the :k, :v, :kv, :p\nadverbs changes that. Think of the matches as a list that is interleaved\nwith the non-matching parts.\n\nThe :v interleaves the values of that list, which will be either Match\nobjects, if a Regex was used as a matcher in the split, or Str objects, if\na Cool was used as matcher. If multiple delimiters are specified, Match\nobjects will be generated for all of them, unless all of the delimiters are\nCool.\n\n    say 'abc'.split(/b/, :v);               # OUTPUT: «(a ｢b｣ c)␤»\n    say 'abc'.split('b', :v);               # OUTPUT: «(a b c)␤»\n\n:k interleaves the keys, that is, the indexes:\n\n    say 'abc'.split(/b/, :k);               # OUTPUT: «(a 0 c)␤»\n\n:kv adds both indexes and matches:\n\n    say 'abc'.split(/b/, :kv);               # OUTPUT: «(a 0 ｢b｣ c)␤»\n\nand :p adds them as Pairs, using the same types for values as :v does:\n\n    say 'abc'.split(/b/, :p);               # OUTPUT: «(a 0 => ｢b｣ c)␤»\n    say 'abc'.split('b', :p);               # OUTPUT: «(a 0 => b c)␤»\n\nYou can only use one of the :k, :v, :kv, :p adverbs in a single call to\nsplit.\n\nNote that empty chunks are not removed from the result list. For that\nbehavior, use the :skip-empty named argument:\n\n    say (\"f,,b,c,d\".split: /\",\"/             ).perl;  # OUTPUT: «(\"f\", \"\", \"b\", \"c\", \"d\")␤»\n    say (\"f,,b,c,d\".split: /\",\"/, :skip-empty).perl;  # OUTPUT: «(\"f\", \"b\", \"c\", \"d\")␤»","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    method match(|)\n\nCoerces the invocant to Stringy and calls Str.match.","n":"match"},{"k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    multi sub comb(Regex $matcher, Cool $input, $limit = *)\n    multi sub comb(Str $matcher, Cool $input, $limit = *)\n    multi sub comb(Int:D $size, Cool $input, $limit = *)\n    multi method comb(|c)\n\nReturns a Seq of all (or if supplied, at most $limit) matches of the\ninvocant (method form) or the second argument (sub form) against the Regex,\nstring or defined number.\n\n    say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\n    say comb(/\\d <[1..9]> /,(11..30)).join(\"--\");\n    # OUTPUT:\n    # «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»\n\nThe second statement exemplifies the first form of comb, with a Regex that\nexcludes multiples of ten, and a Range (which is Cool) as $input. comb\nstringifies the Range before applying .comb on the resulting string. Check\nStr.comb for its effect on different kind of input strings. When the first\nargument is an integer, it indicates the (maximum) size of the chunks the\ninput is going to be divided in\n\n    say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»\n\nIn this case the input is a list, which after transformation to Str (which\nincludes the spaces) is divided in chunks of size 3.","n":"comb"},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    sub lines(Str(Cool))\n    method lines()\n\nCoerces the invocant (and in sub form, the argument) to Str, decomposes it\ninto lines (with the newline characters stripped), and returns the list of\nlines.\n\n    say lines(\"a\\nb\\n\").join('|');          # OUTPUT: «a|b␤»\n    say \"some\\nmore\\nlines\".lines.elems;    # OUTPUT: «3␤»\n\nThis method can be used as part of an IO::Path to process a file\nline-by-line, since IO::Path objects inherit from Cool, e.g.:\n\n    for 'huge-csv'.IO.lines -> $line {\n        # Do something with $line\n    }\n\n    # or if you'll be processing later\n    my @lines = 'huge-csv'.IO.lines;\n\n\nWithout any arguments, sub lines operates on $*ARGFILES, which defaults to\n$*IN in the absence of any filenames.\n\nTo modify values in place use is copy to force a writable container.\n\n    for $*IN.lines -> $_ is copy { s/(\\w+)/{$0 ~ $0}/; .say }","n":"lines"},{"n":"words","d":"Defined as:\n\n    method words(Cool:D: |c)\n\nCoerces the invocant (or first argument, if it is called as a subroutine)\nto Str, and returns a list of words that make up the string. Check\nStr.words for additional arguments and its meaning.\n\n    say <The quick brown fox>.words.join('|');     # OUTPUT: «The|quick|brown|fox␤»\n    say <The quick brown fox>.words(2).join('|');  # OUTPUT: «The|quick␤»\n\n\nCool is the base class for many other classes, and some of them, like\nMatch, can be converted to a string. This is what happens in this case:\n\n    say ( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/).words(Inf);\n    # OUTPUT: «(easy easy)␤»\n    say words( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/ , ∞);\n    # OUTPUT: «(easy easy)␤»\n\nThe example above illustrates two of the ways words can be invoked, with\nthe first argument turned into invocant by its signature. Of course, Inf is\nthe default value of the second argument, so in both cases (and forms) it\ncan be simply omitted.\n\nOnly whitespace (including no-break space) counts as word boundaries\n\n    say <Don't we ♥ Raku>.words.join('|');  # OUTPUT: «Don't|we|♥|Perl|6␤»\n\nIn this case, Raku includes an (visible only in the source) no-break space;\nwords still splits the (resulting) Str on it, even if the original array\nonly had 4 elements:\n\n    say <Don't we ♥ Raku>.join(\"|\");  # OUTPUT: «Don't|we|♥|Raku␤»\n\nPlease see Str.words for more examples and ways to invoke it.","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0,"n":"subst","d":"Defined as:\n\n    method subst(|)\n\nCoerces the invocant to Stringy and calls Str.subst."},{"s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0,"n":"subst-mutate"},{"d":"Defined as:\n\n    method IO(--> IO::Path:D)\n\nCoerces the invocant to IO::Path.\n\n    .say for '.'.IO.dir;        # gives a directory listing","n":"IO","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    method IO(--> IO::Path:D)\n\nCoerces the invocant to IO::Path.\n\n    .say for '.'.IO.dir;        # gives a directory listing","n":"IO","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*@args","*%_"],"r":"Mu"},"n":"sprintf"},{"n":"printf","s":{"p":["*@args","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    sub samecase(Cool $string, Cool $pattern)\n    method samecase(Cool:D: Cool $pattern)\n\nCoerces the invocant (or in sub form, the first argument) to Str, and\nreturns a copy of $string with case information for each individual\ncharacter changed according to $pattern.\n\nNote: The pattern string can contain three types of characters, i.e.\nuppercase, lowercase and caseless. For a given character in $pattern its\ncase information determines the case of the corresponding character in the\nresult.\n\nIf $string is longer than $pattern, the case information from the last\ncharacter of $pattern is applied to the remaining characters of $string.\n\n    say \"perL 6\".samecase(\"A__a__\"); # OUTPUT: «Raku␤»\n    say \"pERL 6\".samecase(\"Ab\");     # OUTPUT: «Raku␤»","n":"samecase","k":"m","m":0,"s":{"r":"Mu","p":["Cool $pattern","*%_"]}},{"d":"Defined as:\n\n    method path()\n\nDEPRECATED. It's been deprecated as of the 6.d version. Will be removed in\nthe next ones.\n\nStringifies the invocant and converts it to IO::Path object. Use the .IO\nmethod instead.","n":"path","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    sub trim(Str(Cool))\n    method trim()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nstring with both leading and trailing whitespace stripped.\n\n    my $stripped = '  abc '.trim;\n    say \"<$stripped>\";          # OUTPUT: «<abc>␤»","n":"trim","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"trim-leading","d":"Defined as:\n\n    sub trim-leading(Str(Cool))\n    method trim-leading()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nstring with leading whitespace stripped.\n\n    my $stripped = '  abc '.trim-leading;\n    say \"<$stripped>\";          # OUTPUT: «<abc >␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"trim-trailing","d":"Defined as:\n\n    sub trim-trailing(Str(Cool))\n    method trim-trailing()\n\nCoerces the invocant (or in sub form, its argument) to Str, and returns the\nstring with trailing whitespace stripped.\n\n    my $stripped = '  abc '.trim-trailing;\n    say \"<$stripped>\";          # OUTPUT: «<  abc>␤»"},{"n":"EVAL","d":"Defined as:\n\n    method EVAL(*%_)\n\n\nIt calls the subroutine form with the invocant as the first argument,\n$code, passing along named args, if any.","s":{"r":"Mu","p":["*%opts"]},"m":0,"k":"m"},{"n":"Int","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"n":"UInt"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"Num"},{"n":"Rat","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"FatRat","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"Complex","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"k":"c","n":"Cool","d":"TITLE\nclass Cool\n\nSUBTITLE\nObject that can be treated as both a string and number\n\n    class Cool is Any { }\n\nCool, also known as the Convenient OO Loop, is a base class employed by a\nnumber of built-in classes whose instances can be meaningfully coerced to a\nstring and a number. For example, an Array can be used in mathematical\noperations, where its numerical representation is the number of elements it\ncontains. At the same time, it can be concatenated to a string, where its\nstringy representation is all of its elements joined by a space. Because\nArray is Cool, the appropriate coercion happens automatically.\n\nMethods in Cool coerce the invocant to a more specific type, and then call\nthe same method on that type. For example both Int and Str inherit from\nCool, and calling method substr on an Int converts the integer to Str\nfirst.\n\n    123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)\n\nThe following built-in types inherit from Cool: Array Bool Complex Cool\nDuration Map FatRat Hash Instant Int List Match Nil Num Range Seq Stash\nStr.\n\nThe following table summarizes the methods that Cool provides, and what\ntype they coerce to:\n\n  method         coercion type\n  abs            Numeric\n  conj           Numeric\n  sqrt           Numeric\n  sign           Real\n  rand           Numeric\n  sin            Numeric\n  asin           Numeric\n  cos            Numeric\n  acos           Numeric\n  tan            Numeric\n  tanh           Numeric\n  atan           Numeric\n  atan2          Numeric\n  atanh          Numeric\n  sec            Numeric\n  asec           Numeric\n  cosec          Numeric\n  acosec         Numeric\n  cotan          Numeric\n  cotanh         Numeric\n  acotan         Numeric\n  sinh           Numeric\n  asinh          Numeric\n  cosh           Numeric\n  acosh          Numeric\n  sech           Numeric\n  asech          Numeric\n  cosech         Numeric\n  acosech        Numeric\n  acotanh        Numeric\n  cis            Numeric\n  log            Numeric\n  exp            Numeric\n  roots          Numeric\n  log10          Numeric\n  unpolar        Numeric\n  round          Numeric\n  floor          Numeric\n  ceiling        Numeric\n  truncate       Numeric\n  chr            Int\n  ord            Str\n  chars          Str\n  fmt            Str\n  uniname        Str\n  uninames       Seq\n  unival         Str\n  univals        Str\n  uniprop        Str\n  unimatch       Str\n  uc             Str\n  lc             Str\n  fc             Str\n  tc             Str\n  tclc           Str\n  flip           Str\n  trans          Str\n  contains       Str\n  index          Str\n  rindex         Str\n  ords           Str\n  split          Str\n  match          Str\n  comb           Str\n  subst          Str\n  sprintf        Str\n  printf         Str\n  samecase       Str\n  trim           Str\n  trim-leading   Str\n  trim-trailing  Str\n  EVAL           Str\n  chomp          Str\n  chop           Str\n  codes          Str\n\n\n","t":"Cool","b":"C"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<gt>"},{"n":"infix:<gt>","s":{"r":"Mu","p":["$x?"]},"k":"s","m":1},{"s":{"r":"Mu","p":["\\a","\\b"]},"k":"s","m":1,"n":"infix:<gt>"},{"n":"infix:<gt>","s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"k":"s","m":1},{"n":"infix:<gt>","s":{"p":["Str:D \\a","Str:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<gt>","s":{"r":"Bool:D","p":["str $a","str $b"]},"k":"s","m":1},{"k":"e","t":"SocketType","n":"SOCK_PACKET"},{"n":"&atomic-fetch","t":"Sub","k":"v"},{"n":"atomic-fetch","s":{"p":["$source is rw"],"r":"Mu"},"m":1,"k":"s"},{"n":"atomic-fetch","k":"s","m":1,"s":{"r":"Mu","p":["atomicint $source is rw"]}},{"k":"v","n":"&is-prime","t":"Sub+{is-pure}"},{"n":"is-prime","s":{"p":["\\x"],"r":"Int:D"},"m":1,"k":"s"},{"mro":["ObjAt"],"k":"c","n":"ValueObjAt","d":"TITLE\nclass ValueObjAt\n\nSUBTITLE\nUnique identification for value types\n\n    class ValueObjAt is ObjAt { }\n\nA subclass of ObjAt that should be used to indicate that a class produces\nobjects that are value types (in other words: are immutable after they have\nbeen initialized.\n\n    my %h = a => 42;        # mutable Hash\n    say %h.WHICH;           # OUTPUT: «ObjAt.new(\"Hash|1402...888\")␤»\n\n    my %m is Map = a => 42; # immutable Map\n    say %m.WHICH;           # OUTPUT: «ValueObjAt.new(\"Map|AAF...09F61F\")␤»\n\nIf you create a class that should be considered a value type, you should\nadd a WHICH method to that class that returns a ValueObjAt object, for\ninstance:\n\n    class YourClass {\n        has $.foo;  # note these are not mutable\n        has $.bar;\n\n        method WHICH() {\n            ValueObjAt.new(\"YourClass|$!foo|$!bar\");\n        }\n    }\n\nNote that it is customary to always start the identifying string with the\nname of the object, followed by a \"|\". This to prevent confusion with other\nclasses that may generate similar string values: the name of the class\nshould then be enough of a differentiator to prevent collisions.","t":"ValueObjAt","b":"A"},{"k":"e","n":"Kept","t":"PromiseStatus"},{"t":"Sub+{Callable[Complex:D]}+{is-pure}+{Precedence}","n":"&postfix:<i>","k":"v"},{"n":"postfix:<i>","k":"s","m":1,"s":{"p":["Real \\a"],"r":"Complex:D"}},{"n":"postfix:<i>","m":1,"k":"s","s":{"p":["Complex:D \\a"],"r":"Complex:D"}},{"s":{"r":"Complex:D","p":["Numeric \\a"]},"m":1,"k":"s","n":"postfix:<i>"},{"s":{"p":["Cool \\a"],"r":"Complex:D"},"k":"s","m":1,"n":"postfix:<i>"},{"t":"Sub","n":"&deepmap","k":"v"},{"n":"deepmap","s":{"p":["\\op","\\obj"],"r":"Mu"},"k":"s","m":1},{"n":"deepmap","k":"s","m":1,"s":{"r":"Mu","p":["\\op","Associative \\h"]}},{"k":"v","t":"Sub","n":"&grep"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu $test","+\\values is raw","*%a"]},"n":"grep"},{"n":"grep","s":{"p":["Bool:D $t","|"],"r":"Mu"},"k":"s","m":1},{"b":"C","k":"c","m":[{"n":"new","s":{"r":"Int:D","p":["\\value","*%_"]},"k":"m","m":1},{"s":{"p":["int \\value","*%_"],"r":"Int:D"},"k":"m","m":1,"n":"new"},{"n":"new","s":{"p":["Int:D \\value = 0","*%_"],"r":"Int:D"},"m":1,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Capture","d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture."},{"n":"Int","s":{"r":"Int","p":["*%_"]},"k":"m","m":0},{"n":"Num","s":{"r":"Num:D","p":["*%_"]},"k":"m","m":0},{"n":"Rat","m":0,"k":"m","s":{"r":"Rat:D","p":["$?","*%_"]}},{"k":"m","m":0,"s":{"r":"FatRat:D","p":["$?","*%_"]},"n":"FatRat"},{"s":{"r":"Int:D","p":["*%_"]},"k":"m","m":0,"n":"abs"},{"n":"Bridge","m":0,"k":"m","s":{"r":"Num:D","p":["*%_"]}},{"s":{"r":"Str:D","p":["*%_"]},"m":0,"k":"m","n":"chr","d":"Defined as:\n\n    multi sub    chr(Int:D  --> Str:D)\n    multi method chr(Int:D: --> Str:D)\n\nReturns a one-character string, by interpreting the integer as a Unicode\ncodepoint number and converting it to the corresponding character.\n\nExample:\n\n    65.chr;  # returns \"A\"\n    196.chr; # returns \"Ä\""},{"n":"sqrt","k":"m","m":0,"s":{"p":["*%_"],"r":"Num:D"}},{"n":"base","m":1,"k":"m","s":{"p":["Int:D $base","*%_"],"r":"Str:D"}},{"s":{"r":"Str:D","p":["Int(Cool) $base","$digits?","*%_"]},"k":"m","m":1,"n":"base"},{"n":"polymod","d":"Defined as:\n\n    method polymod(Int:D: +@mods)\n\nReturns a sequence of mod results corresponding to the divisors in @mods in\nthe same order as they appear there. For the best effect, the divisors\nshould be given from the smallest \"unit\" to the largest (e.g. 60 seconds\nper minute, 60 minutes per hour) and the results are returned in the same\nway: from smallest to the largest (5 seconds, 4 minutes). The last non-zero\nvalue will be the last remainder.\n\n    say 120.polymod(10);    # OUTPUT: «(0 12)␤»\n    say 120.polymod(10,10); # OUTPUT: «(0 2 1)␤»\n\nIn the first case, 120 is divided by 10 giving as a remainder 12, which is\nthe last element. In the second, 120 is divided by 10, giving 12, whose\nremainder once divided by 10 is 2; the result of the integer division of 12\ndiv 10 is the last remainder. The number of remainders will be always one\nmore item than the number of given divisors. If the divisors are given as a\nlazy list, runs until the remainder is 0 or the list of divisors is\nexhausted. All divisors must be Ints, unless the method is called on a\nnon-Int number.\n\n    my $seconds = 1 * 60*60*24 # days\n                + 3 * 60*60    # hours\n                + 4 * 60       # minutes\n                + 5;           # seconds\n\n    say $seconds.polymod(60, 60);                # OUTPUT: «(5 4 27)␤»\n    say $seconds.polymod(60, 60, 24);            # OUTPUT: «(5 4 3 1)␤»\n\n    say 120.polymod:      1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12 0 0 0)␤»\n    say 120.polymod: lazy 1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12)␤»\n    say 120.polymod:      1, 10, 10² … ∞;        # OUTPUT: «(0 0 12)␤»\n\n    say ⅔.polymod(⅓);                            # OUTPUT: «(0 2)␤»\n    say 5.Rat.polymod(.3, .2);                   # OUTPUT: «(0.2 0 80)␤»\n\n    my @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion\n    say @digits-in-base37.reverse                    # OUTPUT: «[4 32 4 15 36]␤»\n\nTo illustrate how the Int, non-lazy version of polymod works, consider this\ncode that implements it:\n\n    my $seconds = 2 * 60*60*24 # days\n                + 3 * 60*60    # hours\n                + 4 * 60       # minutes\n                + 5;           # seconds\n\n    my @pieces;\n    for 60, 60, 24 -> $divisor {\n        @pieces.push: $seconds mod $divisor;\n        $seconds div= $divisor\n    }\n    @pieces.push: $seconds;\n\n    say @pieces; # OUTPUT: «[5 4 3 2]␤»\n\nFor a more detailed discussion, see this blog post","s":{"p":["+@mods","*%_"],"r":"Seq:D"},"m":0,"k":"m"},{"d":"Defined as:\n\n    multi sub    expmod(      $x,     $y,     $mod --> Int:D)\n    multi sub    expmod(Int:D $x, Int $y, Int $mod --> Int:D)\n    multi method expmod(Int:D:    Int $y, Int $mod --> Int:D)\n\nReturns the given Int raised to the $y power within modulus $mod, that is\ngives the result of ($x ** $y) mod $mod. The subroutine form can accept\nnon-Int arguments, which will be coerced to Int.\n\n    say expmod(4, 2, 5);    # OUTPUT: «1␤»\n    say 7.expmod(2, 5);     # OUTPUT: «4␤»\n\n$y argument can also be negative, in which case, the result is equivalent\nto ($x ** $y) mod $mod.\n\n    say 7.expmod(-2, 5);     # OUTPUT: «4␤»","n":"expmod","m":0,"k":"m","s":{"r":"Int:D","p":["Int:D \\base","Int:D \\mod","*%_"]}},{"s":{"p":["*%_"],"r":"Bool:D"},"k":"m","m":0,"n":"is-prime","d":"Defined as:\n\n    multi sub    is-prime (Int:D $number --> Bool:D)\n    multi method is-prime (Int:D: --> Bool:D)\n\nReturns True if this Int is known to be a prime, or is likely to be a prime\nbased on a probabilistic Miller-Rabin test.\n\nReturns False if this Int is known not to be a prime.\n\n    say 2.is-prime;         # OUTPUT: «True␤»\n    say is-prime(9);        # OUTPUT: «False␤»"},{"n":"floor","m":0,"k":"m","s":{"r":"Int:D","p":["*%_"]}},{"n":"ceiling","k":"m","m":0,"s":{"p":["*%_"],"r":"Int:D"}},{"n":"round","m":1,"k":"m","s":{"r":"Int:D","p":["*%_"]}},{"n":"round","s":{"r":"Real:D","p":["Real(Cool) $scale","*%_"]},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"round"},{"n":"round","s":{"p":["$scale","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"lsb","d":"Defined as:\n\n    multi method lsb(Int:D:)\n    multi sub    lsb(Int:D)\n\nShort for \"Least Significant Bit\". Returns Nil if the number is 0.\nOtherwise returns the zero-based index from the right of the least\nsignificant (rightmost) 1 in the binary representation of the number.\n\n    say 0b01011.lsb;        # OUTPUT: «0␤»\n    say 0b01010.lsb;        # OUTPUT: «1␤»\n    say 0b10100.lsb;        # OUTPUT: «2␤»\n    say 0b01000.lsb;        # OUTPUT: «3␤»\n    say 0b10000.lsb;        # OUTPUT: «4␤»","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m","n":"msb","d":"Defined as:\n\n    multi method msb(Int:D:)\n    multi sub    msb(Int:D)\n\nShort for \"Most Significant Bit\". Returns Nil if the number is 0. Otherwise\nreturns the zero-based index from the right of the most significant\n(leftmost) 1 in the binary representation of the number.\n\n    say 0b00001.msb;        # OUTPUT: «0␤»\n    say 0b00011.msb;        # OUTPUT: «1␤»\n    say 0b00101.msb;        # OUTPUT: «2␤»\n    say 0b01010.msb;        # OUTPUT: «3␤»\n    say 0b10011.msb;        # OUTPUT: «4␤»"},{"n":"narrow","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Range:D"},"m":0,"k":"m","n":"Range","d":"Returns a Range object that represents the range of values supported."},{"n":"unival","d":"Defined as:\n\n    multi sub    unival(Int:D  --> Numeric)\n    multi method unival(Int:D: --> Numeric)\n\nReturns the number represented by the Unicode codepoint with the given\ninteger number, or NaN if it does not represent a number.\n\n    say ord(\"¾\").unival;    # OUTPUT: «0.75␤»\n    say 190.unival;         # OUTPUT: «0.75␤»\n    say unival(65);         # OUTPUT: «NaN␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"mro":["Real","Numeric","Cool"],"t":"Int","d":"TITLE\nclass Int\n\nSUBTITLE\nInteger (arbitrary-precision)\n\n    class Int is Cool does Real { }\n\n\nInt objects store integral numbers of arbitrary size. Ints are immutable.\n\nThere are two main syntax forms for Int literals\n\n    123;         # Int in decimal notation\n    :16<BEEF>;   # Int in radix notations\n\nFor your convenience common radix forms come with a prefix shortcut.\n\n    say so :2<11111111> == 0b11111111 == :8<377> == 0o377 == 255 == 0d255 == :16<ff> == 0xff;\n    # OUTPUT: «True␤»\n\nAll forms allow underscores between any two digits which can serve as\nvisual separators, but don't carry any meaning:\n\n    5_00000;       # five Lakhs\n    500_000;       # five hundred thousand\n    0xBEEF_CAFE;   # a strange place\n    :2<1010_1010>; # 0d170\n\nRadix notation also supports round and angle brackets which allow you to\nparse a string for a given base, and putting together digits into a whole\nnumber respectively:\n\n    :16(\"9F\");         # 159\n    :100[99, 2, 3];    # 990203\n\nThese notations allow you to use variables, too:\n\n    my $two = \"2\";\n    my $ninety-nine = \"99\";\n    :16($ninety-nine); # 153\n    :100[99, $two, 3]; # 990203\n\n","n":"Int"},{"d":"TITLE\nclass Instant\n\nSUBTITLE\nSpecific moment in time\n\n    class Instant is Cool does Real { }\n\nAn Instant is a particular moment in time measured in atomic seconds, with\nfractions. It is not tied to or aware of any epoch.\n\nAn Instant can be used to create a DateTime object set to that Instant. The\npseudo-constant now returns the current time as an Instant.\n\nBasic math is defined for Instants (as well as Durations). Adding an\nInstant to a Duration returns another Instant. Subtracting two Instants\nwill yield a Duration. Adding two Instants is explicitly disallowed. All\nother operations with Instants are undefined.\n\nFuture Leap Seconds\n\nThe methods that involve knowledge of leap seconds always assume that there\nwill be no further leaps after the last leap second that the implementation\nknows about, which may not be the last leap second that has actually been\nscheduled. This means you can get different results, depending on the\ncompiler version you're using. For example, the December 31, 2016 leap\nsecond was announced in July and shipped with Rakudo 2016.07, so 2016.06\nand earlier releases won't know about it:\n\n    $ perl6-2016.06 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726631\n\n    $ perl6-2016.07 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\nSince a Rakudo compiler always returns 0 for future leap seconds it doesn't\nknow about, you can patch your old code when new leap seconds are\nannounced, so it will give correct results, regardless of what version of\nthe compiler it runs on:\n\n    $ perl6-2016.06 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n    $ perl6-2016.07 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\n","a":[{"k":"v","n":"$.tai","t":"Rat"}],"t":"Instant","n":"Instant","m":[{"s":{"p":["\\tai","*%_"],"r":"Mu"},"k":"m","m":0,"n":"SET-SELF"},{"n":"new","m":0,"k":"m","s":{"r":"Mu","p":["*@","*%_"]}},{"m":1,"k":"m","s":{"r":"Instant:D","p":["$posix","*%_"]},"d":"method from-posix($posix, Bool $prefer-leap-second = False)\n\nConverts the POSIX timestamp $posix to an Instant. If $prefer-leap-second\nis True, the return value will be the first of the two possible seconds in\nthe case of a leap second.\n\n    say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\n    say DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»","n":"from-posix"},{"d":"method from-posix($posix, Bool $prefer-leap-second = False)\n\nConverts the POSIX timestamp $posix to an Instant. If $prefer-leap-second\nis True, the return value will be the first of the two possible seconds in\nthe case of a leap second.\n\n    say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\n    say DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»","n":"from-posix","k":"m","m":1,"s":{"p":["$posix","Bool $prefer-leap-second","*%_"],"r":"Instant:D"}},{"n":"to-posix","d":"method to-posix()\n\nConverts the invocant to a POSIX timestamp and returns a two element list\ncontaining the POSIX timestamp and a Bool. It is the inverse of #method\nfrom-posix, except that the second return value is True if *and only if*\nthis Instant is in a leap second.\n\n    say DateTime.new(\"1999-01-01T00:00:00Z\").Instant.to-posix; # OUTPUT: «(915148800 False)␤»\n    say DateTime.new('1998-12-31T23:59:60Z').Instant.to-posix; # OUTPUT: «(915148800 True)␤»","s":{"r":"List:D","p":["*%_"]},"k":"m","m":0},{"n":"Bridge","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"Num","k":"m","m":0,"s":{"r":"Num:D","p":["*%_"]}},{"n":"Rat","k":"m","m":0,"s":{"p":["*%_"],"r":"Rat:D"}},{"s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m","n":"Int"},{"n":"narrow","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Date:D"},"k":"m","m":0,"n":"Date","d":"Defined as:\n\n    method Date(Instant:D: --> Date:D)\n\nCoerces the invocant to Date.\n\n    my $i = \"/etc/passwd\".IO.modified;\n    say $i;             # OUTPUT: «Instant:1451489025.878018␤»\n    say $i.Date;        # OUTPUT: «2015-12-30␤»"},{"d":"Defined as:\n\n    method DateTime(Instant:D: --> DateTime:D)\n\nCoerces the invocant to DateTime.\n\n    say now.DateTime;  # OUTPUT: «2017-05-09T14:02:58.147165Z␤»","n":"DateTime","m":0,"k":"m","s":{"p":["*%_"],"r":"DateTime:D"}},{"n":"Instant","s":{"p":["*%_"],"r":"Instant"},"m":0,"k":"m"},{"n":"tai","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["Real","Numeric","Cool"],"b":"C"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<∪>"},{"s":{"p":[],"r":"Mu"},"m":1,"k":"s","n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"p":["QuantHash:D \\a"],"r":"Mu"}},{"s":{"p":["\\a"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]}},{"s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"m":1,"k":"s","n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Baggy:D \\b"]}},{"n":"infix:<(|)>","s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Mu"},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Mu"}},{"n":"infix:<(|)>","k":"s","m":1,"s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"}},{"n":"infix:<(|)>","m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a","Setty:D \\b"]},"n":"infix:<(|)>"},{"s":{"p":["Map:D \\a","Map:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"p":["Iterable:D \\a","Iterable:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"n":"infix:<(|)>","s":{"r":"Mu","p":["Failure:D \\a","$"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["$","Failure:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"r":"Mu","p":["**@p"]}},{"t":"FileChangeEvent","n":"FileChanged","k":"e"},{"n":"&atanh","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":["Numeric \\x"]},"m":1,"k":"s","n":"atanh"},{"n":"atanh","m":1,"k":"s","s":{"r":"Mu","p":["Cool \\x"]}},{"n":"atanh","s":{"p":["num $x"],"r":"num"},"m":1,"k":"s"},{"k":"e","t":"Signal","n":"SIGBUS"},{"n":"&atomic-fetch-dec","t":"Sub","k":"v"},{"n":"atomic-fetch-dec","s":{"r":"atomicint","p":["atomicint $target is rw"]},"m":1,"k":"s"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<minmax>"},{"m":1,"k":"s","s":{"p":["+\\args is raw"],"r":"Mu"},"n":"infix:<minmax>"},{"t":"Sub","n":"&warn","k":"v"},{"s":{"r":"Mu","p":["*@msg"]},"k":"s","m":1,"n":"warn"},{"s":{"r":"Mu","p":["Junction:D \\j"]},"k":"s","m":1,"n":"warn"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<eq>","k":"v"},{"s":{"p":["$x?"],"r":"Mu"},"m":1,"k":"s","n":"infix:<eq>"},{"n":"infix:<eq>","m":1,"k":"s","s":{"r":"Mu","p":["\\a","\\b"]}},{"n":"infix:<eq>","k":"s","m":1,"s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]}},{"n":"infix:<eq>","s":{"p":["Str:D \\a","Str:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"infix:<eq>","s":{"r":"Bool:D","p":["str $a","str $b"]},"k":"s","m":1},{"n":"&prefix:<!>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["Bool \\a"]},"n":"prefix:<!>"},{"m":1,"k":"s","s":{"p":["Mu \\a"],"r":"Mu"},"n":"prefix:<!>"},{"n":"prefix:<!>","s":{"p":["Mu \\a",":$exists!"],"r":"Mu"},"k":"s","m":1},{"t":"ProtocolFamily","n":"ProtocolFamily","k":"e"},{"k":"e","n":"ProtocolFamily::PF_UNIX","t":"ProtocolFamily"},{"t":"ProtocolFamily","n":"ProtocolFamily::PF_INET6","k":"e"},{"k":"e","t":"ProtocolFamily","n":"ProtocolFamily::PF_LOCAL"},{"t":"ProtocolFamily","n":"ProtocolFamily::PF_INET","k":"e"},{"k":"e","n":"ProtocolFamily::PF_MAX","t":"ProtocolFamily"},{"k":"e","n":"SeekType","t":"SeekType"},{"k":"e","n":"SeekType::SeekFromCurrent","t":"SeekType"},{"t":"SeekType","n":"SeekType::SeekFromBeginning","k":"e"},{"t":"SeekType","n":"SeekType::SeekFromEnd","k":"e"},{"t":"Sub+{is-pure}","n":"&tanh","k":"v"},{"m":1,"k":"s","s":{"p":["Numeric \\x"],"r":"Mu"},"n":"tanh"},{"m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"},"n":"tanh"},{"n":"tanh","s":{"p":["num $x"],"r":"num"},"m":1,"k":"s"},{"k":"v","n":"&prefix:<not>","t":"Sub+{is-pure}+{Precedence}"},{"n":"prefix:<not>","k":"s","m":1,"s":{"p":["Bool \\a"],"r":"Mu"}},{"s":{"r":"Mu","p":["Mu \\a"]},"k":"s","m":1,"n":"prefix:<not>"},{"t":"Sub","n":"&reduce","k":"v"},{"n":"reduce","k":"s","m":1,"s":{"r":"Mu","p":["&with","+\\list is raw"]}},{"b":"C","t":"HardRoutine","n":"HardRoutine","m":[{"s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0,"n":"soft"}],"k":"ro","mro":[]},{"b":"C","k":"c","m":[{"n":"!throw","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!SET-SELF","k":"m","m":0,"s":{"p":["$!exception","*%_"],"r":"Mu"}}],"mro":["Nil"],"d":"TITLE\nclass Failure\n\nSUBTITLE\nDelayed exception\n\n    class Failure is Nil { }\n\nA Failure is a soft or unthrown Exception, usually generated by calling\n&fail. It acts as a wrapper around an Exception object.\n\nSink (void) context causes a Failure to throw, i.e. turn into a normal\nexception. The use fatal pragma causes this to happen in all contexts\nwithin the pragma's scope. Inside try blocks, use fatal is automatically\nset, and you can disable it with no fatal.\n\nThat means that Failures are generally only useful in cases of code that\nnormally would produce an rvalue; Failures are more or less equivalent to\nExceptions in code that will frequently be called in sink context (i.e.,\nfor its side-effects, such as with say).\n\nSimilarly, you should generally use &fail only inside code that is normally\nexpected to return something.\n\nChecking a Failure for truth (with the Bool method) or definedness (with\nthe defined method) marks the failure as handled, and causes it not to\nthrow in sink context anymore.\n\nYou can call the handled method to check if a failure has been handled.\n\nCalling methods on unhandled failures propagates the failure. The\nspecification says the result is another Failure, in Rakudo it causes the\nfailure to throw.\n\nBecause a Failure is Nil, which is undefined, a common idiom for safely\nexecuting code that may fail uses a with/else statement:\n\n    sub may_fail( --> Numeric:D ) {\n      my $value = (^10).pick || fail \"Zero is unacceptable\";\n      fail \"Odd is also not okay\" if $value % 2;\n      return $value;\n    }\n\n    with may_fail() -> $value { # defined, so didn't fail\n      say \"I know $value isn't zero or odd.\"\n    } else { # undefined, so failed, and the Failure is the topic\n      say \"Uh-oh: {.exception.message}.\"\n    }\n\n\n","a":[{"k":"v","n":"$.exception","t":"Mu"},{"k":"v","t":"Mu","n":"$.backtrace"},{"t":"int","n":"$!handled","k":"v"}],"t":"Failure","n":"Failure"},{"a":[{"k":"v","t":"num","n":"$.re"},{"n":"$.im","t":"num","k":"v"}],"d":"TITLE\nclass ComplexStr\n\nSUBTITLE\nDual value complex number and string\n\n    class ComplexStr is Complex is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42+0i>; say $f.^name; # OUTPUT: «ComplexStr␤»\n\nAs a subclass of both Complex and Str, a ComplexStr will be accepted where\neither is expected. However, ComplexStr does not share object identity with\nComplex- or Str-only variants:\n\n    my $complex-str = < 42+0i >;\n    my Complex $complex = $complex-str; # OK!\n    my Str     $str     = $complex-str; # OK!\n    say 42+0i ∈ <42+0i  55  1>; # False; ∈ operator cares about object identity\n\n","t":"ComplexStr","n":"ComplexStr","k":"c","m":[{"d":"method new(Complex $i, Str $s)\n\nThe constructor requires both the Complex and the Str value, when\nconstructing one directly the values can be whatever is required:\n\n    my $f = ComplexStr.new(42+0i, \"forty two (but complicated)\");\n    say +$f; # OUTPUT: «42+0i␤»\n    say ~$f; # OUTPUT: «\"forty two (but complicated)\"␤»","n":"new","m":0,"k":"m","s":{"r":"Mu","p":["Complex $c","Str $s","*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method Capture(ComplexStr:D --> Capture:D)\n\nEquivalent to Mu.Capture.","n":"Capture"},{"n":"Complex","d":"method Complex\n\nReturns the Complex value of the ComplexStr.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Numeric","Stringy","Complex","Str"],"b":"C"},{"b":"C","d":"TITLE\nrole Associative\n\nSUBTITLE\nObject that supports looking up values by key\n\n    role Associative[::TValue = Mu, ::TKey = Str(Any)] { }\n\nA common role for types that support name-based lookup through\npostcircumfix:<{ }>, for example Hash and Map. It is used for type checks\nin operators that expect to find specific methods to call. See Subscripts\nfor details.\n\nThe % sigil restricts variables to objects that do Associative, so you will\nhave to mix in that role if you want to use it for your classes.\n\n    class Whatever {};\n    my %whatever := Whatever.new;\n    # OUTPUT: «Type check failed in binding; expected Associative but got Whatever\n\n\nPlease note that we are using binding := here, since by default %\nassignments expect a Hash in the right-hand side. However, with the\nAssociative role:\n\n    class Whatever is Associative {};\n    my %whatever := Whatever.new;\n\nwill be syntactically correct.\n\n","t":"Associative","n":"Associative","k":"ro","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"of","d":"Defined as:\n\n    method of()\n\nAssociative is actually a parameterized role which can use different\nclasses for keys and values. As seen at the top of the document, by default\nit coerces to Str for the key and uses a very generic Mu for value.\n\n    my %any-hash;\n    say %any-hash.of;#  OUTPUT: «(Mu)␤»\n\nThe value is the first parameter you use when instantiating Associative\nwith particular classes:\n\n    class DateHash is Hash does Associative[Cool,DateTime] {};\n    my %date-hash := DateHash.new;\n    say %date-hash.of; # OUTPUT: «(Cool)␤»"},{"d":"Defined as:\n\n    method keyof()\n\nReturns the parameterized key used for the Associative role, which is Any\ncoerced to Str by default. This is the class used as second parameter when\nyou use the parameterized version of Associative.\n\n    my %any-hash;\n    %any-hash.keyof; #OUTPUT: «(Str(Any))␤»\n\nMethods that should be provided\n\nYou need to provide these methods if you want your class to implement the\nAssociative role.","n":"keyof","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"mro":[]},{"k":"v","t":"Sub+{is-pure}","n":"&bag"},{"s":{"p":[],"r":"Mu"},"m":1,"k":"s","n":"bag"},{"s":{"p":["*@a"],"r":"Bag:D"},"m":1,"k":"s","n":"bag"},{"a":[{"t":"NuT","n":"$.numerator","k":"v"},{"n":"$.denominator","t":"DeT","k":"v"}],"t":"Rational","d":"TITLE\nrole Rational\n\nSUBTITLE\nNumber stored as numerator and denominator\n\n    role Rational[::NuT, ::DeT] does Real { ... }\n\nRational is the common role for numbers that are stored as pairs of\nnumerator and denominator. It is parameterized by the types of the\nnumerator (NuT) and denominator (DeT). By default, these are Int, but other\ntypes of Rational are possible by using a different parameterization. In\naddition, Rational objects are immutable throughout their life.\n\n    class Positive does Rational[UInt] {};\n    my Positive $one-third = Positive.new(1,3);\n    say $one-third;                         # OUTPUT: «0.333333␤»\n    my Positive $fail =Positive.new(-2,3);  # OUTPUT: «Type check failed in binding to parameter 'nu'; expected UInt but got Int (-2)␤»\n\nPlease note that, since DeT is by default equal to NuT, in this case both\nare instantiated to UInt. Built into Raku are Rat and FatRat, which both do\nthe Rational role.\n\n","n":"Rational","k":"ro","m":[{"n":"new","d":"method new(NuT:D $numerator, DeT:D $denominator --> Rational:D)\n\n\nCreates a new rational object from numerator and denominator, which it\nnormalizes to the lowest terms. The $denominator can be zero, in which case\nthe numerator is normalized to -1, 0, or 1 depending on whether the\noriginal is negative, zero, or positive, respectively.","s":{"p":["NuT:D \\nu = 0","DeT:D \\de = 1","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"method nude(Rational:D: --> Positional)\n\nReturns a list of the numerator and denominator.","n":"nude","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method Num(Rational:D: --> Num:D)\n\nCoerces the invocant to Num by dividing numerator by denominator. If\ndenominator is 0, returns Inf, -Inf, or NaN, based on whether numerator is\na positive number, negative number, or 0, respectively.","n":"Num","k":"m","m":0,"s":{"p":["*%_"],"r":"Num:D"}},{"n":"floor","d":"Defined as:\n\n    method floor(Rational:D: --> Int:D)\n\nReturn the largest integer not greater than the invocant. If denominator is\nzero, fails with X::Numeric::DivideByZero.","s":{"p":["*%_"],"r":"Int:D"},"m":0,"k":"m"},{"n":"ceiling","d":"Defined as:\n\n    method ceiling(Rational:D: --> Int:D)\n\nReturn the smallest integer not less than the invocant. If denominator is\nzero, fails with X::Numeric::DivideByZero.","s":{"r":"Int:D","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m","n":"Int","d":"Defined as:\n\n    method Int(Rational:D: --> Int:D)\n\nCoerces the invocant to Int by truncating non-whole portion of the\nrepresented number, if any. If the denominator is zero, will fail with\nX::Numeric::DivideByZero."},{"n":"Bridge","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"Range","d":"Returns a Range object that represents the range of values supported."},{"m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]},"d":"method isNaN(Rational:D: --> Bool:D)\n\nTests whether the invocant's Num value is a NaN, an acronym for Not\navailable Number. That is both its numerator and denominator are zero.","n":"isNaN"},{"s":{"p":["*%_"],"r":"Bool:D"},"k":"m","m":0,"n":"is-prime"},{"n":"base","m":0,"k":"m","s":{"p":["$base","$digits? is copy","*%_"],"r":"Mu"}},{"n":"base-repeating","d":"method base-repeating(Rational:D: Int:D() $base = 10)\n\nReturns a list of two strings that, when concatenated, represent the number\nin base $base. The second element is the one that repeats. For example:\n\n    my ($non-rep, $repeating) = (19/3).base-repeating(10);\n    say $non-rep;                               # OUTPUT: «6.␤»\n    say $repeating;                             # OUTPUT: «3␤»\n    printf '%s(%s)', $non-rep, $repeating;      # OUTPUT: «6.(3)»\n\n19/3 is 6.333333... with the 3 repeating indefinitely.\n\nIf no repetition occurs, the second string is empty:\n\n    say (5/2).base-repeating(10).perl;          # OUTPUT: «(\"2.5\", \"\")␤»\n\nThe precision for determining the repeating group is limited to 1000\ncharacters, above that, the second string is ???.\n\n$base defaults to 10.","s":{"p":["$base = 10","*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"succ"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pred"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method norm(Rational:D: --> Rational:D)\n\nDEPRECATED as of 6.d. The method is no longer needed, because as of 6.d\nlanguage version, it's required for Rational type to be normalized on\ncreation.\n\nReturns a normalized Rational object, i.e. with positive denominator, and\nnumerator and denominator coprime. The denominator can also by zero, but\nusing it in any operation or a conversion to string will result in an\nexception.\n\n    use v6.c;\n    my Rational $by-zero = 3/0;\n    say $by-zero.norm.perl; # OUTPUT: «<1/0>␤»\n\n\n    say $by-zero; # OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤","n":"norm"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"narrow"},{"s":{"p":["\\whole","\\fract","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!SLOW-STR"},{"n":"!STRINGIFY","k":"m","m":0,"s":{"r":"Mu","p":["\\whole","\\fract","Int:D $precision","*%_"]}}],"mro":[],"b":"C"},{"n":"PF_INET","t":"ProtocolFamily","k":"e"},{"t":"Sub","n":"&permutations","k":"v"},{"s":{"r":"Seq:D","p":["\\n"]},"k":"s","m":1,"n":"permutations"},{"n":"permutations","k":"s","m":1,"s":{"r":"Seq:D","p":["Iterable \\n"]}},{"d":"TITLE\nclass List\n\nSUBTITLE\nSequence of values\n\n    my class List does Iterable does Positional { }\n\n\nList stores items sequentially and potentially lazily.\n\nIndexes into lists and arrays start at 0 by default.\n\nYou can assign to list elements if they are containers. Use Arrays to have\nevery value of the list stored in a container.\n\nList implements Positional and as such provides support for subscripts.\n\nItems, flattening and sigils\n\nIn Raku, assigning a List to a scalar variable does not lose information.\nThe difference is that iteration generally treats a list (or any other\nlist-like object, like a Seq or an Array) inside a scalar as a single\nelement.\n\n    my $s = (1, 2, 3);\n    for $s { }      # one iteration\n    for $s.list { } # three iterations\n\n    my $t = [1, 2, 3];\n    for $t { }      # one iteration\n    for $t.list { } # three iterations\n\n    my @a = 1, 2, 3;\n    for @a { }      # three iterations\n    for @a.item { } # one iteration\n\nThis operation is called itemization or putting in an item context. .item\ndoes the job for objects, as well as $( ... ) and, on array variables,\n$@a.\n\nLists generally don't interpolate (flatten) into other lists, except when\nthey are in list context and the single argument to an operation such as\nappend:\n\n    my $a = (1, 2, 3);\n    my $nested = ($a, $a);  # two elements\n\n    my $flat = $nested.map({ .Slip });  # six elements, with explicit Slip\n\n    my @b = <a b>;\n    @b.append: $a.list;     # The array variable @b has 5 elements, because\n                            # the list $a is the sole argument to append\n\n    say @b.elems;           # OUTPUT: «5␤»\n\n    my @c = <a b>;\n    @c.append: $a.list, 7;  # The array variable @c has 4 elements, because\n                            # the list $a wasn't the only argument and thus\n                            # wasn't flatten by the append operation\n\n    say @c.elems;           # OUTPUT: «4␤»\n\n    my @d = <a b>;\n    @d.append: $a;          # The array variable @d has 3 elements, because\n                            # $a is in an item context and as far as append is\n                            # concerned a single element\n\n    say @d.elems;           # OUTPUT: «3␤»\n\nThe same flattening behavior applies all objects that do the Iterable role,\nnotable hashes:\n\n    my %h = a => 1, b => 2;\n    my @b = %h;   say @b.elems;     # OUTPUT: «2␤»\n    my @c = %h, ; say @c.elems;     # OUTPUT: «1␤»\n    my @d = $%h;  say @d.elems;     # OUTPUT: «1␤»\n\nSlurpy parameters (*@a) flatten non-itemized sublists:\n\n    sub fe(*@flat) { @flat.elems }\n    say fe(<a b>, <d e>);           # OUTPUT: «4␤»\n    say fe(<a b>, <d e>.item);      # OUTPUT: «3␤»\n\n The empty list is created with (). Smartmatching against the empty list\nwill check for the absence of elements.\n\n    my @a;\n    for @a, @a.list, @a.Seq -> \\listoid {\n        say listoid ~~ ()\n    }\n    # OUTPUT: «True␤True␤True␤»\n\nCoercion to Bool also indicates if the List got any elements.\n\n    my @a;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[0 False False]␤»\n    @a.push: 42;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[1 True True]␤»\n    say 'empty' unless @a;        # no output\n\n","a":[{"n":"$!reified","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!todo"}],"t":"List","n":"List","k":"c","m":[{"s":{"p":["Iterator $iter","*%_"],"r":"List:D"},"k":"m","m":0,"n":"from-iterator"},{"n":"from-slurpy","s":{"r":"Mu","p":["|"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"from-slurpy-onearg"},{"s":{"p":["|"],"r":"Mu"},"k":"m","m":0,"n":"from-slurpy-flat"},{"s":{"p":["**@things is raw","*%_"],"r":"List:D"},"k":"m","m":0,"n":"new"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"\"abc123def\" ~~ m:g/\\d/;\n    say $/.to; # OUTPUT: «6␤»\n\nAssumes the List contains Match objects, such as the $/ variable being a\nList, when using :g modifier in regexes. Returns the value of .to called on\nthe last element of the list.","n":"to"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"from","d":"Assumes the list contains Match objects and returns the value of .from\ncalled on the first element of the list.\n\n    'abcdefg' ~~ /(c)(d)/;\n    say $/.list.from;         # OUTPUT: «2␤»\n\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.list.from;         # OUTPUT: «3␤»"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    sub    sum($list   --> Numeric:D)\n    method sum(List:D: --> Numeric:D)\n\nReturns the sum of all elements in the list or 0 if the list is empty.\nThrows an exception if an element can not be coerced into Numeric.\n\n    say (1, 3, pi).sum;       # OUTPUT: «7.14159265358979␤»\n    say (1, \"0xff\").sum;      # OUTPUT: «256␤»\n    say sum(0b1111, 5);       # OUTPUT: «20␤»\n\nWhen being called on native integer arrays, it is also possible to specify\na :wrap named parameter. This will add the values as native integers,\nwrapping around if they exceed the size of a native integer. If you are\nsure you will not exceed that value, or if you don't mind, using :wrap will\nmake the calculation about 20x as fast.\n\n    my int @values = ^1_000_000;\n    say @a.sum(:wrap);        # OUTPUT: «499999500000␤»","n":"sum"},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Str:D"},"d":"Defined as:\n\n    method fmt($format = '%s', $separator = ' ' --> Str:D)\n\nReturns a string where each element in the list has been formatted\naccording to $format and where each element is separated by $separator.\n\nFor more information about formats strings, see sprintf.\n\n    my @a = 8..11;\n    say @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»","n":"fmt"},{"s":{"p":["Str(Cool) $format","*%_"],"r":"Str:D"},"k":"m","m":1,"n":"fmt","d":"Defined as:\n\n    method fmt($format = '%s', $separator = ' ' --> Str:D)\n\nReturns a string where each element in the list has been formatted\naccording to $format and where each element is separated by $separator.\n\nFor more information about formats strings, see sprintf.\n\n    my @a = 8..11;\n    say @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»"},{"n":"fmt","d":"Defined as:\n\n    method fmt($format = '%s', $separator = ' ' --> Str:D)\n\nReturns a string where each element in the list has been formatted\naccording to $format and where each element is separated by $separator.\n\nFor more information about formats strings, see sprintf.\n\n    my @a = 8..11;\n    say @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»","s":{"p":["Str(Cool) $format","$separator","*%_"],"r":"Str:D"},"k":"m","m":1},{"s":{"r":"Mu","p":["Int:D \\pos","\\what","*%_"]},"m":0,"k":"m","n":"ASSIGN-POS"},{"n":"BIND-POS","s":{"r":"Mu","p":["Int:D \\pos","\\what","*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"reification-target"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Iterator:D"},"n":"iterator"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"d":"Defined as:\n\n    method sink(--> Nil) { }\n\nIt does nothing, and returns Nil, as the definition clearly shows.\n\n    sink [1,2,Failure.new(\"boo!\"),\"still here\"]; # OUTPUT: «»","n":"sink"},{"n":"STORE","s":{"r":"List:D","p":["Iterable:D \\iterable",":$INITIALIZE!","*%_"]},"k":"m","m":1},{"n":"STORE","s":{"r":"List:D","p":["Iterable:D \\iterable","*%_"]},"m":1,"k":"m"},{"k":"m","m":1,"s":{"p":["Mu \\item","*%_"],"r":"List:D"},"n":"STORE"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"List:D"},"d":"Defined as:\n\n    multi method eager(List:D: --> List:D)\n    multi sub eager(*@elems --> List:D)\n\nEvaluates all elements in the List eagerly, and returns them as a List.\n\n    my  \\ll = (lazy 1..5).cache;\n\n    say ll[];     # OUTPUT: «(...)␤»\n    say ll.eager  # OUTPUT: «(1 2 3 4 5)␤»","n":"eager"},{"s":{"r":"Capture:D","p":["*%_"]},"m":0,"k":"m","n":"Capture","d":"Defined as:\n\n    method Capture(--> Capture:D)\n\nReturns a Capture where each Pair, if any, in the List has been converted\nto a named argument (with the key of the Pair stringified). All other\nelements in the List are converted to positional arguments in the order\nthey are found, i.e. the first non pair item in the list becomes the first\npositional argument, which gets index 0, the second non pair item becomes\nthe second positional argument, getting index 1 etc.\n\n    my $list = (7, 5, a => 2, b => 17);\n    my $capture = $list.Capture;\n    say $capture.keys;                                # OUTPUT: «(0 1 a b)␤»\n    my-sub(|$capture);                                # RESULT: «7, 5, 2, 17»\n\n    sub my-sub($first, $second, :$a, :$b) {\n        say \"$first, $second, $a, $b\"\n    }\n\nA more advanced example demonstrating the returned Capture being matched\nagainst a Signature.\n\n    my $list = (7, 5, a => 2, b => 17);\n    say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «True␤»\n\n    $list = (8, 5, a => 2, b => 17);\n    say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «False␤»"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"FLATTENABLE_LIST"},{"n":"FLATTENABLE_HASH","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"CALL-ME","s":{"r":"Mu","p":["|c is raw"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    multi sub    pick($count, *@list --> Seq:D)\n    multi method pick(List:D: $count --> Seq:D)\n    multi method pick(List:D: --> Mu)\n\nIf $count is supplied: Returns $count elements chosen at random and without\nrepetition from the invocant. If * is passed as $count, or $count is\ngreater than or equal to the size of the list, then all elements from the\ninvocant list are returned in a random sequence; i.e. they are returned\nshuffled.\n\nIn method form, if $count is omitted: Returns a single random item from the\nlist, or Nil if the list is empty\n\nExamples:\n\n    say <a b c d e>.pick;           # OUTPUT: «b␤»\n    say <a b c d e>.pick: 3;        # OUTPUT: «(c a e)␤»\n    say <a b c d e>.pick: *;        # OUTPUT: «(e d a b c)␤»","n":"pick","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["Callable:D $calculate","*%_"],"r":"Mu"},"k":"m","m":1,"n":"pick","d":"Defined as:\n\n    multi sub    pick($count, *@list --> Seq:D)\n    multi method pick(List:D: $count --> Seq:D)\n    multi method pick(List:D: --> Mu)\n\nIf $count is supplied: Returns $count elements chosen at random and without\nrepetition from the invocant. If * is passed as $count, or $count is\ngreater than or equal to the size of the list, then all elements from the\ninvocant list are returned in a random sequence; i.e. they are returned\nshuffled.\n\nIn method form, if $count is omitted: Returns a single random item from the\nlist, or Nil if the list is empty\n\nExamples:\n\n    say <a b c d e>.pick;           # OUTPUT: «b␤»\n    say <a b c d e>.pick: 3;        # OUTPUT: «(c a e)␤»\n    say <a b c d e>.pick: *;        # OUTPUT: «(e d a b c)␤»"},{"k":"m","m":1,"s":{"r":"Mu","p":["$number is copy","*%_"]},"d":"Defined as:\n\n    multi sub    pick($count, *@list --> Seq:D)\n    multi method pick(List:D: $count --> Seq:D)\n    multi method pick(List:D: --> Mu)\n\nIf $count is supplied: Returns $count elements chosen at random and without\nrepetition from the invocant. If * is passed as $count, or $count is\ngreater than or equal to the size of the list, then all elements from the\ninvocant list are returned in a random sequence; i.e. they are returned\nshuffled.\n\nIn method form, if $count is omitted: Returns a single random item from the\nlist, or Nil if the list is empty\n\nExamples:\n\n    say <a b c d e>.pick;           # OUTPUT: «b␤»\n    say <a b c d e>.pick: 3;        # OUTPUT: «(c a e)␤»\n    say <a b c d e>.pick: *;        # OUTPUT: «(e d a b c)␤»","n":"pick"},{"d":"Defined as:\n\n    multi sub    roll($count, *@list --> Seq:D)\n    multi method roll(List:D: $count --> Seq:D)\n    multi method roll(List:D: --> Mu)\n\nIf $count is supplied: Returns a sequence of $count elements, each randomly\nselected from the list. Each random choice is made independently, like a\nseparate die roll where each die face is a list element. If * is passed as\n$count returns a lazy, infinite sequence of randomly chosen elements from\nthe original list.\n\nIf $count is omitted: Returns a single random item from the list, or Nil if\nthe list is empty\n\nExamples:\n\n    say <a b c d e>.roll;       # 1 random letter\n    say <a b c d e>.roll: 3;    # 3 random letters\n    say roll 8, <a b c d e>;    # 8 random letters\n\n    my $random-digits := (^10).roll(*);\n    say $random-digits[^15];    # 15 random digits","n":"roll","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    multi sub    roll($count, *@list --> Seq:D)\n    multi method roll(List:D: $count --> Seq:D)\n    multi method roll(List:D: --> Mu)\n\nIf $count is supplied: Returns a sequence of $count elements, each randomly\nselected from the list. Each random choice is made independently, like a\nseparate die roll where each die face is a list element. If * is passed as\n$count returns a lazy, infinite sequence of randomly chosen elements from\nthe original list.\n\nIf $count is omitted: Returns a single random item from the list, or Nil if\nthe list is empty\n\nExamples:\n\n    say <a b c d e>.roll;       # 1 random letter\n    say <a b c d e>.roll: 3;    # 3 random letters\n    say roll 8, <a b c d e>;    # 8 random letters\n\n    my $random-digits := (^10).roll(*);\n    say $random-digits[^15];    # 15 random digits","n":"roll","m":1,"k":"m","s":{"r":"Mu","p":["Whatever $","*%_"]}},{"s":{"p":["\\number","*%_"],"r":"Mu"},"m":1,"k":"m","n":"roll","d":"Defined as:\n\n    multi sub    roll($count, *@list --> Seq:D)\n    multi method roll(List:D: $count --> Seq:D)\n    multi method roll(List:D: --> Mu)\n\nIf $count is supplied: Returns a sequence of $count elements, each randomly\nselected from the list. Each random choice is made independently, like a\nseparate die roll where each die face is a list element. If * is passed as\n$count returns a lazy, infinite sequence of randomly chosen elements from\nthe original list.\n\nIf $count is omitted: Returns a single random item from the list, or Nil if\nthe list is empty\n\nExamples:\n\n    say <a b c d e>.roll;       # 1 random letter\n    say <a b c d e>.roll: 3;    # 3 random letters\n    say roll 8, <a b c d e>;    # 8 random letters\n\n    my $random-digits := (^10).roll(*);\n    say $random-digits[^15];    # 15 random digits"},{"d":"Defined as:\n\n    multi sub    reverse(*@list  --> Seq:D)\n    multi method reverse(List:D: --> Seq:D)\n\nReturns a Seq with the same elements in reverse order.\n\nNote that reverse always refers to reversing elements of a list; to reverse\nthe characters in a string, use flip.\n\nExamples:\n\n    say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\n    say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»","n":"reverse","k":"m","m":0,"s":{"p":["*%_"],"r":"Seq:D"}},{"n":"rotate","d":"Defined as:\n\n    multi sub    rotate(@list,  Int:D $n = 1 --> List:D)\n    multi method rotate(List:D: Int:D $n = 1 --> List:D)\n\nReturns the list rotated by $n elements.\n\nExamples:\n\n    <a b c d e>.rotate(2);   # <c d e a b>\n    <a b c d e>.rotate(-1);  # <e a b c d>","s":{"p":["Int(Cool) $rotate = 1","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Seq:D"},"m":1,"k":"m","n":"combinations","d":"Defined as:\n\n    multi sub    combinations($from, $of = 0..*             --> Seq:D)\n    multi method combinations(List:D: Int() $of             --> Seq:D)\n    multi method combinations(List:D: Iterable:D $of = 0..* --> Seq:D)\n\nReturns a Seq with all $of-combinations of the invocant list. $of can be a\nnumeric Range, in which case combinations of the range of item numbers it\nrepresents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item\ncombinations>). Otherwise, $of is coerced to an Int.\n\n    .say for <a b c>.combinations: 2;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n\nAbove, there are three possible ways to combine the 2-items lists from the\noriginal list, which is what we receive in the output. See permutations if\nyou want permutations instead of combinations.\n\nWith Range argument, we get both three 2-item combinations and one 3-item\ncombination:\n\n    .say for <a b c>.combinations: 2..3;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n    # (a b c)\n\nIf $of is negative or is larger than there are items in the given list, an\nempty list will be returned. If $of is zero, a 1-item list containing an\nempty list will be returned (there's exactly 1 way to pick no items).\n\nThe subroutine form is equivalent to the method form called on the first\nargument ($from), with the exception that if $from is not an Iterable, it\ngets coerced to an Int and combinations are made from a Range constructed\nwith 0..^$from instead:\n\n    .say for combinations 3, 2\n    # OUTPUT:\n    # (0 1)\n    # (0 2)\n    # (1 2)\n\nNote: some implementations may limit the maximum value of non-Iterable\n$from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems\nhave a limit of 2²⁸-1."},{"n":"combinations","d":"Defined as:\n\n    multi sub    combinations($from, $of = 0..*             --> Seq:D)\n    multi method combinations(List:D: Int() $of             --> Seq:D)\n    multi method combinations(List:D: Iterable:D $of = 0..* --> Seq:D)\n\nReturns a Seq with all $of-combinations of the invocant list. $of can be a\nnumeric Range, in which case combinations of the range of item numbers it\nrepresents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item\ncombinations>). Otherwise, $of is coerced to an Int.\n\n    .say for <a b c>.combinations: 2;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n\nAbove, there are three possible ways to combine the 2-items lists from the\noriginal list, which is what we receive in the output. See permutations if\nyou want permutations instead of combinations.\n\nWith Range argument, we get both three 2-item combinations and one 3-item\ncombination:\n\n    .say for <a b c>.combinations: 2..3;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n    # (a b c)\n\nIf $of is negative or is larger than there are items in the given list, an\nempty list will be returned. If $of is zero, a 1-item list containing an\nempty list will be returned (there's exactly 1 way to pick no items).\n\nThe subroutine form is equivalent to the method form called on the first\nargument ($from), with the exception that if $from is not an Iterable, it\ngets coerced to an Int and combinations are made from a Range constructed\nwith 0..^$from instead:\n\n    .say for combinations 3, 2\n    # OUTPUT:\n    # (0 1)\n    # (0 2)\n    # (1 2)\n\nNote: some implementations may limit the maximum value of non-Iterable\n$from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems\nhave a limit of 2²⁸-1.","s":{"p":["$of","*%_"],"r":"Seq:D"},"k":"m","m":1},{"n":"combinations","d":"Defined as:\n\n    multi sub    combinations($from, $of = 0..*             --> Seq:D)\n    multi method combinations(List:D: Int() $of             --> Seq:D)\n    multi method combinations(List:D: Iterable:D $of = 0..* --> Seq:D)\n\nReturns a Seq with all $of-combinations of the invocant list. $of can be a\nnumeric Range, in which case combinations of the range of item numbers it\nrepresents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item\ncombinations>). Otherwise, $of is coerced to an Int.\n\n    .say for <a b c>.combinations: 2;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n\nAbove, there are three possible ways to combine the 2-items lists from the\noriginal list, which is what we receive in the output. See permutations if\nyou want permutations instead of combinations.\n\nWith Range argument, we get both three 2-item combinations and one 3-item\ncombination:\n\n    .say for <a b c>.combinations: 2..3;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n    # (a b c)\n\nIf $of is negative or is larger than there are items in the given list, an\nempty list will be returned. If $of is zero, a 1-item list containing an\nempty list will be returned (there's exactly 1 way to pick no items).\n\nThe subroutine form is equivalent to the method form called on the first\nargument ($from), with the exception that if $from is not an Iterable, it\ngets coerced to an Int and combinations are made from a Range constructed\nwith 0..^$from instead:\n\n    .say for combinations 3, 2\n    # OUTPUT:\n    # (0 1)\n    # (0 2)\n    # (1 2)\n\nNote: some implementations may limit the maximum value of non-Iterable\n$from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems\nhave a limit of 2²⁸-1.","s":{"r":"Seq:D","p":["Range:D $ofrange","*%_"]},"k":"m","m":1},{"d":"Defined as:\n\n    multi sub    permutations(Int()    $from --> Seq:D)\n    multi sub    permutations(Iterable $from --> Seq:D)\n    multi method permutations(List:D:        --> Seq:D)\n\nReturns all possible permutations of a list as a Seq of lists:\n\n    .say for <a b c>.permutations;\n    # OUTPUT:\n    # (a b c)\n    # (a c b)\n    # (b a c)\n    # (b c a)\n    # (c a b)\n    # (c b a)\n\npermutations treats all elements as unique, thus (1, 1, 2).permutations\nreturns a list of 6 elements, even though there are only three distinct\npermutations, due to first two elements being the same.\n\nThe subroutine form behaves the same as the method form, computing\npermutations from its first argument $from. If $from is not an Iterable,\ncoerces $from to an Int and picks from a Range constructed with 0..^$from:\n\n    .say for permutations 3;\n    # OUTPUT:\n    # (0 1 2)\n    # (0 2 1)\n    # (1 0 2)\n    # (1 2 0)\n    # (2 0 1)\n    # (2 1 0)","n":"permutations","m":1,"k":"m","s":{"p":["*%_"],"r":"Seq:D"}},{"k":"m","m":0,"s":{"p":["Str(Cool) $separator = \"\"","*%_"],"r":"Mu"},"d":"Defined as:\n\n    sub    join($separator, *@list)\n    method join(List:D: $separator = \"\")\n\nTreats the elements of the list as strings by calling .Str on each of them,\ninterleaves them with $separator and concatenates everything into a single\nstring. Note that you can omit the $separator if you use the method\nsyntax.\n\nExample:\n\n    join ', ', <a b c>;             # RESULT: «a, b, c»\n\nNote that the method form does not flatten sublists:\n\n    say (1, <a b c>).join('|');     # OUTPUT: «1|a b c␤»\n\nThe method form also allows you to omit the separator:\n\n    say <a b c>.join;               # OUTPUT: «abc␤»\n\nBut it behaves slurpily, flattening all arguments after the first into a\nsingle list:\n\n    say join('|', 3, 'þ', 1+4i);    # OUTPUT: «3|þ|1+4i␤»\n    say join ', ', <a b c>, 'd', 'e' , 'f'; # OUTPUT: «a, b, c, d, e, f␤»\n\nIn this case, the first list <a b c is slurped and flattened, unlike what\nhappens when join is invoked as a method.\n\nIf one of the elements of the list happens to be a Junction, then join will\nalso return a Junction with concatenation done as much as possible:\n\n    say (\"a\"|\"b\",\"c\",\"d\").join;     # OUTPUT: «any(acd,bcd)␤»","n":"join"},{"k":"m","m":0,"s":{"p":["|"],"r":"Mu"},"n":"push"},{"s":{"r":"Mu","p":["|"]},"m":0,"k":"m","n":"append"},{"n":"unshift","k":"m","m":0,"s":{"p":["|"],"r":"Mu"}},{"n":"prepend","s":{"p":["|"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"shift"},{"m":0,"k":"m","s":{"r":"Mu","p":["|"]},"n":"pop"},{"n":"!AT_POS_SLOW","s":{"p":["\\pos","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!JUNCTIONIZE","k":"m","m":0,"s":{"r":"Mu","p":["\\sep","Mu \\strings","\\i","\\elems","Mu \\initial","*%_"]}}],"mro":["Positional","Iterable","Cool"],"b":"C"},{"n":"List::Reifier","t":"List::Reifier","a":[{"k":"v","n":"$!reified","t":"Mu"},{"k":"v","t":"Iterator","n":"$!current-iter"},{"t":"Mu","n":"$!future","k":"v"},{"t":"Mu","n":"$!reification-target","k":"v"}],"mro":["Any"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["int $elems","*%_"]},"n":"reify-at-least"},{"n":"reify-until-lazy","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"reify-all","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"fully-reified"},{"n":"is-lazy","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"}],"b":"A"},{"k":"v","n":"&infix:<%%>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":[]},"k":"s","m":1,"n":"infix:<%%>"},{"s":{"r":"Mu","p":["$"]},"k":"s","m":1,"n":"infix:<%%>"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Mu"},"n":"infix:<%%>"},{"n":"infix:<%%>","k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]}},{"n":"infix:<%%>","k":"s","m":1,"s":{"r":"Bool:D","p":["int $a","int $b"]}},{"mro":["Systemic","Any"],"m":[{"k":"s","m":0,"s":{"p":[":auth($!auth) = \"unknown\"","*%_"],"r":"Nil"},"n":"BUILD"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"name"},{"n":"version","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method release\n\nInstance method returning the release information of the Kernel object.\nDies if the release information could not be established.","n":"release"},{"d":"Defined as\n\n    method hardware\n\nInstance method returning the hardware information of the Kernel object.\nDies if the hardware information could not be established.\n\n    say $*KERNEL.hardware; # OUTPUT: «x86_64␤»","n":"hardware","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method arch\n\nInstance method returning the \"arch\" (as in \"architecture\") information of\nthe Kernel object. Dies if the \"arch\" could not be established.","n":"arch"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"archname","d":"method archname\n\nInstance method returning the concatenation of hardware and name."},{"n":"bits","d":"method bits\n\nInstance method returning the number of bits used in the architecture of\nthe processor. Usually 32 or 64.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"hostname","d":"method hostname\n\nInstance method returning the hostname of the Kernel object.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"signals","d":"Instance method returning a list of Signals that are supported by the\nkernel represented by the Kernel object.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":1,"k":"m","s":{"r":"Int:D","p":["Str:D $signal","*%_"]},"d":"Defined as:\n\n    multi method signal(Kernel:D: Str:D $signal --> Int:D)\n    multi method signal(Kernel:D: Signal:D \\signal --> Int:D)\n    multi method signal(Kernel:D: Int:D \\signal --> Int:D)\n\nInstance method returning the Signal numeric code for a given name for the\nKernel object.\n\n    say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»","n":"signal"},{"s":{"r":"Int:D","p":["Signal:D \\signal","*%_"]},"k":"m","m":1,"n":"signal","d":"Defined as:\n\n    multi method signal(Kernel:D: Str:D $signal --> Int:D)\n    multi method signal(Kernel:D: Signal:D \\signal --> Int:D)\n    multi method signal(Kernel:D: Int:D \\signal --> Int:D)\n\nInstance method returning the Signal numeric code for a given name for the\nKernel object.\n\n    say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»"},{"n":"signal","d":"Defined as:\n\n    multi method signal(Kernel:D: Str:D $signal --> Int:D)\n    multi method signal(Kernel:D: Signal:D \\signal --> Int:D)\n    multi method signal(Kernel:D: Int:D \\signal --> Int:D)\n\nInstance method returning the Signal numeric code for a given name for the\nKernel object.\n\n    say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»","s":{"r":"Int:D","p":["Int:D \\signal","*%_"]},"k":"m","m":1},{"n":"cpu-cores","d":"method cpu-cores(--> Int)\n\nInstance / Class method returning the number of CPU cores that are\navailable.\n\n    say $*KERNEL.cpu-cores; # OUTPUT: «8␤»","s":{"r":"Int","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Int","p":["*%_"]},"m":0,"k":"m","n":"cpu-usage","d":"method cpu-usage(--> Int)\n\nInstance / Class method returning the amount of CPU uses since the start of\nthe program (in microseconds)."},{"d":"method free-memory(--> Int)\n\nInstance / Class method returning the available memory on the system. When\nusing the JVM, this returns the available memory to the JVM instead. This\nmethod is only available in release v2019.06 and later.","n":"free-memory","m":0,"k":"m","s":{"r":"Int","p":["*%_"]}},{"s":{"r":"Int","p":["*%_"]},"k":"m","m":0,"n":"total-memory","d":"method total-memory(--> Int)\n\nInstance / Class method returning the total memory available to the system.\nWhen using the JVM, this returns the total memory available to the JVM\ninstead. This method is only available in release v2019.06 and later."},{"d":"method endian(--> Endian:D)\n\nClass method that returns the Endian object associated with the kernel\narchitecture (either LittleEndian or BigEndian).","n":"endian","k":"m","m":0,"s":{"p":["*%_"],"r":"Endian:D"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"auth"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"signature"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"desc"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"!uname-r"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"!uname"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"!uname-s"},{"n":"!uname-p","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!uname-v"},{"n":"!uname-m","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"k":"c","n":"Kernel","t":"Kernel","a":[{"t":"Str","n":"$.release","k":"v"},{"t":"Str","n":"$!hardware","k":"v"},{"k":"v","n":"$!arch","t":"Str"},{"k":"v","t":"Int","n":"$!bits"},{"t":"Mu","n":"$!uname","k":"v"},{"t":"Positional","n":"@!signals","k":"v"},{"t":"Mu","n":"$!signals-setup-lock","k":"v"},{"k":"v","t":"Mu","n":"$!signals-setup"},{"k":"v","n":"%!signals-by-Str","t":"Associative"},{"t":"Mu","n":"$!signals-by-Str-setup","k":"v"},{"k":"v","n":"$.name","t":"Str"},{"k":"v","t":"Str","n":"$.auth"},{"n":"$.version","t":"Version","k":"v"},{"n":"$.signature","t":"Blob","k":"v"},{"k":"v","t":"Str","n":"$.desc"}],"d":"TITLE\nclass Kernel\n\nSUBTITLE\nKernel related information\n\n    class Kernel does Systemic { }\n\nBuilt-in class for providing kernel related information. Usually accessed\nthrough the $*KERNEL dynamic variable.\n\n","b":"A"},{"b":"A","mro":["Rakudo::Internals::ImplementationDetail","Callable","Any"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method arity()\n\nReturns the arity of the enclosed code.","n":"arity"},{"d":"method count()\n\nReturns the number of arguments the enclosed code needs.","n":"count","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method signature( ForeignCode:D: )\n\nReturns the signature of the enclosed code.","n":"signature"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method name()\n\nReturns the name of the enclosed code, or <anon> if it has not received\nany.","n":"name"}],"k":"c","n":"ForeignCode","a":[{"k":"v","t":"Code","n":"$!do"}],"t":"ForeignCode","d":"TITLE\nclass ForeignCode\n\nSUBTITLE\nRakudo-specific class that wraps around code in other languages (generally\nNQP)\n\n    class ForeignCode does Callable {}\n\nThis is a Rakudo specific class, and as such it is advisable not to use it\nin your own code, since its interface might change or even disappear in the\nfuture. This is provided here only as a reference\n\nForeignCode is a Raku wrapper around code that is not written originally in\nthat language; its intention is to use these blocks of code in Callable\ncontexts easily. For instance, subs have some anonymous functions that are\nactually ForeignCode.\n\n    sub does-nothing(){};\n    say $_.name ~ ' → ' ~ $_.^name for &does-nothing.^methods;\n    # OUTPUT: «<anon> → ForeignCode␤<anon> → ForeignCode␤soft → Method␤…»\n\n\nThis script will map method names to their class, and it shows that\nroutines, in particular, have several methods that are actually ForeignCode\ninstead of Methods.\n\n"},{"n":"&infix:<?&>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<?&>","m":1,"k":"s","s":{"p":["Mu $x = Bool::True"],"r":"Mu"}},{"n":"infix:<?&>","m":1,"k":"s","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"}},{"t":"Sub","n":"&infix:<⚛=>","k":"v"},{"s":{"r":"Mu","p":["$target is rw","\\value"]},"k":"s","m":1,"n":"infix:<⚛=>"},{"n":"infix:<⚛=>","k":"s","m":1,"s":{"p":["atomicint $target is rw","int $value"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["atomicint $target is rw","Int:D $value"],"r":"Mu"},"n":"infix:<⚛=>"},{"m":1,"k":"s","s":{"p":["atomicint $target is rw","$value"],"r":"Mu"},"n":"infix:<⚛=>"},{"b":"C","n":"Callable","d":"TITLE\nrole Callable\n\nSUBTITLE\nInvocable code object\n\n    role Callable { ... }\n\nRole for objects which support calling them. It's used in Block, Routine,\nSub, Method, Submethod and Macro types.\n\nCallables can be stored in &-sigiled containers, the default type\nconstraint of such a container is Callable.\n\n    my &a = {;}; # Empty block needs a semicolon\n    my &b = -> {};\n    my &c = sub () {};\n    sub foo() {};\n    my &d = &foo;\n\n","t":"Callable","mro":[],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"of"},{"n":"returns","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","n":"Capture"}],"k":"ro"},{"k":"v","t":"Sub","n":"&unshift"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","|elems is raw"]},"n":"unshift"},{"k":"e","t":"Order","n":"Order"},{"n":"Order::Same","t":"Order","k":"e"},{"k":"e","t":"Order","n":"Order::Less"},{"t":"Order","n":"Order::More","k":"e"},{"k":"e","n":"SIGILL","t":"Signal"},{"n":"&round","t":"Sub+{is-pure}","k":"v"},{"n":"round","k":"s","m":1,"s":{"p":["$a"],"r":"Mu"}},{"n":"round","s":{"p":["$a","$scale"],"r":"Mu"},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&chmod"},{"k":"s","m":1,"s":{"r":"Mu","p":["$mode","*@filenames"]},"n":"chmod"},{"n":"&uniprop-str","t":"Sub","k":"v"},{"n":"uniprop-str","m":1,"k":"s","s":{"p":["Str:D $str","Stringy:D $propname"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["Int:D $code","Stringy:D $propname"]},"n":"uniprop-str"},{"t":"Sub","n":"&infix:<⚛+=>","k":"v"},{"n":"infix:<⚛+=>","s":{"r":"atomicint","p":["atomicint $target is rw","int $add"]},"m":1,"k":"s"},{"s":{"p":["atomicint $target is rw","Int:D $add"],"r":"atomicint"},"m":1,"k":"s","n":"infix:<⚛+=>"},{"n":"infix:<⚛+=>","m":1,"k":"s","s":{"r":"atomicint","p":["atomicint $target is rw","$add"]}},{"d":"TITLE\nclass Routine\n\nSUBTITLE\nCode object with its own lexical scope and return handling\n\n    class Routine is Block { }\n\nA Routine is a code object meant for larger unities of code than Block.\nRoutine is the common superclass for Sub (and therefore operators) and\nMethod, the two primary code objects for code reuse.\n\nRoutines serve as a scope limiter for return (i.e. a return returns from\nthe innermost outer Routine).\n\nThe routine level is also the one at which multiness (multi subs and multi\nmethods) are handled. Subroutines can also be declared anon. See the\ndocumentation on the anon declarator for more information.\n\n","a":[{"k":"v","t":"List","n":"@!dispatchees"},{"n":"$!dispatcher_cache","t":"Mu","k":"v"},{"n":"$!dispatcher","t":"Mu","k":"v"},{"k":"v","t":"int","n":"$!rw"},{"n":"$!inline_info","t":"Mu","k":"v"},{"t":"int","n":"$!yada","k":"v"},{"k":"v","t":"Mu","n":"$!package"},{"k":"v","t":"int","n":"$!onlystar"},{"k":"v","n":"@!dispatch_order","t":"List"},{"n":"$!dispatch_cache","t":"Mu","k":"v"},{"k":"v","n":"$!why","t":"Mu"},{"k":"v","t":"Code","n":"$!do"},{"t":"Signature","n":"$!signature","k":"v"},{"n":"@!compstuff","t":"List","k":"v"}],"t":"Routine","n":"Routine","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"onlystar"},{"n":"candidates","d":"method candidates(Routine:D: --> Positional:D)\n\nReturns a list of multi candidates, or a one-element list with itself if\nit's not a multi","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"d":"method cando(Capture $c)\n\nReturns a possibly-empty list of candidates that can be called with the\ngiven Capture, ordered by narrowest candidate first. For methods, the first\nelement of the Capture needs to be the invocant:\n\n    .signature.say for \"foo\".^can(\"comb\")[0].cando: \\(Cool, \"o\");\n    # OUTPUT: «(Cool $: Str $matcher, $limit = Inf, *%_)␤»","n":"cando","k":"m","m":0,"s":{"p":["Capture:D $c","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"multi","d":"method multi(Routine:D: --> Bool:D)\n\nReturns True if the routine is a multi sub or method. Note that the name of\na multi sub refers to its proto and this method would return false if\ncalled on it. It needs to be called on the candidates themselves:\n\n    multi foo ($, $) {};\n    say &foo.multi;             # OUTPUT: «False␤»\n    say &foo.candidates».multi; # OUTPUT: «(True)␤»"},{"n":"soft","m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"}},{"k":"m","m":0,"s":{"r":"Mu","p":["&wrapper","*%_"]},"d":"method wrap(Routine:D: &wrapper)\n\nWraps (i.e. in-place modifies) the routine. That means a call to this\nroutine first calls &wrapper, which then can (but doesn't have to) call the\noriginal routine with the callsame, callwith, nextsame and nextwith\ndispatchers. The return value from the routine is also the return value\nfrom the wrapper.\n\nwrap returns an instance of a private class called Routine::WrapHandle,\nwhich you can pass to unwrap to restore the original routine.","n":"wrap"},{"d":"method unwrap($wraphandle)\n\nRestores the original routine after it has been wrapped with wrap. While\nthe signature allows any type to be passed, only the Routine::WrapHandle\ntype returned from wrap can usefully be.","n":"unwrap","k":"m","m":0,"s":{"p":["$handle","*%_"],"r":"Mu"}},{"d":"method yada(Routine:D: --> Bool:D)\n\nReturns True if the routine is a stub\n\n    say (sub f() { ... }).yada;      # OUTPUT: «True␤»\n    say (sub g() { 1;  }).yada;      # OUTPUT: «False␤»\n\n  trait is cached\n\n    multi sub trait_mod:<is>(Routine $r, :$cached!)\n\nCauses the return value of a routine to be stored, so that when subsequent\ncalls with the same list of arguments are made, the stored value can be\nreturned immediately instead of re-running the routine.This is still in\nexperimental stage. Please check the corresponding section in the\nexperimental features document\n\nUseful when storing and returning the computed value is much faster than\nre-computing it every time, and when the time saved trumps the cost of the\nuse of more memory.\n\nEven if the arguments passed to the routine are \"reference types\" (such as\nobjects or arrays), then for the purpose of caching they will only be\ncompared based on their contents. Thus the second invocation will hit the\ncache in this case:\n\n    say foo( [1, 2, 3] );   # runs foo\n    say foo( [1, 2, 3] );   # doesn't run foo, uses cached value\n\n\nSince it's still at the experimental stage, you will have to insert the use\nexperimental :cached; statement in any module or script that uses it.\n\n    use experimental :cached;\n\n    sub nth-prime(Int:D $x where * > 0) is cached {\n        say \"Calculating {$x}th prime\";\n        return (2..*).grep(*.is-prime)[$x - 1];\n    }\n\n    say nth-prime(43);\n    say nth-prime(43);\n    say nth-prime(43);\n\n\nproduces this output:\n\n    Calculating 43th prime\n    191\n    191\n    191\n\n\n  trait is pure\n\n    multi sub trait_mod:<is>(Routine $r, :$pure!)\n\nMarks a subroutine as pure, that is, it asserts that for the same input, it\nwill always produce the same output without any additional side effects.\n\nThe is pure trait is a promise by the programmer to the compiler that it\ncan constant-fold calls to such functions when the arguments are known at\ncompile time.\n\n    sub syllables() is pure {\n        say \"Generating syllables\";\n        my @vowels = <a e i o u>;\n        return  @vowels.append: <k m n sh d r t y> X~ @vowels;\n    }\n\nYou can mark function as pure even if they throw exceptions in edge cases\nor if they modify temporary objects; hence the is pure trait can cover\ncases that the compiler cannot deduce on its own. On the other hand, you\nmight not want to constant-fold functions that produce a large return value\n(such as the string or list repetition operators, infix x and xx) even if\nthey are pure, to avoid large precompilation files.\n\nTo see it an action with a particular compiler you can try this example:\n\n    BEGIN { say ‘Begin’ }\n    say ‘Start’;\n    say (^100).map: { syllables().pick(2..5).join(\"\") };\n\n\n    # Example output:\n    # Begin\n    # Generating syllables\n    # Start\n    # (matiroi yeterani shoriyuru...\n\n\nEssentially this allows the compiler to perform some operations at compile\ntime. The benefits of constant-folding may include better performance,\nespecially in cases when the folded code is precompiled.\n\nIn addition, using a pure function or operator in sink context (that is,\nwhere the result is discarded) may lead to a warning. The code\n\n    sub double($x) is pure { 2 * $x };\n    double(21);\n    say \"anything\";\n    # WARNING: «Useless use of \"double(21)\" in expression \"double(21)\" in sink context (line 2)»\n\nIf you want to apply this trait to a multi, you need to apply it to the\nproto; it will not work otherwise, at least in versions 2018.08 and below.\n\n  trait is rw\n\n    multi sub trait_mod:<is>(Routine $r, :$rw!)\n\nWhen a routine is modified with this trait, its return value will be\nwritable. This is useful when returning variables or writable elements of\nhashes or arrays, for example:\n\n    sub walk(\\thing, *@keys) is rw {\n        my $current := thing;\n        for @keys -> $k {\n            if $k ~~ Int {\n                $current := $current[$k];\n            }\n            else {\n                $current := $current{$k};\n            }\n        }\n        $current;\n    }\n\n    my %hash;\n    walk(%hash, 'some', 'key', 1, 2) = 'autovivified';\n\n    say %hash.perl;\n\n\nproduces\n\n    (\"some\" => {\"key\" => [Any, [Any, Any, \"autovivified\"]]}).hash\n\n\nNote that return marks return values as read only; if you need an early\nexit from an is rw routine, you have to use return-rw instead.\n\n  trait is export\n\n    multi sub trait_mod:<is>(Routine $r, :$export!)\n\nMarks a routine as exported to the rest of the world\n\n    module Foo {\n        sub double($x) is export {\n            2 * $x\n        }\n    }\n\n    import Foo;         # makes sub double available\n    say double 21;      # 42\n\n\nFrom inside another file you'd say use Foo; to load a module and import the\nexported functions.\n\nSee Exporting and Selective Importing Modules for more details.\n\n  trait is DEPRECATED\n\n    multi sub trait_mod:<is>(Routine:D $r, :$DEPRECATED!)\n\nMarks a routine as deprecated, optionally with a message what to use\ninstead.\n\nThis code\n\n    sub f() is DEPRECATED('the literal 42') { 42 }\n    say f();\n\n\nproduces this output:\n\n    42\n    Saw 1 occurrence of deprecated code.\n    ================================================================================\n    Sub f (from GLOBAL) seen at:\n      deprecated.p6, line 2\n    Please use the literal 42 instead.\n    --------------------------------------------------------------------------------\n    Please contact the author to have these occurrences of deprecated code\n    adapted, so that this message will disappear!\n\n\n  trait is hidden-from-backtrace\n\n    multi sub trait_mod:<is>(Routine:D, :$hidden-from-backtrace!)\n\nHides a routine from showing up in a default backtrace. For example\n\n    sub inner { die \"OH NOEZ\" };\n    sub outer { inner() };\n    outer();\n\n\nproduces the error message and backtrace\n\n    OH NOEZ\n      in sub inner at bt.p6:1\n      in sub outer at bt.p6:2\n      in block <unit> at bt.p6:3\n\n\nbut if inner is marked with hidden-from-backtrace\n\n    sub inner is hidden-from-backtrace { die \"OH NOEZ\" };\n    sub outer { inner() };\n    outer();\n\n\nthe error backtrace does not show it:\n\n    OH NOEZ\n      in sub outer at bt.p6:2\n      in block <unit> at bt.p6:3\n\n\n  trait is default\n\nDefined as\n\n    multi sub trait_mod:<is>(Routine:D $r, :$default!)\n\nThere is a special trait for Routines called is default. This trait is\ndesigned as a way to disambiguate multi calls that would normally throw an\nerror because the compiler would not know which one to use. This means that\ngiven the following two Routines, the one with the is default trait will be\ncalled.\n\n    multi sub f() is default { say \"Hello there\" }\n    multi sub f() { say \"Hello friend\" }\n    f();   # OUTPUT: «\"Hello there\"␤»\n\nThe is default trait can become very useful for debugging and other uses\nbut keep in mind that it will only resolve an ambiguous dispatch between\ntwo Routines of the same precedence. If one of the Routines is narrower\nthan another, then that one will be called. For example:\n\n    multi sub f() is default { say \"Hello there\" }\n    multi sub f(:$greet) { say \"Hello \" ~ $greet }\n    f();   # \"Use of uninitialized value $greet...\"\n\n\nIn this example, the multi without is default was called because it was\nactually narrower than the Sub with it.\n\n  trait is raw\n\nDefined as:\n\n    multi sub trait_mod:<is>(Routine:D $r, :$raw!)\n\nGives total access to the data structure returned by the routine.\n\n    my @zipi = <zape zapatilla>;\n    sub þor() is raw {\n        return @zipi\n    };\n    þor()[1] = 'pantuflo';\n    say @zipi;  # OUTPUT: «[zape pantuflo]␤»","n":"yada","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"package","d":"method package(Routine:D:)\n\nReturns the package in which the routine is defined.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"leave","s":{"p":["*@","*%_"],"r":"Mu"},"m":0,"k":"m"}],"mro":["Callable","Block"],"b":"A"},{"n":"&infix:<before>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<before>","s":{"r":"Bool","p":["$?"]},"k":"s","m":1},{"n":"infix:<before>","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Bool:D"}},{"k":"v","n":"&die","t":"Sub"},{"m":1,"k":"s","s":{"p":[],"r":"Nil"},"n":"die"},{"n":"die","s":{"r":"Nil","p":["Exception:U $e"]},"k":"s","m":1},{"n":"die","s":{"r":"Nil","p":["$payload"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Nil","p":["|cap is raw (*@msg)"]},"n":"die"},{"s":{"p":["Failure:D $f"],"r":"Nil"},"k":"s","m":1,"n":"die"},{"n":"die","m":1,"k":"s","s":{"p":["Failure:U $f"],"r":"Nil"}},{"n":"SIGINT","t":"Signal","k":"e"},{"b":"C","n":"StringyEnumeration","t":"StringyEnumeration","mro":[],"k":"ro"},{"t":"byte","n":"byte","k":"n"},{"k":"v","n":"&chr","t":"Sub+{is-pure}"},{"n":"chr","s":{"p":["Int:D \\x"],"r":"Str:D"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Str:D","p":["Cool \\x"]},"n":"chr"},{"k":"s","m":1,"s":{"r":"str","p":["int $x"]},"n":"chr"},{"t":"Sub","n":"&roll","k":"v"},{"n":"roll","m":1,"k":"s","s":{"r":"Mu","p":["$n","+\\values is raw"]}},{"k":"v","n":"&words","t":"Sub"},{"n":"words","k":"s","m":1,"s":{"p":["$what = { ... }","|c is raw"],"r":"Mu"}},{"m":[{"s":{"p":["Mu $package",":$compiler_services","*%_"],"r":"Mu"},"m":0,"k":"m","n":"compose"},{"s":{"r":"Mu","p":["Mu $pkg","*%_"]},"k":"m","m":0,"n":"apply_handles"},{"s":{"r":"Mu","p":["Mu $obj","*%_"]},"k":"m","m":0,"n":"get_value","d":"Defined as:\n\n    method get_value(Mu $obj)\n\nReturns the value stored in this attribute of object $obj.\n\n    class Violated {\n        has $!private-thing = 5;\n    }\n    my $private = Violated.^attributes(:local)[0];\n    say $private.get_value(Violated.new); # OUTPUT: «5␤»\n\nNote that this method violates encapsulation of the object, and should be\nused with care. Here be dragons."},{"n":"set_value","d":"Defined as:\n\n    method set_value(Mu $obj, Mu \\new_val)\n\nBinds the value new_val to this attribute of object $obj.\n\n    class A {\n        has $!a = 5;\n        method speak() { say $!a; }\n    }\n    my $attr = A.^attributes(:local)[0];\n    my $a = A.new;\n    $a.speak; # OUTPUT: «5␤»\n    $attr.set_value($a, 42);\n    $a.speak; # OUTPUT: «42␤»\n\nNote that this method violates encapsulation of the object, and should be\nused with care. Here be dragons.","s":{"r":"Mu","p":["Mu $obj","Mu \\value","*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"container"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"readonly","d":"Defined as:\n\n    method readonly(Attribute:D: --> Bool:D)\n\nReturns True for readonly attributes, which is the default, or False for\nattributes marked as is rw.\n\n    class Library {\n        has $.address; # Read-only value\n        has @.new-books is rw;\n    }\n    my $addr = Library.^attributes(:local)[0];\n    my $new-books = Library.^attributes(:local)[1];\n    say $addr.readonly;      # OUTPUT: «True␤»\n    say $new-books.readonly; # OUTPUT: «False␤»"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method package()\n\nReturns the package (class/grammar/role) to which this attribute belongs.\n\n    class Boo {\n        has @!baz;\n    }\n    my $a = Boo.^attributes(:local)[0];\n    say $a.package;         # OUTPUT: «(Boo)␤»","n":"package"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"inlined"},{"n":"dimensions","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"WHY","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"set_why","s":{"r":"Mu","p":["$why","*%_"]},"m":0,"k":"m"}],"k":"c","mro":["Any"],"d":"TITLE\nclass Attribute\n\nSUBTITLE\nMember variable\n\n    class Attribute { }\n\nIn Raku lingo, an attribute refers to a per-instance/object storage slot.\nAn Attribute is used to talk about classes' and roles' attributes at the\nmetalevel.\n\nNormal usage of attributes does not require the user to use this class\nexplicitly.\n\nTraits\n\n  Trait is default\n\nAn attribute that is assigned Nil will revert to its default value set with\nthe trait is default. In the case of arrays or associatives, the argument\nof is default will set the default item value or hash value.\n\n    class C {\n        has $.a is default(42) is rw = 666\n    }\n    my $c = C.new;\n    say $c;\n    $c.a = Nil;\n    say $c;\n    # OUTPUT: «C.new(a => 666)␤C.new(a => 42)␤»\n    class Foo {\n        has @.bar is default(42) is rw\n    };\n    my $foo = Foo.new( bar => <a b c> );\n    $foo.bar =Nil;\n    say $foo; # OUTPUT: «Foo.new(bar => [42])␤»\n\n  Trait is required\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute $attr, :$required!)\n\nThe trait is required will mark the attribute as to be filled with a value\nwhen the object is instantiated. Failing to do so will result in a runtime\nerror.\n\n    class C {\n        has $.a is required\n    }\n    my $c = C.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required, but you did not provide a value for it.␤»\n\nAvailable as of 6.d language version (early implementation exists in Rakudo\ncompiler 2018.08+): You can specify a reason why the attribute is\nrequired:\n\n    class D {\n        has $.a is required(\"it is a good idea\");\n    }\n    my $d = D.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required because it is a good idea,␤but you did not provide a value for it.␤»\n\n\nis required doesn't just affect the default constructor, it checks for the\nattribute at a lower level, so it will work for custom constructors written\nusing bless.\n\n  trait is DEPRECATED\n\n    multi sub trait_mod:<is>(Attribute:D $r, :$DEPRECATED!)\n\nMarks an attribute as deprecated, optionally with a message what to use\ninstead.\n\n    class C {\n        has $.foo is DEPRECATED(\"'bar'\");\n    }\n    my $c = C.new( foo => 42 );  # doesn't trigger with initialization (yet)\n    say $c.foo;                  # does trigger on usage\n\nAfter the program is finished, this will show something like this on\nSTDERR:\n\n    # Saw 1 occurrence of deprecated code.\n    # =====================================\n    # Method foo (from C) seen at:\n    # script.p6, line 5\n    # Please use 'bar' instead.\n\n  trait is rw\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute:D $attr, :$rw!)\n\nMarks an attribute as read/write as opposed to the default readonly. The\ndefault accessor for the attribute will return a writable value.\n\n    class Boo {\n       has $.bar is rw;\n       has $.baz;\n    };\n\n    my $boo = Boo.new;\n    $boo.bar = 42; # works\n    $boo.baz = 42;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\n","t":"Attribute","n":"Attribute","b":"A"},{"t":"Sub","n":"&fail","k":"v"},{"n":"fail","s":{"r":"Nil","p":[]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Exception:U $e"],"r":"Nil"},"n":"fail"},{"n":"fail","m":1,"k":"s","s":{"r":"Nil","p":["$payload"]}},{"k":"s","m":1,"s":{"p":["|cap is raw (*@msg)"],"r":"Nil"},"n":"fail"},{"n":"fail","m":1,"k":"s","s":{"p":["Failure:U $f"],"r":"Nil"}},{"n":"fail","s":{"p":["Failure:D $fail"],"r":"Nil"},"m":1,"k":"s"},{"t":"Sub","n":"&callsame","k":"v"},{"n":"callsame","k":"s","m":0,"s":{"r":"Mu","p":[]}},{"k":"ss","n":"UInt","t":"Int"},{"b":"A","k":"c","m":[{"n":"new","m":1,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"new","s":{"p":["Tappable $tappable","*%_"],"r":"Mu"},"k":"m","m":1},{"k":"s","m":0,"s":{"p":["Tappable :tappable($!tappable)!","*%_"],"r":"Nil"},"n":"BUILD"},{"n":"Capture","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"live","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"serial"},{"n":"Tappable","m":0,"k":"m","s":{"p":["*%_"],"r":"Tappable"}},{"k":"m","m":0,"s":{"p":["&emit = { ... }",":&done = { ... }",":&quit = { ... }",":&tap = { ... }","*%_"],"r":"Mu"},"n":"tap"},{"n":"act","s":{"p":["&actor","*%others"],"r":"Mu"},"k":"m","m":0},{"n":"on-demand","s":{"p":["&producer",":&closing",":$scheduler = CurrentThreadScheduler","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"from-list","m":0,"k":"m","s":{"r":"Mu","p":["+@values",":$scheduler = CurrentThreadScheduler","*%_"]}},{"n":"interval","k":"m","m":0,"s":{"r":"Mu","p":["$interval","$delay = 0",":$scheduler = { ... }","*%_"]}},{"n":"serialize","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"sanitize","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["&on-close","*%_"],"r":"Mu"},"n":"on-close"},{"n":"map","s":{"p":["&mapper","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"grep","s":{"p":["Mu $test","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["Scheduler $scheduler","*%_"],"r":"Mu"},"k":"m","m":0,"n":"schedule-on"},{"n":"start","s":{"r":"Mu","p":["&startee","*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["$time",":$scheduler = { ... }","*%_"],"r":"Mu"},"n":"stable"},{"n":"delayed","s":{"r":"Mu","p":["$time",":$scheduler = { ... }","*%_"]},"k":"m","m":0},{"n":"do","m":0,"k":"m","s":{"r":"Mu","p":["&side-effect","*%_"]}},{"n":"flat","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*@s","*%_"],"r":"Mu"},"m":0,"k":"m","n":"merge"},{"n":"reduce","s":{"r":"Mu","p":["&with","*%_"]},"m":0,"k":"m"},{"n":"produce","m":0,"k":"m","s":{"r":"Mu","p":["&with","*%_"]}},{"n":"migrate","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["&mapper","*%_"],"r":"Mu"},"k":"m","m":1,"n":"classify"},{"n":"classify","k":"m","m":1,"s":{"p":["%mapper","*%_"],"r":"Mu"}},{"n":"classify","s":{"p":["@mapper","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"categorize","k":"m","m":1,"s":{"p":["&mapper","*%_"],"r":"Mu"}},{"s":{"p":["%mapper","*%_"],"r":"Mu"},"k":"m","m":1,"n":"categorize"},{"s":{"r":"Mu","p":["@mapper","*%_"]},"k":"m","m":1,"n":"categorize"},{"n":"Channel","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"Seq","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"Promise"},{"n":"wait","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"get-await-handle","s":{"r":"Awaitable::Handle","p":["*%_"]},"k":"m","m":0},{"n":"unique","k":"m","m":0,"s":{"p":[":&as",":&with",":$expires","*%_"],"r":"Mu"}},{"n":"squish","s":{"p":[":&as",":&with is copy","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["Int(Cool) :$elems = 0",":$seconds","*%_"]},"m":0,"k":"m","n":"batch"},{"s":{"p":[":$chomp = Bool::True","*%_"],"r":"Mu"},"k":"m","m":0,"n":"lines"},{"n":"words","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["$seconds?","*%_"],"r":"Mu"},"n":"elems"},{"n":"head","s":{"p":["Int(Cool) $number = 1","*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["Int(Cool) $number = 1","*%_"]},"n":"tail"},{"m":0,"k":"m","s":{"p":["Int(Cool) $number = 1","*%_"],"r":"Mu"},"n":"skip"},{"k":"m","m":0,"s":{"r":"Mu","p":["&by = { ... }","*%_"]},"n":"min"},{"k":"m","m":0,"s":{"p":["&by = { ... }","*%_"],"r":"Mu"},"n":"max"},{"n":"minmax","k":"m","m":0,"s":{"r":"Mu","p":["&by = { ... }","*%_"]}},{"s":{"r":"Mu","p":["&when_done","*%_"]},"m":0,"k":"m","n":"grab"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"reverse"},{"n":"zip","s":{"r":"Mu","p":["**@s",":&with","*%_"]},"m":0,"k":"m"},{"n":"zip-latest","s":{"r":"Mu","p":["**@s",":&with",":$initial","*%_"]},"k":"m","m":0},{"n":"throttle","s":{"p":["$elems","$seconds","$delay = 0",":$scheduler = { ... }",":$control",":$status",":$bleed",":$vent-at","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"throttle","s":{"p":["$elems","Callable:D $process","$delay = 0",":$scheduler = { ... }",":$control",":$status",":$bleed",":$vent-at","*%_"],"r":"Mu"},"k":"m","m":1},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"share"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"m":0,"k":"m","s":{"p":["&mapper",":$multi","*%_"],"r":"Mu"},"n":"!classify"}],"mro":["Awaitable","Any"],"a":[{"k":"v","n":"$!tappable","t":"Tappable"}],"d":"TITLE\nclass Supply\n\nSUBTITLE\nAsynchronous data stream with multiple subscribers\n\n    class Supply {}\n\nA supply is a thread-safe, asynchronous data stream like a Channel, but it\ncan have multiple subscribers (taps) that all get the same values flowing\nthrough the supply.\n\nIt is a thread-safe implementation of the Observer Pattern, and central to\nsupporting reactive programming in Raku.\n\nThere are two types of Supplies: live and on demand. When tapping into a\nlive supply, the tap will only see values that are flowing through the\nsupply after the tap has been created. Such supplies are normally infinite\nin nature, such as mouse movements. Closing such a tap does not stop mouse\nevents from occurring, it just means that the values will go by unseen. All\ntappers see the same flow of values.\n\nA tap on an on demand supply will initiate the production of values, and\ntapping the supply again may result in a new set of values. For example,\nSupply.interval produces a fresh timer with the appropriate interval each\ntime it is tapped. If the tap is closed, the timer simply stops emitting\nvalues to that tap.\n\nA live Supply is obtained from the Supplier factory method Supply. New\nvalues are emitted by calling emit on the Supplier object.\n\n    my $supplier = Supplier.new;\n    my $supply = $supplier.Supply;\n    $supply.tap(-> $v { say \"$v\" });\n    $supplier.emit(42); # Will cause the tap to output \"42\"\n\nThe live method returns True on live supplies. Factory methods such as\ninterval, from-list will return on demand supplies.\n\nA live Supply that keeps values until tapped the first time can be created\nwith Supplier::Preserving.\n\nFurther examples can be found in the concurrency page.\n\nMethods that return Taps\n\n  method tap\n\n    method tap(Supply:D: &emit = -> $ { },\n            :&done,\n            :&quit,\n            :&tap\n        --> Tap:D)\n\n\nCreates a new tap (a kind of subscription if you will), in addition to all\nexisting taps. The first positional argument is a piece of code that will\nbe called when a new value becomes available through the emit call.\n\nThe &done callback can be called in a number of cases: if a supply block is\nbeing tapped, when a done routine is reached; if a supply block is being\ntapped, it will be automatically triggered if the supply block reaches the\nend; if the done method is called on the parent Supplier (in the case of a\nsupply block, if there are multiple Suppliers referenced by whenever, they\nmust all have their done method invoked for this to trigger the &done\ncallback of the tap as the block will then reach its end).\n\nThe &quit callback is called if the tap is on a supply block which exits\nwith an error. It is also called if the quit method is invoked on the\nparent Supplier (in the case of a supply block any one Supplier quitting\nwith an uncaught exception will call the &quit callback as the block will\nexit with an error). The error is passed as a parameter to the callback.\n\nThe &tap callback is called once the Tap object is created, which is passed\nas a parameter to the callback. The callback is called ahead of\nemit/done/quit, providing a reliable way to get the Tap object. One case\nwhere this is useful is when the Supply begins emitting values\nsynchronously, since the call to .tap won't return the Tap object until it\nis done emitting, preventing it from being stopped if needed.\n\nMethod tap returns an object of type Tap, on which you can call the close\nmethod to cancel the subscription.\n\n    my $s = Supply.from-list(0 .. 5);\n    my $t = $s.tap(-> $v { say $v }, done => { say \"no more ticks\" });\n\nProduces:\n\n    0\n    1\n    2\n    3\n    4\n    5\n    no more ticks\n\n\n  method act\n\n    method act(Supply:D: &act --> Tap:D)\n\nCreates a tap on the given supply with the given code. Differently from\ntap, the given code is guaranteed to be only executed by one thread at a\ntime.\n\nUtility methods\n\n  method Capture\n\nDefined as:\n\n    method Capture(Supply:D --> Capture:D)\n\nEquivalent to calling .List.Capture on the invocant.\n\n  method Channel\n\n    method Channel(Supply:D: --> Channel:D)\n\nReturns a Channel object that will receive all future values from the\nsupply, and will be closed when the Supply is done, and quit (shut down\nwith error) when the supply is quit.\n\n  method Promise\n\n    method Promise(Supply:D: --> Promise:D)\n\nReturns a Promise that will be kept when the Supply is done. If the Supply\nalso emits any values, then the Promise will be kept with the final value.\nOtherwise, it will be kept with Nil. If the Supply ends with a quit instead\nof a done, then the Promise will be broken with that exception.\n\n    my $supplier = Supplier.new;\n    my $s = $supplier.Supply;\n    my $p = $s.Promise;\n    $p.then(-> $v { say \"got $v.result()\" });\n    $supplier.emit('cha');         # not output yet\n    $supplier.done();              # got cha\n\nThe Promise method is most useful when dealing with supplies that will tend\nto produce just one value, when only the final value is of interest, or\nwhen only completion (successful or not) is relevant.\n\n  method live\n\n    method live(Supply:D: --> Bool:D)\n\nReturns True if the supply is \"live\", that is, values are emitted to taps\nas soon as they arrive. Always returns True in the default Supply (but for\nexample on the supply returned from Supply.from-list it's False).\n\n    say Supplier.new.Supply.live;    # OUTPUT: «True␤»\n\n  method schedule-on\n\n    method schedule-on(Supply:D: Scheduler $scheduler)\n\nRuns the emit, done and quit callbacks on the specified scheduler.\n\nThis is useful for GUI toolkits that require certain actions to be run from\nthe GUI thread.\n\nMethods that wait until the supply is done\n\n  method wait\n\n    method wait(Supply:D:)\n\nTaps the Supply it is called on, and blocks execution until the either the\nsupply is done (in which case it evaluates to the final value that was\nemitted on the Supply, or Nil if not value was emitted) or quit (in which\ncase it will throw the exception that was passed to quit).\n\n    my $s = Supplier.new;\n    start {\n      sleep 1;\n      say \"One second: running.\";\n      sleep 1;\n      $s.emit(42);\n      $s.done;\n    }\n    $s.Supply.wait;\n    say \"Two seconds: done\";\n\n  method list\n\n    method list(Supply:D: --> List:D)\n\nTaps the Supply it is called on, and returns a lazy list that will be\nreified as the Supply emits values. The list will be terminated once the\nSupply is done. If the Supply quits, then an exception will be thrown once\nthat point in the lazy list is reached.\n\n  method grab\n\n    method grab(Supply:D: &when-done --> Supply:D)\n\nTaps the Supply it is called on. When it is done, calls &when-done and then\nemits the list of values that it returns on the result Supply. If the\noriginal Supply quits, then the exception is immediately conveyed on the\nreturn Supply.\n\n    my $s = Supply.from-list(4, 10, 3, 2);\n    my $t = $s.grab(&sum);\n    $t.tap(&say);           # OUTPUT: «19␤»\n\n  method reverse\n\n    method reverse(Supply:D: --> Supply:D)\n\nTaps the Supply it is called on. Once that Supply emits done, all of the\nvalues it emitted will be emitted on the returned Supply in reverse order.\nIf the original Supply quits, then the exception is immediately conveyed on\nthe return Supply.\n\n    my $s = Supply.from-list(1, 2, 3);\n    my $t = $s.reverse;\n    $t.tap(&say);           # OUTPUT: «3␤2␤1␤»\n\n  method sort\n\n    method sort(Supply:D: &custom-routine-to-use? --> Supply:D)\n\nTaps the Supply it is called on. Once that Supply emits done, all of the\nvalues that it emitted will be sorted, and the results emitted on the\nreturned Supply in the sorted order. Optionally accepts a comparator Block.\nIf the original Supply quits, then the exception is immediately conveyed on\nthe return Supply.\n\n    my $s = Supply.from-list(4, 10, 3, 2);\n    my $t = $s.sort();\n    $t.tap(&say);           # OUTPUT: «2␤3␤4␤10␤»\n\nMethods that return another Supply\n\n  method from-list\n\n    method from-list(Supply:U: +@values --> Supply:D)\n\nCreates an on-demand supply from the values passed to this method.\n\n    my $s = Supply.from-list(1, 2, 3);\n    $s.tap(&say);           # OUTPUT: «1␤2␤3␤»\n\n  method share\n\n    method share(Supply:D: --> Supply:D)\n\nCreates a live supply from an on-demand supply, thus making it possible to\nshare the values of the on-demand supply on multiple taps, instead of each\ntap seeing its own copy of all values from the on-demand supply.\n\n    # this says in turn: \"first 1\" \"first 2\" \"second 2\" \"first 3\" \"second 3\"\n    my $s = Supply.interval(1).share;\n    $s.tap: { \"first $_\".say };\n    sleep 1.1;\n    $s.tap: { \"second $_\".say };\n    sleep 2\n\n  method flat\n\n    method flat(Supply:D: --> Supply:D)\n\nCreates a supply on which all of the values seen in the given supply are\nflattened before being emitted again.\n\n  method do\n\n    method do(Supply:D: &do --> Supply:D)\n\nCreates a supply to which all values seen in the given supply, are emitted\nagain. The given code, executed for its side-effects only, is guaranteed to\nbe only executed by one thread at a time.\n\n  method on-close\n\n    method on-close(Supply:D: &on-close --> Supply:D)\n\nReturns a new Supply which will run &on-close whenever a Tap of that Supply\nis closed. This includes if further operations are chained on to the\nSupply. (for example, $supply.on-close(&on-close).map(*.uc)). When using a\nreact or supply block, using the CLOSE phaser is usually a better choice.\n\n    my $s = Supplier.new;\n    my $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n        -> $v { say \"the value is $v\" },\n        done    => { say \"Supply is done\" },\n        quit    => -> $ex { say \"Supply finished with error $ex\" },\n    );\n\n    $s.emit('Raku');\n    $tap.close;        # OUTPUT: «Tap closed␤»\n\n  method interval\n\n    method interval(Supply:U: $interval, $delay = 0, :$scheduler = $*SCHEDULER --> Supply:D)\n\nCreates a supply that emits a value every $interval seconds, starting\n$delay seconds from the call. The emitted value is an integer, starting\nfrom 0, and is incremented by one for each value emitted.\n\nImplementations may treat too-small values as lowest resolution they\nsupport, possibly warning in such situations; e.g. treating 0.0001 as\n0.001. For 6.d language version, the minimal value specified is 0.001.\n\n  method grep\n\n    method grep(Supply:D: Mu $test --> Supply:D)\n\nCreates a new supply that only emits those values from the original supply\nthat smartmatch against $test.\n\n    my $supplier = Supplier.new;\n    my $all      = $supplier.Supply;\n    my $ints     = $all.grep(Int);\n    $ints.tap(&say);\n    $supplier.emit($_) for 1, 'a string', 3.14159;   # prints only 1\n\n  method map\n\n    method map(Supply:D: &mapper --> Supply:D)\n\nReturns a new supply that maps each value of the given supply through\n&mapper and emits it to the new supply.\n\n    my $supplier = Supplier.new;\n    my $all      = $supplier.Supply;\n    my $double   = $all.map(-> $value { $value * 2 });\n    $double.tap(&say);\n    $supplier.emit(4);           # RESULT: «8»\n\n  method batch\n\n    method batch(Supply:D: :$elems, :$seconds --> Supply:D)\n\nCreates a new supply that batches the values of the given supply by either\nthe number of elements in the batch (using :elems) or the maximum number of\nseconds (using the :seconds) or both. Any remaining values are emitted in a\nfinal batch when the supply is done.\n\n  method elems\n\n    method elems(Supply:D: $seconds? --> Supply:D)\n\nCreates a new supply in which changes to the number of values seen are\nemitted. It optionally also takes an interval (in seconds) if you only want\nto be updated every so many seconds.\n\n  method head\n\n    method head(Supply:D: Int(Cool) $number = 1 --> Supply:D)\n\nCreates a \"head\" supply with the same semantics as List.head.\n\n    my $s = Supply.from-list(4, 10, 3, 2);\n    my $hs = $s.head(2);\n    $hs.tap(&say);           # OUTPUT: «4␤10␤»\n\n  method tail\n\n    method tail(Supply:D: Int(Cool) $number = 1 --> Supply:D)\n\nCreates a \"tail\" supply with the same semantics as List.tail.\n\n    my $s = Supply.from-list(4, 10, 3, 2);\n    my $ts = $s.tail(2);\n    $ts.tap(&say);           # OUTPUT: «3␤2␤»\n\n  method rotor\n\n    method rotor(Supply:D: @cycle --> Supply:D)\n\nCreates a \"rotoring\" supply with the same semantics as List.rotor.\n\n  method delayed\n\n    method delayed(Supply:D: $seconds, :$scheduler = $*SCHEDULER --> Supply:D)\n\nCreates a new supply in which all values flowing through the given supply\nare emitted, but with the given delay in seconds.\n\n  method throttle\n\n    method throttle(Supply:D:\n      $limit,                 # values / time or simultaneous processing\n      $seconds or $callable,  # time-unit / code to process simultaneously\n      $delay = 0,             # initial delay before starting, in seconds\n      :$control,              # supply to emit control messages on (optional)\n      :$status,               # supply to tap status messages from (optional)\n      :$bleed,                # supply to bleed messages to (optional)\n      :$vent-at,              # bleed when so many buffered (optional)\n      :$scheduler,            # scheduler to use, default $*SCHEDULER\n      --> Supply:D)\n\n\nProduces a Supply from a given Supply, but makes sure the number of\nmessages passed through, is limited.\n\nIt has two modes of operation: per time-unit or by maximum number of\nexecution of a block of code: this is determined by the second positional\nparameter.\n\nThe first positional parameter specifies the limit that should be applied.\n\nIf the second positional parameter is a Callable, then the limit indicates\nthe maximum number of parallel processes executing the Callable, which is\ngiven the value that was received. The emitted values in this case will be\nthe Promises that were obtained from starting the Callable.\n\nIf the second positional parameter is a numeric value, it is interpreted as\nthe time-unit (in seconds). If you specify .1 as the value, then it makes\nsure you don't exceed the limit for every tenth of a second.\n\nIf the limit is exceeded, then incoming messages are buffered until there\nis room to pass on / execute the Callable again.\n\nThe third positional parameter is optional: it indicates the number of\nseconds the throttle will wait before passing on any values.\n\nThe :control named parameter optionally specifies a Supply that you can use\nto control the throttle while it is in operation. Messages that can be\nsent, are strings in the form of \"key:value\". Please see below for the\ntypes of messages that you can send to control the throttle.\n\nThe :status named parameter optionally specifies a Supply that will receive\nany status messages. If specified, it will at least send one status message\nafter the original Supply is exhausted. See status message below.\n\nThe :bleed named parameter optionally specifies a Supply that will receive\nany values that were either explicitly bled (with the bleed control\nmessage), or automatically bled (if there's a vent-at active).\n\nThe :vent-at named parameter indicates the number of values that may be\nbuffered before any additional value will be routed to the :bleed Supply.\nDefaults to 0 if not specified (causing no automatic bleeding to happen).\nOnly makes sense if a :bleed Supply has also been specified.\n\nThe :scheduler named parameter indicates the scheduler to be used. Defaults\nto $*SCHEDULER.\n\n    control messages\n\nThese messages can be sent to the :control Supply. A control message\nconsists of a string of the form \"key: value\", e.g. \"limit: 4\".\n\n  * limit\n\nChange the number of messages (as initially given in the first positional)\nto the value given.\n\n  * bleed\n\nRoute the given number of buffered messages to the :bleed Supply.\n\n  * vent-at\n\nChange the maximum number of buffered values before automatic bleeding\ntakes place. If the value is lower than before, will cause immediate\nrerouting of buffered values to match the new maximum.\n\n  * status\n\nSend a status message to the :status Supply with the given id.\n\n    status message\n\nThe status return message is a hash with the following keys:\n\n  * allowed\n\nThe current number of messages / callables that is still allowed to be\npassed / executed.\n\n  * bled\n\nThe number of messages routed to the :bleed Supply.\n\n  * buffered\n\nThe number of messages currently buffered because of overflow.\n\n  * emitted\n\nThe number of messages emitted (passed through).\n\n  * id\n\nThe id of this status message (a monotonically increasing number). Handy if\nyou want to log status messages.\n\n  * limit\n\nThe current limit that is being applied.\n\n  * vent-at\n\nThe maximum number of messages that may be buffered before they're\nautomatically re-routed to the :bleed Supply.\n\n    Examples\n\nHave a simple piece of code announce when it starts running asynchronously,\nwait a random amount of time, then announce when it is done. Do this 6\ntimes, but don't let more than 3 of them run simultaneously.\n\n    my $s = Supply.from-list(^6);  # set up supply\n    my $t = $s.throttle: 3,        # only allow 3 at a time\n    {                              # code block to run\n        say \"running $_\";          # announce we've started\n        sleep rand;                # wait some random time\n        say \"done $_\"              # announce we're done\n    }                              # don't need ; because } at end of line\n    $t.wait;                       # wait for the supply to be done\n\nand the result of one run will be:\n\n    running 0\n    running 1\n    running 2\n    done 2\n    running 3\n    done 1\n    running 4\n    done 4\n    running 5\n    done 0\n    done 3\n    done 5\n\n\n  method stable\n\n    method stable(Supply:D: $time, :$scheduler = $*SCHEDULER --> Supply:D)\n\nCreates a new supply that only passes on a value flowing through the given\nsupply if it wasn't superseded by another value in the given $time (in\nseconds). Optionally uses another scheduler than the default scheduler,\nusing the :scheduler parameter.\n\nTo clarify the above, if, during the timeout $time, additional values are\nemitted to the Supplier all but the last one will be thrown away. Each time\nan additional value is emitted to the Supplier, during the timeout, $time\nis reset.\n\nThis method can be quite useful when handling UI input, where it is not\ndesired to perform an operation until the user has stopped typing for a\nwhile rather than on every keystroke.\n\n    my $supplier = Supplier.new;\n    my $supply1 = $supplier.Supply;\n    $supply1.tap(-> $v { say \"Supply1 got: $v\" });\n    $supplier.emit(42);\n\n    my Supply $supply2 = $supply1.stable(5);\n    $supply2.tap(-> $v { say \"Supply2 got: $v\" });\n    sleep(3);\n    $supplier.emit(43);  # will not be seen by $supply2 but will reset $time\n    $supplier.emit(44);\n    sleep(10);\n    # OUTPUT: «Supply1 got: 42␤Supply1 got: 43␤Supply1 got: 44␤Supply2 got: 44␤»\n\n\nAs can be seen above, $supply1 received all values emitted to the Supplier\nwhile $supply2 only received one value. The 43 was thrown away because it\nwas followed by another 'last' value 44 which was retained and sent to\n$supply2 after approximately eight seconds, this due to the fact that the\ntimeout $time was reset after three seconds.\n\n  method reduce\n\n    method reduce(Supply:D: &with --> Supply:D)\n\nCreates a \"reducing\" supply with the same semantics as List.reduce.\n\n    my $supply = Supply.from-list(1..5).reduce({$^a + $^b});\n    $supply.tap(-> $v { say \"$v\" }); # OUTPUT: «15␤»\n\n  method produce\n\n    method produce(Supply:D: &with --> Supply:D)\n\nCreates a \"producing\" supply with the same semantics as List.produce.\n\n    my $supply = Supply.from-list(1..5).produce({$^a + $^b});\n    $supply.tap(-> $v { say \"$v\" }); # OUTPUT: «1␤3␤6␤10␤15␤»\n\n  method lines\n\n    method lines(Supply:D: :$chomp = True --> Supply:D)\n\nCreates a supply that will emit the characters coming in line by line from\na supply that's usually created by some asynchronous I/O operation. The\noptional :chomp parameter indicates whether to remove line separators: the\ndefault is True.\n\n  method words\n\n    method words(Supply:D: --> Supply:D)\n\nCreates a supply that will emit the characters coming in word for word from\na supply that's usually created by some asynchronous I/O operation.\n\n    my $s = Supply.from-list(\"Hello Word!\".comb);\n    my $ws = $s.words;\n    $ws.tap(&say);           # OUTPUT: «Hello␤Word!␤»\n\n  method unique\n\n    method unique(Supply:D: :$as, :$with, :$expires --> Supply:D)\n\nCreates a supply that only provides unique values, as defined by the\noptional :as and :with parameters (same as with List.unique). The optional\n:expires parameter how long to wait (in seconds) before \"resetting\" and not\nconsidering a value to have been seen, even if it's the same as an old\nvalue.\n\n  method squish\n\n    method squish(Supply:D: :$as, :$with --> Supply:D)\n\nCreates a supply that only provides unique values, as defined by the\noptional :as and :with parameters (same as with List.squish).\n\n  method max\n\n    method max(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)\n\nCreates a supply that only emits values from the given supply if they are\nlarger than any value seen before. In other words, from a continuously\nascending supply it will emit all the values. From a continuously\ndescending supply it will only emit the first value. The optional parameter\nspecifies the comparator, just as with Any.max.\n\n  method min\n\n    method min(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)\n\nCreates a supply that only emits values from the given supply if they are\nsmaller than any value seen before. In other words, from a continuously\ndescending supply it will emit all the values. From a continuously\nascending supply it will only emit the first value. The optional parameter\nspecifies the comparator, just as with Any.min.\n\n  method minmax\n\n    method minmax(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)\n\nCreates a supply that emits a Range every time a new minimum or maximum\nvalues is seen from the given supply. The optional parameter specifies the\ncomparator, just as with Any.minmax.\n\n  method skip\n\n    method skip(Supply:D: Int(Cool) $number = 1 --> Supply:D)\n\nReturns a new Supply which will emit all values from the given Supply\nexcept for the first $number values, which will be thrown away.\n\n    my $supplier = Supplier.new;\n    my $supply = $supplier.Supply;\n    $supply = $supply.skip(3);\n    $supply.tap({ say $_ });\n    $supplier.emit($_) for 1..10; # OUTPUT: «4␤5␤6␤7␤8␤9␤10␤»\n\n\n  method start\n\n    method start(Supply:D: &startee --> Supply:D)\n\nCreates a supply of supplies. For each value in the original supply, the\ncode object is scheduled on another thread, and returns a supply either of\na single value (if the code succeeds), or one that quits without a value\n(if the code fails).\n\nThis is useful for asynchronously starting work that you don't block on.\n\nUse migrate to join the values into a single supply again.\n\n  method migrate\n\n    method migrate(Supply:D: --> Supply:D)\n\nTakes a Supply which itself has values that are of type Supply as input.\nEach time the outer Supply emits a new Supply, this will be tapped and its\nvalues emitted. Any previously tapped Supply will be closed. This is useful\nfor migrating between different data sources, and only paying attention to\nthe latest one.\n\nFor example, imagine an application where the user can switch between\ndifferent stocks. When they switch to a new one, a connection is\nestablished to a web socket to get the latest values, and any previous\nconnection should be closed. Each stream of values coming over the web\nsocket would be represented as a Supply, which themselves are emitted into\na Supply of latest data sources to watch. The migrate method could be used\nto flatten this supply of supplies into a single Supply of the current\nvalues that the user cares about.\n\nHere is a simple simulation of such a program:\n\n    my Supplier $stock-sources .= new;\n\n    sub watch-stock($symbol) {\n        $stock-sources.emit: supply {\n            say \"Starting to watch $symbol\";\n            whenever Supply.interval(1) {\n                emit \"$symbol: 111.\" ~ 99.rand.Int;\n            }\n            CLOSE say \"Lost interest in $symbol\";\n        }\n    }\n\n    $stock-sources.Supply.migrate.tap: *.say;\n\n    watch-stock('GOOG');\n    sleep 3;\n    watch-stock('AAPL');\n    sleep 3;\n\n\nWhich produces output like:\n\n    Starting to watch GOOG\n    GOOG: 111.67\n    GOOG: 111.20\n    GOOG: 111.37\n    Lost interest in GOOG\n    Starting to watch AAPL\n    AAPL: 111.55\n    AAPL: 111.6\n    AAPL: 111.6\n\n\nMethods that combine supplies\n\n  method merge\n\n    method merge(Supply @*supplies --> Supply:D)\n\nCreates a supply to which any value seen from the given supplies, is\nemitted. The resulting supply is done Only when all given supplies are\ndone. Can also be called as a class method.\n\n  method zip\n\n    method zip(Supply @*supplies, :&with = &[,] --> Supply:D)\n\nCreates a supply that emits combined values as soon as there is a new value\nseen on all of the supplies. By default, Lists are created, but this can be\nchanged by specifying your own combiner with the :with parameter. The\nresulting supply is done as soon as any of the given supplies are done. Can\nalso be called as a class method.\n\n  method zip-latest\n\n    method zip-latest(Supply @*supplies, :&with = &[,], :$initial --> Supply:D)\n\nCreates a supply that emits combined values as soon as there is a new value\nseen on any of the supplies. By default, Lists are created, but this can be\nchanged by specifying your own combiner with the :with parameter. The\noptional :initial parameter can be used to indicate the initial state of\nthe combined values. By default, all supplies have to have at least one\nvalue emitted on them before the first combined values is emitted on the\nresulting supply. The resulting supply is done as soon as any of the given\nsupplies are done. Can also be called as a class method.\n\nI/O features exposed as supplies\n\n  sub signal\n\n    sub signal(*@signals, :$scheduler = $*SCHEDULER)\n\nCreates a supply for the Signal enums (such as SIGINT) specified, and an\noptional :scheduler parameter. Any signals received, will be emitted on the\nsupply. For example:\n\n    signal(SIGINT).tap( { say \"Thank you for your attention\"; exit 0 } );\n\nwould catch Control-C, thank you, and then exit.\n\nTo go from a signal number to a Signal, you can do something like this:\n\n    signal(Signal(2)).tap( -> $sig { say \"Received signal: $sig\" } );\n\nThe list of supported signals can be found by checking Signal::.keys (as\nyou would any enum). For more details on how enums work see enum.\n\nNote: Rakudo versions up to 2018.05 had a bug due to which numeric values\nof signals were incorrect on some systems. For example, Signal(10) was\nreturning SIGBUS even if it was actually SIGUSR1 on a particular system.\nThat being said, using signal(SIGUSR1) was working as expected on all\nRakudo versions except 2018.04, 2018.04.1 and 2018.05, where the intended\nbehavior can be achieved by using signal(SIGBUS) instead. These issues are\nresolved in Rakudo releases after 2018.05.\n\n  method IO::Notification.watch-path\n\n    method watch-path($path --> Supply:D)\n\n\nCreates a supply to which the OS will emit values to indicate changes on\nthe filesystem for the given path. Also has a shortcut with the watch\nmethod on an IO object, like this:\n\n    IO::Notification.watch-path(\".\").act( { say \"$^file changed\" } );\n    \".\".IO.watch.act(                     { say \"$^file changed\" } );   # same\n","t":"Supply","n":"Supply"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(cont)>"},{"n":"infix:<(cont)>","s":{"r":"Bool:D","p":["\\a","\\b"]},"m":1,"k":"s"},{"k":"v","t":"Sub+{is-pure}","n":"&roots"},{"s":{"r":"Mu","p":["$x","Cool $n"]},"k":"s","m":1,"n":"roots"},{"n":"roots","s":{"r":"Mu","p":["$x","Numeric $n"]},"k":"s","m":1},{"k":"v","n":"&prefix:<−>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","m":1,"s":{"p":["\\a"],"r":"Mu"},"n":"prefix:<->"},{"s":{"r":"Mu","p":["Real:D \\a"]},"m":1,"k":"s","n":"prefix:<->"},{"n":"prefix:<->","s":{"p":["Int:D \\a"],"r":"Int:D"},"k":"s","m":1},{"n":"prefix:<->","s":{"r":"int","p":["int $a"]},"k":"s","m":1},{"n":"prefix:<->","s":{"r":"Mu","p":["Num:D \\a"]},"k":"s","m":1},{"s":{"p":["num $a"],"r":"num"},"k":"s","m":1,"n":"prefix:<->"},{"s":{"r":"Rat:D","p":["Rat:D \\a"]},"m":1,"k":"s","n":"prefix:<->"},{"m":1,"k":"s","s":{"p":["FatRat:D \\a"],"r":"FatRat:D"},"n":"prefix:<->"},{"n":"prefix:<->","s":{"r":"Complex:D","p":["Complex:D \\a"]},"m":1,"k":"s"},{"n":"prefix:<->","k":"s","m":1,"s":{"p":["Duration:D $a"],"r":"Duration:D"}},{"k":"v","t":"Sub","n":"&chop"},{"s":{"p":["Cool:D $s"],"r":"Str:D"},"m":1,"k":"s","n":"chop"},{"n":"chop","k":"s","m":1,"s":{"r":"Str:D","p":["Cool:D $s","$n"]}},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊄>","k":"v"},{"n":"infix:<⊄>","s":{"r":"Bool:D","p":["\\a","\\b"]},"k":"s","m":1},{"t":"Signal","n":"SIGBREAK","k":"e"},{"b":"A","mro":["Blob[uint16]","Positional[uint16]","Stringy","Any"],"m":[{"n":"encoding","k":"m","m":0,"s":{"r":"Str","p":["*%_"]}},{"n":"!spread","k":"m","m":0,"s":{"r":"Mu","p":["\\to","\\from","*%_"]}},{"n":"!fail-range","m":0,"k":"m","s":{"p":["$got","*%_"],"r":"Mu"}},{"n":"!push-list","s":{"r":"Mu","p":["\\action","\\to","\\from","*%_"]},"m":0,"k":"m"},{"s":{"p":["$action","$got","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!fail-typecheck"},{"n":"!fail-typecheck-element","k":"m","m":0,"s":{"r":"Mu","p":["\\action","\\i","\\got","*%_"]}},{"n":"!unshift-list","m":0,"k":"m","s":{"r":"Mu","p":["\\action","\\to","\\from","*%_"]}}],"k":"c","n":"utf16","t":"utf16"},{"b":"C","n":"Grammar","a":[{"k":"v","t":"List","n":"@!list"},{"k":"v","t":"Hash","n":"%!hash"}],"d":"TITLE\nclass Grammar\n\nSUBTITLE\nFormal grammar made up of named regexes\n\n    class Grammar is Match {}\n\nEvery type declared with grammar and not explicitly stating its superclass,\nbecomes a subclass of Grammar.\n\n    grammar Identifier {\n        token TOP       { <initial> <rest>* }\n        token initial   { <+myletter +[_]> }\n        token rest      { <+myletter +mynumber +[_]> }\n        token myletter  { <[A..Za..z]> }\n        token mynumber  { <[0..9]> }\n    }\n\n    say Identifier.isa(Grammar);                # OUTPUT: «True␤»\n    my $match = Identifier.parse('W4anD0eR96');\n    say ~$match;                                # OUTPUT: «W4anD0eR96␤»\n\nMore documentation on grammars is available.\n\n","t":"Grammar","mro":["NQPMatchRole","Match"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["\\target",":$rule",":$args","Mu :$actions",":$filename","*%_"]},"d":"Defined as:\n\n    method parse($target, :$rule = 'TOP',  Capture() :$args = \\(), Mu :$actions = Mu, *%opt)\n\nParses the $target, which will be coerced to Str if it isn't one, using\n$rule as the starting rule. Additional $args will be passed to the starting\nrule if provided.\n\n    grammar RepeatChar {\n        token start($character) { $character+ }\n    }\n\n    say RepeatChar.parse('aaaaaa', :rule('start'), :args(\\('a')));\n    say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')));\n\n    # OUTPUT:\n    # ｢aaaaaa｣\n    # ｢bbbbbb｣\n\nIf the action named argument is provided, it will be used as an action\nobject, that is, for each successful regex match, a method of the same\nname, if it exists, is called on the action object, passing the match\nobject as the sole positional argument.\n\n    my $actions = class { method TOP($/) { say \"7\" } };\n    grammar { token TOP { a { say \"42\" } b } }.parse('ab', :$actions);\n    # OUTPUT : «42␤7␤»\n\nAdditional named arguments are used as options for matching, so you can\nspecify things like :pos(4) to start parsing from the fourth (zero-base)\ncharacter. All matching adverbs are allowed, but not all of them take\neffect. There are several types of adverbs that a regex can have, some of\nwhich apply at compile time, like :s and :i. You cannot pass those to\n.parse, because the regexes have already been compiled. But, you can pass\nthose adverbs that affect the runtime behavior, such as :pos and\n:continue.\n\n    say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')), :pos(4)).Str;\n    # OUTPUT : «bb␤»\n\n\nMethod parse only succeeds if the cursor has arrived at the end of the\ntarget string when the match is over. Use method subparse if you want to be\nable to stop in the middle.\n\nReturns a Match object on success, and Nil on failure.","n":"parse"},{"d":"Defined as:\n\n    method subparse($target, :$rule = 'TOP', Capture() :$args = \\(),  Mu :$actions = Mu, *%opt)\n\nDoes exactly the same as method parse, except that cursor doesn't have to\nreach the end of the string to succeed. That is, it doesn't have to match\nthe whole string.\n\nNote that unlike method parse, subparse always returns a Match object,\nwhich will be a failed match (and thus falsy), if the grammar failed to\nmatch.\n\n    grammar RepeatChar {\n        token start($character) { $character+ }\n    }\n\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('b')));\n    say RepeatChar.parse('bbbabb', :rule('start'), :args(\\('b')));\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')));\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')), :pos(3));\n\n\n    # OUTPUT:\n    # ｢bbb｣\n    # Nil\n    # #<failed match>\n    # ｢a｣","n":"subparse","k":"m","m":0,"s":{"r":"Mu","p":["\\target",":$rule",":$args",":$actions","*%_"]}},{"d":"Defined as:\n\n    method parsefile(Str(Cool) $filename, :$enc, *%opts)\n\nReads file $filename encoding by $enc, and parses it. All named arguments\nare passed on to method parse.\n\n    grammar Identifiers {\n        token TOP        { [<identifier><.ws>]+ }\n        token identifier { <initial> <rest>* }\n        token initial    { <+myletter +[_]> }\n        token rest       { <+myletter +mynumber +[_]> }\n        token myletter   { <[A..Za..z]> }\n        token mynumber   { <[0..9]> }\n    }\n\n    say Identifiers.parsefile('users.txt', :enc('UTF-8'))\n        .Str.trim.subst(/\\n/, ',', :g);\n\n    # users.txt :\n    # TimToady\n    # lizmat\n    # jnthn\n    # moritz\n    # zoffixznet\n    # MasterDuke17\n\n    # OUTPUT : «TimToady,lizmat,jnthn,moritz,zoffixznet,MasterDuke17␤»","n":"parsefile","k":"m","m":0,"s":{"p":["Str(Cool) $filename",":$enc","*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}]},{"t":"SeekType","n":"SeekFromEnd","k":"e"},{"n":"&acosec","t":"Sub+{is-pure}","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["Numeric \\x"]},"n":"acosec"},{"n":"acosec","m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"}},{"s":{"r":"Mu","p":["Num:D \\x"]},"k":"s","m":1,"n":"acosec"},{"n":"&asinh","t":"Sub+{is-pure}","k":"v"},{"s":{"r":"Mu","p":["Numeric \\x"]},"k":"s","m":1,"n":"asinh"},{"m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"},"n":"asinh"},{"s":{"r":"num","p":["num $x"]},"k":"s","m":1,"n":"asinh"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<+>"},{"s":{"r":"Mu","p":["\\a"]},"k":"s","m":1,"n":"prefix:<+>"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<÷>","k":"v"},{"n":"infix:</>","s":{"r":"Mu","p":[]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["$x"]},"n":"infix:</>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:</>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"n":"infix:</>"},{"n":"infix:</>","s":{"p":["Num:D \\a","Num:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:</>","s":{"p":["num $a","num $b"],"r":"num"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Range:D \\r","Real:D \\v"]},"k":"s","m":1,"n":"infix:</>"},{"n":"infix:</>","k":"s","m":1,"s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Mu"}},{"n":"infix:</>","k":"s","m":1,"s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Mu"}},{"n":"infix:</>","s":{"r":"Mu","p":["Int:D \\a","Rational:D \\b"]},"m":1,"k":"s"},{"n":"infix:</>","k":"s","m":1,"s":{"r":"Mu","p":["Int:D \\a","Int:D \\b"]}},{"s":{"r":"Complex:D","p":["Complex:D \\a","Complex:D \\b"]},"m":1,"k":"s","n":"infix:</>"},{"k":"s","m":1,"s":{"p":["Complex:D \\a","Real \\b"],"r":"Complex:D"},"n":"infix:</>"},{"n":"infix:</>","s":{"r":"Complex:D","p":["Real \\a","Complex:D \\b"]},"m":1,"k":"s"},{"mro":["Systemic","Any"],"m":[{"n":"BUILD","k":"s","m":0,"s":{"r":"Nil","p":[":name($!name) = \"rakudo\"",":auth($!auth) = \"The Perl Foundation\"",":$version",":$release",":$codename","*%_"]}},{"d":"method verbose-config(:$say)\n\nIf $say is True, it prints the different items included in the\nconfiguration of the compiler; if it is not, returns a Hash with the same\ninformation.\n\n    say $*PERL.compiler.verbose-config; # OUTPUT: «distro::auth=https://www.opensuse.org/␤distro::desc=2018-05-06T09:19:17.571307+02:00␤» ... And the rest of the configuration\n\nSee Also: Systemic","n":"verbose-config","m":0,"k":"m","s":{"r":"Mu","p":[":$say","*%_"]}},{"d":"Returns an unique identifier, a long hexadecimal string","n":"id","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"release","d":"It's empty, but it might contain the release number for specific releases."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"It's empty, but it might contain the codename for specific releases.","n":"codename"},{"n":"name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"auth"},{"n":"version","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"signature"},{"n":"desc","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"Compiler","a":[{"t":"Str","n":"$.id","k":"v"},{"t":"Str","n":"$.release","k":"v"},{"n":"$.codename","t":"Str","k":"v"},{"n":"$.name","t":"Str","k":"v"},{"k":"v","n":"$.auth","t":"Str"},{"k":"v","n":"$.version","t":"Version"},{"t":"Blob","n":"$.signature","k":"v"},{"t":"Str","n":"$.desc","k":"v"}],"d":"TITLE\nclass Compiler\n\nSUBTITLE\nInformation related to the compiler that is being used\n\n    class Compiler does Systemic {}\n\nBuilt-in class for providing compiler related information. Usually accessed\nthrough the compiler attribute of the $*PERL dynamic variable.\n\n    say $*PERL.compiler; # OUTPUT: «rakudo (2019.03.1.385.ga.643.b.8.be.1)␤»\n\n","t":"Compiler","b":"A"},{"k":"v","n":"&uniprops","t":"Sub"},{"s":{"p":["Str:D $str","Stringy:D $propname = \"General_Category\""],"r":"Mu"},"k":"s","m":1,"n":"uniprops"},{"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["Junction:D \\a","Junction:D \\b","*%_"]},"n":"INFIX-TWO"},{"k":"m","m":1,"s":{"r":"Mu","p":["\\values","Str :$type!","*%_"]},"d":"Defined as:\n\n    multi method new(Junction: \\values, Str :$type!)\n    multi method new(Junction: Str:D \\type, \\values)\n\nConstructor to define a new Junction from the type that defines de Junction\nand a set of values.\n\n    my $j = Junction.new(<Þor Oðinn Loki>, type => \"all\");\n    my $n = Junction.new( \"one\", 1..6 )","n":"new"},{"n":"new","d":"Defined as:\n\n    multi method new(Junction: \\values, Str :$type!)\n    multi method new(Junction: Str:D \\type, \\values)\n\nConstructor to define a new Junction from the type that defines de Junction\nand a set of values.\n\n    my $j = Junction.new(<Þor Oðinn Loki>, type => \"all\");\n    my $n = Junction.new( \"one\", 1..6 )","s":{"r":"Mu","p":["Str:D \\type","\\values","*%_"]},"k":"m","m":1},{"n":"CALL-ME","s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0},{"n":"sink","s":{"r":"Nil","p":["*%_"]},"m":0,"k":"m"},{"n":"THREAD","s":{"p":["&call","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"AUTOTHREAD","k":"m","m":0,"s":{"p":["&call","|args is raw"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["\\type","\\values","*%_"],"r":"Mu"},"n":"!SET-SELF"}],"k":"c","mro":["Mu"],"a":[{"k":"v","t":"Mu","n":"$!storage"},{"n":"$!type","t":"str","k":"v"}],"d":"TITLE\nclass Junction\n\nSUBTITLE\nLogical superposition of values\n\n    class Junction is Mu { }\n\nA junction is an unordered composite value of zero or more values.\nJunctions autothread over many operations, which means that the operation\nis carried out for each junction element (also known as eigenstate), and\nthe result is junction of the return values of all those operators.\n\nJunctions collapse into a single value in boolean context, so when used in\na conditional, a negation or an explicit coercion to Bool through the so or\n? prefix operators. The semantics of this collapse depend on the junction\ntype, which can be all, any, one or none.\n\n  type  constructor  operator  True if ...\n  all   all          &         no value evaluates to False\n  any   any          |         at least one value evaluates to True\n  one   one          ^         exactly one value evaluates to True\n  none  none                   no value evaluates to True\n\n\nAs the table shows, in order to create junctions, you use the string that\nrepresents the type followed by any object, or else call .all, .none or\n.one on the object.\n\n    say so 3 == (1..30).one;         # OUTPUT: «True␤»\n    say so (\"a\" ^ \"b\" ^ \"c\") eq \"a\"; # OUTPUT: «True␤»\n\nJunctions are very special objects. They fall outside the Any hierarchy,\nbeing only, as any other object, subclasses of Mu. That enables a feature\nfor most methods: autothreading. Autothreading happens when a junction is\nbound to a parameter of a code object that doesn't accept values of type\nJunction. Instead of producing an error, the signature binding is repeated\nfor each value of the junction.\n\nExample:\n\n    my $j = 1|2;\n    if 3 == $j + 1 {\n        say 'yes';\n    }\n\nFirst autothreads over the infix:<+>  operator, producing the Junction 2|3.\nThe next autothreading step is over infix:<==> , which produces False|True.\nThe if conditional evaluates the junction in boolean context, which\ncollapses it to True. So the code prints yes\\n.\n\nThe type of a Junction does not affect the number of items in the resultant\nJunction after autothreading. For example, using a one Junction during Hash\nkey lookup, still results in a Junction with several items. It is only in\nboolean context would the type of the Junction come into play:\n\n    my %h = :42foo, :70bar;\n    say    %h{one <foo meow>}:exists; # OUTPUT: «one(True, False)␤»\n    say so %h{one <foo meow>}:exists; # OUTPUT: «True␤»\n    say    %h{one <foo  bar>}:exists; # OUTPUT: «one(True, True)␤»\n    say so %h{one <foo  bar>}:exists; # OUTPUT: «False␤»\n\nNote that the compiler is allowed, but not required, to parallelize\nautothreading (and Junction behavior in general), so it is usually an error\nto autothread junctions over code with side effects.\n\nAutothreading implies that the function that's autothreaded will also\nreturn a Junction of the values that it would usually return.\n\n    (1..3).head( 2|3 ).say; # OUTPUT: «any((1 2), (1 2 3))␤»\n\nSince .head returns a list, the autothreaded version returns a Junction of\nlists.\n\n    (1..3).contains( 2&3 ).say; # OUTPUT: «all(True, True)␤»\n\nLikewise, .contains returns a Boolean; thus, the autothreaded version\nreturns a Junction of Booleans. In general, all methods and routines that\ntake an argument of type T and return type TT, will also accept junctions\nof T, returning junctions of TT.\n\nImplementations are allowed to short-circuit Junctions. For example one or\nmore routine calls (a(), b(), or c()) in the code below might not get\nexecuted at all, if the result of the conditional has been fully determined\nfrom routine calls already performed (only one truthy return value is\nenough to know the entire Junction is true):\n\n    if a() | b() | c() {\n        say \"At least one of the routines was called and returned a truthy value\"\n    }\n\n\nJunctions are meant to be used as matchers in boolean context;\nintrospection of junctions is not supported. If you feel the urge to\nintrospect a junction, use a Set or a related type instead.\n\nUsage examples:\n\n    my @list = <1 2 \"Great\">;\n    @list.append(True).append(False);\n    my @bool_or_int = grep Bool|Int, @list;\n\n    sub is_prime(Int $x) returns Bool {\n        # 'so' is for boolean context\n        so $x %% none(2..$x.sqrt);\n    }\n    my @primes_ending_in_1 = grep &is_prime & / 1$ /, 2..100;\n    say @primes_ending_in_1;        # OUTPUT: «[11 31 41 61 71]␤»\n\n    my @exclude = <~ .git>;\n    for dir(\".\") { say .Str if .Str.ends-with(none @exclude) }\n\nSpecial care should be taken when using all with arguments that may produce\nan empty list:\n\n    my @a = ();\n    say so all(@a) # True, because there are 0 False's\n\nTo express \"all, but at least one\", you can use @a && all(@a)\n\n    my @a = ();\n    say so @a && all(@a);   # OUTPUT: «False␤»\n\nNegated operators are special-cased when it comes to autothreading. $a !op\n$b is rewritten internally as !($a op $b). The outer negation collapses any\njunctions, so the return value always a plain Bool.\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word !eq any @negations {\n        say '\"yes\" is not a negation';\n    }\n\nNote that without this special-casing, an expression like $word ne any\n@words would always evaluate to True for non-trivial lists on one side.\n\nFor this purpose, infix:<ne>  counts as a negation of infix:<eq> .\n\nIn general it is more readable to use a positive comparison operator and a\nnegated junction:\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word eq none @negations {\n        say '\"yes\" is not a negation';\n    }\n\nFailures and exceptions\n\nFailures are just values like any other, as far as Junctions are\nconcerned:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    my @list = gather for $j -> $e {\n        take $e if $e.defined;\n    }\n    @list.say; # OUTPUT: «[42 2.1]␤»\n\nAbove, we've used prefix + operator on a Junction to coerce the strings\ninside of it to Numeric. Since the operator returns a Failure when a Str\nthat doesn't contain a number gets coerced to Numeric, one of the elements\nin the Junction is a Failure. Failures do not turn into exceptions until\nthey are used or sunk, but we can check for definedness to avoid that. That\nis what we do in the loop that runs over the elements of the junction,\nadding them to a list only if they are defined.\n\nThe exception will be thrown, if you try to use the Failure as a value—just\nlike as if this Failure were on its own and not part of the Junction:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    try say $j == 42;\n    $! and say \"Got exception: $!.^name()\";\n    # OUTPUT: «Got exception: X::Str::Numeric␤»\n\n\nNote that if an exception gets thrown when any of the values in a Junction\nget computed, it will be thrown just as if the problematic value were\ncomputed on its own and not with a Junction; you can't just compute the\nvalues that work while ignoring exceptions:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    say try calc $j; # OUTPUT: «Nil␤»\n\nOnly one value above causes an exception, but the result of the try block\nis still a Nil. A possible way around it is to cheat and evaluate the\nvalues of the Junction individually and then re-create the Junction from\nthe result:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    $j = any (gather $j».take).grep: {Nil !=== try calc $_};\n    say so $j == 42; # OUTPUT: «True␤»\n\nSmartmatching\n\nNote that using Junctions on the right-hand side of ~~ works slightly\ndifferently than using Junctions with other operators.\n\nConsider this example:\n\n    say 25 == (25 | 42);    # OUTPUT: «any(True, False)␤» – Junction\n    say 25 ~~ (25 | 42);    # OUTPUT: «True␤»             – Bool\n\nThe reason is that == (and most other operators) are subject to\nauto-threading, and therefore you will get a Junction as a result. On the\nother hand, ~~ will call .ACCEPTS on the right-hand-side (in this case on a\nJunction) and the result will be a Bool.\n\n","t":"Junction","n":"Junction","b":"M"},{"k":"e","t":"ProtocolFamily","n":"PF_MAX"},{"t":"Sub+{is-pure}","n":"&sqrt","k":"v"},{"n":"sqrt","m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Cool \\x"]},"n":"sqrt"},{"k":"s","m":1,"s":{"r":"num","p":["num $a"]},"n":"sqrt"},{"n":"&cas","t":"Sub","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["$target is rw","\\expected","\\value"]},"n":"cas"},{"n":"cas","s":{"r":"Mu","p":["$target is rw","&code"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["atomicint $target is rw","int $expected","int $value"]},"n":"cas"},{"n":"cas","s":{"p":["atomicint $target is rw","Int:D $expected","Int:D $value"],"r":"Mu"},"m":1,"k":"s"},{"n":"cas","k":"s","m":1,"s":{"p":["atomicint $target is rw","$expected","$value"],"r":"Mu"}},{"n":"cas","m":1,"k":"s","s":{"p":["atomicint $target is rw","&code"],"r":"Mu"}},{"t":"Sub","n":"&dd","k":"v"},{"m":0,"k":"s","s":{"r":"Mu","p":["|"]},"n":"dd"},{"t":"int8","n":"int8","k":"n"},{"n":"Regex","t":"Regex","a":[{"k":"v","t":"Mu","n":"$!caps"},{"k":"v","n":"$!nfa","t":"Mu"},{"k":"v","n":"%!alt_nfas","t":"Hash"},{"k":"v","n":"$!source","t":"str"},{"k":"v","n":"$!topic","t":"Mu"},{"t":"Mu","n":"$!slash","k":"v"},{"n":"@!dispatchees","t":"List","k":"v"},{"k":"v","t":"Mu","n":"$!dispatcher_cache"},{"t":"Mu","n":"$!dispatcher","k":"v"},{"n":"$!rw","t":"int","k":"v"},{"t":"Mu","n":"$!inline_info","k":"v"},{"t":"int","n":"$!yada","k":"v"},{"k":"v","t":"Mu","n":"$!package"},{"k":"v","n":"$!onlystar","t":"int"},{"k":"v","t":"List","n":"@!dispatch_order"},{"k":"v","t":"Mu","n":"$!dispatch_cache"},{"n":"$!why","t":"Mu","k":"v"},{"n":"$!do","t":"Code","k":"v"},{"n":"$!signature","t":"Signature","k":"v"},{"k":"v","n":"@!compstuff","t":"List"}],"d":"TITLE\nclass Regex\n\nSUBTITLE\nString pattern\n\n    class Regex is Method { }\n\nA regex is a kind of pattern that describes a set of strings. The process\nof finding out whether a given string is in the set is called matching. The\nresult of such a matching is a Match object, which evaluates to True in\nboolean context if the string is in the set.\n\nA regex is typically constructed by a regex literal\n\n    rx/ ^ab /;      # describes all strings starting with 'ab'\n    / ^ ab /;       # same\n    rx/ \\d ** 2/;   # describes all strings containing at least two digits\n\n A named regex can be defined with the regex declarator followed by its\ndefinition in curly braces. Since any regex does Callable introspection\nrequires referencing via &-sigil.\n\n    my regex R { \\N };\n    say &R.^name; # OUTPUT: «Regex␤»\n\nTo match a string against a regex, you can use the smartmatch operator:\n\n    my $match = 'abc' ~~ rx/ ^ab /;\n    say $match.Bool;                # OUTPUT: «True␤»\n    say $match.orig;                # OUTPUT: «abc␤»\n    say $match.Str;                 # OUTPUT: «ab␤»\n    say $match.from;                # OUTPUT: «0␤»\n    say $match.to;                  # OUTPUT: «2␤»\n\nOr you can evaluate the regex in boolean context, in which case it matches\nagainst the $_ variable\n\n    $_ = 'abc';\n    if / ^ab / {\n        say '\"abc\" begins with \"ab\"';\n    }\n    else {\n        say 'This is a weird alternative Universe';\n    }\n\n","mro":["Callable","Method"],"k":"c","m":[{"s":{"r":"Mu","p":["Mu:U \\a","*%_"]},"m":1,"k":"m","n":"ACCEPTS","d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure."},{"m":1,"k":"m","s":{"r":"Mu","p":["\\topic","*%_"]},"d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","n":"ACCEPTS"},{"k":"m","m":1,"s":{"p":["\\topic","*%_"],"r":"Mu"},"d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","n":"ACCEPTS"},{"m":1,"k":"m","s":{"p":["Uni:D \\uni","*%_"],"r":"Mu"},"d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","n":"ACCEPTS"},{"n":"ACCEPTS","d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","s":{"r":"Mu","p":["@a","*%_"]},"k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":["%h","*%_"]},"d":"multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","n":"ACCEPTS"},{"k":"m","m":0,"s":{"p":["Mu :$topic is raw","Mu :$slash is raw","*%_"],"r":"Regex"},"n":"clone"},{"s":{"r":"Mu","p":["\\slash","Iterator:D \\iter","*%_"]},"k":"m","m":0,"n":"!ACCEPT-ITERATOR"},{"n":"!Bool6c","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}],"b":"A"},{"n":"&pairs","t":"Sub","k":"v"},{"n":"pairs","m":1,"k":"s","s":{"r":"Mu","p":["$x"]}},{"n":"&dir","t":"Sub","k":"v"},{"n":"dir","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"s"},{"n":"dir","s":{"r":"Mu","p":["IO::Path:D $path","|c is raw"]},"m":1,"k":"s"},{"n":"dir","k":"s","m":1,"s":{"p":["$path","|c is raw"],"r":"Mu"}},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(^)>"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"p":["QuantHash:D \\a"],"r":"Mu"},"n":"infix:<(^)>"},{"s":{"r":"Mu","p":["\\a"]},"m":1,"k":"s","n":"infix:<(^)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]},"n":"infix:<(^)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","m":1,"k":"s","s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["Mixy:D \\a","Mixy:D \\b"]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","m":1,"k":"s","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"}},{"n":"infix:<(^)>","s":{"r":"Mu","p":["Mixy:D \\a","Setty:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"n":"infix:<(^)>"},{"n":"infix:<(^)>","s":{"p":["Baggy:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(^)>","s":{"p":["Baggy:D \\a","Setty:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(^)>","s":{"r":"Mu","p":["Map:D \\a","Map:D \\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["Failure:D \\a","$"]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","s":{"p":["$","Failure:D \\b"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","k":"s","m":1,"s":{"r":"Mu","p":["**@p"]}},{"t":"Sub","n":"&gethostname","k":"v"},{"n":"gethostname","s":{"r":"Str:D","p":[]},"m":1,"k":"s"},{"n":"&acosech","t":"Sub+{is-pure}","k":"v"},{"s":{"p":["Numeric \\x"],"r":"Mu"},"k":"s","m":1,"n":"acosech"},{"s":{"r":"Mu","p":["Cool \\x"]},"m":1,"k":"s","n":"acosech"},{"n":"acosech","k":"s","m":1,"s":{"r":"num","p":["num $x"]}},{"k":"e","n":"SIGSYS","t":"Signal"},{"t":"Sub","n":"&get","k":"v"},{"s":{"p":["IO::Handle:D $fh = { ... }"],"r":"Mu"},"m":1,"k":"s","n":"get"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<⊈>"},{"s":{"p":["\\a","\\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<⊈>"},{"k":"v","t":"Sub+{Callable[Instant:D]}","n":"&term:<now>"},{"s":{"p":[],"r":"Instant:D"},"m":0,"k":"s","n":"term:<now>"},{"k":"v","t":"Sub+{is-pure}","n":"&minmax"},{"k":"s","m":1,"s":{"r":"Mu","p":["+\\args is raw",":&by!"]},"n":"minmax"},{"m":1,"k":"s","s":{"p":["+\\args is raw"],"r":"Mu"},"n":"minmax"},{"m":[{"n":"ast","d":"Alias for #method made.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"made","d":"Returns the payload that was set with make."},{"n":"STR","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"MATCH"},{"n":"CURSOR_NEXT","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"CURSOR_OVERLAP"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"CURSOR_MORE"},{"k":"m","m":1,"s":{"r":"Mu","p":["Callable:D \\var","$","$","$","$","$","*%_"]},"n":"INTERPOLATE"},{"n":"INTERPOLATE","k":"m","m":1,"s":{"r":"Mu","p":["Iterable:D \\var","int \\im","int \\monkey","int \\s","$","\\context","*%_"]}},{"k":"m","m":1,"s":{"r":"Mu","p":["Associative:D \\var","int \\im","$","$","$","\\context","*%_"]},"n":"INTERPOLATE"},{"n":"INTERPOLATE","k":"m","m":1,"s":{"r":"Mu","p":["Regex:D \\var","int \\im","int \\monkey","$","$","$","*%_"]}},{"n":"INTERPOLATE","s":{"r":"Mu","p":["Mu:D \\var","int \\im","int \\monkey","$","$","\\context","*%_"]},"m":1,"k":"m"},{"s":{"p":["Mu:U \\var","$","$","$","$","$","*%_"],"r":"Mu"},"k":"m","m":1,"n":"INTERPOLATE"},{"k":"m","m":1,"s":{"r":"Mu","p":["Associative:D $","$","$","$","$","$","*%_"]},"n":"INTERPOLATE_ASSERTION"},{"k":"m","m":1,"s":{"p":["Iterable:D \\var","int \\im","int \\monkey","int \\s","$","\\context","*%_"],"r":"Mu"},"n":"INTERPOLATE_ASSERTION"},{"s":{"r":"Mu","p":["Mu:D \\var","int \\im","int \\monkey","$","$","\\context","*%_"]},"k":"m","m":1,"n":"INTERPOLATE_ASSERTION"},{"n":"CALL_SUBRULE","k":"m","m":0,"s":{"p":["$rule","|c is raw"],"r":"Mu"}},{"s":{"p":["$mm","*%_"],"r":"Mu"},"k":"m","m":0,"n":"DYNQUANT_LIMITS"},{"k":"m","m":0,"s":{"r":"Mu","p":["$grammar","$name","|"]},"n":"OTHERGRAMMAR"},{"s":{"p":["$name","|c is raw"],"r":"Mu"},"k":"m","m":0,"n":"INDMETHOD"},{"k":"m","m":0,"s":{"r":"Mu","p":["$rule","|c is raw"]},"n":"INDRULE"},{"n":"RECURSE","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":[":$orig = \"\"",":$from = 0",":to(:$pos)",":ast(:$made)",":$shared",":$braid",":$list",":$hash","*%_"]},"n":"BUILD"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"clone","d":"Defined as:\n\n    method clone()\n\nClones the Match object."},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Bool"},"d":"Defined as:\n\n    method Bool(Capture:D: --> Bool:D)\n\nReturns True on successful and False on unsuccessful matches. Please note\nthat any zero-width match can also be successful.\n\n    say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\n    say $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»","n":"Bool"},{"n":"Bool","d":"Defined as:\n\n    method Bool(Capture:D: --> Bool:D)\n\nReturns True on successful and False on unsuccessful matches. Please note\nthat any zero-width match can also be successful.\n\n    say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\n    say $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method prematch(Match:D: --> Str:D)\n\nReturns the part of the original string leading up to the match.\n\n    'abcdefg' ~~ /cd/;\n    say $/.prematch;          # OUTPUT: «ab␤»\n\n    # will return a list of three match objects\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.[1].prematch;      # OUTPUT: «abc1␤»","n":"prematch"},{"n":"postmatch","d":"Defined as:\n\n    method postmatch(Match:D: --> Str:D)\n\nReturns the part of the original string following the match.\n\n    'abcdefg' ~~ /cd/;\n    say $/.postmatch;         # OUTPUT: «efg␤»\n\n    # will return a list of three match objects\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.[1].postmatch;     # OUTPUT: «3def␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"caps","d":"Returns a list of pairs, with the index or submatch name as key and the\nsubmatches as values. The list is ordered by starting position of the\nsubmatches."},{"n":"chunks","d":"Returns a list of pairs, with the index or submatch name as key and the\nsubmatches as values. The list is ordered by starting position of the\nsubmatches.\n\nThose parts of the string that were not matched by submatches are\ninterleaved with the other pairs, with the string ~ as key.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"!MATCH-EMPTY"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!MATCH"},{"n":"!MATCH-PASS","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"!MATCH-CAPTURES","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}],"k":"c","mro":["NQPMatchRole","Capture","Cool"],"a":[{"k":"v","t":"List","n":"@!list"},{"t":"Hash","n":"%!hash","k":"v"}],"d":"TITLE\nclass Match\n\nSUBTITLE\nResult of a successful regex match\n\n    class Match is Capture is Cool does NQPMatchRole {}\n\nMatch objects are the result of a successful regex match, this does include\nany zero-width match. They store a reference to the original string\n(.orig), positional and named captures, the positions of the start and end\nof the match in the original string, and a payload referred to as AST\n(abstract syntax tree), which can be used to build data structures from\ncomplex regexes and grammars.\n\nThe last match is also stored in the $¢ Match object, which is lexically\nscoped to the regex, that is, only available from within the regular\nexpression, as shown here:\n\n    my $c;\n    'abc' ~~ /.$${ $c = $¢ }/;\n    say $c; # OUTPUT: «｢c｣␤»\n\nIn this case, we are running the code among curly braces when the match\noccurs, in this case the last letter in the string (actually, the last,\nindicated by the double $, character); $c gets the value of the cursor $¢,\nwhich contains the Match; when used with say, the Match is stringified by\ncalling .Str on it. This $¢ offers a way of capturing the Match inside a\nregular expression; outside, you need to use $/\n\n    my $c; 'camelia' ~~ /<[ l m ]> {$c = $¢}/;\n    say $c; # OUTPUT: «｢m｣␤»\n    say $/; # OUTPUT: «｢m｣␤»\n\nNote: This feature works only from Raku version 2018.02. It would have\nreturned Nil with any previous version. Alternatively and prior to that\nversion, you could use $/ which, inside the regex, has the same value:\n\n    '123' ~~ / (\\d) { say $0; say $/; } \\d+ /; # OUTPUT: «｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n\nThe main difference between $/ and $¢ is scope: the latter only has a value\ninside the regex:\n\n    '123' ~~ / (\\d) { say $/; say $¢; } \\d+ /; # OUTPUT: «｢1｣␤ 0 => ｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n    say \"¢ → \", $¢, \"/ is $/\"; ; # OUTPUT: «¢ → Nil/ is 123␤»\n\n\nSubmatches are also Match objects (or lists of Match objects, if the\ncorresponding regex was quantified), so each match object can be seen as\nthe root of a tree of match objects.\n\nA Match object can also hold the result of a match in progress (while the\ngrammar engine is running), in which case the pos method returns the\ncurrent position. This view on Match objects is only visible if you call\ncode from within a regex.\n\nNote (deprecated): There is a synonym for this class, Cursor, defined as:\n\n    my constant Cursor = Match\n\nInitially, it was used to keep track of initial position in regex matches.\nIn current versions, it's an alias for Match.\n\n","t":"Match","n":"Match","b":"C"},{"k":"v","t":"Sub","n":"&next"},{"n":"next","s":{"p":[],"r":"Nil"},"k":"s","m":1},{"n":"next","s":{"r":"Nil","p":["Label:D \\x"]},"k":"s","m":1},{"t":"Sub+{is-pure}","n":"&infix:«<»","k":"v"},{"s":{"p":["$?"],"r":"Mu"},"m":1,"k":"s","n":"infix:«<»"},{"n":"infix:«<»","s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["Real \\a","Real \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:«<»"},{"k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Bool:D"},"n":"infix:«<»"},{"n":"infix:«<»","m":1,"k":"s","s":{"p":["int $a","int $b"],"r":"Bool:D"}},{"k":"s","m":1,"s":{"p":["Num:D \\a","Num:D \\b"],"r":"Bool:D"},"n":"infix:«<»"},{"m":1,"k":"s","s":{"p":["num $a","num $b"],"r":"Bool:D"},"n":"infix:«<»"},{"s":{"r":"Bool:D","p":["Rational:D \\a","Rational:D \\b"]},"m":1,"k":"s","n":"infix:«<»"},{"n":"infix:«<»","m":1,"k":"s","s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Bool:D"}},{"k":"s","m":1,"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Bool:D"},"n":"infix:«<»"},{"n":"infix:«<»","s":{"p":["Instant:D $a","Instant:D $b"],"r":"Bool:D"},"m":1,"k":"s"},{"s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"m":1,"k":"s","n":"infix:«<»"},{"n":"infix:«<»","k":"s","m":1,"s":{"p":["Date:D $a","Date:D $b"],"r":"Bool:D"}},{"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"m":1,"k":"s","n":"infix:«<»"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<Z>"},{"k":"s","m":1,"s":{"r":"Seq:D","p":["+\\lol is raw",":&with!"]},"n":"infix:<Z>"},{"m":1,"k":"s","s":{"r":"Seq:D","p":["+\\lol is raw"]},"n":"infix:<Z>"},{"b":"C","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["\\re","\\im","*%_"]},"n":"!SET-SELF"}],"k":"c","mro":["Numeric","Cool"],"t":"Complex","a":[{"k":"v","t":"num","n":"$.re"},{"k":"v","n":"$.im","t":"num"}],"n":"i"},{"k":"v","n":"&infix:<~~>","t":"Sub+{Precedence}"},{"n":"infix:<~~>","k":"s","m":1,"s":{"r":"Mu","p":["Mu \\topic","Mu \\matcher"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu \\topic","Regex:D \\matcher"]},"n":"infix:<~~>"},{"k":"v","n":"&uniprop-bool","t":"Sub"},{"n":"uniprop-bool","s":{"p":["Str:D $str","Stringy:D $propname"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Int:D $code","Stringy:D $propname"],"r":"Mu"},"k":"s","m":1,"n":"uniprop-bool"},{"t":"FatRat","a":[{"t":"Int","n":"$.numerator","k":"v"},{"k":"v","t":"Int","n":"$.denominator"}],"d":"TITLE\nclass FatRat\n\nSUBTITLE\nRational number (arbitrary-precision)\n\n    class FatRat is Cool does Rational[Int, Int] {}\n\nA FatRat is a rational number stored with arbitrary size numerator and\ndenominator. Arithmetic operations involving a FatRat and optionally Int or\nRat objects return a FatRat, avoiding loss of precision.\n\nSince, unlike Rat, FatRat arithmetics do not fall back Num at some point,\nthere is a risk that repeated arithmetic operations generate pathologically\nlarge numerators and denominators.\n\nThere are two common ways to generate FatRat objects: through the\nFatRat.new(Int, Int) constructor, which generates them from numerator and\ndenominator, or by calling the .FatRat method on an Int or Rat object.\n\n","n":"FatRat","m":[{"n":"FatRat","s":{"r":"FatRat","p":["Real $?","*%_"]},"k":"m","m":0},{"n":"Rat","s":{"r":"Rat:D","p":["Real $?","*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"numerator"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"denominator"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"n":"!STRINGIFY","s":{"p":["\\whole","\\fract","Int:D $precision","*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["\\whole","\\fract","*%_"]},"n":"!SLOW-STR"}],"k":"c","mro":["Rational[Int,Int]","Real","Numeric","Cool"],"b":"C"},{"t":"Sub+{Callable[Bool]}","n":"&lastcall","k":"v"},{"k":"s","m":0,"s":{"p":[],"r":"Bool"},"n":"lastcall"},{"t":"Sub","n":"&note","k":"v"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"note"},{"n":"note","m":1,"k":"s","s":{"r":"Mu","p":["**@args is raw"]}},{"b":"C","mro":[],"k":"ro","n":"IO","d":"TITLE\nrole IO\n\nSUBTITLE\nInput/output related routines\n\nThe role provides no methods, but exists so that IO() coercers, which\ncoerce to IO::Path, correctly type-check the resultant value. The role is\nimplemented by IO::Path and IO::Special.\n\nSee also the related classes IO::Handle and IO::Path.","t":"IO"},{"mro":["IO::Handle"],"m":[{"n":"TWEAK","k":"m","m":0,"s":{"p":[":on-close($!on-close)!",":$enc",":$bin",":on-read($!on-read)",":on-write($!on-write)",":on-native-descriptor($!on-native-descriptor)","*%_"],"r":"Nil"}},{"n":"READ","m":0,"k":"m","s":{"r":"Mu","p":["$","*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"EOF"},{"s":{"p":["$data","*%_"],"r":"Mu"},"k":"m","m":0,"n":"WRITE"},{"n":"flush","s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0},{"d":"Defined as:\n\n    method close(IO::Pipe: --> Proc:D)\n\nCloses the pipe and returns Proc object from which the pipe originates.","n":"close","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"opened"},{"n":"t","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"native-descriptor","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"IO","d":"Defined as:\n\n    method IO(IO::Pipe: --> IO::Path:U)\n\nReturns an IO::Path type object.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"path","d":"Defined as:\n\n    method path(IO::Pipe: --> IO::Path:U)\n\nReturns an IO::Path type object."},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"proc","d":"Defined as:\n\n    method proc(IO::Pipe: --> Proc:D)\n\nReturns the Proc object from which the pipe originates."},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","n":"IO::Pipe","a":[{"k":"v","n":"$.proc","t":"Mu"},{"n":"$!on-read","t":"Mu","k":"v"},{"k":"v","n":"$!on-write","t":"Mu"},{"n":"$!on-close","t":"Mu","k":"v"},{"k":"v","n":"$!on-native-descriptor","t":"Mu"},{"k":"v","t":"Mu","n":"$!eof"},{"k":"v","n":"$!closed","t":"Mu"},{"t":"Mu","n":"$.path","k":"v"},{"k":"v","n":"$!PIO","t":"Mu"},{"n":"$.chomp","t":"Mu","k":"v"},{"k":"v","n":"$.nl-in","t":"Mu"},{"n":"$.nl-out","t":"Str:D","k":"v"},{"n":"$.encoding","t":"Str","k":"v"},{"k":"v","n":"$!decoder","t":"Encoding::Decoder"},{"t":"Encoding::Encoder","n":"$!encoder","k":"v"},{"t":"int","n":"$!out-buffer","k":"v"}],"d":"TITLE\nclass IO::Pipe\n\nSUBTITLE\nBuffered inter-process string or binary stream\n\n    class IO::Pipe is IO::Handle {}\n\nAn IO::Pipe object closely corresponds to a UNIX pipe. It has one end where\nit consumes string or binary data, and another where it reproduces the same\ndata. It is buffered, so that a write without a read doesn't immediately\nblock.\n\nPipes can be easily constructed with sub run and Proc::Async.new.\n\n","t":"IO::Pipe","b":"A"},{"d":"TITLE\nclass IO::Spec\n\nSUBTITLE\nPlatform specific operations on file and directory paths\n\n    class IO::Spec { }\n\nObjects of this class are not used directly but as a sub-class specific to\nthe platform perl is running on via the $*SPEC variable which will contain\nan object of the appropriate type.\n\nThe sub-classes are documented separately, with the platform-specific\ndifferences documented in IO::Spec::Cygwin, IO::Spec::QNX, IO::Spec::Unix\nand IO::Spec::Win32.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\nMethods","t":"IO::Spec","n":"IO::Spec","m":[{"n":"select","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["$token","*%_"]},"k":"m","m":1,"n":"select"}],"k":"c","mro":["Any"],"b":"A"},{"n":"IO::Spec::Cygwin","t":"IO::Spec::Cygwin","d":"TITLE\nclass IO::Spec::Cygwin\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Cygwin\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec will be available from the $*SPEC variable for a\nperl running on Cygwin .\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n","mro":["IO::Spec::Unix"],"m":[{"n":"canonpath","d":"Defined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem.\n\n    IO::Spec::Cygwin.canonpath(｢C:\\foo\\\\..\\bar\\..\\ber｣).say;\n    # OUTPUT: «C:/foo/../bar/../ber␤»\n\n    IO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»","s":{"p":["$patharg",":$parent","*%_"],"r":"Mu"},"k":"m","m":0},{"d":"Defined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Cygwin.catdir(<foo/bar ber perl>).say;\n    # OUTPUT: «foo/bar/ber/perl␤»","n":"catdir","k":"m","m":0,"s":{"p":["*@paths","*%_"],"r":"Mu"}},{"s":{"p":["$path","*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-absolute","d":"Defined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\") or backslash (\"\\\"),\neven if they have combining character on them, optionally preceded by a\nvolume:\n\n    say IO::Spec::Cygwin.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: \"bar\";         # OUTPUT: «False␤»"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"tmpdir","d":"Defined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found."},{"s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0,"n":"abs2rel","d":"Defined as:\n\n    method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)\n\nReturns a string that represents $path, but relative to $base path. Both\n$path and $base may be relative paths. $base defaults to $*CWD. Uses\nIO::Spec::Win32's semantics."},{"d":"Defined as:\n\n    method rel2abs(|c --> List:D)\n\nSame as IO::Spec::Win32.rel2abs, except replaces backslashes with slashes\nin the final result.","n":"rel2abs","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m","n":"splitpath","d":"Defined as:\n\n    method splitpath(|c --> List:D)\n\nSame as IO::Spec::Win32.splitpath, except replaces backslashes with slashes\nin all the values of the final result."},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nSame as IO::Spec::Win32.catpath, except will also change all backslashes to\nslashes at the end:\n\n    IO::Spec::Cygwin.catpath('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir/foo.txt␤»\n\n    IO::Spec::Cygwin.catpath('C:', '/some/dir', '').say;\n    # OUTPUT: «C:/some/dir␤»\n\n    IO::Spec::Cygwin.catpath('', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «/some/dir/foo.txt␤»\n\n    IO::Spec::Cygwin.catpath('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","n":"catpath"},{"d":"Defined as:\n\n    method split(|c --> List:D)\n\nSame as IO::Spec::Win32.split, except replaces backslashes with slashes in\nall the values of the final result.","n":"split","k":"m","m":0,"s":{"p":["Cool:D $path","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method join(|c)\n\nSame as IO::Spec::Win32.join, except replaces backslashes with slashes in\nthe final result.","n":"join","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}}],"k":"c","b":"A"},{"b":"A","mro":["IO::Spec::Unix"],"k":"c","m":[{"d":"Defined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem.\n\n    IO::Spec::Win32.canonpath(\"C:/foo//../bar/../ber\").say;\n    # OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\n    IO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\").say;\n    # OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\n    IO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «C:\\ber␤»","n":"canonpath","m":0,"k":"m","s":{"p":["$patharg",":$parent","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*@dirs","*%_"]},"k":"m","m":0,"n":"catdir","d":"Defined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Win32.catdir(<foo/bar ber perl>).say;\n    # OUTPUT: «foo\\bar\\ber\\perl␤»"},{"n":"dir-sep","d":"Defined as:\n\n    method dir-sep(--> Str:D)\n\nReturns the string ｢\\｣ representing canonical directory separator\ncharacter.\n\n    IO::Spec::Win32.dir-sep.say; # OUTPUT: «\\␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"devnull","d":"Defined as:\n\n    method devnull(--> Str:D)\n\nReturns the string \"nul\" representing the \"Null device\":\n\n    $*SPEC.devnull.IO.spurt: \"foo bar baz\";","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method rootdir(--> Str:D)\n\nReturns string ｢\\｣, representing root directory.","n":"rootdir","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["Cool:D $path","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method splitdir(Cool:D $path --> List:D)\n\nSplits the given $path on slashes and backslashes.\n\n    IO::Spec::Win32.splitdir('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\", \"foo\", \"bar.txt\")␤»\n\n    IO::Spec::Win32.splitdir('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"foo\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('///').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('./').perl.say;\n    # OUTPUT: «(\".\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('.').perl.say;\n    # OUTPUT: «(\".\",)␤»\n\n    IO::Spec::Win32.splitdir('').perl.say;\n    # OUTPUT: «(\"\",)␤»","n":"splitdir"},{"d":"Defined as:\n\n    method basename(Str:D $path --> Str:D)\n\nTakes a path as a string and returns a possibly-empty portion after the\nlast slash or backslash:\n\n    IO::Spec::Win32.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Win32.basename(\"foo/bar\\\\\").perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Win32.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\n    IO::Spec::Win32.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»","n":"basename","k":"m","m":0,"s":{"p":["\\path","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found.","n":"tmpdir","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method path(--> Seq:D)\n\nSplits the value of %*ENV<PATH> (or %*ENV<Path> if the former is not set)\non semicolons (\";\") and returns a Seq with each of the resultant parts,\nalways adding element \".\" to the head. Removes all double quotes (\") it\nfinds.\n\n    %*ENV<PATH> = 'foo;\"bar\"/\"ber\"';\n    IO::Spec::Win32.path.perl.say; # OUTPUT: «(\".\", \"foo\", \"bar/ber\").Seq␤»","n":"path"},{"d":"Defined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\") or backslash (\"\\\"),\neven if they have combining character on them, optionally preceded by a\nvolume:\n\n    say IO::Spec::Win32.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: \"bar\";         # OUTPUT: «False␤»","n":"is-absolute","m":0,"k":"m","s":{"r":"Mu","p":["$path","*%_"]}},{"s":{"r":"Mu","p":["Cool:D $path is copy","*%_"]},"k":"m","m":0,"n":"split","d":"Defined as:\n\n    method split(Cool:D $path --> List:D)\n\nSplits the given $path into \"volume\", \"dirname\", and \"basename\" and returns\nthe result as a List of three Pairs, in that order. The \"volume\" is always\nan empty string and exists for consistency with other IO::Spec classes.\n\n    IO::Spec::Win32.split('C:/foo/bar.txt').perl.say;\n    # OUTPUT: «(:volume(\"C:\"), :dirname(\"/foo\"), :basename(\"bar.txt\"))␤»\n\n    IO::Spec::Win32.split('/foo/').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\n    IO::Spec::Win32.split('///').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"\\\\\"))␤»\n\n    IO::Spec::Win32.split('./').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Win32.split('.').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Win32.split('').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»"},{"d":"Defined as:\n\n    method join (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nSimilar to catpath, takes two path fragments and concatenates them, adding\nor removing a path separator, if necessary, except it will return just\n$file if both $dir and $file are string '/' or if $dir is the string '.'.\nThe first argument is ignored (it exists to maintain consistent interface\nwith other IO::Spec types for systems that have volumes).\n\n    IO::Spec::Win32.join('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir\\and/more␤»\n\n    IO::Spec::Win32.join('C:', '.', 'foo.txt').say;\n    # OUTPUT: «C:foo.txt␤»\n\n    IO::Spec::Win32.join('C:', ｢\\｣, '/').say;\n    # OUTPUT: «C:\\␤»\n\n    IO::Spec::Win32.join('//server/share', ｢\\｣, '/').say;\n    # OUTPUT: «//server/share␤»\n\n    IO::Spec::Win32.join('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","n":"join","k":"m","m":0,"s":{"p":["Str \\vol","Str $dir is copy","Str $file is copy","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method splitpath(Cool:D $path, :$nofile --> List:D)\n\nSplits the given $path into a list of 3 strings: volume, dirname, and file.\nThe volume is always an empty string, returned for API compatibility with\nother IO::Spec types. If :$nofile named argument is set to True, the\ncontent of the file string is undefined and should be ignored; this is a\nmeans to get a performance boost, as implementations may use faster code\npath when file is not needed.\n\n    IO::Spec::Win32.splitpath('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\", \"\\\\foo/\", \"bar.txt\")␤»\n\n    IO::Spec::Win32.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n    # OUTPUT: «(\"C:\", \"\\\\foo/bar.txt\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('/foo/', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('///').perl.say;\n    # OUTPUT: «(\"\", \"///\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('./').perl.say;\n    # OUTPUT: «(\"\", \"./\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('.').perl.say;\n    # OUTPUT: «(\"\", \"\", \".\")␤»\n\n    IO::Spec::Win32.splitpath('').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\")␤»","n":"splitpath","m":0,"k":"m","s":{"p":["$path",":$nofile = Bool::False","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["Str $vol is copy","Str \\dir","Str \\file","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nConcatenates a path from given volume, a chain of directories, and file. An\nempty string can be given for any of the three arguments. No attempt to\nmake the path canonical is made. Use canonpath for that purpose.\n\n    IO::Spec::Win32.catpath('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir\\foo.txt␤»\n\n    IO::Spec::Win32.catpath('C:', '/some/dir', '').say;\n    # OUTPUT: «C:/some/dir␤»\n\n    IO::Spec::Win32.catpath('', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «/some/dir\\foo.txt␤»\n\n    IO::Spec::Win32.catpath('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","n":"catpath"},{"s":{"r":"Mu","p":["$path is copy","$base? is copy",":$omit-volume","*%_"]},"k":"m","m":0,"n":"rel2abs","d":"Defined as:\n\n    method rel2abs(Str() $path, $base = $*CWD --> Str:D)\n\nReturns a string representing $path converted to absolute path, based at\n$base, which defaults to $*CWD. If $base is not an absolute path, it will\nbe made absolute relative to $*CWD, unless $*CWD and $base are the same.\n\n    say $*CWD;                                   # OUTPUT: «\"C:\\Users\\camelia\".IO␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo';          # OUTPUT: «C:\\Users\\camelia\\foo␤»\n    say IO::Spec::Win32.rel2abs: './';           # OUTPUT: «C:\\Users\\camelia␤»\n    say IO::Spec::Win32.rel2abs: 'foo/../../';   # OUTPUT: «C:\\Users\\camelia\\foo\\..\\..␤»\n    say IO::Spec::Win32.rel2abs: '/foo/';        # OUTPUT: «C:\\foo␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo', 'bar';   # OUTPUT: «C:\\Users\\camelia\\bar\\foo␤»\n    say IO::Spec::Win32.rel2abs: './', '/bar';   # OUTPUT: «\\bar␤»\n    say IO::Spec::Win32.rel2abs: '/foo/', 'bar'; # OUTPUT: «C:\\foo␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo/../../', 'bar';\n    # OUTPUT: «C:\\Users\\camelia\\bar\\foo\\..\\..␤»"},{"s":{"r":"Str:D","p":["$first","*@rest",":$parent","*%_"]},"m":0,"k":"m","n":"!canon-cat"}],"n":"IO::Spec::Win32","t":"IO::Spec::Win32","d":"TITLE\nclass IO::Spec::Win32\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Windows\n\n    class IO::Spec::Win32 is IO::Spec { }\n\nObjects of this class are used not directly but as a sub-class specific to\nthe platform Raku is running on via the $*SPEC variable, which will contain\nan object of the appropriate type.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n"},{"d":"TITLE\nclass IO::Spec::Unix\n\nSUBTITLE\nPlatform specific operations on file and directory paths for POSIX\n\n    class IO::Spec::Unix is IO::Spec  { }\n\nOn object of this type is available via the variable $*SPEC if the Raku\ninterpreter is running on a Unix-like platform.\n\nThe IO::Spec::* classes provide low-level path operations. Unless you're\ncreating your own high-level path manipulation routines, you don't need to\nuse IO::Spec::*. Use IO::Path instead.\n\nBeware that no special validation is done by these classes (e.g. check\nwhether path contains a null character). It is the job of higher-level\nclasses, like IO::Path, to do that.\n\n","t":"IO::Spec::Unix","n":"IO::Spec::Unix","k":"c","m":[{"d":"Defined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem, so no symlinks are followed.\n\n    IO::Spec::Unix.canonpath(\"foo//../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Unix.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Unix.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»","n":"canonpath","m":0,"k":"m","s":{"p":["$patharg",":$parent","*%_"],"r":"Str:D"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"dir-sep","d":"Defined as:\n\n    method dir-sep(--> Str:D)\n\nReturns the string \"/\" representing canonical directory separator\ncharacter.\n\n    IO::Spec::Unix.dir-sep.say; # OUTPUT: «/␤»"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method curdir()\n\nReturns a string representing the current directory:\n\n    say '.' eq $*SPEC.curdir; # OUTPUT: «True␤»","n":"curdir"},{"d":"Defined as:\n\n    method updir()\n\nReturns a string representing the directory one up from current:\n\n    say '..' eq $*SPEC.updir; # OUTPUT: «True␤»","n":"updir","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"curupdir","d":"Defined as:\n\n    method curupdir()\n\nReturns a none Junction of strings representing the current directory and\nthe \"one directory up\":\n\n    say $*SPEC.curupdir;                  # OUTPUT: «none(., ..)␤»\n    my @dirs = <. foo .. bar>;\n    say @dirs.grep(* eq $*SPEC.curupdir); # OUTPUT: «(foo bar)␤»\n\n\nNeither foo nor bar are equal to the representation of the current or\nparent directory, that is why they are returned by grep.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"rootdir","d":"Defined as:\n\n    method rootdir(--> Str:D)\n\nReturns string '/', representing root directory.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"devnull","d":"Defined as:\n\n    method devnull(--> Str:D)\n\nReturns the string \"/dev/null\" representing the \"Null device\":\n\n    $*SPEC.devnull.IO.spurt: \"foo bar baz\";"},{"m":0,"k":"m","s":{"r":"Mu","p":["\\path","*%_"]},"d":"Defined as:\n\n    method basename(Str:D $path --> Str:D)\n\nTakes a path as a string and returns a possibly-empty portion after the\nlast slash:\n\n    IO::Spec::Unix.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Unix.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\n    IO::Spec::Unix.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»","n":"basename"},{"n":"extension","d":"NOTE: Most users would want to use the higher-level routine\nIO::Path.extension instead of this lower-level version.\n\nDefined as:\n\n    method extension(Str:D $path --> Str:D)\n\nTakes a string representing a base name and returns the characters after\nthe last dot (\".\"), or empty string if no dots are present. The routine\nmakes no attempt to detect path separators and will return everything after\nthe last dot.\n\n    $*SPEC.extension('foo.'      ).perl.say;  # OUTPUT: «\"\"␤»\n    $*SPEC.extension('foo.txt'   ).perl.say;  # OUTPUT: «\"txt\"␤»\n    $*SPEC.extension('foo.tar.gz').perl.say;  # OUTPUT: «\"gz\"␤»\n    $*SPEC.extension('foo'       ).perl.say;  # OUTPUT: «\"\"␤»\n    $*SPEC.extension('bar.foo/foo').perl.say; # OUTPUT: «\"foo/foo\"␤»","s":{"r":"Mu","p":["\\path","*%_"]},"m":0,"k":"m"},{"n":"tmpdir","d":"Defined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\"), even if it has\ncombining character on it:\n\n    say IO::Spec::Unix.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Unix.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Unix.is-absolute: \"bar\";         # OUTPUT: «False␤»","n":"is-absolute","k":"m","m":0,"s":{"p":["\\path","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method path(--> Seq:D)\n\nSplits the value of %*ENV<PATH> on colons (\":\"), replaces empty parts with\n\".\", and returns a Seq with each of the resultant parts. Returns an empty\nSeq if %*ENV<PATH> is not set or is an empty string.\n\n    %*ENV<PATH> = 'foo:bar/ber::foo:';\n    IO::Spec::Unix.path.perl.say;\n    # OUTPUT: «(\"foo\", \"bar/ber\", \".\", \"foo\", \".\").Seq␤»","n":"path","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method splitpath(Cool:D $path, :$nofile --> List:D)\n\nSplits the given $path into a list of 3 strings: volume, dirname, and file.\nThe volume is always an empty string, returned for API compatibility with\nother IO::Spec types. If :$nofile named argument is set to True, the\ncontent of the file string is undefined and should be ignored; this is a\nmeans to get a performance boost, as implementations may use faster code\npath when file is not needed.\n\n    IO::Spec::Unix.splitpath('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"\", \"C:\\\\foo/\", \"bar.txt\")␤»\n\n    IO::Spec::Unix.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"C:\\\\foo/bar.txt\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('/foo/', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('///').perl.say;\n    # OUTPUT: «(\"\", \"///\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('./').perl.say;\n    # OUTPUT: «(\"\", \"./\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('.').perl.say;\n    # OUTPUT: «(\"\", \"\", \".\")␤»\n\n    IO::Spec::Unix.splitpath('').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\")␤»","n":"splitpath","k":"m","m":0,"s":{"r":"Mu","p":["$path",":$nofile = Bool::False","*%_"]}},{"d":"Defined as:\n\n    method split(Cool:D $path --> List:D)\n\nSplits the given $path into \"volume\", \"dirname\", and \"basename\" and returns\nthe result as a List of three Pairs, in that order. The \"volume\" is always\nan empty string and exists for consistency with other IO::Spec classes.\n\n    IO::Spec::Unix.split('C:/foo/bar.txt').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"C:/foo\"), :basename(\"bar.txt\"))␤»\n\n    IO::Spec::Unix.split('/foo/').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\n    IO::Spec::Unix.split('///').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"/\"))␤»\n\n    IO::Spec::Unix.split('./').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Unix.split('.').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Unix.split('').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»","n":"split","k":"m","m":0,"s":{"p":["Cool:D $path","*%_"],"r":"Mu"}},{"n":"join","d":"Defined as:\n\n    method join ($, Str:D $dir, Str:D $file --> Str:D)\n\nSimilar to catpath, takes two path fragments and concatenates them, adding\nor removing a path separator, if necessary, except it will return just\n$file if both $dir and $file are string '/' or if $dir is the string '.'.\nThe first argument is ignored (it exists to maintain consistent interface\nwith other IO::Spec types for systems that have volumes).\n\n    IO::Spec::Unix.join($, 'foo', 'bar').say; # OUTPUT: «foo/bar␤»\n    IO::Spec::Unix.join($, '/', '/').say;     # OUTPUT: «/␤»\n    IO::Spec::Unix.join($, '.', 'foo').say;   # OUTPUT: «foo␤»\n    say $*SPEC.join(True,\".\",\"/foo\");         # OUTPUT: «/foo␤»","s":{"p":["$","\\dir","\\file","*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["$","\\dirname","\\file","*%_"]},"d":"Defined as:\n\n    method catpath ($, Str:D $part1, Str:D $part2 --> Str:D)\n\nTakes two path fragments and concatenates them, adding or removing a path\nseparator, if necessary. The first argument is ignored (it exists to\nmaintain consistent interface with other IO::Spec|/type/IO::Spec types for\nsystems that have volumes).\n\n    IO::Spec::Unix.catpath($, 'some/dir', 'and/more').say;\n    # OUTPUT: «some/dir/and/more␤»","n":"catpath"},{"n":"catdir","d":"Defined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Unix.catdir(<foo/bar ber perl>).say; # OUTPUT: «foo/bar/ber/perl␤»","s":{"p":["*@parts","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method splitdir(Cool:D $path --> List:D)\n\nSplits the given $path on slashes.\n\n    IO::Spec::Unix.splitdir('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\\\\foo\", \"bar.txt\")␤»\n\n    IO::Spec::Unix.splitdir('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"foo\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('///').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('./').perl.say;\n    # OUTPUT: «(\".\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('.').perl.say;\n    # OUTPUT: «(\".\",)␤»\n\n    IO::Spec::Unix.splitdir('').perl.say;\n    # OUTPUT: «(\"\",)␤»","n":"splitdir","m":0,"k":"m","s":{"p":["Cool:D $path","*%_"],"r":"Mu"}},{"d":"Alias for catdir.","n":"catfile","k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["$path is copy","$base is copy = { ... }","*%_"]},"d":"Defined as:\n\n    method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)\n\nReturns a string that represents $path, but relative to $base path. Both\n$path and $base may be relative paths. $base defaults to $*CWD.","n":"abs2rel"},{"s":{"p":["\\path","$base? is copy","*%_"],"r":"Mu"},"m":0,"k":"m","n":"rel2abs","d":"Defined as:\n\n    method rel2abs(Str() $path, $base = $*CWD --> Str:D)\n\nReturns a string representing $path converted to absolute path, based at\n$base, which defaults to $*CWD. If $base is not an absolute path, it will\nbe made absolute relative to $*CWD, unless $*CWD and $base are the same.\n\n    say $*CWD;                                  # OUTPUT: «\"/home/camelia\".IO␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo';          # OUTPUT: «/home/camelia/foo␤»\n    say IO::Spec::Unix.rel2abs: './';           # OUTPUT: «/home/camelia␤»\n    say IO::Spec::Unix.rel2abs: 'foo/../../';   # OUTPUT: «/home/camelia/foo/../..␤»\n    say IO::Spec::Unix.rel2abs: '/foo/';        # OUTPUT: «/foo␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo', 'bar';   # OUTPUT: «/home/camelia/bar/foo␤»\n    say IO::Spec::Unix.rel2abs: './', '/bar';   # OUTPUT: «/bar␤»\n    say IO::Spec::Unix.rel2abs: '/foo/', 'bar'; # OUTPUT: «/foo␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo/../../', 'bar';\n    # OUTPUT: «/home/camelia/bar/foo/../..␤»"}],"mro":["IO::Spec"],"b":"A"},{"b":"A","mro":["IO::Spec::Unix"],"k":"c","m":[{"s":{"p":["$patharg",":$parent","*%_"],"r":"Mu"},"k":"m","m":0,"n":"canonpath","d":"Defined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem, so no symlinks are followed.\n\n    IO::Spec::QNX.canonpath(\"foo//../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::QNX.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::QNX.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»"}],"n":"IO::Spec::QNX","t":"IO::Spec::QNX","d":"TITLE\nclass IO::Spec::QNX\n\nSUBTITLE\nPlatform specific operations on file and directory paths QNX\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec specific to QNX will be available via $*SPEC if\nthe perl is running on QNX.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n"},{"d":"TITLE\nclass IO::Notification\n\nSUBTITLE\nAsynchronous notification for file and directory changes    \n\n    enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));\n\n\n    class IO::Notification  {\n        class Change {\n            has $.path;\n            has $.event;\n        }\n        ...\n    }\n\n\nIO::Notification.watch-path($path) produces a Supply of\nIO::Notification::Change events for a file or directory.\n\nHere is a small example that prints the first ten FileChanged-notifications\nfor the current working directory:\n\n    my $finish = Promise.new;\n    my $count = 0;\n    IO::Notification.watch-path($*CWD).act( -> $change {\n        $count++ if $change.event ~~ FileChanged;\n        say \"($count) $change.path(): $change.event()\";\n        $finish.keep if $count >= 10;\n    });\n    await $finish;\n\n\nThe type of the change is very much dependent both on the platform and on\nspecific system calls that were used initiate the change. At this point in\ntime you should not rely on the type of change in general, and test your\nparticular situation.\n\n","t":"IO::Notification","n":"IO::Notification","m":[{"m":0,"k":"m","s":{"p":["$path",":$scheduler = { ... }","*%_"],"r":"Mu"},"d":"method watch-path(IO::Notification: Str() $path, :$scheduler = $*SCHEDULER)\n\n\nReturns a Supply that emits IO::Notification::Change objects.\n\nIf $path is a file, only modifications of that file are reported. If $path\nis a directory, both modifications to the directory itself (for example\npermission changes) and to files in the directory (including new files in\nthe directory) are reported.\n\n:$scheduler allows you to specify which thread scheduler is responsible for\nthe notification stream.","n":"watch-path"}],"k":"c","mro":["Any"],"b":"A"},{"b":"A","m":[{"n":"IO","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"path"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"event"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["Any"],"a":[{"t":"Mu","n":"$.path","k":"v"},{"k":"v","t":"Mu","n":"$.event"}],"t":"IO::Notification::Change","n":"IO::Notification::Change"},{"m":[{"n":"BUILD","s":{"p":[":path($!path)!",":SPEC($!SPEC)!",":CWD($!CWD)!","*%_"],"r":"Nil"},"m":0,"k":"s"},{"s":{"r":"Mu","p":["Str $path",":$SPEC = { ... }","Str:D :$CWD","*%_"]},"k":"m","m":1,"n":"new","d":"Defined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead."},{"s":{"p":["Str $path",":$SPEC = { ... }",":$CWD = { ... }","*%_"],"r":"Mu"},"m":1,"k":"m","n":"new","d":"Defined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead."},{"m":1,"k":"m","s":{"p":["Cool $path",":$SPEC = { ... }",":$CWD = { ... }","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead.","n":"new"},{"n":"new","d":"Defined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead.","s":{"r":"Mu","p":[":$basename!",":$dirname = \"\"",":$volume = \"\"",":$SPEC = { ... }",":$CWD = { ... }","*%_"]},"k":"m","m":1},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead.","n":"new"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method is-absolute(IO::Path:D: --> Bool)\n\nReturns True if the path is an absolute path, and False otherwise.\n\n    \"/foo\".IO.is-absolute.say; # OUTPUT: «True␤»\n    \"bars\".IO.is-absolute.say; # OUTPUT: «False␤»\n\nNote that on Windows a path that starts with a slash or backslash is still\nconsidered absolute even if no volume was given, as it is absolute for that\nparticular volume:\n\n    IO::Path::Win32.new(\"/foo\"  ).is-absolute.say; # OUTPUT: «True␤»\n    IO::Path::Win32.new(\"C:/foo\").is-absolute.say; # OUTPUT: «True␤»\n    IO::Path::Win32.new(\"C:foo\" ).is-absolute.say; # OUTPUT: «False␤»","n":"is-absolute"},{"d":"Defined as:\n\n    method is-relative(IO::Path:D: --> Bool)\n\nReturns True if the path is a relative path, and False otherwise. Windows\ncaveats for .is-absolute apply.","n":"is-relative","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method parts(IO::Path:D: --> Map:D)\n\nReturns a Map with the keys volume, dirname, basename whose values are the\nsame as available via methods .volume, .dirname, and .basename\nrespectively.\n\n    say IO::Path::Win32.new(\"C:/rakudo/perl6.bat\").parts.perl;\n    # OUTPUT: «Map.new((:basename(\"perl6.bat\"),:dirname(\"/rakudo\"),:volume(\"C:\")))␤»","n":"parts"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"volume","d":"Defined as:\n\n    method volume(IO::Path:D:)\n\nReturns the volume portion of the path object. On Unix system, this is\nalways the empty string.\n\n    say IO::Path::Win32.new(\"C:\\\\Windows\\\\registry.ini\").volume;    # OUTPUT: «C:␤»"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method dirname(IO::Path:D:)\n\nReturns the directory name portion of the path object. That is, it returns\nthe path excluding the volume and the base name. Unless the dirname consist\nof only the directory separator (i.e. it's the top directory), the trailing\ndirectory separator will not be included in the return value.\n\n    say IO::Path.new(\"/home/camelia/myfile.p6\").dirname; # OUTPUT: «/home/camelia␤»\n    say IO::Path::Win32.new(\"C:/home/camelia\").dirname;  # OUTPUT: «/home␤»\n    say IO::Path.new(\"/home\").dirname;                   # OUTPUT: «/␤»","n":"dirname"},{"n":"basename","d":"Defined as:\n\n    method basename(IO::Path:D:)\n\nReturns the basename part of the path object, which is the name of the\nfilesystem object itself that is referenced by the path.\n\n    \"docs/README.pod\".IO.basename.say; # OUTPUT: «README.pod␤»\n    \"/tmp/\".IO.basename.say;           # OUTPUT: «tmp␤»\n\nNote that in IO::Spec::Win32 semantics, the basename of a Windows share is\n\\, not the name of the share itself:\n\n    IO::Path::Win32.new('//server/share').basename.say; # OUTPUT: «\\␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","n":"extension"},{"d":"Defined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","n":"extension","k":"m","m":1,"s":{"r":"Mu","p":["Int :$parts!","*%_"]}},{"d":"Defined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","n":"extension","k":"m","m":1,"s":{"r":"Mu","p":["Range :$parts!","*%_"]}},{"n":"extension","d":"Defined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","s":{"p":["Str $subst","Int :$parts = 1","Str :$joiner = { ... }","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"extension","d":"Defined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","s":{"p":["Str $subst","Range :$parts","Str :$joiner = { ... }","*%_"],"r":"Mu"},"k":"m","m":1},{"n":"Numeric","d":"Defined as:\n\n    method Numeric(IO::Path:D: --> Numeric:D)\n\nCoerces .basename to Numeric. Fails with X::Str::Numeric if base name is\nnot numerical.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"sibling","d":"Defined as:\n\n    method sibling(IO::Path:D: Str() $sibling --> IO::Path:D)\n\nAllows to reference a sibling file or directory. Returns a new IO::Path\nbased on the invocant, with the .basename changed to $sibling. The $sibling\nis allowed to be a multi-part path fragment; see also .add.\n\n    say '.bashrc'.IO.sibling: '.bash_aliases'; # OUTPUT: «.bash_aliases\".IO␤»\n    say '/home/camelia/.bashrc'.IO.sibling: '.bash_aliases';\n    # OUTPUT: «/home/camelia/.bash_aliases\".IO␤»\n\n    say '/foo/' .IO.sibling: 'bar';  # OUTPUT: «/bar\".IO␤»\n    say '/foo/.'.IO.sibling: 'bar';  # OUTPUT: «/foo/bar\".IO␤»","s":{"p":["\\sibling","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"succ","d":"Defined as:\n\n    method succ(IO::Path:D: --> IO::Path:D)\n\nReturns a new IO::Path constructed from the invocant, with .basename\nchanged by calling Str.succ on it.\n\n    \"foo/file02.txt\".IO.succ.say; # OUTPUT: «\"foo/file03.txt\".IO␤»"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pred","d":"Defined as:\n\n    method pred(IO::Path:D: --> IO::Path:D)\n\nReturns a new IO::Path constructed from the invocant, with .basename\nchanged by calling Str.pred on it.\n\n    \"foo/file02.txt\".IO.pred.say; # OUTPUT: «\"foo/file01.txt\".IO␤»"},{"k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    method open(IO::Path:D: *%opts)\n\nOpens the path as a file; the named options control the mode, and are the\nsame as the open function accepts.","n":"open"},{"n":"watch","d":"Defined as:\n\n    method watch(IO::Path:D: --> Supply:D)\n\nEquivalent to calling IO::Notification.watch-path with the invocant as the\nargument.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"absolute","d":"Defined as:\n\n    multi method absolute(IO::Path:D: --> Str)\n    multi method absolute(IO::Path:D: $base --> Str)\n\nReturns a new Str object that is an absolute path. If the invocant is not\nalready an absolute path, it is first made absolute using $base as base, if\nit is provided, or the .CWD attribute the object was created with if it is\nnot.","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["$CWD","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method absolute(IO::Path:D: --> Str)\n    multi method absolute(IO::Path:D: $base --> Str)\n\nReturns a new Str object that is an absolute path. If the invocant is not\nalready an absolute path, it is first made absolute using $base as base, if\nit is provided, or the .CWD attribute the object was created with if it is\nnot.","n":"absolute"},{"d":"Defined as:\n\n    method relative(IO::Path:D: $base = $*CWD --> Str)\n\nReturns a new Str object with the path relative to the $base. If $base is\nnot provided, $*CWD is used in its place. If the invocant is not an\nabsolute path, it's first made to be absolute using the .CWD attribute the\nobject was created with, and then is made relative to $base.","n":"relative","k":"m","m":0,"s":{"p":["$CWD = { ... }","*%_"],"r":"Mu"}},{"n":"cleanup","d":"Defined as:\n\n    method cleanup(IO::Path:D: --> IO::Path:D)\n\nReturns a new path that is a canonical representation of the invocant path,\ncleaning up any extraneous path parts:\n\n    \"foo/./././..////bar\".IO.cleanup.say;      # OUTPUT: «\"foo/../bar\".IO␤»\n    IO::Path::Win32.new(\"foo/./././..////bar\")\n        .cleanup.say; \"foo\\..\\bar\".IO;         # OUTPUT: «\"foo\\..\\bar\".IO␤»\n\nNote that no filesystem access is made. See also resolve.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"resolve","d":"Defined as:\n\n    method resolve(IO::Path:D: :$completely --> IO::Path)\n\nReturns a new IO::Path object with all symbolic links and references to the\nparent directory (..) resolved. This means that the filesystem is examined\nfor each directory in the path, and any symlinks found are followed.\n\n    # bar is a symlink pointing to \"/baz\"\n    my $io = \"foo/./bar/..\".IO.resolve;      # now \"/\" (the parent of \"/baz\")\n\nIf :$completely, which defaults to False, is set to a true value, the\nmethod will fail with X::IO::Resolve if it cannot completely resolve the\npath, otherwise, it will resolve as much as possible, and will merely\nperform cleanup of the rest of the path. The last part of the path does NOT\nhave to exist to :$completely resolve the path.\n\nNOTE: Currently (April 2017) this method doesn't work correctly on all\nplatforms, e.g. Windows, since it assumes POSIX semantics.","s":{"r":"Mu","p":[":$completely","*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["Int:D $depth where { ... }","*%_"]},"m":1,"k":"m","n":"parent","d":"Defined as:\n\n    multi method parent(IO::Path:D:)\n    multi method parent(IO::Path:D: UInt:D $level)\n\nReturns the parent path of the invocant. Note that no actual filesystem\naccess is made, so the returned parent is physical and not the logical\nparent of symlinked directories.\n\n    '/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    './'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n    'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n    '/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\n    IO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»\n\nIf $level is specified, the call is equivalent to calling .parent() $level\ntimes:\n\n    say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"parent","d":"Defined as:\n\n    multi method parent(IO::Path:D:)\n    multi method parent(IO::Path:D: UInt:D $level)\n\nReturns the parent path of the invocant. Note that no actual filesystem\naccess is made, so the returned parent is physical and not the logical\nparent of symlinked directories.\n\n    '/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    './'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n    'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n    '/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\n    IO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»\n\nIf $level is specified, the call is equivalent to calling .parent() $level\ntimes:\n\n    say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»"},{"s":{"p":["\\child","*%_"],"r":"Mu"},"m":0,"k":"m","n":"child","d":"Defined as:\n\n    method child(IO::Path:D: Str() $childname --> IO::Path:D)\n\nAlias for .add. NOTE: This method has been deprecated as of the 6.d\nversion, and will be removed in the future. For any new code, please use\n.add"},{"k":"m","m":0,"s":{"r":"Mu","p":["\\what","*%_"]},"d":"Defined as:\n\n    method add(IO::Path:D: Str() $what --> IO::Path:D)\n\nConcatenates a path fragment to the invocant and returns the resultant\nIO::Path. If adding ../ to paths that end with a file, you may need to call\nresolve for the resultant path to be accessible by other IO::Path methods\nlike dir or open. See also sibling and parent.\n\n    \"foo/bar\".IO.mkdir;\n    \"foo/bar\".IO.add(\"meow\")    .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n    \"foo/bar\".IO.add(\"/meow\")   .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n    \"foo/bar\".IO.add(\"meow.txt\").resolve.relative.say; # OUTPUT: «foo/bar/meow.txt␤»\n    \"foo/bar\".IO.add(\"../meow\") .resolve.relative.say; # OUTPUT: «foo/meow␤»\n    \"foo/bar\".IO.add(\"../../\")  .resolve.relative.say; # OUTPUT: «.␤»","n":"add"},{"d":"Defined as:\n\n    multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)\n\nDEPRECATION NOTICE: this method will be deprecated in 6.d language and\nremoved in 6.e. Do not use it for new code. Instead, create a new path or\nuse add method. For altering current working directory see &chdir and\n&*chdir subroutines.\n\nContrary to the name, the .chdir method does not change any directories,\nbut merely concatenates the given $path to the invocant and returns the\nresultant IO::Path. Optional file tests can be performed by providing :d,\n:r, :w, or :x Bool named arguments; when set to True, they'll perform .d,\n.r, .w, and .x tests respectively. By default, only :d is set to True.\n\n  sub mkdir\n\nDefined as:\n\n    method mkdir(IO::Path:D: Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory, including its parent directories, as needed\n(similar to *nix utility mkdir with -p option). That is, mkdir\n\"foo/bar/ber/meow\" will create foo, foo/bar, and foo/bar/ber directories as\nwell if they do not exist.\n\nReturns the IO::Path object pointing to the newly created directory on\nsuccess; fails with X::IO::Mkdir if directory cannot be created.\n\nSee also mode for explanation and valid values for $mode.","n":"chdir","m":1,"k":"m","s":{"p":["$path",":$test!","*%_"],"r":"Mu"}},{"s":{"p":["IO $path","|c is raw"],"r":"Mu"},"k":"m","m":1,"n":"chdir","d":"Defined as:\n\n    multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)\n\nDEPRECATION NOTICE: this method will be deprecated in 6.d language and\nremoved in 6.e. Do not use it for new code. Instead, create a new path or\nuse add method. For altering current working directory see &chdir and\n&*chdir subroutines.\n\nContrary to the name, the .chdir method does not change any directories,\nbut merely concatenates the given $path to the invocant and returns the\nresultant IO::Path. Optional file tests can be performed by providing :d,\n:r, :w, or :x Bool named arguments; when set to True, they'll perform .d,\n.r, .w, and .x tests respectively. By default, only :d is set to True.\n\n  sub mkdir\n\nDefined as:\n\n    method mkdir(IO::Path:D: Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory, including its parent directories, as needed\n(similar to *nix utility mkdir with -p option). That is, mkdir\n\"foo/bar/ber/meow\" will create foo, foo/bar, and foo/bar/ber directories as\nwell if they do not exist.\n\nReturns the IO::Path object pointing to the newly created directory on\nsuccess; fails with X::IO::Mkdir if directory cannot be created.\n\nSee also mode for explanation and valid values for $mode."},{"s":{"r":"Mu","p":["$path is copy",":$d = Bool::True",":$r",":$w",":$x","*%_"]},"k":"m","m":1,"n":"chdir","d":"Defined as:\n\n    multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)\n\nDEPRECATION NOTICE: this method will be deprecated in 6.d language and\nremoved in 6.e. Do not use it for new code. Instead, create a new path or\nuse add method. For altering current working directory see &chdir and\n&*chdir subroutines.\n\nContrary to the name, the .chdir method does not change any directories,\nbut merely concatenates the given $path to the invocant and returns the\nresultant IO::Path. Optional file tests can be performed by providing :d,\n:r, :w, or :x Bool named arguments; when set to True, they'll perform .d,\n.r, .w, and .x tests respectively. By default, only :d is set to True.\n\n  sub mkdir\n\nDefined as:\n\n    method mkdir(IO::Path:D: Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory, including its parent directories, as needed\n(similar to *nix utility mkdir with -p option). That is, mkdir\n\"foo/bar/ber/meow\" will create foo, foo/bar, and foo/bar/ber directories as\nwell if they do not exist.\n\nReturns the IO::Path object pointing to the newly created directory on\nsuccess; fails with X::IO::Mkdir if directory cannot be created.\n\nSee also mode for explanation and valid values for $mode."},{"m":0,"k":"m","s":{"p":["$to",":$createonly","*%_"],"r":"Bool"},"d":"Defined as:\n\n    method rename(IO::Path:D: IO() $to, :$createonly = False --> Bool:D)\n    sub    rename(IO() $from, IO() $to, :$createonly = False --> Bool:D)\n\nRenames a file or directory. Returns True on success; fails with\nX::IO::Rename if :$createonly is True and the $to path already exists or if\nthe operation failed for some other reason.\n\nNote: some renames will always fail, such as when the new name is on a\ndifferent storage device. See also: move.","n":"rename"},{"d":"Defined as:\n\n    method copy(IO::Path:D: IO() $to, :$createonly --> Bool:D)\n    sub    copy(IO() $from, IO() $to, :$createonly --> Bool:D)\n\nCopies a file. Returns True on success; fails with X::IO::Copy if\n:$createonly is True and the $to path already exists or if the operation\nfailed for some other reason, such as when $to and $from are the same\nfile.","n":"copy","k":"m","m":0,"s":{"p":["$to",":$createonly","*%_"],"r":"Bool"}},{"k":"m","m":0,"s":{"r":"Bool","p":["|c is raw"]},"d":"Defined as:\n\n    method move(IO::Path:D: IO() $to, :$createonly --> Bool:D)\n    sub    move(IO() $from, IO() $to, :$createonly --> Bool:D)\n\nCopies a file and then removes the original. If removal fails, it's\npossible to end up with two copies of the file. Returns True on success;\nfails with X::IO::Move if :$createonly is True and the $to path already\nexists or if the operation failed for some other reason, such as when $to\nand $from are the same file.\n\nTo avoid copying, you can use rename, if the files are on the same storage\ndevice. It also works with directories, while move does not.","n":"move"},{"d":"Defined as:\n\n    method chmod(IO::Path:D: Int() $mode --> Bool)\n\nChanges the POSIX permissions of a file or directory to $mode. Returns True\non success; on failure, fails with X::IO::Chmod.\n\nThe mode is expected as an integer following the standard numeric notation,\nand is best written as an octal number:\n\n    'myfile'.IO.chmod(0o444);          # make a file read-only\n    'somedir'.IO.chmod(0o777);         # set 0777 permissions on a directory\n\n\nMake sure you don't accidentally pass the intended octal digits as a\ndecimal number (or string containing a decimal number):\n\n    'myfile'.IO.chmod:  '0444';        # BAD!!! (interpreted as mode 0o674)\n    'myfile'.IO.chmod: '0o444';        # OK (an octal in a string)\n    'myfile'.IO.chmod:  0o444;         # Also OK (an octal literal)","n":"chmod","k":"m","m":0,"s":{"r":"Bool","p":["$mode","*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Bool"},"d":"Defined as:\n\n    method unlink(IO::Path:D: --> True)\n    sub    unlink(*@filenames --> List:D)\n\nDelete all specified ordinary files, links, or symbolic links for which\nthere are privileges to do so. See rmdir to delete directories.\n\nThe subroutine form returns the names of all the files in the list,\nexcluding those for which the filesystem raised some error; since trying to\ndelete a file that does not exist does not raise any error at that level,\nthis list will include the names of the files in the list that do not\nexist.\n\nThe method form returns True on success, or fails with X::IO::Unlink if the\noperation could not be completed. If the file to be deleted does not exist,\nthe routine treats it as success.\n\n    'foo.txt'.IO.open(:w).close;\n    'bar'.IO.mkdir;\n    say unlink <foo.txt  bar  not-there.txt>; # OUTPUT: «[foo.txt not-there.txt]␤»\n    # `bar` is not in output because it failed to delete (it's a directory)\n    # `not-there.txt` is present. It never existed, so that's deemed a success.\n\n    # Method form `fail`s:\n    say .exception.message without 'bar'.IO.unlink;\n    # OUTPUT: «Failed to remove the file […] illegal operation on a directory␤»","n":"unlink"},{"s":{"p":["$name","*%_"],"r":"Bool"},"m":0,"k":"m","n":"symlink","d":"Defined as:\n\n    method symlink(IO::Path:D $target: IO() $link --> Bool:D)\n    sub    symlink(      IO() $target, IO() $link --> Bool:D)\n\nCreate a new symbolic link $link to existing $target. Returns True on\nsuccess; fails with X::IO::Symlink if the symbolic link could not be\ncreated. If $target does not exist, creates a dangling symbolic link. To\ncreate a hard link, see link.\n\nNote: on Windows, creation of symbolic links may require escalated\nprivileges."},{"d":"Defined as:\n\n    method link(IO::Path:D $target: IO() $link --> Bool:D)\n    sub    link(      IO() $target, IO() $link --> Bool:D)\n\nCreate a new hard link $link to existing $target. Returns True on success;\nfails with X::IO::Link if the hard link could not be created. To create a\nsymbolic link, see symlink.","n":"link","k":"m","m":0,"s":{"p":["$name","*%_"],"r":"Bool"}},{"m":0,"k":"m","s":{"p":["$mode = 511","*%_"],"r":"Mu"},"n":"mkdir"},{"s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m","n":"rmdir","d":"Defined as:\n\n    sub    rmdir(*@dirs --> List:D)\n    method rmdir(IO::Path:D: --> True)\n\nRemove the invocant, or in sub form, all of the provided directories in the\ngiven list, which can contain any Cool object. Only works on empty\ndirectories.\n\nMethod form returns True on success and throws an exception of type\nX::IO::Rmdir if the directory cannot be removed (e.g. the directory is not\nempty, or the path is not a directory). Subroutine form returns a list of\ndirectories that were successfully deleted.\n\nTo delete non-empty directory, see rmtree in File::Directory::Tree module."},{"s":{"p":["Mu :$test = { ... }","*%_"],"r":"Mu"},"k":"m","m":1,"n":"dir","d":"Defined as:\n\n    sub    dir(Cool $path = '.', Mu :$test = none('.', '..'))\n    method dir(IO::Path:D: Mu :$test = none('.', '..'))\n\nReturns the contents of a directory as a lazy list of IO::Path objects\nrepresenting relative paths, filtered by smartmatching their names (as\nstrings) against the :test parameter.\n\nSince the tests are performed against Str arguments, not IO, the tests are\nexecuted in the $*CWD, instead of the target directory. When testing\nagainst file test operators, this won't work:\n\n    dir('mydir', test => { .IO.d })\n\nwhile this will:\n\n    dir('mydir', test => { \"mydir/$_\".IO.d })\n\nNOTE: a dir call opens a directory for reading, which counts towards\nmaximum per-process open files for your program. Be sure to exhaust\nreturned Seq before doing something like recursively performing more dir\ncalls. You can exhaust it by assigning to a @-sigiled variable or simply\nlooping over it. Note how examples below push further dirs to look through\ninto an Array, rather than immediately calling dir on them. See also\nIO::Dir module that gives you finer control over closing dir handles.\n\nExamples:\n\n    # To iterate over the contents of the current directory:\n    for dir() -> $file {\n        say $file;\n    }\n\n    # As before, but include even '.' and '..' which are filtered out by\n    # the default :test matcher:\n    for dir(test => *) -> $file {\n        say $file;\n    }\n\n    # To get the names of all .jpg and .jpeg files in ~/Downloads:\n    my @jpegs = $*HOME.dir: test => /:i '.' jpe?g $/;\n\nAn example program that lists all files and directories recursively:\n\n    sub MAIN($dir = '.') {\n        my @todo = $dir.IO;\n        while @todo {\n            for @todo.pop.dir -> $path {\n                say $path.Str;\n                @todo.push: $path if $path.d;\n            }\n        }\n    }\n\nA lazy way to find the first three files ending in \".p6\" recursively\nstarting from the current directory:\n\n    my @stack = '.'.IO;\n    my $perl-files = gather while @stack {\n        with @stack.pop {\n            when :d { @stack.append: .dir }\n            .take when .extension.lc eq 'p6'\n        }\n    }\n    .put for $perl-files[^3];\n\n\n  File test operators\n\nFor most file tests, you can do a smartmatch ~~ or you can call a method.\nYou don't need to actually open a filehandle in the traditional way\n(although you can) to do a filetest. You can simply append .IO to the\nfilename. For instance, here is how to check whether a file is readable\nusing smartmatch:\n\n    '/path/to/file'.IO ~~ :r;\n\nFile tests include:\n\n  * :d (Directory)\n\n  * :e (Exists)\n\n  * :f (File)\n\n  * :l (Symbolic link)\n\n  * :r (Readable)\n\n  * :rw (Readable and writable)\n\n  * :rwx (Readable, writable and executable)\n\n  * :s (Size)\n\n  * :w (Writable)\n\n  * :x (Executable)\n\n  * :z (Zero size)\n\nSmartmatching on Pairs can be used to perform multiple tests at once:\n\n    say :d & :x;                # OUTPUT: «all(d => True, x => True)␤»\n    say '/tmp'.IO ~~ :d & :x;   # OUTPUT: «True␤»\n    say '/'.IO    ~~ :d & :rw;  # OUTPUT: «False␤»\n\nAll of the above tests can be used as methods (without the colon), though\nmethod tests may throw X::IO::DoesNotExist as documented below. Three tests\nonly exist as methods: accessed, changed and modified.\n\nYou can also perform file tests on an already opened filehandle by testing\nagainst its .path method. For example, given filehandle $fh:\n\n    $fh.path ~~ :r;\n    $fh.path.r;       # method form"},{"n":"slurp","d":"Defined as:\n\n    multi method slurp(IO::Path:D: :$bin, :$enc)\n\nRead all of the file's content and return it as either Buf, if :$bin is\nTrue, or if not, as Str decoded with :$enc encoding, which defaults to\nutf8. File will be closed afterwards. See &open for valid values for\n:$enc.","s":{"r":"Mu","p":[":$enc",":$bin","*%_"]},"k":"m","m":1},{"n":"spurt","d":"Defined as:\n\n    method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)\n\nOpens the file path for writing, and writes all of the $data into it. File\nwill be closed, afterwards. Will fail if it cannot succeed for any reason.\nThe $data can be any Cool type or any Blob type. Arguments are as follows:\n\n  * :$enc — character encoding of the data. Takes same values as :$enc in\n  IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.\n\n  * :$append — open the file in append mode, preserving existing contents, and\n  appending data to the end of the file.\n\n  * :$createonly — fail if the file already exists.","s":{"r":"Mu","p":["$data",":$enc",":$append",":$createonly","*%_"]},"m":0,"k":"m"},{"n":"lines","d":"Defined as:\n\n    method lines(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)\n\nOpens the invocant and returns its lines.\n\nThe behavior is equivalent to opening the file specified by the invocant,\nforwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open,\nthen calling IO::Handle.lines on that handle, forwarding any of the\nremaining arguments to that method, and returning the resultant Seq.\n\nNOTE: the lines are ready lazily and the handle used under the hood won't\nget closed until the returned Seq is fully reified, so ensure it is, or\nyou'll be leaking open filehandles. (TIP: use the $limit argument)\n\n    say \"The file contains \",\n      '50GB-file'.IO.lines.grep(*.contains: 'Perl').elems,\n      \" lines that mention Perl\";\n    # OUTPUT: «The file contains 72 lines that mention Perl␤»","s":{"p":[":$chomp = Bool::True",":$enc = \"utf8\"",":$nl-in = { ... }","|c is raw"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":[":$chomp = Bool::True",":$enc = \"utf8\"",":$nl-in = { ... }","|c is raw"]},"d":"Defined as:\n\n    method comb(IO::Path:D: |args --> Seq:D)\n\nOpens the file and processes its contents the same way Str.comb does,\ntaking the same arguments. Implementations may slurp the file in its\nentirety when this method is called.","n":"comb"},{"d":"Defined as:\n\n    method split(IO::Path:D: |args --> Seq:D)\n\nOpens the file and processes its contents the same way Str.split does,\ntaking the same arguments. Implementations may slurp the file in its\nentirety when this method is called.","n":"split","k":"m","m":0,"s":{"r":"Mu","p":[":$chomp = Bool::True",":$enc = \"utf8\"",":$nl-in = { ... }","|c is raw"]}},{"n":"words","d":"Defined as:\n\n    method words(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)\n\nOpens the invocant and returns its words.\n\nThe behavior is equivalent to opening the file specified by the invocant,\nforwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open,\nthen calling IO::Handle.words on that handle, forwarding any of the\nremaining arguments to that method, and returning the resultant Seq.\n\nNOTE: words are lazily read. The handle used under the hood is not closed\nuntil the returned Seq is fully reified, and this could lead to leaking\nopen filehandles. It is possible to avoid leaking open filehandles using\nthe $limit argument to cut down the Seq of words to be generated.\n\n    my %dict := bag 'my-file.txt'.IO.words;\n    say \"Most common words: \", %dict.sort(-*.value).head: 5;","s":{"r":"Mu","p":[":$chomp = Bool::True",":$enc = \"utf8\"",":$nl-in = { ... }","|c is raw"]},"m":0,"k":"m"},{"n":"e","d":"Defined as:\n\n    method e(--> Bool:D)\n\nReturns True if the invocant is a path that exists.","s":{"p":["*%_"],"r":"Bool:D"},"k":"m","m":0},{"d":"Defined as:\n\n    method d(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a directory. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","n":"d","m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]},"d":"Defined as:\n\n    method f(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a file. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","n":"f"},{"k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]},"d":"Defined as:\n\n    method s(--> Int:D)\n\nReturns the file size in bytes. May be called on paths that are\ndirectories, in which case the reported size is dependent on the operating\nsystem. The method will fail with X::IO::DoesNotExist if the path points to\na non-existent filesystem entity.\n\n    say $*EXECUTABLE.IO.s; # OUTPUT : «467␤»","n":"s"},{"n":"l","d":"Defined as:\n\n    method l(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a symlink. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","s":{"r":"Bool:D","p":["*%_"]},"k":"m","m":0},{"n":"r","d":"Defined as:\n\n    method r(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is accessible. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","s":{"r":"Bool:D","p":["*%_"]},"k":"m","m":0},{"n":"w","d":"Defined as:\n\n    method w(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is writable. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","s":{"p":["*%_"],"r":"Bool:D"},"k":"m","m":0},{"n":"rw","d":"Defined as:\n\n    method rw(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is readable and\nwritable. The method will fail with X::IO::DoesNotExist if the path points\nto a non-existent filesystem entity.","s":{"r":"Bool:D","p":["*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method x(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is executable. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","n":"x","k":"m","m":0,"s":{"r":"Bool:D","p":["*%_"]}},{"n":"rwx","d":"Defined as:\n\n    method rwx(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is executable,\nreadable, and writable. The method will fail with X::IO::DoesNotExist if\nthe path points to a non-existent filesystem entity.","s":{"r":"Bool:D","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Bool:D"},"m":0,"k":"m","n":"z","d":"Defined as:\n\n    method z(--> Bool:D)\n\nReturns True if the invocant is a path that exists and has size of 0. May\nbe called on paths that are directories, in which case the reported file\nsize (and thus the result of this method) is dependent on the operating\nsystem. The method will fail with X::IO::DoesNotExist if the path points to\na non-existent filesystem entity."},{"s":{"r":"Instant:D","p":["*%_"]},"m":0,"k":"m","n":"modified","d":"Returns an Instant object indicating when the content of the file was last\nmodified. Compare with changed.\n\n    say \"path/to/file\".IO.modified;          # Instant:1424089165\n    say \"path/to/file\".IO.modified.DateTime; # 2015-02-16T12:18:50Z"},{"s":{"p":["*%_"],"r":"Instant:D"},"m":0,"k":"m","n":"accessed","d":"Return an Instant object representing the timestamp when the file was last\naccessed. Note: depending on how the filesystem was mounted, the last\naccessed time may not update on each access to the file, but only on the\nfirst access after modifications.\n\n    say \"path/to/file\".IO.accessed;          # Instant:1424353577\n    say \"path/to/file\".IO.accessed.DateTime; # 2015-02-19T13:45:42Z"},{"d":"Returns an Instant object indicating the metadata of the file or directory\nwas last changed (e.g. permissions, or files created/deleted in directory).\nCompare with modified.\n\n    say \"path/to/file\".IO.changed;           # Instant:1424089165\n    say \"path/to/file\".IO.changed.DateTime;  # 2015-02-16T12:18:50Z\n\n\nFile permissions retrieval","n":"changed","m":0,"k":"m","s":{"r":"Instant:D","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"IntStr:D"},"d":"Return an IntStr object representing the POSIX permissions of a file. The\nStr part of the result is the octal representation of the file permission,\nlike the form accepted by the chmod(1) utility.\n\n    say ~\"path/to/file\".IO.mode;  # e.g. '0644'\n    say +\"path/to/file\".IO.mode;  # e.g. 420, where sprintf('%04o', 420) eq '0644'\n\n\nThe result of this can be used in the other methods that take a mode as an\nargument.\n\n    \"path/to/file1\".IO.chmod(\"path/to/file2\".IO.mode);  # will change the\n                                                        # permissions of file1\n                                                        # to be the same as file2","n":"mode"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method SPEC(IO::Path:D: --> IO::Spec)\n\nReturns the IO::Spec object that was (implicitly) specified at object\ncreation time.\n\n    my $io = IO::Path.new(\"/bin/bash\");\n    say $io.SPEC;                            # OUTPUT: «(Unix)␤»\n    say $io.SPEC.dir-sep;                    # OUTPUT: «/␤»\n\nFile timestamp retrieval\n\nThere are also 3 methods for fetching the 3 timestamps of a file (inode),\non Operating Systems where these are available:","n":"SPEC"},{"n":"CWD","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"path"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"n":"!new-from-absolute-path","m":0,"k":"m","s":{"p":["$path",":$SPEC = { ... }",":$CWD = { ... }","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["$path","*%_"]},"m":0,"k":"m","n":"!set-absolute"}],"k":"c","mro":["IO","Cool"],"d":"TITLE\nclass IO::Path\n\nSUBTITLE\nFile or directory path\n\n    class IO::Path is Cool does IO { }\n\n\nIO::Path is the workhorse of IO operations.\n\nConceptually, an IO::Path object consists of a volume, a directory, and a\nbasename. It supports both purely textual operations, and operations that\naccess the filesystem, e.g. to resolve a path, or to read all content of a\nfile.\n\nAt creation, each IO::Path object is given information about the current\nworking directory the path might be relative to using the $.CWD attribute\n(defaults to $*CWD), as well as what operating system semantics should be\nused for path manipulation using the special IO::Spec type given in the\n$.SPEC attribute.\n\nThe $.SPEC defaults to the value of $*SPEC, which uses the object suitable\nfor the operating system the code is currently running on. This is the\ndefault most code will be comfortable with.\n\nIn certain situations, e.g. testing, you may wish to force $*SPEC to use\none of the specific SPEC modules: IO::Spec::Unix, IO::Spec::Win32,\nIO::Spec::Cygwin, and IO::Spec::QNX, or to create IO::Path objects via\nshortcut subclasses IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin, and\nIO::Path::QNX that pre-set the $.SPEC attribute for you.\n\nThe rest of this document silently assumes Unix semantics in its examples,\nunless stated otherwise.\n\n","a":[{"n":"$.SPEC","t":"IO::Spec","k":"v"},{"k":"v","n":"$.CWD","t":"Str"},{"n":"$.path","t":"Str","k":"v"},{"k":"v","t":"Bool","n":"$!is-absolute"},{"k":"v","t":"Str","n":"$!abspath"},{"k":"v","t":"Associative","n":"%!parts"}],"t":"IO::Path","n":"IO::Path","b":"C"},{"n":"IO::Path::Win32","t":"IO::Path::Win32","a":[{"t":"IO::Spec","n":"$.SPEC","k":"v"},{"t":"Str","n":"$.CWD","k":"v"},{"t":"Str","n":"$.path","k":"v"},{"k":"v","t":"Bool","n":"$!is-absolute"},{"t":"Str","n":"$!abspath","k":"v"},{"k":"v","n":"%!parts","t":"Associative"}],"d":"TITLE\nclass IO::Path::Win32\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Win32\n\n    class IO::Path::Win32 is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Win32 in the $.SPEC\nattribute.\n\n","mro":["IO","IO::Path"],"k":"c","m":[{"n":"new","d":"Same as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Win32, regardless of the operating system the code is being run\non.","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"b":"C"},{"k":"c","m":[{"s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0,"n":"new","d":"Same as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Cygwin, regardless of the operating system the code is being run\non."},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["IO","IO::Path"],"a":[{"n":"$.SPEC","t":"IO::Spec","k":"v"},{"t":"Str","n":"$.CWD","k":"v"},{"t":"Str","n":"$.path","k":"v"},{"k":"v","t":"Bool","n":"$!is-absolute"},{"t":"Str","n":"$!abspath","k":"v"},{"k":"v","n":"%!parts","t":"Associative"}],"d":"TITLE\nclass IO::Path::Cygwin\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Cygwin\n\n    class IO::Path::Cygwin is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Cygwin in the $.SPEC\nattribute.\n\n","t":"IO::Path::Cygwin","n":"IO::Path::Cygwin","b":"C"},{"t":"IO::Path::QNX","a":[{"k":"v","n":"$.SPEC","t":"IO::Spec"},{"k":"v","n":"$.CWD","t":"Str"},{"k":"v","t":"Str","n":"$.path"},{"n":"$!is-absolute","t":"Bool","k":"v"},{"k":"v","t":"Str","n":"$!abspath"},{"k":"v","n":"%!parts","t":"Associative"}],"d":"TITLE\nclass IO::Path::QNX\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::QNX\n\n    class IO::Path::QNX is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::QNX in the $.SPEC\nattribute.\n\n","n":"IO::Path::QNX","m":[{"n":"new","d":"Same as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::QNX, regardless of the operating system the code is being run\non.","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["IO","IO::Path"],"b":"C"},{"b":"C","n":"IO::Path::Unix","t":"IO::Path::Unix","a":[{"k":"v","t":"IO::Spec","n":"$.SPEC"},{"t":"Str","n":"$.CWD","k":"v"},{"k":"v","t":"Str","n":"$.path"},{"k":"v","t":"Bool","n":"$!is-absolute"},{"t":"Str","n":"$!abspath","k":"v"},{"k":"v","t":"Associative","n":"%!parts"}],"d":"TITLE\nclass IO::Path::Unix\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Unix\n\n    class IO::Path::Unix is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Unix in the $.SPEC\nattribute.\n\n","mro":["IO","IO::Path"],"k":"c","m":[{"d":"Same as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Unix, regardless of the operating system the code is being run\non.","n":"new","m":0,"k":"m","s":{"r":"Mu","p":["|c is raw"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}]},{"n":"IO::Handle","t":"IO::Handle","a":[{"n":"$.path","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!PIO"},{"k":"v","n":"$.chomp","t":"Mu"},{"k":"v","n":"$.nl-in","t":"Mu"},{"t":"Str:D","n":"$.nl-out","k":"v"},{"k":"v","n":"$.encoding","t":"Str"},{"k":"v","t":"Encoding::Decoder","n":"$!decoder"},{"n":"$!encoder","t":"Encoding::Encoder","k":"v"},{"k":"v","t":"int","n":"$!out-buffer"}],"d":"TITLE\nclass IO::Handle\n\nSUBTITLE\nOpened file or stream\n\n    class IO::Handle { }\n\nInstances of IO::Handle encapsulate an handle to manipulate input/output\nresources. Usually there is no need to create directly an IO::Handle\ninstance, since it will be done by other roles and methods. For instance,\nan IO::Path object provides an open method that returns an IO::Handle:\n\n    my $fh = '/tmp/log.txt'.IO.open;\n    say $fh.^name; # OUTPUT: IO::Handle\n\nThe first line is pretty much equivalent to the following piece of code:\n\n    my $fh = IO::Handle.new( :path( '/tmp/log.txt'.IO.path ) ).open;\n\n","mro":["Any"],"m":[{"n":"TWEAK","s":{"r":"Mu","p":[":$encoding",":$bin",":path($!path) = Nil","*%_"]},"m":0,"k":"s"},{"s":{"r":"Mu","p":[":$r",":$w",":$x",":$a",":$update",":$rw",":$rx",":$ra",":$mode is copy",":$create is copy",":$append is copy",":$truncate is copy",":$exclusive is copy",":$bin",":$enc is copy",":$chomp = { ... }",":$nl-in is copy = { ... }","Str:D :$nl-out is copy = { ... }",":$out-buffer is copy","*%_"]},"k":"m","m":0,"n":"open","d":"Defined as:\n\n    method open(IO::Handle:D:\n        :$bin, :$enc, :$chomp, :$nl-in, Str:D :$nl-out,\n        Str :$mode,\n        :$r, :$w, :$a, :$x, :$update, :$rw, :$rx, :$ra,\n        :$create, :$append, :$truncate, :$exclusive,\n        :$out-buffer,\n        --> IO::Handle:D\n    )\n\n\nOpens the handle in one of the modes. Fails with appropriate exception if\nthe open fails.\n\nSee description of individual methods for the accepted values and behavior\nof :$chomp, :$nl-in, :$nl-out, and :$enc. The values for parameters default\nto the invocant's attributes and if any of them are provided, the\nattributes will be updated to the new values. Specify :$bin set to True\ninstead of :$enc to indicate the handle should be opened in binary mode.\nSpecifying undefined value as :$enc is equivalent to not specifying :$enc\nat all. Specifying both a defined encoding as :$enc and :$bin set to true\nwill cause X::IO::BinaryAndEncoding exception to be thrown.\n\nThe open mode defaults to non-exclusive, read only (same as specifying :r)\nand can be controlled by a mix of the following arguments:\n\n    :r      same as specifying   :mode<ro>  same as specifying nothing\n\n    :w      same as specifying   :mode<wo>, :create, :truncate\n    :a      same as specifying   :mode<wo>, :create, :append\n    :x      same as specifying   :mode<wo>, :create, :exclusive\n\n    :update same as specifying   :mode<rw>\n    :rw     same as specifying   :mode<rw>, :create\n    :ra     same as specifying   :mode<rw>, :create, :append\n    :rx     same as specifying   :mode<rw>, :create, :exclusive\n\n\nSupport for combinations of modes other than what is listed above is\nimplementation-dependent and should be assumed unsupported. That is,\nspecifying, for example, .open(:r :create) or .open(:mode<wo> :append\n:truncate) might work or might cause the Universe to implode, depending on\na particular implementation. This applies to reads/writes to a handle\nopened in such unsupported modes as well.\n\nThe mode details are:\n\n    :mode<ro>  means \"read only\"\n    :mode<wo>  means \"write only\"\n    :mode<rw>  means \"read and write\"\n\n    :create    means the file will be created, if it does not exist\n    :truncate  means the file will be emptied, if it exists\n    :exclusive means .open will fail if the file already exists\n    :append    means writes will be done at the end of file's current contents\n\n\nAttempts to open a directory, write to a handle opened in read-only mode or\nread from a handle opened in write-only mode, or using text-reading methods\non a handle opened in binary mode will fail or throw.\n\nIn 6.c language, it's possible to open path '-', which will cause open to\nopen (if closed) the $*IN handle if opening in read-only mode or to open\nthe $*OUT handle if opening in write-only mode. All other modes in this\ncase will result in exception being thrown.\n\nAs of 6.d language version, use path '-' is deprecated and it will be\nremoved in future language versions entirely.\n\nThe :out-buffer controls output buffering and by default behaves as if it\nwere Nil. See method out-buffer for details.\n\nNote (Rakudo versions before 2017.09): Filehandles are NOT flushed or\nclosed when they go out of scope. While they will get closed when garbage\ncollected, garbage collection isn't guaranteed to get run. This means you\nshould use an explicit close on handles opened for writing, to avoid data\nloss, and an explicit close is recommended on handles opened for reading as\nwell, so that your program does not open too many files at the same time,\ntriggering exceptions on further open calls.\n\nNote (Rakudo versions 2017.09 and after): Open filehandles are\nautomatically closed on program exit, but it is still highly recommended\nthat you close opened handles explicitly."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"out-buffer","d":"Defined as:\n\n    method out-buffer(--> Int:D) is rw\n\nControls output buffering and can be set via an argument to open. Takes an\nint as the size of the buffer to use (zero is acceptable). Can take a Bool:\nTrue means to use default, implementation-defined buffer size; False means\nto disable buffering (equivalent to using 0 as buffer size).\n\nLastly, can take a Nil to enable TTY-based buffering control: if the handle\nis a TTY, the buffering is disabled, otherwise, default,\nimplementation-defined buffer size is used.\n\nSee flush to write out data currently in the buffer. Changing buffer size\nflushes the filehandle.\n\n    given 'foo'.IO.open: :w, :1000out-buffer {\n        .say: 'Hello world!'; # buffered\n        .out-buffer = 42;       # buffer resized; previous print flushed\n        .say: 'And goodbye';\n        .close; # closing the handle flushes the buffer\n    }"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method nl-in(--> Str:D) is rw\n\nOne of the attributes that can be set via .new or open. Defaults to\n[\"\\x0A\", \"\\r\\n\"]. Takes either a Str or Array of Str specifying input line\nending(s) for this handle. If .chomp attribute is set to True, will strip\nthese endings in routines that chomp, such as get and lines.\n\n    with 'test'.IO {\n        .spurt: '1foo2bar3foo'; # write some data into our test file\n        my $fh will leave {.close} = .open; # can also set .nl-in via .open arg\n        $fh.nl-in = [<foo bar>]; # set two possible line endings to use;\n        $fh.lines.say; # OUTPUT: (\"1\", \"2\", \"3\").Seq\n    }","n":"nl-in"},{"n":"close","d":"Defined as:\n\n    method close(IO::Handle:D: --> Bool:D)\n    multi sub close(IO::Handle $fh)\n\nCloses an open filehandle. It's not an error to call close on an\nalready-closed filehandle. Returns True on success. If you close one of the\nstandard filehandles (by default: $*IN, $*OUT, or $*ERR), that is any\nhandle with native-descriptor 2 or lower, you won't be able to re-open such\na handle.\n\nIt's a common idiom to use LEAVE phaser for closing the handles, which\nensures the handle is closed regardless of how the block is left.\n\n    if $do-stuff-with-the-file {\n        my $fh = open \"path-to-file\";\n        LEAVE close $fh;\n        # ... do stuff with the file\n    }\n\n    sub do-stuff-with-the-file (IO $path-to-file)\n      my $fh = $path-to-file.open;\n\n      # stick a `try` on it, since this will get run even when the sub is\n      # called with wrong arguments, in which case the `$fh` will be an `Any`\n      LEAVE try close $fh;\n\n      # ... do stuff with the file\n    }\n\n    given \"foo/bar\".IO.open(:w) {\n        .spurt: \"I ♥ Raku!\";\n        .close;\n    }\n\n\nNote: unlike some other languages, Raku does not use reference counting,\nand so the filehandles are NOT closed when they go out of scope. While they\nwill get closed when garbage collected, garbage collection isn't guaranteed\nto get run. This means you must use an explicit close on handles opened for\nwriting, to avoid data loss, and an explicit close is recommended on\nhandles opened for reading as well, so that your program does not open too\nmany files at the same time, triggering exceptions on further open calls.\n\nNote several methods allow for providing :close argument, to close the\nhandle after the operation invoked by the method completes. As a simpler\nalternative, the IO::Path type provides many reading and writing methods\nthat let you work with files without dealing with filehandles directly.","s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"eof","d":"Defined as:\n\n    method eof(IO::Handle:D: --> Bool:D)\n\nNon-blocking. Returns True if the read operations have exhausted the\ncontents of the handle. For seekable handles, this means current position\nis at or beyond the end of file and seeking an exhausted handle back into\nthe file's contents will result in eof returning False again.\n\nOn non-seekable handles and handles opened to zero-size files (including\nspecial files in /proc/), EOF won't be set until a read operation fails to\nread any bytes. For example, in this code, the first read consumes all of\nthe data, but it's only until the second read that reads nothing would the\nEOF on a TTY handle be set:\n\n    $ echo \"x\" | perl6 -e 'with $*IN { .read: 10000; .eof.say; .read: 10; .eof.say }'\n    False\n    True"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"EOF","d":"Defined as:\n\n    method EOF(IO::Handle:D: --> Bool:D)\n\nIndicates whether \"end of file\" has been reached for the data source of the\nhandle; i.e. no more data can be obtained by calling .READ method. Note\nthat this is not the same as eof method, which will return True only if\n.EOF returns True and all the decoder buffers, if any were used by the\nhandle, are also empty. See .READ for an example implementation.\n\nRelated roles and classes\n\nSee also the related role IO and the related class IO::Path."},{"n":"READ","d":"Defined as:\n\n    method READ(IO::Handle:D: Int:D \\bytes --> Buf:D)\n\nCalled whenever a read operation is performed on the handle. Receives the\nnumber of bytes requested to read. Returns a Buf with those bytes which can\nbe used to either fill the decoder buffer or returned from reading methods\ndirectly. The result is allowed to have fewer than the requested number of\nbytes, including no bytes at all.\n\nIf you provide your own .READ, you very likely need to provide your own\n.EOF as well, for all the features to behave correctly.\n\nThe compiler may call .EOF method any number of times during a read\noperation to ascertain whether a call to .READ should be made. More bytes\nthan necessary to satisfy a read operation may be requested from .READ, in\nwhich case the extra data may be buffered by the IO::Handle or the decoder\nit's using, to fulfill any subsequent reading operations, without\nnecessarily having to make another .READ call.\n\n    class IO::Store is IO::Handle {\n        has @.lines = [];\n\n        submethod TWEAK {\n          self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n          @!lines.push: data;\n          True;\n        }\n\n        method whole() {\n          my Buf $everything = Buf.new();\n          for @!lines -> $b {\n            $everything ~= $b;\n          }\n          return $everything;\n        }\n\n        method READ(IO::Handle:D: Int:D \\bytes --> Buf:D) {\n          my Buf $everything := self.whole();\n          return $everything;\n        }\n\n        method EOF {\n          my $everything = self.whole();\n          !$everything;\n        }\n    }\n\n    my $store := IO::Store.new();\n\n    $store.print( $_ ) for <one two three>;\n    say $store.read(3).decode; # OUTPUT «one␤»\n    say $store.read(3).decode; # OUTPUT «two␤»\n\n\nIn this case, we have programmed the two READ and EOF methods, as well as\nWRITE, which stores every line in an element in an array. The read method\nactually calls READ, returning 3 bytes, which correspond to the three\ncharacters in the first two elements. Please note that it's the IO::Handle\nbase class the one that is taking care of cursor, since READ just provides\na handle into the whole content of the object; the base class will READ\n1024 * 1024 bytes at a time. If your object is planned to hold an amount of\nbytes bigger than that, you will have to handle an internal cursor\nyourself. That is why in this example we don't actually use the bytes\nargument.","s":{"r":"Mu","p":["Int:D $bytes","*%_"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    method get(IO::Handle:D: --> Str:D)\n    multi sub get (IO::Handle $fh = $*ARGFILES --> Str:D)\n\nReads a single line of input from the handle, removing the trailing newline\ncharacters (as set by .nl-in) if the handle's .chomp attribute is set to\nTrue. Returns Nil, if no more input is available. The subroutine form\ndefaults to $*ARGFILES if no handle is given.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    $*IN.get.say;              # Read one line from the standard input\n\n    my $fh = open 'filename';\n    $fh.get.say;               # Read one line from a file\n    $fh.close;\n\n    say get;                   # Read one line from $*ARGFILES","n":"get","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method getc(IO::Handle:D: --> Str:D)\n    multi sub getc (IO::Handle $fh = $*ARGFILES --> Str:D)\n\nReads a single character from the input stream. Attempting to call this\nmethod when the handle is in binary mode will result in X::IO::BinaryMode\nexception being thrown. The subroutine form defaults to $*ARGFILES if no\nhandle is given. Returns Nil, if no more input is available, otherwise\noperation will block, waiting for at least one character to be available;\nthese caveats apply:\n\n    Buffering terminals\n\nUsing getc to get a single keypress from a terminal will only work properly\nif you've set the terminal to \"unbuffered\". Otherwise the terminal will\nwait for the return key to be struck or the buffer to be filled up before\nperl6 gets even a single byte of data.\n\n    Waiting for potential combiners\n\nIf your handle's encoding allows combining characters to be read, perl6\nwill wait for more data to be available before it provides a character.\nThis means that inputting an \"e\" followed by a combining acute will give\nyou an e with an acute rather than giving an \"e\" and letting the next\nreading function give you a dangling combiner. However, it also means that\nwhen the user inputs just an \"e\" and has no intention to also input a\ncombining acute, your program will be waiting for another keypress before\nthe initial \"e\" is returned.\n\n  submethod DESTROY\n\nDefined as:\n\n    submethod DESTROY(IO::Handle:D:)\n\nCloses the filehandle, unless its native-descriptor is 2 or lower. This\nensures the standard filehandles do not get inadvertently closed.\n\nNote that garbage collection is not guaranteed to happen, so you must NOT\nrely on DESTROY for closing the handles you write to and instead close them\nyourself. Programs that open a lot of files should close the handles\nexplicitly as well, regardless of whether they were open for writing, since\ntoo many files might get opened before garbage collection happens and the\nno longer used handles get closed.","n":"getc"},{"m":0,"k":"m","s":{"r":"Mu","p":[":$close","|c is raw"]},"d":"Defined as:\n\n    method comb(IO::Handle:D: Bool :$close, |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.comb does,\ntaking the same arguments, closing the handle when done if $close is set to\na true value. Implementations may slurp the file in its entirety when this\nmethod is called.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open;\n    say \"The file has {+$fh.comb: '♥', :close} ♥s in it\";","n":"comb"},{"k":"m","m":0,"s":{"r":"Mu","p":[":$close","|c is raw"]},"d":"Defined as:\n\n    method split(IO::Handle:D: :$close, |c)\n\nSlurps the handle's content and calls Str.split on it, forwarding any of\nthe given arguments. If :$close named parameter is set to True, will close\nthe invocant after slurping.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open;\n    $fh.split: '♥', :close; # Returns file content split on ♥","n":"split"},{"m":1,"k":"m","s":{"r":"Mu","p":["$limit",":$close","*%_"]},"d":"Defined as:\n\n    multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    multi method words(IO::Handle:D: $limit = Inf, :$close --> Seq:D)\n\nSimilar to Str.words, separates the handle's stream on contiguous chunks of\nwhitespace (as defined by Unicode) and returns a Seq of the resultant\n\"words.\" Takes an optional $limit argument that can be a non-negative Int,\nInf, or Whatever (which is interpreted to mean Inf), to indicate only up-to\n$limit words must be returned. If Bool :$close named argument is set to\nTrue, will automatically close the handle when the returned Seq is\nexhausted. Subroutine form defaults to $*ARGFILES, if no handle is\nprovided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my %dict := bag $*IN.words;\n    say \"Most common words: \", %dict.sort(-*.value).head: 5;\n\n\nNOTE: implementations may read more data than necessary when a call to\n.words is made. That is, $handle.words(2) may read more data than two\n\"words\" worth of data and subsequent calls to read methods might not read\nfrom the place right after the two fetched words. After a call to .words,\nthe file position should be treated as undefined.","n":"words"},{"s":{"r":"Mu","p":[":$close","*%_"]},"k":"m","m":1,"n":"words","d":"Defined as:\n\n    multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    multi method words(IO::Handle:D: $limit = Inf, :$close --> Seq:D)\n\nSimilar to Str.words, separates the handle's stream on contiguous chunks of\nwhitespace (as defined by Unicode) and returns a Seq of the resultant\n\"words.\" Takes an optional $limit argument that can be a non-negative Int,\nInf, or Whatever (which is interpreted to mean Inf), to indicate only up-to\n$limit words must be returned. If Bool :$close named argument is set to\nTrue, will automatically close the handle when the returned Seq is\nexhausted. Subroutine form defaults to $*ARGFILES, if no handle is\nprovided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my %dict := bag $*IN.words;\n    say \"Most common words: \", %dict.sort(-*.value).head: 5;\n\n\nNOTE: implementations may read more data than necessary when a call to\n.words is made. That is, $handle.words(2) may read more data than two\n\"words\" worth of data and subsequent calls to read methods might not read\nfrom the place right after the two fetched words. After a call to .words,\nthe file position should be treated as undefined."},{"d":"Defined as:\n\n    sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    method lines(IO::Handle:D:               $limit = Inf, :$close --> Seq:D)\n\nReturn a Seq each element of which is a line from the handle (that is\nchunks delineated by .nl-in). If the handle's .chomp attribute is set to\nTrue, then characters specified by .nl-in will be stripped from each line.\n\nReads up to $limit lines, where $limit can be a non-negative Int, Inf, or\nWhatever (which is interpreted to mean Inf). If :$close is set to True,\nwill close the handle when the file ends or $limit is reached. Subroutine\nform defaults to $*ARGFILES, if no handle is provided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\nNOTE: the lines are read lazily, so ensure the returned Seq is either fully\nreified or is no longer needed when you close the handle or attempt to use\nany other method that changes the file position.\n\n    say \"The file contains \",\n      '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n      \" lines that mention Perl\";\n    # OUTPUT: «The file contains 72 lines that mention Perl␤»","n":"lines","k":"m","m":1,"s":{"r":"Mu","p":["$limit",":$close","*%_"]}},{"n":"lines","d":"Defined as:\n\n    sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    method lines(IO::Handle:D:               $limit = Inf, :$close --> Seq:D)\n\nReturn a Seq each element of which is a line from the handle (that is\nchunks delineated by .nl-in). If the handle's .chomp attribute is set to\nTrue, then characters specified by .nl-in will be stripped from each line.\n\nReads up to $limit lines, where $limit can be a non-negative Int, Inf, or\nWhatever (which is interpreted to mean Inf). If :$close is set to True,\nwill close the handle when the file ends or $limit is reached. Subroutine\nform defaults to $*ARGFILES, if no handle is provided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\nNOTE: the lines are read lazily, so ensure the returned Seq is either fully\nreified or is no longer needed when you close the handle or attempt to use\nany other method that changes the file position.\n\n    say \"The file contains \",\n      '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n      \" lines that mention Perl\";\n    # OUTPUT: «The file contains 72 lines that mention Perl␤»","s":{"r":"Mu","p":[":$close","*%_"]},"k":"m","m":1},{"d":"Defined as:\n\n    method read(IO::Handle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)\n\nBinary reading; reads and returns up to $bytes bytes from the filehandle.\n$bytes defaults to an implementation-specific value (in Rakudo, the value\nof $*DEFAULT-READ-ELEMS, which by default is set to 65536). This method can\nbe called even when the handle is not in binary mode.\n\n    (my $file = 'foo'.IO).spurt: 'I ♥ Perl';\n    given $file.open {\n        say .read: 6; # OUTPUT: «Buf[uint8]:0x<49 20 e2 99 a5 20>␤»\n        .close;\n    }","n":"read","k":"m","m":0,"s":{"p":["Int(Cool:D) $bytes = { ... }","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["Int(Cool:D) $chars = { ... }","*%_"]},"d":"Defined as:\n\n    method readchars(IO::Handle:D: Int(Cool:D) $chars = 65536 --> Str:D)\n\nReading chars; reads and returns up to $chars chars (graphemes) from the\nfilehandle. $chars defaults to an implementation-specific value (in Rakudo,\nthe value of $*DEFAULT-READ-ELEMS, which by default is set to 65536).\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    (my $file = 'foo'.IO).spurt: 'I ♥ Perl';\n    given $file.open {\n        say .readchars: 5; # OUTPUT: «I ♥ P␤»\n        .close;\n    }","n":"readchars"},{"d":"Defined as:\n\n    method seek(IO::Handle:D: Int:D $offset, SeekType:D $whence --> True)\n\nMove the file pointer (that is, the position at which any subsequent read\nor write operations will begin) to the byte position specified by $offset\nrelative to the location specified by $whence which may be one of:\n\n  * SeekFromBeginning: The beginning of the file.\n\n  * SeekFromCurrent: The current position in the file.\n\n  * SeekFromEnd: The end of the file. Please note that you need to specify a\n  negative offset if you want to position before the end of the file.","n":"seek","k":"m","m":1,"s":{"r":"Bool","p":["Int:D $offset","SeekType:D $whence = SeekType::SeekFromBeginning","*%_"]}},{"n":"tell","d":"Defined as:\n\n    method tell(IO::Handle:D: --> Int:D)\n\nReturn the current position of the file pointer in bytes.","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"s":{"p":["Blob:D $buf","*%_"],"r":"Bool"},"k":"m","m":0,"n":"write","d":"Defined as:\n\n    method write(IO::Handle:D: Blob:D $buf --> True)\n\nWrites $buf to the filehandle. This method can be called even when the\nhandle is not in binary mode."},{"m":0,"k":"m","s":{"r":"Bool","p":["Blob:D $buf","*%_"]},"d":"Defined as:\n\n    method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D)\n\nCalled whenever a write operation is performed on the handle. Always\nreceives the data as a Blob, even if a textual writing method has been\ncalled.\n\n    class IO::Store is IO::Handle {\n        has @.lines = [];\n\n        submethod TWEAK {\n            self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n            @!lines.push: data.decode();\n            True;\n        }\n\n        method gist() {\n            return @!lines.join(\"\\n\" );\n        }\n    }\n    my $store = IO::Store.new();\n    my $output = $PROCESS::OUT;\n    $PROCESS::OUT = $store;\n    .say for <one two three>;\n    $PROCESS::OUT = $output;\n    say $store.lines(); # OUTPUT «[one␤ two␤ three␤]»\n\n\nIn this example we are creating a simple WRITE redirection which stores\nanything written to the filehandle to an array. Se need to save the\nstandard output first, which we do in $output, and then everything that is\nprinted or said (through say) gets stored in the defined IO::Store class.\nTwo things should be taken into account in this class. By default,\nIO::Handles are in binary mode, so we need to TWEAK the objects if we want\nthem to work with text. Second, a WRITE operation should return True if\nsuccessful. It will fail if it does not.","n":"WRITE"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method opened(IO::Handle:D: --> Bool:D)\n\nReturns True if the handle is open, False otherwise.","n":"opened"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method t(IO::Handle:D: --> Bool:D)\n\nReturns True if the handle is opened to a TTY, False otherwise.\n\nCreating Custom Handles\n\nAs of 6.d language (early implementation available in Rakudo compiler\nversion 2018.08), a few helper methods are available to simplify creation\nof custom IO::Handle objects. In your subclass you simply need to implement\nthose methods to affect all of the related features. If your handle wants\nto work with textual read/write methods and doesn't use the standard .open\nmethod, be sure to call .encoding method in your custom handle to get\ndecoder/encoder properly set up:\n\n    class IO::URL is IO::Handle {\n        has $.URL is required;\n        has Buf $!content;\n        submethod TWEAK {\n            use WWW; # ecosystem module that will let us `get` a web page\n            use DOM::Tiny; # ecosystem module that will parse out all text from HTML\n            $!content := Buf.new: DOM::Tiny.parse(get $!URL).all-text(:trim).encode;\n            self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method open(|)  { self }       # block out some IO::Handle methods\n        method close(|) { self }       # that work with normal low-level file\n        method opened   { ! self.EOF } # handles, since we don't. This isn't\n        method lock(| --> True) { }    # necessary, but will make our handle\n        method unlock( --> True) { }   # be more well-behaved if someone\n        # actually calls one of these methods. There are more of these you\n        # can handle, such as .tell, .seek, .flush, .native-descriptor, etc.\n\n        method WRITE(|) {\n            # For this handle we'll just die on write. If yours can handle writes.\n            # The data to write will be given as a Blob positional argument.\n            die \"Cannot write into IO::URL\";\n        }\n        method READ(\\bytes) {\n            # We splice off the requested number of bytes from the head of\n            # our content Buf. The handle's decoder will handle decoding them\n            # automatically, if textual read methods were called on the handle.\n            $!content.splice: 0, bytes\n        }\n        method EOF {\n            # For \"end of file\", we'll simply report whether we still have\n            # any bytes of the website we fetched on creation.\n            not $!content\n        }\n    }\n\n    my $fh := IO::URL.new: :URL<www.perl6.org>;\n\n    # .slurp and print all the content from the website. We can use all other\n    # read methods, such as .lines, or .get, or .readchars. All of them work\n    # correctly, even though we only defined .READ and .EOF\n    $fh.slurp.say;","n":"t"},{"d":"Defined as:\n\n    method lock(IO::Handle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)\n\nPlaces an advisory lock on the filehandle. If :$non-blocking is True will\nfail with X::IO::Lock if lock could not be obtained, otherwise will block\nuntil the lock can be placed. If :$shared is True will place a shared\n(read) lock, otherwise will place an exclusive (write) lock. On success,\nreturns True; fails with X::IO::Lock if lock cannot be placed (e.g. when\ntrying to place a shared lock on a filehandle opened in write mode or\ntrying to place an exclusive lock on a filehandle opened in read mode).\n\nYou can use lock again to replace an existing lock with another one. To\nremove a lock, close the filehandle or use unlock.\n\n    # One program writes, the other reads, and thanks to locks either\n    # will wait for the other to finish before proceeding to read/write\n\n    # Writer\n    given \"foo\".IO.open(:w) {\n        .lock;\n        .spurt: \"I ♥ Raku!\";\n        .close; # closing the handle unlocks it; we could also use `unlock` method for that\n    }\n\n    # Reader\n    given \"foo\".IO.open {\n        .lock: :shared;\n        .slurp.say; # OUTPUT: «I ♥ Raku!␤»\n        .close;\n    }","n":"lock","m":0,"k":"m","s":{"r":"Bool","p":["Bool:D :$non-blocking = Bool::False","Bool:D :$shared = Bool::False","*%_"]}},{"n":"unlock","d":"Defined as:\n\n    method unlock(IO::Handle:D: --> True)\n\nRemoves a lock from the filehandle.","s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0},{"s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m","n":"printf","d":"Defined as:\n\n    multi method printf(IO::Handle:D: Cool $format, *@args)\n\nFormats a string based on the given format and arguments and .prints the\nresult into the filehandle. See sub sprintf for details on acceptable\nformat directives.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = open 'path/to/file', :w;\n    $fh.printf: \"The value is %d\\n\", 32;\n    $fh.close;"},{"d":"Defined as:\n\n    multi method print(**@text --> True)\n    multi method print(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them. Junction arguments autothread and the order\nof printed strings is not guaranteed. See write to write bytes.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.print: 'some text';\n    $fh.close;","n":"print","m":1,"k":"m","s":{"r":"Bool","p":["Str:D \\x","*%_"]}},{"m":1,"k":"m","s":{"p":["**@list is raw","*%_"],"r":"Bool"},"d":"Defined as:\n\n    multi method print(**@text --> True)\n    multi method print(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them. Junction arguments autothread and the order\nof printed strings is not guaranteed. See write to write bytes.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.print: 'some text';\n    $fh.close;","n":"print"},{"d":"Defined as:\n\n    multi method print(**@text --> True)\n    multi method print(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them. Junction arguments autothread and the order\nof printed strings is not guaranteed. See write to write bytes.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.print: 'some text';\n    $fh.close;","n":"print","m":1,"k":"m","s":{"r":"Mu","p":["Junction:D \\j","*%_"]}},{"d":"Defined as:\n\n    multi method put(**@text --> True)\n    multi method put(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them, and appending the value of .nl-out at the\nend. Junction arguments autothread and the order of printed strings is not\nguaranteed.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.put: 'some text';\n    $fh.close;","n":"put","m":1,"k":"m","s":{"p":["Str:D \\x","*%_"],"r":"Bool"}},{"d":"Defined as:\n\n    multi method put(**@text --> True)\n    multi method put(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them, and appending the value of .nl-out at the\nend. Junction arguments autothread and the order of printed strings is not\nguaranteed.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.put: 'some text';\n    $fh.close;","n":"put","k":"m","m":1,"s":{"r":"Bool","p":["**@list is raw","*%_"]}},{"n":"put","d":"Defined as:\n\n    multi method put(**@text --> True)\n    multi method put(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them, and appending the value of .nl-out at the\nend. Junction arguments autothread and the order of printed strings is not\nguaranteed.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.put: 'some text';\n    $fh.close;","s":{"p":["Junction:D \\j","*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"print-nl","d":"Defined as:\n\n    method print-nl(IO::Handle:D: --> True)\n\nWrites the value of $.nl-out attribute into the handle. This attribute, by\ndefault, is ␤, but see the page on newline for the rules it follows in\ndifferent platforms and environments.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w, :nl-out(\"\\r\\n\");\n    $fh.print: \"some text\";\n    $fh.print-nl; # prints \\r\\n\n    $fh.close;","s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m"},{"n":"slurp-rest","d":"Defined as:\n\n    multi method slurp-rest(IO::Handle:D: :$bin! --> Buf)\n    multi method slurp-rest(IO::Handle:D: :$enc --> Str)\n\nDEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not\nuse it for new code, use .slurp method instead.\n\nReturns the remaining content of the file from the current file position\n(which may have been set by previous reads or by seek.) If the adverb :bin\nis provided a Buf will be returned; otherwise the return will be a Str with\nthe optional encoding :enc.","s":{"r":"Buf:D","p":[":$bin! where { ... }",":$close","*%_"]},"m":1,"k":"m"},{"n":"slurp-rest","d":"Defined as:\n\n    multi method slurp-rest(IO::Handle:D: :$bin! --> Buf)\n    multi method slurp-rest(IO::Handle:D: :$enc --> Str)\n\nDEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not\nuse it for new code, use .slurp method instead.\n\nReturns the remaining content of the file from the current file position\n(which may have been set by previous reads or by seek.) If the adverb :bin\nis provided a Buf will be returned; otherwise the return will be a Str with\nthe optional encoding :enc.","s":{"p":[":$enc",":$bin",":$close","*%_"],"r":"Str:D"},"k":"m","m":1},{"d":"Defined as:\n\n    method slurp(IO::Handle:D: :$close, :$bin)\n\nReturns all the content from the current file pointer to the end. If the\ninvocant is in binary mode or if $bin is set to True, will return a Buf,\notherwise will decode the content using invocant's current .encoding and\nreturn a Str.\n\nIf :$close is set to True, will close the handle when finished reading.\n\nNote: On Rakudo this method was introduced with release 2017.04; $bin arg\nwas added in 2017.10.","n":"slurp","m":0,"k":"m","s":{"p":[":$close",":$bin","*%_"],"r":"Mu"}},{"s":{"p":["Blob $data",":$close","*%_"],"r":"Mu"},"k":"m","m":1,"n":"spurt","d":"Defined as:\n\n    multi method spurt(IO::Handle:D: Blob $data, :$close = False)\n    multi method spurt(IO::Handle:D: Cool $data, :$close = False)\n\nWrites all of the $data into the filehandle, closing it when finished, if\n$close is True. For Cool $data, will use the encoding the handle is set to\nuse (IO::Handle.open or IO::Handle.encoding).\n\nBehavior for spurting a Cool when the handle is in binary mode or spurting\na Blob when the handle is NOT in binary mode is undefined."},{"k":"m","m":1,"s":{"r":"Mu","p":["Cool $data",":$close","*%_"]},"d":"Defined as:\n\n    multi method spurt(IO::Handle:D: Blob $data, :$close = False)\n    multi method spurt(IO::Handle:D: Cool $data, :$close = False)\n\nWrites all of the $data into the filehandle, closing it when finished, if\n$close is True. For Cool $data, will use the encoding the handle is set to\nuse (IO::Handle.open or IO::Handle.encoding).\n\nBehavior for spurting a Cool when the handle is in binary mode or spurting\na Blob when the handle is NOT in binary mode is undefined.","n":"spurt"},{"n":"path","d":"Defined as:\n\n    method path(IO::Handle:D:)\n\nFor a handle opened on a file this returns the IO::Path that represents the\nfile. For the standard I/O handles $*IN, $*OUT, and $*ERR it returns an\nIO::Special object.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"IO","d":"Defined as:\n\n    method IO(IO::Handle:D:)\n\nAlias for .path","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method flush(IO::Handle:D: --> True)\n\nWill flush the handle, writing any of the buffered data. Returns True on\nsuccess; otherwise, fails with X::IO::Flush.\n\n    given \"foo\".IO.open: :w {\n        LEAVE .close;\n        .print: 'something';\n        'foo'.IO.slurp.say; # (if the data got buffered) OUTPUT: «␤»\n        .flush;             # flush the handle\n        'foo'.IO.slurp.say; # OUTPUT: «something␤»\n    }","n":"flush","m":0,"k":"m","s":{"p":["*%_"],"r":"Bool"}},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method encoding(IO::Handle:D: --> Str:D)\n    multi method encoding(IO::Handle:D: $enc --> Str:D)\n\nReturns a Str representing the encoding currently used by the handle,\ndefaulting to \"utf8\". Nil indicates the filehandle is currently in binary\nmode. Specifying an optional positional $enc argument switches the encoding\nused by the handle; specify Nil as encoding to put the handle into binary\nmode.\n\nThe accepted values for encoding are case-insensitive. The available\nencodings vary by implementation and backend. On Rakudo MoarVM the\nfollowing are supported:\n\n    utf8\n    utf16\n    utf16le\n    utf16be\n    utf8-c8\n    iso-8859-1\n    windows-1251\n    windows-1252\n    windows-932\n    ascii\n\n\nThe default encoding is utf8, which undergoes normalization into Unicode\nNFC (normalization form canonical). In some cases you may want to ensure no\nnormalization is done; for this you can use utf8-c8. Before using utf8-c8\nplease read Unicode: Filehandles and I/O for more information on utf8-c8\nand NFC.\n\nAs of Rakudo 2018.04 windows-932 is also supported which is a variant of\nShiftJIS.\n\nImplementation may choose to also provide support for aliases, e.g. Rakudo\nallows aliases latin-1 for iso-8859-1 encoding and dashed utf versions:\nutf-8 and utf-16.\n\n    utf16, utf16le and utf16be\n\nUnlike utf8, utf16 has an endianness — either big endian or little endian.\nThis relates to the ordering of bytes. Computer CPUs also have an\nendianness. Raku's utf16 format specifier will use the endianness of host\nsystem when encoding. When decoding it will look for a byte order mark and\nif it is there use that to set the endianness. If there is no byte order\nmark it will assume the file uses the same endianness as the host system. A\nbyte order mark is the codepoint U+FEFF which is ZERO WIDTH NO-BREAK SPACE.\nOn utf16 encoded files the standard states if it exists at the start of a\nfile it shall be interpreted as a byte order mark, not a U+FEFF codepoint.\n\nWhile writing will cause a different file to be written on different endian\nsystems, at the release of 2018.10 the byte order mark will be written out\nwhen writing a file and files created with the utf16 encoding will be able\nto be read on either big or little endian systems.\n\nWhen using utf16be or utf16le encodings a byte order mark is not used. The\nendianness used is not affected by the host cpu type and is either big\nendian for utf16be or little endian for utf16le.\n\nIn keeping with the standard, a 0xFEFF byte at the start of a file is\ninterpreted as a ZERO WIDTH NO-BREAK SPACE and not as a byte order mark. No\nbyte order mark is written to files that use the utf16be or utf16le\nencodings.\n\nAs of Rakudo 2018.09 on MoarVM, utf16, utf16le and utf16be are supported.\nIn 2018.10, writing to a file with utf16 will properly add a byte order\nmark (BOM).\n\n    Examples\n\n    with 'foo'.IO {\n        .spurt: \"First line is text, then:\\nBinary\";\n        my $fh will leave {.close} = .open;\n        $fh.get.say;         # OUTPUT: «First line is text, then:␤»\n        $fh.encoding: Nil;\n        $fh.slurp.say;       # OUTPUT: «Buf[uint8]:0x<42 69 6e 61 72 79>␤»\n    }","n":"encoding"},{"n":"encoding","d":"Defined as:\n\n    multi method encoding(IO::Handle:D: --> Str:D)\n    multi method encoding(IO::Handle:D: $enc --> Str:D)\n\nReturns a Str representing the encoding currently used by the handle,\ndefaulting to \"utf8\". Nil indicates the filehandle is currently in binary\nmode. Specifying an optional positional $enc argument switches the encoding\nused by the handle; specify Nil as encoding to put the handle into binary\nmode.\n\nThe accepted values for encoding are case-insensitive. The available\nencodings vary by implementation and backend. On Rakudo MoarVM the\nfollowing are supported:\n\n    utf8\n    utf16\n    utf16le\n    utf16be\n    utf8-c8\n    iso-8859-1\n    windows-1251\n    windows-1252\n    windows-932\n    ascii\n\n\nThe default encoding is utf8, which undergoes normalization into Unicode\nNFC (normalization form canonical). In some cases you may want to ensure no\nnormalization is done; for this you can use utf8-c8. Before using utf8-c8\nplease read Unicode: Filehandles and I/O for more information on utf8-c8\nand NFC.\n\nAs of Rakudo 2018.04 windows-932 is also supported which is a variant of\nShiftJIS.\n\nImplementation may choose to also provide support for aliases, e.g. Rakudo\nallows aliases latin-1 for iso-8859-1 encoding and dashed utf versions:\nutf-8 and utf-16.\n\n    utf16, utf16le and utf16be\n\nUnlike utf8, utf16 has an endianness — either big endian or little endian.\nThis relates to the ordering of bytes. Computer CPUs also have an\nendianness. Raku's utf16 format specifier will use the endianness of host\nsystem when encoding. When decoding it will look for a byte order mark and\nif it is there use that to set the endianness. If there is no byte order\nmark it will assume the file uses the same endianness as the host system. A\nbyte order mark is the codepoint U+FEFF which is ZERO WIDTH NO-BREAK SPACE.\nOn utf16 encoded files the standard states if it exists at the start of a\nfile it shall be interpreted as a byte order mark, not a U+FEFF codepoint.\n\nWhile writing will cause a different file to be written on different endian\nsystems, at the release of 2018.10 the byte order mark will be written out\nwhen writing a file and files created with the utf16 encoding will be able\nto be read on either big or little endian systems.\n\nWhen using utf16be or utf16le encodings a byte order mark is not used. The\nendianness used is not affected by the host cpu type and is either big\nendian for utf16be or little endian for utf16le.\n\nIn keeping with the standard, a 0xFEFF byte at the start of a file is\ninterpreted as a ZERO WIDTH NO-BREAK SPACE and not as a byte order mark. No\nbyte order mark is written to files that use the utf16be or utf16le\nencodings.\n\nAs of Rakudo 2018.09 on MoarVM, utf16, utf16le and utf16be are supported.\nIn 2018.10, writing to a file with utf16 will properly add a byte order\nmark (BOM).\n\n    Examples\n\n    with 'foo'.IO {\n        .spurt: \"First line is text, then:\\nBinary\";\n        my $fh will leave {.close} = .open;\n        $fh.get.say;         # OUTPUT: «First line is text, then:␤»\n        $fh.encoding: Nil;\n        $fh.slurp.say;       # OUTPUT: «Buf[uint8]:0x<42 69 6e 61 72 79>␤»\n    }","s":{"r":"Mu","p":["$new-encoding is copy",":$replacement",":$strict","Bool:D :$translate-nl = Bool::True","*%_"]},"m":1,"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"DESTROY"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"native-descriptor","d":"Defined as:\n\n    method native-descriptor()\n\nThis returns a value that the operating system would understand as a \"file\ndescriptor\" and is suitable for passing to a native function that requires\na file descriptor as an argument such as fcntl or ioctl."},{"n":"chomp","d":"Defined as:\n\n    has $.chomp is rw = True\n\nOne of the attributes that can be set via .new or open. Defaults to True.\nTakes a Bool specifying whether the line separators (as defined by .nl-in)\nshould be removed from content when using .get or .lines methods.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    has Str:D $.nl-out is rw = \"\\n\";\n\nOne of the attributes that can be set via .new or open. Defaults to \"\\n\".\nTakes a Str specifying output line ending for this handle, to be used by\nmethods .put and .say.\n\n    with 'test'.IO {\n        given .open: :w {\n            .put: 42;\n            .nl-out = 'foo';\n            .put: 42;\n            .close;\n        }\n        .slurp.perl.say; # OUTPUT: «\"42\\n42foo\"»\n    }","n":"nl-out","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"!close-all-open-handles"},{"n":"!remember-to-close","s":{"r":"Nil","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["$chars","*%_"]},"n":"!readchars-slow-path"},{"m":0,"k":"m","s":{"r":"Nil","p":["int $fileno","*%_"]},"n":"!forget-about-closing"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"!get-line-slow-path"},{"n":"!LINES-ITERATOR","s":{"p":["$close","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["$buffer is copy","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!set-out-buffer-size"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"!slurp-all-chars"},{"n":"!read-slow-path","s":{"p":["$bytes","*%_"],"r":"Mu"},"m":0,"k":"m"}],"k":"c","b":"A"},{"n":"IO::Special","a":[{"n":"$.what","t":"Str","k":"v"}],"t":"IO::Special","d":"TITLE\nclass IO::Special\n\nSUBTITLE\nPath to special I/O device\n\n    class IO::Special does IO { }\n\n\nUsed as a $.path attribute in filehandles for special standard input $*IN\nand output $*OUT and $*ERR. Provides a bridged interface of IO::Handle,\nmostly file tests and stringification.\n\n","mro":["IO","Any"],"m":[{"m":0,"k":"m","s":{"r":"IO::Special:D","p":["Str:D \\what","*%_"]},"d":"method new(:$!what!)\n\n\nTakes a single required attribute what. It is unlikely that you will ever\nneed to construct one of these objects yourself.","n":"new"},{"s":{"p":["*%_"],"r":"IO::Special:D"},"k":"m","m":0,"n":"IO","d":"method IO(IO::Special:D: --> IO::Special)\n\nReturns the invocant.\n\n    say $*IN.path.IO.what;  # OUTPUT: «<STDIN>␤»\n    say $*IN.path.what;     # OUTPUT: «<STDIN>␤»"},{"n":"e","d":"method e(IO::Special:D: --> True)\n\nThe 'exists' file test operator, always returns True.","s":{"r":"Bool","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m","n":"d","d":"method d(IO::Special:D: --> False)\n\nThe 'directory' file test operator, always returns False."},{"s":{"r":"Bool","p":["*%_"]},"m":0,"k":"m","n":"f","d":"method f(IO::Special:D: --> False)\n\nThe 'file' file test operator, always returns False."},{"d":"method s(IO::Special:D: --> 0)\n\nThe 'size' file test operator, always returns 0.","n":"s","k":"m","m":0,"s":{"r":"Int","p":["*%_"]}},{"n":"l","d":"method l(IO::Special:D: --> False)\n\nThe 'symbolic links' file test operator, always returns False.","s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0},{"d":"method r(IO::Special:D: --> Bool)\n\nThe 'read access' file test operator, returns True if and only if this\ninstance represents the standard input handle(<STDIN>).","n":"r","m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]},"d":"method w(IO::Special:D: --> Bool)\n\nThe 'write access' file test operator, returns True only if this instance\nrepresents either the standard output (<STOUT>) or the standard error\n(<STDERR>) handle.","n":"w"},{"d":"method x(IO::Special:D: --> False)\n\nThe 'execute access' file test operator, always returns False.","n":"x","m":0,"k":"m","s":{"p":["*%_"],"r":"Bool"}},{"k":"m","m":0,"s":{"r":"Instant","p":["*%_"]},"d":"method modified(IO::Special:D: --> Instant)\n\nThe last modified time for the filehandle. It always returns an Instant\ntype object.","n":"modified"},{"m":0,"k":"m","s":{"r":"Instant","p":["*%_"]},"d":"method accessed(IO::Special:D: --> Instant)\n\nThe last accessed time for the filehandle. It always returns an Instant\ntype object.","n":"accessed"},{"d":"method changed(IO::Special:D: --> Instant)\n\nThe last changed time for the filehandle. It always returns an Instant type\nobject.","n":"changed","k":"m","m":0,"s":{"p":["*%_"],"r":"Instant"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Nil"},"d":"method mode(IO::Special:D: --> Nil)\n\nThe mode for the filehandle, it always returns Nil","n":"mode"},{"d":"say $*IN.path.what;  # OUTPUT: «<STDIN>␤»\n    say $*OUT.path.what; # OUTPUT: «<STDOUT>␤»\n    say $*ERR.path.what; # OUTPUT: «<STDERR>␤»\n\nReturns one of the strings '<STDIN>', '<STDOUT>', or '<STDERR>', specifying\nthe type of the special IO device.","n":"what","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","b":"A"},{"mro":["IO::CatHandle"],"m":[{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","n":"IO::ArgFiles","a":[{"n":"$!handles","t":"Mu","k":"v"},{"n":"$!active-handle","t":"Mu","k":"v"},{"n":"$.chomp","t":"Mu","k":"v"},{"k":"v","n":"$.nl-in","t":"Mu"},{"t":"Str","n":"$.encoding","k":"v"},{"k":"v","n":"&.on-switch","t":"Callable"},{"k":"v","t":"Mu","n":"$.path"},{"n":"$!PIO","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.chomp"},{"n":"$.nl-in","t":"Mu","k":"v"},{"k":"v","t":"Str:D","n":"$.nl-out"},{"n":"$.encoding","t":"Str","k":"v"},{"k":"v","t":"Encoding::Decoder","n":"$!decoder"},{"k":"v","t":"Encoding::Encoder","n":"$!encoder"},{"t":"int","n":"$!out-buffer","k":"v"}],"d":"TITLE\nclass IO::ArgFiles\n\nSUBTITLE\nIterate over contents of files specified on command line\n\n    class IO::ArgFiles is IO::CatHandle { }\n\nThis class exists for backwards compatibility reasons and provides no\nadditional methods to IO::CatHandle, so it can be used in the same way as\nit, for instance, in this way:\n\n    my $argfiles = IO::ArgFiles.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nIf invoked with perl6 io-argfiles.p6 *.p6 it will print the contents of all\nthe files with that extension in the directory. However, that is totally\nequivalent to:\n\n    my $argfiles = IO::CatHandle.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nVariables\n\n  $*ARGFILES\n\nThis class is the magic behind the $*ARGFILES variable, which provides a\nway to iterate over files passed in to the program on the command line\n(i.e. elements of @*ARGS). Thus the examples above can be simplified like\nso:\n\n    .say for $*ARGFILES.lines;\n\n    # or\n    while ! $*ARGFILES.eof {\n        say $*ARGFILES.get;\n    }\n\n    # or\n    say $*ARGFILES.slurp;\n\nSave one of the variations above in a file, say argfiles.p6. Then create\nanother file (named, say sonnet18.txt with the contents:\n\n    Shall I compare thee to a summer's day?\n\n\nRunning the command\n\n    $ perl6 argfiles.p6 sonnet18.txt\n\n\nwill then give the output\n\n    Shall I compare thee to a summer's day?\n\n\nAs of 6.d language, $*ARGFILES inside sub MAIN is always set to $*IN, even\nwhen @*ARGS is not empty. That means that\n\n    sub MAIN () {\n        .say for $*ARGFILES.lines;\n    }\n\n\nwhich can be used as cat *.p6 | perl6 argfiles-main.p6, for instance, is\ntotally equivalent to:\n\n    sub MAIN () {\n        .say for $*IN.lines;\n    }\n\n\nand, in fact, can't be used to process the arguments in the command line,\nsince, in this case, it would result in an usage error.\n\nBear in mind that the object $*ARGFILES is going to contain a handle for\nevery argument in a command line, even if that argument is not a valid\nfile. You can retrieve them via the .handles method.\n\n    for $*ARGFILES.handles -> $fh {\n        say $fh;\n    }\n\n\nThat code will fail if any of the arguments is not the valid name of a\nfile. You will have to deal with that case at another level, checking that\n@*ARGS contains valid file names, for instance.","t":"IO::ArgFiles","b":"A"},{"b":"A","d":"TITLE\nclass IO::CatHandle\n\nSUBTITLE\nUse multiple IO handles as if they were one\n\n    class IO::CatHandle is IO::Handle { }\n\nThis class has been available in Rakudo since version 2017.06.\n\nThe IO::CatHandle|/type/IO::CatHandle class provides a means to create an\nIO::Handle that seamlessly gathers input from multiple IO::Handle and\nIO::Pipe sources.\n\nAll of the IO::Handle's methods are implemented, and while attempt to use\nwrite methods will (currently) throw and exception, an IO::CatHandle is\nusable anywhere a read-only IO::Handle can be used.\n\n","a":[{"k":"v","n":"$!handles","t":"Mu"},{"k":"v","n":"$!active-handle","t":"Mu"},{"k":"v","n":"$.chomp","t":"Mu"},{"n":"$.nl-in","t":"Mu","k":"v"},{"n":"$.encoding","t":"Str","k":"v"},{"n":"&.on-switch","t":"Callable","k":"v"},{"k":"v","t":"Mu","n":"$.path"},{"n":"$!PIO","t":"Mu","k":"v"},{"k":"v","n":"$.chomp","t":"Mu"},{"k":"v","n":"$.nl-in","t":"Mu"},{"k":"v","n":"$.nl-out","t":"Str:D"},{"n":"$.encoding","t":"Str","k":"v"},{"t":"Encoding::Decoder","n":"$!decoder","k":"v"},{"n":"$!encoder","t":"Encoding::Encoder","k":"v"},{"n":"$!out-buffer","t":"int","k":"v"}],"t":"IO::CatHandle","n":"IO::CatHandle","k":"c","m":[{"d":"Defined as:\n\n    method new(*@handles, :&on-switch, :$chomp = True,\n               :$nl-in = [\"\\n\", \"\\r\\n\"], Str :$encoding, Bool :$bin)\n\n\nCreates a new IO::CatHandle object.\n\nThe @handles positional argument indicates a source of handles for the\nIO::CatHandle to read from and can deal with a mixed collection of Cool,\nIO::Path, and IO::Handle (including IO::Pipe) objects. As input from\nIO::CatHandle is processed (so operations won't happen during .new call,\nbut only when @handles' data is needed), it will walk through the @handles\nlist, processing each argument as follows:\n\n  * the Cool objects will be coerced to IO::Path;\n\n  * IO::Path objects will be opened for reading using the IO::CatHandle's\n  (invocant's) attributes for open calls;\n\n  * un-opened IO::Handle objects will be opened in the same fashion as IO::Path\n  objects;\n\n  * and already opened IO::Handle objects will have all of their attributes set\n  to the attributes of the invocant IO::CatHandle.\n\nIn short, all the @handles end up as IO::Handle objects opened in the same\nmode and with the same attributes as the invocant IO::CatHandle.\n\nSee .on-switch method for details on the :&on-switch named argument, which\nby default is not set.\n\nThe :$encoding named argument specifies the handle's encoding and accepts\nthe same values as IO::Handle.encoding. Set :$bin named argument to True if\nyou wish the handle to be in binary mode. Attempting to specify both a\ndefined :$encoding and a True :$bin is a fatal error resulting in\nX::IO::BinaryAndEncoding exception thrown. If neither :$encoding is set nor\n:$bin set to a true value, the handle will default to utf8 encoding.\n\nThe :$chomp and :$nl-in arguments have the same meaning as in IO::Handle\nand take and default to the same values.","n":"new","k":"m","m":0,"s":{"r":"Mu","p":["*@handles",":&on-switch",":$chomp = Bool::True",":$nl-in = { ... }","Str :$encoding","Bool :$bin","*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"next-handle","d":"Defined as:\n\n    method next-handle(IO::CatHandle:D: --> IO::Handle:D)\n\nSwitches the active source handle to the next handle in the source handle\nqueue, which is the sources given in @handles attribute to .new. The return\nvalue is the currently active source handle or Nil if the source handle\nqueue has been exhausted.\n\nCoerces Cool source \"handles\" to IO::Path; opens IO::Path and unopened\nIO::Handle source handles for reading using the invocant's $.nl-in,\n$.chomp, and $.encoding attributes; those same attributes of already-opened\nIO::Handle objects will be changed to the values of the invocant's\nattributes.\n\nThis method is called automatically whenever CatHandle's methods require a\nswitch to the next source handle, triggers .on-switch Callable to be\ncalled, and is called once during .new call. The .on-switch will continue\nto be triggered each time this method is called, even after the source\nhandle queue has been exhausted. Note that generally reaching the EOF of\nthe currently active source handle does not trigger the .next-handle call,\nbut rather further read operations that need more data do.\n\n    (my $f1 = 'foo'.IO).spurt: \"a\\nb\";\n    (my $f2 = 'bar'.IO).spurt: \"c\\nd\";\n    with IO::CatHandle.new: :on-switch{ say '▸ Switching' }, $f1, $f2 {\n        say 'one';\n        .next-handle.^name.say;\n        say 'two';\n        .next-handle.^name.say;\n        say 'three';\n        .next-handle.^name.say;\n        # OUTPUT:\n        # ▸ Switching\n        # one\n        # ▸ Switching\n        # IO::Handle\n        # two\n        # ▸ Switching\n        # Nil\n        # three\n        # ▸ Switching\n        # Nil\n    }"},{"s":{"p":["*%_"],"r":"Seq:D"},"m":0,"k":"m","n":"handles","d":"Defines as:\n\n    method handles(IO::CatHandle:D: --> Seq:D)\n\nReturns a Seq containing the currently-active handle, as well as all the\nremaining source handles produced by calling next-handle. If the invocant\nhas already been fully-consumed, returns an empty Seq.\n\nThis method is especially handy when working with IO::ArgFiles, where you\nwant to treat each filehandle separately:\n\n    # print at most the first 2 lines of each file in $*ARGFILES:\n    .say for flat $*ARGFILES.handles.map: *.lines: 2\n\nIt is acceptable to call this method multiple times; .handles.head is a\nvalid idiom for obtaining the currently-active handle. If, between\nreification of the elements of the returned Seq the handles get switched by\nsome other means, the next element produced by the Seq would be the next\nhandle of the invocant, not the handle that would've been produced if no\nswitching occurred:\n\n    (my $file1 := 'file1'.IO).spurt: \"1a\\n1b\\n1c\";\n    (my $file2 := 'file2'.IO).spurt: \"2a\\n2b\\n2c\";\n    (my $file3 := 'file3'.IO).spurt: \"3a\\n3b\\n3c\";\n    my $cat := IO::CatHandle.new: $file1, $file2, $file3;\n    for $cat.handles {\n        say .lines: 2;\n        $cat.next-handle;\n    }\n    # OUTPUT: «(1a 1b)␤(3a 3b)␤»\n\nLikewise, reifying the returned Seq consumes the invocant's source handles\nand once it is fully reified the invocant becomes fully-consumed."},{"d":"Defined as:\n\n    method chomp(IO::CatHandle:D:) is rw\n\nSets the invocant's $.chomp attribute to the assigned value. All source\nhandles, including the active one will use the provided $.chomp value.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\\n\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\\n\";\n    with IO::CatHandle.new: $f1, $f2 {\n        # .chomp is True by default:\n        (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n        .chomp = False;\n        (.get xx 3).perl.say; # OUTPUT: «(\"C\\n\", \"D\\n\", \"E\\n\").Seq␤»\n        .close\n    }","n":"chomp","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"comb","d":"Defined as:\n\n    method comb(IO::CatHandle:D: |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.comb does,\ntaking the same arguments. Implementations may slurp the contents of all\nthe source handles in their entirety when this method is called.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    IO::CatHandle.new($f1, $f2).comb(2).perl.say;\n    # OUTPUT: «(\"fo\", \"ob\", \"ar\").Seq␤»","s":{"p":["|c is raw"],"r":"Mu"},"k":"m","m":0},{"n":"split","d":"Defined as:\n\n    method split(IO::CatHandle:D: |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.split does,\ntaking the same arguments. Implementations may slurp the contents of all\nthe source handles in their entirety when this method is called.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    IO::CatHandle.new($f1, $f2).split(/o+/).perl.say;\n    # OUTPUT: «(\"f\", \"bar\").Seq␤»","s":{"p":["|c is raw"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method get(IO::CatHandle:D: --> Bool:D)\n\nReturns a single line of input from the handle, with the new line string\ndefined by the value(s) of $.nl-in attribute, which will be removed from\nthe line if $.chomp attribute is set to True. Returns Nil when there is no\nmore input. It is an error to call this method when the handle is in binary\nmode, resulting in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: \"a\\nb\\nc\";\n    (my $f2 = 'bar'.IO).spurt: \"d\\ne\";\n    my $cat = IO::CatHandle.new: $f1, $f2;\n    .say while $_ = $cat.get; # OUTPUT: «a␤b␤c␤d␤e␤»","n":"get"},{"n":"getc","d":"Defined as:\n\n    method getc(IO::CatHandle:D: --> Bool:D)\n\nReturns a single character of input from the handle. All the caveats\ndescribed in IO::Handle.getc apply. Returns Nil when there is no more\ninput. It is an error to call this method when the handle is in binary\nmode, resulting in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    my $cat = IO::CatHandle.new: $f1, $f2;\n    .say while $_ = $cat.getc; # OUTPUT: «I␤ ␤♥␤ ␤P␤e␤r␤l␤m␤e␤o␤w␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["Int(Cool:D) $bytes = { ... }","*%_"]},"m":0,"k":"m","n":"read","d":"Defined as:\n\n    method read(IO::CatHandle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)\n\nReads up to $bytes bytes from the handle and returns them in a Buf. $bytes\ndefaults to an implementation-specific value (in Rakudo, the value of\n$*DEFAULT-READ-ELEMS, which by default is set to 65536). It is permitted to\ncall this method on handles that are not in binary mode.\n\n    (my $f1 = 'foo'.IO).spurt: 'meow';\n    (my $f2 = 'bar'.IO).spurt: Blob.new: 4, 5, 6;\n    with IO::CatHandle.new: :bin, $f1, $f2 {\n        say .read: 2;    # OUTPUT: «Buf[uint8]:0x<6d 65>␤»\n        say .read: 2000; # OUTPUT: «Buf[uint8]:0x<6f 77 04 05 06>␤»\n    }\n\n    # Non-binary mode is OK too:\n    with IO::CatHandle.new: $f1, $f2 {\n        say .get;        # OUTPUT: «meow␤»\n        say .read: 2000; # OUTPUT: «Buf[uint8]:0x<04 05 06>␤»\n    }"},{"n":"readchars","d":"Defined as:\n\n    method readchars(IO::CatHandle:D: Int(Cool:D) $chars = 65536 --> Str:D)\n\nReturns a Str of up to $chars characters read from the handle. $chars\ndefaults to an implementation-specific value (in Rakudo, the value of\n$*DEFAULT-READ-ELEMS, which by default is set to 65536). It is NOT\npermitted to call this method on handles opened in binary mode and doing so\nwill result in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: 'Perl loves to';\n    (my $f2 = 'bar'.IO).spurt: ' meow';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        say .readchars: 11;   # OUTPUT: «Perl loves ␤»\n        say .readchars: 1000; # OUTPUT: «to meow␤»\n    }","s":{"r":"Mu","p":["Int(Cool:D) $chars = { ... }","*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method slurp(IO::CatHandle:D:)\n\nReads all of the available input from all the source handles and returns it\nas a Buf if the handle is in binary mode or as a Str otherwise. Returns Nil\nif the source handle queue has been exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    IO::CatHandle.new(      $f1, $f2).slurp.say; # OUTPUT: «foobar␤»\n    IO::CatHandle.new(:bin, $f1, $f2).slurp.say; # OUTPUT: «Buf[uint8]:0x<66 6f 6f 62 61 72>␤»\n    IO::CatHandle.new                .slurp.say; # OUTPUT: «Nil␤»","n":"slurp","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["|"],"r":"Mu"},"n":"slurp-rest"},{"d":"Defined as:\n\n    method DESTROY(IO::CatHandle:D:)\n\nCalls .close. This method isn't to be used directly, but is something\nthat's called during garbage collection.","n":"DESTROY","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    method close(IO::CatHandle:D: --> True)\n\nCloses the currently active source handle, as well as any already-open\nsource handles, and empties the source handle queue. Unlike a regular\nIO::Handle, an explicit call to .close is often not necessary on a\nCatHandle, as merely exhausting all the input closes all the handles that\nneed to be closed.\n\n    with IO::CatHandle.new: @bunch-of-handles {\n        say .readchars: 42;\n        .close; # we are done; close all the open handles\n    }","n":"close","m":0,"k":"m","s":{"p":["*%_"],"r":"Bool"}},{"d":"Defined as:\n\n    multi method encoding(IO::CatHandle:D:)\n    multi method encoding(IO::CatHandle:D: $new-encoding)\n\nSets the invocant's $.encoding attribute to the provided value. Valid\nvalues are the same as those accepted by IO::Handle.encoding (use value Nil\nto switch to binary mode). All source handles, including the active one\nwill use the provided $.encoding value.\n\n    (my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    with IO::CatHandle.new: $f1, $f2 {\n        # .encoding is 'utf8' by default:\n        .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n        .encoding: Nil; # switch to binary mode\n        .slurp.say; # OUTPUT: «Buf[uint8]:0x<72 6c 6d 65 6f 77>␤»\n    }","n":"encoding","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"m":1,"k":"m","s":{"p":["$enc is copy","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method encoding(IO::CatHandle:D:)\n    multi method encoding(IO::CatHandle:D: $new-encoding)\n\nSets the invocant's $.encoding attribute to the provided value. Valid\nvalues are the same as those accepted by IO::Handle.encoding (use value Nil\nto switch to binary mode). All source handles, including the active one\nwill use the provided $.encoding value.\n\n    (my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    with IO::CatHandle.new: $f1, $f2 {\n        # .encoding is 'utf8' by default:\n        .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n        .encoding: Nil; # switch to binary mode\n        .slurp.say; # OUTPUT: «Buf[uint8]:0x<72 6c 6d 65 6f 77>␤»\n    }","n":"encoding"},{"d":"Defined as:\n\n    method eof(IO::CatHandle:D: --> Bool:D)\n\nReturns True if the read operations have exhausted the source handle queue,\nincluding the contents of the last handle. Note: calling this method may\ncause one or more .on-switch calls, while the source handle queue is\nexamined, and the source handle queue may get exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    with IO::CatHandle.new: :on-switch{ print 'SWITCH! ' }, $f1, $f2 {\n                       # OUTPUT: «SWITCH! »\n        .eof.say;      # OUTPUT: «False␤»\n        .readchars(3);\n        .eof.say;      # OUTPUT: «SWITCH! False␤»\n\n        .slurp;        # OUTPUT: «SWITCH! »\n        .eof.say;      # OUTPUT: «True␤»\n    }\n\n\nThe same caveats for non-seekable handles and empty files that apply to\nIO::Handle.eof apply here.","n":"eof","k":"m","m":0,"s":{"r":"Bool:D","p":["*%_"]}},{"n":"IO","d":"Defined as:\n\n    method IO(IO::CatHandle:D:)\n\nAlias for .path","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    method path(IO::CatHandle:D:)\n\nReturns the value of .path attribute of the currently active source handle,\nor Nil if the source handle queue has been exhausted. Basically, if your\nCatHandle is based on files, this is the way to get the path of the file\nthe CatHandle is currently reading from.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\n    my $line;\n    my $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\n    say \"{$cat.path}:{$line++} $_\" for $cat.lines;\n    # OUTPUT:\n    # foo:1 A\n    # foo:2 B\n    # foo:3 C\n    # bar:1 D\n    # bar:2 E","n":"path","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Bool:D"},"m":0,"k":"m","n":"opened","d":"Defined as:\n\n    method opened(IO::CatHandle:D: --> Bool:D)\n\nReturns True if the invocant has any source handles, False otherwise.\n\n    say IO::CatHandle.new      .opened; # OUTPUT: «False␤»\n    say IO::CatHandle.new($*IN).opened; # OUTPUT: «True␤»\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    with IO::CatHandle.new: $f1 {\n        .opened.say; # OUTPUT: «True␤»\n        .slurp;\n        .opened.say; # OUTPUT: «False␤»\n    }"},{"s":{"r":"Mu","p":["|c is raw"]},"k":"m","m":0,"n":"lock","d":"Defined as:\n\n    method lock(IO::CatHandle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)\n\nSame as IO::Handle.lock. Returns Nil if the source handle queue has been\nexhausted.\n\nLocks only the currently active source handle. The .on-switch Callable can\nbe used to conveniently lock/unlock the handles as they're being processed\nby the CatHandle."},{"d":"Defined as:\n\n    method nl-in(IO::CatHandle:D:) is rw\n\nSets the invocant's $.nl-in attribute to the assigned value, which can be a\nStr or a List of Str, where each Str object represents the end-of-line\nstring. All source handles, including the active one will use the provided\n$.nl-in value. Note that source handle boundary is always counted as a new\nline break.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"DxEx\";\n    with IO::CatHandle.new: $f1, $f2 {\n        # .nl-in is [\"\\n\", \"\\r\\n\"] by default:\n        (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n        .nl-in = 'x';\n        (.get xx 3).perl.say; # OUTPUT: «(\"C\", \"D\", \"E\").Seq␤»\n        .close\n    }","n":"nl-in","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["|c is raw"],"r":"Mu"},"d":"Defined as:\n\n    method seek(IO::CatHandle:D: |c)\n\nCalls .seek on the currently active source handle, forwarding it all the\narguments, and returns the result. Returns Nil if the source handle queue\nhas been exhausted. NOTE: this method does NOT perform any source handle\nswitching, so seeking past the end of the current source handle will NOT\nseek to the next source handle in the queue and seeking past the beginning\nof the current source handle is a fatal error. Also see .next-handle, to\nlearn the details on when source handles are switched.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        .get.say;                     # OUTPUT: «foo␤»\n        .seek: -2, SeekFromCurrent;\n        .readchars(2).say;            # OUTPUT: «oo␤»\n        .seek: 1000, SeekFromCurrent; # this doesn't switch to second handle!\n        .readchars(3).say;            # OUTPUT: «bar␤»\n        try .seek: -4;                # this won't seek to previous handle!\n        say ~$!;                      # OUTPUT: «Failed to seek in filehandle: 22␤»\n    }","n":"seek"},{"n":"tell","d":"Defined as:\n\n    method tell(IO::CatHandle:D: --> Int:D)\n\nCalls .tell on the currently active source handle and returns the result.\nReturns Nil if the source handle queue has been exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        .get.say;                   # OUTPUT: «foo␤»\n        .tell.say;                  # OUTPUT: «3␤»\n        .seek: -2, SeekFromCurrent;\n        .tell.say;                  # OUTPUT: «1␤»\n        say .readchars: 3;          # OUTPUT: «oob␤»\n        .tell.say;                  # OUTPUT: «2␤»\n        }","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Bool:D"},"m":0,"k":"m","n":"t","d":"Defined as:\n\n    method t(IO::CatHandle:D: --> Bool:D)\n\nCalls .t, which tells if the handle is a TTY, on the currently active\nsource handle and returns the result. If the source handle queue has been\nexhausted, returns False.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    with IO::CatHandle.new: $f1, $*IN {\n        repeat { .t.say } while .next-handle; # OUTPUT: «False␤True␤»\n    }"},{"n":"unlock","d":"Defined as:\n\n    method unlock(IO::CatHandle:D:)\n\nSame as IO::Handle.unlock. Returns Nil if the source handle queue has been\nexhausted.\n\nUnlocks only the currently active source handle. The .on-switch Callable\ncan be used to conveniently lock/unlock the handles as they're being\nprocessed by the CatHandle.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"native-descriptor","d":"Defined as:\n\n    method native-descriptor(IO::CatHandle:D: --> Int:D)\n\nReturns the native-descriptor of the currently active source handle or Nil\nif the source handle queue has been exhausted.\n\nSince the CatHandle closes a source handle, once it's done with it, it's\npossible for successive source handles to have the same native descriptor,\nif they were passed to .new as Cool or IO::Path objects.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    with IO::CatHandle.new: $f1, $f2, $*IN {\n        repeat { .native-descriptor.say } while .next-handle;\n        # OUTPUT: «13␤13␤9␤»\n    }","s":{"r":"Int:D","p":["*%_"]},"k":"m","m":0},{"d":"Defined as:\n\n    method open(IO::CatHandle:D: --> IO::CatHandle:D)\n\nReturns the invocant. The intent of this method is to merely make CatHandle\nworkable with things that open IO::Handle. You never have to call this\nmethod intentionally.","n":"open","m":0,"k":"m","s":{"r":"IO::CatHandle","p":["*%_"]}},{"m":1,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"flush"},{"n":"out-buffer","s":{"p":["|"],"r":"Mu"},"k":"m","m":1},{"n":"print","m":1,"k":"m","s":{"p":["|"],"r":"Mu"}},{"n":"printf","s":{"r":"Mu","p":["|"]},"m":1,"k":"m"},{"k":"m","m":1,"s":{"p":["|"],"r":"Mu"},"n":"print-nl"},{"m":1,"k":"m","s":{"p":["|"],"r":"Mu"},"n":"put"},{"n":"say","m":1,"k":"m","s":{"r":"Mu","p":["|"]}},{"n":"write","s":{"p":["|"],"r":"Mu"},"m":1,"k":"m"},{"n":"WRITE","m":1,"k":"m","s":{"p":["|"],"r":"Mu"}},{"m":1,"k":"m","s":{"r":"Mu","p":["|"]},"n":"READ"},{"n":"EOF","m":1,"k":"m","s":{"p":["|"],"r":"Mu"}},{"n":"on-switch","d":"Defined as:\n\n    has &.on-switch is rw\n\nOne of the attributes that can be set during .new call and changed later by\nassigning to. By default is not specified. Takes a Callable with .count of\n0, 1, 2, or Inf. Gets called every time .next-handle is, which happens once\nduring .new call and then each time a source handle is switched to the next\none in the queue, or when the .next-handle method is called manually.\n\nIf the .count of &.on-switch is 0, it receives no arguments; if it's 1, it\nreceives the currently active handle, and if it's 2 or Inf, it receives the\ncurrently active handle, and the last active handle as positional arguments\n(in that order). On the very first &.on-switch execution, the \"last active\nhandle\" argument is Nil. Upon source handle queue exhaustion the \"currently\nactive handle\" argument is Nil, and all the executions made afterwards have\nboth arguments as Nil.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\n    my $line;\n    my $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\n    say \"{$cat.path}:{$line++} $_\" for $cat.lines;\n    # OUTPUT:\n    # foo:1 A\n    # foo:2 B\n    # foo:3 C\n    # bar:1 D\n    # bar:2 E\n\n\n    my @old-stuff;\n    sub on-switch ($new, $old) {\n        $new and $new.seek: 1, SeekFromBeginning;\n        $old and @old-stuff.push: $old.open.slurp: :close;\n    }\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n    my $cat = IO::CatHandle.new: :&on-switch, $f1, $f2;\n    $cat.lines.perl.say; # OUTPUT: «(\"\", \"B\", \"C\", \"\", \"E\").Seq␤»\n    @old-stuff.perl.say; # OUTPUT: «[\"A\\nB\\nC\", \"D\\nE\"]␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"},{"n":"!LINES","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["@handles","&!on-switch","$!chomp","$!nl-in","$encoding","$bin","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!SET-SELF"},{"n":"!WORDS","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"mro":["IO::Handle"]},{"mro":[],"m":[{"s":{"r":"Mu","p":["Cool $limit? is copy",":$bin","*%_"]},"k":"m","m":0,"n":"recv","d":"method recv(IO::Socket:D: Cool $elems = Inf, :$bin)\n\nReceive a packet and return it, either as a Blob if :bin was passed, or a\nStr if not. Receives up to $elems or 65535 (whichever is smaller) bytes or\ncharacters.\n\nFails if the socket is not connected."},{"d":"method read(IO::Socket:D: Int(Cool) $bytes)\n\nReads $bytes bytes from the socket and returns them in a Blob.\n\nFails if the socket is not connected.","n":"read","m":0,"k":"m","s":{"r":"Mu","p":["Int(Cool) $bufsize","*%_"]}},{"n":"nl-in","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method get(IO::Socket:D: --> Str:D)\n\nReads a single line of input from the socket, removing the trailing newline\ncharacters (as set by .nl-in). Returns Nil, if no more input is available.\n\nFails if the socket is not connected.","n":"get"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"lines"},{"d":"method print(IO::Socket:D: Str(Cool) $string)\n\nWrites the supplied string to the socket, thus sending it to other end of\nthe connection. The binary version is #method write.\n\nFails if the socket is not connected.","n":"print","m":0,"k":"m","s":{"r":"Bool","p":["Str(Cool) $string","*%_"]}},{"d":"method put(IO::Socket:D: Str(Cool) $string)\n\nWrites the supplied string, with a \\n appended to it, to the socket, thus\nsending it to other end of the connection.\n\nFails if the socket is not connected.","n":"put","k":"m","m":0,"s":{"p":["Str(Cool) $string","*%_"],"r":"Bool"}},{"n":"write","d":"method write(IO::Socket:D: Blob:D $buf)\n\nWrites the supplied buffer to the socket, thus sending it to other end of\nthe connection. The string version is #method print.\n\nFails if the socket is not connected.","s":{"p":["Blob:D $buf","*%_"],"r":"Bool"},"m":0,"k":"m"},{"d":"method close(IO::Socket:D)\n\nCloses the socket.\n\nFails if the socket is not connected.","n":"close","m":0,"k":"m","s":{"r":"Bool","p":["*%_"]}},{"d":"method native-descriptor()\n\nThis returns a value that the operating system would understand as a\n\"socket descriptor\" and is suitable for passing to a native function that\nrequires a socket descriptor as an argument such as setsockopt.","n":"native-descriptor","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Nil","p":["*%_"]},"m":0,"k":"m","n":"!ensure-coders"}],"k":"ro","n":"IO::Socket","d":"TITLE\nrole IO::Socket\n\nSUBTITLE\nNetwork socket\n\n    role IO::Socket { ... }\n\nIO::Socket contains read and write methods for sockets. It is usually used\nthrough IO::Socket::INET.\n\n","a":[{"t":"Mu","n":"$!PIO","k":"v"},{"t":"Str","n":"$.encoding","k":"v"},{"t":"Mu","n":"$.nl-in","k":"v"},{"t":"Str:D","n":"$.nl-out","k":"v"},{"n":"$!decoder","t":"Encoding::Decoder","k":"v"},{"k":"v","n":"$!encoder","t":"Encoding::Encoder"}],"t":"IO::Socket","b":"C"},{"n":"IO::Socket::INET","t":"IO::Socket::INET","a":[{"k":"v","t":"Str","n":"$.host"},{"k":"v","n":"$.port","t":"Int"},{"k":"v","n":"$.localhost","t":"Str"},{"k":"v","t":"Int","n":"$.localport"},{"k":"v","n":"$.backlog","t":"Int"},{"k":"v","t":"Bool","n":"$.listening"},{"k":"v","n":"$.family","t":"Mu"},{"t":"Mu","n":"$.proto","k":"v"},{"n":"$.type","t":"Mu","k":"v"},{"n":"$!PIO","t":"Mu","k":"v"},{"n":"$.encoding","t":"Str","k":"v"},{"k":"v","t":"Mu","n":"$.nl-in"},{"n":"$.nl-out","t":"Str:D","k":"v"},{"t":"Encoding::Decoder","n":"$!decoder","k":"v"},{"n":"$!encoder","t":"Encoding::Encoder","k":"v"}],"d":"TITLE\nclass IO::Socket::INET\n\nSUBTITLE\nTCP Socket\n\n    class IO::Socket::INET does IO::Socket {}\n\n\nIO::Socket::INET provides TCP sockets, both the server and the client\nside.\n\nFor UDP support, please see IO::Socket::Async.\n\nHere is an example of a very simplistic \"echo\" server that listens on\nlocalhost, port 3333:\n\n    my $listen = IO::Socket::INET.new( :listen,\n                                       :localhost<localhost>,\n                                       :localport(3333) );\n    loop {\n        my $conn = $listen.accept;\n        try {\n            while my $buf = $conn.recv(:bin) {\n                $conn.write: $buf;\n            }\n        }\n        $conn.close;\n\n        CATCH {\n              default { .payload.say;      }\n        }\n\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    my $conn = IO::Socket::INET.new( :host<localhost>,\n                                     :port(3333) );\n    $conn.print: 'Hello, Raku';\n    say $conn.recv;\n    $conn.close;\n\n\nPlease bear in mind that this is a synchronous connection; an attempt by\nany of the nodes to write without the other reading will produce an Could\nnot receive data from socket: Connection reset by peer error.\n\n","mro":["IO::Socket","Any"],"m":[{"n":"connect","s":{"r":"Mu","p":["$host","$port","*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["$localhost","$localport","*%_"]},"k":"m","m":0,"n":"listen"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"accept"},{"n":"host","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"port","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"localhost"},{"n":"localport","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"backlog","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"listening"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"family"},{"n":"proto","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"type","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"encoding","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"nl-out"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Nil"},"n":"!ensure-coders"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"!initialize"}],"k":"c","b":"A"},{"b":"A","n":"IO::Socket::Async","t":"IO::Socket::Async","a":[{"k":"v","t":"Mu","n":"$!VMIO"},{"t":"int","n":"$!udp","k":"v"},{"t":"Mu","n":"$.enc","k":"v"},{"n":"$!encoder","t":"Mu","k":"v"},{"t":"Mu","n":"$!close-promise","k":"v"},{"t":"Mu","n":"$!close-vow","k":"v"},{"t":"Str","n":"$.peer-host","k":"v"},{"t":"IO::Socket::Async::Port-Number","n":"$.peer-port","k":"v"},{"k":"v","n":"$.socket-host","t":"Str"},{"k":"v","n":"$.socket-port","t":"IO::Socket::Async::Port-Number"}],"d":"TITLE\nclass IO::Socket::Async\n\nSUBTITLE\nAsynchronous socket in TCP or UDP\n\n    class IO::Socket::Async {}\n\nIO::Socket::Async|/type/IO::Socket::Async provides asynchronous sockets,\nfor both the server and the client side.\n\nHere is a simple example of a simple \"hello world\" HTTP server that listens\non port 3333:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3333) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n        }\n        CATCH {\n            default {\n                say .^name, ': ', .Str;\n                say \"handled in $?LINE\";\n            }\n        }\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    await IO::Socket::Async.connect('127.0.0.1', 3333).then( -> $promise {\n        given $promise.result {\n            .print(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\");\n            react {\n                whenever .Supply() -> $v {\n                    $v.print;\n                    done;\n                }\n            }\n            .close;\n        }\n    });\n\n\nIO::Socket::Async can also send and receive UDP messages An example server\nthat outputs all the data it receives would be:\n\n    my $socket = IO::Socket::Async.bind-udp('localhost', 3333);\n\n    react {\n        whenever $socket.Supply -> $v {\n            if $v.chars > 0 {\n                say $v;\n            }\n        }\n    }\n\n\nAnd an associated client might be:\n\n    my $socket = IO::Socket::Async.udp();\n    await $socket.print-to('localhost', 3333, \"Hello, Raku!\");\n\n\nThe CATCH phaser can be included to deal specifically with problems that\nmight occur in this kind of sockets, such as a port being already taken:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3000) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n            QUIT {\n                default {\n                    say .^name, '→ ', .Str;\n                    say \"handled in line $?LINE\";\n                }\n            }\n        }\n\n    }\n    # Will print this, if address 3000 is already in use:\n    # X::AdHoc→ address already in use\n    # handled in 23\n\n\nMain difference with using other phasers such as CATCH is that this kind of\nexception will be caught within the whenever block and will put exiting the\nprogram, or not, under your control.\n\n","mro":["Any"],"k":"c","m":[{"n":"new","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"method print(Str $str --> Promise)\n\nAttempt to send $str on the IO::Socket::Async that will have been obtained\nindirectly via connect or listen, returning a Promise that will be kept\nwith the number of bytes sent or broken if there was an error sending.","n":"print","k":"m","m":0,"s":{"r":"Mu","p":["$str",":$scheduler = { ... }","*%_"]}},{"s":{"r":"Mu","p":["Blob $b",":$scheduler = { ... }","*%_"]},"m":0,"k":"m","n":"write","d":"method write(Blob $b --> Promise)\n\nThis method will attempt to send the bytes in $b on the IO::Socket::Async\nthat will have been obtained indirectly via connect or listen, returning a\nPromise that will be kept with the number of bytes sent or broken if there\nwas an error sending."},{"n":"close","d":"method close()\n\nClose the connected client IO::Socket::Async which will have been obtained\nfrom the listen Supply or the connect Promise.\n\nIn order to close the underlying listening socket created by listen you can\nclose the Tap. See listen for examples.","s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["$host","$port where { ... }",":$enc = \"utf-8\"",":$scheduler = { ... }","*%_"]},"k":"m","m":0,"n":"connect","d":"method connect(Str $host, Int $port --> Promise)\n\nAttempts to connect to the TCP server specified by $host and $port,\nreturning a Promise that will either be kept with a connected\nIO::Socket::Async or broken if the connection cannot be made."},{"d":"method listen(Str $host, Int $port --> Supply)\n\nCreates a listening socket on the specified $host and $port, returning a\nSupply to which the accepted client IO::Socket::Asyncs will be emitted.\nThis Supply should be tapped start listening for client connections. You\ncan use $port = 0 if you want the operating system to find one for you.\n\nTo close the underlying listening socket, the Tap returned by tapping the\nlistener should be closed.\n\nFor example, when using tap:\n\n    my $listener = IO::Socket::Async.listen('127.0.0.1', 8080);\n    my $tap = $listener.tap({ ... });\n\n    # When you want to close the listener\n    $tap.close;\n\n\nOr when using whenever:\n\n    my $listener = IO::Socket::Async.listen('127.0.0.1', 5000);\n    my $tap;\n    react {\n        $tap = do whenever $listener -> $conn { ... }\n    }\n\n    # When you want to close the listener, you can still use:\n    $tap.close;","n":"listen","k":"m","m":0,"s":{"r":"Mu","p":["$host","$port where { ... }","$backlog = 128",":$enc = \"utf-8\"",":$scheduler = { ... }","*%_"]}},{"d":"method native-descriptor(--> Int)\n\nReturns the file descriptor of this socket.","n":"native-descriptor","k":"m","m":0,"s":{"p":["*%_"],"r":"Int"}},{"n":"udp","d":"method udp(IO::Socket::Async:U: :$broadcast --> IO::Socket::Async)\n\nReturns an initialized IO::Socket::Async client object that is configured\nto send UDP messages using print-to or write-to. The :broadcast adverb will\nset the SO_BROADCAST option which will allow the socket to send packets to\na broadcast address.","s":{"p":[":$broadcast",":$enc = \"utf-8\"",":$scheduler = { ... }","*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"method bind-udp(IO::Socket::Async:U: Str() $host, Int() $port, :$broadcast --> IO::Socket::Async)\n\nThis returns an initialized IO::Socket::Async server object that is\nconfigured to receive UDP messages sent to the specified $host and $port\nand is equivalent to listen for a TCP socket. The :broadcast adverb can be\nspecified to allow the receipt of messages sent to the broadcast address.","n":"bind-udp","m":0,"k":"m","s":{"p":["$host","$port where { ... }",":$broadcast",":$enc = \"utf-8\"",":$scheduler = { ... }","*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["$host","$port where { ... }","$str",":$scheduler = { ... }","*%_"],"r":"Mu"},"d":"method print-to(IO::Socket::Async:D: Str() $host, Int() $port, Str() $str --> Promise)\n\nThis is the equivalent of print for UDP sockets that have been created with\nthe udp method, it will try send a UDP message of $str to the specified\n$host and $port returning a Promise that will be kept when the data is\nsuccessfully sent or broken if it was unable to send the data. In order to\nsend to a broadcast address the :broadcast flag must have been specified\nwhen the socket was created.","n":"print-to"},{"d":"method write-to(IO::Socket::Async:D: Str() $host, Int() $port, Blob $b --> Promise)\n\nThis is the equivalent of write for UDP sockets that have been created with\nthe udp method. It will try send a UDP message comprised of the bytes in\nthe Blob $b to the specified $host and $port returning a Promise that will\nbe kept when the data is successfully sent or broken if it was unable to\nsend the data. In order to send to a broadcast address the :broadcast flag\nmust have been specified when the socket was created.","n":"write-to","m":0,"k":"m","s":{"p":["$host","$port where { ... }","Blob $b",":$scheduler = { ... }","*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"enc"},{"n":"peer-host","d":"method peer-host(--> Str)\n\nReturns the IP address of the remote end of this socket.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"peer-port","d":"method peer-port(--> Int)\n\nReturns the port of the remote end of this socket."},{"n":"socket-host","d":"method socket-host(--> Str)\n\nReturns the IP address of the local end of this socket.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method socket-port(--> Int)\n\nReturns the port of the local end of this socket.","n":"socket-port"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}]},{"t":"Int","n":"IO::Socket::Async::Port-Number","k":"ss"},{"a":[{"t":"Promise","n":"$!VMIO-tobe","k":"v"},{"t":"Promise","n":"$.socket-host","k":"v"},{"n":"$.socket-port","t":"Promise","k":"v"},{"k":"v","t":"Callable","n":"&!on-close"}],"t":"IO::Socket::Async::ListenSocket","n":"IO::Socket::Async::ListenSocket","k":"c","m":[{"m":0,"k":"s","s":{"r":"Mu","p":["Promise :VMIO-tobe($!VMIO-tobe)","Promise :socket-host($!socket-host)","Promise :socket-port($!socket-port)","*%_"]},"n":"TWEAK"},{"s":{"p":["&on-close","Promise :$VMIO-tobe","Promise :$socket-host","Promise :$socket-port","*%_"],"r":"Mu"},"k":"m","m":0,"n":"new"},{"s":{"r":"Int","p":["*%_"]},"m":0,"k":"m","n":"native-descriptor"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"socket-host"},{"n":"socket-port","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Tap"],"b":"A"},{"k":"v","t":"Sub","n":"&srand"},{"k":"s","m":1,"s":{"r":"Int:D","p":["Int:D $seed"]},"n":"srand"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<^..>"},{"s":{"r":"Mu","p":["$min","$max"]},"k":"s","m":1,"n":"infix:<^..>"},{"k":"v","t":"Sub+{is-pure}","n":"&asin"},{"n":"asin","k":"s","m":1,"s":{"p":["Numeric \\x"],"r":"Mu"}},{"s":{"p":["Cool \\x"],"r":"Mu"},"k":"s","m":1,"n":"asin"},{"n":"asin","s":{"p":["num $x"],"r":"num"},"m":1,"k":"s"},{"k":"v","n":"&sort","t":"Sub"},{"s":{"r":"Mu","p":["&by","@values"]},"k":"s","m":1,"n":"sort"},{"n":"sort","s":{"p":["&by","+\\values is raw"],"r":"Mu"},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["@values"]},"n":"sort"},{"n":"sort","m":1,"k":"s","s":{"r":"Mu","p":["+\\values is raw"]}},{"n":"&infix:<..^>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"k":"s","m":1,"s":{"p":["$min","$max"],"r":"Mu"},"n":"infix:<..^>"},{"n":"SIGTRAP","t":"Signal","k":"e"},{"n":"More","t":"Order","k":"e"},{"n":"&leave","t":"Sub","k":"v"},{"n":"leave","s":{"p":["|"],"r":"Mu"},"k":"s","m":0},{"mro":["Iterable","Any"],"m":[{"k":"m","m":1,"s":{"r":"Mu","p":["*@values","*%_"]},"n":"STORE"},{"n":"BIND-POS","k":"m","m":0,"s":{"p":["|"],"r":"Mu"}},{"s":{"p":["|"],"r":"Mu"},"k":"m","m":0,"n":"DELETE-POS"},{"n":"ASSIGN-POS","s":{"p":["\\pos","Mu \\assignee","*%_"],"r":"Mu"},"m":1,"k":"m"},{"s":{"r":"Mu","p":["Any:U \\pos","Mu \\assignee","*%_"]},"m":1,"k":"m","n":"ASSIGN-POS"},{"n":"shape","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"Real"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"Int"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"eager"},{"n":"flat","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"list"},{"n":"sink","k":"m","m":0,"s":{"p":["*%_"],"r":"Nil"}},{"n":"FLATTENABLE_LIST","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"FLATTENABLE_HASH"},{"n":"iterator","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["int $index","*%_"],"r":"Mu"},"k":"m","m":0,"n":"out_of_range"},{"n":"!create-ws","m":0,"k":"m","s":{"p":["$shape","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"!create"},{"n":"!shaped","s":{"r":"Mu","p":["\\shape","*%_"]},"k":"m","m":0}],"k":"c","n":"array","t":"array","b":"A"},{"b":"C","t":"array::shaped1intarray","n":"array::shaped1intarray","m":[{"n":"iterator","m":0,"k":"m","s":{"r":"array::shaped1intarray::Iterate-int:D","p":["*%_"]}},{"s":{"r":"::?CLASS","p":["*%_"]},"k":"m","m":0,"n":"reverse"},{"n":"rotate","m":0,"k":"m","s":{"p":["Int(Cool) $rotate = 1","*%_"],"r":"::?CLASS"}}],"k":"ro","mro":[]},{"b":"C","n":"array::shaped3intarray","t":"array::shaped3intarray","mro":[],"k":"ro"},{"b":"C","k":"ro","mro":[],"t":"array::shaped2intarray","n":"array::shaped2intarray"},{"n":"array::shaped3numarray","t":"array::shaped3numarray","mro":[],"k":"ro","b":"C"},{"mro":[],"k":"ro","m":[{"s":{"p":["*%_"],"r":"array::shaped1strarray::Iterate-str:D"},"m":0,"k":"m","n":"iterator"},{"n":"reverse","k":"m","m":0,"s":{"p":["*%_"],"r":"::?CLASS"}},{"m":0,"k":"m","s":{"p":["Int(Cool) $rotate = 1","*%_"],"r":"::?CLASS"},"n":"rotate"}],"n":"array::shaped1strarray","t":"array::shaped1strarray","b":"C"},{"b":"C","k":"ro","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"shape"}],"mro":[],"t":"array::shapedarray","n":"array::shapedarray"},{"b":"C","n":"array::shapedstrarray","t":"array::shapedstrarray","mro":[],"k":"ro","m":[{"n":"iterator","s":{"p":["*%_"],"r":"array::shapedstrarray::Iterate-str:D"},"m":0,"k":"m"}]},{"n":"array::typedim2role","a":[{"k":"v","t":"Mu","n":"$!reified"},{"k":"v","n":"$!todo","t":"Mu"}],"t":"List","mro":["Positional","Iterable","Cool"],"k":"c","m":[{"n":"!AT_POS_SLOW","s":{"p":["\\pos","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!JUNCTIONIZE","s":{"p":["\\sep","Mu \\strings","\\i","\\elems","Mu \\initial","*%_"],"r":"Mu"},"m":0,"k":"m"}],"b":"C"},{"b":"C","mro":[],"k":"ro","m":[{"n":"iterator","s":{"p":["*%_"],"r":"array::shaped1numarray::Iterate-num:D"},"m":0,"k":"m"},{"n":"reverse","k":"m","m":0,"s":{"r":"::?CLASS","p":["*%_"]}},{"n":"rotate","s":{"r":"::?CLASS","p":["Int(Cool) $rotate = 1","*%_"]},"k":"m","m":0}],"n":"array::shaped1numarray","t":"array::shaped1numarray"},{"b":"C","n":"array::shapedintarray","t":"array::shapedintarray","mro":[],"m":[{"n":"iterator","m":0,"k":"m","s":{"r":"array::shapedintarray::Iterate-int:D","p":["*%_"]}}],"k":"ro"},{"n":"array::shaped3strarray","t":"array::shaped3strarray","mro":[],"k":"ro","b":"C"},{"mro":[],"k":"ro","n":"array::shaped2strarray","t":"array::shaped2strarray","b":"C"},{"b":"C","t":"array::shaped2numarray","n":"array::shaped2numarray","k":"ro","mro":[]},{"n":"array::shapednumarray","t":"array::shapednumarray","mro":[],"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"array::shapednumarray::Iterate-num:D"},"n":"iterator"}],"k":"ro","b":"C"},{"t":"Sub","n":"&rename","k":"v"},{"s":{"r":"Mu","p":["$from","$to",":$createonly"]},"k":"s","m":1,"n":"rename"},{"k":"v","n":"&prefix:<⚛>","t":"Sub"},{"s":{"p":["$source is rw"],"r":"Mu"},"m":1,"k":"s","n":"prefix:<⚛>"},{"n":"prefix:<⚛>","m":1,"k":"s","s":{"p":["atomicint $source is rw"],"r":"Mu"}},{"k":"e","n":"SIGTERM","t":"Signal"},{"k":"v","n":"&infix:<does>","t":"Sub+{Precedence}"},{"k":"s","m":1,"s":{"p":["Mu:D \\obj","Mu:U \\rolish"],"r":"Mu"},"n":"infix:<does>"},{"m":1,"k":"s","s":{"p":["Mu:D \\obj","Mu:U \\rolish",":$value! is raw"],"r":"Mu"},"n":"infix:<does>"},{"n":"infix:<does>","k":"s","m":1,"s":{"r":"Mu","p":["Mu:U \\obj","Mu:U \\role","*%_"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:D \\obj","**@roles"]},"n":"infix:<does>"},{"n":"infix:<does>","k":"s","m":1,"s":{"p":["Mu:U \\obj","**@roles"],"r":"Mu"}},{"n":"&infix:<...^>","t":"Sub","k":"v"},{"n":"infix:<...^>","s":{"r":"Mu","p":["\\a","Mu \\b"]},"m":1,"k":"s"},{"t":"SocketType","n":"SOCK_SEQPACKET","k":"e"},{"mro":["Any"],"m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"backtrace","d":"Defined as:\n\n    method backtrace(Exception:D:)\n\nReturns the backtrace associated with the exception in a Backtrace object\nor an empty string if there is none. Only makes sense on exceptions that\nhave been thrown at least once.\n\n    try die \"Something bad happened\";\n    with $! { .backtrace.print ; }"},{"n":"vault-backtrace","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"reset-backtrace"},{"s":{"r":"Mu","p":["$bt?","*%_"]},"m":0,"k":"m","n":"throw","d":"Defined as:\n\n    method throw(Exception:D:)\n\nThrows the exception.\n\n    my $exception = X::AdHoc.new;    # Totally fine\n    try $exception.throw;            # Throws\n    if ($!) { #`( some handling ) }; # Suppress the exception"},{"n":"rethrow","d":"Defined as:\n\n    method rethrow(Exception:D:)\n\nRethrows an exception that has already been thrown at least once. This is\ndifferent from throw in that it preserves the original backtrace.\n\n    my $e = X::AdHoc.new(payload => \"Bad situation\");\n    sub f() { die 'Bad' };\n    sub g() { try f; CATCH { default { .rethrow } } };\n    g;\n    CATCH { default { say .backtrace.full } };","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Bool"},"d":"Defined as:\n\n    method resume(Exception:D:)\n\nResumes control flow where .throw left it when handled in a CATCH block.\n\n    # For example, resume control flow for any exception\n    CATCH { default { .resume } }","n":"resume"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"die"},{"n":"fail","d":"Defined as:\n\n    multi sub    fail(*@text)\n    multi sub    fail(Exception $e)\n    method fail(Exception:D:)\n\nExits the calling Routine and returns a Failure object wrapping the\nexception $e - or, for the *@text form, an X::AdHoc exception constructed\nfrom the concatenation of @text. If the caller activated fatal exceptions\nvia the pragma use fatal;, the exception is thrown instead of being\nreturned as a Failure.\n\n    # A custom exception defined\n    class ForbiddenDirectory is Exception {\n        has Str $.name;\n\n        method message { \"This directory is forbidden: '$!name'\" }\n    }\n\n    sub copy-directory-tree ($dir) {\n        # We don't allow for non-directories to be copied\n        fail \"$dir is not a directory\" if !$dir.IO.d;\n        # We don't allow 'foo' directory to be copied too\n        fail ForbiddenDirectory.new(:name($dir)) if $dir eq 'foo';\n        # or above can be written in method form as:\n        # ForbiddenDirectory.new(:name($dir)).fail if $dir eq 'foo';\n        # Do some actual copying here\n        ...\n    }\n\n    # A Failure with X::AdHoc exception object is returned and\n    # assigned, so no throwing Would be thrown without an assignment\n    my $result = copy-directory-tree(\"cat.jpg\");\n    say $result.exception; # OUTPUT: «cat.jpg is not a directory␤»\n\n    # A Failure with a custom Exception object is returned\n    $result = copy-directory-tree('foo');\n    say $result.exception; # OUTPUT: «This directory is forbidden: 'foo'␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","s":{"r":"Bool","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Nil","p":["*%_"]},"n":"!maybe-set-control"}],"k":"c","n":"Exception","a":[{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass Exception\n\nSUBTITLE\nAnomalous event capable of interrupting normal control-flow\n\n    class Exception {}\n\nAll exceptions that are placed into the $! variable (or into $_ in CATCH\nblocks) inherit from Exception. When you call die or fail with a\nnon-Exception argument, it is wrapped into an X::AdHoc object, which also\ninherits from Exception.\n\nUser-defined exception classes should inherit from Exception too, and\ndefine at least a method message.\n\n    class X::YourApp::SomeError is Exception {\n        method message() {\n            \"A YourApp-Specific error occurred: out of coffee!\";\n        }\n    }\n\n","t":"Exception","b":"A"},{"t":"Sub+{is-pure}","n":"&infix:«>»","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["$?"]},"n":"infix:«>»"},{"n":"infix:«>»","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"}},{"n":"infix:«>»","m":1,"k":"s","s":{"r":"Mu","p":["Real \\a","Real \\b"]}},{"n":"infix:«>»","s":{"r":"Bool:D","p":["Int:D \\a","Int:D \\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["int $a","int $b"]},"n":"infix:«>»"},{"n":"infix:«>»","k":"s","m":1,"s":{"p":["Num:D \\a","Num:D \\b"],"r":"Bool:D"}},{"s":{"p":["num $a","num $b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«>»"},{"m":1,"k":"s","s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Bool:D"},"n":"infix:«>»"},{"n":"infix:«>»","s":{"r":"Bool:D","p":["Rational:D \\a","Int:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Bool:D"},"n":"infix:«>»"},{"n":"infix:«>»","s":{"p":["Instant:D $a","Instant:D $b"],"r":"Bool:D"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["DateTime:D \\a","DateTime:D \\b"],"r":"Bool:D"},"n":"infix:«>»"},{"s":{"r":"Bool:D","p":["Date:D $a","Date:D $b"]},"m":1,"k":"s","n":"infix:«>»"},{"s":{"p":["Version:D \\a","Version:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:«>»"},{"k":"v","n":"&squish","t":"Sub"},{"n":"squish","k":"s","m":1,"s":{"r":"Mu","p":["+\\values is raw","|c is raw"]}},{"k":"e","t":"ProtocolType","n":"PROTO_UDP"},{"k":"v","n":"&infix:<≥>","t":"Sub+{is-pure}"},{"n":"infix:«>=»","s":{"p":["$?"],"r":"Mu"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Mu"},"n":"infix:«>=»"},{"n":"infix:«>=»","s":{"r":"Mu","p":["Real \\a","Real \\b"]},"m":1,"k":"s"},{"n":"infix:«>=»","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:«>=»","s":{"r":"Bool:D","p":["int $a","int $b"]},"k":"s","m":1},{"s":{"p":["Num:D \\a","Num:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«>=»"},{"s":{"p":["num $a","num $b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«>=»"},{"n":"infix:«>=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Rational:D \\a","Rational:D \\b"]}},{"n":"infix:«>=»","s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Bool:D","p":["Int:D \\a","Rational:D \\b"]}},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Bool:D","p":["Instant:D $a","Instant:D $b"]}},{"m":1,"k":"s","s":{"r":"Bool:D","p":["DateTime:D \\a","DateTime:D \\b"]},"n":"infix:«>=»"},{"n":"infix:«>=»","k":"s","m":1,"s":{"r":"Bool:D","p":["Date:D $a","Date:D $b"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"n":"infix:«>=»"},{"t":"Sub","n":"&unimatch","k":"v"},{"s":{"p":["Str:D $str","|c is raw"],"r":"Mu"},"k":"s","m":1,"n":"unimatch"},{"n":"unimatch","s":{"p":["Int:D $code","Stringy:D $pvalname","Stringy:D $propname"],"r":"Mu"},"m":1,"k":"s"},{"n":"unimatch","k":"s","m":1,"s":{"p":["Int:D $code","Stringy:D $pvalname","Stringy:D $propname = { ... }"],"r":"Mu"}},{"n":"&sech","t":"Sub+{is-pure}","k":"v"},{"n":"sech","s":{"p":["Numeric \\x"],"r":"Mu"},"m":1,"k":"s"},{"n":"sech","s":{"p":["Cool \\x"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["num $x"],"r":"num"},"n":"sech"},{"t":"Sub","n":"&parse-names","k":"v"},{"s":{"r":"Mu","p":["Str:D \\names"]},"k":"s","m":0,"n":"parse-names"},{"k":"v","t":"Sub+{Precedence}","n":"&postfix:<++>"},{"n":"postfix:<++>","k":"s","m":1,"s":{"r":"Mu","p":["Mu:D $a is rw"]}},{"k":"s","m":1,"s":{"p":["Mu:U $a is rw"],"r":"Mu"},"n":"postfix:<++>"},{"n":"postfix:<++>","s":{"r":"Int:D","p":["Int:D $a is rw"]},"k":"s","m":1},{"s":{"p":["int $a is rw"],"r":"int"},"m":1,"k":"s","n":"postfix:<++>"},{"s":{"r":"Bool","p":["Bool:U $a is rw"]},"k":"s","m":1,"n":"postfix:<++>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Bool:D $a is rw"]},"n":"postfix:<++>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Num:D $a is rw"]},"n":"postfix:<++>"},{"n":"postfix:<++>","m":1,"k":"s","s":{"p":["Num:U $a is rw"],"r":"Num"}},{"n":"postfix:<++>","s":{"r":"num","p":["num $a is rw"]},"k":"s","m":1},{"n":"&infix:<?|>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"n":"infix:<?|>","s":{"p":["Mu $x = Bool::False"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<?|>","s":{"r":"Mu","p":["Mu \\a","Mu \\b"]},"k":"s","m":1},{"b":"A","a":[{"t":"List","n":"@!list","k":"v"},{"t":"Hash","n":"%!hash","k":"v"}],"t":"Capture","d":"TITLE\nclass Capture\n\nSUBTITLE\nArgument list suitable for passing to a Signature\n\n \n\n    class Capture { }\n\n\nA Capture is a container for passing arguments to a code object. Captures\nare the flip-side of Signatures – Captures are the caller defined\narguments, while Signatures are the callee defined parameters.\n\nWhen you call print $a, $b, the $a, $b part is a Capture.\n\nCaptures contain a list-like part for positional arguments and a hash-like\npart for named arguments, thus behaving as Positional and Associative,\nalthough it does not actually mixes in those roles. For the named\narguments, Captures use a slightly different syntax than a normal List.\nThere are two easy ways to make a named argument: 1) use an unquoted key\nnaming a parameter, followed by =>, followed by the argument and 2) use a\ncolon-pair literal named after the parameter:\n\n    say unique 1, -2, 2, 3, as => { abs $_ };   # OUTPUT: «(1 -2 3)␤»\n    # ... is the same thing as:\n    say unique 1, -2, 2, 3, :as({ abs $_ });    # OUTPUT: «(1 -2 3)␤»\n    # Be careful not to quote the name of a named parameter:\n    say unique 1, -2, 2, 3, 'as' => { abs $_ };\n    # OUTPUT: «(1 -2 2 3 as => -> ;; $_? is raw { #`(Block|78857320) ... })␤»\n\nA stand-alone Capture can also be made, stored, and used later. A literal\nCapture can be created by prefixing a term with a backslash \\. Commonly,\nthis term will be a List of terms, from which any Pair literal will be\nplaced in the named part, and all other terms will be placed in the\npositional part.\n\n    my $c = \\(42);          # Capture with one positional part\n    $c = \\(1, 2, a => 'b'); # Capture with two positional and one named parts\n\nTo use such a Capture, you may use '|' before it in a function call, and it\nwill be as if the values in the Capture were passed directly to the\nfunction as arguments – named arguments will be passed as named arguments\nand positional arguments will be passed as positional arguments. You may\nre-use the Capture as many times as you want, even with different\nfunctions.\n\n    my $c = \\(4, 2, 3);\n    reverse(|$c).say; # OUTPUT: «3 2 4␤»\n    sort(5,|$c).say;  # OUTPUT: «2 3 4 5␤»\n\nInside a Signature, a Capture may be created by prefixing a sigilless\nparameter with a vertical bar |. This packs the remainder of the argument\nlist into that parameter.\n\n    f(1, 2, 3, a => 4, b => 5);\n    sub f($a, |c) {\n        # c  is  \\(2, 3, a => 4, b => 5)\n    }\n\nNote that Captures are still Lists in that they may contain containers, not\njust values:\n\n    my $b = 1;\n    my $c = \\(4, 2, $b, 3);\n    sort(|$c).say;        # OUTPUT: «1 2 3 4␤»\n    $b = 6;\n    sort(|$c).say;        # OUTPUT: «2 3 4 6␤»\n\n","n":"Capture","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["|c is raw"]},"n":"from-args"},{"n":"BUILD","k":"s","m":0,"s":{"r":"Nil","p":[":@list",":%hash","*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"hash","d":"Defined as:\n\n    method hash(Capture:D:)\n\nReturns the named/hash part of the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.hash; # OUTPUT: «Map.new((:apples(:red(2))))␤»"},{"d":"Defined as:\n\n    method list(Capture:D:)\n\nReturns the positional part of the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.list;                                      # OUTPUT: «(2 3 5)␤»","n":"list","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method elems(Capture:D: --> Int:D)\n\nReturns the number of positional elements in the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.elems;                                  # OUTPUT: «3␤»","n":"elems"},{"n":"Capture","d":"Defined as:\n\n    method Capture(Capture:D: --> Capture:D)\n\nReturns itself, i.e. the invocant.\n\n    say \\(1,2,3, apples => 2).Capture; # OUTPUT: «\\(1, 2, 3, :apples(2))␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"FLATTENABLE_LIST","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"FLATTENABLE_HASH"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Any"]},{"k":"e","t":"Signal","n":"SIGXCPU"},{"b":"C","t":"Stringy","d":"TITLE\nrole Stringy\n\nSUBTITLE\nString or object that can act as a string\n\n    role Stringy { ... }\n\nCommon role for string types (such as Str).","n":"Stringy","k":"ro","mro":[]},{"n":"&append","t":"Sub","k":"v"},{"s":{"p":["\\a","|elems is raw"],"r":"Mu"},"m":1,"k":"s","n":"append"},{"k":"e","n":"SOCK_RDM","t":"SocketType"},{"t":"SocketType","n":"SocketType","k":"e"},{"t":"SocketType","n":"SocketType::SOCK_DGRAM","k":"e"},{"n":"SocketType::SOCK_STREAM","t":"SocketType","k":"e"},{"k":"e","n":"SocketType::SOCK_RAW","t":"SocketType"},{"n":"SocketType::SOCK_SEQPACKET","t":"SocketType","k":"e"},{"k":"e","n":"SocketType::SOCK_RDM","t":"SocketType"},{"k":"e","n":"SocketType::SOCK_PACKET","t":"SocketType"},{"n":"SocketType::SOCK_MAX","t":"SocketType","k":"e"},{"k":"v","n":"&comb","t":"Sub"},{"n":"comb","s":{"p":["Regex $matcher","Cool $input","$limit = *"],"r":"Mu"},"m":1,"k":"s"},{"n":"comb","m":1,"k":"s","s":{"r":"Mu","p":["Str $matcher","Cool $input","$limit = *"]}},{"n":"comb","s":{"p":["Int:D $size","Cool $input","$limit = *"],"r":"Mu"},"k":"s","m":1},{"n":"Pair","a":[{"n":"$.key","t":"Mu","k":"v"},{"n":"$.value","t":"Mu","k":"v"},{"t":"Mu","n":"$!WHICH","k":"v"}],"t":"Pair","d":"TITLE\nclass Pair\n\nSUBTITLE\nKey/value pair\n\n    class Pair does Associative {}\n\nConsists of two parts, a key and a value. Pairs can be seen as the atomic\nunits in Hashes, and they are also used in conjunction with named arguments\nand parameters.\n\n     There are many syntaxes for creating Pairs:\n\n    Pair.new('key', 'value'); # The canonical way\n    'key' => 'value';         # this...\n    :key<value>;              # ...means the same as this\n    :key<value1 value2>;      # But this is  key => <value1 value2>\n    :foo(127);                # short for  foo => 127\n    :127foo;                  # the same   foo => 127\n\nNote that last form supports Non-ASCII numerics as well:\n\n    # use MATHEMATICAL DOUBLE-STRUCK DIGIT THREE\n    say (:\uD835\uDFDBmath-three);         # OUTPUT: «math-three => 3␤»\n\nYou can also use an identifier-like literal as key; this will not need the\nquotes as long as it follows the syntax of ordinary identifiers:\n\n    (foo => 127)              # the same   foo => 127\n\nVariants of this are\n\n    :key;                     # same as   key => True\n    :!key;                    # same as   key => False\n\nAnd this other variant, to be used in routine invocation\n\n    sub colon-pair( :$key-value ) {\n        say $key-value;\n    }\n    my $key-value = 'value';\n    colon-pair( :$key-value );               # OUTPUT: «value␤»\n    colon-pair( key-value => $key-value );   # OUTPUT: «value␤»\n\n\n Colon pairs can be chained without a comma to create a List of Pairs.\nDepending on context you may have to be explicit when assigning colon\nlists.\n\n    sub s(*%h){ say %h.perl };\n    s :a1:b2;\n    # OUTPUT: «{:a1, :b2}␤»\n\n    my $manna = :a1:b2:c3;\n    say $manna.^name;\n    # OUTPUT: «Pair␤»\n\n    $manna = (:a1:b2:c3);\n    say $manna.^name;\n    # OUTPUT: «List␤»\n\nAny variable can be turned into a Pair of its name and its value.\n\n    my $bar = 10;\n    my $p   = :$bar;\n    say $p; # OUTPUT: «bar => 10␤»\n\nIt is worth noting that when assigning a Scalar as value of a Pair the\nvalue holds the container of the value itself. This means that it is\npossible to change the value from outside of the Pair itself:\n\n    my $v = 'value A';\n    my $pair = a => $v;\n    $pair.say;  # OUTPUT: «a => value A␤»\n\n    $v = 'value B';\n    $pair.say;  # OUTPUT: «a => value B␤»\n\n\nPlease also note that this behavior is totally unrelated to the way used to\nbuild the Pair itself (i.e., explicit usage of new, use of colon, fat\narrow), as well as if the Pair is bound to a variable.\n\nIt is possible to change the above behavior forcing the Pair to remove the\nscalar container and to hold the effective value itself via the method\nfreeze:\n\n    my $v = 'value B';\n    my $pair = a => $v;\n    $pair.freeze;\n    $v = 'value C';\n    $pair.say; # OUTPUT: «a => value B␤»\n\n\nAs Pair implements Associative role, its value can be accessed using\nAssociative subscription operator, however, due to Pair's singular nature,\nthe pair's value will be only returned for the pair's key. Nil object will\nbe returned for any other key. Subscript adverbs such as :exists can be\nused on Pair.\n\n    my $pair = a => 5;\n    say $pair<a>;           # OUTPUT: «5␤»\n    say $pair<a>:exists;    # OUTPUT: «True␤»\n    say $pair<no-such-key>; # OUTPUT: «Nil␤»\n\n\n","mro":["Associative","Any"],"k":"c","m":[{"d":"Defined as:\n\n    multi method new(Pair: Mu  $key, Mu  $value)\n    multi method new(Pair: Mu :$key, Mu :$value)\n\nConstructs a new Pair object.","n":"new","k":"m","m":1,"s":{"p":["Cool:D \\key","Mu \\value","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    multi method new(Pair: Mu  $key, Mu  $value)\n    multi method new(Pair: Mu :$key, Mu :$value)\n\nConstructs a new Pair object.","n":"new","k":"m","m":1,"s":{"p":["Mu \\key","Mu \\value","*%_"],"r":"Mu"}},{"s":{"p":["Mu :$key!","Mu :$value!","*%_"],"r":"Mu"},"k":"m","m":1,"n":"new","d":"Defined as:\n\n    multi method new(Pair: Mu  $key, Mu  $value)\n    multi method new(Pair: Mu :$key, Mu :$value)\n\nConstructs a new Pair object."},{"d":"Defined as:\n\n    method Pair()\n\nReturns the invocant Pair object.\n\n    my $pair = eggs => 3;\n    say $pair.Pair === $pair;                         # OUTPUT: «True␤»","n":"Pair","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"antipair","d":"Defined as:\n\n    method antipair(--> Pair:D)\n\nReturns a new Pair object with key and value exchanged.\n\n    my $p = (6 => 'Perl').antipair;\n    say $p.key;         # OUTPUT: «Perl␤»\n    say $p.value;       # OUTPUT: «6␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"freeze","d":"Defined as:\n\n    method freeze(Pair:D:)\n\nMakes the value of the Pair read-only, by removing it from its Scalar\ncontainer, and returns it.\n\n    my $str = \"apple\";\n    my $p = Pair.new('key', $str);\n    $p.value = \"orange\";              # this works as expected\n    $p.say;                           # OUTPUT: «key => orange␤»\n    $p.freeze.say;                    # OUTPUT: «orange␤»\n    $p.value = \"a new apple\";         # Fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Str (apple)␤»\n\nNOTE: this method is deprecated as of 6.d language version. Instead, create\na new Pair, with a decontainerized key/value.\n\n    $p.=Map.=head.say;                                    # OUTPUT: «orange␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"iterator","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["$format = \"\\%s\\t\\%s\"","*%_"],"r":"Mu"},"k":"m","m":0,"n":"fmt","d":"Defined as:\n\n    multi method fmt(Pair:D: Str:D $format --> Str:D)\n\nTakes a format string, and returns a string the key and value parts of the\nPair formatted. Here's an example:\n\n    my $pair = :Earth(1);\n    say $pair.fmt(\"%s is %.3f AU away from the sun\")\n    # OUTPUT: «Earth is 1.000 AU away from the sun␤»\n\nFor more about format strings, see sprintf."},{"n":"FLATTENABLE_LIST","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"FLATTENABLE_HASH"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method key(Pair:D:)\n\nReturns the key part of the Pair.\n\n    my $p = (Perl => 6);\n    say $p.key; # OUTPUT: «Perl␤»","n":"key"},{"d":"Defined as:\n\n    multi method value(Pair:D:) is rw\n\nReturns the value part of the Pair.\n\n    my $p = (Perl => 6);\n    say $p.value; # OUTPUT: «6␤»\n\n  infix cmp\n\nDefined as:\n\n    multi sub infix:<cmp>(Pair:D, Pair:D)\n\nThe type-agnostic comparator; compares two Pairs. Compares first their key\nparts, and then compares the value parts if the keys are equal.\n\n    my $a = (Apple => 1);\n    my $b = (Apple => 2);\n    say $a cmp $b; # OUTPUT: «Less␤»","n":"value","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"b":"A"},{"t":"Sub+{Precedence}","n":"&infix:<or>","k":"v"},{"s":{"r":"Mu","p":["Mu $x = Bool::False"]},"k":"s","m":1,"n":"infix:<or>"},{"n":"infix:<or>","s":{"r":"Mu","p":["Mu \\a","&b"]},"m":1,"k":"s"},{"s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<or>"},{"t":"Sub+{Precedence}","n":"&infix:<coll>","k":"v"},{"n":"infix:<coll>","s":{"r":"Order:D","p":["Str:D \\a","Str:D \\b"]},"m":1,"k":"s"},{"s":{"r":"Order:D","p":["Cool:D \\a","Cool:D \\b"]},"k":"s","m":1,"n":"infix:<coll>"},{"n":"infix:<coll>","s":{"p":["Pair:D \\a","Pair:D \\b"],"r":"Order:D"},"k":"s","m":1},{"t":"Sub","n":"&ord","k":"v"},{"s":{"r":"Mu","p":["Cool $s"]},"m":1,"k":"s","n":"ord"},{"b":"C","mro":["Real","Numeric","Cool"],"k":"c","n":"\uD835\uDC52","t":"Num"},{"n":"&spurt","t":"Sub","k":"v"},{"n":"spurt","s":{"p":["IO::Handle:D $fh","|c is raw"],"r":"Mu"},"m":1,"k":"s"},{"n":"spurt","s":{"p":["$path","|c is raw"],"r":"Mu"},"k":"s","m":1},{"k":"v","n":"&infix:<×>","t":"Sub+{is-pure}+{Precedence}"},{"m":1,"k":"s","s":{"p":["$x = 1"],"r":"Mu"},"n":"infix:<*>"},{"n":"infix:<*>","k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]}},{"n":"infix:<*>","s":{"r":"Mu","p":["Real \\a","Real \\b"]},"k":"s","m":1},{"n":"infix:<*>","m":1,"k":"s","s":{"r":"Int:D","p":["Int:D \\a","Int:D \\b"]}},{"s":{"r":"int","p":["int $a","int $b"]},"k":"s","m":1,"n":"infix:<*>"},{"n":"infix:<*>","k":"s","m":1,"s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]}},{"n":"infix:<*>","s":{"r":"num","p":["num $a","num $b"]},"k":"s","m":1},{"n":"infix:<*>","s":{"p":["Range:D \\r","Real:D \\v"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<*>","s":{"r":"Mu","p":["Real:D \\v","Range:D \\r"]},"k":"s","m":1},{"s":{"p":["Rational:D \\a","Rational:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<*>"},{"s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<*>"},{"s":{"r":"Mu","p":["Int:D \\a","Rational:D \\b"]},"m":1,"k":"s","n":"infix:<*>"},{"n":"infix:<*>","k":"s","m":1,"s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Complex:D"}},{"n":"infix:<*>","k":"s","m":1,"s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Complex:D"}},{"k":"s","m":1,"s":{"r":"Complex:D","p":["Num(Real) \\a","Complex:D \\b"]},"n":"infix:<*>"},{"n":"&circumfix:<[ ]>","t":"Sub","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":[]},"n":"circumfix:<[ ]>"},{"m":1,"k":"s","s":{"p":["Iterable:D \\iterable"],"r":"Mu"},"n":"circumfix:<[ ]>"},{"n":"circumfix:<[ ]>","k":"s","m":1,"s":{"r":"Mu","p":["Mu \\x"]}},{"b":"C","mro":["Cool"],"m":[{"n":"new","d":"method new(*@)\n\nReturns Nil","s":{"r":"Nil","p":["*@","*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Numeric","d":"method Numeric()\n\nWarns the user that they tried to numify a Nil."},{"d":"method Str()\n\nWarns the user that they tried to stringify a Nil.","n":"Str","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Nil","p":["*%_"]},"n":"sink"},{"s":{"p":["|"],"r":"Nil"},"m":0,"k":"m","n":"AT-POS"},{"n":"AT-KEY","m":0,"k":"m","s":{"r":"Nil","p":["|"]}},{"n":"BIND-POS","m":0,"k":"m","s":{"r":"Mu","p":["|"]}},{"s":{"r":"Mu","p":["|"]},"k":"m","m":0,"n":"BIND-KEY"},{"n":"ASSIGN-POS","k":"m","m":0,"s":{"r":"Mu","p":["|"]}},{"n":"ASSIGN-KEY","m":0,"k":"m","s":{"p":["|"],"r":"Mu"}},{"s":{"r":"Mu","p":["|"]},"m":0,"k":"m","n":"STORE"},{"k":"m","m":0,"s":{"p":["|"],"r":"Mu"},"d":"method push(*@)\n\nWarns the user that they tried to push onto a Nil.","n":"push"},{"n":"append","d":"method append(*@)\n\nWarns the user that they tried to append onto a Nil.","s":{"r":"Mu","p":["|"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["|"]},"d":"method unshift(*@)\n\nWarns the user that they tried to unshift onto a Nil.","n":"unshift"},{"n":"prepend","d":"method prepend(*@)\n\nWarns the user that they tried to prepend onto a Nil.","s":{"p":["|"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Nil","p":["|"]},"k":"m","m":0,"n":"FALLBACK","d":"method FALLBACK(| --> Nil) {}\n\nThe fallback method takes any arguments and always returns a Nil."},{"n":"ords","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"chrs"},{"n":"chop","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"chomp","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"iterator","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"Set"},{"n":"SetHash","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"Bag","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BagHash","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"Mix","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"MixHash"}],"k":"c","n":"Nil","d":"TITLE\nclass Nil\n\nSUBTITLE\nAbsence of a value or a benign failure\n\n    class Nil is Cool { }\n\nThe value Nil may be used to fill a spot where a value would normally go,\nand in so doing, explicitly indicate that no value is present. It may also\nbe used as a cheaper and less explosive alternative to a Failure. (In fact,\nclass Failure is derived from Nil, so smartmatching Nil will also match\nFailure.)\n\nThe class Nil is the same exact thing as its only possible value, Nil.\n\n    say Nil === Nil.new;        # OUTPUT: «True␤»\n\nAlong with Failure, Nil and its sub classes may always be returned from a\nroutine even when the routine specifies a particular return type. It may\nalso be returned regardless of the definedness of the return type, however,\nNil is considered undefined for all other purposes.\n\n    sub a( --> Int:D ) { return Nil }\n    a().say;                    # OUTPUT: «Nil␤»\n\nNil is what is returned from empty routines or closure, or routines that\nuse a bare return statement.\n\n    sub a { }; a().say;         # OUTPUT: «Nil␤»\n    sub b { return }; b().say;  # OUTPUT: «Nil␤»\n    say (if 1 { });             # OUTPUT: «Nil␤»\n    { ; }().say;                # OUTPUT: «Nil␤»\n    say EVAL \"\";                # OUTPUT: «Nil␤»\n\nIn a list, Nil takes the space of one value. Iterating a Nil behaves like\niteration of any non-iterable value, producing a sequence of one Nil. (When\nyou need the other meaning, the special value Empty is available to take no\nspaces when inserted into list, and to return no values when iterated.)\n\n    (1, Nil, 3).elems.say;      # OUTPUT: «3␤»\n    (for Nil { $_ }).perl.say;  # OUTPUT: «(Nil,)␤»\n\nAny method call on Nil of a method that does not exist, and consequently,\nany subscripting operation, will succeed and return Nil.\n\n    say Nil.ITotallyJustMadeThisUp;  # OUTPUT: «Nil␤»\n    say (Nil)[100];                  # OUTPUT: «Nil␤»\n    say (Nil){100};                  # OUTPUT: «Nil␤»\n\n When assigned to a container, the Nil value (but not any subclass of Nil)\nwill attempt to revert the container to its default value; if no such\ndefault is declared, Raku assumes Any.\n\nSince a hash assignment expects two elements, use Empty not Nil, e.g.\n\n    my %h = 'a'..'b' Z=> 1..*;\n    # stuff happens\n    %h = Empty; # %h = Nil will generate an error\n\nHowever, if the container type is constrained with :D, assigning Nil to it\nwill immediately throw an exception. (In contrast, an instantiated Failure\nmatches :D because it's a definite value, but will fail to match the actual\nnominal type unless it happens to be a parent class of Failure.) Native\ntypes can not have default values nor hold a type object. Assigning Nil to\na native type container will fail with a runtime error.\n\n    my Int $x = 42;\n    $x = Nil;\n    $x.say;                     # OUTPUT: «(Int)␤»\n\n    sub f( --> Int:D ){ Nil };  # this definedness constraint is ignored\n    my Int:D $i = f;            # this definedness constraint is not ignored, so throws\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)»\n\n    sub g( --> Int:D ){ fail \"oops\" }; # this definedness constraint is ignored\n    my Any:D $h = g;                   # failure object matches Any:D, so is assigned\n\nbut\n\n    my Int:D $j = g;\n    # It will throw both exceptions:\n    # Earlier failure:\n    #  oops\n    #   in sub g at <unknown file> line 1\n    #   in block <unit> at <unknown file> line 1\n    #\n    # Final error:\n    #  Type check failed in assignment to $j; expected Int:D but got Failure (Failure.new(exception...)\n    #   in block <unit> at <unknown file> line 1\n\n\nBecause an untyped variable is type Any, assigning a Nil to one will result\nin an (Any) type object.\n\n    my $x = Nil;\n    $x.say;          # OUTPUT: «(Any)␤»\n    my Int $y = $x;  # will throw an exception\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)␤»\n\nIf you are looking for a variable which transforms objects into type\nobjects when said variable appears on the right-hand side, you can type the\ncontainer as Nil.\n\n    my Nil $x;\n    my Str $s = $x;\n    $s.say;          # OUTPUT: «(Str)␤»\n\nThere is an important exception to this transforms-into-type-object rule:\nassigning Nil to a variable which has a default will restore that default.\n\n    my Int $x is default(42) = -1;\n    my $y = 1;\n    for $x, $y -> $val is rw { $val = Nil unless $val > 0 }\n    $x.say;          # OUTPUT: «42␤»\n\n","t":"Nil"},{"t":"Sub","n":"&postfix:<⚛++>","k":"v"},{"n":"postfix:<⚛++>","k":"s","m":1,"s":{"p":["atomicint $target is rw"],"r":"atomicint"}},{"t":"Sub","n":"&reverse","k":"v"},{"n":"reverse","m":1,"k":"s","s":{"r":"Mu","p":["@a"]}},{"n":"reverse","s":{"p":["+@a"],"r":"Mu"},"m":1,"k":"s"},{"k":"v","n":"&infix:<^..^>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":["$min","$max"],"r":"Mu"},"k":"s","m":1,"n":"infix:<^..^>"},{"t":"num64","n":"num64","k":"n"},{"k":"v","n":"&postcircumfix:<[ ]>","t":"Sub+{is-nodal}+{Precedence}+{is-nodal}"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Any:U $type","|c is raw"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","int $pos"]},"n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":["\\SELF","int $pos","Mu \\assignee"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","int $pos","Mu :$BIND! is raw"]}},{"s":{"r":"Mu","p":["\\SELF","int $pos",":$delete!"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","int $pos",":$delete!","*%other"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["\\SELF","int $pos",":$exists!"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","int $pos",":$exists!","*%other"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["\\SELF","int $pos",":$kv!","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":["\\SELF","int $pos",":$p!","*%other"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","int $pos",":$k!","*%other"]},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","int $pos",":$v!","*%other"]},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Int:D $pos"]},"n":"postcircumfix:<[ ]>"},{"s":{"p":["\\SELF","Int:D $pos","Mu \\assignee"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":["\\SELF","Int:D $pos","Mu :$BIND! is raw"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Int:D $pos",":$delete!"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Int:D $pos",":$delete!","*%other"],"r":"Mu"}},{"s":{"r":"Mu","p":["\\SELF","Int:D $pos",":$exists!"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"s":{"p":["\\SELF","Int:D $pos",":$exists!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Int:D $pos",":$kv!","*%other"]}},{"s":{"p":["\\SELF","Int:D $pos",":$p!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Int:D $pos",":$k!","*%other"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["\\SELF","Int:D $pos",":$v!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Any:D \\pos"],"r":"Mu"},"k":"s","m":1},{"s":{"r":"Mu","p":["\\SELF","Any:D \\pos","Mu \\assignee"]},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Any:D \\pos","Mu :$BIND! is raw"]},"n":"postcircumfix:<[ ]>"},{"m":1,"k":"s","s":{"p":["\\SELF","Any:D \\pos",":$delete!"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Any:D \\pos",":$delete!","*%other"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Any:D \\pos",":$exists!"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Any:D \\pos",":$exists!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Any:D \\pos",":$kv!","*%other"],"r":"Mu"}},{"s":{"p":["\\SELF","Any:D \\pos",":$p!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"k":"s","m":1,"s":{"p":["\\SELF","Any:D \\pos",":$k!","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Any:D \\pos",":$v!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos"]}},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos","Mu \\val"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["\\SELF","Iterable:D \\pos",":$BIND!"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos",":$delete!","*%other"]},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"p":["\\SELF","Iterable:D \\pos",":$exists!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos",":$kv!","*%other"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos",":$p!","*%other"]},"n":"postcircumfix:<[ ]>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos",":$k!","*%other"]},"n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":["\\SELF","Iterable:D \\pos",":$v!","*%other"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Callable:D $block"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Callable:D $block","Mu \\assignee"]},"m":1,"k":"s"},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Callable:D $block",":$BIND!"]}},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF","Callable:D $block",":$delete!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Callable:D $block",":$exists!","*%other"]},"k":"s","m":1},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Callable:D $block",":$kv!","*%other"]}},{"k":"s","m":1,"s":{"p":["\\SELF","Callable:D $block",":$p!","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Callable:D $block",":$k!","*%other"]},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","Callable:D $block",":$v!","*%other"]},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Whatever:D $"]}},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","Whatever:D $","Mu \\assignee"]},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"p":["\\SELF","Whatever:D $",":$BIND!"],"r":"Mu"}},{"s":{"p":["\\SELF","Whatever:D $",":$delete!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"s":{"r":"Mu","p":["\\SELF","Whatever:D $",":$exists!","*%other"]},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"s":{"p":["\\SELF","Whatever:D $",":$kv!","*%other"],"r":"Mu"},"k":"s","m":1,"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF","Whatever:D $",":$p!","*%other"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["\\SELF","Whatever:D $",":$k!","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF","Whatever:D $",":$v!","*%other"]},"k":"s","m":1},{"s":{"p":["\\SELF","HyperWhatever:D $","*%adv"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[ ]>"},{"k":"s","m":1,"s":{"r":"Mu","p":["\\SELF","HyperWhatever:D $","Mu \\assignee"]},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["\\SELF",":$BIND!"]},"m":1,"k":"s"},{"n":"postcircumfix:<[ ]>","s":{"p":["\\SELF",":$delete!","*%other"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"p":["\\SELF",":$exists!","*%other"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["\\SELF",":$kv!","*%other"]},"n":"postcircumfix:<[ ]>"},{"m":1,"k":"s","s":{"p":["\\SELF",":$p!","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","k":"s","m":1,"s":{"p":["\\SELF",":$k!","*%other"],"r":"Mu"}},{"n":"postcircumfix:<[ ]>","m":1,"k":"s","s":{"p":["\\SELF",":$v!","*%other"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["\\SELF","*%other"],"r":"Mu"},"n":"postcircumfix:<[ ]>"},{"n":"postcircumfix:<[ ]>","s":{"r":"Mu","p":["array:D \\SELF","Range:D \\range"]},"m":1,"k":"s"},{"t":"Sub","n":"&keys","k":"v"},{"k":"s","m":1,"s":{"p":["$x"],"r":"Mu"},"n":"keys"},{"k":"v","n":"&pair","t":"Sub+{is-pure}"},{"s":{"r":"Mu","p":["Mu \\key","Mu \\value"]},"k":"s","m":1,"n":"pair"},{"k":"v","n":"&indir","t":"Sub"},{"n":"indir","s":{"r":"Mu","p":["$path","&what",":$test!"]},"m":1,"k":"s"},{"n":"indir","s":{"r":"Mu","p":["$path","&what",":$d = Bool::True",":$r",":$w",":$x"]},"m":1,"k":"s"},{"k":"v","n":"&move","t":"Sub"},{"s":{"p":["$from","$to",":$createonly"],"r":"Mu"},"m":1,"k":"s","n":"move"},{"k":"v","n":"&infix:«+>»","t":"Sub+{is-pure}"},{"k":"s","m":1,"s":{"r":"Mu","p":[]},"n":"infix:«+>»"},{"n":"infix:«+>»","s":{"r":"Mu","p":["$x"]},"m":1,"k":"s"},{"s":{"p":["$x","$y"],"r":"Mu"},"k":"s","m":1,"n":"infix:«+>»"},{"n":"infix:«+>»","k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"}},{"n":"infix:«+>»","s":{"r":"int","p":["int $a","int $b"]},"m":1,"k":"s"},{"n":"PF_LOCAL","t":"ProtocolFamily","k":"e"},{"n":"&prefix:<--⚛>","t":"Sub","k":"v"},{"n":"prefix:<--⚛>","m":1,"k":"s","s":{"p":["atomicint $target is rw"],"r":"atomicint"}},{"k":"e","t":"Signal","n":"SIGHUP"},{"n":"Semaphore","d":"TITLE\nclass Semaphore\n\nSUBTITLE\nControl access to shared resources by multiple threads\n\n    class Semaphore { }\n\nProtect your shared code, data or device access using semaphores. An\nexample is a printer manager managing a pool of printers without the need\nof storing print jobs when all printers are occupied. The next job is just\nblocked until a printer becomes available.\n\n    class print-manager {\n      has Array $!printers;\n      has Semaphore $!print-control;\n\n      method BUILD( Int:D :$nbr-printers ) {\n        for ^$nbr-printers -> $pc {\n          $!printers[$pc] = { :name{\"printer-$pc\"} };\n        }\n\n        $!print-control .= new($nbr-printers);\n      }\n\n      method find-available-printer-and-print-it($job) { say \"Is printed!\"; }\n\n      method print( $print-job ) {\n        $!print-control.acquire;\n\n        self.find-available-printer-and-print-it($print-job);\n\n        $!print-control.release;\n      }\n    }\n\nAnother example is a protection around code updating sensitive data. In\nsuch a case the semaphore is typically initialized to 1.\n\nIt is important to have a release on every exit of your program! While this\nis obvious, it is easy to fall in traps such as throwing an exception\ncaused by some event. When the program dies there is no problem. When the\nexception is caught your program might eventually come back to the acquire\nmethod and will hang indefinitely.\n\n","t":"Semaphore","mro":["Any"],"k":"c","m":[{"n":"new","d":"method new( int $permits )\n\nInitialize the semaphore with the number of permitted accesses. E.g. when\nset to 2, program threads can pass the acquire method twice until it blocks\non the third time acquire is called.","s":{"p":["int $permits","*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method acquire()\n\nAcquire access. When other threads have called the method before and the\nnumber of permits are used up, the process blocks until threads passed\nbefore releases the semaphore.","n":"acquire"},{"m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]},"d":"method try_acquire(--> Bool)\n\nSame as acquire but will not block. Instead it returns True if access is\npermitted or False otherwise.","n":"try_acquire"},{"d":"method release()\n\nRelease the semaphore raising the number of permissions. Any blocked thread\nwill get access after that.","n":"release","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"b":"A"},{"k":"v","n":"&infix:<⊖>","t":"Sub+{is-pure}+{Precedence}"},{"k":"s","m":1,"s":{"r":"Mu","p":[]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","k":"s","m":1,"s":{"p":["QuantHash:D \\a"],"r":"Mu"}},{"k":"s","m":1,"s":{"p":["\\a"],"r":"Mu"},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"p":["Setty:D \\a","Setty:D \\b"],"r":"Mu"},"n":"infix:<(^)>"},{"n":"infix:<(^)>","s":{"p":["Setty:D \\a","Mixy:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(^)>","s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(^)>"},{"s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Mu"},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a","Mixy:D \\b"]},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]},"n":"infix:<(^)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a","Setty:D \\b"]},"n":"infix:<(^)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Map:D \\a","Map:D \\b"]},"n":"infix:<(^)>"},{"n":"infix:<(^)>","m":1,"k":"s","s":{"p":["Failure:D \\a","$"],"r":"Mu"}},{"m":1,"k":"s","s":{"r":"Mu","p":["$","Failure:D \\b"]},"n":"infix:<(^)>"},{"s":{"p":["\\a","\\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(^)>"},{"n":"infix:<(^)>","m":1,"k":"s","s":{"r":"Mu","p":["**@p"]}},{"t":"Sub","n":"&infix:<≅>","k":"v"},{"n":"infix:<=~=>","m":1,"k":"s","s":{"p":["$?"],"r":"Mu"}},{"n":"infix:<=~=>","k":"s","m":1,"s":{"p":["\\a","\\b",":$tolerance = { ... }"],"r":"Mu"}},{"s":{"r":"Mu","p":["Inf","Inf"]},"k":"s","m":1,"n":"infix:<≅>"},{"m":1,"k":"s","s":{"p":["-Inf","-Inf"],"r":"Mu"},"n":"infix:<≅>"},{"s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:<≅>"},{"n":"infix:<≅>","s":{"p":["Complex:D \\a","Num(Real) \\b"],"r":"Bool:D"},"k":"s","m":1},{"n":"infix:<≅>","s":{"p":["Num(Real) \\a","Complex:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"n":"&infix:<and>","t":"Sub+{Precedence}","k":"v"},{"s":{"p":["Mu $x = Bool::True"],"r":"Mu"},"k":"s","m":1,"n":"infix:<and>"},{"n":"infix:<and>","k":"s","m":1,"s":{"r":"Mu","p":["Mu \\a","&b"]}},{"n":"infix:<and>","m":1,"k":"s","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"}},{"t":"Sub","n":"&rotate","k":"v"},{"n":"rotate","k":"s","m":1,"s":{"r":"Mu","p":["@a"]}},{"m":1,"k":"s","s":{"r":"Mu","p":["@a","Int:D $n"]},"n":"rotate"},{"k":"v","n":"&infix:«(>)»","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:«(>)»","m":1,"k":"s","s":{"p":["\\a","\\b"],"r":"Bool:D"}},{"k":"e","n":"SIGXFSZ","t":"Signal"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(|)>","k":"v"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"p":[],"r":"Mu"}},{"s":{"r":"Mu","p":["QuantHash:D \\a"]},"m":1,"k":"s","n":"infix:<(|)>"},{"n":"infix:<(|)>","s":{"r":"Mu","p":["\\a"]},"m":1,"k":"s"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"r":"Mu","p":["Setty:D \\a","Setty:D \\b"]}},{"n":"infix:<(|)>","s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mixy:D \\a","Mixy:D \\b"]},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mixy:D \\a","Baggy:D \\b"]},"n":"infix:<(|)>"},{"n":"infix:<(|)>","s":{"p":["Mixy:D \\a","Setty:D \\b"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(|)>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]},"n":"infix:<(|)>"},{"n":"infix:<(|)>","m":1,"k":"s","s":{"p":["Baggy:D \\a","Setty:D \\b"],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["Map:D \\a","Map:D \\b"]},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"p":["Iterable:D \\a","Iterable:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"s":{"r":"Mu","p":["Failure:D \\a","$"]},"k":"s","m":1,"n":"infix:<(|)>"},{"m":1,"k":"s","s":{"p":["$","Failure:D \\b"],"r":"Mu"},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"},"n":"infix:<(|)>"},{"k":"s","m":1,"s":{"p":["**@p"],"r":"Mu"},"n":"infix:<(|)>"},{"k":"e","n":"Endian","t":"Endian"},{"n":"Endian::BigEndian","t":"Endian","k":"e"},{"t":"Endian","n":"Endian::NativeEndian","k":"e"},{"k":"e","t":"Endian","n":"Endian::LittleEndian"},{"k":"v","n":"&infix:<⚛-=>","t":"Sub"},{"n":"infix:<⚛-=>","s":{"p":["atomicint $target is rw","int $add"],"r":"atomicint"},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["atomicint $target is rw","Int:D $add"],"r":"atomicint"},"n":"infix:<⚛-=>"},{"s":{"r":"atomicint","p":["atomicint $target is rw","$add"]},"m":1,"k":"s","n":"infix:<⚛-=>"},{"n":"Proxy","d":"TITLE\nclass Proxy\n\nSUBTITLE\nItem container with custom storage and retrieval\n\n    class Proxy {}\n\nA Proxy is an object that allows you to set a hook that executes whenever a\nvalue is retrieved from a container (FETCH) or when it is set (STORE).\nPlease note that Proxy can introduce mutability at places where it would\nbreak behavior, e.g. in Hash keys.\n\nTo create a container that returns twice what was stored in it, you do\nsomething like this:\n\n    sub double() is rw {\n        my $storage = 0;\n        Proxy.new(\n            FETCH => method ()     { $storage * 2    },\n            STORE => method ($new) { $storage = $new },\n        )\n     }\n     my $doubled := double();\n     $doubled = 4;\n     say $doubled;       # OUTPUT: «8␤»\n\n","t":"Proxy","mro":["Any"],"k":"c","b":"A"},{"b":"C","m":[{"n":"Capture","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"Num","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"Bridge"},{"n":"Range","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"Int"},{"n":"Rat","k":"m","m":0,"s":{"p":["Real $epsilon = 1e-06",":$fat","*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["Real $epsilon = 1e-06","*%_"]},"n":"FatRat"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"succ"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pred"},{"n":"isNaN","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"abs"},{"n":"log","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":1,"s":{"p":["Num \\base","*%_"],"r":"Mu"},"n":"log"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":1,"n":"log"},{"s":{"p":["Real $base","*%_"],"r":"Mu"},"m":1,"k":"m","n":"log"},{"m":1,"k":"m","s":{"r":"Mu","p":["Cool $base","*%_"]},"n":"log"},{"s":{"p":["Numeric $base","*%_"],"r":"Mu"},"k":"m","m":1,"n":"log"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"sqrt"},{"n":"rand","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"ceiling"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"floor"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"sin"},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"asin"},{"s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m","n":"cos"},{"n":"acos","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"n":"tan"},{"k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"},"n":"atan"},{"n":"sec","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"asec"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"cosec"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"acosec"},{"n":"cotan","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"acotan"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"sinh"},{"n":"asinh","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"cosh","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"n":"acosh","s":{"r":"Mu","p":["*%_"]},"k":"m","m":1},{"n":"tanh","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"n":"atanh"},{"n":"atanh","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"sech"},{"n":"asech","s":{"r":"Mu","p":["*%_"]},"m":1,"k":"m"},{"m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"cosech"},{"n":"acosech","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"n":"cotanh","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"n":"acotanh","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"n":"is-prime","s":{"p":["*%_"],"r":"Bool:D"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"narrow"}],"k":"c","mro":["Real","Numeric","Cool"],"t":"Num","d":"TITLE\nclass Num\n\nSUBTITLE\nFloating-point number\n\n    class Num is Cool does Real { }\n\nA Num object stores a floating-point number. It is immutable. On most\nplatforms, it's an IEEE 754 64-bit floating point numbers, aka \"double\nprecision\".\n\n \n\n  Inf\n\nThe value Inf is an instance of Num and represents value that's too large\nto represent in 64-bit double-precision floating point number (roughly,\nabove 1.7976931348623158e308 for positive Inf and below\n-1.7976931348623157e308 for negative Inf) as well as returned from certain\noperations as defined by the IEEE 754-2008 standard.\n\n    say 2e300 ** 2e300; # OUTPUT: «Inf␤»\n    say (-1/0).Num;     # OUTPUT: «-Inf␤»\n\nThe ∞ U+221E Unicode character can be used instead of the word Inf and can\nbe handy when Inf would otherwise require an unspace, such as when writing\nComplex numbers:\n\n    say Inf+Inf\\i; # Backslash (unspace) before `i` required\n    say ∞+∞i;      # No backslash is needed\n\nNote that there are just two infinities (positive and negative), so even if\nan operation that would instinctively give a \"larger\" infinity is\nperformed, the result in still an infinity of the original magnitude. The\ninfinities can be compared, operated and used as an argument as if they\nwere simply a number that's too big to represent or to signify \"without\nbounds\" or limits:\n\n    say ∞²;                       # OUTPUT: «Inf␤»\n    say 42 + Inf === ∞;           # OUTPUT: «True␤»\n    say atan ∞;                   # OUTPUT: «1.5707963267949␤»\n    say -∞ < 42 < ∞;              # OUTPUT: «True␤»\n    my  $l := 1, 2, 4, 8 ... Inf; # Infinite sequence (no limits)\n\nIn some cases, it's used as an implicit value to represent \"all of them\"\n\n    say \"House of M\".comb(3,Inf).join(\"←X→\");\n    # OUTPUT: «Hou←X→se ←X→of ←X→M␤»\n\nIn the example above, Inf can be eliminated, since it's the default value\nfor the second argument of .comb, used to indicate how many parts should be\nreturned.\n\nDivision of an infinity by another infinity results in a NaN:\n\n    say ∞/∞;             # OUTPUT: «NaN␤»\n\n  NaN\n\nThe value NaN is an instance of Num and represents a floating point\nnot-a-number value, which is returned from some routines where a concrete\nnumber as the answer is not defined, but a Numeric value is still\nacceptable. NaN is defined and boolifies to True, but is not numerically\nequal to any value (including itself).\n\n    say cos ∞;     # OUTPUT: «NaN␤»\n    say (0/0).Num; # OUTPUT: «NaN␤»\n\nTo test for NaN, use isNaN method or === operator:\n\n    say (0/0).isNaN;       # OUTPUT: «True␤»\n    say (0/0).Num === NaN; # OUTPUT: «True␤»\n\n  method rand\n\n    method rand(Num:D: --> Num)\n\nReturns a pseudo random number between 0 and the invocant.\n\n  sub srand\n\n    sub srand(Int $seed --> Int:D)\n\nSeeds the pseudo random number generator used by Num.rand with the provided\nvalue. Note that srand is called with a platform dependent value when a\nRaku program is started.\n\n  method Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.\n\n  Int\n\n    method Int(Num:D:)\n\nConverts the number to an Int. Fails with X::Numeric::CannotConvert if the\ninvocant is a NaN or Inf/-Inf. No rounding is performed.\n\n  Rat\n\n    method Rat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a Rat with $epsilon precision. If the invocant is a\nInf, -Inf, or a NaN, converts them to a Rat with 0 denominator and 1, -1,\nor 0 numerator, respectively.\n\n  FatRat\n\n    method FatRat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a FatRat with the precision $epsilon. If invocant is\na Inf, -Inf, or a NaN, converts them to a FatRat with 0 denominator and 1,\n-1, or 0 numerator, respectively.","n":"Num"},{"k":"e","n":"SIGTTIN","t":"Signal"},{"t":"PredictiveIterator","d":"TITLE\nrole PredictiveIterator\n\nSUBTITLE\nIterators that can predict number of values\n\nA PredictiveIterator is a special kind of Iterator that can know how many\nvalues it will (still) generate without actually needing to generate those\nvalues.\n\nThe main addition to the API of the Iterator role, is the count-only\nmethod, which should return the number of values the Iterator is still able\nto generate.\n\nThe other addition is the bool-only method, that should return a Bool\nindicating whether the Iterator is still capable of producing values (aka,\nis not exhausted yet). By default, this is the Booleanification of the\nresult of the call to the count-only method.\n\n","n":"PredictiveIterator","m":[{"s":{"p":["*%_"],"r":"Int:D"},"m":0,"k":"m","n":"count-only","d":"Defined as:\n\n    method count-only(--> Int:D) { ... }\n\nIt is expected to return the number of values the iterator can still\nproduce without actually producing them. The returned number must adjust\nitself for items already pulled, so that the method can be called on a\npartially consumed Iterator.\n\nIt will be used in situations where only the number of values of an\niterator is needed, e.g. when the .elems method is called.\n\nImportant: it's expected the Iterators that implement this method can\nreturn that number without producing any values. In other words, it's\nexpected the user of the class will be able to still pull-one after calling\nthis method, and eventually receive as many values as the return value of\nthis method indicated."},{"m":0,"k":"m","s":{"r":"Bool:D","p":["*%_"]},"d":"Defaults to the Booleanification of the result of calling the count-only\nmethod. If it is possible to have a faster way of finding out whether the\niterator is capable of producing any value, it should be implemented.\n\nDefined as:\n\n    method bool-only(--> Bool:D) { self.count-only.Bool }","n":"bool-only"}],"k":"ro","mro":[],"b":"C"},{"t":"Sub+{Precedence}","n":"&infix:<||>","k":"v"},{"n":"infix:<||>","m":1,"k":"s","s":{"r":"Mu","p":["Mu $x = Bool::False"]}},{"n":"infix:<||>","k":"s","m":1,"s":{"p":["Mu \\a","&b"],"r":"Mu"}},{"s":{"r":"Mu","p":["Mu \\a","Mu \\b"]},"k":"s","m":1,"n":"infix:<||>"},{"k":"v","t":"Sub+{Precedence}","n":"&infix:<notandthen>"},{"n":"infix:<notandthen>","s":{"p":["+\\a is raw"],"r":"Mu"},"k":"s","m":1},{"t":"Signal","n":"SIGIO","k":"e"},{"n":"&list","t":"Sub","k":"v"},{"s":{"r":"Mu","p":["+\\l is raw"]},"m":1,"k":"s","n":"list"},{"n":"&splice","t":"Sub","k":"v"},{"n":"splice","s":{"p":["@arr","|c is raw"],"r":"Mu"},"m":1,"k":"s"},{"t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","n":"&infix:«(<+)»","k":"v"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Setty:D \\a","QuantHash:D \\b"]},"n":"infix:«(<+)»"},{"m":1,"k":"s","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Bool:D"},"n":"infix:«(<+)»"},{"s":{"p":["Baggy:D \\a","Baggy:D \\b"],"r":"Bool:D"},"k":"s","m":1,"n":"infix:«(<+)»"},{"s":{"r":"Bool","p":["QuantHash:U $a","QuantHash:U $b"]},"m":1,"k":"s","n":"infix:«(<+)»"},{"n":"infix:«(<+)»","s":{"p":["QuantHash:U $a","QuantHash:D $b"],"r":"Bool"},"m":1,"k":"s"},{"s":{"r":"Bool:D","p":["QuantHash:D $a","QuantHash:U $b"]},"m":1,"k":"s","n":"infix:«(<+)»"},{"s":{"p":["QuantHash:D $a","QuantHash:D $b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«(<+)»"},{"m":1,"k":"s","s":{"r":"Mu","p":["$","Failure:D $b"]},"n":"infix:«(<+)»"},{"s":{"p":["Failure:D $a","$"],"r":"Mu"},"m":1,"k":"s","n":"infix:«(<+)»"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["$a","$b"]},"n":"infix:«(<+)»"},{"n":"&postcircumfix:<[; ]>","t":"Sub+{is-nodal}","k":"v"},{"n":"postcircumfix:<[; ]>","s":{"r":"Mu","p":["\\SELF","@indices"]},"m":1,"k":"s"},{"s":{"p":["\\SELF","@indices","Mu \\assignee"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[; ]>"},{"n":"postcircumfix:<[; ]>","m":1,"k":"s","s":{"r":"Mu","p":["\\SELF","@indices",":$BIND!"]}},{"n":"postcircumfix:<[; ]>","m":1,"k":"s","s":{"p":["\\SELF","@indices",":$delete!"],"r":"Mu"}},{"n":"postcircumfix:<[; ]>","s":{"p":["\\SELF","@indices",":$exists!"],"r":"Mu"},"k":"s","m":1},{"n":"postcircumfix:<[; ]>","s":{"r":"Mu","p":["\\SELF","@indices",":$kv!"]},"m":1,"k":"s"},{"k":"s","m":1,"s":{"p":["\\SELF","@indices",":$p!"],"r":"Mu"},"n":"postcircumfix:<[; ]>"},{"n":"postcircumfix:<[; ]>","s":{"r":"Mu","p":["\\SELF","@indices",":$k!"]},"k":"s","m":1},{"s":{"p":["\\SELF","@indices",":$v!"],"r":"Mu"},"m":1,"k":"s","n":"postcircumfix:<[; ]>"},{"k":"v","n":"&sleep-until","t":"Sub"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["$until"]},"n":"sleep-until"},{"k":"v","t":"Sub","n":"&atomic-inc-fetch"},{"s":{"p":["atomicint $target is rw"],"r":"atomicint"},"k":"s","m":1,"n":"atomic-inc-fetch"},{"t":"Sub","n":"&uniname","k":"v"},{"s":{"p":["Str:D $str"],"r":"Mu"},"m":1,"k":"s","n":"uniname"},{"k":"s","m":1,"s":{"p":["Int:D $code"],"r":"Mu"},"n":"uniname"},{"b":"C","n":"π","t":"Num","mro":["Real","Numeric","Cool"],"k":"c"},{"k":"v","n":"&infix:<~^>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":["$x = \"\""],"r":"Mu"},"m":1,"k":"s","n":"infix:<~^>"},{"n":"infix:<~^>","s":{"r":"Mu","p":["\\a","\\b"]},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"n":"infix:<~^>"},{"k":"s","m":1,"s":{"p":["Str:D \\a","Str:D \\b"],"r":"Str:D"},"n":"infix:<~^>"},{"s":{"p":["str $a","str $b"],"r":"str"},"m":1,"k":"s","n":"infix:<~^>"},{"n":"&close","t":"Sub","k":"v"},{"s":{"r":"Mu","p":["IO::Handle:D $fh"]},"m":1,"k":"s","n":"close"},{"s":{"p":["Channel:D $channel"],"r":"Mu"},"m":1,"k":"s","n":"close"},{"k":"v","n":"&shell","t":"Sub"},{"n":"shell","s":{"p":["$cmd",":$in = \"-\"",":$out = \"-\"",":$err = \"-\"","Bool :$bin","Bool :$chomp = Bool::True","Bool :$merge","Str :$enc","Str:D :$nl = \"\\n\"",":$cwd = { ... }",":$env"],"r":"Mu"},"m":1,"k":"s"},{"d":"TITLE\nclass Lock\n\nSUBTITLE\nA low-level, re-entrant, mutual exclusion lock\n\n    class Lock {}\n\nA Lock is a low-level concurrency control construct. It provides mutual\nexclusion, meaning that only one thread may hold the lock at a time. Once\nthe lock is unlocked, another thread may then lock it.\n\nA Lock is typically used to protect access to one or more pieces of state.\nFor example, in this program:\n\n    my $x = 0;\n    my $l = Lock.new;\n    await (^10).map: {\n        start {\n            $l.protect({ $x++ });\n        }\n    }\n    say $x;         # OUTPUT: «10␤»\n\nThe Lock is used to protect operations on $x. An increment is not an atomic\noperation; without the lock, it would be possible for two threads to both\nread the number 5 and then both store back the number 6, thus losing an\nupdate. With the use of the Lock, only one thread may be running the\nincrement at a time.\n\nA Lock is re-entrant, meaning that a thread that holds the lock can lock it\nagain without blocking. That thread must unlock the same number of times\nbefore the lock can be obtained by another thread (it works by keeping a\nrecursion count).\n\nIt's important to understand that there is no direct connection between a\nLock and any particular piece of data; it is up to the programmer to ensure\nthat the Lock is held during all operations that involve the data in\nquestion. The OO::Monitors module, while not a complete solution to this\nproblem, does provide a way to avoid dealing with the lock explicitly and\nencourage a more structured approach.\n\nThe Lock class is backed by operating-system provided constructs, and so a\nthread that is waiting to acquire a lock is, from the point of view of the\noperating system, blocked.\n\nCode using high-level Raku concurrency constructs should avoid using Lock.\nWaiting to acquire a Lock blocks a real Thread, meaning that the thread\npool (used by numerous higher-level Raku concurrency mechanisms) cannot use\nthat thread in the meantime for anything else.\n\nAny await performed while a Lock is held will behave in a blocking manner;\nthe standard non-blocking behavior of await relies on the code following\nthe `await` resuming on a different Thread from the pool, which is\nincompatible with the requirement that a Lock be unlocked by the same\nthread that locked it. See Lock::Async for an alternative mechanism that\ndoes not have this shortcoming.\n\nBy their nature, Locks are not composable, and it is possible to end up\nwith hangs should circular dependencies on locks occur. Prefer to structure\nconcurrent programs such that they communicate results rather than modify\nshared data structures, using mechanisms like Promise, Channel and Supply.\n\n","t":"Lock","n":"Lock","m":[{"n":"new","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"lock","d":"Defined as:\n\n    method lock(Lock:D:)\n\nAcquires the lock. If it is currently not available, waits for it.\n\n    my $l = Lock.new;\n    $l.lock;\n\nSince a Lock is implemented using OS-provided facilities, a thread waiting\nfor the lock will not be scheduled until the lock is available for it.\nSince Lock is re-entrant, if the current thread already holds the lock,\ncalling lock will simply bump a recursion count.\n\nWhile it's easy enough to use the lock method, it's more difficult to\ncorrectly use unlock. Instead, prefer to use the protect method instead,\nwhich takes care of making sure the lock/unlock calls always both occur.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"unlock","d":"Defined as:\n\n    method unlock(Lock:D:)\n\nReleases the lock.\n\n    my $l = Lock.new;\n    $l.lock;\n    $l.unlock;\n\nIt is important to make sure the Lock is always released, even if an\nexception is thrown. The safest way to ensure this is to use the protect\nmethod, instead of explicitly calling lock and unlock. Failing that, use a\nLEAVE phaser.\n\n    my $l = Lock.new;\n    {\n        $l.lock;\n        LEAVE $l.unlock;\n    }","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"protect","d":"Defined as:\n\n    method protect(Lock:D: &code)\n\nObtains the lock, runs &code, and releases the lock afterwards. Care is\ntaken to make sure the lock is released even if the code is left through an\nexception.\n\nNote that the Lock itself needs to be created outside the portion of the\ncode that gets threaded and it needs to protect. In the first example\nbelow, Lock is first created and assigned to $lock, which is then used\ninside the Promises to protect the sensitive code. In the second example, a\nmistake is made: the Lock is created right inside the Promise, so the code\nends up with a bunch of separate locks, created in a bunch of threads, and\nthus they don't actually protect the code we want to protect.\n\n    # Right: $lock is instantiated outside the portion of the\n    # code that will get threaded and be in need of protection\n    my $lock = Lock.new;\n    await ^20 .map: {\n        start {\n            $lock.protect: {\n                print \"Foo\";\n                sleep rand;\n                say \"Bar\";\n            }\n        }\n    }\n\n    # !!! WRONG !!! Lock is created inside threaded area!\n    await ^20 .map: {\n        start {\n            Lock.new.protect: {\n                print \"Foo\"; sleep rand; say \"Bar\";\n            }\n        }\n    }","s":{"p":["&code","*%_"],"r":"Mu"},"m":1,"k":"m"},{"d":"Defined as:\n\n    my class ConditionVariable {\n        method wait();\n        method signal();\n        method signal_all();\n    }\n\n    method condition(Lock:D: --> ConditionVariable:D)\n\n\nReturns a condition variable. Compare\nhttps://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=locks\nor https://en.wikipedia.org/wiki/Monitor_%28synchronization%29 for\nbackground.\n\n    my $l = Lock.new;\n    $l.condition;","n":"condition","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}}],"k":"c","mro":["Any"],"b":"A"},{"b":"A","a":[{"n":"$!holder","t":"Lock::Async::Holder","k":"v"}],"t":"Lock::Async","d":"TITLE\nclass Lock::Async\n\nSUBTITLE\nA non-blocking, non-re-entrant, mutual exclusion lock\n\n    class Lock::Async {}\n\nA Lock::Async instance provides a mutual exclusion mechanism: when the lock\nis held, any other code wishing to lock must wait until the holder calls\nunlock.\n\nUnlike Lock, which provides a traditional OS-backed mutual exclusion\nmechanism, Lock::Async works with the high-level concurrency features of\nRaku. The lock method returns a Promise, which will be kept when the lock\nis available. This Promise can be used with non-blocking await. This means\nthat a thread from the thread pool need not be consumed while waiting for\nthe Lock::Async to be available, and the code trying to obtain the lock\nwill be resumed once it is available.\n\nThe result is that it's quite possible to have many thousands of\noutstanding Lock::Async lock requests, but just a small number of threads\nin the pool. Attempting that with a traditional Lock would not go so well!\n\nThere is no requirement that a Lock::Async is locked and unlocked by the\nsame physical thread, meaning it is possible to do a non-blocking await\nwhile holding the lock. The flip side of this is Lock::Async is not\nre-entrant.\n\nWhile Lock::Async works in terms of higher-level Raku concurrency\nmechanisms, it should be considered a building block. Indeed, it lies at\nthe heart of the Supply concurrency model. Prefer to structure programs so\nthat they communicate results rather than mutate shared data structures,\nusing mechanisms like Promise, Channel and Supply.\n\n","n":"Lock::Async","k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Promise"},"d":"Defined as:\n\n    method lock(Lock::Async:D: --> Promise:D)\n\nReturns a Promise that will be kept when the lock is available. In the case\nthat the lock is already available, an already kept Promise will be\nreturned. Use await to wait for the lock to be available in a non-blocking\nmanner.\n\n    my $l = Lock::Async.new;\n    await $l.lock;\n\nPrefer to use protect instead of explicit calls to lock and unlock.","n":"lock"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"d":"Defined as:\n\n    method unlock(Lock::Async:D: --> Nil)\n\nReleases the lock. If there are any outstanding lock Promises, the one at\nthe head of the queue will then be kept, and potentially code scheduled on\nthe thread pool (so the cost of calling unlock is limited to the work\nneeded to schedule another piece of code that wants to obtain the lock, but\nnot to execute that code).\n\n    my $l = Lock::Async.new;\n    await $l.lock;\n    $l.unlock;\n\nPrefer to use protect instead of explicit calls to lock and unlock.\nHowever, if wishing to use the methods separately, it is wise to use a\nLEAVE block to ensure that unlock is reliably called. Failing to unlock\nwill mean that nobody can ever lock this particular Lock::Async instance\nagain.\n\n    my $l = Lock::Async.new;\n    {\n        await $l.lock;\n        LEAVE $l.unlock;\n    }","n":"unlock"},{"d":"Defined as:\n\n    method protect(Lock::Async:D: &code)\n\nCalls lock, does an await to wait for the lock to be available, and\nreliably calls unlock afterwards, even if the code throws an exception.\n\nNote that the Lock::Async itself needs to be created outside the portion of\nthe code that gets threaded and it needs to protect. In the first example\nbelow, Lock::Async is first created and assigned to $lock, which is then\nused inside the Promises to protect the sensitive code. In the second\nexample, a mistake is made, the Lock::Async is created right inside the\nPromise, so the code ends up with a bunch of separate locks, created in a\nbunch of threads, and thus they don't actually protect the code we want to\nprotect.\n\n    # Right: $lock is instantiated outside the portion of the\n    # code that will get threaded and be in need of protection\n    my $lock = Lock::Async.new;\n    await ^20 .map: {\n        start {\n            $lock.protect: {\n                print \"Foo\";\n                sleep rand;\n                say \"Bar\";\n            }\n        }\n    }\n\n    # !!! WRONG !!! Lock::Async is instantiated inside threaded area!\n    await ^20 .map: {\n        start {\n            my $lock = Lock::Async.new;\n            $lock.protect: {\n                print \"Foo\"; sleep rand; say \"Bar\";\n            }\n        }\n    }","n":"protect","k":"m","m":1,"s":{"p":["&code","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method protect-or-queue-on-recursion(Lock::Async:D: &code)\n\nWhen calling protect on a Lock::Async instance that is already locked, the\nmethod is forced to block until the lock gets unlocked.\nprotect-or-queue-on-recursion avoids this issue by either behaving the same\nas protect if the lock is unlocked or the lock was locked by something\noutside the caller chain, returning Nil, or queueing the call to &code and\nreturning a Promise if the lock had already been locked at another point in\nthe caller chain.\n\n    my Lock::Async $lock .= new;\n    my Int         $count = 0;\n\n    # The lock is unlocked, so the code runs instantly.\n    $lock.protect-or-queue-on-recursion({\n        $count++\n    });\n\n    # Here, we have caller recursion. The outer call only returns a Promise\n    # because the inner one does. If we try to await the inner call's Promise\n    # from the outer call, the two calls will block forever since the inner\n    # caller's Promise return value is just the outer's with a then block.\n    $lock.protect-or-queue-on-recursion({\n        $lock.protect-or-queue-on-recursion({\n            $count++\n        }).then({\n            $count++\n        })\n    });\n\n    # Here, the lock is locked, but not by anything else on the caller chain.\n    # This behaves just like calling protect would in this scenario.\n    for 0..^2 {\n        $lock.protect-or-queue-on-recursion({\n            $count++;\n        });\n    }\n\n    say $count; # OUTPUT: 5","n":"protect-or-queue-on-recursion","k":"m","m":0,"s":{"r":"Mu","p":["&code","*%_"]}},{"d":"Defined as:\n\n    method with-lock-hidden-from-recursion-check(&code)\n\nTemporarily resets the Lock::Async recursion list so that it no longer\nincludes the lock this method is called on and runs the given &code\nimmediately if the call to the method occurred in a caller chain where\nprotect-or-queue-on-recursion has already been called and the lock has been\nplaced on the recursion list.\n\n    my Lock::Async $lock .= new;\n    my Int         $count = 0;\n\n    $lock.protect-or-queue-on-recursion({\n        my Int $count = 0;\n\n        # Runs instantly.\n        $lock.with-lock-hidden-from-recursion-check({\n            $count++;\n        });\n\n        # Runs after the outer caller's protect-or-queue-on-recursion call has\n        # finished running.\n        $lock.protect-or-queue-on-recursion({\n            $count++;\n        }).then({\n            say $count; # OUTPUT: 2\n        });\n\n        say $count; # OUTPUT: 1\n    });","n":"with-lock-hidden-from-recursion-check","m":0,"k":"m","s":{"r":"Mu","p":["&code","*%_"]}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!on-recursion-list"},{"n":"!hidden-in-recursion-list","m":0,"k":"m","s":{"p":["IterationBuffer \\current","&code","*%_"],"r":"Mu"}},{"n":"!search-recursion-list","s":{"p":["IterationBuffer \\rec-list","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!run-under-recursion-list","k":"m","m":0,"s":{"p":["IterationBuffer $*LOCK-ASYNC-RECURSION-LIST","&code","*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["&code","*%_"],"r":"Mu"},"n":"!run-with-updated-recursion-list"}],"mro":["Any"]},{"mro":["Any"],"k":"c","m":[{"n":"new","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"wait","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"signal"},{"n":"signal_all","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"n":"Lock::ConditionVariable","t":"Lock::ConditionVariable","b":"A"},{"n":"&sprintf","t":"Sub","k":"v"},{"k":"s","m":1,"s":{"p":["Cool:D $format","*@args"],"r":"Mu"},"n":"sprintf"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&prefix:<->"},{"n":"prefix:<->","s":{"p":["\\a"],"r":"Mu"},"m":1,"k":"s"},{"n":"prefix:<->","s":{"p":["Real:D \\a"],"r":"Mu"},"m":1,"k":"s"},{"n":"prefix:<->","m":1,"k":"s","s":{"r":"Int:D","p":["Int:D \\a"]}},{"m":1,"k":"s","s":{"r":"int","p":["int $a"]},"n":"prefix:<->"},{"n":"prefix:<->","k":"s","m":1,"s":{"r":"Mu","p":["Num:D \\a"]}},{"s":{"p":["num $a"],"r":"num"},"k":"s","m":1,"n":"prefix:<->"},{"n":"prefix:<->","s":{"p":["Rat:D \\a"],"r":"Rat:D"},"m":1,"k":"s"},{"s":{"r":"FatRat:D","p":["FatRat:D \\a"]},"k":"s","m":1,"n":"prefix:<->"},{"n":"prefix:<->","k":"s","m":1,"s":{"p":["Complex:D \\a"],"r":"Complex:D"}},{"k":"s","m":1,"s":{"p":["Duration:D $a"],"r":"Duration:D"},"n":"prefix:<->"},{"k":"v","n":"&prefix:<?^>","t":"Sub+{is-pure}+{Precedence}"},{"n":"prefix:<?^>","s":{"p":["Mu \\a"],"r":"Mu"},"m":1,"k":"s"},{"n":"&infix:<⊂>","t":"Sub+{Callable[Bool:D]}+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Setty:D \\a","Setty:D \\b"]},"n":"infix:«(<)»"},{"m":1,"k":"s","s":{"p":["Setty:D \\a","Mixy:D \\b"],"r":"Bool:D"},"n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"p":["Setty:D \\a","Baggy:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Setty:D \\a","\\b"]},"n":"infix:«(<)»"},{"n":"infix:«(<)»","k":"s","m":1,"s":{"p":["Mixy:D \\a","Mixy:D \\b"],"r":"Bool:D"}},{"n":"infix:«(<)»","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Mixy:D \\a","\\b"]},"n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"r":"Bool:D","p":["Baggy:D \\a","Mixy:D \\b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Baggy:D \\a","Baggy:D \\b"]},"n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"r":"Bool:D","p":["Baggy:D \\a","\\b"]},"k":"s","m":1},{"n":"infix:«(<)»","s":{"r":"Bool:D","p":["\\a","Mixy:D \\b"]},"k":"s","m":1},{"n":"infix:«(<)»","s":{"r":"Bool:D","p":["\\a","Baggy:D \\b"]},"m":1,"k":"s"},{"n":"infix:«(<)»","k":"s","m":1,"s":{"p":["Failure:D \\a","$"],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["$","Failure:D \\b"]},"n":"infix:«(<)»"},{"n":"infix:«(<)»","s":{"r":"Bool:D","p":["\\a","\\b"]},"k":"s","m":1},{"k":"v","t":"Sub+{is-pure}","n":"&one"},{"n":"one","m":1,"k":"s","s":{"p":["@values"],"r":"Mu"}},{"m":1,"k":"s","s":{"p":["+\\values is raw"],"r":"Mu"},"n":"one"},{"mro":[],"m":[{"n":"of","d":"method of()\n\nReturns the type constraint for elements of the positional container.\nDefaults to Mu.\n\nMethods that should be provided","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"k":"ro","n":"Positional","d":"TITLE\nrole Positional\n\nSUBTITLE\nObject that supports looking up values by index\n\n    role Positional { ... }\n\nRole for objects which support indexing them using postcircumfix:«[ ]»\n(usually list-like objects). Example types with Positional role include\nList, Array, Range, and Buf.\n\n","t":"Positional","b":"C"},{"k":"v","t":"Sub","n":"&to-json"},{"k":"s","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"n":"to-json"},{"k":"v","n":"&infix:<+&>","t":"Sub+{is-pure}+{Precedence}"},{"n":"infix:<+&>","m":1,"k":"s","s":{"r":"Mu","p":[]}},{"n":"infix:<+&>","s":{"r":"Mu","p":["$x"]},"m":1,"k":"s"},{"n":"infix:<+&>","s":{"p":["$x","$y"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<+&>","m":1,"k":"s","s":{"r":"Int:D","p":["Int:D \\a","Int:D \\b"]}},{"s":{"p":["int $a","int $b"],"r":"int"},"m":1,"k":"s","n":"infix:<+&>"},{"b":"A","m":[{"s":{"r":"Date:D","p":["Int:D(Any):D $year","Int:D(Any):D $month","Int:D(Any):D $day",":&formatter","*%_"]},"k":"m","m":1,"n":"new","d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);"},{"d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);","n":"new","k":"m","m":1,"s":{"p":["Int:D(Any):D :$year!","Int:D(Any):D :$month = 1","Int:D(Any):D :$day = 1",":&formatter","*%_"],"r":"Date:D"}},{"s":{"p":["Str $date",":&formatter","*%_"],"r":"Date:D"},"m":1,"k":"m","n":"new","d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);"},{"s":{"r":"Date:D","p":["Dateish $d",":&formatter","*%_"]},"k":"m","m":1,"n":"new","d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);"},{"m":1,"k":"m","s":{"p":["Instant $i",":&formatter","*%_"],"r":"Date:D"},"d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);","n":"new"},{"d":"Defined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);","n":"new","m":1,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"r":"Date:D","p":["$daycount",":&formatter","*%_"]},"d":"Defined as:\n\n    method new-from-daycount($daycount,:&formatter --> Date:D)\n\nCreates a new Date object given $daycount which is the number of days from\nepoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a\nformatter as a named parameter.\n\n    say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»","n":"new-from-daycount"},{"n":"new-from-daycount","d":"Defined as:\n\n    method new-from-daycount($daycount,:&formatter --> Date:D)\n\nCreates a new Date object given $daycount which is the number of days from\nepoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a\nformatter as a named parameter.\n\n    say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»","s":{"p":["$daycount",":&formatter = { ... }","*%_"],"r":"Date:D"},"k":"m","m":1},{"d":"Defined as:\n\n    method today(:&formatter --> Date:D)\n\nReturns a Date object for the current day. Optionally accepts a formatter\nnamed parameter.\n\n    say Date.today;","n":"today","m":0,"k":"m","s":{"p":[":&formatter","*%_"],"r":"Date:D"}},{"s":{"p":["Cool $unit","*%_"],"r":"Date:D"},"m":0,"k":"m","n":"truncated-to","d":"Defined as:\n\n    method truncated-to(Date:D: Cool $unit)\n\nReturns a Date truncated to the first day of its year, month or week. For\nexample\n\n    my $c = Date.new('2012-12-24');\n    say $c.truncated-to('year');     # OUTPUT: «2012-01-01␤»\n    say $c.truncated-to('month');    # OUTPUT: «2012-12-01␤»\n    say $c.truncated-to('week');     # OUTPUT: «2012-12-24␤», because it's Monday already"},{"d":"Defined as:\n\n    method later(Date:D: *%unit)\n\nReturns a Date object based on the current one, but with a date delta\napplied. The date delta can be passed as a named argument where the\nargument name is the unit.\n\nAllowed units are day, days, week, weeks, month, months, year, years.\nPlease note that the plural forms can only be used with the later method.\n\nPlease note that the special \":2nd\" named parameter syntax can be a compact\nand self-documenting way of specifying the delta\n\n    say Date.new('2015-12-24').later(:2years);  # OUTPUT: «2017-12-24␤»\n\nSince addition of several different time units is not commutative, only one\nunit may be passed.\n\n    my $d = Date.new('2015-02-27');\n    say $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29␤»\n    say $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01␤»\n    say $d.later(days => 2).later(:month);   # same, as +True === 1\n\nNegative offsets are allowed, though #method earlier is more idiomatic for\nthat.","n":"later","k":"m","m":0,"s":{"p":[":$earlier","*%unit"],"r":"Date:D"}},{"s":{"p":["*%_"],"r":"Date:D"},"k":"m","m":0,"n":"clone","d":"Defined as:\n\n    method clone(:$year, :$month, :$day, :&formatter)\n\nCreates a new Date object based on the invocant, but with the given\narguments overriding the values from the invocant.\n\n    say Date.new('2015-11-24').clone(month => 12);    # OUTPUT: «2015-12-24␤»"},{"n":"new-from-diff","s":{"p":["Int:D $diff","*%_"],"r":"Date:D"},"k":"m","m":0},{"n":"succ","d":"Defined as:\n\n    method succ(Date:D: --> Date:D)\n\nReturns a Date of the following day. \"succ\" is short for \"successor\".\n\n    say Date.new(\"2016-02-28\").succ;   # OUTPUT: «2016-02-29␤»","s":{"r":"Date:D","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Date:D","p":["*%_"]},"d":"Defined as:\n\n    method pred(Date:D: --> Date:D)\n\nReturns a Date of the previous day. \"pred\" is short for \"predecessor\".\n\n    say Date.new(\"2016-01-01\").pred;   # OUTPUT: «2015-12-31␤»","n":"pred"},{"n":"DateTime","d":"Defined as:\n\n    multi method DateTime(Date:U --> DateTime:U)\n    multi method DateTime(Date:D --> DateTime:D)\n\nConverts the invocant to DateTime\n\n    say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\n    say Date.DateTime;                   # OUTPUT: «(DateTime)␤»\n\nFunctions\n\n  sub sleep\n\n    sub sleep($seconds = Inf --> Nil)\n\nAttempt to sleep for the given number of $seconds. Returns Nil on\ncompletion. Accepts Int, Num, Rat, or Duration types as an argument since\nall of these also do Real.\n\n    sleep 5;                # Int\n    sleep 5.2;              # Num\n    sleep (5/2);            # Rat\n    sleep (now - now + 5);  # Duration\n\n\nIt is thus possible to sleep for a non-integer amount of time. For\ninstance, the following code shows that sleep (5/2) sleeps for 2.5 seconds\nand sleep 5.2 sleeps for 5.2 seconds:\n\n    my $before = now;\n    sleep (5/2);\n    my $after = now;\n    say $after-$before;  # OUTPUT: «2.502411561␤»\n\n    $before = now;\n    sleep 5.2;\n    $after = now;\n    say $after-$before;  # OUTPUT: «5.20156987␤»\n\n  sub sleep-timer\n\n    sub sleep-timer(Real() $seconds = Inf --> Duration:D)\n\nThis function is implemented like sleep, but unlike the former it does\nreturn a Duration instance with the number of seconds the system did not\nsleep.\n\nIn particular, the returned Duration will handle the number of seconds\nremaining when the process has been awakened by some external event (e.g.,\nVirtual Machine or Operating System events). Under normal condition, when\nsleep is not interrupted, the returned Duration has a value of 0, meaning\nno extra seconds remained to sleep. Therefore, in normal situations:\n\n    say sleep-timer 3.14;  # OUTPUT: «0␤»\n\nThe same result applies to edge cases, when a negative or zero time to\nsleep is passed as argument:\n\n    say sleep-timer -2; # OUTPUT: 0\n    say sleep-timer 0;  # OUTPUT: 0\n\n\nSee also sleep-until.\n\n  sub sleep-until\n\n    sub sleep-until(Instant $until --> Bool)\n\nWorks similar to sleep but checks the current time and keeps sleeping until\nthe required instant in the future has been reached. It uses internally the\nsleep-timer method in a loop to ensure that, if accidentally woken up\nearly, it will wait again for the specified amount of time remaining to\nreach the specified instant. goes back to sleep\n\nReturns True if the Instant in the future has been achieved (either by mean\nof sleeping or because it is right now), False in the case an Instant in\nthe past has been specified.\n\nTo sleep until 10 seconds into the future, one could write something like\nthis:\n\n    say sleep-until now+10;   # OUTPUT: «True␤»\n\nTrying to sleep until a time in the past doesn't work:\n\n    my $instant = now - 5;\n    say sleep-until $instant; # OUTPUT: «False␤»\n\nHowever if we put the instant sufficiently far in the future, the sleep\nshould run:\n\n    my $instant = now + 30;\n    # assuming the two commands are run within 30 seconds of one another...\n    say sleep-until $instant; # OUTPUT: «True␤»\n\n\nTo specify an exact instant in the future, first create a DateTime at the\nappropriate point in time, and cast to an Instant.\n\n    my $instant = DateTime.new(\n        year => 2020,\n        month => 9,\n        day => 1,\n        hour => 22,\n        minute => 5);\n    say sleep-until $instant.Instant; # True (eventually...)\n\n\nThis could be used as a primitive kind of alarm clock. For instance, say\nyou need to get up at 7am on the 4th of September 2015, but for some reason\nyour usual alarm clock is broken and you only have your laptop. You can\nspecify the time to get up (being careful about time zones, since\nDateTime.new uses UTC by default) as an Instant and pass this to\nsleep-until, after which you can play an mp3 file to wake you up instead of\nyour normal alarm clock. This scenario looks roughly like this:\n\n    # DateTime.new uses UTC by default, so get time zone from current time\n    my $timezone = DateTime.now.timezone;\n    my $instant = DateTime.new(\n        year => 2015,\n        month => 9,\n        day => 4,\n        hour => 7,\n        minute => 0,\n        timezone => $timezone\n    ).Instant;\n    sleep-until $instant;\n    qqx{mplayer wake-me-up.mp3};\n\n\n  sub infix:<->\n\n    multi sub infix:<-> (Date:D, Int:D --> Date:D)\n    multi sub infix:<-> (Date:D, Date:D --> Int:D)\n\nTakes a date to subtract from and either an Int, representing the number of\ndays to subtract, or another Date object. Returns a new Date object or the\nnumber of days between the two dates, respectively.\n\n    say Date.new('2016-12-25') - Date.new('2016-12-24'); # OUTPUT: «1␤»\n    say Date.new('2015-12-25') - Date.new('2016-11-21'); # OUTPUT: «-332␤»\n    say Date.new('2016-11-21') - 332;                    # OUTPUT: «2015-12-25␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+> (Date:D, Int:D --> Date:D)\n    multi sub infix:<+> (Int:D, Date:D --> Date:D)\n\nTakes an Int and adds that many days to the given Date object.\n\n    say Date.new('2015-12-25') + 332; # OUTPUT: «2016-11-21␤»\n    say 1 + Date.new('2015-12-25');   # OUTPUT: «2015-12-26␤»","s":{"r":"DateTime:D","p":["*%_"]},"m":1,"k":"m"},{"s":{"p":["*%_"],"r":"DateTime:U"},"k":"m","m":1,"n":"DateTime","d":"Defined as:\n\n    multi method DateTime(Date:U --> DateTime:U)\n    multi method DateTime(Date:D --> DateTime:D)\n\nConverts the invocant to DateTime\n\n    say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\n    say Date.DateTime;                   # OUTPUT: «(DateTime)␤»\n\nFunctions\n\n  sub sleep\n\n    sub sleep($seconds = Inf --> Nil)\n\nAttempt to sleep for the given number of $seconds. Returns Nil on\ncompletion. Accepts Int, Num, Rat, or Duration types as an argument since\nall of these also do Real.\n\n    sleep 5;                # Int\n    sleep 5.2;              # Num\n    sleep (5/2);            # Rat\n    sleep (now - now + 5);  # Duration\n\n\nIt is thus possible to sleep for a non-integer amount of time. For\ninstance, the following code shows that sleep (5/2) sleeps for 2.5 seconds\nand sleep 5.2 sleeps for 5.2 seconds:\n\n    my $before = now;\n    sleep (5/2);\n    my $after = now;\n    say $after-$before;  # OUTPUT: «2.502411561␤»\n\n    $before = now;\n    sleep 5.2;\n    $after = now;\n    say $after-$before;  # OUTPUT: «5.20156987␤»\n\n  sub sleep-timer\n\n    sub sleep-timer(Real() $seconds = Inf --> Duration:D)\n\nThis function is implemented like sleep, but unlike the former it does\nreturn a Duration instance with the number of seconds the system did not\nsleep.\n\nIn particular, the returned Duration will handle the number of seconds\nremaining when the process has been awakened by some external event (e.g.,\nVirtual Machine or Operating System events). Under normal condition, when\nsleep is not interrupted, the returned Duration has a value of 0, meaning\nno extra seconds remained to sleep. Therefore, in normal situations:\n\n    say sleep-timer 3.14;  # OUTPUT: «0␤»\n\nThe same result applies to edge cases, when a negative or zero time to\nsleep is passed as argument:\n\n    say sleep-timer -2; # OUTPUT: 0\n    say sleep-timer 0;  # OUTPUT: 0\n\n\nSee also sleep-until.\n\n  sub sleep-until\n\n    sub sleep-until(Instant $until --> Bool)\n\nWorks similar to sleep but checks the current time and keeps sleeping until\nthe required instant in the future has been reached. It uses internally the\nsleep-timer method in a loop to ensure that, if accidentally woken up\nearly, it will wait again for the specified amount of time remaining to\nreach the specified instant. goes back to sleep\n\nReturns True if the Instant in the future has been achieved (either by mean\nof sleeping or because it is right now), False in the case an Instant in\nthe past has been specified.\n\nTo sleep until 10 seconds into the future, one could write something like\nthis:\n\n    say sleep-until now+10;   # OUTPUT: «True␤»\n\nTrying to sleep until a time in the past doesn't work:\n\n    my $instant = now - 5;\n    say sleep-until $instant; # OUTPUT: «False␤»\n\nHowever if we put the instant sufficiently far in the future, the sleep\nshould run:\n\n    my $instant = now + 30;\n    # assuming the two commands are run within 30 seconds of one another...\n    say sleep-until $instant; # OUTPUT: «True␤»\n\n\nTo specify an exact instant in the future, first create a DateTime at the\nappropriate point in time, and cast to an Instant.\n\n    my $instant = DateTime.new(\n        year => 2020,\n        month => 9,\n        day => 1,\n        hour => 22,\n        minute => 5);\n    say sleep-until $instant.Instant; # True (eventually...)\n\n\nThis could be used as a primitive kind of alarm clock. For instance, say\nyou need to get up at 7am on the 4th of September 2015, but for some reason\nyour usual alarm clock is broken and you only have your laptop. You can\nspecify the time to get up (being careful about time zones, since\nDateTime.new uses UTC by default) as an Instant and pass this to\nsleep-until, after which you can play an mp3 file to wake you up instead of\nyour normal alarm clock. This scenario looks roughly like this:\n\n    # DateTime.new uses UTC by default, so get time zone from current time\n    my $timezone = DateTime.now.timezone;\n    my $instant = DateTime.new(\n        year => 2015,\n        month => 9,\n        day => 4,\n        hour => 7,\n        minute => 0,\n        timezone => $timezone\n    ).Instant;\n    sleep-until $instant;\n    qqx{mplayer wake-me-up.mp3};\n\n\n  sub infix:<->\n\n    multi sub infix:<-> (Date:D, Int:D --> Date:D)\n    multi sub infix:<-> (Date:D, Date:D --> Int:D)\n\nTakes a date to subtract from and either an Int, representing the number of\ndays to subtract, or another Date object. Returns a new Date object or the\nnumber of days between the two dates, respectively.\n\n    say Date.new('2016-12-25') - Date.new('2016-12-24'); # OUTPUT: «1␤»\n    say Date.new('2015-12-25') - Date.new('2016-11-21'); # OUTPUT: «-332␤»\n    say Date.new('2016-11-21') - 332;                    # OUTPUT: «2015-12-25␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+> (Date:D, Int:D --> Date:D)\n    multi sub infix:<+> (Int:D, Date:D --> Date:D)\n\nTakes an Int and adds that many days to the given Date object.\n\n    say Date.new('2015-12-25') + 332; # OUTPUT: «2016-11-21␤»\n    say 1 + Date.new('2015-12-25');   # OUTPUT: «2015-12-26␤»"},{"s":{"r":"Date","p":["*%_"]},"k":"m","m":0,"n":"Date","d":"Defined as:\n\n    method Date(--> Date)\n\nReturns the invocant.\n\n    say Date.new('2015-12-24').Date;  # OUTPUT: «2015-12-24␤»\n    say Date.Date;                    # OUTPUT: «(Date)␤»"},{"n":"year","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"month"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"day"},{"n":"formatter","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"n":"!calculate-daycount","s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["$daycount","\\year","\\month","\\day","*%_"],"r":"Nil"},"n":"!ymd-from-daycount"},{"k":"m","m":0,"s":{"r":"Str:D","p":["*%_"]},"n":"!formatter"},{"n":"!DAYS-IN-MONTH","m":0,"k":"m","s":{"p":["\\year","\\month","*%_"],"r":"Int:D"}},{"m":0,"k":"m","s":{"r":"Date:D","p":["\\year","\\month","\\day","\\formatter","$daycount?","*%_"]},"n":"!SET-SELF"},{"n":"!truncate-ymd","m":0,"k":"m","s":{"r":"Mu","p":["Cool:D $unit","%parts? is copy","*%_"]}},{"s":{"p":["*%_"],"r":"Str:D"},"k":"m","m":0,"n":"!year-Str"},{"m":0,"k":"m","s":{"p":["$unit","*%_"],"r":"Mu"},"n":"!VALID-UNIT"},{"n":"!SET-DAYCOUNT","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!clone-without-validating","s":{"r":"Date:D","p":["*%_"]},"k":"m","m":0}],"k":"c","mro":["Dateish","Any"],"a":[{"k":"v","n":"$.year","t":"Int"},{"k":"v","n":"$.month","t":"Int"},{"n":"$.day","t":"Int","k":"v"},{"n":"$.daycount","t":"Int","k":"v"},{"k":"v","t":"Callable","n":"&.formatter"}],"d":"TITLE\nclass Date\n\nSUBTITLE\nCalendar date\n\n    class Date { }\n\nA Date is an immutable object identifying a day in the Gregorian calendar.\n\nDate objects support addition and subtraction of integers, where an integer\nis interpreted as the number of days. You can compare Date objects with the\nnumeric comparison operators ==, <, <=, >, >=, != . Their stringification\nin YYYY-MM-DD format means that comparing them with the string operators\neq, lt, le etc. also gives the right result.\n\nDate.today creates an object the current day according to the system\nclock.\n\n    my $d = Date.new(2015, 12, 24); # Christmas Eve!\n    say $d;                         # OUTPUT: «2015-12-24␤»\n    say $d.year;                    # OUTPUT: «2015␤»\n    say $d.month;                   # OUTPUT: «12␤»\n    say $d.day;                     # OUTPUT: «24␤»\n    say $d.day-of-week;             # OUTPUT: «4␤» (Thursday)\n    say $d.later(days => 20);       # OUTPUT: «2016-01-13␤»\n    my $n = Date.new('2015-12-31'); # New Year's Eve\n    say $n - $d;                    # OUTPUT: «7␤», 7 days between New Years/Christmas Eve\n    say $n + 1;                     # OUTPUT: «2016-01-01␤»\n\nNote since version 6.d, .perl can be called on Date.\n\n","t":"Date","n":"Date"},{"n":"&infix:<but>","t":"Sub+{is-pure}+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:D \\obj","Mu:U \\rolish"]},"n":"infix:<but>"},{"s":{"p":["Mu:D \\obj","Mu:U \\rolish",":$value! is raw"],"r":"Mu"},"k":"s","m":1,"n":"infix:<but>"},{"s":{"r":"Mu","p":["Mu:U \\obj","Mu:U \\rolish"]},"k":"s","m":1,"n":"infix:<but>"},{"n":"infix:<but>","s":{"p":["Mu \\obj","Mu:D $val"],"r":"Mu"},"m":1,"k":"s"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu:D \\obj","**@roles"]},"n":"infix:<but>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:U \\obj","**@roles"]},"n":"infix:<but>"},{"k":"v","n":"&take-rw","t":"Sub"},{"m":1,"k":"s","s":{"r":"Mu","p":[]},"n":"take-rw"},{"n":"take-rw","s":{"r":"Mu","p":["\\x"]},"k":"s","m":1},{"s":{"p":["|"],"r":"Mu"},"m":1,"k":"s","n":"take-rw"},{"k":"v","t":"Sub","n":"&infix:<∘>"},{"n":"infix:<o>","s":{"r":"Mu","p":[]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["&f"],"r":"Mu"},"n":"infix:<o>"},{"n":"infix:<o>","s":{"p":["&f","&g"],"r":"Block:D"},"m":1,"k":"s"},{"n":"&pick","t":"Sub","k":"v"},{"s":{"p":["$n","+\\values is raw"],"r":"Mu"},"m":1,"k":"s","n":"pick"},{"k":"v","n":"&rindex","t":"Sub"},{"s":{"r":"Mu","p":["Cool $s","Cool $needle","Cool $pos"]},"m":1,"k":"s","n":"rindex"},{"n":"rindex","s":{"r":"Mu","p":["Cool $s","Cool $needle"]},"m":1,"k":"s"},{"n":"&postfix:<⚛-->","t":"Sub","k":"v"},{"s":{"r":"atomicint","p":["atomicint $target is rw"]},"m":1,"k":"s","n":"postfix:<⚛-->"},{"n":"StrDistance","a":[{"k":"v","t":"Str","n":"$.before"},{"t":"Str","n":"$.after","k":"v"},{"t":"Int","n":"$!distance","k":"v"}],"d":"TITLE\nclass StrDistance\n\nSUBTITLE\nContains the result of a string transformation.\n\nStrDistance objects are used to represent the return of the string\ntransformation operator.\n\n    say (($ = \"fold\") ~~ tr/old/new/).^name;  # OUTPUT: «StrDistance␤»\n\nA StrDistance object will stringify to the resulting string after the\ntransformation, and will numify to the distance between the two strings.\n\n    my $str = \"fold\";\n    my $str-dist = ($str ~~ tr/old/new/);\n    say ~$str-dist;  # OUTPUT: «fnew␤»\n    say +$str-dist;  # OUTPUT: «3␤»\n\n\n","t":"StrDistance","mro":["Cool"],"m":[{"k":"s","m":0,"s":{"r":"Nil","p":[":before($!before)",":after($!after)","*%_"]},"n":"BUILD"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"Bool","d":"Returns True if before is different from after."},{"m":0,"k":"m","s":{"r":"Mu","p":["Mu \\a","*%_"]},"n":"ACCEPTS"},{"d":"Returns the distance as a number.","n":"Numeric","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"Defined as:\n\n    multi method Str(StrDistance:D: --> Str)\n\nReturns an after string value.\n\n        my $str-dist = ($str ~~ tr/old/new/);\n        say $str-dist.Str; # OUTPUT: «fnew␤»\n        say ~$str-dist;    # OUTPUT: «fnew␤»","n":"Str","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"before","d":"This is actually a class attribute, and called as a method returns the\nstring before the transformation:\n\n    say $str-dist.before; # OUTPUT: «fold␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"after","d":"Also a class attribute, returns the string after the transformation:\n\n    say $str-dist.after;  # OUTPUT: «fnew␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"C"},{"k":"v","n":"&full-barrier","t":"Sub"},{"n":"full-barrier","s":{"p":[],"r":"Nil"},"k":"s","m":1},{"b":"C","t":"NumericStringyEnumeration","n":"NumericStringyEnumeration","k":"ro","mro":[]},{"k":"v","n":"&asec","t":"Sub+{is-pure}"},{"s":{"r":"Mu","p":["Numeric \\x"]},"k":"s","m":1,"n":"asec"},{"n":"asec","m":1,"k":"s","s":{"p":["Cool \\x"],"r":"Mu"}},{"s":{"p":["num $x"],"r":"num"},"k":"s","m":1,"n":"asec"},{"n":"True","t":"Bool","k":"e"},{"b":"C","mro":[],"m":[{"n":"pull-one","d":"Defined as:\n\n    method pull-one(Iterator:D: --> Mu)\n\nThis method stub ensures that classes implementing the Iterator role\nprovide a method named pull-one.\n\nThe pull-one method is supposed to produce and return the next value if\npossible, or return the sentinel value IterationEnd if no more values could\nbe produced.\n\n    my $i = (1 .. 3).iterator;\n    say $i.pull-one;       # OUTPUT: «1␤»\n    say $i.pull-one;       # OUTPUT: «2␤»\n    say $i.pull-one;       # OUTPUT: «3␤»\n    say $i.pull-one.perl;  # OUTPUT: «IterationEnd␤»\n\nAs a more illustrative example of its use, here is a count down iterator\nalong with a simplistic subroutine re-implementation of the for loop.\n\n    # works the same as (10 ... 1, 'lift off')\n    class CountDown does Iterator {\n        has Int:D $!current = 10;\n\n        method pull-one ( --> Mu ) {\n            my $result = $!current--;\n            if $result ==  0 { return 'lift off' }\n            if $result == -1 { return IterationEnd }\n\n            # calling .pull-one again after it returns IterationEnd is undefined\n            if $result <= -2 {\n                # so for fun we will give them nonsense data\n                return (1..10).pick;\n            }\n\n            return $result;\n        }\n    }\n\n    sub for( Iterable:D $sequence, &do --> Nil ) {\n        my Iterator:D $iterator = $sequence.iterator;\n\n        loop {\n            # must bind the result so that =:= works\n            my Mu $pulled := $iterator.pull-one;\n\n            # always check the result and make sure that .pull-one\n            # is not called again after it returns IterationEnd\n            if $pulled =:= IterationEnd { last }\n\n            do( $pulled );\n        }\n    }\n\n    for( Seq.new(CountDown.new), &say );  # OUTPUT: «10␤9␤8␤7␤6␤5␤4␤3␤2␤1␤lift off␤»\n\nIt would be more idiomatic to use while or until, and a sigilless\nvariable.\n\n    until IterationEnd =:= (my \\pulled = $iterator.pull-one) {\n        do( pulled );\n    }","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"skip-one","d":"Defined as:\n\n    method skip-one(Iterator:D: $target --> Mu)\n\nShould skip producing one value. The return value should be truthy if the\nskip was successful and falsy if there were no values to be skipped:\n\n    my $i = <a b>.iterator;\n    say $i.skip-one; say $i.pull-one; say $i.skip-one\n    # OUTPUT: «1␤b␤0␤»\n\nThe Iterator role implements this method as a call pull-one and returning\nwhether the value obtained was not IterationEnd.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"push-exactly","d":"Defined as:\n\n    method push-exactly(Iterator:D: $target, int $count --> Mu)\n\nShould produce $count elements, and for each of them, call\n$target.push($value).\n\nIf fewer than $count elements are available from the iterator, it should\nreturn the sentinel value IterationEnd. Otherwise it should return $count.\n\n    my @array;\n    say (1 .. ∞).iterator.push-exactly(@array, 3); # OUTPUT: «3␤»\n    say @array; # OUTPUT: «[1 2 3]␤»\n\nThe Iterator role implements this method in terms of pull-one. In general,\nthis is a method that is not intended to be called directly from the end\nuser who, instead, should implement it in classes that mix the iterator\nrole. For instance, this class implements that role:\n\n    class DNA does Iterable does Iterator {\n        has $.chain;\n        has Int $!index = 0;\n\n        method new ($chain where {\n                           $chain ~~ /^^ <[ACGT]>+ $$ / and\n                           $chain.chars %% 3 } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator( ){ self }\n\n        method pull-one( --> Mu){\n          if $!index < $.chain.chars {\n             my $codon = $.chain.comb.rotor(3)[$!index div 3];\n             $!index += 3;\n             return $codon;\n          } else {\n            return IterationEnd;\n          }\n        }\n\n        method push-exactly(Iterator:D: $target, int $count --> Mu) {\n            return IterationEnd if $.chain.elems / 3 < $count;\n            for ^($count) {\n                $target.push: $.chain.comb.rotor(3)[ $_ ];\n            }\n        }\n\n    };\n\n    my $b := DNA.new(\"AAGCCT\");\n    for $b -> $a, $b, $c { say \"Never mind\" }; # Does not enter the loop\n    my $þor := DNA.new(\"CAGCGGAAGCCT\");\n    for $þor -> $first, $second {\n        say \"Coupled codons: $first, $second\";\n        # OUTPUT: «Coupled codons: C A G, C G G␤Coupled codons: A A G, C C T␤»\n    }\n\n\nThis code, which groups DNA chains in triplets (usually called codons)\nreturns those codons when requested in a loop; if too many are requested,\nlike in the first case for $b -> $a, $b, $c, it simply does not enter the\nloop since push-exactly will return IterationEnd since it is not able to\nserve the request for exactly 3 codons. In the second case, however, it\nrequests exactly two codons in each iteration of the loop; push-exactly is\nbeing called with the number of loop variables as the $count variable.","s":{"r":"Mu","p":["\\target","int $n","*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["\\target","int $n","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method push-at-least(Iterator:D: $target, int $count --> Mu)\n\nShould produce at least $count elements, and for each of them, call\n$target.push($value).\n\nIf fewer than $count elements are available from the iterator, it should\nreturn the sentinel value IterationEnd. Otherwise it should return $count.\n\nIterators with side effects should produce exactly $count elements;\niterators without side effects (such as Range iterators) can produce more\nelements to achieve better performance.\n\n    my @array;\n    say (1 .. ∞).iterator.push-at-least(@array, 10); # OUTPUT: «10␤»\n    say @array; # OUTPUT: «[1 2 3 4 5 6 7 8 9 10]␤»\n\nThe Iterator role implements this method in terms of pull-one. In general,\nit is also not intended to be called directly as in the example above. It\ncan be implemented, if unhappy with this default implementation, by those\nusing this role. See the documentation for push-exactly for an example\nimplementation.","n":"push-at-least"},{"m":0,"k":"m","s":{"p":["\\target","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method push-all(Iterator:D: $target)\n\nShould produce all elements from the iterator and push them to $target.\n\n    my @array;\n    say (1 .. 1000).iterator.push-all(@array); # All 1000 values are pushed\n\nThe Iterator role implements this method in terms of push-at-least. As in\nthe case of the other push-* methods, it is mainly intended for developers\nimplementing this role. push-all is called when assigning an object with\nthis role to an array, for instance, like in this example:\n\n    class DNA does Iterable does Iterator {\n        has $.chain;\n        has Int $!index = 0;\n\n        method new ($chain where {\n                           $chain ~~ /^^ <[ACGT]>+ $$ / and\n                           $chain.chars %% 3 } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator( ){ self }\n        method pull-one( --> Mu){\n          if $!index < $.chain.chars {\n             my $codon = $.chain.comb.rotor(3)[$!index div 3];\n             $!index += 3;\n             return $codon;\n          } else {\n            return IterationEnd;\n          }\n        }\n\n        method push-all(Iterator:D: $target) {\n            for $.chain.comb.rotor(3) -> $codon {\n                $target.push: $codon;\n            }\n        }\n\n    };\n\n    my $b := DNA.new(\"AAGCCT\");\n    my @dna-array = $b;\n    say @dna-array; # OUTPUT: «[(A A G) (C C T)]␤»\n\n\nThe push-all method implemented pushes to the target iterator in lists of\nthree aminoacid representations; this is called under the covers when we\nassign $b to @dna-array.","n":"push-all"},{"k":"m","m":0,"s":{"p":["\\target","*%_"],"r":"Mu"},"d":"Defined as:\n\n    method push-until-lazy(Iterator:D: $target --> Mu)\n\nShould produce values until it considers itself to be lazy, and push them\nonto $target.\n\nThe Iterator role implements this method as a no-op if is-lazy returns a\nTrue value, or as a synonym of push-all if not.\n\nThis matters mostly for iterators that have other iterators embedded, some\nof which might be lazy, while others aren't.","n":"push-until-lazy"},{"d":"Defined as:\n\n    method skip-at-least(Iterator:D: $target, int $to-skip --> Mu)\n\nShould skip producing $to-skip values. The return value should be truthy if\nthe skip was successful and falsy if there were not enough values to be\nskipped:\n\n    my $i = <a b c>.iterator;\n    say $i.skip-at-least(2); say $i.pull-one; say $i.skip-at-least(20);\n    # OUTPUT: «1␤c␤0␤»\n\nThe Iterator role implements this method as a loop calling skip-one and\nreturning whether it returned a truthy value sufficient number of times.","n":"skip-at-least","k":"m","m":0,"s":{"p":["int $toskip","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method skip-at-least-pull-one(Iterator:D: $target, int $to-skip --> Mu)\n\nShould skip producing $to-skip values and if the iterator is still not\nexhausted, produce and return the next value. Should return IterationEnd if\nthe iterator got exhausted at any point:\n\n    my $i = <a b c>.iterator;\n    say $i.skip-at-least-pull-one(2);\n    say $i.skip-at-least-pull-one(20) =:= IterationEnd;\n    # OUTPUT: «c␤True␤»\n\nThe Iterator role implements this method as calling skip-at-least and then\ncalling pull-one if it was not exhausted yet.\n\nPredictive iterators\n\nPlease see the PredictiveIterator role if your Iterator can know how many\nvalues it can still produce without actually producing them.","n":"skip-at-least-pull-one","m":0,"k":"m","s":{"r":"Mu","p":["int $toskip","*%_"]}},{"n":"sink-all","d":"Defined as:\n\n    method sink-all(Iterator:D: --> IterationEnd)\n\nShould exhaust the iterator purely for the side-effects of producing the\nvalues, without actually saving them in any way. Should always return\nIterationEnd. If there are no side-effects associated with producing a\nvalue, then it can be implemented by a consuming class to be a virtual\nno-op.\n\n    say (1 .. 1000).iterator.sink-all;  # OUTPUT: «IterationEnd␤»\n\nThe Iterator role implements this method as a loop that calls pull-one\nuntil it is exhausted.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-lazy","d":"Defined as:\n\n    method is-lazy(Iterator:D: --> Bool:D)\n\nShould return True for iterators that consider themselves lazy, and False\notherwise.\n\nBuilt-in operations that know that they can produce infinitely many values\nreturn True here, for example (1..6).roll(*).\n\n    say (1 .. 100).is-lazy; # OUTPUT: «False␤»\n    say (1 .. ∞).is-lazy; # OUTPUT: «True␤»\n\nThe Iterator role implements this method returning False, indicating a\nnon-lazy iterator.","s":{"r":"Bool","p":["*%_"]},"m":0,"k":"m"}],"k":"ro","n":"Iterator","d":"TITLE\nrole Iterator\n\nSUBTITLE\nGeneric API for producing a sequence of values\n\n    constant IterationEnd\n    role Iterator { }\n\n\nA Iterator is an object that can generate or provide elements of a\nsequence. Users usually don't have to care about iterators, their usage is\nhidden behind iteration APIs such as for @list { }, map, grep, head, tail,\nskip and list indexing with .[$idx].\n\nThe main API is the pull-one method, which either returns the next value,\nor the sentinel value IterationEnd if no more elements are available. Each\nclass implementing Iterator must provide a pull-one method. All other\nnon-optional Iterator API methods are implemented in terms of pull-one, but\ncan also be overridden by consuming classes for performance or other\nreasons. There are also optional Iterator API methods that will only be\ncalled if they are implemented by the consuming class: these are not\nimplemented by the Iterator role.\n\nIterationEnd\n\nIterators only allow one iteration over the entire sequence. It's forbidden\nto make attempts to fetch more data, once IterationEnd has been generated,\nand behavior for doing so is undefined. For example, the following Seq will\nnot cause the die to be called under normal use, because pull-one will\nnever be called after it returns IterationEnd:\n\n    class SkippingArray is Array {\n        # skip all undefined values while iterating\n        method iterator {\n            class :: does Iterator {\n                has $.index is rw = 0;\n                has $.array is required;\n                method pull-one {\n                    $.index++ while !$.array.AT-POS($.index).defined && $.array.elems > $.index;\n                    $.array.elems > $.index ?? $.array.AT-POS($.index++) !! IterationEnd\n                }\n            }.new(array => self)\n        }\n    }\n\n    my @a := SkippingArray.new;\n\n    @a.append: 1, Any, 3, Int, 5, Mu, 7;\n\n    for @a -> $a, $b {\n        say [$a, $b];\n    }\n\n    # OUTPUT: «[1 3]␤[5 7]␤»\n\n\nThe only valid use of the sentinel value IterationEnd in a program is\nidentity comparison (using =:=) with the result of a method in the iterator\nAPI. Any other behavior is undefined and implementation dependent.\n\nPlease bear in mind that IterationEnd is a constant, so if you are going to\ncompare it against the value of a variable, this variable will have to be\nbound, not assigned. Comparing directly to the output of pull-one will\nwork.\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    say $it.pull-one =:= IterationEnd; # OUTPUT: «True␤»\n\n\nHowever, if we use a variable we and we assign it, the result will be\nincorrect:\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    my $is-it-the-end = $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «False␤»\n\n\nSo we'll have to bind the variable to make it work:\n\n    my $is-it-the-end := $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «True␤»\n\n\n","t":"Iterator"},{"n":"&callframe","t":"Sub","k":"v"},{"n":"callframe","k":"s","m":0,"s":{"p":["Int:D $level = 0"],"r":"Mu"}},{"n":"&prefix:<++>","t":"Sub+{Precedence}","k":"v"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:D $a is rw"]},"n":"prefix:<++>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $a is rw"]},"n":"prefix:<++>"},{"n":"prefix:<++>","m":1,"k":"s","s":{"r":"Int:D","p":["Int:D $a is rw"]}},{"k":"s","m":1,"s":{"r":"int","p":["int $a is rw"]},"n":"prefix:<++>"},{"s":{"p":["Bool $a is rw"],"r":"Mu"},"k":"s","m":1,"n":"prefix:<++>"},{"m":1,"k":"s","s":{"p":["Num:D $a is rw"],"r":"Mu"},"n":"prefix:<++>"},{"s":{"p":["Num:U $a is rw"],"r":"Mu"},"k":"s","m":1,"n":"prefix:<++>"},{"n":"prefix:<++>","s":{"p":["num $a is rw"],"r":"num"},"k":"s","m":1},{"k":"v","n":"&gist","t":"Sub"},{"m":1,"k":"s","s":{"r":"Mu","p":["|"]},"n":"gist"},{"k":"v","t":"Sub+{is-pure}","n":"&tan"},{"m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]},"n":"tan"},{"s":{"r":"Mu","p":["Cool \\x"]},"m":1,"k":"s","n":"tan"},{"n":"tan","m":1,"k":"s","s":{"p":["num $x"],"r":"num"}},{"k":"v","t":"Sub","n":"&say"},{"n":"say","s":{"r":"Mu","p":[]},"k":"s","m":1},{"n":"say","m":1,"k":"s","s":{"r":"Mu","p":["\\x"]}},{"s":{"p":["**@args is raw"],"r":"Mu"},"m":1,"k":"s","n":"say"},{"k":"v","t":"Sub","n":"&redo"},{"n":"redo","s":{"p":[],"r":"Nil"},"m":1,"k":"s"},{"n":"redo","k":"s","m":1,"s":{"r":"Nil","p":["Label:D \\x"]}},{"t":"PromiseStatus","n":"Planned","k":"e"},{"n":"&cotan","t":"Sub+{is-pure}","k":"v"},{"s":{"p":["Numeric \\x"],"r":"Mu"},"k":"s","m":1,"n":"cotan"},{"n":"cotan","s":{"p":["Cool \\x"],"r":"Mu"},"m":1,"k":"s"},{"s":{"p":["num $x"],"r":"num"},"k":"s","m":1,"n":"cotan"},{"n":"&acos","t":"Sub+{is-pure}","k":"v"},{"n":"acos","m":1,"k":"s","s":{"r":"Mu","p":["Numeric \\x"]}},{"s":{"r":"Mu","p":["Cool \\x"]},"m":1,"k":"s","n":"acos"},{"k":"s","m":1,"s":{"p":["num $x"],"r":"num"},"n":"acos"},{"k":"v","n":"&exp","t":"Sub+{is-pure}"},{"n":"exp","k":"s","m":1,"s":{"r":"Mu","p":["Numeric $x"]}},{"m":1,"k":"s","s":{"p":["Numeric $x","Numeric $base"],"r":"Mu"},"n":"exp"},{"d":"TITLE\nclass VM\n\nSUBTITLE\nRaku Virtual Machine related information\n\n    class VM does Systemic { }\n\nBuilt-in class for providing information about the virtual machine in which\nRaku is running. Usually accessed through the $*VM dynamic variable.\n\n","a":[{"k":"v","n":"$.config","t":"Mu"},{"t":"Mu","n":"$.prefix","k":"v"},{"k":"v","t":"Mu","n":"$.precomp-ext"},{"k":"v","n":"$.precomp-target","t":"Mu"},{"t":"Str","n":"$.name","k":"v"},{"n":"$.auth","t":"Str","k":"v"},{"n":"$.version","t":"Version","k":"v"},{"k":"v","t":"Blob","n":"$.signature"},{"t":"Str","n":"$.desc","k":"v"}],"t":"VM","n":"VM","m":[{"n":"BUILD","s":{"p":[":config($!config)",":$desc","*%_"],"r":"Nil"},"k":"s","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["IO::Path $library","Version :$version","*%_"]},"n":"platform-library-name"},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method osname(VM:U:)\n    multi method osname(VM:D:)\n\nInstance / Class method returning the name of the Operating System, as\nknown by the configuration of the VM object / currently running virtual\nmachine.","n":"osname"},{"k":"m","m":1,"s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method osname(VM:U:)\n    multi method osname(VM:D:)\n\nInstance / Class method returning the name of the Operating System, as\nknown by the configuration of the VM object / currently running virtual\nmachine.","n":"osname"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"config"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Instance method returning a string of the path in which the virtual machine\nof the VM object is installed.","n":"prefix"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"precomp-ext","d":"Instance method returning a string of the extension that should be used for\nprecompiled files of the VM object."},{"n":"precomp-target","d":"Instance method returning a string of the value of the compilation target\nthat should be used when precompiling source-files with the VM object.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"name","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"auth"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"version"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"signature"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"desc"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["Systemic","Any"],"b":"A"},{"b":"A","mro":["Any"],"k":"c","m":[{"n":"new","s":{"p":["\\op",":$dwim-left",":$dwim-right","*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"name"},{"n":"infix","s":{"p":["\\left","\\right","*%_"],"r":"Mu"},"m":1,"k":"m"},{"s":{"p":["Associative:D \\left","Associative:D \\right","*%_"],"r":"Associative:D"},"m":1,"k":"m","n":"infix"},{"s":{"r":"Mu","p":["Associative:D \\left","List:D \\right","*%_"]},"m":1,"k":"m","n":"infix"},{"n":"infix","k":"m","m":1,"s":{"p":["Associative:D \\left","\\right","*%_"],"r":"Associative:D"}},{"n":"infix","k":"m","m":1,"s":{"r":"Mu","p":["List:D \\left","Associative:D \\right","*%_"]}},{"n":"infix","s":{"p":["\\left","Associative:D \\right","*%_"],"r":"Associative:D"},"m":1,"k":"m"},{"n":"infix","s":{"p":["Positional:D \\left","\\right","*%_"],"r":"Positional:D"},"k":"m","m":1},{"n":"infix","s":{"p":["\\left","Positional:D \\right","*%_"],"r":"Positional:D"},"m":1,"k":"m"},{"n":"infix","k":"m","m":1,"s":{"r":"Iterable:D","p":["Iterable:D \\left","Iterable:D \\right","*%_"]}},{"n":"infix","k":"m","m":1,"s":{"p":["\\object","*%_"],"r":"Mu"}},{"n":"operator","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"dwim-left"},{"n":"dwim-right","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"assigns"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"n":"!right-exhausted","m":0,"k":"m","s":{"p":["Iterator:D \\iterator","int $right-elems","*%_"],"r":"Mu"}},{"n":"!mu-pair","k":"m","m":0,"s":{"r":"Mu","p":["\\left","\\right","*%_"]}},{"n":"!associatives","m":0,"k":"m","s":{"r":"Mu","p":["@keys","\\left","\\right","*%_"]}},{"s":{"p":["\\left","\\right","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!pair-mu"},{"n":"!pair-pair","k":"m","m":0,"s":{"r":"Mu","p":["\\left","\\right","*%_"]}},{"n":"!iterators-right","k":"m","m":0,"s":{"r":"Mu","p":["Iterator:D \\left","Iterator:D \\right","*%_"]}},{"n":"!left-exhausted","s":{"r":"Mu","p":["Iterator:D \\iterator","int $left-elems","*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["Iterator:D \\left","Iterator:D \\right","*%_"],"r":"Mu"},"n":"!iterators"},{"s":{"p":["\\left","\\right","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!str-associatives"},{"m":0,"k":"m","s":{"p":["Iterator:D \\left","Iterator:D \\right","*%_"],"r":"Mu"},"n":"!iterators-left-right"},{"s":{"r":"Mu","p":["\\left","\\right","*%_"]},"m":0,"k":"m","n":"!obj-associatives"},{"n":"!iterators-left","s":{"p":["Iterator:D \\left","Iterator:D \\right","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!predictive-iterators","s":{"r":"Mu","p":["PredictiveIterator:D \\left","PredictiveIterator:D \\right","*%_"]},"m":0,"k":"m"}],"n":"Hyper","t":"Hyper","a":[{"k":"v","n":"$.operator","t":"Mu"},{"k":"v","t":"int8","n":"$.dwim-left"},{"t":"int8","n":"$.dwim-right","k":"v"},{"k":"v","n":"$.assigns","t":"int8"}]},{"b":"A","n":"X::SecurityPolicy","t":"X::SecurityPolicy","a":[{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"k":"c"},{"b":"A","a":[{"k":"v","n":"$.payload","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::SecurityPolicy::Eval","n":"X::SecurityPolicy::Eval","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"Numeric","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"from-slurpy","s":{"r":"Mu","p":["|cap is raw"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"payload"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::SecurityPolicy"]},{"b":"A","mro":["Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"}],"n":"X::ParametricConstant","a":[{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::ParametricConstant"},{"b":"A","a":[{"t":"Mu","n":"$.localizer","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Localizer::NoContainer","n":"X::Localizer::NoContainer","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"localizer"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Exception"]},{"a":[{"k":"v","n":"$.dispatcher","t":"Mu"},{"t":"Mu","n":"$.capture","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Multi::NoMatch","n":"X::Multi::NoMatch","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"dispatcher","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"capture"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["Exception"],"b":"A"},{"mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"dispatcher","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"ambiguous","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"capture"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"n":"X::Multi::Ambiguous","t":"X::Multi::Ambiguous","a":[{"k":"v","n":"$.dispatcher","t":"Mu"},{"n":"@.ambiguous","t":"Positional","k":"v"},{"n":"$.capture","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"b":"A"},{"n":"X::Pragma::CannotPrecomp","t":"X::Pragma::CannotPrecomp","a":[{"k":"v","n":"$.what","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"what"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","b":"A"},{"mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"name","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"alternatives"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","n":"X::Pragma::MustOneOf","t":"X::Pragma::MustOneOf","a":[{"k":"v","n":"$.name","t":"Mu"},{"n":"$.alternatives","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A"},{"b":"A","mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"name","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","n":"X::Pragma::OnlyOne","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Pragma::OnlyOne"},{"a":[{"t":"Mu","n":"$.name","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Pragma::NoArgs","n":"X::Pragma::NoArgs","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"name"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"b":"A"},{"b":"A","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"what"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"name"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["Exception"],"a":[{"n":"$.what","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.name"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Pragma::CannotWhat","n":"X::Pragma::CannotWhat"},{"a":[{"t":"Mu","n":"$.name","k":"v"},{"n":"$.arg","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Pragma::UnknownArg","n":"X::Pragma::UnknownArg","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"name","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"arg"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["Exception"],"b":"A"},{"n":"X::Supply::Migrate::Needs","t":"X::Supply::Migrate::Needs","a":[{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"}],"k":"c","b":"A"},{"b":"A","n":"X::Supply::Combinator","a":[{"k":"v","n":"$.combinator","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Supply::Combinator","mro":["Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"combinator","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}]},{"b":"A","mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"}],"n":"X::Supply::New","t":"X::Supply::New","a":[{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"d":"method old(--> Str:D)\n\nReturns a textual description of the obsolete syntax construct","n":"old","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method replacement(--> Str:D)\n\nDescribes what to use instead of the obsolete syntax.","n":"replacement"},{"d":"method when(--> Str:D)\n\nReturns a string describing the state of the language (usually \" in\nRaku\").","n":"when","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.old","t":"Mu"},{"k":"v","t":"Mu","n":"$.replacement"},{"k":"v","n":"$.when","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Obsolete","d":"TITLE\nclass X::Obsolete\n\nSUBTITLE\nCompilation error due to use of obsolete syntax\n\n    class X::Obsolete does X::Comp { }\n\nSyntax error thrown when the user is attempting to use constructs from\nother languages.\n\nFor example\n\n    m/abc/i\n\n\ndies with\n\n    ===SORRY!===\n    Unsupported use of /i; in Raku please use :i\n\n\n","n":"X::Obsolete"},{"b":"A","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"operation"},{"n":"got-dimensions","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"needed-dimensions","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"a":[{"t":"Mu","n":"$.operation","k":"v"},{"n":"$.got-dimensions","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.needed-dimensions"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::NotEnoughDimensions","n":"X::NotEnoughDimensions"},{"n":"X::NotParametric","a":[{"n":"$.type","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::NotParametric","mro":["Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"type"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"target-name","d":"method target-name(--> Str:D)\n\nReturns the name of the type that should be composed, but failed.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"composer","d":"method composer(--> Mu)\n\nReturns the type that should be composed into the target, but which isn't a\nrole.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"k":"c","mro":["X::Comp","Exception"],"d":"TITLE\nclass X::Composition::NotComposable\n\nSUBTITLE\nCompilation error due to composing an ineligible type\n\n    class X::Composition::NotComposable is Exception { }\n\nThrown when trying to compose a type into a target type, but the composer\ntype cannot be used for composition (roles and enums are generally OK).\n\nFor example\n\n    class A { }\n    class B does A { }\n\n\ndies with\n\n    ===SORRY!===\n    ␤A is not composable, so B cannot compose it\n\n\nbecause does is reserved for role composition, and A is not a role, nor\nsomething that knows how to turn into a role.\n\nThe fix is to either make A a role, or use inheritance (class B is A { })\ninstead.\n\n","a":[{"k":"v","t":"Mu","n":"$.target-name"},{"k":"v","n":"$.composer","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Composition::NotComposable","n":"X::Composition::NotComposable"},{"n":"X::IO","d":"TITLE\nrole X::IO\n\nSUBTITLE\nIO related error\n\n    role X::IO does X::OS {}\n\nCommon role for IO related errors.\n\nThis role does not provide any additional methods.","t":"X::IO","mro":[],"k":"ro","b":"C"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.path"},{"n":"$.os-error","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::IO::Unlink","d":"TITLE\nclass X::IO::Unlink\n\nSUBTITLE\nError while trying to remove a file\n\n    class X::IO::Unlink does X::IO is Exception { }\n\n\nError class for failed unlink operation.\n\nA typical error message is\n\n    Failed to remove the file 'secret': Permission defined\n\n\n","n":"X::IO::Unlink","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Returns the path that unlink failed to delete.","n":"path"},{"n":"os-error","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::IO","X::OS","Exception"]},{"mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"path","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"trying","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"os-error","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::IO::NotAFile","a":[{"k":"v","t":"Mu","n":"$.path"},{"n":"$.trying","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.os-error"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::IO::NotAFile","b":"A"},{"b":"A","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"d":"Returns the path rmdir failed to remove","n":"path","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"os-error"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::IO","X::OS","Exception"],"t":"X::IO::Rmdir","a":[{"k":"v","t":"Mu","n":"$.path"},{"n":"$.os-error","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::IO::Rmdir\n\nSUBTITLE\nError while trying to remove a directory\n\n    my class X::IO::Rmdir does X::IO is Exception { }\n\n\nError class for failed rmdir operations.\n\nA typical error message is\n\n    Failed to remove the directory 'lib': Directory not empty\n\n\n","n":"X::IO::Rmdir"},{"n":"X::IO::DoesNotExist","d":"TITLE\nclass X::IO::DoesNotExist\n\nSUBTITLE\nError while doing file tests on a non existing path\n\n    class X::IO::DoesNotExist does X::IO is Exception { }\n\n\nThrown when doing file test operations on a non existing path.\n\nA typical error message is\n\n    Failed to find 'euler-5.p6' while trying to do '.f'\n\n\n","a":[{"k":"v","n":"$.path","t":"Mu"},{"n":"$.trying","t":"Mu","k":"v"},{"t":"Mu","n":"$.os-error","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::IO::DoesNotExist","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"path","d":"Returns the path that was passed to the failed call."},{"n":"trying","d":"Returns a string describing the failed operation.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"os-error"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"b":"A"},{"mro":["X::IO","X::OS","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"path","d":"Returns the path that dir failed to read."},{"n":"os-error","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"X::IO::Dir","a":[{"k":"v","n":"$.path","t":"Mu"},{"n":"$.os-error","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::IO::Dir","d":"TITLE\nclass X::IO::Dir\n\nSUBTITLE\nError while trying to get a directory's contents\n\n    class X::IO::Dir does X::IO is Exception { }\n\n\nError class that is thrown when a dir call fails.\n\nA typical error message is\n\n    Failed to get the directory contents of '/tmp/': No such file or directory\n\n\n","b":"A"},{"b":"A","t":"X::IO::Directory","a":[{"k":"v","n":"$.path","t":"Mu"},{"t":"Mu","n":"$.trying","k":"v"},{"k":"v","n":"$.use","t":"Mu"},{"k":"v","t":"Mu","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::IO::Directory","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"path"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"trying"},{"n":"use","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::IO","X::OS","Exception"]},{"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"os-error","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::IO","X::OS","Exception"],"a":[{"n":"$.os-error","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::IO::BinaryAndEncoding","n":"X::IO::BinaryAndEncoding","b":"A"},{"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"path","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"child","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"os-error","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::IO","X::OS","Exception"],"a":[{"k":"v","t":"Mu","n":"$.path"},{"t":"Mu","n":"$.child","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::IO::NotAChild","n":"X::IO::NotAChild","b":"A"},{"t":"X::IO::Link","a":[{"k":"v","n":"$.target","t":"Mu"},{"n":"$.name","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.os-error"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::IO::Link\n\nSUBTITLE\nError while trying to create a link\n\n    class X::IO::Link does X::IO is Exception { }\n\n\nError class for failed link operation.\n\nA typical error message is\n\n    Failed to create link called 'my-link' on target 'does-not exist': Failed to link file\n\n\n","n":"X::IO::Link","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"n":"target","d":"Returns the name of the link target, i.e. the existing file.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"name","d":"Returns the name of the link that could not be created."},{"n":"os-error","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["X::IO","X::OS","Exception"],"b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.os-error"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::IO::Cwd\n\nSUBTITLE\nError while trying to determine the current working directory\n\n    class X::IO::Cwd does X::IO is Exception { }\n\n\nError class when the runtime fails to determine the current directory.\n\nA typical error message is\n\n    Failed to get the working directory: permission denied\n","t":"X::IO::Cwd","n":"X::IO::Cwd","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::IO","X::OS","Exception"],"b":"A"},{"b":"A","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"os-error","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::IO","X::OS","Exception"],"t":"X::IO::Flush","a":[{"t":"Mu","n":"$.os-error","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::IO::Flush"},{"n":"X::IO::Rename","d":"TITLE\nclass X::IO::Rename\n\nSUBTITLE\nError while trying to rename a file or directory\n\n    class X::IO::Rename does X::IO is Exception { }\n\n\nError class for failed file or directory rename operations. A typical error\nmessage is\n\n    Failed to rename 'source' to 'destination': is a directory\n\n\n","a":[{"k":"v","t":"Mu","n":"$.from"},{"k":"v","n":"$.to","t":"Mu"},{"k":"v","t":"Mu","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::IO::Rename","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Returns the source of the failed rename operation","n":"from","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"to","d":"Returns the destination of the failed rename operation"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"os-error"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"b":"A"},{"b":"A","n":"X::IO::Unknown","t":"X::IO::Unknown","a":[{"t":"Mu","n":"$.trying","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::IO","X::OS","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"trying","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"os-error"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c"},{"b":"A","t":"X::IO::Chdir","a":[{"k":"v","n":"$.path","t":"Mu"},{"t":"Mu","n":"$.os-error","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::IO::Chdir\n\nSUBTITLE\nError while trying to change the working directory\n\n    class X::IO::Chdir does X::IO is Exception { }\n\n\nError class when a chdir call failed.\n\nFor example\n\n    chdir '/home/other'\n\n\nthrows\n\n    Failed to change the working directory to '/home/other': permission denied\n\n\n","n":"X::IO::Chdir","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"path","d":"Returns the path that was passed to the failed chdir call."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"os-error"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::IO","X::OS","Exception"]},{"b":"A","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"trying","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::IO","X::OS","Exception"],"a":[{"t":"Mu","n":"$.trying","k":"v"},{"n":"$.os-error","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::IO::BinaryMode","n":"X::IO::BinaryMode"},{"b":"A","n":"X::IO::Lock","a":[{"n":"$.lock-type","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::IO::Lock","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"lock-type"},{"n":"os-error","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}]},{"b":"A","n":"X::IO::Chmod","t":"X::IO::Chmod","a":[{"n":"$.path","t":"Mu","k":"v"},{"t":"Mu","n":"$.mode","k":"v"},{"k":"v","n":"$.os-error","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::IO::Chmod\n\nSUBTITLE\nError while trying to change file permissions\n\n    class X::IO::Chmod does X::IO is Exception { }\n\n\nError class for failed chmod calls.\n\nA typical error message is\n\n    Failed to set the mode of '/home/other' to '0o777': Permission denied\n","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"path"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"mode"},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}]},{"b":"A","t":"X::IO::Symlink","a":[{"n":"$.target","t":"Mu","k":"v"},{"k":"v","n":"$.name","t":"Mu"},{"k":"v","n":"$.os-error","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::IO::Symlink\n\nSUBTITLE\nError while trying to create a symbolic link\n\n    class X::IO::Symlink does X::IO is Exception { }\n\n\nError class for failed symlink creation.\n\nA typical error message is\n\n    Failed to create symlink called 'euler' on target '/home/myhome/euler-1.p6': Failed to symlink file: file already exist\n\n\n","n":"X::IO::Symlink","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Returns the path that symlink failed to create a link to.","n":"target","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"d":"Returns the path that symlink failed to create.","n":"name","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::IO","X::OS","Exception"]},{"b":"A","n":"X::IO::Move","d":"TITLE\nclass X::IO::Move\n\nSUBTITLE\nError while trying to move a file\n\n    class X::IO::Move does X::IO is Exception { }\n\n\nError class for a failed file move operation. A typical error message is\n\n    Failed to move '/tmp/alpha.p6' to 'test.p6': :createonly specified and destination exists\n\n\n","a":[{"k":"v","n":"$.from","t":"Mu"},{"t":"Mu","n":"$.to","k":"v"},{"k":"v","t":"Mu","n":"$.os-error"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::IO::Move","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"from","d":"Returns the source of the failed move operation","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"to","d":"Returns the destination of the failed move operation","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"os-error","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}]},{"b":"A","mro":["X::IO","X::OS","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"path","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"os-error"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","n":"X::IO::Resolve","a":[{"t":"Mu","n":"$.path","k":"v"},{"k":"v","t":"Mu","n":"$.os-error"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::IO::Resolve"},{"n":"X::IO::Mkdir","a":[{"n":"$.path","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.mode"},{"k":"v","n":"$.os-error","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::IO::Mkdir\n\nSUBTITLE\nError while trying to create a directory\n\n    class X::IO::Mkdir does X::IO is Exception { }\n\n\nError class for failed mkdir operations.\n\nA typical error message is\n\n    Failed to create directory 'destination' with mode '0o755': File exists\n\n\n","t":"X::IO::Mkdir","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Returns the path that the mkdir operation failed to create.","n":"path"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"mode","d":"Returns the permissions mask of the failed mkdir operation as an Int."},{"n":"os-error","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"b":"A"},{"a":[{"t":"Mu","n":"$.os-error","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::IO::Null","n":"X::IO::Null","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"os-error","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::IO","X::OS","Exception"],"b":"A"},{"b":"A","n":"X::IO::Copy","d":"TITLE\nclass X::IO::Copy\n\nSUBTITLE\nError while trying to copy a file\n\n    class X::IO::Copy does X::IO is Exception { }\n\n\nError class for failed file copy operations. A typical error message is\n\n    Failed to copy 'source' to 'destination': permission denied\n\n\n","a":[{"n":"$.from","t":"Mu","k":"v"},{"n":"$.to","t":"Mu","k":"v"},{"n":"$.os-error","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::IO::Copy","mro":["X::IO","X::OS","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"from","d":"Returns the source of the failed copy operation"},{"n":"to","d":"Returns the destination of the failed copy operation","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"os-error"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}]},{"mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"type","d":"method type(X::Does::TypeObject:D: --> Mu:U)\n\nReturns the type object into which the code tried to mix in a role.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"nameds","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"n":"X::Does::TypeObject","d":"TITLE\nclass X::Does::TypeObject\n\nSUBTITLE\nError due to mixing into a type object\n\n    class X::Does::TypeObject is Exception {}\n\nWhen you try to add one or more roles to a type object with does after it\nhas been composed, an error of type X::Does::TypeObject is thrown:\n\n    Mu does Numeric;    # Cannot use 'does' operator with a type object.\n\n\nThe correct way to apply roles to a type is at declaration time:\n\n    class GrassmannNumber does Numeric { ... };\n    role AlgebraDebugger does IO { ... };\n    grammar IntegralParser does AlgebraParser { ... };\n\n\nRoles may only be runtime-mixed into defined object instances:\n\n    GrassmannNumber.new does AlgebraDebugger;\n\n\n(This restriction may be worked around by using augment or supersede, or\nwith dark Metamodel magics, but this will likely result in a significant\nperformance penalty.)\n\n","a":[{"k":"v","t":"Mu","n":"$.type"},{"k":"v","n":"%.nameds","t":"Associative"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Does::TypeObject","b":"A"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"method"},{"n":"name","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"value"},{"n":"reason","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Exception"],"t":"X::Invalid::ComputedValue","a":[{"n":"$.method","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.name"},{"k":"v","n":"$.value","t":"Mu"},{"t":"Mu","n":"$.reason","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Invalid::ComputedValue"},{"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"method","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"name","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"value","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Exception"],"a":[{"t":"Mu","n":"$.method","k":"v"},{"k":"v","t":"Mu","n":"$.name"},{"n":"$.value","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Invalid::Value","n":"X::Invalid::Value","b":"A"},{"mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"type"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"n":"X::Match::Bool","a":[{"k":"v","n":"$.type","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Match::Bool","b":"A"},{"b":"C","mro":[],"k":"ro","n":"X::MOP","t":"X::MOP"},{"n":"X::Subscript::Negative","a":[{"t":"Mu","n":"$.index","k":"v"},{"t":"Mu","n":"$.type","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Subscript::Negative","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"index"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"type"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","b":"A"},{"b":"A","n":"X::Routine::Unwrap","t":"X::Routine::Unwrap","a":[{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"}]},{"b":"A","t":"X::Backslash::UnrecognizedSequence","a":[{"k":"v","n":"$.sequence","t":"Mu"},{"k":"v","t":"Mu","n":"$.suggestion"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Backslash::UnrecognizedSequence","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"sequence","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"suggestion","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::Syntax","X::Comp","Exception"]},{"t":"X::Backslash::NonVariableDollar","a":[{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Backslash::NonVariableDollar","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"mro":["X::Comp","X::Undeclared"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Returns the kind of package the attribute was used in (for example class,\ngrammar)","n":"package-kind"},{"d":"Returns the name of the package in which the offensive attribute reference\nwas performed.","n":"package-name","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"n":"X::Attribute::Undeclared","d":"TITLE\nclass X::Attribute::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared attribute\n\n    class X::Attribute::Undeclared is X::Undeclared { }\n\nThrown when code refers to an attribute that has not been declared.\n\nFor example the code\n\n    class A { method m { $!notthere } }\n\n\nProduces the error\n\n    Attribute $!notthere not declared in class A\n\n\n","a":[{"n":"$.package-kind","t":"Mu","k":"v"},{"k":"v","n":"$.package-name","t":"Mu"},{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.symbol","k":"v"},{"k":"v","t":"Positional","n":"@.suggestions"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Attribute::Undeclared","b":"A"},{"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"scope","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"allowed","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"disallowed"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.scope","t":"Mu"},{"n":"$.allowed","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.disallowed"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Attribute::Scope::Package","n":"X::Attribute::Scope::Package","b":"A"},{"mro":["X::Comp","Exception"],"m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"package-kind","d":"method package-kind(--> Str:D)\n\nReturns the kind of package (package, module) that doesn't support\nattributes.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"name","d":"method name(--> Str:D)\n\nReturns the name of the attribute that triggered this error."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","n":"X::Attribute::Package","a":[{"k":"v","t":"Mu","n":"$.package-kind"},{"k":"v","t":"Mu","n":"$.name"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Attribute::Package","d":"TITLE\nclass X::Attribute::Package\n\nSUBTITLE\nCompilation error due to declaring an attribute in an ineligible package\n\n    class X::Attribute::Package does X::Comp { }\n\nCompile time error, thrown when the compiler encounters an attribute\ndeclaration inside a package that does not support attributes.\n\nFor example\n\n    module A { has $.x }\n\n\ndies with\n\n    A module cannot have attributes, but you tried to declare '$.x'\n\n\n","b":"A"},{"a":[{"n":"$.what","t":"Mu","k":"v"},{"n":"$.symbol","t":"Mu","k":"v"},{"t":"Positional","n":"@.suggestions","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Attribute::Regex","n":"X::Attribute::Regex","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Comp","X::Undeclared"],"b":"A"},{"mro":["X::MOP","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method name(--> Str:D)\n\nReturns the name of the attribute.","n":"name"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"why","d":"method why(--> Str:D)\n\nReturns the reason why that attribute is required, and it will be included\nin the message if provided. That reason is taken directly from the is\nrequired trait.\n\n    my class Uses-required {\n        has $.req is required(\"because yes\")\n    };\n    my $object = Uses-required.new();                                  │\n    # OUTPUT:\n    # «(exit code 1) The attribute '$!req' is required because because yes,␤\n    # but you did not provide a value for it.␤»"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"n":"X::Attribute::Required","a":[{"k":"v","n":"$.name","t":"Mu"},{"n":"$.why","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Attribute::Required","d":"TITLE\nclass X::Attribute::Required\n\nSUBTITLE\nCompilation error due to not declaring an attribute with the is required\ntrait\n\n    class X::Attribute::NoPackage does X::MOP { }\n\nCompile time error thrown when a required attribute is not assigned when\ncreating an object.\n\nFor example\n\n    my class Uses-required {\n        has $.req is required\n    };\n    my $object = Uses-required.new()\n\n\nDies with\n\n    OUTPUT: «(exit code 1) The attribute '$!req' is required, but you did not provide a value for it.␤»\n\n\n","b":"A"},{"b":"A","d":"TITLE\nclass X::Attribute::NoPackage\n\nSUBTITLE\nCompilation error due to declaring an attribute outside of a package\n\n    class X::Attribute::NoPackage does X::Comp { }\n\nCompile time error thrown when an attribute is declared where it does not\nmake sense (for example in the mainline).\n\nFor example\n\n    has $.x;\n\n\nDies with\n\n    You cannot declare attribute '$.x' here; maybe you'd like a class or a role?\n\n\n","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Attribute::NoPackage","n":"X::Attribute::NoPackage","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method name(--> Str:D)\n\nReturns the name of the attribute","n":"name"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"modules","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"]},{"n":"X::InvalidType","t":"X::InvalidType","a":[{"n":"$.typename","t":"Mu","k":"v"},{"n":"@.suggestions","t":"Positional","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"typename"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"suggestions"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"t":"X::Exhausted","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","n":"$.reason","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Exhausted","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"what"},{"n":"reason","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["Exception"],"b":"A"},{"a":[{"n":"$.target","t":"Mu","k":"v"},{"n":"$.rolish","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Mixin::NotComposable","d":"TITLE\nclass X::Mixin::NotComposable\n\nSUBTITLE\nError due to using an ineligible type as a mixin\n\n    class X::Mixin::NotComposable is Exception { }\n\nThrown when a mixin with infix does or but is done with a composer that\ncannot be used for mixin.\n\nFor example\n\n    class A { };\n    1 but A;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Mixin::NotComposable: Cannot mix in non-composable type A into object of type Int␤»\n\nThe compile-time equivalent of this error is X::Composition::NotComposable\n\n","n":"X::Mixin::NotComposable","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"target","d":"method target()\n\nReturns the target of the failed mixin operation."},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method rolish()\n\nReturns the thing that could not act as a role for mixing it in","n":"rolish"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["Exception"],"b":"A"},{"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"got"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["Exception"],"t":"X::Range::InvalidArg","a":[{"t":"Mu","n":"$.got","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Range::InvalidArg","b":"A"},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method packages(--> Positional:D)\n\nReturns a list of packages that were stubbed but not defined.","n":"packages"},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::Comp","Exception"],"t":"X::Package::Stubbed","a":[{"k":"v","t":"Positional","n":"@.packages"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Package::Stubbed\n\nSUBTITLE\nCompilation error due to a stubbed package that is never defined\n\n    class X::Package::Stubbed does X::Comp { }\n\nThrown at CHECK time when there are packages stubbed but not later\ndefined.\n\nFor example\n\n    class A { ... }     # literal ...\n    class B { ... }     # literal ...\n\n\ndies with\n\n    ===SORRY!===\n    The following packages were stubbed but not defined:\n        A\n        B\n\n\n","n":"X::Package::Stubbed","b":"A"},{"n":"X::Package::UseLib","t":"X::Package::UseLib","a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"mro":["X::Comp","Exception"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"what"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","b":"A"},{"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"redispatcher","d":"method redispatcher(--> Str:D)\n\nReturns the name of the redispatcher function that did not succeed."},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["Exception"],"a":[{"k":"v","t":"Mu","n":"$.redispatcher"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::NoDispatcher\n\nSUBTITLE\nError due to calling a dispatch command in an ineligible scope\n\n    class X::NoDispatcher is Exception { }\n\nWhen a redispatcher like nextsame is called without being in the dynamic\nscope of a call where a redispatch is possible, an X::NoDispatcher is\nthrown.\n\nFor example\n\n    nextsame; # In the mainline\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::NoDispatcher: nextsame is not in the dynamic scope of a dispatcher␤»\n\n","t":"X::NoDispatcher","n":"X::NoDispatcher","b":"A"},{"t":"X::Adverb","a":[{"t":"Mu","n":"$.what","k":"v"},{"n":"$.source","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.unexpected"},{"k":"v","t":"Positional","n":"@.nogo"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Adverb","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"unexpected","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"nogo"},{"n":"what","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"source","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","mro":["Exception"],"b":"A"},{"t":"X::StubCode","a":[{"k":"v","n":"$.message","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::StubCode\n\nSUBTITLE\nRuntime error due to execution of stub code\n\n    class X::StubCode is Exception { }\n\nThrown when a piece of stub code (created via !!! or ...) is executed.\n\n","n":"X::StubCode","k":"c","m":[{"d":"Returns the custom message provided to !!!, or a reasonable default if none\nwas provided.","n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["Exception"],"b":"A"},{"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"what","d":"Returns the kind of symbol that was not declared (for example variable,\ntype, routine).\n\nSince The symbol wasn't declared, the compiler sometimes has to guess (or\nrather disambiguate) what kind of symbol it encounter that wasn't declared.\nFor example if you write\n\n    say a;\n\n\nThen the disambiguation defaults to reporting a missing subroutine, even\nthough declaring a constant a = 'a' would also make the error go away."},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"symbol","d":"Returns the name of the undeclared symbol"},{"n":"suggestions","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.what","t":"Mu"},{"k":"v","n":"$.symbol","t":"Mu"},{"k":"v","t":"Positional","n":"@.suggestions"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared symbol\n\n    class X::Undeclared does X::Comp {}\n\nThrown when the compiler encounters a symbol that has not been declared,\nbut needs to be.\n\nExample\n\n    $x;\n\n\nresults in\n\n    ===SORRY!===\n    Variable $x is not declared\n\n\n","t":"X::Undeclared","n":"X::Undeclared","b":"A"},{"b":"A","t":"X::Undeclared::Symbols","a":[{"k":"v","t":"Associative","n":"%.post_types"},{"k":"v","t":"Associative","n":"%.unk_types"},{"k":"v","n":"%.unk_routines","t":"Associative"},{"n":"%.routine_suggestion","t":"Associative","k":"v"},{"n":"%.type_suggestion","t":"Associative","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Undeclared::Symbols","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post_types"},{"n":"unk_types","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"unk_routines","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"routine_suggestion","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"type_suggestion","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"]},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"role"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"a":[{"n":"$.role","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Role::Parametric::NoSuchCandidate","n":"X::Role::Parametric::NoSuchCandidate","b":"A"},{"b":"A","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"role","d":"method role()\n\nReturns the role that caused the error.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["Exception"],"a":[{"k":"v","n":"$.role","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Role::Initialization\n\nSUBTITLE\nError due to passing an initialization value to an ineligible role\n\n    class X::Role::Initialization is Exception { }\n\nThrown when the SomeRole($init) syntax is used, but SomeRole does not have\nexactly one public attribute.\n\nFor example:\n\n    role R { }; \"D2\" but R(2)\n    CATCH { default { put .^name, ': ', .Str } }\n    # OUTPUT: «X::Role::Initialization: Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'R'␤»\n\n\n","t":"X::Role::Initialization","n":"X::Role::Initialization"},{"b":"A","mro":["Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"promise","d":"method promise()\n\nReturns the Promise that was asked about."},{"d":"method status()\n\nReturns the status the Promise had at that time.","n":"status","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Promise::CauseOnlyValidOnBroken","a":[{"k":"v","t":"Mu","n":"$.promise"},{"k":"v","n":"$.status","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Promise::CauseOnlyValidOnBroken\n\nSUBTITLE\nError due to asking why an unbroken promise has been broken.\n\n    class X::Promise::CauseOnlyValidOnBroken is Exception { }\n\nThis exception is thrown when code expects a Promise to be broken, and asks\nwhy it has been broken, but the Promise has in fact, not yet been broken.\n\n","t":"X::Promise::CauseOnlyValidOnBroken"},{"k":"ro","mro":[],"t":"X::Promise::Broken","a":[{"n":"$.result-backtrace","t":"Mu","k":"v"}],"n":"X::Promise::Broken","b":"C"},{"b":"A","t":"X::Promise::Vowed","a":[{"n":"$.promise","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Promise::Vowed\n\nSUBTITLE\nError due to directly trying to keep/break a vowed promise.\n\n    class X::Promise::Vowed is Exception { }\n\nThis exception is thrown when code tries to keep/break an already vowed\npromise without going through the corresponding Vow object.\n\n","n":"X::Promise::Vowed","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"d":"method promise()\n\nReturns the vowed Promise.","n":"promise","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"k":"c","mro":["Exception"]},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.combinator"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Promise::Combinator","n":"X::Promise::Combinator","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"combinator","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"]},{"b":"A","n":"X::Bind","t":"X::Bind","a":[{"n":"$.target","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Bind\n\nSUBTITLE\nError due to binding to something that is not a variable or container\n\n    class X::Bind is Exception {}\n\nIf you write code like this:\n\n    floor(1.1) := 42;\n\n\nit dies with an X::Bind exception:\n\n    Cannot use bind operator with this left-hand side\n","mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"target"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}]},{"b":"A","d":"TITLE\nclass X::Bind::Slice\n\nSUBTITLE\nError due to binding to a slice\n\n    class X::Bind::Slice is Exception {}\n\nWhen you try to bind to an array or hash slice:\n\n    my @a; @a[0, 1] := [42];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Array slice␤»\n\nand\n\n    my %h; %h<a b> := {};\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Hash slice␤»\n\nyou get an exception of type ::Bind::Slice\n\n","a":[{"k":"v","t":"Mu","n":"$.type"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Bind::Slice","n":"X::Bind::Slice","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"method type(X::Bind::Slice:D:)\n\nreturns the type object of the thing that you tried to slice-bind, for\nexample Array, List or Hash.","n":"type","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["Exception"]},{"b":"A","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"d":"method name(--> Str:D)\n\nReturns the name of the variable.","n":"name","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.name","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Bind::NativeType","d":"TITLE\nclass X::Bind::NativeType\n\nSUBTITLE\nCompilation error due to binding to a natively typed variable\n\n    class X::Bind::NativeType does X::Comp { }\n\nCompile-time error thrown when trying to bind to a natively typed\nvariable.\n\nSince native variables explicitly don't have the concept of a container at\nruntime, it does not make sense to support both binding and assignment;\nRaku supports only assignment (which makes more sense, because native types\nare value types).\n\nFor example the code\n\n    my int $x := 3;\n\n\ndies with\n\n    Cannot bind to natively typed variable '$x'; use assignment instead\n\n\nand can be fixed by writing it as\n\n    my int $x = 3;\n\n","n":"X::Bind::NativeType"},{"b":"A","t":"X::Bind::ZenSlice","a":[{"n":"$.type","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Bind::ZenSlice","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::Bind::Slice"]},{"b":"A","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"name"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["X::Comp","Exception"],"t":"X::InvalidTypeSmiley","a":[{"k":"v","n":"$.name","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::InvalidTypeSmiley"},{"a":[{"k":"v","n":"$.thing","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Set::Coerce","n":"X::Set::Coerce","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"thing"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"k":"c","mro":["Exception"],"b":"A"},{"mro":["Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"type","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"subtype"},{"n":"declaring","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"n":"X::Trait::Unknown","a":[{"n":"$.type","t":"Mu","k":"v"},{"t":"Mu","n":"$.subtype","k":"v"},{"n":"$.declaring","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Trait::Unknown","b":"A"},{"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"type"},{"n":"subtype","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"declaring"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"name"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["Exception"],"a":[{"t":"Mu","n":"$.type","k":"v"},{"k":"v","n":"$.subtype","t":"Mu"},{"k":"v","t":"Mu","n":"$.declaring"},{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Trait::Invalid","n":"X::Trait::Invalid","b":"A"},{"b":"A","n":"X::Trait::NotOnNative","t":"X::Trait::NotOnNative","a":[{"k":"v","n":"$.type","t":"Mu"},{"k":"v","n":"$.subtype","t":"Mu"},{"k":"v","n":"$.native","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"type"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"subtype"},{"n":"native","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c"},{"b":"A","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"type","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"subtype","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"declaring"},{"n":"scope","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"supported"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["Exception"],"t":"X::Trait::Scope","a":[{"k":"v","n":"$.type","t":"Mu"},{"k":"v","n":"$.subtype","t":"Mu"},{"t":"Mu","n":"$.declaring","k":"v"},{"k":"v","n":"$.scope","t":"Mu"},{"k":"v","t":"Mu","n":"$.supported"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Trait::Scope"},{"b":"C","k":"ro","mro":[],"t":"X::React::Died","a":[{"n":"$.react-backtrace","t":"Mu","k":"v"}],"n":"X::React::Died"},{"b":"A","n":"X::Buf::Pack","a":[{"k":"v","n":"$.directive","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Buf::Pack","mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"directive","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}]},{"n":"X::Buf::Pack::NonASCII","t":"X::Buf::Pack::NonASCII","a":[{"n":"$.char","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"char","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"b":"A"},{"b":"A","n":"X::Buf::AsStr","t":"X::Buf::AsStr","a":[{"k":"v","n":"$.method","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"method","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c"},{"b":"A","n":"X::Anon::Multi","d":"TITLE\nclass X::Anon::Multi\n\nSUBTITLE\nCompilation error due to declaring an anonymous multi\n\n    class X::Anon::Multi does X::Comp { }\n\nCompile time error thrown when an anonymous multi is being declared.\n\nFor example\n\n    multi method () { }\n\n\ndies with\n\n    Cannot put multi on anonymous method\n\n\n","a":[{"k":"v","t":"Mu","n":"$.multiness"},{"t":"Mu","n":"$.routine-type","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Anon::Multi","mro":["X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"multiness","d":"method multiness(--> Str:D)\n\nReturns a string describing the multiness that the original code used, for\nexample \"multi\" or \"proto\"."},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method routine-type(--> Str:D)\n\nReturns a string describing the type of routine that was declared, for\nexample \"sub\" or \"method\".","n":"routine-type"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c"},{"n":"X::Anon::Augment","a":[{"n":"$.package-kind","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Anon::Augment","d":"TITLE\nclass X::Anon::Augment\n\nSUBTITLE\nCompilation error due to augmenting an anonymous package\n\n    class X::Anon::Augment does X::Comp { }\n\nCompile time error thrown when trying to augment an anonymous package.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class { }\n\n\nDies with\n\n    Cannot augment anonymous class\n\n\n","mro":["X::Comp","Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method package-kind returns Str:D\n\nReturns the kind of package (module, class, grammar, ...) that the code\ntried to augment.","n":"package-kind"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","b":"A"},{"mro":["X::Temporal","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"}],"n":"X::DateTime::TimezoneClash","a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::DateTime::TimezoneClash","d":"TITLE\nclass X::DateTime::TimezoneClash\n\nSUBTITLE\nError due to using both time zone offset and :timezone\n\n    class X::DateTime::TimezoneClash does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime object\nspecifying both a time zone offset and the named argument :timezone.\n\n    say DateTime.new('2015-12-24T12:23:00+0200');                   # works\n    say DateTime.new('2015-12-24T12:23:00', timezone => 7200);      # works\n    say DateTime.new('2015-12-24T12:23:00+0200', timezone => 7200); # exception\n\n\n","b":"A"},{"n":"X::DateTime::InvalidDeltaUnit","a":[{"k":"v","n":"$.unit","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::DateTime::InvalidDeltaUnit","mro":["X::Temporal","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"n":"unit","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"b":"A"},{"k":"ro","mro":[],"d":"TITLE\nrole X::Control\n\nSUBTITLE\nRole for control exceptions\n\n    role X::Control is Exception { }\n\nThis role turns an exception into a control exception, such as CX::Next or\nCX::Take. It has got no code other than the definition.\n\nSince Rakudo 2019.03, throwing an object that mixes in this role X::Control\ncan raise a control exception which is caught by the CONTROL phaser instead\nof CATCH. This allows to define custom control exceptions.\n\nFor example, the custom CX::Oops control exception we define below:\n\n    class CX::Vaya does X::Control {\n        has $.message\n    }\n\n    sub ea {\n        CONTROL {\n            default {\n                say \"Controlled { .^name }: { .message }\"\n            }\n        }\n        CX::Vaya.new( message => \"I messed up!\" ).throw;\n\n    }\n    ea;\n    # OUTPUT: «Controlled CX::Vaya: I messed up!␤»\n","t":"X::Control","n":"X::Control","b":"C"},{"b":"A","a":[{"n":"$.symbol","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Export::NameClash\n\nSUBTITLE\nCompilation error due to exporting the same symbol twice\n\n    class X::Export::NameClash does X::Comp { }\n\nCompile time error thrown when a symbol is exported twice.\n\nFor example\n\n    sub f() is export { };\n    {\n        sub f() is export { }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    A symbol '&f' has already been exported\n\n\n","t":"X::Export::NameClash","n":"X::Export::NameClash","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"d":"Returns the symbol that is exported twice.","n":"symbol","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"]},{"n":"X::WheneverOutOfScope","a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::WheneverOutOfScope","mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"k":"c","b":"A"},{"b":"A","mro":["X::Comp","Exception"],"m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"feature"},{"n":"use","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"k":"c","n":"X::Experimental","a":[{"n":"$.feature","t":"Mu","k":"v"},{"k":"v","n":"$.use","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Experimental"},{"b":"A","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["X::Comp","Exception"],"t":"X::MultipleTypeSmiley","a":[{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::MultipleTypeSmiley"},{"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"operator","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"side"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"a":[{"n":"&.operator","t":"Callable","k":"v"},{"t":"Mu","n":"$.side","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::HyperOp::Infinite","n":"X::HyperOp::Infinite","b":"A"},{"m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"operator","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"left-elems"},{"n":"right-elems","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"recursing","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["Exception"],"a":[{"k":"v","n":"&.operator","t":"Callable"},{"n":"$.left-elems","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.right-elems"},{"n":"$.recursing","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::HyperOp::NonDWIM","n":"X::HyperOp::NonDWIM","b":"A"},{"b":"A","t":"X::Cannot::Lazy","a":[{"n":"$.action","t":"Mu","k":"v"},{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Cannot::Lazy","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"action"},{"n":"what","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"mro":["Exception"]},{"n":"X::Cannot::Map","a":[{"n":"$.what","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.using"},{"k":"v","t":"Mu","n":"$.suggestion"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Cannot::Map","mro":["Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"what"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"using"},{"n":"suggestion","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"junction","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"for","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Cannot::Junction","t":"X::Cannot::Junction","a":[{"n":"$.junction","t":"Mu","k":"v"},{"n":"$.for","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}]},{"a":[{"k":"v","n":"$.what","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Cannot::Capture","n":"X::Cannot::Capture","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"what","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Exception"],"b":"A"},{"b":"A","mro":["Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"class"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"X::Cannot::New","a":[{"n":"$.class","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Cannot::New"},{"a":[{"k":"v","t":"Mu","n":"$.action"},{"k":"v","t":"Mu","n":"$.what"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Cannot::Empty","n":"X::Cannot::Empty","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"action"},{"n":"what","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["Exception"],"b":"A"},{"n":"X::Lock::ConditionVariable::New","t":"X::Lock::ConditionVariable::New","a":[{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"}],"b":"A"},{"b":"A","mro":["Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"n":"X::Lock::Async::NotLocked","a":[{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Lock::Async::NotLocked"},{"a":[{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Seq::Consumed\n\nSUBTITLE\nError due to trying to reuse a consumed sequence\n\n    class X::Seq::Consumed is Exception { }\n\nThis exception is thrown when a piece of code tries to reuse a Seq which\nhas already been iterated.","t":"X::Seq::Consumed","n":"X::Seq::Consumed","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0}],"mro":["Exception"],"b":"A"},{"n":"X::Seq::NotIndexable","a":[{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Seq::NotIndexable","mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"}],"b":"A"},{"n":"X::TooManyDimensions","t":"X::TooManyDimensions","a":[{"n":"$.operation","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.got-dimensions"},{"k":"v","t":"Mu","n":"$.needed-dimensions"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"operation"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"got-dimensions"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"needed-dimensions"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","b":"A"},{"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"d":"method proc(X::Proc::Unsuccessful:D --> Proc)\n\nReturns the object that threw the exception.","n":"proc","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Exception"],"a":[{"n":"$.proc","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Proc::Unsuccessful","d":"TITLE\nclass X::Proc::Unsuccessful\n\nSUBTITLE\nException thrown if a Proc object is sunk after the process it ran exited\nunsuccessfully\n\n    class X::Proc::Unsuccessful is Exception {}\n\n","n":"X::Proc::Unsuccessful","b":"A"},{"b":"C","n":"X::Proc::Async","a":[{"n":"$.proc","t":"Proc::Async","k":"v"}],"t":"X::Proc::Async","d":"TITLE\nrole X::Proc::Async\n\nSUBTITLE\nException thrown by Proc::Async\n\n    role X::Proc::Async is Exception { ... }\n\nAll exceptions thrown by Proc::Async do this common role.\n\n","mro":[],"k":"ro"},{"b":"A","d":"TITLE\nclass X::Proc::Async::MustBeStarted\n\nSUBTITLE\nError due to interacting with a Proc::Async stream before spawning its\nprocess\n\n    class X::Proc::Async::MustBeStarted is Exception {}\n\nSeveral methods from Proc::Async expect that the external program has been\nspawned (by calling .start on it), including say, write, print and\nclose-stdin. If one of those methods is called before .start was called,\nthey throw an exception of type X::Proc::Async::MustBeStarted.\n\n    Proc::Async.new('echo', :w).say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::MustBeStarted: Process must be started first before calling 'say'␤»\n\n","a":[{"k":"v","n":"$.method","t":"Mu"},{"n":"$.proc","t":"Proc::Async","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Proc::Async::MustBeStarted","n":"X::Proc::Async::MustBeStarted","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"method","d":"method method(X::Proc::Async::MustBeStarted:D --> Str:D)\n\nReturns the name of the method that was illegally called before starting\nthe external program.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"proc","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Proc::Async","Exception"]},{"b":"A","mro":["X::Proc::Async","Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"proc","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Proc::Async::SupplyOrStd","t":"X::Proc::Async::SupplyOrStd","a":[{"t":"Proc::Async","n":"$.proc","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}]},{"b":"A","a":[{"k":"v","n":"$.handle","t":"Mu"},{"k":"v","t":"Proc::Async","n":"$.proc"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Proc::Async::TapBeforeSpawn","d":"TITLE\nclass X::Proc::Async::TapBeforeSpawn\n\nSUBTITLE\nError due to tapping a Proc::Async stream after spawning its process\n\n    class X::Proc::Async::TapBeforeSpawn is Exception {}\n\nIf the stdout or stderr methods of Proc::Async are called after the program\nhas been started, an exception of type X::Proc::Async::TapBeforeSpawn is\nthrown.\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.start;\n    $proc.stdout.tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::TapBeforeSpawn: To avoid data races, you must tap stdout before running the process␤»\n\nThe right way is the reverse order\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.stdout.tap(&print);\n    await $proc.start;\n\n","n":"X::Proc::Async::TapBeforeSpawn","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"handle","d":"method handle(X::Proc::Async::TapBeforeSpawn:D: --> Str:D)\n\nReturns the name of the handle (stdout or stderr) that was accessed after\nthe program started.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"proc","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","mro":["X::Proc::Async","Exception"]},{"n":"X::Proc::Async::BindOrUse","a":[{"n":"$.handle","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.use"},{"n":"$.proc","t":"Proc::Async","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Proc::Async::BindOrUse\n\nSUBTITLE\nError due to trying to bind a handle that is also used\n\n        class X::Proc::Async::BindOrUse does X::Proc::Async {}\n\n\nIn general, it occurs when there's some mistake in the direction the stream\nflows, for instance:\n\n    my $p = Proc::Async.new(\"ls\", :w);\n    my $h = \"ls.out\".IO.open(:w);\n    $p.bind-stdin($h);\n    # Fails with OUTPUT: «Cannot both bind stdin to a handle and also use :w␤»\n\n\nIn this case, stdin is already bound and cannot be used again; one of them\nshould flow :out and the other one :w to work correctly.","t":"X::Proc::Async::BindOrUse","mro":["X::Proc::Async","Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"handle","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"use"},{"n":"proc","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"b":"A"},{"m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"proc","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Proc::Async","Exception"],"a":[{"n":"$.proc","t":"Proc::Async","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Proc::Async::AlreadyStarted","d":"TITLE\nclass X::Proc::Async::AlreadyStarted\n\nSUBTITLE\nError due to calling start on an already started Proc::Async object\n\n    class X::Proc::Async::AlreadyStarted is Exception {}\n\nWhen you call start twice on the same Proc::Async object, the second\ninvocation will die with an X::Proc::Async::AlreadyStarted exception.\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.start;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::AlreadyStarted: Process has already been started␤»","n":"X::Proc::Async::AlreadyStarted","b":"A"},{"b":"A","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"d":"method handle(X::Proc::Async::CharsOrBytes:D: --> Str:D)\n\nReturns the name of the handle that was accessed both for text and for\nbinary data, stdout or stderr.","n":"handle","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"proc","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Proc::Async","Exception"],"a":[{"n":"$.handle","t":"Mu","k":"v"},{"k":"v","n":"$.proc","t":"Proc::Async"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Proc::Async::CharsOrBytes\n\nSUBTITLE\nError due to tapping the same Proc::Async stream for both text and binary\nreading\n\n    class X::Proc::Async::CharsOrBytes is Exception {}\n\nA Proc::Async object allows subscription to the output or error stream\neither for bytes (Blob) or for text data (Str), but not for both. If you do\ntry both, it throws an exception of type X::Proc::Async::CharsOrBytes.\n\n    my $proc = Proc::Async.new('echo');\n    $proc.stdout.tap(&print);\n    $proc.stdout(:bin).tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::CharsOrBytes: Can only tap one of chars or bytes supply for stdout␤»\n\n","t":"X::Proc::Async::CharsOrBytes","n":"X::Proc::Async::CharsOrBytes"},{"b":"A","d":"TITLE\nclass X::Proc::Async::OpenForWriting\n\nSUBTITLE\nError due to writing to a read-only Proc::Async object\n\n    class X::Proc::Async::OpenForWriting is Exception {}\n\nWhen a Proc::Async object is opened only for reading from the external\nprogram (no :w passed to open), and a write operation such as write, print\nand say is performed, an exception of type X::Proc::Async::OpenForWriting\nis thrown:\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::OpenForWriting: Process must be opened for writing with :w to call 'say'␤»\n\nTo fix that you can use writable commands with :w flag:\n\n    my $prog = Proc::Async.new(:w, 'cat');\n    $prog.stdout.tap( -> $str {\n        print $str;\n    });\n    my $promise = $prog.start;\n    await $prog.say('foo');\n    $prog.close-stdin;\n    await $promise;\n\n","a":[{"k":"v","t":"Mu","n":"$.method"},{"n":"$.proc","t":"Proc::Async","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Proc::Async::OpenForWriting","n":"X::Proc::Async::OpenForWriting","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"d":"method method(X::Proc::Async::OpenForWriting:D:)\n\nReturns the method name that was called and which caused the exception.","n":"method","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"proc"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::Proc::Async","Exception"]},{"b":"A","a":[{"n":"$.action","t":"Mu","k":"v"},{"n":"$.target-shape","t":"Mu","k":"v"},{"t":"Mu","n":"$.source-shape","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::ArrayShapeMismatch","n":"X::ArrayShapeMismatch","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"action","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"target-shape","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"source-shape","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["Exception"]},{"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"channel","d":"method Channel(X::Channel::SendOnClosed:D: --> Channel:D)\n\nReturns the Channel object on which the send method was called."},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Exception"],"a":[{"n":"$.channel","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Channel::SendOnClosed","d":"TITLE\nclass X::Channel::SendOnClosed\n\nSUBTITLE\nError due to calling send on a closed channel\n\n    class X::Channel::SendOnClosed {}\n\nThis exception is thrown when a calling send on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.send(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n\n","n":"X::Channel::SendOnClosed","b":"A"},{"b":"A","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"channel","d":"method Channel(X::Channel::ReceiveOnClosed:D: --> Channel:D)\n\nReturns the Channel object on which the receive method was called.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","n":"X::Channel::ReceiveOnClosed","d":"TITLE\nclass X::Channel::ReceiveOnClosed\n\nSUBTITLE\nError due to calling receive on a closed channel\n\n    class X::Channel::ReceiveOnClosed {}\n\nThis exception is thrown when a calling receive on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.receive;     # Cannot receive a message on a closed channel\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::ReceiveOnClosed: Cannot receive a message on a closed channel␤»\n\n","a":[{"t":"Mu","n":"$.channel","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Channel::ReceiveOnClosed"},{"b":"A","n":"X::Caller::NotDynamic","a":[{"k":"v","t":"Mu","n":"$.symbol"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Caller::NotDynamic","d":"TITLE\nclass X::Caller::NotDynamic\n\nSUBTITLE\nError while trying to access a non dynamic variable through CALLER\n\n    class X::Caller::NotDynamic is Exception { }\n\nThrown when trying to access a non dynamic variable through CALLER\n\nA typical error message is\n\n    Cannot access '$x' through CALLER, because it is not declared as dynamic\n\n\n","mro":["Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Returns the name of the symbol that was passed to CALLER.","n":"symbol"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c"},{"b":"A","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"version"},{"n":"modifier","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","mro":["Exception"],"t":"X::Language::ModRequired","a":[{"t":"Mu","n":"$.version","k":"v"},{"n":"$.modifier","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Language::ModRequired"},{"b":"A","k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"version","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["Exception"],"t":"X::Language::Unsupported","a":[{"k":"v","t":"Mu","n":"$.version"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Language::Unsupported"},{"b":"A","mro":["Exception"],"k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}}],"n":"X::Language::TooLate","a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Language::TooLate"},{"b":"A","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"t":"X::LibEmpty","a":[{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::LibEmpty"},{"d":"TITLE\nrole X::Temporal\n\nSUBTITLE\nError related to DateTime or Date\n\n    role X::Temporal is Exception { }\n\nA common exception type for all errors related to DateTime or Date.","t":"X::Temporal","n":"X::Temporal","k":"ro","mro":[],"b":"C"},{"b":"A","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"Returns the invalid format string (12/25/2015 in the example above)","n":"invalid-str","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Returns the target type (Date in the example above)","n":"target"},{"n":"format","d":"Returns valid format strings for the target type in question, (yyyy-mm-dd\nin the example above)","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Temporal","Exception"],"a":[{"n":"$.invalid-str","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.target"},{"k":"v","t":"Mu","n":"$.format"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Temporal::InvalidFormat\n\nSUBTITLE\nError due to using an invalid format when creating a DateTime or Date\n\n    class X::Temporal::InvalidFormat does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime or Date\nobject using an invalid format.\n\n    my $dt = Date.new(\"12/25/2015\");\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Temporal::InvalidFormat: Invalid Date string '12/25/2015'; use yyyy-mm-dd instead␤»\n\n\n","t":"X::Temporal::InvalidFormat","n":"X::Temporal::InvalidFormat"},{"b":"A","a":[{"k":"v","n":"$.type","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::TooLateForREPR","n":"X::TooLateForREPR","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"type","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"mro":["X::Comp","X::Comp"]},{"n":"X::Str::Subst::Adverb","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$.got","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Str::Subst::Adverb","mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"name"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"got"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","mro":["Exception"],"m":[{"n":"source-indicator","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method source(--> Str:D)\n\nReturns the string that was attempted to convert to a number","n":"source"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos","d":"method pos(--> Int:D)\n\nGives the position into the string where the parsing failed."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method reason(--> Int:D)\n\nVerbal description of the reason why the conversion failed.","n":"reason"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","n":"X::Str::Numeric","a":[{"k":"v","t":"Mu","n":"$.source"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.reason","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Str::Numeric","d":"TITLE\nclass X::Str::Numeric\n\nSUBTITLE\nError while trying to coerce a string to a number\n\n    class X::Str::Numeric is Exception { }\n\nError thrown (or wrapped in a Failure) when a conversion from string to a\nnumber fails.\n\nFor example\n\n    say +\"42 answers\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Str::Numeric: Cannot convert string to number: trailing characters after number in '42⏏ answers' (indicated by ⏏)␤»\n\n"},{"n":"X::Str::InvalidCharName","t":"X::Str::InvalidCharName","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"name"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"type"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"directive"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"expected"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"value"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["Exception"],"a":[{"k":"v","n":"$.type","t":"str"},{"k":"v","t":"str","n":"$.directive"},{"n":"$.expected","t":"str","k":"v"},{"t":"Mu","n":"$.value","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Str::Sprintf::Directives::BadType","n":"X::Str::Sprintf::Directives::BadType"},{"n":"X::Str::Sprintf::Directives::Count","a":[{"t":"int","n":"$.args-used","k":"v"},{"k":"v","n":"$.args-have","t":"num"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Str::Sprintf::Directives::Count","mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"args-used","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"args-have","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","n":"X::Str::Sprintf::Directives::Unsupported","a":[{"k":"v","n":"$.directive","t":"str"},{"k":"v","n":"$.sequence","t":"str"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Str::Sprintf::Directives::Unsupported","mro":["Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"directive"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"sequence"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}]},{"b":"A","a":[{"k":"v","n":"$.key","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Str::Trans::IllegalKey","n":"X::Str::Trans::IllegalKey","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"key","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["Exception"]},{"b":"A","n":"X::Str::Trans::InvalidArg","a":[{"n":"$.got","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Str::Trans::InvalidArg","mro":["Exception"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"got"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c"},{"n":"X::Str::Match::x","t":"X::Str::Match::x","a":[{"t":"Mu","n":"$.got","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"got"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"b":"A","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"method what(--> Str:D)\n\nVerbal description of the thing that was out of range (e.g. \"array index\",\n\"month\").","n":"what","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method got()\n\nReturns the object that was considered out of range (often an integer)","n":"got"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"range","d":"method range(--> Range:D)\n\nReturns a Range object describing the permissible range for the object\nreturned from .got."},{"n":"comment","d":"method comment(--> Str)\n\nReturns an additional comment that is included in the error message.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"mro":["Exception"],"a":[{"n":"$.what","t":"Mu","k":"v"},{"k":"v","n":"$.got","t":"Mu"},{"k":"v","t":"Mu","n":"$.range"},{"n":"$.comment","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::OutOfRange\n\nSUBTITLE\nError due to indexing outside of an allowed range\n\n    class X::OutOfRange is Exception { }\n\nGeneral error when something (for example an array index) is out of an\nallowed range.\n\nFor example\n\n    say 42[2];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::OutOfRange: Index out of range. Is: 2, should be in 0..0␤»\n\nsince scalars generally act as a one-element list.\n\n","t":"X::OutOfRange","n":"X::OutOfRange"},{"b":"A","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"symbol","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["Exception"],"t":"X::NoSuchSymbol","a":[{"n":"$.symbol","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::NoSuchSymbol"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"package-kind","d":"method package-kind(--> Str:D)\n\nReturns the kind of package (class, grammar) that is being tried to\naugment","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"d":"Returns the name that was tried to augment, but which doesn't exist.","n":"package","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","Exception"],"a":[{"t":"Mu","n":"$.package-kind","k":"v"},{"k":"v","n":"$.package","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Augment::NoSuchType","d":"TITLE\nclass X::Augment::NoSuchType\n\nSUBTITLE\nCompilation error due to augmenting a non-existing type\n\n    class X::Augment::NoSuchType does X::Comp { }\n\nThrown when trying to augment a type which doesn't exist.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class NoSuch { }\n\n\ndies with\n\n    You tried to augment class NoSuch, but it does not exist\n\n\n","n":"X::Augment::NoSuchType"},{"n":"X::Eval::NoSuchLang","a":[{"n":"$.lang","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Eval::NoSuchLang\n\nSUBTITLE\nError due to specifying an unknown language for EVAL\n\n    class X::Eval::NoSuchLang is Exception { }\n\nError thrown when EVAL($str, :$lang) specifies a language that the compiler\ndoes not know how to handle.\n\nFor example\n\n    EVAL 'boo', lang => \"bar\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Eval::NoSuchLang: No compiler available for language 'bar'␤»\n\n","t":"X::Eval::NoSuchLang","mro":["Exception"],"k":"c","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"lang","d":"method lang()\n\nReturns the language that EVAL did not know how to handle.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"b":"A"},{"a":[{"k":"v","n":"$.aggregate","t":"Mu"},{"t":"Mu","n":"$.index","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Item","n":"X::Item","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"aggregate"},{"n":"index","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["Exception"],"b":"A"},{"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"n":"what","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.what","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Value::Dynamic","n":"X::Value::Dynamic","b":"A"},{"n":"X::Dynamic::NotFound","a":[{"n":"$.name","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Dynamic::NotFound","d":"TITLE\nclass X::Dynamic::NotFound\n\nSUBTITLE\nRuntime error thrown when a dynamic variable does not exist\n\n    class X::Dynamic::NotFound is Exception {}\n\nThis exception is raised when a dynamic variable that has not been declared\nis used.\n\n    $*dynamic-not-found = 33;\n    # OUTPUT: «Dynamic variable $*dynamic-not-found not found␤»\n\n\n","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"name","d":"method name(--> Str:D)\n\nReturns the name of the variable that has not been found."},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","b":"A"},{"b":"A","t":"X::Dynamic::Package","a":[{"k":"v","n":"$.symbol","t":"Mu"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Dynamic::Package","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"symbol"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"]},{"m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"symbol"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.symbol"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Dynamic::Postdeclaration","n":"X::Dynamic::Postdeclaration","b":"A"},{"b":"A","mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"type"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","n":"X::Constructor::Positional","a":[{"n":"$.type","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Constructor::Positional\n\nSUBTITLE\nError due to passing positional arguments to a default constructor\n\n    class X::Constructor::Positional is Exception { }\n\nThrown from Mu.new when positional arguments are passed to it.\n\nFor example\n\n    class A { };\n    A.new(2, 3);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Constructor::Positional: Default constructor for 'A' only takes named arguments␤»","t":"X::Constructor::Positional"},{"b":"C","k":"ro","mro":[],"t":"X::Encoding","n":"X::Encoding"},{"t":"X::Encoding::Unknown","a":[{"k":"v","t":"Mu","n":"$.name"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Encoding::Unknown","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"name"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Encoding","Exception"],"b":"A"},{"b":"A","n":"X::Encoding::AlreadyRegistered","a":[{"t":"Mu","n":"$.name","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Encoding::AlreadyRegistered","mro":["X::Encoding","Exception"],"k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"name","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}]},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::LibNone","n":"X::LibNone","b":"A"},{"b":"A","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"variable_name","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"placeholder","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"decl","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"mro":["X::Comp","Exception"],"t":"X::Placeholder::NonPlaceholder","a":[{"k":"v","t":"Mu","n":"$.variable_name"},{"n":"$.placeholder","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.decl"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Placeholder::NonPlaceholder"},{"a":[{"n":"$.placeholder","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Placeholder::Attribute","n":"X::Placeholder::Attribute","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::Comp","X::Placeholder::Block"],"b":"A"},{"a":[{"t":"Mu","n":"$.placeholder","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Placeholder::Mainline","d":"TITLE\nclass X::Placeholder::Mainline\n\nSUBTITLE\nCompilation error due to a placeholder in the mainline\n\n    class X::Placeholder::Mainline is X::Placeholder::Block { }\n\nThrown when a placeholder variable is used in the mainline, i.e. outside of\nany explicit block.\n\nFor example\n\n    $^x;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use placeholder parameter $^x outside of a sub or block\n\n\nNote that this error can also occur when you think something is a block,\nbut it really is a postcircumfix:<{ }>, for example\n\n    my %h;\n    say %h{ $^x };\n    #     ^^^^^^^  not a block, so $^x is part of the mainline\n","n":"X::Placeholder::Mainline","k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["X::Comp","X::Placeholder::Block"],"b":"A"},{"b":"A","n":"X::Placeholder::Block","a":[{"k":"v","t":"Mu","n":"$.placeholder"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Placeholder::Block","d":"TITLE\nclass X::Placeholder::Block\n\nSUBTITLE\nCompilation error due to a placeholder in an ineligible block\n\n    class X::Placeholder::Block does X::Comp {}\n\nThrown when a placeholder variable is used in a block that does not allow a\nsignature.\n\nFor example\n\n    class A { $^foo }\n\n\ndies with\n\n    Placeholder variable $^foo may not be used here because the surrounding block takes no signature\n\n\n","mro":["X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Returns the name of the (first) illegally used placeholder.","n":"placeholder","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}]},{"b":"A","mro":["Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Str","p":["*%_"]}}],"n":"X::Scheduler::CueInNaNSeconds","t":"X::Scheduler::CueInNaNSeconds","a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Scheduler::CueInNaNSeconds\n\nSUBTITLE\nError caused by passing NaN to Scheduler.cue as :at, :in, or :every\n\n    class X::Scheduler::CueInNaNSeconds is Exception { }\n\nWhen calling ThreadPoolScheduler.cue or CurrentThreadScheduler.cue with\n:at, :in, or :every as NaN, this exception gets thrown. For example, the\nfollowing code:\n\n    my Cancellation $c = $*SCHEDULER.cue({\n        say 'This will never output :(';\n    }, at => NaN);\n\n\nThrows with:\n\n    Cannot pass NaN as a number of seconds to Scheduler.cue\n\n\nThis class only exists in releases 2019.05 and later."},{"n":"X::HyperRace::Died","a":[{"t":"Mu","n":"$.start-backtrace","k":"v"}],"t":"X::HyperRace::Died","mro":[],"k":"ro","b":"C"},{"b":"A","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Returns the message including the above properties.","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"feature","d":"Returns a Str describing the missing feature."},{"n":"did-you-mean","d":"Returns a Str indicating the optional feature that is already implemented.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"It helpfully shows a possible workaround for the missing feature, if it's\nbeen declared.","n":"workaround"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"mro":["Exception"],"t":"X::NYI","a":[{"t":"Mu","n":"$.feature","k":"v"},{"k":"v","n":"$.did-you-mean","t":"Mu"},{"k":"v","n":"$.workaround","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::NYI\n\nSUBTITLE\nError due to use of an unimplemented feature\n\n    class X::NYI is Exception { }\n\nError class for unimplemented features. NYI stands for Not Yet\nImplemented.\n\nIf a Raku compiler is not yet feature complete, it may throw an X::NYI\nexception when a program uses a feature that it can detect and is somehow\nspecified is not yet implemented.\n\nA full-featured Raku compiler must not throw such exceptions, but still\nprovide the X::NYI class for compatibility reasons.\n\nA typical error message is\n\n    HyperWhatever is not yet implemented. Sorry.\n\n\n","n":"X::NYI"},{"a":[{"k":"v","n":"$.op","t":"Mu"},{"t":"Mu","n":"$.big","k":"v"},{"n":"$.side","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::NYI::BigInt","n":"X::NYI::BigInt","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"op"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"big"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"side"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["Exception"],"b":"A"},{"t":"X::NYI::Available","a":[{"n":"@.available","t":"Positional","k":"v"},{"t":"Mu","n":"$.feature","k":"v"},{"k":"v","t":"Mu","n":"$.did-you-mean"},{"k":"v","n":"$.workaround","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::NYI::Available","k":"c","m":[{"n":"available-str","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"available"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::NYI"],"b":"A"},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"dim"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["Exception"],"t":"X::IllegalDimensionInShape","a":[{"n":"$.dim","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::IllegalDimensionInShape","b":"A"},{"mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"typename"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"method"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","n":"X::Immutable","t":"X::Immutable","a":[{"t":"Mu","n":"$.typename","k":"v"},{"t":"Mu","n":"$.method","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A"},{"n":"X::Hash::Store::OddNumber","a":[{"k":"v","t":"Mu","n":"$.found"},{"n":"$.last","t":"Mu","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Hash::Store::OddNumber","mro":["Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"found","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"last","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"b":"A"},{"mro":["X::Comp","Exception"],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"method","d":"method method(--> Str:D)\n\nThe name of the private method"},{"d":"method source-package(--> Mu:D)\n\nReturns the type object that (supposedly) contains the private method.","n":"source-package","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"calling-package","d":"method calling-package(--> Mu:D)\n\nReturns the package in which the calling code is, and which the source\npackage does not trust."},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"X::Method::Private::Permission","a":[{"k":"v","t":"Mu","n":"$.method"},{"t":"Mu","n":"$.source-package","k":"v"},{"k":"v","t":"Mu","n":"$.calling-package"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Method::Private::Permission\n\nSUBTITLE\nCompilation error due to calling a private method without permission\n\n    class X::Method::Private::Permission does X::Comp { }\n\nCompile time error thrown when the code contains a call to a private method\nthat isn't defined in the current class, and when no appropriate trusts\nrelation is defined that permits the private method call.\n\nFor example\n\n    1!Int::foo\n\n\ndies with\n\n    ===SORRY!===\n    Cannot call private method 'foo' on package Int because it does not trust GLOBAL\n\n\n","t":"X::Method::Private::Permission","b":"A"},{"b":"A","t":"X::Method::Private::Unqualified","a":[{"t":"Mu","n":"$.method","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Method::Private::Unqualified\n\nSUBTITLE\nCompilation error due to an unqualified private method call\n\n    class X::Method::Private::Unqualified does X::Comp { }\n\nCompile time error thrown when a private method call on anything but self\nis not fully qualified.\n\nFor example\n\n    1!priv\n\n\ndies with\n\n    ===SORRY!===\n    Private method call to priv must be fully qualified with the package containing the method\n\n\n","n":"X::Method::Private::Unqualified","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"method","d":"method method(--> Str:D)\n\nReturns the name of the private method that triggered the error."},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"]},{"b":"A","a":[{"n":"$.method","t":"Mu","k":"v"},{"n":"$.invocant","t":"Mu","k":"v"},{"k":"v","n":"$.qualifier-type","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Method::InvalidQualifier\n\nSUBTITLE\nError due to calling a qualified method from an ineligible class\n\n    class X::Method::InvalidQualifier is Exception { }\n\nThrown when a method is call in the form $invocant.TheClass::method if\n<$invocant> does not conform to TheClass.\n\nFor example\n\n    1.Str::split(/a/);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::InvalidQualifier: Cannot dispatch to method split on Str because it is not inherited or done by Int␤»\n\n","t":"X::Method::InvalidQualifier","n":"X::Method::InvalidQualifier","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method method(--> Str:D)\n\nReturns the name of the (unqualified) method.","n":"method"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Returns the invocant of the failed, qualified method call","n":"invocant"},{"n":"qualifier-type","d":"Returns the type by which the method call was qualified.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Exception"]},{"mro":["Exception"],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"invocant","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method method(--> Str:D)\n\nReturns the method name that was invoked.","n":"method"},{"d":"method typename(--> Str:D)\n\nReturns the name of the invocant type.","n":"typename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method private(--> Bool:D)\n\nReturns True for private methods, and False for public methods.","n":"private"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"addendum","d":"method addendum(--> Str:D)\n\nReturns additional explanations or hints.\n\nNote: addendum was introduced in Rakudo 2019.03."},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","n":"X::Method::NotFound","d":"TITLE\nclass X::Method::NotFound\n\nSUBTITLE\nError due to calling a method that isn't there\n\n    class X::Method::NotFound is Exception {}\n\nThrown when the user tries to call a method that isn't there.\n\nFor example\n\n    1.no-such\n\n\nthrows\n\n    No such method 'no-such' for invocant of type 'Int'\n\n\n","a":[{"k":"v","n":"$.invocant","t":"Mu"},{"k":"v","t":"Mu","n":"$.method"},{"k":"v","t":"Mu","n":"$.typename"},{"t":"Bool","n":"$.private","k":"v"},{"k":"v","n":"$.addendum","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Method::NotFound","b":"A"},{"b":"A","mro":["Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"type","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"n":"X::MustBeParametric","a":[{"k":"v","t":"Mu","n":"$.type"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::MustBeParametric"},{"b":"C","n":"X::Syntax","t":"X::Syntax","d":"TITLE\nrole X::Syntax\n\nSUBTITLE\nSyntax error thrown by the compiler\n\n    role X::Syntax does X::Comp { }\n\nCommon role for syntax errors thrown by the compiler.","mro":[],"k":"ro"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"varname","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"vartype","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"value"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"valuetype"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"suggestiontype"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"native"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","n":"X::Syntax::Number::LiteralType","a":[{"n":"$.varname","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.vartype"},{"t":"Mu","n":"$.value","k":"v"},{"k":"v","n":"$.valuetype","t":"Mu"},{"k":"v","t":"Mu","n":"$.suggestiontype"},{"k":"v","n":"$.native","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Number::LiteralType"},{"b":"A","n":"X::Syntax::Number::RadixOutOfRange","d":"TITLE\nclass X::Syntax::Number::RadixOutOfRange\n\nSUBTITLE\nCompilation error due to an unallowed radix in a number literal\n\n    class X::Syntax::Number::RadixOutOfRange does X::Syntax { }\n\nSyntax error that is thrown when the radix of a radix number is not\nallowed, like :1<1>  or :42<ouch> .\n\n","a":[{"k":"v","n":"$.radix","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Number::RadixOutOfRange","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method radix(--> Int:D)\n\nThe offensive radix.","n":"radix"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}]},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"n":"X::Syntax::Number::IllegalDecimal","a":[{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Number::IllegalDecimal","b":"A"},{"mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"d":"method what(X::Syntax::Malformed:D: --> Str)\n\nReturns a description of the thing that was being parsed.","n":"what","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"X::Syntax::Malformed","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Syntax::Malformed\n\nSUBTITLE\nCompilation error due to a malformed construct (usually a declarator)\n\n    class X::Syntax::Malformed does X::Syntax {}\n\nThe Raku compiler throws errors of type X::Syntax::Malformed when it knows\nwhat kind of declaration it is parsing, and encounters a syntax error, but\ncan't give a more specific error message.\n\n    my Int a;   # throws an X::Syntax::Malformed\n\n\nproduces\n\n    ===SORRY!===\n    Malformed my\n    at -e:1\n    ------> my Int ⏏a\n\n\n","t":"X::Syntax::Malformed","b":"A"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"what"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::Malformed::Elsif","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Malformed::Elsif"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.meta"},{"t":"Mu","n":"$.operator","k":"v"},{"k":"v","n":"$.reason","t":"Mu"},{"n":"$.dba","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::CannotMeta","n":"X::Syntax::CannotMeta","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"meta","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"operator","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"reason","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"dba","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","t":"X::Syntax::KeywordAsFunction","a":[{"n":"$.word","t":"Mu","k":"v"},{"t":"Mu","n":"$.needparens","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::KeywordAsFunction","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"word"},{"n":"needparens","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"]},{"mro":["X::Syntax","X::Comp","Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"second-part","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","n":"X::Syntax::ConditionalOperator::SecondPartInvalid","a":[{"k":"v","n":"$.second-part","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::ConditionalOperator::SecondPartInvalid","b":"A"},{"b":"A","k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::ConditionalOperator::SecondPartGobbled","n":"X::Syntax::ConditionalOperator::SecondPartGobbled"},{"n":"X::Syntax::ConditionalOperator::PrecedenceTooLoose","a":[{"k":"v","t":"Mu","n":"$.operator"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::ConditionalOperator::PrecedenceTooLoose","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"operator"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","b":"A"},{"t":"X::Syntax::NonListAssociative","a":[{"n":"$.left","t":"Mu","k":"v"},{"k":"v","n":"$.right","t":"Mu"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::NonListAssociative","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","X::Syntax::NonAssociative"],"b":"A"},{"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"call"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::VirtualCall","a":[{"k":"v","t":"Mu","n":"$.call"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::VirtualCall","b":"A"},{"b":"A","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"keyword"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"n":"$.keyword","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::UnlessElse","d":"TITLE\nclass X::Syntax::UnlessElse\n\nSUBTITLE\nCompilation error due to an unless clause followed by else\n\n    class X::Syntax::UnlessElse does X::Syntax { }\n\nSyntax error thrown when an unless clause is followed by an else clause.\n\nFor example\n\n    unless 1 { } else { };\n\n\ndies with\n\n    ===SORRY!===\n    \"unless\" does not take \"else\", please rewrite using \"if\"\n","n":"X::Syntax::UnlessElse"},{"n":"X::Syntax::NegatedPair","t":"X::Syntax::NegatedPair","a":[{"t":"Mu","n":"$.key","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Syntax::NegatedPair\n\nSUBTITLE\nCompilation error due to passing an argument to a negated colonpair\n\n    class X::Syntax::NegatedPair does X::Syntax { }\n\nThrown if a colonpair illegally has a value, for example :!a(1). This is an\nerror because the ! negation implies that the value is False.\n\nA typical error message from this class is Argument not allowed on negated\npair with key 'a'.\n\n","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"key","d":"Returns the key of the pair that caused the error.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","b":"A"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::Syntax::Self::WithoutObject","d":"TITLE\nclass X::Syntax::Self::WithoutObject\n\nSUBTITLE\nCompilation error due to invoking self in an ineligible scope\n\n    class X::Syntax::Self::WithoutObject does X::Syntax { }\n\nSyntax error thrown when self is referenced in a place where no invocant is\navailable.\n\nFor example\n\n    self;\n\n\noutside a class or role declaration dies with\n\n    ===SORRY!===\n    'self' used where no object is available\n","a":[{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Self::WithoutObject"},{"a":[{"t":"Mu","n":"$.reserved","k":"v"},{"k":"v","t":"Mu","n":"$.instead"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Syntax::Reserved\n\nSUBTITLE\nCompilation error due to use of syntax reserved for future use\n\n    class X::Syntax::Reserved does X::Syntax { }\n\nSyntax error thrown when a syntax is used which is reserved for future\nexpansion.\n\nFor example\n\n    my @a();\n\n\ndies with\n\n    ===SORRY!===\n    The () shape syntax in array declarations is reserved\n\n\n","t":"X::Syntax::Reserved","n":"X::Syntax::Reserved","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"reserved","d":"method reserved(--> Str:D)\n\nReturns a text description of the reserved syntax.","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"instead","d":"method instead(--> Str)\n\nDescribes what to use instead of the reserved syntax (if anything).","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"column"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"b":"A","a":[{"t":"Mu","n":"$.name","k":"v"},{"t":"Mu","n":"$.identifier-name","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Syntax::Perl5Var\n\nSUBTITLE\nCompilation error due to use of Perl 5-only default variables\n\n    class X::Syntax::Perl5Var does X::Syntax { }\n\nSyntax error thrown when some piece of code tries to use one of the old\nPerl 5 variables (and it does not error for some other reason).\n\n    say $];\n\n\ndies with\n\n    Unsupported use of $] variable; in Raku please use $*PERL.version or $*PERL.compiler.version\n\n\nFor every unsupported variable (which include most $^'letter' constructs,\nas well as others like $\", the error message will mention that the variable\nis unsupported and the equivalent commands you could use.","t":"X::Syntax::Perl5Var","n":"X::Syntax::Perl5Var","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"name"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"identifier-name"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Syntax","X::Comp","Exception"]},{"a":[{"n":"$.char","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Regex::Unspace","n":"X::Syntax::Regex::Unspace","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"char"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"t":"X::Syntax::Regex::Unterminated","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Regex::Unterminated","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"b":"A","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::NonQuantifiable","a":[{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Syntax::Regex::NonQuantifiable"},{"b":"A","n":"X::Syntax::Regex::UnrecognizedMetachar","t":"X::Syntax::Regex::UnrecognizedMetachar","a":[{"t":"Mu","n":"$.metachar","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"metachar","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c"},{"b":"A","n":"X::Syntax::Regex::UnrecognizedModifier","t":"X::Syntax::Regex::UnrecognizedModifier","a":[{"n":"$.modifier","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modifier"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"column"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c"},{"mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"adverb","d":"method adverb(--> Str:D)\n\nReturns the illegally used adverb"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"method construct(--> Str:D)\n\nReturns the name of the construct that adverb was used on (m, ms, rx, s,\nss).","n":"construct"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","n":"X::Syntax::Regex::Adverb","a":[{"n":"$.adverb","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.construct"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Regex::Adverb","d":"TITLE\nclass X::Syntax::Regex::Adverb\n\nSUBTITLE\nCompilation error due to an unrecognized regex adverb\n\n    class X::Syntax::Regex::Adverb does X::Syntax { }\n\nSyntax error thrown when an unrecognized or illegal regex adverb is\nencountered.\n\nFor example\n\n    rx:g/a/\n\n\ndies with\n\n    ===SORRY!===\n    Adverb g not allowed on rx\n\n\nbecause :g belongs to a match operation, not a regex itself.\n\n","b":"A"},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Syntax::Regex::SolitaryQuantifier","a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Regex::SolitaryQuantifier","d":"TITLE\nclass X::Syntax::Regex::SolitaryQuantifier\n\nSUBTITLE\nCompilation error due to a regex quantifier without preceding atom\n\n    class X::Syntax::Regex::SolitaryQuantifier does X::Syntax { }\n\nSyntax error when a stand alone quantifier (without a preceding atom to\nquantify) is encountered in a regular expression.\n\nFor example\n\n    / * /;\n\n\ndies with\n\n    ===SORRY!===\n    Quantifier quantifies nothing\n","b":"A"},{"n":"X::Syntax::Regex::SpacesInBareRange","t":"X::Syntax::Regex::SpacesInBareRange","a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"column"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","b":"A"},{"n":"X::Syntax::Regex::QuantifierValue","t":"X::Syntax::Regex::QuantifierValue","a":[{"k":"v","t":"Mu","n":"$.inf"},{"k":"v","n":"$.non-numeric","t":"Mu"},{"n":"$.non-numeric-range","t":"Mu","k":"v"},{"n":"$.empty-range","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"inf","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"non-numeric"},{"n":"non-numeric-range","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"empty-range"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"b":"A"},{"n":"X::Syntax::Regex::MalformedRange","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Regex::MalformedRange","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"post","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"b":"A"},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"n":"X::Syntax::Regex::Alias::LongName","t":"X::Syntax::Regex::Alias::LongName","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A"},{"n":"X::Syntax::Regex::NullRegex","a":[{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Regex::NullRegex","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"b":"A"},{"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Regex::SolitaryBacktrackControl","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Syntax::Regex::SolitaryBacktrackControl","b":"A"},{"b":"A","n":"X::Syntax::Coercer::TooComplex","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Coercer::TooComplex","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}]},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"parent","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::ParentAsHash","t":"X::Syntax::ParentAsHash","a":[{"k":"v","t":"Mu","n":"$.parent"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}]},{"b":"A","t":"X::Syntax::Variable::MissingInitializer","a":[{"n":"$.type","t":"Mu","k":"v"},{"t":"Mu","n":"$.implicit","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Syntax::Variable::MissingInitializer","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"type","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"implicit","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"what","d":"method what returns Str:D\n\nReturns a verbal description of the kind of symbol that was declared\n(variable, parameter, attribute)."},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"n":"X::Syntax::Variable::Numeric","t":"X::Syntax::Variable::Numeric","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Syntax::Variable::Numeric\n\nSUBTITLE\nCompilation error due to declaring a numeric symbol\n\n    class X::Syntax::Variable::Numeric does X::Syntax { }\n\nSyntax error thrown when trying to declare numeric symbols.\n\nFor example\n\n    my @101;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a numeric variable\n\n\n"},{"b":"A","mro":["X::Comp","Exception"],"m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"type"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"X::Syntax::Variable::BadType","a":[{"n":"$.type","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Variable::BadType"},{"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"what"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method twigil(--> Str:D)\n\nReturns the twigil that was illegally used","n":"twigil"},{"n":"scope","d":"method scope(--> Str:D)\n\nReturns the scope that did not harmonize with the twigil.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"additional"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.what"},{"n":"$.twigil","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.scope"},{"k":"v","t":"Mu","n":"$.additional"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Variable::Twigil","d":"TITLE\nclass X::Syntax::Variable::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a declaration\n\n    class X::Syntax::Variable::Twigil does X::Syntax { }\n\nSyntax error thrown when a variable with a twigil is used in an\nincompatible declaration.\n\nFor example\n\n    my $!foo;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use ! twigil on my variable\n\n\n","n":"X::Syntax::Variable::Twigil","b":"A"},{"m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Variable::IndirectDeclaration","n":"X::Syntax::Variable::IndirectDeclaration","b":"A"},{"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"name"},{"n":"filename","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"line"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Variable::Initializer","a":[{"k":"v","t":"Mu","n":"$.name"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Syntax::Variable::Initializer","b":"A"},{"n":"X::Syntax::Variable::ConflictingTypes","a":[{"k":"v","t":"Mu","n":"$.outer"},{"k":"v","n":"$.inner","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Variable::ConflictingTypes","mro":["X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"outer"},{"n":"inner","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","n":"X::Syntax::Variable::Match","t":"X::Syntax::Variable::Match","a":[{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Syntax::Variable::Match\n\nSUBTITLE\nCompilation error due to declaring a match variable\n\n    class X::Syntax::Variable::Match does X::Syntax { }\n\nSyntax error thrown when a match variable like $<thing>  was declared.\n\nFor example\n\n    my $<thing>;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a match variable\n","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c"},{"a":[{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Missing","d":"TITLE\nclass X::Syntax::Missing\n\nSUBTITLE\nCompilation error due to a missing piece of syntax\n\n    class X::Syntax::Missing does X::Syntax { }\n\nSyntax error thrown when the previous piece of syntax requires the\nexistence of another piece of syntax, and that second piece is missing.\n\nFor example\n\n    for 1, 2, 3;\n\n\ndies with\n\n    ===SORRY!===\n    Missing block\n\n\nbecause a for that is not a statement modifier must be followed by a\nblock.\n\n","n":"X::Syntax::Missing","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method what(--> Str:D)\n\nReturns a string description of the missing syntax element.","n":"what"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"what","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Adverb","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Adverb","b":"A"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"category"},{"n":"opname","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"hint","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Extension::SpecialForm","a":[{"n":"$.category","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.opname"},{"k":"v","t":"Mu","n":"$.hint"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Extension::SpecialForm"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","n":"X::Syntax::Extension::TooComplex","a":[{"n":"$.name","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Extension::TooComplex"},{"b":"A","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"category","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"column"},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.category"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Extension::Category","n":"X::Syntax::Extension::Category"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::Extension::Null","a":[{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Extension::Null"},{"k":"c","m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Syntax::Comment::Embedded\n\nSUBTITLE\nCompilation error due to a malformed inline comment\n\n    class X::Syntax::Comment::Embedded does X::Syntax { }\n\nSyntax error thrown when #` is encountered and it is not followed by an\nopening curly brace.\n\nFor example\n\n    #`\n\n\ndies with\n\n    ===SORRY!===\n    Opening bracket is required for #` comment\n","t":"X::Syntax::Comment::Embedded","n":"X::Syntax::Comment::Embedded","b":"A"},{"b":"A","t":"X::Syntax::WithoutElse","a":[{"k":"v","t":"Mu","n":"$.keyword"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::WithoutElse","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"keyword","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"column"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Syntax","X::Comp","Exception"]},{"d":"TITLE\nclass X::Syntax::Signature::InvocantMarker\n\nSUBTITLE\nCompilation error due to a misplaced invocant marker in a signature\n\n    class X::Syntax::Signature::InvocantMarker does X::Syntax { }\n\nSyntax error when the invocant in a signature is anywhere else than after\nthe first parameter.\n\nFor example\n\n    :($a, $b: $c);\n\n\ndies with\n\n    ===SORRY!===\n    Can only use : as invocant marker in a signature after the first parameter\n\n\nSee also: Signature.","a":[{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Signature::InvocantMarker","n":"X::Syntax::Signature::InvocantMarker","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"b":"A","n":"X::Syntax::Signature::InvocantNotAllowed","t":"X::Syntax::Signature::InvocantNotAllowed","a":[{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c"},{"b":"A","n":"X::Syntax::P5","a":[{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::P5","d":"TITLE\nclass X::Syntax::P5\n\nSUBTITLE\nCompilation error due to use of Perl 5-only syntax\n\n    class X::Syntax::P5 does X::Syntax { }\n\nSyntax error thrown when some piece of code is clearly Perl 5, not Raku.\n\nFor example\n\n    for my $a (1, 2) { };\n\n\ndies with\n\n    ===SORRY!===\n    This appears to be Perl 5 code\n","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}]},{"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["X::Pod","X::Syntax","X::Comp","Exception"],"t":"X::Syntax::Pod::BeginWithoutIdentifier","a":[{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Syntax::Pod::BeginWithoutIdentifier","b":"A"},{"n":"X::Syntax::Pod::BeginWithoutEnd","a":[{"k":"v","n":"$.type","t":"Mu"},{"t":"Mu","n":"$.spaces","k":"v"},{"k":"v","t":"Mu","n":"$.instead"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::Pod::BeginWithoutEnd","mro":["X::Pod","X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"type","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"spaces","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"instead"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","t":"X::Syntax::Name::Null","a":[{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Syntax::Name::Null","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","t":"X::Syntax::NonAssociative","a":[{"n":"$.left","t":"Mu","k":"v"},{"t":"Mu","n":"$.right","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Syntax::NonAssociative","k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"left"},{"n":"right","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::Syntax","X::Comp","Exception"]},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"category"},{"n":"needs","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Syntax::AddCategorical::TooFewParts","a":[{"t":"Mu","n":"$.category","k":"v"},{"k":"v","t":"Mu","n":"$.needs"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::AddCategorical::TooFewParts","b":"A"},{"t":"X::Syntax::AddCategorical::TooManyParts","a":[{"k":"v","t":"Mu","n":"$.category"},{"k":"v","t":"Mu","n":"$.needs"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::AddCategorical::TooManyParts","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"category"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"needs"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"b":"A","d":"TITLE\nclass X::Syntax::InfixInTermPosition\n\nSUBTITLE\nCompilation error due to an infix in term position\n\n    class X::Syntax::InfixInTermPosition does X::Syntax { }\n\nSyntax error thrown when the parser expects a term, but finds an infix\noperator instead.\n\nFor example\n\n    1, => 2;\n\n\ndies with\n\n    ===SORRY!===\n    Preceding context expects a term, but found infix => instead\n\n\n","a":[{"k":"v","t":"Mu","n":"$.infix"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::InfixInTermPosition","n":"X::Syntax::InfixInTermPosition","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"d":"method infix(--> Str:D)\n\nReturns the symbol of the infix that was found in term position.","n":"infix","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"macro"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"X::Syntax::Argument::MOPMacro","a":[{"k":"v","n":"$.macro","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Argument::MOPMacro"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"what"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Syntax::BlockGobbled","t":"X::Syntax::BlockGobbled","a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"adverb"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Syntax::Type::Adverb","a":[{"n":"$.adverb","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Type::Adverb"},{"m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"d":"TITLE\nclass X::Syntax::Term::MissingInitializer\n\nSUBTITLE\nCompilation error due to declaring a term without initialization\n\n    class X::Syntax::Term::MissingInitializer does X::Syntax { }\n\nSyntax error when a term (a backslash variable) is declared without\ninitialization assignment.\n\nFor example\n\n    my \\foo;\n\n\ndies with\n\n    ===SORRY!===\n    Term definition requires an initializer\n\n\nValid code would be\n\n    my \\foo = 42;\n","a":[{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Syntax::Term::MissingInitializer","n":"X::Syntax::Term::MissingInitializer","b":"A"},{"b":"A","mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"package","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"filename"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::Syntax::Augment::Illegal","a":[{"t":"Mu","n":"$.package","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Syntax::Augment::Illegal"},{"b":"A","t":"X::Syntax::Augment::Adverb","a":[{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Syntax::Augment::Adverb","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","a":[{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Syntax::Augment::WithoutMonkeyTyping","d":"TITLE\nclass X::Syntax::Augment::WithoutMonkeyTyping\n\nSUBTITLE\nCompilation error due to augmenting a type without the MONKEY-TYPING\npragma\n\n    class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax { }\n\nCompile time error thrown when augment is used without use MONKEY-TYPING.\n\nSince augment is considered a rather unsafe and impolite action, you have\nto pre-declare your intent with the use MONKEY-TYPING; pragma.\n\nIf you don't do that, like here\n\n    augment class Int { };\n\n\nyou get the error\n\n    ===SORRY!===\n    augment not allowed without 'use MONKEY-TYPING'\n","n":"X::Syntax::Augment::WithoutMonkeyTyping","k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Syntax","X::Comp","Exception"]},{"m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"variable","d":"Returns the variable/method call that caused the error."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"t":"X::Syntax::NoSelf","a":[{"k":"v","t":"Mu","n":"$.variable"},{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Syntax::NoSelf\n\nSUBTITLE\nCompilation error due to implicitly using a self that is not there\n\n    class X::Syntax::NoSelf does X::Syntax { }\n\nCompile time error thrown when $.foo style calls are used where no invocant\nis available.\n\nFor example the code\n\n    $.meth;\n\n\nin the program body throws the error\n\n    ===SORRY!===\n    Variable $.meth used where no 'self' is available\n\n\nbecause $.meth is short for $(self.meth), and there is no self available in\nmainline.\n\n","n":"X::Syntax::NoSelf","b":"A"},{"mro":["X::Syntax","X::Comp","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"reason"},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","n":"X::Syntax::Confused","a":[{"n":"$.reason","t":"Mu","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Syntax::Confused\n\nSUBTITLE\nCompilation error due to unrecognized syntax\n\n    class X::Syntax::Confused does X::Syntax { }\n\n\nThe most general syntax error, if no more specific error message can be\ngiven.\n\nFor example\n\n    1∞\n\n\ndies with\n\n    ===SORRY!===\n    Confused\n","t":"X::Syntax::Confused","b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.prefixes"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Syntax::DuplicatedPrefix","n":"X::Syntax::DuplicatedPrefix","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"n":"prefixes","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"mro":["X::Syntax","X::Comp","Exception"],"b":"A"},{"b":"A","k":"c","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method name(--> Str:D)\n\nReturns the name that was used for more than one parameter.","n":"name"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Comp","Exception"],"a":[{"t":"Mu","n":"$.name","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Signature::NameClash","d":"TITLE\nclass X::Signature::NameClash\n\nSUBTITLE\nCompilation error due to two named parameters with the same name\n\n    my class X::Signature::NameClash does X::Comp { }\n\nCompile time error thrown when two named parameters have the same name,\npotentially through aliases.\n\nFor example\n\n    sub f(:$a, :a(:@b)) { }\n\n\ndies with\n\n    ===SORRY!===\n    Name a used for more than one named parameter\n\n\n","n":"X::Signature::NameClash"},{"b":"A","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"d":"method placeholder(--> Str:D)\n\nReturns the name of a placeholder that was used in a block that already had\na signature.","n":"placeholder","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Comp","Exception"],"a":[{"k":"v","t":"Mu","n":"$.placeholder"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Signature::Placeholder\n\nSUBTITLE\nCompilation error due to placeholders in a block with a signature\n\n    class X::Signature::Placeholder does X::Comp { }\n\n\nCompile time error thrown when a block has both an explicit signature and\nplaceholder parameters.\n\nFor example\n\n    sub f() { $^x }\n\n\ndies with\n\n    ===SORRY!===\n    Placeholder variable '$^x' cannot override existing signature\n\n\n","t":"X::Signature::Placeholder","n":"X::Signature::Placeholder"},{"b":"A","mro":["X::Comp","Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"symbol","d":"Returns the name of the symbol that was redeclared.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Returns a string that is attached to the end of the error message. It\nusually explains the particular problem in more detail, or suggests way to\nfix the problem.","n":"postfix"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"what","d":"Returns the kind of symbol that was redeclared. Usually symbol, but can\nalso be routine, type etc."},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"post"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"n":"X::Redeclaration","a":[{"n":"$.symbol","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.postfix"},{"t":"Mu","n":"$.what","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Redeclaration","d":"TITLE\nclass X::Redeclaration\n\nSUBTITLE\nCompilation error due to declaring an already declared symbol\n\n    class X::Redeclaration does X::Comp { }\n\nThrown when a symbol (variable, routine, type, parameter, ...) is\nredeclared. Note that redeclarations are generally fine in an inner scope,\nbut if the redeclaration appears in the same scope as the original\ndeclaration, it usually indicates an error and is treated as one.\n\nExamples\n\n    my $x; my $x;\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of symbol $x\n\n\nIt works with routines too:\n\n    sub f() { }\n    sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of routine f\n\n\nBut those are fine\n\n    my $x;\n    sub f() {\n        my $x;          # not a redeclaration,\n                        # because it's in an inner scope\n        sub f() { };    # same\n    }\n\n\n"},{"b":"A","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"symbol"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"filename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"],"t":"X::Redeclaration::Outer","a":[{"t":"Mu","n":"$.symbol","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Redeclaration::Outer"},{"b":"A","mro":["X::Comp","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pseudo-package"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"action"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::PseudoPackage::InDeclaration","a":[{"k":"v","n":"$.pseudo-package","t":"Mu"},{"t":"Mu","n":"$.action","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::PseudoPackage::InDeclaration"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.op"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::NQP::NotFound","n":"X::NQP::NotFound","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"op","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["Exception"]},{"k":"ro","mro":[],"d":"TITLE\nrole X::Pod\n\nSUBTITLE\nPod related error\n\n    role X::Pod { }\n\nCommon role for Pod related errors.","t":"X::Pod","n":"X::Pod","b":"C"},{"b":"A","t":"X::CompUnit::UnsatisfiedDependency","a":[{"n":"$.specification","t":"CompUnit::DependencySpecification","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::CompUnit::UnsatisfiedDependency","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"specification","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","mro":["Exception"]},{"t":"X::EXPORTHOW::InvalidDirective","a":[{"k":"v","t":"Mu","n":"$.directive"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::EXPORTHOW::InvalidDirective","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"directive"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"modules","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","Exception"],"b":"A"},{"b":"A","n":"X::EXPORTHOW::Conflict","t":"X::EXPORTHOW::Conflict","a":[{"n":"$.declarator","t":"Mu","k":"v"},{"t":"Mu","n":"$.directive","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["X::Comp","Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"declarator"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"directive"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}]},{"b":"A","n":"X::EXPORTHOW::NothingToSupersede","t":"X::EXPORTHOW::NothingToSupersede","a":[{"n":"$.declarator","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Comp","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"declarator"},{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c"},{"mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"Numeric","d":"Defined as\n\n    method Numeric()\n\nConverts the payload to Numeric and returns it"},{"m":0,"k":"m","s":{"p":["|cap is raw"],"r":"Mu"},"d":"Defined as\n\n    method from-slurpy (|cap)\n\n Creates a new exception from a capture and returns it. The capture will\nhave the SlurpySentry role mixed in, so that the .message method behaves in\na different when printing the message.\n\n    try {\n        X::AdHoc.from-slurpy( 3, False, \"Not here\" ).throw\n    };\n    print $!.payload.^name; # OUTPUT: «Capture+{X::AdHoc::SlurpySentry}»\n    print $!.message;       # OUTPUT: «3FalseNot here»\n\n\nThe SlurpySentry role joins the elements of the payload, instead of\ndirectly converting them to a string.","n":"from-slurpy"},{"d":"Returns the original object which was passed to die.","n":"payload","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"k":"c","n":"X::AdHoc","d":"TITLE\nclass X::AdHoc\n\nSUBTITLE\nError with a custom message\n\n    class X::AdHoc is Exception { }\n\n\nX::AdHoc is the type into which objects are wrapped if they are thrown as\nexceptions, but don't inherit from Exception.\n\nIts benefit over returning non-Exception objects is that it gives access to\nall the methods from class Exception, like backtrace and rethrow.\n\nYou can obtain the original object with the payload method.\n\n    try {\n        die [404, 'File not found']; # throw non-exception object\n    }\n    print \"Got HTTP code \",\n        $!.payload[0],          # 404\n        \" and backtrace \",\n        $!.backtrace.Str;\n\nNote that young code will often be prototyped using X::AdHoc and then later\nbe revised to use more specific subtypes of Exception. As such it is\nusually best not to explicitly rely on receiving an X::AdHoc – in many\ncases using the string returned by the .message method, which all\nExceptions must have, is preferable. Please note that we need to explicitly\ncall .Str to stringify the backtrace correctly.\n\n","a":[{"t":"Mu","n":"$.payload","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::AdHoc","b":"A"},{"n":"X::PoisonedAlias","a":[{"n":"$.alias","t":"Mu","k":"v"},{"k":"v","n":"$.package-type","t":"Mu"},{"k":"v","t":"Mu","n":"$.package-name"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::PoisonedAlias","mro":["X::Comp","Exception"],"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"alias"},{"n":"package-type","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"package-name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"line","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"modules"},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","mro":["Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"phaser","d":"method phaser(--> Str:D)\n\nReturns the name of the failed phaser, \"PRE\" or \"POST\"."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method condition(--> Str:D)\n\nReturns the part of the source code that describes the phaser condition.","n":"condition"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Phaser::PrePost","a":[{"k":"v","n":"$.phaser","t":"Mu"},{"k":"v","n":"$.condition","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Phaser::PrePost","d":"TITLE\nclass X::Phaser::PrePost\n\nSUBTITLE\nError due to a false return value of a PRE/POST phaser\n\n    class X::Phaser::PrePost is Exception { }\n\n\nThrown when the condition inside a PRE or POST phaser evaluate to a false\nvalue.\n\nFor example\n\n    sub f($x) { PRE { $x ~~ Int } };\n    f \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: X::Phaser::PrePost: Precondition '{ $x ~~ Int }' failed«␤»\n\n"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.block"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Phaser::Multiple\n\nSUBTITLE\nCompilation error due to multiple phasers of the same type\n\n    class X::Phaser::Multiple does X::Comp { }\n\nThrown when multiple phasers of the same type occur in a block, but only\none is allowed (for example CATCH or CONTROL).\n\nFor example\n\n    CATCH { }; CATCH { }\n\n\ndies with\n\n    ===SORRY!===\n    Only one CATCH block is allowed\n\n\n","t":"X::Phaser::Multiple","n":"X::Phaser::Multiple","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Returns the name of the phaser that occurred more than once.","n":"block"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"post"},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Comp","Exception"]},{"b":"A","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"parameter","d":"The text of the offensive parameter declaration ($:param in the example\nabove)."},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"right","d":"Suggestion on how to write the parameter declaration instead (:$param in\nthe example above)."},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"t":"X::Parameter::Placeholder","a":[{"k":"v","n":"$.parameter","t":"Mu"},{"n":"$.right","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::Parameter::Placeholder\n\nSUBTITLE\nCompilation error due to an unallowed placeholder in a signature\n\n    class X::Parameter::Placeholder does X::Comp { }\n\nThrown when a placeholder parameter is used inside a signature where a\nnormal parameter is expected. The reason is often that a named parameter\n:$param was misspelled as $:param.\n\nFor example\n\n    sub f($:param) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter, placeholder variables like $:param are illegal\n    you probably meant a named parameter: ':$param'\n\n\n","n":"X::Parameter::Placeholder"},{"t":"X::Parameter::WrongOrder","a":[{"n":"$.misplaced","t":"Mu","k":"v"},{"t":"Mu","n":"$.parameter","k":"v"},{"t":"Mu","n":"$.after","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"d":"TITLE\nclass X::Parameter::WrongOrder\n\nSUBTITLE\nCompilation error due to passing parameters in the wrong order\n\n    class X::Parameter::WrongOrder does X::Comp { }\n\nCompile time error that is thrown when parameters in a signature in the\nwrong order (for example if an optional parameter comes before a mandatory\nparameter).\n\nFor example\n\n    sub f($a?, $b) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put required parameter $b after optional parameters\n\n\n","n":"X::Parameter::WrongOrder","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"misplaced","d":"Returns the kind of misplaced parameter (for example \"mandatory\",\n\"positional\").","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"parameter","d":"Returns the name of the (first) misplaced parameter","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Returns a string describing other parameters after which the current\nparameter was illegally placed (for example \"variadic\", \"positional\" or\n\"optional\").","n":"after"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pos"},{"n":"line","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::Comp","Exception"],"b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.type"},{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Parameter::BadType","n":"X::Parameter::BadType","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"n":"type","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["X::Comp","Exception"],"b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.parameter"},{"k":"v","n":"$.twigil","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Parameter::Twigil","d":"TITLE\nclass X::Parameter::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a signature\n\n    class X::Parameter::Twigil does X::Comp { }\n\nThrown when a parameter in a signature has a twigil that it may not have.\nOnly !, . and * as twigils are allowed.\n\nExample:\n\n    sub f($=foo) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter $=foo, it is illegal to use the = twigil\n\n\n","n":"X::Parameter::Twigil","k":"c","m":[{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"d":"The name of the offensive parameter ($=foo in the example above)","n":"parameter","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"The illegally used twigil.","n":"twigil"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pos"},{"n":"line","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","Exception"],"b":"A"},{"mro":["X::Syntax","X::Comp","Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"type"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modifier"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"default"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"n":"line","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"column"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"is-compile-time","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"n":"X::Parameter::AfterDefault","a":[{"k":"v","n":"$.type","t":"Mu"},{"t":"Mu","n":"$.modifier","k":"v"},{"k":"v","n":"$.default","t":"Mu"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Parameter::AfterDefault","b":"A"},{"a":[{"n":"$.got","t":"Mu","k":"v"},{"n":"$.symbol","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Parameter::RW","n":"X::Parameter::RW","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"n":"got","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"symbol"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["Exception"],"b":"A"},{"b":"A","n":"X::Parameter::MultipleTypeConstraints","a":[{"k":"v","t":"Mu","n":"$.parameter"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Parameter::MultipleTypeConstraints\n\nSUBTITLE\nCompilation error due to a parameter with multiple type constraints\n\n    class X::Parameter::MultipleTypeConstraints does X::Comp { }\n\nCompile time error thrown when a parameter has multiple type constraints.\nThis is not allowed in Raku.0.\n\nExample:\n\n    sub f(Cool Real $x) { }\n\n\ndies with\n\n    Parameter $x may only have one prefix type constraint\n\n\n","t":"X::Parameter::MultipleTypeConstraints","mro":["X::Comp","Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Returns the name of the offensive parameter.","n":"parameter"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pos"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pre"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"post"},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s","n":"BUILDALL"}]},{"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"expected"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"got"},{"n":"routine","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"param"},{"n":"should-be-concrete","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"param-is-invocant"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"mro":["Exception"],"t":"X::Parameter::InvalidConcreteness","a":[{"k":"v","n":"$.expected","t":"Mu"},{"n":"$.got","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.routine"},{"n":"$.param","t":"Mu","k":"v"},{"n":"$.should-be-concrete","t":"Bool","k":"v"},{"t":"Bool","n":"$.param-is-invocant","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"n":"X::Parameter::InvalidConcreteness","b":"A"},{"t":"X::Parameter::InvalidType","a":[{"k":"v","n":"$.typename","t":"Mu"},{"k":"v","n":"@.suggestions","t":"Positional"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"t":"Positional","n":"@.modules","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Parameter::InvalidType","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"typename"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"suggestions"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"mro":["X::Comp","Exception"],"b":"A"},{"b":"A","a":[{"k":"v","t":"Mu","n":"$.kind"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Parameter::TypedSlurpy","n":"X::Parameter::TypedSlurpy","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"kind","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pre","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"mro":["X::Comp","Exception"]},{"b":"A","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"how","d":"Returns a string describing how the parameter is qualified that makes it\ndisallow default values, for example \"slurpy\" or \"mandatory\"."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"Returns the parameter name","n":"parameter"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"post"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"highexpect"},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Comp","Exception"],"d":"TITLE\nclass X::Parameter::Default\n\nSUBTITLE\nCompilation error due to an unallowed default value in a signature\n\n    class X::Parameter::Default does X::Comp { }\n\nCompile-time error thrown when a parameter in a signature has default\nvalue, but isn't allowed to have one. That is the case with slurpy\nparameters (because a slurpy always binds successfully, even to zero\narguments) and with mandatory parameters.\n\nExample:\n\n    sub f($x! = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on required parameter $x\n\n\nAnd\n\n    sub f(*@ = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on anonymous slurpy parameter\n\n\n","a":[{"t":"Mu","n":"$.how","k":"v"},{"k":"v","t":"Mu","n":"$.parameter"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Parameter::Default","n":"X::Parameter::Default"},{"m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"got"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"expected"},{"n":"filename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.got","t":"Mu"},{"t":"Mu","n":"$.expected","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Parameter::Default::TypeCheck","n":"X::Parameter::Default::TypeCheck","b":"A"},{"mro":[],"k":"ro","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0}],"n":"X::OS","t":"X::OS","a":[{"k":"v","t":"Mu","n":"$.os-error"}],"d":"TITLE\nrole X::OS\n\nSUBTITLE\nError reported by the operating system\n\n    role X::OS { has $.os-error }\n\nCommon role for all exceptions that are triggered by some error reported by\nthe operating system (failed IO, system calls, fork, memory allocation).\n\n","b":"C"},{"b":"A","n":"X::Declaration::OurScopeInRole","a":[{"k":"v","t":"Mu","n":"$.declaration"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Declaration::OurScopeInRole","mro":["X::Comp","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"declaration","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}]},{"b":"A","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method scope(--> Str:D)\n\nReturns a string representation of the scope, usually the same keyword that\nis used for the declaration (\"my\", \"our\", \"has\", ...);","n":"scope"},{"n":"declaration","d":"method declaration(--> Str:D)\n\nDescribes the symbol that has been declared in a wrong scope.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"pre"},{"n":"post","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"highexpect","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0}],"mro":["X::Comp","Exception"],"a":[{"k":"v","n":"$.scope","t":"Mu"},{"n":"$.declaration","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Declaration::Scope","d":"TITLE\nclass X::Declaration::Scope\n\nSUBTITLE\nCompilation error due to a declaration with an ineligible scope\n\n    class X::Declaration::Scope does X::Comp { }\n\n\nCompile time error thrown when a declaration does not harmonize with the\ndeclared scope.\n\nFor example\n\n    has sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use 'has' with sub declaration\n\n\n","n":"X::Declaration::Scope"},{"b":"A","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::Comp","X::Declaration::Scope"],"t":"X::Declaration::Scope::Multi","a":[{"k":"v","n":"$.scope","t":"Mu"},{"n":"$.declaration","t":"Mu","k":"v"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","n":"$.post","t":"Mu"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"d":"TITLE\nclass X::Declaration::Scope::Multi\n\nSUBTITLE\nCompilation error due to declaring a multi with an ineligible scope\n\n    class X::Declaration::Scope::Multi is X::Declaration::Scope { }\n\nThrown when a multi is declared with an incompatible scope.\n\nFor example our multi sub foo() { } dies with\n\n    ===SORRY!===\n    Cannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead\n","n":"X::Declaration::Scope::Multi"},{"b":"A","n":"X::Inheritance::SelfInherit","a":[{"n":"$.name","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Inheritance::SelfInherit","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"name"},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c"},{"b":"A","mro":["X::Comp","Exception"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"d":"The name of the type that tries to inherit.","n":"child-typename","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"The type object that the child tried to inherit from.","n":"parent"},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"line"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"column"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","n":"X::Inheritance::Unsupported","t":"X::Inheritance::Unsupported","a":[{"n":"$.child-typename","t":"Mu","k":"v"},{"t":"Mu","n":"$.parent","k":"v"},{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Inheritance::Unsupported\n\nSUBTITLE\nCompilation error due to inheriting from an ineligible type\n\n    class X::Inheritance::Unsupported does X::Comp { }\n\nCompile time error thrown when trying to inherit from a type that does not\nsupport inheritance (like a package or an enum).\n\nFor example\n\n    enum A <Ax Ay>;\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    A does not support inheritance, so B cannot inherit from it\n\n\n"},{"n":"X::Inheritance::UnknownParent","a":[{"n":"$.child","t":"Mu","k":"v"},{"n":"$.parent","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.suggestions"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Inheritance::UnknownParent","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"child","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"parent","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"suggestions"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","b":"A"},{"n":"X::Inheritance::NotComposed","t":"X::Inheritance::NotComposed","a":[{"k":"v","n":"$.child-name","t":"Mu"},{"n":"$.parent-name","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::Inheritance::NotComposed\n\nSUBTITLE\nError due to inheriting from a type that's not composed yet\n\n    class X::Inheritance::NotComposed is Exception {}\n\nWhen you try to inherit from a class that hasn't been composed, an\nexception of type X::Inheritance::NotComposed is thrown.\n\nUsually this happens because it's not yet fully parsed, or that is\nstubbed:\n\nFor example\n\n    class A { ... };    # literal ... for stubbing\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    'B' cannot inherit from 'A' because 'A' isn't composed yet (maybe it is stubbed)\n\n\nThe second common way to trigger this error is by trying to inherit from a\nclass from within the class body.\n\nFor example\n\n    class Outer {\n        class Inner is Outer {\n        }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    'Outer::Inner' cannot inherit from 'Outer' because 'Outer' isn't composed yet (maybe it is stubbed)\n\n\n","mro":["X::MOP","Exception"],"m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"child-name","d":"method child-name(X::Inheritance::NotComposed:D: --> Str:D)\n\nReturns the name of the type that tries to inherit.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"parent-name","d":"method parent-name(X::Inheritance::NotComposed:D: --> Str:D)\n\nReturns the name of the parent type that the type tries to inherit from","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","b":"A"},{"b":"A","mro":["X::ArrayShapeMismatch"],"m":[{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","n":"X::Assignment::ArrayShapeMismatch","a":[{"n":"$.action","t":"Mu","k":"v"},{"k":"v","n":"$.target-shape","t":"Mu"},{"n":"$.source-shape","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Assignment::ArrayShapeMismatch"},{"b":"A","mro":["Exception"],"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"shape"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"n":"X::Assignment::ToShaped","a":[{"k":"v","n":"$.shape","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Assignment::ToShaped"},{"k":"c","m":[{"n":"message","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"typename","d":"method typename(X::Assignment::RO:D: --> Str)\n\nReturns the type name of the value on the left-hand side","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"value","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["Exception"],"a":[{"n":"$.value","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Assignment::RO","d":"TITLE\nclass X::Assignment::RO\n\nSUBTITLE\nException thrown when trying to assign to something read-only\n\n    class X::Assignment::RO is Exception {}\n\nCode like\n\n    sub f() { 42 };\n    f() = 'new value';  # throws an X::Assignment::RO\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\nthrows an exception of type X::Assignment::RO.\n\n","n":"X::Assignment::RO","b":"A"},{"a":[{"t":"Mu","n":"$.variable","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Assignment::RO::Comp","n":"X::Assignment::RO::Comp","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"variable","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"column"},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"pre"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"highexpect"},{"k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"],"b":"A"},{"b":"A","t":"X::UnitScope::Invalid","a":[{"k":"v","t":"Mu","n":"$.what"},{"t":"Mu","n":"$.where","k":"v"},{"k":"v","t":"Str:D","n":"$.suggestion"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"n":"@.modules","t":"Positional","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::UnitScope::Invalid","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"what"},{"n":"where","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"suggestion","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"filename","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"pos","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"]},{"b":"A","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"what","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Syntax","X::Comp","Exception"],"a":[{"t":"Mu","n":"$.what","k":"v"},{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","n":"$.line","t":"Mu"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::UnitScope::TooLate","n":"X::UnitScope::TooLate"},{"mro":["Exception"],"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"gotn"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"expectedn"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"priors"},{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"method operation(--> Str:D)\n\nReturns a string description of the operation that failed, for example\n\"assignment\", \"binding\", \"return\".","n":"operation","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"d":"method got()\n\nReturns the object that failed to type check","n":"got","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"expected","d":"method expected()\n\nReturns the type object against which the check failed.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"n":"X::TypeCheck","a":[{"n":"$.operation","t":"Mu","k":"v"},{"t":"Mu","n":"$.got","k":"v"},{"n":"$.expected","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::TypeCheck","d":"TITLE\nclass X::TypeCheck\n\nSUBTITLE\nError due to a failed type check\n\n    class X::TypeCheck is Exception { }\n\nError class thrown when a type check fails.\n\n","b":"A"},{"a":[{"k":"v","n":"$.action","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","t":"Positional","n":"@.modules"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$.operation","k":"v"},{"n":"$.got","t":"Mu","k":"v"},{"k":"v","n":"$.expected","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::TypeCheck::Splice","d":"TITLE\nclass X::TypeCheck::Splice\n\nSUBTITLE\nCompilation error due to a macro trying to splice a non-AST value\n\n    class X::TypeCheck::Splice is X::TypeCheck does X::Comp { }\n\nCompile time error thrown when a Macro or an unquote/hole in a quasi quote\ndoes not return an AST.\n\nFor example\n\n    use experimental :macros;\n    macro quasi-ast { quasi { {{{'not AST'}}} };};\n    say quasi-ast;\n\n\ndies with\n\n    ===SORRY!===\n    Type check failed in macro application; expected AST but got Str(\"not AST\")\n\n\nThis is because you are purposefully creating something that does not\nevaluate to an abstract syntax tree. To fix, instead write\n\n    use experimental :macros;\n    macro an-ast {\n        quasi { 'yes AST' }\n    }\n    say an-ast;              # OUTPUT: «yes AST␤»\n\n\n","n":"X::TypeCheck::Splice","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"method action(--> Str:D)\n\nReturns a verbal description of the action that triggered the error, \"macro\napplication\" or \"unquote evaluation\".","n":"action"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"line"},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"post","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::Comp","X::TypeCheck","Exception"],"b":"A"},{"m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"protoguilt"},{"n":"arguments","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"objname"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"signature"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["X::TypeCheck"],"t":"X::TypeCheck::Argument","a":[{"t":"Mu","n":"$.protoguilt","k":"v"},{"t":"Positional","n":"@.arguments","k":"v"},{"n":"$.objname","t":"Mu","k":"v"},{"k":"v","n":"$.signature","t":"Mu"},{"k":"v","n":"$.operation","t":"Mu"},{"n":"$.got","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.expected"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::TypeCheck::Argument","b":"A"},{"b":"A","n":"X::TypeCheck::Binding","t":"X::TypeCheck::Binding","a":[{"k":"v","t":"Mu","n":"$.symbol"},{"n":"$.operation","t":"Mu","k":"v"},{"k":"v","n":"$.got","t":"Mu"},{"k":"v","n":"$.expected","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"d":"TITLE\nclass X::TypeCheck::Binding\n\nSUBTITLE\nError due to a failed type check during binding\n\n    class X::TypeCheck::Binding is X::TypeCheck { }\n\nThrown when the type check of a binding operation fails.\n\nFor example:\n\n    my Int $x := \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding: Type check failed in binding; expected Int but got Str (\"foo\")␤»\n\nNote that the compiler is free to detect obvious errors at compile time,\nand complain with a different error at compile time.","mro":["X::TypeCheck"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"operation"},{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"symbol"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"k":"s","m":0,"n":"BUILDALL"}],"k":"c"},{"t":"X::TypeCheck::Binding::Parameter","a":[{"t":"Parameter","n":"$.parameter","k":"v"},{"n":"$.constraint","t":"Bool","k":"v"},{"n":"$.symbol","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.operation"},{"k":"v","t":"Mu","n":"$.got"},{"k":"v","t":"Mu","n":"$.expected"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::TypeCheck::Binding::Parameter","m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"expectedn"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"message"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"parameter"},{"n":"constraint","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"k":"c","mro":["X::TypeCheck::Binding"],"b":"A"},{"k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"operation"},{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"symbol","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::TypeCheck"],"t":"X::TypeCheck::Assignment","a":[{"n":"$.symbol","t":"Mu","k":"v"},{"t":"Mu","n":"$.operation","k":"v"},{"k":"v","n":"$.got","t":"Mu"},{"n":"$.expected","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"d":"TITLE\nclass X::TypeCheck::Assignment\n\nSUBTITLE\nError due to a failed type check during assignment\n\n    class X::TypeCheck::Assignment is X::TypeCheck { }\n\nError class thrown when the type check of an assignment fails.\n\nFor example, this will die\n\n    my Int $x = \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (\"foo\")␤»\n\nthough compilers are allowed to detect obvious cases like this example and\ncomplain at compile time with a different error.","n":"X::TypeCheck::Assignment","b":"A"},{"mro":["X::TypeCheck"],"m":[{"n":"operation","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"X::TypeCheck::Return","d":"TITLE\nclass X::TypeCheck::Return\n\nSUBTITLE\nError due to a failed typecheck during return\n\n    class X::TypeCheck::Return is X::TypeCheck { }\n\nThrown when a return type check fails.\n\nFor example\n\n    sub f(--> Int) { \"foo\" }\n    f();\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Return: Type check failed for return value; expected Int but got Str (\"foo\")␤»","a":[{"k":"v","t":"Mu","n":"$.operation"},{"k":"v","t":"Mu","n":"$.got"},{"n":"$.expected","t":"Mu","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::TypeCheck::Return","b":"A"},{"b":"A","d":"TITLE\nclass X::Sequence::Deduction\n\nSUBTITLE\nError due to constructing a sequence from ineligible input\n\n    class X::Sequence::Deduction is Exception { }\n\nException type thrown when the ... sequence operator is being called\nwithout an explicit closure, and the sequence cannot be deduced.","a":[{"k":"v","n":"$.from","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Sequence::Deduction","n":"X::Sequence::Deduction","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"from"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["Exception"]},{"b":"C","d":"TITLE\nrole X::Comp\n\nSUBTITLE\nCommon role for compile-time errors\n\n    role X::Comp is Exception { }\n\nCommon role for compile-time errors.\n\nNote that since the backtrace of a compile time error generally shows\nroutines from the compiler, not from user-space programs, the Backtrace\nreturned from the backtrace method is not very informative. Instead the\nexception carries its own filename, line and column attributes and public\naccessors.\n\nIf an error occurs while creating an object (like a class or routine) at\ncompile time, generally the exception associated with it does not hold a\nreference to the object (for example a class would not be fully composed,\nand thus not usable). In those cases the name of the would-be-created\nobject is included in the error message instead.\n\n","a":[{"k":"v","t":"Mu","n":"$.filename"},{"t":"Mu","n":"$.pos","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"n":"$.pre","t":"Mu","k":"v"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","t":"Positional","n":"@.highexpect"}],"t":"X::Comp","n":"X::Comp","k":"ro","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"sorry_heading"},{"n":"SET_FILE_LINE","m":0,"k":"m","s":{"p":["$file","$line","*%_"],"r":"Mu"}}],"mro":[]},{"mro":["X::Comp","Exception"],"m":[{"m":0,"k":"m","s":{"r":"Bool","p":["*%_"]},"n":"is-compile-time"},{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"dba"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"goal"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"line-real"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"filename"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"n":"post","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","n":"X::Comp::FailGoal","t":"X::Comp::FailGoal","a":[{"n":"$.dba","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.goal"},{"t":"Mu","n":"$.line-real","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"n":"$.pos","t":"Mu","k":"v"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"n":"$.pre","t":"Mu","k":"v"},{"k":"v","n":"$.post","t":"Mu"},{"k":"v","t":"Positional","n":"@.highexpect"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"n":"@.modules","t":"Positional","k":"v"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","t":"Mu","n":"$.pre"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"n":"$.type","t":"Mu","k":"v"},{"k":"v","n":"$.subtype","t":"Mu"},{"k":"v","t":"Mu","n":"$.declaring"},{"k":"v","t":"Mu","n":"$.scope"},{"k":"v","t":"Mu","n":"$.supported"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Comp::Trait::Scope","n":"X::Comp::Trait::Scope","k":"c","m":[{"n":"filename","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"n":"pre","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"post","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"highexpect"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"mro":["X::Comp","X::Trait::Scope","Exception"],"b":"A"},{"t":"X::Comp::Trait::NotOnNative","a":[{"n":"$.filename","t":"Mu","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","t":"Mu","n":"$.column"},{"k":"v","t":"Positional","n":"@.modules"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","n":"$.pre","t":"Mu"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"t":"Mu","n":"$.type","k":"v"},{"k":"v","n":"$.subtype","t":"Mu"},{"k":"v","t":"Mu","n":"$.native"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Comp::Trait::NotOnNative","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"column","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"modules"},{"n":"is-compile-time","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"pre","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","X::Trait::NotOnNative","Exception"],"b":"A"},{"b":"A","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"modules","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","X::Trait::Unknown","Exception"],"t":"X::Comp::Trait::Unknown","a":[{"k":"v","n":"$.filename","t":"Mu"},{"n":"$.pos","t":"Mu","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$.type","t":"Mu","k":"v"},{"t":"Mu","n":"$.subtype","k":"v"},{"n":"$.declaring","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"n":"X::Comp::Trait::Unknown"},{"n":"X::Comp::WheneverOutOfScope","a":[{"k":"v","t":"Mu","n":"$.filename"},{"k":"v","n":"$.pos","t":"Mu"},{"k":"v","t":"Mu","n":"$.line"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"t":"Positional","n":"@.highexpect","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Comp::WheneverOutOfScope","mro":["X::Comp","Exception"],"k":"c","m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"filename"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pos"},{"n":"line","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"column"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"modules"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"is-compile-time"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pre"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"post"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"highexpect"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"b":"A"},{"b":"A","a":[{"n":"$.use-case","t":"str","k":"v"},{"k":"v","n":"$.exception","t":"Mu"},{"k":"v","n":"$.filename","t":"Mu"},{"t":"Mu","n":"$.pos","k":"v"},{"k":"v","n":"$.line","t":"Mu"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"t":"Mu","n":"$.pre","k":"v"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Comp::BeginTime","n":"X::Comp::BeginTime","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"use-case"},{"n":"exception","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"filename"},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"column","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"modules","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","Exception"]},{"mro":["Exception"],"m":[{"s":{"p":["*%_"],"r":"Bool"},"k":"m","m":0,"n":"is-compile-time"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"panic"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"sorrows"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"worries"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","n":"X::Comp::Group","a":[{"n":"$.panic","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.sorrows"},{"k":"v","n":"@.worries","t":"Positional"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Comp::Group","b":"A"},{"n":"X::Comp::NYI","t":"X::Comp::NYI","a":[{"k":"v","n":"$.filename","t":"Mu"},{"k":"v","n":"$.pos","t":"Mu"},{"n":"$.line","t":"Mu","k":"v"},{"t":"Mu","n":"$.column","k":"v"},{"k":"v","n":"@.modules","t":"Positional"},{"t":"Mu","n":"$.is-compile-time","k":"v"},{"t":"Mu","n":"$.pre","k":"v"},{"k":"v","t":"Mu","n":"$.post"},{"k":"v","n":"@.highexpect","t":"Positional"},{"k":"v","n":"$.feature","t":"Mu"},{"k":"v","t":"Mu","n":"$.did-you-mean"},{"k":"v","n":"$.workaround","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Comp","X::NYI","Exception"],"k":"c","m":[{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"column"},{"n":"modules","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"is-compile-time"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"pre"},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"highexpect","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"b":"A"},{"m":[{"m":0,"k":"m","s":{"r":"Bool","p":["*%_"]},"n":"is-compile-time"},{"n":"filename","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pos"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"line"},{"n":"column","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"modules","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"post","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["X::Comp","X::AdHoc","Exception"],"t":"X::Comp::AdHoc","a":[{"n":"$.filename","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pos"},{"t":"Mu","n":"$.line","k":"v"},{"k":"v","n":"$.column","t":"Mu"},{"k":"v","n":"@.modules","t":"Positional"},{"k":"v","n":"$.is-compile-time","t":"Mu"},{"k":"v","n":"$.pre","t":"Mu"},{"t":"Mu","n":"$.post","k":"v"},{"k":"v","n":"@.highexpect","t":"Positional"},{"t":"Mu","n":"$.payload","k":"v"},{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Comp::AdHoc","b":"A"},{"a":[{"k":"v","t":"Mu","n":"$.await-backtrace"}],"t":"X::Await::Died","n":"X::Await::Died","k":"ro","mro":[],"b":"C"},{"d":"TITLE\nclass X::ControlFlow\n\nSUBTITLE\nError due to calling a loop control command in an ineligible scope\n\n    class X::ControlFlow is Exception { }\n\nThrown when a control flow construct (such as next or redo) is called\noutside the dynamic scope of an enclosing construct that is supposed to\ncatch them.\n\nFor example\n\n    last;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow: last without loop construct␤»\n\n","a":[{"k":"v","n":"$.illegal","t":"Mu"},{"n":"$.enclosing","t":"Mu","k":"v"},{"k":"v","n":"$.backtrace","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::ControlFlow","n":"X::ControlFlow","k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"backtrace"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"illegal","d":"method illegal returns Str:D\n\nReturns the name of the control flow command that was called."},{"d":"method enclosing returns Str:D\n\nReturns the name of the missing enclosing construct.","n":"enclosing","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["Exception"],"b":"A"},{"mro":["X::ControlFlow"],"k":"c","m":[{"n":"BUILD","s":{"p":[":out-of-dynamic-scope($!out-of-dynamic-scope)","*%_"],"r":"Mu"},"m":0,"k":"s"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"illegal"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"enclosing"},{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"out-of-dynamic-scope"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"}],"n":"X::ControlFlow::Return","d":"TITLE\nclass X::ControlFlow::Return\n\nSUBTITLE\nError due to calling return outside a routine\n\n    class X::ControlFlow::Return is X::ControlFlow { }\n\nThrown when a return is called from outside a routine.\n\n    return;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»","a":[{"k":"v","t":"Bool","n":"$.out-of-dynamic-scope"},{"k":"v","n":"$.illegal","t":"Mu"},{"t":"Mu","n":"$.enclosing","k":"v"},{"k":"v","n":"$.backtrace","t":"Mu"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::ControlFlow::Return","b":"A"},{"b":"A","mro":["Exception"],"k":"c","n":"X::Worry","t":"X::Worry","a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}]},{"b":"A","k":"c","mro":["X::Worry"],"a":[{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Worry::P5","n":"X::Worry::P5"},{"b":"A","t":"X::Worry::P5::BackReference","a":[{"k":"v","n":"$!ex","t":"Mu"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Worry::P5::BackReference","k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"}],"mro":["X::Worry::P5"]},{"b":"A","n":"X::Worry::P5::LeadingZero","t":"X::Worry::P5::LeadingZero","a":[{"n":"$.value","t":"Mu","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["X::Worry::P5"],"m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"n":"value","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c"},{"n":"X::Worry::P5::Reference","a":[{"n":"$!ex","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Worry::P5::Reference","mro":["X::Worry::P5"],"m":[{"n":"message","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}}],"k":"c","b":"A"},{"a":[{"k":"v","n":"$.action","t":"Mu"},{"n":"$!ex","t":"Mu","k":"v"},{"n":"$!bt","t":"Mu","k":"v"}],"t":"X::Worry::Precedence::Range","n":"X::Worry::Precedence::Range","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"n":"action","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"BUILDALL","m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"mro":["X::Worry"],"b":"A"},{"k":"c","m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"}],"mro":["Exception"],"t":"X::Numeric::Underflow","a":[{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"n":"X::Numeric::Underflow","b":"A"},{"b":"A","a":[{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::Numeric::Overflow","n":"X::Numeric::Overflow","m":[{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"message"}],"k":"c","mro":["Exception"]},{"n":"X::Numeric::CannotConvert","a":[{"n":"$.target","t":"Mu","k":"v"},{"t":"Mu","n":"$.reason","k":"v"},{"k":"v","n":"$.source","t":"Mu"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Numeric::CannotConvert","mro":["Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"message"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"target"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"reason"},{"n":"source","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"b":"A"},{"mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"using"},{"n":"details","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"numerator"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"X::Numeric::DivideByZero","t":"X::Numeric::DivideByZero","a":[{"n":"$.using","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.details"},{"t":"Mu","n":"$.numerator","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"b":"A"},{"a":[{"n":"$.target","t":"Mu","k":"v"},{"n":"$.reason","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.source"},{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Numeric::Real","d":"TITLE\nclass X::Numeric::Real\n\nSUBTITLE\nError while trying to coerce a number to a Real type\n\n    class X::Numeric::Real is Exception { }\n\nOccurs when an attempt to coerce a Numeric to a Real, Num, Int or Rat fails\n(due to a number with a nonzero imaginary part, for instance).\n\nFor example\n\n    say (1+2i).Int;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Numeric::Real: Can not convert 1+2i to Int: imaginary part not zero␤»\n\n","n":"X::Numeric::Real","k":"c","m":[{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Numeric::CannotConvert"],"b":"A"},{"n":"X::Numeric::Confused","a":[{"t":"Mu","n":"$.num","k":"v"},{"t":"Mu","n":"$.base","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"t":"X::Numeric::Confused","mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"num"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"base"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"b":"A"},{"b":"A","a":[{"k":"v","n":"@.exceptions","t":"Positional"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::PhaserExceptions","n":"X::PhaserExceptions","m":[{"n":"message","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"exceptions","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"k":"c","mro":["Exception"]},{"b":"A","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"}],"k":"c","mro":["Exception"],"a":[{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Pairup::OddNumber","n":"X::Pairup::OddNumber"},{"n":"X::HyperWhatever::Multiple","a":[{"k":"v","n":"$!ex","t":"Mu"},{"k":"v","t":"Mu","n":"$!bt"}],"t":"X::HyperWhatever::Multiple","mro":["Exception"],"m":[{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"message"}],"k":"c","b":"A"},{"n":"X::IllegalOnFixedDimensionArray","t":"X::IllegalOnFixedDimensionArray","a":[{"k":"v","n":"$.operation","t":"Mu"},{"k":"v","t":"Mu","n":"$!ex"},{"k":"v","n":"$!bt","t":"Mu"}],"mro":["Exception"],"k":"c","m":[{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"message"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"operation"},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"b":"A"},{"b":"A","mro":["Exception"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"from"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"missing"},{"s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0,"n":"BUILDALL"}],"k":"c","n":"X::Import::MissingSymbols","t":"X::Import::MissingSymbols","a":[{"n":"$.from","t":"Mu","k":"v"},{"n":"@.missing","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"k":"v","t":"Mu","n":"$!bt"}]},{"mro":["Exception"],"k":"c","m":[{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"message"},{"n":"source-package","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"n":"X::Import::Positional","a":[{"k":"v","t":"Mu","n":"$.source-package"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Import::Positional","b":"A"},{"b":"A","n":"X::Import::NoSuchTag","t":"X::Import::NoSuchTag","a":[{"t":"Mu","n":"$.source-package","k":"v"},{"t":"Mu","n":"$.tag","k":"v"},{"k":"v","t":"Mu","n":"$!ex"},{"t":"Mu","n":"$!bt","k":"v"}],"mro":["Exception"],"m":[{"n":"message","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"source-package","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"tag","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s"}],"k":"c"},{"b":"A","t":"X::Import::OnlystarProto","a":[{"k":"v","t":"Positional","n":"@.symbols"},{"k":"v","t":"Mu","n":"$.source-package-name"},{"k":"v","t":"Mu","n":"$.filename"},{"n":"$.pos","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.line"},{"k":"v","n":"$.column","t":"Mu"},{"t":"Positional","n":"@.modules","k":"v"},{"n":"$.is-compile-time","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$.pre"},{"k":"v","t":"Mu","n":"$.post"},{"n":"@.highexpect","t":"Positional","k":"v"},{"n":"$!ex","t":"Mu","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"n":"X::Import::OnlystarProto","k":"c","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"message"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"symbols"},{"n":"source-package-name","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"filename"},{"n":"pos","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"line","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"column","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"modules","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"is-compile-time","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"post","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"highexpect","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"mro":["X::Comp","Exception"]},{"a":[{"k":"v","n":"@.symbols","t":"Positional"},{"n":"$.source-package-name","t":"Mu","k":"v"},{"t":"Mu","n":"$.filename","k":"v"},{"t":"Mu","n":"$.pos","k":"v"},{"t":"Mu","n":"$.line","k":"v"},{"n":"$.column","t":"Mu","k":"v"},{"k":"v","t":"Positional","n":"@.modules"},{"k":"v","t":"Mu","n":"$.is-compile-time"},{"k":"v","n":"$.pre","t":"Mu"},{"n":"$.post","t":"Mu","k":"v"},{"n":"@.highexpect","t":"Positional","k":"v"},{"t":"Mu","n":"$!ex","k":"v"},{"t":"Mu","n":"$!bt","k":"v"}],"t":"X::Import::Redeclaration","n":"X::Import::Redeclaration","k":"c","m":[{"n":"message","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"symbols"},{"n":"source-package-name","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"filename","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"pos","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"line","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"column","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"modules"},{"n":"is-compile-time","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"pre","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"post"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"highexpect"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"mro":["X::Comp","Exception"],"b":"A"},{"n":"SIGWINCH","t":"Signal","k":"e"},{"k":"v","n":"&infix:<ne>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Mu","p":["$x?"]},"k":"s","m":1,"n":"infix:<ne>"},{"n":"infix:<ne>","s":{"p":["Mu \\a","Mu \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<ne>","s":{"p":["\\a","\\b"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["Blob:D \\a","Blob:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<ne>"},{"k":"s","m":1,"s":{"r":"Bool:D","p":["Str:D \\a","Str:D \\b"]},"n":"infix:<ne>"},{"m":1,"k":"s","s":{"p":["str $a","str $b"],"r":"Bool:D"},"n":"infix:<ne>"},{"k":"v","n":"&infix:<∋>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"r":"Bool:D","p":["\\a","\\b"]},"k":"s","m":1,"n":"infix:<∋>"},{"k":"v","n":"&unpolar","t":"Sub"},{"n":"unpolar","m":1,"k":"s","s":{"r":"Mu","p":["Real $mag","Real $angle"]}},{"b":"C","mro":["Real","Numeric","Stringy","Int","Str"],"m":[{"s":{"r":"Mu","p":["Int:D $i","Str:D $s","*%_"]},"m":0,"k":"m","n":"new","d":"method new(Int $i, Str $s)\n\nThe constructor requires both the Int and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = IntStr.new(42, \"forty two\");\n    say +$f; # OUTPUT: «42␤»\n    say ~$f; # OUTPUT: «\"forty two\"␤»"},{"d":"method Int\n\nReturns the integer value of the IntStr.","n":"Int","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["@auto","%init","*%_"],"r":"Mu"},"m":0,"k":"s","n":"BUILDALL"}],"k":"c","n":"IntStr","t":"IntStr","d":"TITLE\nclass IntStr\n\nSUBTITLE\nDual value integer and string\n\n    class IntStr is Int is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42>; say $f.^name; # OUTPUT: «IntStr␤»\n\nAs a subclass of both Int and Str, an IntStr will be accepted where either\nis expected. However, IntStr does not share object identity with Int- or\nStr-only variants:\n\n    my $int-str = <42>;\n    my Int $int = $int-str; # OK!\n    my Str $str = $int-str; # OK!\n    say 42 ∈ <42  55  1>;   # False; ∈ operator cares about object identity\n\n"},{"n":"&trim-leading","t":"Sub","k":"v"},{"n":"trim-leading","m":1,"k":"s","s":{"p":["Cool:D $s"],"r":"Str:D"}},{"b":"A","mro":["Any"],"m":[{"n":"Capture","d":"Defined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"parts","d":"method parts(Version:D: --> List:D)\n\nReturns the list of parts that make up this Version object\n\n    my $v1 = v1.0.1;\n    my $v2 = v1.0.1+;\n    say $v1.parts;                                    # OUTPUT: «(1 0 1)␤»\n    say $v2.parts;                                    # OUTPUT: «(1 0 1)␤»\n\nThe + suffix is not considered a part of the Version object, and thus not\nreturned by this method, as shown above in the $v2 variable.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"plus","d":"method plus(Version:D: --> Bool:D)\n\nReturns True if comparisons against this version allow larger versions\ntoo.\n\n    my $v1 = v1.0.1;\n    my $v2 = v1.0.1+;\n    say $v1.plus;                                     # OUTPUT: «False␤»\n    say $v2.plus;                                     # OUTPUT: «True␤»"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"whatever"},{"m":0,"k":"m","s":{"p":["str $s","*%_"],"r":"Mu"},"n":"!SLOW-NEW"},{"s":{"r":"Mu","p":["\\parts","\\plus","\\whatever","\\string","*%_"]},"m":0,"k":"m","n":"!SET-SELF"}],"k":"c","n":"Version","d":"TITLE\nclass Version\n\nSUBTITLE\nModule version descriptor\n\n    class Version { }\n\nVersion objects identify version of software components (and potentially\nother entities). Raku uses them internally for versioning modules.\n\nA version consists of several parts, which are visually represented by\njoining them with a dot. A version part is usually an integer, a string\nlike alpha, or a Whatever-star *. The latter is used to indicate that any\nversion part is acceptable in another version that is compared to the\ncurrent one.\n\n    say v1.0.1 ~~ v1.*;     # OUTPUT: «True␤»\n    say v1.0.1 ~~ v1.*.1;   # OUTPUT: «True␤»\n\nThe first part of version literals contains v and a number; this might be\nfollowed by alphanumeric and Whatever parts and trailed by +. Multiple\nparts are separate with a dot .. A trailing + indicates that higher\nversions are OK in comparisons:\n\n    say v1.2 ~~ v1.0;                 # OUTPUT: «False␤»\n    say v1.2 ~~ v1.0+;                # OUTPUT: «True␤»\n    say v0.and.anything.else ~~ v0+;  # OUTPUT: «True␤»\n\nIn comparisons, order matters, and every part is compared in turn.\n\n    say v1.2 cmp v2.1;      # OUTPUT: «Less␤»\n\nThe + suffix is always taken into account in comparisons:\n\n    say v1.0.1+ <=> v1.0.1; # OUTPUT: «More␤»\n\nAnd * (Whatever) is too, and considered always Less than whatever digit is\nin the corresponding part, even if * is trailed by +:\n\n    say v1.* <=> v1.0;      # OUTPUT: «Less␤»\n    say v1.* <= v1.0;       # OUTPUT: «True␤»\n    say v1.*+ <= v1.0;      # OUTPUT: «True␤»\n\nPlease note that method calls, including pseudo methods like WHAT, require\nversion literals either to be enclosed with parentheses or use some other\nmethod to separate them from the dot that denotes a method call, like in\nthese examples:\n\n    say (v0.and.some.*.stuff).parts;  # OUTPUT: «(0 and some * stuff)␤»\n    say v0.and.some.*.stuff .parts;   # OUTPUT: «(0 and some * stuff)␤»\n\n","a":[{"k":"v","n":"$!parts","t":"Mu"},{"t":"int","n":"$!plus","k":"v"},{"k":"v","t":"int","n":"$!whatever"},{"k":"v","t":"str","n":"$!string"}],"t":"Version"},{"k":"v","t":"Sub","n":"&printf"},{"k":"s","m":1,"s":{"r":"Mu","p":["Cool:D $format","*@args"]},"n":"printf"},{"k":"v","n":"&infix:<min>","t":"Sub+{is-pure}+{Precedence}"},{"s":{"p":["Mu:D \\a","Mu:U $"],"r":"Mu"},"m":1,"k":"s","n":"infix:<min>"},{"n":"infix:<min>","k":"s","m":1,"s":{"r":"Mu","p":["Mu:U $","Mu:D \\b"]}},{"n":"infix:<min>","k":"s","m":1,"s":{"p":["Mu:D \\a","Mu:D \\b"],"r":"Mu"}},{"n":"infix:<min>","k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Mu"}},{"n":"infix:<min>","k":"s","m":1,"s":{"r":"Mu","p":["int \\a","int \\b"]}},{"n":"infix:<min>","m":1,"k":"s","s":{"p":["Num:D \\a","Num:D \\b"],"r":"Mu"}},{"n":"infix:<min>","s":{"p":["num \\a","num \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<min>","m":1,"k":"s","s":{"r":"Mu","p":["+\\args is raw"]}},{"t":"uint32","n":"uint32","k":"n"},{"n":"&flat","t":"Sub","k":"v"},{"s":{"r":"Mu","p":["**@list is raw"]},"k":"s","m":1,"n":"flat"},{"n":"flat","s":{"p":["Iterable \\a"],"r":"Mu"},"m":1,"k":"s"},{"k":"v","t":"Sub","n":"&infix:<o>"},{"s":{"p":[],"r":"Mu"},"k":"s","m":1,"n":"infix:<o>"},{"s":{"r":"Mu","p":["&f"]},"m":1,"k":"s","n":"infix:<o>"},{"m":1,"k":"s","s":{"r":"Block:D","p":["&f","&g"]},"n":"infix:<o>"},{"mro":["Any"],"k":"c","n":"PhasersList","t":"PhasersList","b":"A"},{"k":"e","t":"Signal","n":"SIGKILL"},{"b":"C","d":"TITLE\nclass Array\n\nSUBTITLE\nSequence of itemized values\n\n    class Array is List {}\n\nAn Array is a List which forces all its elements to be scalar containers,\nwhich means you can assign to array elements.\n\nArray implements Positional and as such provides support for subscripts.\n\nNote from version 6.d, .perl can be called on multi-dimensional arrays.\n\n","a":[{"n":"$!descriptor","t":"Mu","k":"v"},{"k":"v","t":"Mu","n":"$!reified"},{"n":"$!todo","t":"Mu","k":"v"}],"t":"Array","n":"Array","m":[{"n":"iterator","k":"m","m":0,"s":{"r":"Iterator:D","p":["*%_"]}},{"n":"from-iterator","s":{"p":["Iterator $iter","*%_"],"r":"Array:D"},"m":0,"k":"m"},{"n":"from-list","m":0,"k":"m","s":{"p":["Mu \\list","*%_"],"r":"Array:D"}},{"n":"new","m":1,"k":"m","s":{"r":"Array:D","p":[":$shape!","*%_"]}},{"n":"new","s":{"p":["*%_"],"r":"Array:D"},"m":1,"k":"m"},{"n":"new","k":"m","m":1,"s":{"p":["\\values",":$shape!","*%_"],"r":"Array:D"}},{"s":{"r":"Array:D","p":["\\values","*%_"]},"m":1,"k":"m","n":"new"},{"n":"new","s":{"r":"Array:D","p":["**@values is raw",":$shape!","*%_"]},"m":1,"k":"m"},{"n":"new","s":{"p":["**@values is raw","*%_"],"r":"Array:D"},"k":"m","m":1},{"s":{"p":["Iterable:D \\iterable","*%_"],"r":"Array:D"},"m":1,"k":"m","n":"STORE"},{"n":"STORE","s":{"p":["Mu \\item","*%_"],"r":"Array:D"},"m":1,"k":"m"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Array::ArrayReificationTarget:D"},"n":"reification-target"},{"n":"FLATTENABLE_LIST","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"List:D","p":["*%_"]},"k":"m","m":0,"n":"shape","d":"Defined as:\n\n    method shape() { (*,) }\n\nReturns the shape of the array as a list.\n\nExample:\n\n    my @foo[2;3] = ( < 1 2 3 >, < 4 5 6 > ); # Array with fixed dimensions\n    say @foo.shape;                          # OUTPUT: «(2 3)␤»\n    my @bar = ( < 1 2 3 >, < 4 5 6 > );      # Normal array (of arrays)\n    say @bar.shape;                          # OUTPUT: «(*)␤»"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"pop","d":"Defined as:\n\n    multi sub    pop(Array:D )\n    multi method pop(Array:D:)\n\nRemoves and returns the last item from the array. Fails for an empty\narray.\n\nExample:\n\n    my @foo = <a b>; # a b\n    @foo.pop;        # b\n    pop @foo;        # a\n    pop @foo;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Cannot::Empty: Cannot pop from an empty Array␤»"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"shift","d":"Defined as:\n\n    multi sub    shift(Array:D )\n    multi method shift(Array:D:)\n\nRemoves and returns the first item from the array. Fails for an empty\narrays.\n\nExample:\n\n    my @foo = <a b>;\n    say @foo.shift;             # OUTPUT: «a␤»\n    say @foo.shift;             # OUTPUT: «b␤»\n    say @foo.shift;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Cannot::Empty: Cannot shift from an empty Array␤»"},{"n":"grab","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":1,"s":{"r":"Mu","p":["Callable:D $calculate","*%_"]},"n":"grab"},{"k":"m","m":1,"s":{"p":["Whatever $","*%_"],"r":"Seq:D"},"n":"grab"},{"n":"grab","m":1,"k":"m","s":{"p":["\\count","*%_"],"r":"Seq:D"}},{"n":"GRAB_ONE","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"name","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"of","d":"Defined as:\n\n    method of\n\nReturns the type constraint for the values of the invocant. By default,\ni.e. if no type constraint is given during declaration, the method returns\n(Mu).\n\n    my @a1 = 1, 'two', 3.14159;              # (no type constraint specified)\n    say @a1.of;                              # OUTPUT: «(Mu)␤»\n\n    my Int @a2 = 1, 2, 3;                    # (values must be of type Int)\n    say @a2.of;                              # OUTPUT: «(Int)␤»\n    @a2.push: 'd';\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to @a2; expected Int but got Str (\"d\")␤»"},{"d":"Defined as:\n\n    method default\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen trying to access an element in the Array which has not been previously\ninitialized or when accessing an element which has explicitly been set to\nNil. Unless the Array is declared as having a default value by using the is\ndefault trait the method returns the type object (Any).\n\n    my @a1 = 1, \"two\", 2.718;\n    say @a1.default;                               # OUTPUT: «(Any)␤»\n    say @a1[4];                                    # OUTPUT: «(Any)␤»\n\n    my @a2 is default(17) = 1, \"two\", 3;\n    say @a2.default;                               # OUTPUT: «17␤»\n    say @a2[4];                                    # OUTPUT: «17␤»\n    @a2[1] = Nil;                                  # (resets element to its default)\n    say @a2[1];                                    # OUTPUT: «17␤»","n":"default","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"dynamic","d":"Defined as:\n\n    method dynamic(Array:D: --> Bool:D)\n\nReturns True if the invocant has been declared with the is dynamic trait.\n\n    my @a;\n    say @a.dynamic;                          # OUTPUT: «False␤»\n\n    my @b is dynamic;\n    say @b.dynamic;                          # OUTPUT: «True␤»\n\nIf you declare a variable with the * twigil is dynamic is implied.\n\n    my @*b;\n    say @*b.dynamic;                         # OUTPUT: «True␤»\n\nNote that in the Scalar case you have to use the VAR method in order to get\ncorrect information.\n\n    my $s is dynamic = [1, 2, 3];\n    say $s.dynamic;                          # OUTPUT: «False␤»  (wrong, don't do this)\n    say $s.VAR.dynamic;                      # OUTPUT: «True␤»   (correct approach)"},{"n":"!splice-save","s":{"r":"Array:D","p":["int $offset","int $size","\\removed","*%_"]},"m":0,"k":"m"},{"s":{"r":"Array:D","p":["@values","*%_"]},"m":0,"k":"m","n":"!append-list"},{"n":"!splice-offset-size-new","k":"m","m":0,"s":{"p":["int $offset","int $size","@new","*%_"],"r":"Array:D"}},{"s":{"r":"Mu","p":["$got","*%_"]},"k":"m","m":0,"n":"!splice-offset-fail"},{"n":"!prepend-list","s":{"p":["@values","*%_"],"r":"Array:D"},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["int $pos","*%_"],"r":"Mu"},"n":"!AT_POS_SLOW"},{"s":{"p":["Int:D $pos","Mu \\assignee","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!ASSIGN_POS_SLOW_PATH"},{"n":"!INDEX_OOR","s":{"p":["$pos","*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!splice-size-fail","k":"m","m":0,"s":{"r":"Mu","p":["$got","$offset","*%_"]}},{"s":{"p":["int $offset","*%_"],"r":"Array:D"},"k":"m","m":0,"n":"!splice-offset"},{"n":"!AT_POS_CONTAINER","s":{"p":["int $pos","*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["\\shape","*%_"],"r":"Array:D"},"m":0,"k":"m","n":"!difficult-shape"},{"s":{"p":["int $offset","int $size","*%_"],"r":"Array:D"},"k":"m","m":0,"n":"!splice-offset-size"},{"m":0,"k":"m","s":{"p":["Int:D $pos","Mu \\assignee_decont","*%_"],"r":"Mu"},"n":"!ASSIGN_POS_FAST_PATH"}],"k":"c","mro":["Positional","Iterable","List"]},{"k":"e","n":"SOCK_MAX","t":"SocketType"},{"n":"Set","a":[{"n":"$!WHICH","t":"ValueObjAt","k":"v"},{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"d":"TITLE\nclass Set\n\nSUBTITLE\nImmutable collection of distinct objects\n\n    class Set does Setty { }\n\nA Set is an immutable set, meaning a collection of distinct elements in no\nparticular order. (For mutable sets, see SetHash instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = set <peach apple orange apple apple>;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSets can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the value True for keys that are elements of the set, and\nFalse for keys that aren't:\n\n    my $fruits = set <peach apple orange apple apple>;\n    say $fruits<apple>;  # OUTPUT: «True␤»\n    say $fruits<kiwi>;   # OUTPUT: «False␤»\n\nCreating Set objects\n\nSets can be composed using the set subroutine (or Set.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the set:\n\n    my $n = set \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .Set coercer (or its functional form, Set()) can be\ncalled on an existing object to coerce it to a Set. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a set with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the set - and keys mapped to values which boolify to False are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).Set;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nFurthermore, you can get a Set by using set operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Set on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (^) 4;  # OUTPUT: «set(1, 2, 3, 5)␤»\n\nOf course, you can also create a Set with the .new method.\n\n    my $fruits = Set.new( <peach apple orange apple apple> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Set, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Set\n    my $fruits = Set[Str].new( <peach apple orange apple apple> );\n\n    # only allow whole numbers (Int) in the Set\n    my $fruits = Set[Int].new( <peach apple orange apple apple> );\n    # Type check failed in binding; expected Int but got Str (\"peach\")\n\nFinally, you can create Set masquerading as a hash by using the is trait:\n\n    my %s is Set = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %s is Set[Str] = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\n    # limit to whole numbers\n    my %s is Set[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set operators, which can take Sets (or any other\ncollections) as input, and return result sets as new Set objects. For\nexample:\n\n    my ($a, $b) = set(1, 2, 3), set(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSubroutines\n\n  sub set\n\n    sub set(*@args --> Set)\n\nCreates a Set from the given @args\n\nSee Also\n\nSets, Bags, and Mixes","t":"Set","mro":["Setty","QuantHash","Associative","Any"],"k":"c","m":[{"n":"iterator","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["\\type","*%_"]},"k":"m","m":0,"n":"!HASHIFY"},{"s":{"p":["\\type","\\iterator","*%_"],"r":"Setty:D"},"m":0,"k":"m","n":"!create-from-iterator"}],"b":"A"},{"n":"&circumfix:<:{ }>","t":"Sub","k":"v"},{"s":{"r":"Mu","p":["*@e"]},"k":"s","m":0,"n":""},{"k":"v","n":"&sinh","t":"Sub+{is-pure}"},{"n":"sinh","k":"s","m":1,"s":{"r":"Mu","p":["Numeric \\x"]}},{"k":"s","m":1,"s":{"p":["Cool \\x"],"r":"Mu"},"n":"sinh"},{"n":"sinh","s":{"r":"num","p":["num $x"]},"k":"s","m":1},{"b":"A","mro":["Setty","QuantHash","Associative","Any"],"m":[{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"iterator"},{"n":"clone","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"!HASHIFY","s":{"p":["\\type","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!create-from-iterator","k":"m","m":0,"s":{"r":"Setty:D","p":["\\type","\\iterator","*%_"]}}],"k":"c","n":"SetHash","d":"TITLE\nclass SetHash\n\nSUBTITLE\nMutable collection of distinct objects\n\n    class SetHash does Setty { }\n\nA SetHash is a mutable set, meaning a collection of distinct elements in no\nparticular order. (For immutable sets, see Set instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSetHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the value True for keys that are elements of the\nset, and False for keys that aren't. Assigning a value that boolifies to\nTrue or False, respectively, can be used to add or remove a set element:\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits<apple>;     # OUTPUT: «True␤»\n    say $fruits<kiwi>;      # OUTPUT: «False␤»\n\n    $fruits<apple kiwi> = False, True;\n    say $fruits.keys.sort;  # OUTPUT: «kiwi orange peach␤»\n\n\nHere is a convenient shorthand idiom for adding and removing SetHash\nelements:\n\n    my SetHash $fruits .= new;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<cherry>++;\n    say $fruits<cherry>;      # OUTPUT: «True␤»\n    $fruits<apple banana kiwi>»++; # Add multiple elements\n\n    $fruits<cherry>--;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<banana kiwi>»--; # Remove multiple elements\n\n\n\nCreating SetHash objects\n\nSetHashes can be composed using SetHash.new. Any positional parameters,\nregardless of their type, become elements of the set:\n\n    my $n = SetHash.new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .SetHash coercer (or its functional form, SetHash()) can\nbe called on an existing object to coerce it to a SetHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a set with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the set - and keys mapped to values which boolify to\nFalse are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).SetHash;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nIt is also possible to initialize a single key with the use of {}:\n\n    my $sh = SetHash.new;\n    $sh{ 'key1' } = True;\n    $sh{ 'key2' } = 'Hello World!';\n    $sh{ 'key3' } = 0;  # does not store the key since 0.Bool is False\n    say $sh;            # OUTPUT: «SetHash(key1 key2)␤»\n    say $sh.keys.perl;  # OUTPUT: «(\"key1\", \"key2\").Seq␤»\n\nor, in order to initialize more than one key at the same time, use a list\nassignment:\n\n    my $sh = SetHash.new;\n    $sh{ 'a', 'b', 'c' } = True, False, True;\n    say $sh.keys.perl;  # OUTPUT: «(\"a\", \"c\").Seq␤»\n\nYou can also create SetHash masquerading as a hash by using the is trait:\n\n    my %sh is SetHash = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a SetHash. This can either be done when\ncalling .new:\n\n    # only allow Pairs\n    my $n = SetHash[Pair].new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %sh is SetHash[Str] = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\n    # only allow whole numbers\n    my %sh is SetHash[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set operators, which can take SetHashes (or any other\ncollections) as input, although result sets are returned as immutable Sets.\nFor example:\n\n    my ($a, $b) = SetHash.new(1, 2, 3), SetHash.new(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a (|) $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a ∪ $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSee Also\n\nSets, Bags, and Mixes","a":[{"k":"v","t":"Rakudo::Internals::IterationSet","n":"$!elems"}],"t":"SetHash"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<unicmp>"},{"s":{"r":"Order:D","p":["Str:D \\a","Str:D \\b"]},"k":"s","m":1,"n":"infix:<unicmp>"},{"s":{"p":["Pair:D \\a","Pair:D \\b"],"r":"Order:D"},"k":"s","m":1,"n":"infix:<unicmp>"},{"k":"v","t":"Sub","n":"&first"},{"m":1,"k":"s","s":{"p":["Bool:D $t","|"],"r":"Mu"},"n":"first"},{"m":1,"k":"s","s":{"p":["Mu $test","+\\values is raw","*%a"],"r":"Mu"},"n":"first"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<max>","k":"v"},{"n":"infix:<max>","s":{"p":["Mu:D \\a","Mu:U $"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<max>","m":1,"k":"s","s":{"r":"Mu","p":["Mu:U $","Mu:D \\b"]}},{"k":"s","m":1,"s":{"p":["Mu:D \\a","Mu:D \\b"],"r":"Mu"},"n":"infix:<max>"},{"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Mu"},"k":"s","m":1,"n":"infix:<max>"},{"s":{"r":"Mu","p":["int \\a","int \\b"]},"k":"s","m":1,"n":"infix:<max>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]},"n":"infix:<max>"},{"n":"infix:<max>","s":{"r":"Mu","p":["num \\a","num \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["+\\args is raw"],"r":"Mu"},"n":"infix:<max>"},{"b":"A","t":"NFC","d":"TITLE\nclass NFC\n\nSUBTITLE\nCodepoint string in Normal Form C (composed)\n\n    class NFC is Uni {}\n\nA Codepoint string in Unicode Normalization Form C. It is created by\nCanonical Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15.","n":"NFC","k":"c","m":[{"n":"new","k":"m","m":0,"s":{"r":"Mu","p":["|"]}},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"NFC"}],"mro":["Stringy","Positional[uint32]","Uni"]},{"b":"A","mro":["Systemic","Any"],"k":"c","m":[{"m":0,"k":"s","s":{"r":"Nil","p":[":name($!name) = \"Perl 6\"",":auth($!auth) = \"The Perl Foundation\"",":version($!version) = { ... }",":compiler($!compiler) = { ... }","*%_"]},"n":"BUILD"},{"n":"VMnames","d":"Instance / Class method returning the names of the VM objects that are\nsupported by this version of Perl.\n\nSee Also\n\nSystemic, Compiler.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"d":"Instance / Class method returning the names of the Distro objects that are\nsupported by this version of Perl.","n":"DISTROnames","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Instance / Class method returning the names of the Kernel objects that are\nsupported by this version of Perl.","n":"KERNELnames"},{"d":"Instance method returning the compiler object, of type Compiler, associated\nwith the Perl object.","n":"compiler","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"name"},{"n":"auth","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"version","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"signature"},{"n":"desc","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"r":"Mu","p":["@auto","%init","*%_"]}}],"n":"Perl","t":"Perl","a":[{"k":"v","t":"Compiler","n":"$.compiler"},{"k":"v","n":"$.name","t":"Str"},{"k":"v","n":"$.auth","t":"Str"},{"n":"$.version","t":"Version","k":"v"},{"t":"Blob","n":"$.signature","k":"v"},{"k":"v","t":"Str","n":"$.desc"}],"d":"TITLE\nclass Perl\n\nSUBTITLE\nPerl related information\n\n    class Perl does Systemic { }\n\nBuilt-in class for providing perl related information. Usually accessed\nthrough the $*PERL dynamic variable.\n\n"},{"n":"uint16","t":"uint16","k":"n"},{"mro":[],"k":"c","n":"IterationEnd","t":"Mu","b":"M"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<~&>"},{"s":{"r":"Mu","p":[]},"m":1,"k":"s","n":"infix:<~&>"},{"s":{"p":["$x"],"r":"Mu"},"k":"s","m":1,"n":"infix:<~&>"},{"m":1,"k":"s","s":{"r":"Mu","p":["\\a","\\b"]},"n":"infix:<~&>"},{"s":{"r":"Mu","p":["Blob:D \\a","Blob:D \\b"]},"k":"s","m":1,"n":"infix:<~&>"},{"n":"infix:<~&>","s":{"r":"Str:D","p":["Str:D \\a","Str:D \\b"]},"k":"s","m":1},{"m":1,"k":"s","s":{"r":"str","p":["str $a","str $b"]},"n":"infix:<~&>"},{"b":"C","m":[{"s":{"p":["*%_"],"r":"IO::Path:D"},"k":"m","m":0,"n":"IO","d":"Defined as:\n\n    method IO(Dateish:D: --> IO::Path:D)\n\nReturns an IO::Path object representing the stringified value of the\nDateish object:\n\n    Date.today.IO.say;   # OUTPUT: «\"2016-10-03\".IO␤»\n    DateTime.now.IO.say; # OUTPUT: «\"2016-10-03T11:14:47.977994-04:00\".IO␤»\n\nPORTABILITY NOTE: some operating systems (e.g. Windows) do not permit\ncolons (:) in filenames, which would be present in IO::Path created from a\nDateTime object."},{"k":"m","m":0,"s":{"r":"Bool:D","p":["*%_"]},"d":"Defined as:\n\n    method is-leap-year(--> Bool:D)\n\nReturns True if the year of the Dateish object is a leap year.\n\n    say DateTime.new(:year<2016>).is-leap-year; # OUTPUT: «True␤»\n    say Date.new(\"1900-01-01\").is-leap-year;    # OUTPUT: «False␤»","n":"is-leap-year"},{"k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]},"d":"Defined as:\n\n    method days-in-month(Dateish:D: --> Int:D)\n\nReturns the number of days in the month represented by the Dateish object:\n\n    say Date.new(\"2016-01-02\").days-in-month;                # OUTPUT: «31␤»\n    say DateTime.new(:year<10000>, :month<2>).days-in-month; # OUTPUT: «29␤»","n":"days-in-month"},{"m":0,"k":"m","s":{"r":"Int:D","p":["*%_"]},"d":"Defined as:\n\n    method daycount(Dateish:D: --> Int:D)\n\nReturns the number of days from the epoch Nov. 17, 1858 to the day of the\ninvocant. The daycount returned by this method is the MJD, i.e. the\nModified Julian Day, which is used routinely by e.g. astronomers,\ngeodesists, scientists and others. The MJD convention is designed to\nfacilitate simplified chronological calculations.\n\n    say Date.new('1995-09-27').daycount;    # OUTPUT: «49987␤»","n":"daycount"},{"d":"Defined as:\n\n    method day-of-month(Date:D: --> Int:D)\n\nReturns the day of the month of the date (1..31). Synonymous to the day\nmethod.\n\n    say Date.new('2015-12-31').day-of-month;                                  # OUTPUT: «31␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-month; # OUTPUT: «24␤»","n":"day-of-month","m":0,"k":"m","s":{"p":["*%_"],"r":"Int:D"}},{"d":"Defined as:\n\n    method day-of-week(Date:D: --> Int:D)\n\nReturns the day of the week, where 1 is Monday, 2 is Tuesday and Sunday is\n7.\n\n    say Date.new('2015-12-31').day-of-week;                                  # OUTPUT: «4␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-week; # OUTPUT: «4␤»","n":"day-of-week","k":"m","m":0,"s":{"p":["*%_"],"r":"Int:D"}},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"week","d":"Defined as:\n\n    method week()\n\nReturns a list of two integers: the year, and the week number. This is\nbecause at the start or end of a year, the week may actually belong to the\nother year.\n\n    my ($year, $week) = Date.new(\"2014-12-31\").week;\n    say $year;                       # OUTPUT: «2015␤»\n    say $week;                       # OUTPUT: «1␤»\n    say Date.new('2015-01-31').week; # OUTPUT: «(2015 5)␤»"},{"n":"week-year","d":"Defined as:\n\n    method week-year(Date:D: --> Int:D)\n\nReturns the week year of the date specified by the invocant. Normally\nweek-year is equal to Date.year. Note however that dates early in January\noften end up in the last week of the prior year, and similarly, the final\nfew days of December may be placed in the first week of the next year.\n\n    say Date.new(\"2015-11-15\").week-year;   # 2015\n    say Date.new(\"2014-12-31\").week-year;   # 2015 (date belongs to the first week of 2015)\n    say Date.new(\"2016-01-02\").week-year;   # 2015 (date belongs to the last week of 2015)","s":{"r":"Int:D","p":["*%_"]},"k":"m","m":0},{"n":"week-number","d":"Defined as:\n\n    method week-number(Date:D: --> Int:D)\n\nReturns the week number (1..53) of the date specified by the invocant. The\nfirst week of the year is defined by ISO as the one which contains the\nfourth day of January. Thus, dates early in January often end up in the\nlast week of the prior year, and similarly, the final few days of December\nmay be placed in the first week of the next year.\n\n    say Date.new(\"2014-12-31\").week-number;   # 1  (first week of 2015)\n    say Date.new(\"2016-01-02\").week-number;   # 53 (last week of 2015)","s":{"r":"Int:D","p":["*%_"]},"k":"m","m":0},{"k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]},"d":"Defined as:\n\n    method weekday-of-month(Date:D: --> Int:D)\n\nReturns a number (1..5) indicating the number of times a particular\nday-of-week has occurred so far during that month, the day itself\nincluded.\n\n    say Date.new(\"2003-06-09\").weekday-of-month;  # 2  (second Monday of the month)","n":"weekday-of-month"},{"n":"day-of-year","d":"Defined as:\n\n    method day-of-year(Date:D: --> Int:D)\n\nReturns the day of the year (1..366).\n\n    say Date.new('2015-12-31').day-of-year;                                  # OUTPUT: «365␤»\n    say DateTime.new(date => Date.new('2015-03-24'), hour => 1).day-of-year; # OUTPUT: «83␤»","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"n":"yyyy-mm-dd","d":"Defined as:\n\n    method yyyy-mm-dd(Date:D: --> Str:D)\n\n\nReturns the date in YYYY-MM-DD format (ISO 8601)\n\n    say Date.new(\"2015-11-15\").yyyy-mm-dd;   # OUTPUT: «2015-11-15␤»\n    say DateTime.new(1470853583).yyyy-mm-dd; # OUTPUT: «2016-08-10␤»","s":{"r":"Str:D","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%unit"],"r":"Mu"},"m":0,"k":"m","n":"earlier"},{"k":"m","m":0,"s":{"p":["\\year","\\month","*%_"],"r":"Int:D"},"n":"!DAYS-IN-MONTH"},{"s":{"r":"Int:D","p":["*%_"]},"m":0,"k":"m","n":"!calculate-daycount"},{"n":"!ymd-from-daycount","m":0,"k":"m","s":{"r":"Nil","p":["$daycount","\\year","\\month","\\day","*%_"]}},{"n":"!year-Str","m":0,"k":"m","s":{"r":"Str:D","p":["*%_"]}},{"n":"!truncate-ymd","s":{"p":["Cool:D $unit","%parts? is copy","*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"!SET-DAYCOUNT","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"}],"k":"ro","mro":[],"a":[{"k":"v","n":"$.year","t":"Int"},{"k":"v","n":"$.month","t":"Int"},{"k":"v","n":"$.day","t":"Int"},{"k":"v","n":"$.daycount","t":"Int"},{"n":"&.formatter","t":"Callable","k":"v"}],"t":"Dateish","d":"TITLE\nrole Dateish\n\nSUBTITLE\nObject that can be treated as a date\n\n    role Dateish { ... }\n\nBoth Date and DateTime support accessing a year, month and day-of-month, as\nwell as related functionality such as calculating the day of the week.\n\n","n":"Dateish"},{"k":"v","n":"&log","t":"Sub+{is-pure}"},{"n":"log","s":{"p":["Numeric $x"],"r":"Mu"},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Numeric $x","Numeric $base"]},"m":1,"k":"s","n":"log"},{"m":1,"k":"s","s":{"p":["Cool $x"],"r":"Mu"},"n":"log"},{"k":"s","m":1,"s":{"r":"Mu","p":["Cool $x","Cool $base"]},"n":"log"},{"k":"s","m":1,"s":{"p":["num $x"],"r":"num"},"n":"log"},{"b":"C","mro":["Associative","Iterable","Cool"],"k":"c","m":[{"d":"Defined as:\n\n    method elems(Map:D: --> Int:D)\n\nReturns the number of pairs stored in the Map.\n\n    my %map = Map.new('a', 1, 'b', 2);\n    say %map.elems; # OUTPUT: «2␤»","n":"elems","k":"m","m":0,"s":{"r":"Int:D","p":["*%_"]}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"IterationBuffer:D"},"n":"IterationBuffer"},{"s":{"r":"List:D","p":["*%_"]},"m":0,"k":"m","n":"List"},{"m":0,"k":"m","s":{"r":"Iterator:D","p":["*%_"]},"n":"iterator"},{"s":{"p":["*%_"],"r":"List:D"},"m":0,"k":"m","n":"list","d":"Defined as:\n\n    method list(Map:D: --> List:D)\n\nReturns a List of all keys and values in the Map.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.list;                                      # OUTPUT: «(b => 17 a => (2 3))␤»"},{"n":"STORE","k":"m","m":1,"s":{"r":"Map:D","p":["Map:D \\map",":$INITIALIZE!","*%_"]}},{"n":"STORE","s":{"r":"Map:D","p":["\\to_store",":$INITIALIZE!","*%_"]},"k":"m","m":1},{"n":"STORE","m":1,"k":"m","s":{"p":["\\keys","\\values",":$INITIALIZE!","*%_"],"r":"Map:D"}},{"n":"STORE","k":"m","m":1,"s":{"p":["|"],"r":"Mu"}},{"d":"Defined as:\n\n    method Capture(Map:D:)\n\nReturns a Capture where each key, if any, has been converted to a named\nargument with the same value as it had in the original Map. The returned\nCapture will not contain any positional arguments.\n\n    my $map = Map.new('a' => 2, 'b' => 17);\n    my $capture = $map.Capture;\n    my-sub(|$capture);                                # RESULT: «2, 17»\n\n    sub my-sub(:$a, :$b) {\n        say \"$a, $b\"\n    }","n":"Capture","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"FLATTENABLE_LIST","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"FLATTENABLE_HASH","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"fmt","s":{"p":["Cool $format = \"\\%s\\t\\%s\"","$sep = \"\\n\"","*%_"],"r":"Str:D"},"k":"m","m":0},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"hash"},{"n":"clone","k":"m","m":0,"s":{"r":"Map:D","p":["*%_"]}},{"n":"!STORE_MAP_FROM_ITERATOR","m":0,"k":"m","s":{"p":["\\iter","*%_"],"r":"Map:D"}},{"n":"!STORE_MAP_FROM_OBJECT_HASH","s":{"p":["\\map","*%_"],"r":"Nil"},"m":0,"k":"m"},{"n":"!DECONTAINERIZE","m":0,"k":"m","s":{"p":["*%_"],"r":"Map:D"}},{"s":{"p":["\\map","*%_"],"r":"Nil"},"m":0,"k":"m","n":"!STORE_MAP_FROM_MAP"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!keys-as-str"},{"m":0,"k":"m","s":{"p":["\\map","*%_"],"r":"Nil"},"n":"!STORE_MAP"}],"n":"Map","a":[{"k":"v","t":"Mu","n":"$!storage"}],"d":"TITLE\nclass Map\n\nSUBTITLE\nImmutable mapping from strings to values\n\n    class Map does Associative does Iterable { }\n\nA Map is an immutable mapping from string keys to values of arbitrary\ntypes. It serves as a base class for Hash, which is mutable.\n\nIn list context a Map behaves as a list of Pair objects.\n\nNote that the order in which keys, values and pairs are retrieved is\ngenerally arbitrary, but the keys, values and pairs methods return them\nalways in the same order when called on the same object.\n\n    my %e := Map.new('a', 1, 'b', 2);\n    say %e.keys;    # can print \"a b\\n\" or \"b a\\n\";\n    say %e.values;  # prints \"1 2\\n\" if the previous line\n                    # printed \"a b\\n\", \"b a\\n\" otherwise\n\nTo retrieve a value from the Map by key, use the { } postcircumfix\noperator:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    say $map{'a'};      # OUTPUT: «1␤»\n    say $map{ 'a', 'b' }; # OUTPUT: «(1 2)␤»\n\nTo check whether a given key is stored in a Map, modify the access with the\n:exists adverb:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    my $key = 'a';\n    if $map{$key}:exists {\n        say \"$map{} has key $key\";\n    }\n\nBeing an immutable instance, it is not possible to add keys after a Map has\nbeen initialized:\n\n    my $m = Map.new( 'a', 1, 'b', 2 );\n    $m{ 'c' } = 'foo'; # WRONG!\n                       # Cannot modify an immutable Str\n\n","t":"Map"},{"b":"A","m":[{"s":{"p":[":$past","*%_"],"r":"Nil"},"k":"s","m":0,"n":"BUILD"},{"s":{"p":["$quasi_context","@unquote_asts","*%_"],"r":"Mu"},"m":0,"k":"m","n":"incarnate"},{"n":"evaluate_unquotes","k":"m","m":0,"s":{"r":"Mu","p":["@unquote_asts","*%_"]}},{"n":"is_quasi_ast","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"Str"},{"m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"},"n":"BUILDALL"}],"k":"c","mro":["Any"],"d":"TITLE\nclass AST\n\nSUBTITLE\nAbstract representation of a piece of source code\n\n    class AST { }\n\nAn AST or Abstract Syntax Tree is a partially processed representation of a\nprogram. ASTs are return values of the quasi quoting construct, and are\ntypically used within macros to generate code that is inserted in the\ncalling location of the macro.\n\nThere is no API defined for ASTs yet. Hopefully that will emerge as part of\nthe work on macros.","a":[{"k":"v","t":"Mu","n":"$!past"},{"k":"v","n":"$!quasi_context","t":"Mu"},{"k":"v","n":"$!Str","t":"Mu"}],"t":"AST","n":"AST"},{"k":"v","n":"&cosec","t":"Sub+{is-pure}"},{"s":{"p":["Numeric \\x"],"r":"Mu"},"m":1,"k":"s","n":"cosec"},{"k":"s","m":1,"s":{"p":["Cool \\x"],"r":"Mu"},"n":"cosec"},{"n":"cosec","s":{"r":"Mu","p":["Num:D \\x"]},"k":"s","m":1},{"b":"A","a":[{"k":"v","t":"Int","n":"$.hour"},{"t":"Int","n":"$.minute","k":"v"},{"t":"Mu","n":"$.second","k":"v"},{"n":"$.timezone","t":"Int","k":"v"},{"n":"$.year","t":"Int","k":"v"},{"k":"v","n":"$.month","t":"Int"},{"n":"$.day","t":"Int","k":"v"},{"t":"Int","n":"$.daycount","k":"v"},{"k":"v","t":"Callable","n":"&.formatter"}],"d":"TITLE\nclass DateTime\n\nSUBTITLE\nCalendar date with time\n\n    class DateTime does Dateish {}\n\nFor handling points in civil time, a DateTime object stores year, month,\nday, hour, minute (all Int), second (potentially fractional) and a time\nzone.\n\nIt provides methods for calculating with date and time.\n\nDateTime methods are immutable; if you are tempted to modify one, create a\nmodified copy instead.\n\nTime zones are handled as Integers in seconds offset from UTC, not by time\nzone name.\n\n    my $dt = DateTime.new(\n        year    => 2015,\n        month   => 11,\n        day     => 21,\n        hour    => 16,\n        minute  => 1,\n    );\n\n    say $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»\n    say $dt.later(days => 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»\n    say $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»\n    say $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»\n\n    my $now = DateTime.now(formatter => { sprintf \"%02d:%02d\", .hour, .minute });\n    say $now;                           # 12:45 (or something like that)\n\n\n","t":"DateTime","n":"DateTime","k":"c","m":[{"n":"new","d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","s":{"p":["\\y","\\mo","\\d","\\h","\\mi","\\s",":$timezone = 0",":&formatter","*%_"],"r":"DateTime:D"},"m":1,"k":"m"},{"d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","n":"new","k":"m","m":1,"s":{"p":[":$year!",":$month = 1",":$day = 1",":$hour = 0",":$minute = 0",":$second = 0",":$timezone = 0",":&formatter","*%_"],"r":"DateTime:D"}},{"k":"m","m":1,"s":{"r":"DateTime:D","p":["Date:D :$date!","*%_"]},"d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","n":"new"},{"m":1,"k":"m","s":{"p":["Instant:D $i",":$timezone = 0","*%_"],"r":"DateTime:D"},"d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","n":"new"},{"s":{"p":["Numeric:D $time is copy",":$timezone = 0",":&formatter","*%_"],"r":"DateTime:D"},"m":1,"k":"m","n":"new","d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string"},{"d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","n":"new","k":"m","m":1,"s":{"r":"DateTime:D","p":["Str:D $datetime",":$timezone is copy",":&formatter","*%_"]}},{"m":1,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","n":"new"},{"s":{"p":[":$timezone = { ... }",":&formatter","*%_"],"r":"DateTime:D"},"k":"m","m":0,"n":"now","d":"Defined as:\n\n    method now(:$timezone = $*TZ, :&formatter --> DateTime:D)\n\nCreates a new DateTime object from the current system time. A custom\nformatter and timezone can be provided. The :$timezone is the offset in\nseconds from GMT and defaults to the value of $*TZ variable.\n\n    say DateTime.now; # OUTPUT: «2018-01-08T13:05:32.703292-06:00␤»\n\nNote that one may use the methods shown below chained to the .now to easily\nexpress current values, e.g.,\n\n    say DateTime.now.year; # OUTPUT: «2018␤»"},{"n":"clone","d":"Defined as:\n\n    method clone(:$year, :$month, :$day, :$hour, :$minute, :$second, :$timezone, :&formatter)\n\nCreates a new DateTime object based on the invocant, but with the given\narguments overriding the values from the invocant.\n\n    say DateTime.new('2015-12-24T12:23:00Z').clone(hour => 0);\n    # OUTPUT: «2015-12-24T00:23:00Z␤»\n\nNote that this can lead to invalid dates in some circumstances:\n\n    say DateTime.new(\"2012-02-29T12:34:56Z\").clone(year => 2015);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::OutOfRange: Day out of range. Is: 29, should be in 1..28␤»","s":{"r":"DateTime:D","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Instant:D"},"m":0,"k":"m","n":"Instant","d":"Defined as:\n\n    method Instant(DateTime:D: --> Instant:D)\n\nReturns an Instant object based on the invocant.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').Instant; # OUTPUT: «Instant:1450952616␤»"},{"d":"Defined as:\n\n    method posix(Bool:D: $ignore-timezone = False --> Int:D)\n\nReturns the date and time as a POSIX/UNIX timestamp (seconds since the\nEpoch, 1st January 1970 UTC).\n\nIf $ignore-timezone is True, the DateTime object will be treated as if the\ntime zone offset is zero.\n\n    say DateTime.new('2015-12-24T12:23:00Z').posix;       # OUTPUT: «1450959780␤»","n":"posix","m":0,"k":"m","s":{"p":["$ignore-timezone?","*%_"],"r":"Int:D"}},{"n":"offset","d":"Defined as:\n\n    method offset(DateTime:D: --> Int:D)\n\nReturns the time zone in seconds as an offset from UTC. This is an alias\nfor #method timezone.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset;            # OUTPUT: «7200␤»","s":{"p":["*%_"],"r":"Int:D"},"k":"m","m":0},{"d":"Defined as:\n\n    method offset-in-minutes(DateTime:D: --> Real:D)\n\nReturns the time zone in minutes as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-minutes; # OUTPUT: «120␤»","n":"offset-in-minutes","k":"m","m":0,"s":{"p":["*%_"],"r":"Rat:D"}},{"s":{"r":"Rat:D","p":["*%_"]},"k":"m","m":0,"n":"offset-in-hours","d":"Defined as:\n\n    method offset-in-hours(DateTime:D: --> Real:D)\n\nReturns the time zone in hours as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-hours;   # OUTPUT: «2␤»"},{"s":{"r":"Str:D","p":["*%_"]},"m":0,"k":"m","n":"hh-mm-ss","d":"Defined as:\n\n    method hh-mm-ss(DateTime:D: --> Str:D)\n\nReturns the time represented by the object as a string in 24-hour HH:MM:SS\nformat:\n\n    say DateTime.new(\"2052-02-29T22:34:56Z\").hh-mm-ss;\n    # OUTPUT: «22:34:56␤»"},{"s":{"r":"DateTime:D","p":[":$earlier","*%unit"]},"k":"m","m":0,"n":"later","d":"Defined as:\n\n    method later(DateTime:D: *%unit)\n\nReturns a DateTime object based on the current one, but with a time delta\napplied. The time delta can be passed as a named argument where the\nargument name is the unit.\n\nUnless the given unit is second or seconds, the given value will be\nconverted to an Int.\n\nAllowed units are second, seconds, minute, minutes, hour, hours, day, days,\nweek, weeks, month, months, year, years. Please note that the plural forms\ncan only be used with the later and earlier methods.\n\nThe :2nd form of colonpairs can be used as a compact and self-documenting\nway of specifying the delta:\n\n    say DateTime.new('2015-12-24T12:23:00Z').later(:2years);\n    # OUTPUT: «2017-12-24T12:23:00Z␤»\n\nSince addition of several different time units is not commutative, only one\nunit may be passed.\n\n    my $d = DateTime.new(date => Date.new('2015-02-27'));\n    say $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29T00:00:00Z␤»\n    say $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01T00:00:00Z␤»\n    say $d.later(days => 2).later(:month);   # same, as +True === 1\n\nIf the resultant time has value 60 for seconds, yet no leap second actually\nexists for that time, seconds will be set to 59:\n\n    say DateTime.new('2008-12-31T23:59:60Z').later: :1day;\n    # OUTPUT: «2009-01-01T23:59:59Z␤»\n\nNegative offsets are allowed, though earlier is more idiomatic for that."},{"d":"Defined as:\n\n    method truncated-to(DateTime:D: Cool $unit)\n\nReturns a copy of the invocant, with everything smaller than the specified\nunit truncated to the smallest possible value.\n\n    my $d = DateTime.new(\"2012-02-29T12:34:56.946314Z\");\n    say $d.truncated-to('second');      # OUTPUT: «2012-02-29T12:34:56Z␤»\n    say $d.truncated-to('minute');      # OUTPUT: «2012-02-29T12:34:00Z␤»\n    say $d.truncated-to('hour');        # OUTPUT: «2012-02-29T12:00:00Z␤»\n    say $d.truncated-to('day');         # OUTPUT: «2012-02-29T00:00:00Z␤»\n    say $d.truncated-to('month');       # OUTPUT: «2012-02-01T00:00:00Z␤»\n    say $d.truncated-to('year');        # OUTPUT: «2012-01-01T00:00:00Z␤»\n\nDateTimes with fractional seconds can be truncated to whole seconds with\n.truncated-to('second').","n":"truncated-to","k":"m","m":0,"s":{"r":"DateTime:D","p":["Cool $unit","*%_"]}},{"d":"Defined as:\n\n    method whole-second(DateTime:D:)\n\nReturns the second component, rounded down to an Int.\n\n    say DateTime.new('2012-02-29T12:34:56.789Z').whole-second;      # OUTPUT: «56␤»","n":"whole-second","k":"m","m":0,"s":{"p":["*%_"],"r":"Int:D"}},{"n":"in-timezone","d":"Defined as:\n\n    method in-timezone(DateTime:D: Int(Cool) $timezone = 0 --> DateTime:D)\n\nReturns a DateTime object for the same time, but in the specified\n$timezone, which is the offset in seconds from GMT.\n\n    say DateTime.new('2015-12-24T12:23:00Z').in-timezone(3600 + 1800); # OUTPUT: «2015-12-24T13:53:00+0130␤»\n\nPer RFC 7164, leap seconds do not respect local time and always occur at\nthe end of the UTC day:\n\n    say DateTime.new: '2017-01-01T00:59:60+01:00'\n    # OUTPUT: «2017-01-01T00:59:60+01:00␤»","s":{"p":["Int(Cool) $timezone","*%_"],"r":"DateTime:D"},"k":"m","m":0},{"s":{"r":"DateTime:D","p":["*%_"]},"k":"m","m":0,"n":"utc","d":"Defined as:\n\n    method utc(DateTime:D: --> DateTime:D)\n\nReturns a DateTime object for the same time, but in time zone UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').utc;\n    # OUTPUT: «2015-12-24T10:23:00Z␤»"},{"n":"local","d":"Defined as:\n\n    method local(DateTime:D: --> DateTime:D)\n\nReturns a DateTime object for the same time, but in the local time zone\n($*TZ).\n\n    my $*TZ = -3600;\n    say DateTime.new('2015-12-24T12:23:00+0200').local; # OUTPUT: «2015-12-24T09:23:00-0100␤»\n\n  sub infix:<->\n\n    multi sub infix:<-> (DateTime:D, Duration:D --> DateTime:D)\n    multi sub infix:<-> (DateTime:D, DateTime:D --> Duration:D)\n\nTakes a DateTime to subtract from and either a Duration or another DateTime\nobject. Returns a new DateTime object or the Duration between the two\ndates, respectively. When subtracting Duration, time zone of the original\nDateTime is preserved in the returned DateTime object.\n\n    say perl DateTime.new(:2016year) - DateTime.new(:2015year):;\n    # OUTPUT: «Duration.new(31536001.0)␤»\n    say DateTime.new(:2016year, :3600timezone) - Duration.new(31536001.0);\n    # OUTPUT: «2015-01-01T00:00:00+01:00␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+> (DateTime:D, Duration:D --> DateTime:D)\n    multi sub infix:<+> (Duration:D, DateTime:D --> DateTime:D)\n\nTakes a DateTime and increases it by the given Duration, preserving the\ntime zone.\n\n    say DateTime.new(:2015year) + Duration.new(31536001.0);\n    # OUTPUT: «2016-01-01T00:00:00Z␤»\n    say Duration.new(42) + DateTime.new(:2015year, :3600timezone);\n    # OUTPUT: «2015-01-01T00:00:42+01:00␤»\n\n  sub infix:«<=>»\n\n    multi sub infix:«<=>»(DateTime:D \\a, DateTime:D \\b --> Order:D)\n\nCompares the equivalent instant, returns the Order.\n\n    say DateTime.now <=> DateTime.now; # OUTPUT: «Less␤»\n\n  sub infix:«cmp»\n\n    multi sub infix:«cmp»(DateTime:D \\a, DateTime:D \\b --> Order:D)\n\nCompares the equivalent instant, returns the Order.\n\n  sub infix:«<»\n\n    multi sub infix:«<»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«>»\n\n    multi sub infix:«>»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«<=»\n\n    multi sub infix:«<=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«>=»\n\n    multi sub infix:«>=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«==»\n\n    multi sub infix:«==»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«!=»\n\n    multi sub infix:«!=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool","s":{"r":"DateTime:D","p":["*%_"]},"m":0,"k":"m"},{"n":"Date","d":"Defined as:\n\n    multi method Date(DateTime:U --> Date:U)\n    multi method Date(DateTime:D --> Date:D)\n\nConverts the invocant to Date.\n\n    say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\n    say DateTime.Date;                                    # OUTPUT: «(Date)␤»","s":{"p":["*%_"],"r":"Date:D"},"k":"m","m":1},{"d":"Defined as:\n\n    multi method Date(DateTime:U --> Date:U)\n    multi method Date(DateTime:D --> Date:D)\n\nConverts the invocant to Date.\n\n    say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\n    say DateTime.Date;                                    # OUTPUT: «(Date)␤»","n":"Date","m":1,"k":"m","s":{"r":"Date:U","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"DateTime"},"d":"Defined as:\n\n    method DateTime(--> DateTime)\n\nReturns the invocant.\n\n    say DateTime.new(\"2012-02-29T12:34:56.946314Z\").DateTime;\n    # OUTPUT: «2012-02-29T12:34:56.946314Z␤»\n    say DateTime.DateTime;\n    # OUTPUT: «(DateTime)␤»","n":"DateTime"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"hour","d":"Defined as:\n\n    method hour(DateTime:D: --> Int:D)\n\nReturns the hour component.\n\n    say DateTime.new('2012-02-29T12:34:56Z').hour;      # OUTPUT: «12␤»"},{"n":"minute","d":"Defined as:\n\n    method minute(DateTime:D: --> Int:D)\n\nReturns the minute component.\n\n    say DateTime.new('2012-02-29T12:34:56Z').minute;     # OUTPUT: «34␤»","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"second","d":"Defined as:\n\n    method second(DateTime:D:)\n\nReturns the second component, including potentially fractional seconds.\n\n    say DateTime.new('2012-02-29T12:34:56Z').second;     # OUTPUT: «56␤»\n    say DateTime.new('2012-02-29T12:34:56.789Z').second; # OUTPUT: «56.789␤»\n    say DateTime.new('2012-02-29T12:34:56,789Z').second; # comma also ok","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"timezone","d":"Defined as:\n\n    method timezone(DateTime:D: --> Int:D)\n\nReturns the time zone in seconds as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').timezone;          # OUTPUT: «7200␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"year","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"month"},{"n":"day","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"formatter"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"},{"s":{"p":["*%_"],"r":"Int:D"},"m":0,"k":"m","n":"!calculate-daycount"},{"k":"m","m":0,"s":{"r":"Nil","p":["$daycount","\\year","\\month","\\day","*%_"]},"n":"!ymd-from-daycount"},{"n":"!formatter","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"!DAYS-IN-MONTH","m":0,"k":"m","s":{"p":["\\year","\\month","*%_"],"r":"Int:D"}},{"s":{"r":"DateTime:D","p":["Int:D \\year","Int:D \\month","Int:D \\day","Int:D \\hour","Int:D \\minute","\\second","Int:D \\timezone","&formatter","*%_"]},"m":0,"k":"m","n":"!SET-SELF"},{"n":"!year-Str","m":0,"k":"m","s":{"r":"Str:D","p":["*%_"]}},{"s":{"p":["Cool:D $unit","%parts? is copy","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!truncate-ymd"},{"k":"m","m":0,"s":{"r":"Mu","p":["$unit","*%_"]},"n":"!VALID-UNIT"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"!SET-DAYCOUNT"},{"s":{"p":["*%_"],"r":"DateTime:D"},"k":"m","m":0,"n":"!clone-without-validating"},{"n":"!new-from-positional","s":{"p":["$year","$month","$day","$hour","$minute","$second","%extra",":$timezone = 0",":&formatter","*%_"],"r":"DateTime:D"},"m":0,"k":"m"},{"n":"!check-leap-second","s":{"r":"DateTime:D","p":["*%_"]},"k":"m","m":0}],"mro":["Dateish","Any"]},{"k":"v","t":"Sub+{is-pure}","n":"&item"},{"n":"item","s":{"r":"Mu","p":["\\x"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["|c is raw"]},"n":"item"},{"k":"s","m":1,"s":{"r":"Mu","p":["Mu $a"]},"n":"item"},{"k":"v","n":"&samemark","t":"Sub"},{"n":"samemark","s":{"p":["$s","$pat"],"r":"Str:D"},"m":1,"k":"s"},{"k":"e","t":"Endian","n":"NativeEndian"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<x>","k":"v"},{"n":"infix:<x>","s":{"r":"Mu","p":[]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["$x"],"r":"Mu"},"n":"infix:<x>"},{"n":"infix:<x>","s":{"r":"Mu","p":["$s","Num:D $n"]},"k":"s","m":1},{"n":"infix:<x>","s":{"r":"Mu","p":["$s","Any:D $n"]},"m":1,"k":"s"},{"s":{"r":"Mu","p":["$s","Any:U $n"]},"k":"s","m":1,"n":"infix:<x>"},{"s":{"r":"Str:D","p":["Str:D $s","Bool:D $repetition"]},"m":1,"k":"s","n":"infix:<x>"},{"m":1,"k":"s","s":{"p":["Str:D $s","Int:D $repetition"],"r":"Str:D"},"n":"infix:<x>"},{"n":"infix:<x>","k":"s","m":1,"s":{"r":"str","p":["str $s","int $repetition"]}},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<(.)>"},{"n":"infix:<(.)>","s":{"p":[],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<(.)>","k":"s","m":1,"s":{"p":["Setty:D \\a"],"r":"Mu"}},{"n":"infix:<(.)>","k":"s","m":1,"s":{"r":"Mu","p":["Baggy:D \\a"]}},{"s":{"r":"Mu","p":["\\a"]},"k":"s","m":1,"n":"infix:<(.)>"},{"k":"s","m":1,"s":{"p":["Setty:D \\a","Setty:D \\b"],"r":"Mu"},"n":"infix:<(.)>"},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Mixy:D \\a","Mixy:D \\b"]},"m":1,"k":"s"},{"n":"infix:<(.)>","s":{"p":["Mixy:D \\a","Baggy:D \\b"],"r":"Mu"},"k":"s","m":1},{"n":"infix:<(.)>","k":"s","m":1,"s":{"p":["Mixy:D \\a","\\b"],"r":"Mu"}},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Setty:D \\a","Mixy:D \\b"]},"k":"s","m":1},{"s":{"p":["Baggy:D \\a","Mixy:D \\b"],"r":"Mu"},"m":1,"k":"s","n":"infix:<(.)>"},{"n":"infix:<(.)>","m":1,"k":"s","s":{"p":["\\a","Mixy:D \\b"],"r":"Mu"}},{"n":"infix:<(.)>","m":1,"k":"s","s":{"r":"Mu","p":["Baggy:D \\a","Baggy:D \\b"]}},{"n":"infix:<(.)>","k":"s","m":1,"s":{"p":["$","Failure:D \\b"],"r":"Mu"}},{"n":"infix:<(.)>","s":{"r":"Mu","p":["Failure:D \\a","$"]},"m":1,"k":"s"},{"n":"infix:<(.)>","s":{"r":"Mu","p":["\\a","\\b"]},"m":1,"k":"s"},{"m":1,"k":"s","s":{"r":"Mu","p":["**@p"]},"n":"infix:<(.)>"},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<*>"},{"n":"infix:<*>","k":"s","m":1,"s":{"r":"Mu","p":["$x = 1"]}},{"n":"infix:<*>","k":"s","m":1,"s":{"r":"Mu","p":["\\a","\\b"]}},{"n":"infix:<*>","s":{"p":["Real \\a","Real \\b"],"r":"Mu"},"m":1,"k":"s"},{"n":"infix:<*>","k":"s","m":1,"s":{"p":["Int:D \\a","Int:D \\b"],"r":"Int:D"}},{"n":"infix:<*>","s":{"r":"int","p":["int $a","int $b"]},"k":"s","m":1},{"k":"s","m":1,"s":{"r":"Mu","p":["Num:D \\a","Num:D \\b"]},"n":"infix:<*>"},{"n":"infix:<*>","k":"s","m":1,"s":{"p":["num $a","num $b"],"r":"num"}},{"n":"infix:<*>","k":"s","m":1,"s":{"r":"Mu","p":["Range:D \\r","Real:D \\v"]}},{"s":{"r":"Mu","p":["Real:D \\v","Range:D \\r"]},"m":1,"k":"s","n":"infix:<*>"},{"n":"infix:<*>","m":1,"k":"s","s":{"r":"Mu","p":["Rational:D \\a","Rational:D \\b"]}},{"s":{"r":"Mu","p":["Rational:D \\a","Int:D \\b"]},"m":1,"k":"s","n":"infix:<*>"},{"n":"infix:<*>","m":1,"k":"s","s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Mu"}},{"n":"infix:<*>","m":1,"k":"s","s":{"p":["Complex:D \\a","Complex:D \\b"],"r":"Complex:D"}},{"m":1,"k":"s","s":{"r":"Complex:D","p":["Complex:D \\a","Num(Real) \\b"]},"n":"infix:<*>"},{"n":"infix:<*>","s":{"r":"Complex:D","p":["Num(Real) \\a","Complex:D \\b"]},"k":"s","m":1},{"a":[{"t":"Int","n":"$.numerator","k":"v"},{"k":"v","t":"Int","n":"$.denominator"}],"t":"RatStr","d":"TITLE\nclass RatStr\n\nSUBTITLE\nDual value rational number and string\n\n    class RatStr is Rat is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1>; say $f.^name; # OUTPUT: «RatStr␤»\n\nAs a subclass of both Rat and Str, a RatStr will be accepted where either\nis expected. However, RatStr does not share object identity with Rat- or\nStr-only variants:\n\n    my $rat-str = <42.1>;\n    my Rat $rat = $rat-str; # OK!\n    my Str $str = $rat-str; # OK!\n    say 42.1 ∈ <42.1  55  1>; # False; ∈ operator cares about object identity\n\n","n":"RatStr","k":"c","m":[{"s":{"r":"Mu","p":["Rat $r","Str $s","*%_"]},"m":0,"k":"m","n":"new","d":"method new(Rat $i, Str $s)\n\nThe constructor requires both the Rat and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = RatStr.new(42.1, \"forty two and a bit\");\n    say +$f; # OUTPUT: «42.1␤»\n    say ~$f; # OUTPUT: «\"forty two and a bit\"␤»"},{"n":"succ","k":"m","m":0,"s":{"r":"Rat:D","p":["*%_"]}},{"k":"m","m":0,"s":{"r":"Rat:D","p":["*%_"]},"n":"pred"},{"d":"Defined as:\n\n    method Capture(RatStr:D --> Capture:D)\n\nEquivalent to Mu.Capture.","n":"Capture","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"method Rat\n\nReturns the Rat value of the RatStr.","n":"Rat","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["Rational[Int,Int]","Real","Numeric","Stringy","Rat","Str"],"b":"C"},{"n":"&postcircumfix:<{; }>","t":"Sub+{is-nodal}","k":"v"},{"s":{"r":"Mu","p":["\\SELF","@indices"]},"k":"s","m":1,"n":"postcircumfix:<{; }>"},{"n":"postcircumfix:<{; }>","s":{"p":["\\SELF","@indices",":$exists!"],"r":"Mu"},"m":1,"k":"s"},{"t":"Sub+{is-pure}+{Precedence}","n":"&infix:<mod>","k":"v"},{"n":"infix:<mod>","k":"s","m":1,"s":{"p":["Real $a","Real $b"],"r":"Mu"}},{"t":"Sub+{is-pure}","n":"&infix:<≤>","k":"v"},{"k":"s","m":1,"s":{"r":"Mu","p":["$?"]},"n":"infix:«<=»"},{"n":"infix:«<=»","k":"s","m":1,"s":{"p":["\\a","\\b"],"r":"Mu"}},{"k":"s","m":1,"s":{"r":"Mu","p":["Real \\a","Real \\b"]},"n":"infix:«<=»"},{"n":"infix:«<=»","s":{"p":["Int:D \\a","Int:D \\b"],"r":"Bool:D"},"m":1,"k":"s"},{"s":{"r":"Bool:D","p":["int $a","int $b"]},"m":1,"k":"s","n":"infix:«<=»"},{"s":{"r":"Bool:D","p":["Num:D \\a","Num:D \\b"]},"k":"s","m":1,"n":"infix:«<=»"},{"n":"infix:«<=»","m":1,"k":"s","s":{"r":"Bool:D","p":["num $a","num $b"]}},{"n":"infix:«<=»","m":1,"k":"s","s":{"r":"Bool:D","p":["Rational:D \\a","Rational:D \\b"]}},{"n":"infix:«<=»","k":"s","m":1,"s":{"p":["Rational:D \\a","Int:D \\b"],"r":"Bool:D"}},{"s":{"p":["Int:D \\a","Rational:D \\b"],"r":"Bool:D"},"m":1,"k":"s","n":"infix:«<=»"},{"m":1,"k":"s","s":{"r":"Bool:D","p":["Instant:D $a","Instant:D $b"]},"n":"infix:«<=»"},{"n":"infix:«<=»","s":{"p":["DateTime:D \\a","DateTime:D \\b"],"r":"Bool:D"},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Date:D $a","Date:D $b"],"r":"Bool:D"},"n":"infix:«<=»"},{"s":{"r":"Mu","p":["Version:D \\a","Version:D \\b"]},"k":"s","m":1,"n":"infix:«<=»"},{"b":"C","n":"Buf","d":"TITLE\nrole Buf\n\nSUBTITLE\nMutable buffer for binary data\n\n    role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T){ ... }\n\nA Buf does the role of a mutable sequence of (usually unsigned) integers.\n\n    my $b = Buf.new(1, 2, 3);\n    $b[1] = 42;\n\nHowever, it's a parameterized type, and you can instantiate with several\ninteger types:\n\n    my $b = Buf[int32].new( 3, -3, 0xff32, -44)\n    # OUTPUT: «Buf[int32]:0x<03 -3 FF32 -2C>»\n\n\nBy default, Buf uses 8-bit unsigned integers, that is, it is equivalent to\nBuf[uint8]. Some other types of Bufs which are used often get their own\nclass name.\n\n  buf8   Buf[uint8]\n  buf16  Buf[uint16]\n  buf32  Buf[uint32]\n  buf64  Buf[uint64]\n\n\nYou can use these in pretty much the same way you would with Buf:\n\n    my $buf = buf8.new(3,6, 254);\n    say $buf; # OUTPUT: «Buf[uint8]:0x<03 06 fe>␤»\n\nPlus there are some object methods, like encode that might return a buf8 in\nsome cases where it is the best representation for a particular encoding.\n\n","t":"Buf","mro":[],"m":[{"n":"write-int8","d":"Defined as:\n\n    method write-int8(buf8: uint $pos, int8 $value, $endian = NativeEndian --> buf8:D)\n\nWrites a signed 8-bit integer value at the given position. The $endian\nparameter has no meaning, but is available for consistency.","s":{"r":"Nil","p":["int $offset","int8 $value","Endian $endian = Endian::NativeEndian","*%_"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    method write-int16(buf8: uint $pos, int16 $value, $endian = NativeEndian --> buf8:D)\n\nWrites a signed 16-bit integer value at the given position with the given\nendianness.","n":"write-int16","m":0,"k":"m","s":{"p":["int $offset","int16 $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"}},{"d":"Defined as:\n\n    method write-int32(buf8: uint $pos, int32 $value, $endian = NativeEndian --> buf8:D)\n\nWrites a signed 32-bit integer value at the given position with the given\nendianness.","n":"write-int32","m":0,"k":"m","s":{"r":"Nil","p":["int $offset","int32 $value","Endian $endian = Endian::NativeEndian","*%_"]}},{"d":"Defined as:\n\n    method write-int64(buf8: uint $pos, Int:D $value, $endian = NativeEndian --> buf8:D)\n\nWrites a signed 64-bit integer value at the given position with the given\nendianness.","n":"write-int64","m":0,"k":"m","s":{"p":["int $offset","Int:D $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"}},{"d":"Defined as:\n\n    method write-int128(buf8: uint $pos, Int:D $value, $endian = NativeEndian --> buf8:D)\n\nWrites a signed 128-bit integer value at the given position with the given\nendianness.","n":"write-int128","k":"m","m":0,"s":{"r":"Nil","p":["int $offset","Int:D $value","Endian $endian = Endian::NativeEndian","*%_"]}},{"k":"m","m":0,"s":{"p":["int $offset","uint8 $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"},"d":"Defined as:\n\n    method write-uint8(buf8: uint $pos, uint8 $value, $endian = NativeEndian --> buf8:D)\n\nWrites an unsigned 8-bit integer value at the given position. The $endian\nparameter has no meaning, but is available for consistency.","n":"write-uint8"},{"s":{"p":["int $offset","uint16 $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"},"k":"m","m":0,"n":"write-uint16","d":"Defined as:\n\n    method write-uint16(buf8: uint $pos, uint16 $value, $endian = NativeEndian --> buf8:D)\n\nWrites an unsigned 16-bit integer value at the given position with the\ngiven endianness."},{"n":"write-uint32","d":"Defined as:\n\n    method write-uint32(buf8: uint $pos, uint32 $value, $endian = NativeEndian --> buf8:D)\n\nWrites an unsigned 32-bit integer value at the given position with the\ngiven endianness.","s":{"p":["int $offset","uint32 $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Nil","p":["int $offset","Int:D $value where { ... }","Endian $endian = Endian::NativeEndian","*%_"]},"d":"Defined as:\n\n    method write-uint64(buf8: uint $pos, uint64 $value, $endian = NativeEndian --> buf8:D)\n\nWrites an unsigned 64-bit integer value at the given position with the\ngiven endianness.","n":"write-uint64"},{"k":"m","m":0,"s":{"p":["int $offset","Int:D $value where { ... }","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"},"d":"Defined as:\n\n    method write-uint128(buf8: uint $pos, UInt:D $value, $endian = NativeEndian --> buf8:D)\n\nWrites an unsigned 128-bit integer value at the given position with the\ngiven endianness.","n":"write-uint128"},{"n":"write-num32","d":"Defined as:\n\n    method write-num32(buf8: uint $pos, num32 $value, $endian = NativeEndian --> buf8:D)\n\nWrites a native num32 IEEE floating point value at the given position with\nthe given endianness.","s":{"p":["int $offset","num32 $value","Endian $endian = Endian::NativeEndian","*%_"],"r":"Nil"},"m":0,"k":"m"},{"m":0,"k":"m","s":{"r":"Nil","p":["int $offset","num64 $value","Endian $endian = Endian::NativeEndian","*%_"]},"d":"Defined as:\n\n    method write-num64(buf8: uint $pos, num64 $value, $endian = NativeEndian --> buf8:D)\n\nWrites a native num64 IEEE floating point value at the given position with\nthe given endianness.","n":"write-num64"},{"n":"write-bits","d":"Defined as:\n\n    method write-bits(buf8: uint $pos, uint $bits, Int:D $value --> buf8:D)\n\nWrites a signed integer value for the bits from the given bit offset and\ngiven number of bits. The endianness of the bits is assumed to be\nBigEndian.","s":{"r":"Nil","p":["int $pos","Int:D $bits","Int:D \\value","*%_"]},"m":0,"k":"m"},{"d":"Defined as:\n\n    method write-ubits(buf8: uint $pos, uint $bits, UInt:D $value --> buf8:D)\n\nWrites an unsigned integer value to the bits from the given bit offset and\ngiven number of bits. The endianness of the bits is assumed to be\nBigEndian.","n":"write-ubits","k":"m","m":0,"s":{"r":"Nil","p":["int $pos","Int:D $bits","Int:D \\value where { ... }","*%_"]}},{"k":"m","m":0,"s":{"p":["Int:D $elements","*%_"],"r":"Mu"},"d":"method reallocate($elems)\n\nChange the number of elements of the Buf, returning the changed Buf. The\nsize of Buf will be adapted depending on the number of $elems specified: if\nit is smaller than the actual size of the Buf the resulting Buf will be\nshrunk down, otherwise it will be enlarged to fit the number of $elems. In\nthe case the Buf is enlarged, newly created items will be assigned a\nVirtual Machine specific null value, therefore you should not rely upon\ntheir value since it could be inconsistent across different virtual\nmachines.\n\n    my Buf $b .= new(^10);\n    $b.reallocate(5);\n    say $b.perl;  # OUTPUT: «Buf.new(0,1,2,3,4)␤»\n\n    $b = Buf.new( 1..3 );\n    $b.reallocate( 10 );\n    $b.perl.say; # OUTPUT: «Buf.new(1,2,3,0,0,0,0,0,0,0)␤»","n":"reallocate"},{"s":{"r":"Mu","p":["$from = 0","$elems = { ... }","*%_"]},"k":"m","m":0,"n":"subbuf-rw","d":"Declared as\n\n    multi sub subbuf-rw(Buf:D \\b) is rw\n    multi sub subbuf-rw(Buf:D \\b, Int() $from) is rw\n    multi sub subbuf-rw(Buf:D \\b, $from, $elems) is rw\n\nReturns a writable reference to a part of a buffer. Invokes the subbuf-rw\nmethod on the specified Buf:\n\n    my Buf $b .= new(1,2,3);\n    subbuf-rw($b,2,1) = Buf.new(42);\n    say $b.perl;   # OUTPUT: «Buf.new(1,2,42)␤»"},{"m":0,"k":"m","s":{"r":"Mu","p":["Int:D $offset","$size","\\x","*%_"]},"n":"!splice-native"},{"n":"!pend","s":{"r":"Mu","p":["@values","$action","*%_"]},"m":0,"k":"m"},{"s":{"p":["\\offset","\\size","*%_"],"r":"Mu"},"m":0,"k":"m","n":"!remove"}],"k":"ro"},{"t":"Sub","n":"&push","k":"v"},{"s":{"r":"Mu","p":["\\a","|elems is raw"]},"k":"s","m":1,"n":"push"},{"k":"ro","m":[{"n":"of","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Baggy:D","p":["*@pairs","*%_"]},"d":"Defined as:\n\n    method new-from-pairs(*@pairs --> Baggy:D)\n\nConstructs a Baggy objects from a list of Pair objects given as positional\narguments:\n\n    say Mix.new-from-pairs: 'butter' => 0.22, 'sugar' => 0.1, 'sugar' => 0.02;\n    # OUTPUT: «mix(butter(0.22), sugar(0.12))␤»\n\nNote: be sure you aren't accidentally passing the Pairs as positional\narguments; the quotes around the keys in the above example are\nsignificant.","n":"new-from-pairs"},{"n":"default","d":"Defined as:\n\n    method default(Baggy:D: --> Int:D)\n\nReturns zero.\n\n    my $breakfast = bag <eggs bacon>;\n    say $breakfast.default;                           # OUTPUT: «0␤»","s":{"p":["*%_"],"r":"Int"},"k":"m","m":0},{"n":"RAW-HASH","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["\\type","*%_"],"r":"Mu"},"k":"m","m":0,"n":"!HASHIFY"},{"n":"!create-from-iterator","m":0,"k":"m","s":{"r":"Baggy:D","p":["\\type","\\iterator","*%_"]}}],"mro":[],"t":"Baggy","a":[{"t":"Rakudo::Internals::IterationSet","n":"$!elems","k":"v"}],"d":"TITLE\nrole Baggy\n\nSUBTITLE\nCollection of distinct weighted objects\n\n    role Baggy does QuantHash { }\n\nA role for collections of weighted objects. See Bag, BagHash, and Mixy.\n\n","n":"Baggy","b":"C"},{"b":"C","n":"pi","t":"Num","mro":["Real","Numeric","Cool"],"k":"c"},{"k":"v","t":"Sub+{is-nodal}","n":"&elems"},{"m":1,"k":"s","s":{"r":"Mu","p":["$a"]},"n":"elems"},{"b":"A","t":"Slang","a":[{"n":"$.grammar","t":"Mu","k":"v"},{"k":"v","n":"$.actions","t":"Mu"}],"n":"Slang","m":[{"k":"m","m":0,"s":{"p":["|c is raw"],"r":"Mu"},"n":"parse"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"grammar"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"actions"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"m":0,"k":"s"}],"k":"c","mro":["Any"]},{"k":"e","t":"Signal","n":"SIGPWR"},{"k":"v","n":"&categorize","t":"Sub"},{"n":"categorize","m":1,"k":"s","s":{"p":["$test","+\\items is raw",":$into!","*%named"],"r":"Mu"}},{"n":"categorize","k":"s","m":1,"s":{"p":["$test","+\\items is raw","*%named"],"r":"Mu"}},{"k":"v","t":"Sub+{is-pure}+{Precedence}","n":"&infix:<^>"},{"m":1,"k":"s","s":{"p":["+\\values is raw"],"r":"Mu"},"n":"infix:<^>"},{"k":"v","n":"&emit","t":"Sub+{Callable[Nil]}"},{"s":{"r":"Nil","p":["Mu \\value"]},"m":0,"k":"s","n":"emit"},{"a":[{"t":"HyperConfiguration","n":"$.configuration","k":"v"},{"k":"v","t":"Rakudo::Internals::HyperWorkStage","n":"$!work-stage-head"},{"k":"v","t":"Mu","n":"$!list"}],"d":"TITLE\nclass RaceSeq\n\nSUBTITLE\nPerforms batches of work in parallel without respecting original order.\n\n    class RaceSeq does Iterable does Sequence { }\n\nAn RaceSeq is the intermediate object used when the operator race is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n","t":"RaceSeq","n":"RaceSeq","k":"c","m":[{"m":0,"k":"s","s":{"r":"Mu","p":[":configuration($!configuration)!",":work-stage-head($!work-stage-head)!","*%_"]},"n":"BUILD"},{"n":"iterator","d":"method iterator(RaceSeq:D: --> Iterator:D)\n\nReturns the underlying iterator.","s":{"p":["*%_"],"r":"Iterator"},"m":0,"k":"m"},{"d":"method grep(RaceSeq:D: $matcher, *%options)\n\nApplies grep to the RaceSeq similarly to how it would do it on a Seq.\n\n    my @raced = (^10000).map(*²).race;\n    @raced.grep( * %% 3 ).say;\n    # OUTPUT: «(0 9 36 81 144 …»\n\n\nWhen you use race on a Seq, this is the method that is actually called.","n":"grep","k":"m","m":0,"s":{"r":"Mu","p":["$matcher","*%options"]}},{"s":{"r":"Mu","p":["$matcher","*%options"]},"k":"m","m":0,"n":"map","d":"method map(RaceSeq:D: $matcher, *%options)\n\nUses maps on the RaceSeq, generally created by application of .race to a\npreexisting Seq."},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"invert","d":"method invert(RaceSeq:D:)\n\nInverts the RaceSeq created from a Seq by .race."},{"d":"method hyper(RaceSeq:D:)\n\nCreates a HyperSeq object out of the current one.","n":"hyper","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"method race(RaceSeq:D:)\n\nReturns the object.","n":"race"},{"s":{"p":["*%_"],"r":"Bool"},"m":0,"k":"m","n":"is-lazy","d":"method is-lazy(--> False )\n\nReturns False."},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"d":"Defined as:\n\n    method sink(--> Nil)\n\nSinks the underlying data structure, producing any side effects.","n":"sink"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"configuration"},{"n":"BUILDALL","s":{"r":"Mu","p":["@auto","%init","*%_"]},"k":"s","m":0}],"mro":["Sequence","PositionalBindFailover","Iterable","Any"],"b":"A"},{"n":"&nextwith","t":"Sub","k":"v"},{"n":"nextwith","m":0,"k":"s","s":{"p":["|c is raw"],"r":"Mu"}},{"t":"Sub+{is-pure}","n":"&set","k":"v"},{"m":1,"k":"s","s":{"p":[],"r":"Mu"},"n":"set"},{"n":"set","s":{"p":["*@a"],"r":"Set:D"},"k":"s","m":1},{"k":"v","n":"&abs","t":"Sub+{is-pure}"},{"s":{"p":["\\a"],"r":"Mu"},"m":1,"k":"s","n":"abs"},{"s":{"r":"Mu","p":["Real \\a"]},"m":1,"k":"s","n":"abs"},{"s":{"p":["Int:D \\a"],"r":"Int:D"},"m":1,"k":"s","n":"abs"},{"n":"abs","s":{"p":["int $a"],"r":"int"},"k":"s","m":1},{"n":"abs","s":{"r":"Mu","p":["Num:D \\a"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["num $a"],"r":"num"},"n":"abs"},{"n":"abs","s":{"p":["Complex:D \\a"],"r":"Num:D"},"m":1,"k":"s"},{"n":"Promise","a":[{"k":"v","n":"$.scheduler","t":"Mu"},{"k":"v","n":"$.status","t":"Mu"},{"k":"v","n":"$!result","t":"Mu"},{"k":"v","t":"int","n":"$!vow_taken"},{"k":"v","t":"Mu","n":"$!lock"},{"n":"$!cond","t":"Mu","k":"v"},{"n":"$!thens","t":"Mu","k":"v"},{"k":"v","n":"$!dynamic_context","t":"Mu"},{"n":"$!report-broken-if-sunk","t":"Bool","k":"v"}],"t":"Promise","d":"TITLE\nclass Promise\n\nSUBTITLE\nStatus/result of an asynchronous computation\n\n    my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));\n    class Promise {}\n\nA Promise is used to handle the result of a computation that might not have\nfinished. It allows the user to execute code once the computation is done\n(with the then method), execution after a time delay (with in), combining\npromises, and waiting for results.\n\n    my $p = Promise.start({ sleep 2; 42});\n    $p.then({ say .result });   # will print 42 once the block finished\n    say $p.status;              # OUTPUT: «Planned␤»\n    $p.result;                  # waits for the computation to finish\n    say $p.status;              # OUTPUT: «Kept␤»\n\nThere are two typical scenarios for using promises. The first is to use a\nfactory method (start, in, at, anyof, allof, kept, broken) on the type\nobject; those will make sure that the promise is automatically kept or\nbroken for you, and you can't call break or keep on these promises\nyourself.\n\nThe second is to create your promises yourself with Promise.new. If you\nwant to ensure that only your code can keep or break the promise, you can\nuse the vow method to get a unique handle, and call keep or break on it:\n\n    sub async-get-with-promise($user-agent, $url) {\n        my $p = Promise.new;\n        my $v = $p.vow;\n\n        # do an asynchronous call on a fictive user agent,\n        # and return the promise:\n        $user-agent.async-get($url,\n                on-error => -> $error {\n                    $v.break($error);\n                },\n                on-success => -> $response {\n                    $v.keep($response);\n                }\n        );\n        return $p;\n    }\n\n\nFurther examples can be found in the concurrency page.\n\n","mro":["Awaitable","Any"],"k":"c","m":[{"n":"new","s":{"r":"Mu","p":[":$scheduler = { ... }",":$report-broken-if-sunk","*%_"]},"m":0,"k":"s"},{"s":{"p":[":scheduler($!scheduler) = { ... }",":$report-broken-if-sunk","*%_"],"r":"Nil"},"k":"s","m":0,"n":"BUILD"},{"n":"vow","d":"my class Vow {\n        has Promise $.promise;\n        method keep() { ... }\n        method break() { ... }\n    }\n    method vow(Promise:D: --> Vow:D)\n\n\nReturns an object that holds the sole authority over keeping or breaking a\npromise. Calling keep or break on a promise that has vow taken throws an\nexception of type X::Promise::Vowed.\n\n    my $p   = Promise.new;\n    my $vow = $p.vow;\n    $vow.keep($p);\n    say $p.status;          # OUTPUT: «Kept␤»","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0},{"n":"kept","d":"multi method kept(Promise:U: \\result = True --> Promise:D)\n\nReturns a new promise that is already kept, either with the given value, or\nwith the default value True.","s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1},{"m":1,"k":"m","s":{"p":["Mu \\result","*%_"],"r":"Mu"},"d":"multi method kept(Promise:U: \\result = True --> Promise:D)\n\nReturns a new promise that is already kept, either with the given value, or\nwith the default value True.","n":"kept"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"keep","d":"multi method keep(Promise:D: \\result = True)\n\nKeeps a promise, optionally setting the result. If no result is passed, the\nresult will be True.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    if Bool.pick {\n        $p.keep;\n    }\n    else {\n         $p.break;\n    }"},{"d":"multi method keep(Promise:D: \\result = True)\n\nKeeps a promise, optionally setting the result. If no result is passed, the\nresult will be True.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    if Bool.pick {\n        $p.keep;\n    }\n    else {\n         $p.break;\n    }","n":"keep","m":1,"k":"m","s":{"p":["Mu \\result","*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":1,"n":"broken","d":"multi method broken(Promise:U: --> Promise:D)\n    multi method broken(Promise:U: \\exception --> Promise:D)\n\nReturns a new promise that is already broken, either with the given value,\nor with the default value X::AdHoc.new(payload => \"Died\")"},{"k":"m","m":1,"s":{"p":["Mu \\exception","*%_"],"r":"Mu"},"d":"multi method broken(Promise:U: --> Promise:D)\n    multi method broken(Promise:U: \\exception --> Promise:D)\n\nReturns a new promise that is already broken, either with the given value,\nor with the default value X::AdHoc.new(payload => \"Died\")","n":"broken"},{"d":"multi method break(Promise:D: \\cause = False)\n\nBreaks a promise, optionally setting the cause. If no cause is passed, the\ncause will be False.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    $p.break('sorry');\n    say $p.status;          # OUTPUT: «Broken␤»\n    say $p.cause;           # OUTPUT: «sorry␤»","n":"break","k":"m","m":1,"s":{"r":"Mu","p":["*%_"]}},{"d":"multi method break(Promise:D: \\cause = False)\n\nBreaks a promise, optionally setting the cause. If no cause is passed, the\ncause will be False.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    $p.break('sorry');\n    say $p.status;          # OUTPUT: «Broken␤»\n    say $p.cause;           # OUTPUT: «sorry␤»","n":"break","m":1,"k":"m","s":{"p":["\\result","*%_"],"r":"Mu"}},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"result","d":"method result(Promise:D)\n\nWaits for the promise to be kept or broken. If it is kept, returns the\nresult; otherwise throws the result as an exception."},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method cause(Promise:D)\n\nIf the promise was broken, returns the result (or exception). Otherwise,\nthrows an exception of type X::Promise::CauseOnlyValidOnBroken.","n":"cause"},{"s":{"p":["&code","*%_"],"r":"Mu"},"m":0,"k":"m","n":"then","d":"method then(Promise:D: &code)\n\nSchedules a piece of code to be run after the invocant has been kept or\nbroken, and returns a new promise for this computation. In other words,\ncreates a chained promise.\n\n    my $timer = Promise.in(2);\n    my $after = $timer.then({ say \"2 seconds are over!\"; 'result' });\n    say $after.result;  # 2 seconds are over\n                        # result"},{"n":"get-await-handle","s":{"r":"Awaitable::Handle:D","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Nil","p":["*%_"]},"n":"sink"},{"d":"method start(Promise:U: &code, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that runs the given code object. The promise will be\nkept when the code terminates normally, or broken if it throws an\nexception. The return value or exception can be inspected with the result\nmethod.\n\nThe scheduler that handles this promise can be passed as a named argument.\n\nThere is also a statement prefix start that provides syntactic sugar for\nthis method:\n\n    # these two are equivalent:\n    my $p1 = Promise.start({ ;#`( do something here ) });\n    my $p2 = start { ;#`( do something here ) };\n\nAs of the 6.d version of the language, start statement prefix used in sink\ncontext will automatically attach an exceptions handler. If an exception\noccurs in the given code, it will be printed and the program will then\nexit, like if it were thrown without any start statement prefixes\ninvolved.\n\n    use v6.c;\n    start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n\n    use v6.d;\n    start { die }; sleep ⅓; say \"hello\";\n    # OUTPUT:\n    # Unhandled exception in code scheduled on thread 4\n    # Died\n    #     in block  at -e line 1\n\n\nIf you wish to avoid this behavior, use start in non-sink context or catch\nthe exception yourself:\n\n    # Don't sink it:\n    my $ = start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n    # Catch yourself:\n    start { die; CATCH { default { say \"caught\" } } };\n    sleep ⅓;\n    say \"hello\";\n    # OUTPUT: «caught␤hello␤»\n\n\nThis behavior exists only syntactically, by using an alternate .sink method\nfor Promise objects created by start blocks in sink context, thus simply\nsinking a Promise object that was created by other means won't trigger this\nbehavior.","n":"start","k":"m","m":0,"s":{"p":["&code",":&catch",":$scheduler = { ... }",":$report-broken-if-sunk","|c is raw"],"r":"Mu"}},{"d":"method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that will be kept in $seconds seconds, or later.\n\n    my $proc = Proc::Async.new('perl6', '-e', 'sleep 10; warn \"end\"');\n\n    my $result = await Promise.anyof(\n        my $promise = $proc.start,  # may or may not work in time\n        Promise.in(5).then: {       # fires after 5 seconds no matter what\n            unless $promise {       # don't do anything if we were successful\n                note 'timeout';\n                $proc.kill;\n            }\n        }\n    ).then: { $promise.result }\n    # OUTPUT: «timeout␤»\n\n$seconds can be fractional or negative. Negative values are treated as 0\n(i.e. keeping the returned Promise right away).\n\nPlease note that situations like these are often more clearly handled with\na react and whenever block.","n":"in","k":"m","m":0,"s":{"p":["$seconds",":$scheduler = { ... }","*%_"],"r":"Mu"}},{"k":"m","m":0,"s":{"r":"Mu","p":["$at",":$scheduler = { ... }","*%_"]},"d":"method at(Promise:U: $at, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that will be kept $at the given time—which is given\nas an Instant or equivalent Numeric—or as soon as possible after it.\n\n    my $p = Promise.at(now + 2).then({ say \"2 seconds later\" });\n    # do other stuff here\n\n    await $p;   # wait here until the 2 seconds are over\n\nIf the given time is in the past, it will be treated as now (i.e. keeping\nthe returned Promise right away).\n\nPlease note that situations like these are often more clearly handled with\na react and whenever block.","n":"at"},{"s":{"r":"Mu","p":["*@p","*%_"]},"k":"m","m":0,"n":"anyof","d":"method anyof(Promise:U: *@promises --> Promise:D)\n\nReturns a new promise that will be kept as soon as any of the promises\npassed as arguments is kept or broken. The result of the completed Promise\nis not reflected in the result of the returned promise which will always be\nKept.\n\nYou can use this to wait at most a number of seconds for a promise:\n\n    my $timeout = 5;\n    await Promise.anyof(\n        Promise.in($timeout),\n        start {\n            # do a potentially long-running calculation here\n        },\n    );"},{"s":{"p":["*@p","*%_"],"r":"Mu"},"m":0,"k":"m","n":"allof","d":"method allof(Promise:U: *@promises --> Promise:D)\n\nReturns a new promise that will be kept when all the promises passed as\narguments are kept or broken. The result of the individual Promises is not\nreflected in the result of the returned promise: it simply indicates that\nall the promises have been completed in some way. If the results of the\nindividual promises are important then they should be inspected after the\nallof promise is kept.\n\nIn the following requesting the result of a broken promise will cause the\noriginal Exception to be thrown. (You may need to run it several times to\nsee the exception.)\n\n    my @promises;\n    for 1..5 -> $t {\n        push @promises, start {\n            sleep $t;\n        };\n    }\n    my $all-done = Promise.allof(@promises);\n    await $all-done;\n    @promises>>.result;\n    say \"Promises kept so we get to live another day!\";"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"d":"method scheduler(Promise:D:)\n\nReturns the scheduler that manages the promise.","n":"scheduler"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"status","d":"method status(Promise:D --> PromiseStatus)\n\nReturns the current state of the promise: Kept, Broken or Planned:\n\n    say \"promise got Kept\" if $promise.status ~~ Kept;"},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}},{"n":"!break","k":"m","m":0,"s":{"r":"Nil","p":["\\result","*%_"]}},{"n":"!until_n_kept","s":{"r":"Mu","p":["@promises","Int:D $N","Str $combinator","*%_"]},"k":"m","m":0},{"n":"!schedule_thens","k":"m","m":0,"s":{"p":["*%_"],"r":"Nil"}},{"n":"!keep","s":{"p":["Mu \\result","*%_"],"r":"Nil"},"k":"m","m":0}],"b":"A"},{"t":"num32","n":"num32","k":"n"},{"k":"v","n":"&prefix:<?>","t":"Sub+{is-pure}+{Precedence}"},{"n":"prefix:<?>","m":1,"k":"s","s":{"p":["Bool:D \\a"],"r":"Mu"}},{"n":"prefix:<?>","s":{"r":"Mu","p":["Bool:U \\a"]},"m":1,"k":"s"},{"n":"prefix:<?>","s":{"r":"Mu","p":["Mu \\a"]},"k":"s","m":1},{"b":"A","t":"Exceptions::JSON","n":"Exceptions::JSON","m":[{"m":0,"k":"m","s":{"r":"Mu","p":["$ex","*%_"]},"n":"process"}],"k":"c","mro":["Any"]},{"t":"Sub","n":"&undefine","k":"v"},{"n":"undefine","k":"s","m":1,"s":{"p":["Mu \\x"],"r":"Mu"}},{"s":{"p":["Array \\x"],"r":"Mu"},"m":1,"k":"s","n":"undefine"},{"k":"s","m":1,"s":{"r":"Mu","p":["Hash \\x"]},"n":"undefine"},{"k":"v","n":"&substr-rw","t":"Sub"},{"k":"s","m":1,"s":{"p":["\\what"],"r":"Mu"},"n":"substr-rw"},{"n":"substr-rw","k":"s","m":1,"s":{"r":"Mu","p":["\\what","\\from"]}},{"n":"substr-rw","m":1,"k":"s","s":{"p":["\\what","\\from","\\chars"],"r":"Mu"}},{"m":[{"n":"new","d":"Defined as:\n\n    multi method new(Real $re, Real $im --> Complex:D)\n\nCreates a new Complex object from real and imaginary parts.\n\n    my $complex = Complex.new(1, 1);\n    say $complex;    # OUTPUT: «1+1i␤»\n\nWhen created without arguments, both parts are considered to be zero.\n\n    say Complex.new; # OUTPUT: «0+0i␤»","s":{"p":["*%_"],"r":"Mu"},"m":1,"k":"m"},{"d":"Defined as:\n\n    multi method new(Real $re, Real $im --> Complex:D)\n\nCreates a new Complex object from real and imaginary parts.\n\n    my $complex = Complex.new(1, 1);\n    say $complex;    # OUTPUT: «1+1i␤»\n\nWhen created without arguments, both parts are considered to be zero.\n\n    say Complex.new; # OUTPUT: «0+0i␤»","n":"new","k":"m","m":1,"s":{"p":["Real \\re","Real \\im","*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method reals(Complex:D: --> Positional:D)\n\nReturns a two-element list containing the real and imaginary parts for this\nvalue.\n\n    say (3+5i).reals;    # OUTPUT: «(3 5)␤»","n":"reals","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    method isNaN(Complex:D: --> Bool:D)\n\nReturns true if the real or imaginary part is NaN (not a number).\n\n    say (NaN+5i).isNaN; # OUTPUT: «True␤»\n    say (7+5i).isNaN;   # OUTPUT: «False␤»","n":"isNaN","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"coerce-to-real","s":{"p":["$exception-target","*%_"],"r":"Mu"},"k":"m","m":0},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"Num"},{"n":"Int","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"n":"Rat","s":{"p":["$epsilon?","*%_"],"r":"Mu"},"k":"m","m":0},{"s":{"r":"Mu","p":["$epsilon?","*%_"]},"m":0,"k":"m","n":"FatRat"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"Complex"},{"n":"conj","d":"Defined as:\n\n    method conj(Complex:D: --> Complex:D)\n\nReturns the complex conjugate of the invocant (that is, the number with the\nsign of the imaginary part negated).\n\n    say (1-4i).conj;                # OUTPUT: «1+4i␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"abs","d":"Defined as:\n\n    method abs(Complex:D: --> Num:D)\n    multi sub abs(Complex:D $z --> Num:D)\n\nReturns the absolute value of the invocant (or the argument in sub form).\nFor a given complex number $z the absolute value |$z| is defined as\nsqrt($z.re * $z.re + $z.im * $z.im).\n\n    say (3+4i).abs;                 # OUTPUT: «5␤»\n                                    # sqrt(3*3 + 4*4) == 5","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method polar(Complex:D: --> Positional:D)\n\nReturns a two-element list of the polar coordinates for this value, i.e.\nmagnitude and angle in radians.\n\n    say (10+7i).polar; # OUTPUT: «(12.2065556157337 0.610725964389209)␤»","n":"polar"},{"s":{"p":["*%_"],"r":"Mu"},"k":"m","m":0,"n":"cis"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"sqrt","d":"Defined as:\n\n    method sqrt(Complex:D: --> Complex:D)\n\nReturns the complex square root of the invocant, i.e. the root where the\nreal part is ≥ 0 and the imaginary part has the same sign as the imaginary\npart of the invocant.\n\n    say (3-4i).sqrt;                # OUTPUT: «2-1i␤»\n    say (-3+4i).sqrt;               # OUTPUT: «1+2i␤»"},{"n":"roots","m":0,"k":"m","s":{"p":["$n","*%_"],"r":"Mu"}},{"n":"sin","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"asin","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"cos","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"acos","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"tan","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"atan","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"sec"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"n":"asec"},{"n":"cosec","k":"m","m":0,"s":{"r":"Mu","p":["*%_"]}},{"n":"acosec","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"cotan"},{"n":"acotan","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"sinh","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m","n":"asinh"},{"n":"cosh","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"n":"acosh","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"n":"tanh","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"atanh"},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"sech"},{"n":"asech","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"k":"m","m":0,"s":{"r":"Mu","p":["*%_"]},"n":"cosech"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"acosech"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"n":"cotanh"},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"},"n":"acotanh"},{"n":"floor","d":"Defined as:\n\n    method floor(Complex:D: --> Complex:D)\n\nReturns self.re.floor + self.im.floor. That is, each of the real and\nimaginary parts is rounded to the highest integer not greater than the\nvalue of that part.\n\n    say (1.2-3.8i).floor;           # OUTPUT: «1-4i␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"d":"Defined as:\n\n    method ceiling(Complex:D: --> Complex:D)\n\nReturns self.re.ceiling + self.im.ceiling. That is, each of the real and\nimaginary parts is rounded to the lowest integer not less than the value of\nthat part.\n\n    say (1.2-3.8i).ceiling;         # OUTPUT: «2-3i␤»","n":"ceiling","k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"}},{"d":"Defined as:\n\n    multi method round(Complex:D: --> Complex:D)\n    multi method round(Complex:D: Real() $scale --> Complex:D)\n\nWith no arguments, rounds both the real and imaginary parts to the nearest\ninteger and returns a new Complex number. If $scale is given, rounds both\nparts of the invocant to the nearest multiple of $scale. Uses the same\nalgorithm as Real.round on each part of the number.\n\n    say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\n    say (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»","n":"round","k":"m","m":1,"s":{"p":["*%_"],"r":"Mu"}},{"m":1,"k":"m","s":{"p":["$scale","*%_"],"r":"Mu"},"d":"Defined as:\n\n    multi method round(Complex:D: --> Complex:D)\n    multi method round(Complex:D: Real() $scale --> Complex:D)\n\nWith no arguments, rounds both the real and imaginary parts to the nearest\ninteger and returns a new Complex number. If $scale is given, rounds both\nparts of the invocant to the nearest multiple of $scale. Uses the same\nalgorithm as Real.round on each part of the number.\n\n    say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\n    say (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»","n":"round"},{"m":0,"k":"m","s":{"r":"Mu","p":["*%_"]},"d":"Defined as:\n\n    method truncate(Complex:D: --> Complex:D)\n\nRemoves the fractional part of both the real and imaginary parts of the\nnumber, using Real.truncate, and returns the result as a new Complex.\n\n    say (1.2-3.8i).truncate;        # OUTPUT: «1-3i␤»","n":"truncate"},{"n":"narrow","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"re","d":"Defined as:\n\n    method re(Complex:D: --> Real:D)\n\nReturns the real part of the complex number.\n\n    say (3+5i).re;    # OUTPUT: «3␤»","s":{"r":"Mu","p":["*%_"]},"k":"m","m":0},{"n":"im","d":"Defined as:\n\n    method im(Complex:D: --> Real:D)\n\nReturns the imaginary part of the complex number.\n\n    say (3+5i).im;    # OUTPUT: «5␤»","s":{"p":["*%_"],"r":"Mu"},"m":0,"k":"m"},{"m":0,"k":"s","s":{"r":"Mu","p":["@auto","%init","*%_"]},"n":"BUILDALL"},{"n":"!SET-SELF","m":0,"k":"m","s":{"p":["\\re","\\im","*%_"],"r":"Mu"}}],"k":"c","mro":["Numeric","Cool"],"a":[{"n":"$.re","t":"num","k":"v"},{"k":"v","t":"num","n":"$.im"}],"t":"Complex","d":"TITLE\nclass Complex\n\nSUBTITLE\nComplex number\n\n    class Complex is Cool does Numeric {}\n\nRepresents a number in the complex plane.\n\nComplex objects are immutable.\n\nOperators\n\n  postfix i\n\nAdding a trailing i to a number literal makes it a Complex, for example:\n\n    say 2i;     # same as Complex.new(0, 2);\n    say 1-2e3i; # same as Complex.new(1, -2e3);\n\n","n":"Complex","b":"C"},{"k":"e","t":"Signal","n":"SIGCONT"},{"t":"Sub","n":"&index","k":"v"},{"n":"index","s":{"p":["Cool $s","Cool $needle"],"r":"Mu"},"k":"s","m":1},{"s":{"p":["Cool $s","Cool $needle","Cool $pos"],"r":"Mu"},"k":"s","m":1,"n":"index"},{"b":"A","n":"Macro","a":[{"n":"@!dispatchees","t":"List","k":"v"},{"k":"v","n":"$!dispatcher_cache","t":"Mu"},{"k":"v","n":"$!dispatcher","t":"Mu"},{"k":"v","t":"int","n":"$!rw"},{"k":"v","n":"$!inline_info","t":"Mu"},{"k":"v","n":"$!yada","t":"int"},{"n":"$!package","t":"Mu","k":"v"},{"n":"$!onlystar","t":"int","k":"v"},{"k":"v","n":"@!dispatch_order","t":"List"},{"k":"v","t":"Mu","n":"$!dispatch_cache"},{"k":"v","t":"Mu","n":"$!why"},{"n":"$!do","t":"Code","k":"v"},{"k":"v","n":"$!signature","t":"Signature"},{"k":"v","n":"@!compstuff","t":"List"}],"d":"TITLE\nclass Macro\n\nSUBTITLE\nCompile-time routine\n\n    class Macro is Routine { }\n\nA macro is a Routine whose invocation typically happens during parsing. By\nreturning an AST, a macro can inject code into the calling location.","t":"Macro","mro":["Callable","Routine"],"k":"c"},{"k":"e","n":"SIGSTKFLT","t":"Signal"},{"k":"v","t":"Sub","n":"&atomic-sub-fetch"},{"n":"atomic-sub-fetch","m":1,"k":"s","s":{"r":"atomicint","p":["atomicint $target is rw","int $add"]}},{"m":1,"k":"s","s":{"r":"atomicint","p":["atomicint $target is rw","Int:D $add"]},"n":"atomic-sub-fetch"},{"s":{"p":["atomicint $target is rw","$add"],"r":"atomicint"},"m":1,"k":"s","n":"atomic-sub-fetch"},{"k":"v","t":"Sub","n":"&link"},{"k":"s","m":1,"s":{"p":["$target","$name"],"r":"Mu"},"n":"link"},{"m":[{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"enums","d":"Defined as:\n\n    method enums()\n\nReturns a Map of enum values. Works both on the enum type and any key.\n\n    enum Mass ( mg => 1/1000, g => 1/1, kg => 1000/1 );\n    say Mass.enums; # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»\n    say g.enums;    # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»"},{"k":"m","m":0,"s":{"p":["*%_"],"r":"Mu"},"d":"Defined as:\n\n    method pair(::?CLASS:D:)\n\nReturns it as a Pair.\n\n    say g.pair; # OUTPUT: «g => 1␤»","n":"pair"},{"d":"Defined as:\n\n    method pred(::?CLASS:D:)\n\n    say Freija.pred;  # OUTPUT: «Oðin␤»","n":"pred","m":0,"k":"m","s":{"r":"Mu","p":["*%_"]}},{"s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m","n":"succ","d":"Defined as:\n\n    method succ(::?CLASS:D:)\n\n    say Oðin.succ;  # OUTPUT: «Freija␤»"}],"k":"ro","mro":[],"t":"Enumeration","a":[{"t":"Mu","n":"$.key","k":"v"},{"k":"v","n":"$.value","t":"Mu"},{"k":"v","t":"int","n":"$!index"}],"d":"TITLE\nrole Enumeration\n\nSUBTITLE\nWorking with the role behind the enum type\n\n    role Enumeration { }\n\nThis is the role implemented by the enum-pairs in the enum type. In\ngeneral, it is used to create constant sets, the elements of which become\nalso constant symbols in the current namespace and to establish a\nrelationship between the symbols belonging to the same set. In general, you\nwill find Enumeration in enum types:\n\n    enum norse-gods <Þor Oðin Loki>;\n    my $one-of-them = norse-gods.pick;\n    say $one-of-them ~~ Enumeration; # OUTPUT: «True␤»\n\nbut nothing prevents you from using it in your own programs if you want to\nrestrict somehow the relationship between the key and the value:\n\n    class DNA does Enumeration {\n        my %pairings = %( A => \"T\",\n                          T => \"A\",\n                          C => \"G\",\n                          G => \"C\" );\n\n        method new( $base-pair where \"A\" | \"C\" | \"G\" | \"T\" )  {\n            self.bless( key => $base-pair,\n                        value => %pairings{$base-pair});\n        }\n\n        multi method gist(::?CLASS:D:) {\n            return \"$!key → $!value\";\n        }\n\n    }\n\n    enum Chain ();\n    constant length = 16;\n    for <A C G T>.roll( length ) -> $letter {\n        my DNA $base = DNA.new( $letter );\n        Chain.HOW.add_enum_value( Chain, $base );\n    }\n\n    for ^length {\n        my $base = Chain.pick;\n        say \"{$base.key} and {$base.value}\";\n    }\n\n\nIn this code, DNA consumes the Enumeration role, which is from this point\nof view a pair of key and value; we can use the generated DNA objects to\ncompose an enum type from which elements can be picked one by one, with the\noutput shown below.\n\n    T and A\n    C and G\n    T and A\n    # and so on...\n\n\n","n":"Enumeration","b":"C"},{"n":"&so","t":"Sub","k":"v"},{"n":"so","s":{"r":"Mu","p":["Mu $x"]},"k":"s","m":1},{"k":"c","m":[{"n":"new","d":"method new()\n\nThe Supplier constructor.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"n":"BUILD","s":{"r":"Nil","p":[":taplist($!taplist)!","*%_"]},"m":0,"k":"s"},{"d":"method emit(Supplier:D: Mu \\value)\n\nSends the given value to all of the taps on all of the supplies created by\nSupply on this Supplier.","n":"emit","m":0,"k":"m","s":{"p":["Mu \\value","*%_"],"r":"Nil"}},{"m":0,"k":"m","s":{"p":["*%_"],"r":"Nil"},"d":"method done(Supplier:D:)\n\nCalls the done callback on all the taps that have one.\n\n    my $supplier = Supplier.new;\n    my $supply   = $supplier.Supply;\n    $supply.tap(-> $v { say $v }, done => { say \"no more answers\" });\n    $supplier.emit(42);\n    $supplier.done;\n\nWill output:\n\n    42\n    no more answers","n":"done"},{"s":{"p":["Exception $ex","*%_"],"r":"Mu"},"m":1,"k":"m","n":"quit","d":"multi method quit(Supplier:D: Exception $ex)\n    multi method quit(Supplier:D: Str() $message)\n\nCalls the quit callback on all the taps that have one, passing the\nexception to them. If called with a Str the exception will be an X::AdHoc\nwith the supplied message.\n\nThis is meant for shutting down a supply with an error."},{"d":"multi method quit(Supplier:D: Exception $ex)\n    multi method quit(Supplier:D: Str() $message)\n\nCalls the quit callback on all the taps that have one, passing the\nexception to them. If called with a Str the exception will be an X::AdHoc\nwith the supplied message.\n\nThis is meant for shutting down a supply with an error.","n":"quit","k":"m","m":1,"s":{"r":"Mu","p":["$message","*%_"]}},{"n":"Supply","d":"method Supply(Supplier:D: --> Supply)\n\nThis creates a new Supply object to which any values which are emitted on\nthis supplier are passed. This is the factory for all live supplies.","s":{"r":"Mu","p":["*%_"]},"m":0,"k":"m"},{"s":{"r":"Mu","p":["*%_"]},"k":"m","m":0,"n":"unsanitized-supply"},{"n":"BUILDALL","k":"s","m":0,"s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["Any"],"t":"Supplier","a":[{"k":"v","t":"Mu","n":"$!taplist"}],"d":"TITLE\nclass Supplier\n\nSUBTITLE\nLive Supply factory\n\n    class Supplier { }\n\nThis is a factory for live Supply objects, which provides the mechanism for\nemitting new values onto the supplies:\n\n    my $supplier = Supplier.new;\n    my $supply_1 = $supplier.Supply;\n    $supply_1.tap(-> $v { say \"One $v\" });\n    my $supply_2 = $supplier.Supply;\n    $supply_2.tap(-> $v { say \"Two $v\" });\n    $supplier.emit(42);\n\nWill output:\n\n    One 42\n    Two 42\n\n\non demand supplies are created by the factory methods of the Supply class\nor by the supply keyword. A mixture of a live and on-demand Supply can be\ncreated with a Supplier::Preserving.\n\n","n":"Supplier","b":"A"},{"k":"c","m":[{"d":"method new()\n\nThe Supplier constructor.","n":"new","m":0,"k":"m","s":{"p":["*%_"],"r":"Mu"}},{"n":"BUILDALL","m":0,"k":"s","s":{"p":["@auto","%init","*%_"],"r":"Mu"}}],"mro":["Supplier"],"a":[{"n":"$!taplist","t":"Mu","k":"v"}],"t":"Supplier::Preserving","d":"TITLE\nclass Supplier::Preserving\n\nSUBTITLE\nCached live Supply factory\n\n    class Supplier::Preserving is Supplier { }\n\nThis is a factory for live Supply-type objects, and it provides the\nmechanism for emitting new values onto the supplies, whereby values are\nkept when no consumer has tapped into the Supply. Any tapping will consume\nthe already stored and future values.\n\nStarting a preserving Supply and consuming its values after it is done:\n\n    my $p = Supplier::Preserving.new;\n    start for ^3 {\n        $p.emit($_);\n        LAST {\n            say „done after { now - BEGIN now}s“;\n            $p.done;\n        }\n    }\n    sleep 2;\n    react {\n        whenever $p.Supply { $_.say; }\n        whenever Promise.in(2) { done }\n    }\n    say „also done after { now - BEGIN now }s“\n\nWill output:\n\n    done after 0.0638467s\n    0\n    1\n    2\n    also done after 4.0534119s\n\n\n","n":"Supplier::Preserving","b":"A"},{"k":"e","n":"LittleEndian","t":"Endian"},{"k":"v","t":"Sub+{is-pure}","n":"&log10"},{"n":"log10","s":{"p":["Numeric $x"],"r":"Mu"},"k":"s","m":1},{"n":"log10","k":"s","m":1,"s":{"r":"Mu","p":["Cool $x"]}},{"k":"v","n":"&uninames","t":"Sub"},{"k":"s","m":1,"s":{"p":["Str:D $str"],"r":"Mu"},"n":"uninames"},{"t":"Sub","n":"&trait_mod:<will>","k":"v"},{"n":"trait_mod:<will>","s":{"r":"Mu","p":["Attribute:D $attr","|c is raw"]},"k":"s","m":1},{"m":1,"k":"s","s":{"p":["Attribute $attr","Mu :$build!"],"r":"Mu"},"n":"trait_mod:<will>"},{"m":1,"k":"s","s":{"p":["Variable:D $v","$block","|c is raw"],"r":"Mu"},"n":"trait_mod:<will>"},{"s":{"p":["Variable:D $v","$block",":$begin!"],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<will>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Variable:D $v","$block",":$check!"]},"n":"trait_mod:<will>"},{"n":"trait_mod:<will>","k":"s","m":1,"s":{"p":["Variable:D $v","$block",":$final!"],"r":"Mu"}},{"n":"trait_mod:<will>","m":1,"k":"s","s":{"r":"Mu","p":["Variable:D $v","$block",":$init!"]}},{"s":{"p":["Variable:D $v","$block",":$end!"],"r":"Mu"},"k":"s","m":1,"n":"trait_mod:<will>"},{"m":1,"k":"s","s":{"p":["Variable:D $v","$block",":$enter!"],"r":"Mu"},"n":"trait_mod:<will>"},{"n":"trait_mod:<will>","s":{"r":"Mu","p":["Variable:D $v","$block",":$leave!"]},"k":"s","m":1},{"k":"s","m":1,"s":{"p":["Variable:D $v","$block",":$keep!"],"r":"Mu"},"n":"trait_mod:<will>"},{"s":{"p":["Variable:D $v","$block",":$undo!"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<will>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Variable:D $v","$block",":$first!"]},"n":"trait_mod:<will>"},{"m":1,"k":"s","s":{"r":"Mu","p":["Variable:D $v","$block",":$next!"]},"n":"trait_mod:<will>"},{"n":"trait_mod:<will>","s":{"r":"Mu","p":["Variable:D $v","$block",":$last!"]},"m":1,"k":"s"},{"s":{"r":"Mu","p":["Variable:D $v","$block",":$pre!"]},"k":"s","m":1,"n":"trait_mod:<will>"},{"k":"s","m":1,"s":{"r":"Mu","p":["Variable:D $v","$block",":$post!"]},"n":"trait_mod:<will>"},{"s":{"p":["Variable:D $v","$block",":$compose!"],"r":"Mu"},"m":1,"k":"s","n":"trait_mod:<will>"},{"k":"v","t":"Sub+{Callable[Int:D]}","n":"&term:<time>"},{"k":"s","m":0,"s":{"r":"Int:D","p":[]},"n":"term:<time>"}]
