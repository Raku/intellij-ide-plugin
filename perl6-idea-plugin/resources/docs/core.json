{"types":{"Metamodel::ClassHOW":{"name":"Metamodel::ClassHOW","prefix":"<p><pre><code>class Metamodel::ClassHOW\n    does Metamodel::Naming\n    does Metamodel::Documenting\n    does Metamodel::Versioning\n    does Metamodel::Stashing\n    does Metamodel::AttributeContainer\n    does Metamodel::MethodContainer\n    does Metamodel::PrivateMethodContainer\n    does Metamodel::MultiMethodContainer\n    does Metamodel::RoleContainer\n    does Metamodel::MultipleInheritance\n    does Metamodel::DefaultParent\n    does Metamodel::C3MRO\n    does Metamodel::MROBasedMethodDispatch\n    does Metamodel::MROBasedTypeChecking\n    does Metamodel::Trusting\n    does Metamodel::BUILDPLAN\n    does Metamodel::Mixins\n    does Metamodel::ArrayType\n    does Metamodel::BoolificationProtocol\n    does Metamodel::REPRComposeProtocol\n    does Metamodel::InvocationProtocol\n    does Metamodel::Finalization\n        { }</code></pre></p><p>Metamodel::ClassHOW is the metaclass behind the class keyword.</p><p><pre><code>say so Int.HOW ~~ Metamodel::ClassHOW;    # OUTPUT: «True␤»\nsay Int.^methods(:all).pick.name;         # OUTPUT: «random Int method name␤»</code></pre></p><p>Warning: This class is part of the Rakudo implementation, not a part of the language itself.</p>","defs":{"compose":"<p><pre><code>method compose(Metamodel::ClassHOW:D: $obj)</code></pre></p><p>A call to compose brings the metaobject and thus the class it represents into a fully functional state, so if you construct or modify a class, you must call the compose method before working with the class.</p><p>It updates the method cache, checks that all methods that are required by roles are implemented, does the actual role composition work, and sets up the class to work well with language interoperability.</p>","lookup":"<p><pre><code>method lookup(Metamodel::ClassHOW:D: $obj, $method-name --> Method:D)</code></pre></p><p>Returns the first matching Method with the provided name. If no method was found, returns a VM-specific sentinel value (typically a low-level NULL value) that can be tested for with a test for definedness. It is potentially faster than .^can but does not provide a full list of all candidates.</p><p><pre><code>say Str.^lookup('Int').perl; # OUTPUT: «method Int (Str:D $: *%_) { #`(Method|39910024) ... }␤»\n\nfor <upper-case  uc> {\n    Str.^lookup: $^meth andthen .(\"foo\").say\n        orelse \"method `$meth` not found\".say\n}\n# OUTPUT:\n# method `upper-case` not found\n# FOO</code></pre></p>","add_fallback":"<p><pre><code>method add_fallback(Metamodel::ClassHOW:D: $obj, $condition, $calculator)</code></pre></p><p>Installs a method fallback, that is, add a way to call methods that weren't statically added.</p><p>Both $condition and $calculator must be callables that receive the invocant and the method name once a method is called that can't be found in the method cache.</p><p>If $condition returns a true value, $calculator is called with the same arguments, and must return the code object to be invoked as the method, and is added to the method cache.</p><p>If $condition returns a false value, the next fallback (if any) is tried, and if none matches, an exception of type X::Method::NotFound is thrown.</p><p>User-facing code (that is, code not dabbling with metaclasses) should use method FALLBACK instead.</p>","can":"<p><pre><code>method can(Metamodel::ClassHOW:D: $obj, $method-name)</code></pre></p><p>Given a method name, it returns a List of methods that are available with this name.</p><p><pre><code>class A      { method x($a) {} };\nclass B is A { method x()   {} };\nsay B.^can('x').elems;              # OUTPUT: «2␤»\nfor B.^can('x') {\n    say .arity;                     # OUTPUT: «1, 2␤»\n}</code></pre></p><p>In this example, class B has two possible methods available with name x (though a normal method call would only invoke the one installed in B directly). The one in B has arity 1 (i.e. it expects one argument, the invocant (self)), and the one in A expects 2 arguments (self and $a).</p>"}},"X::Declaration::Scope::Multi":{"defs":{},"prefix":"<p><pre><code>class X::Declaration::Scope::Multi is X::Declaration::Scope { }</code></pre></p><p>Thrown when a multi is declared with an incompatible scope.</p><p>For example our multi sub foo() { } dies with</p><p><pre><code>===SORRY!===\nCannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead\n</code></pre></p>","name":"X::Declaration::Scope::Multi"},"Metamodel::Documenting":{"name":"Metamodel::Documenting","prefix":"<p><pre><code>role Metamodel::Documenting { }</code></pre></p><p>Type declarations may include declarator blocks (#| and #=), which allow you to set the type's documentation. This can then be accessed through the WHY method on objects of that type:</p><p><pre><code>#|[Documented is an example class for Metamodel::Documenting's documentation.]\nclass Documented { }\n#=[Take a look at my WHY!]\n\nsay Documented.WHY;\n# OUTPUT:\n# Documented is an example class for Metamodel::Documenting's documentation.\n# Take a look at my WHY!\n</code></pre></p><p>Metamodel::Documenting is what implements this behavior for types. This example can be rewritten to use its methods explicitly like so:</p><p><pre><code>BEGIN {\n    our Mu constant Documented = Metamodel::ClassHOW.new_type: :name<Documented>;\n    Documented.HOW.compose: Documented;\n    Documented.HOW.set_why: do {\n        my Pod::Block::Declarator:D $pod .= new;\n        $pod._add_leading:  \"Documented is an example class for Metamodel::Documenting's documentation.\";\n        $pod._add_trailing: \"Take a look at my WHY!\";\n        $pod\n    };\n}\n\nsay Documented.HOW.WHY;\n# OUTPUT:\n# Documented is an example class for Metamodel::Documenting's documentation.\n# Take a look at my WHY!\n</code></pre></p><p>It typically isn't necessary to handle documentation for types directly through their HOW like this, as Metamodel::Documenting's methods are exposed through Mu via its WHY and set_why methods, which are usable on types in most cases.</p><p>Warning: This role is part of the Rakudo implementation, not a part of the language itself.</p>","defs":{"set_why":"<p><pre><code>method set_why($why)</code></pre></p><p>Sets the documentation for a type to $why.</p>"}},"X::IO::Chdir":{"prefix":"<p><pre><code>class X::IO::Chdir does X::IO is Exception { }\n</code></pre></p><p>Error class when a chdir call failed.</p><p>For example</p><p><pre><code>chdir '/home/other'\n</code></pre></p><p>throws</p><p><pre><code>Failed to change the working directory to '/home/other': permission denied\n</code></pre></p>","defs":{},"name":"X::IO::Chdir"},"X::IO::Symlink":{"defs":{"name":"<p>Returns the path that symlink failed to create.</p>"},"prefix":"<p><pre><code>class X::IO::Symlink does X::IO is Exception { }\n</code></pre></p><p>Error class for failed symlink creation.</p><p>A typical error message is</p><p><pre><code>Failed to create symlink called 'euler' on target '/home/myhome/euler-1.p6': Failed to symlink file: file already exist\n</code></pre></p>","name":"X::IO::Symlink"},"PseudoStash":{"defs":{},"prefix":"<p><pre><code>class PseudoStash is Map { }</code></pre></p><p>PseudoStash is the stash type (hanging off .WHO) that backs various pseudo-packages. So, when you do MY:: or CALLER::, that gives back a PseudoStash. In most cases, Package:: gives back a Stash. Neither of these are objects the user is expected to create by themselves, but in case you have one, you can just use it like a hash.</p><p><pre><code>my $a = 42;\nmy $b = q/$a/;\nsay MY::{$b};\n#OUTPUT: «42␤»\n</code></pre></p><p>This shows how you can use a PseudoStash to look up variables, by name, at runtime.</p>","name":"PseudoStash"},"Telemetry":{"name":"Telemetry","prefix":"<p><pre><code>class Telemetry { }</code></pre></p><p>Note:  This class is a Rakudo-specific feature and not standard Raku.</p><p>On creation, a Telemetry object contains a snapshot of various aspects of the current state of the virtual machine. This is in itself useful, but generally one needs two snapshots for the difference (which is a Telemetry::Period object).</p><p>The Telemetry object is really a collection of snapshots taken by different \"instruments\". By default, the Telemetry::Instrument::Usage and Telemetry::Instrument::ThreadPool instruments are activated.</p><p>The Telemetry (and Telemetry::Period) object also Associative. This means that you can treat a Telemetry object as a read-only Hash, with all of the data values of the instruments as keys.</p><p>You can determine which instruments Telemetry should use by setting the $*SAMPLER dynamic variable, which is a Telemetry::Sampler object.</p><p>Currently, the following instruments are supported by the Rakudo core:</p>* <p>Telemetry::Instrument::Usage</p><br><p>Provides (in alphabetical order): cpu, cpu-sys, cpu-user, cpus, id-rss, inb, invcsw, is-rss, ix-rss, majf, max-rss, minf, mrcv, msnd, nsig, nswp, volcsw, outb, util% and wallclock. For complete documentation of the meaning of these data values, see Telemetry::Instrument::Usage.</p>* <p>Telemetry::Instrument::Thread</p><br><p>Provides (in alphabetical order): tad, tcd, thid, tjd, tsd and tys. For complete documentation of the meaning of these data values, see Telemetry::Instrument::Thread.</p>* <p>Telemetry::Instrument::ThreadPool</p><br><p>Provides (in alphabetical order): atc, atq, aw, gtc, gtq, gw, s, ttc, ttq and tw. For complete documentation of the meaning of these data values, see Telemetry::Instrument::ThreadPool.</p>* <p>Telemetry::Instrument::AdHoc</p><br><p>Does not provide any data by itself: one must indicate which variables are to be monitored, which will then become available as methods with the same name on the instrument. For complete documentation, see Telemetry::Instrument::AdHoc.</p>","defs":{"snapper":"<p><pre><code>sub snapper($sleep = 0.1, :$stop, :$reset --> Nil)</code></pre></p><p>The snapper routine starts a separate thread that will call snap repeatedly until the end of program. It is exported by default.</p><p>By default, it will call snap every 0.1 second. The only positional parameter is taken to be the delay between snaps.</p><p>Please see the snapper module for externally starting a snapper without having to change the code. Simply adding -Msnapper as a command line parameter, will then start a snapper for you.</p>","report":"<p><pre><code>multi sub report(:@columns, :$legend, :$header-repeat, :$csv, :@format)</code></pre></p><p>The report subroutine generates a report about an array of Telemetry objects. It is exported by default. These can have been created by regularly calling snap, or by having a snapper running. If no positional parameter is used, it will assume the internal array to which the parameterless snap pushes.</p><p>Below are the additional named parameters of report.</p>* <p>:columns</p><br><p>Specify the names of the columns to be included in the report. Names can be specified with the column name (e.g. gw). If not specified, defaults to what is specified in the RAKUDO_REPORT_COLUMNS environment variable. If that is not set either, defaults to:</p><p><pre><code>wallclock util% max-rss gw gtc tw ttc aw atc\n</code></pre></p>* <p>:header-repeat</p><br><p>Specifies after how many lines the header should be repeated in the report. If not specified, defaults to what is specified in the RAKUDO_REPORT_HEADER_REPEAT environment variable. If that is not set either, defaults to 32.</p>* <p>:legend</p><br><p>Specifies whether a legend should be added to the report. If not specified, defaults to what is specified in the RAKUDO_REPORT_LEGEND environment variable. If that is not set either, defaults to True.</p><p>If there are snaps available in the internal array at the end of the program, then report will be automatically generated and printed on STDERR.</p>","snap":"<p><pre><code>multi sub snap(--> Nil)\nmulti sub snap(@s --> Nil)</code></pre></p><p>The snap subroutine is shorthand for creating a new Telemetry object and pushing it to an array for later processing. It is exported by default.</p><p><pre><code>use Telemetry;\nmy @t;\nfor ^5 {\n    snap(@t);\n    # do some stuff\n    LAST snap(@t);\n}\n</code></pre></p><p>If no array is specified, it will use an internal array for convenience.</p>","periods":"<p><pre><code>multi sub periods( --> Seq)\nmulti sub periods(@s --> Seq)</code></pre></p><p>The periods subroutine processes an array of Telemetry objects and generates a Seq of Telemetry::Period objects out of that. It is exported by default.</p><p><pre><code>.<cpu wallclock>.say for periods(@t);\n\n# OUTPUT:\n# ====================\n# (164 / 160)\n# (23 / 21)\n# (17 / 17)\n# (15 / 16)\n# (29 / 28)\n</code></pre></p><p>If no array is specified, it will use the internal array of snap without parameters and will reset that array upon completion (so that new snaps can be added again).</p><p><pre><code>use Telemetry;\nfor ^5 {\n    snap;\n    LAST snap;\n}\nsay .<cpu wallclock>.join(\" / \") for periods;\n\n# OUTPUT:\n# ====================\n# 172 / 168\n# 24 / 21\n# 17 / 18\n# 17 / 16\n# 27 / 27\n</code></pre></p><p>If only one snap was done, another snap will be done to create at least one Telemetry::Period object.</p>","T":"<p><pre><code>sub T()</code></pre></p><p>Shortcut for Telemetry.new. It is exported by default. Since the Telemetry class also provides an Associative interface, one can easily interpolate multiple values in a single statement:</p><p><pre><code>use Telemetry;\nsay \"Used {T<max-rss cpu>} (KiB CPU) so far\";\n</code></pre></p>"}},"Scalar":{"name":"Scalar","prefix":"<p><pre><code>class Scalar {}</code></pre></p><p>A Scalar is an internal indirection which is for most purposes invisible during ordinary use of Raku. It is the default container type associated with the $ sigil. A literal Scalar may be placed around a literal value by enclosing the value in $(…). This notation will appear in the output of a .perl method in certain places where it is important to note the presence of Scalars.</p><p>When a value is assigned to a $-sigiled variable, the variable will actually bind to a Scalar, which in turn will bind to the value. When a Scalar is assigned to a $-sigiled variable, the value bound to by that Scalar will be bound to the Scalar which that variable was bound to (a new one will be created if necessary.)</p><p>In addition, Scalars delegate all method calls to the value which they contain. As such, Scalars are for the most part invisible. There is, however, one important place where Scalars have a visible impact: a Scalar will shield its content from flattening by most Raku core list operations.</p><p>A $-sigiled variable may be bound directly to a value with no intermediate Scalar using the binding operator :=. You can tell if this has been done by examining the output of the introspective pseudo-method .VAR:</p><p><pre><code>my $a = 1;\n$a.^name.say;     # OUTPUT: «Int␤»\n$a.VAR.^name.say; # OUTPUT: «Scalar␤»\nmy $b := 1;\n$b.^name.say;     # OUTPUT: «Int␤»\n$b.VAR.^name.say; # OUTPUT: «Int␤»</code></pre></p><p>This same thing happens when values are assigned to an element of an Array, however, Lists directly contain their values:</p><p><pre><code>my @a = 1, 2, 3;\n@a[0].^name.say;            # OUTPUT: «Int␤»\n@a[0].VAR.^name.say;        # OUTPUT: «Scalar␤»\n[1, 2, 3][0].^name.say;     # OUTPUT: «Int␤»\n[1, 2, 3][0].VAR.^name.say; # OUTPUT: «Scalar␤»\n(1, 2, 3)[0].^name.say;     # OUTPUT: «Int␤»\n(1, 2, 3)[0].VAR.^name.say; # OUTPUT: «Int␤»</code></pre></p><p>Array elements may be bound directly to values using := as well; however, this is discouraged as it may lead to confusion. Doing so will break exact round-tripping of .perl output – since Arrays are assumed to place Scalars around each element, Scalars are not denoted with $ in the output of Array.perl.</p><p><pre><code>[1, $(2, 3)].perl.say;     # OUTPUT: «[1, (2, 3)]␤»\n(1, $(2, 3)).perl.say;     # OUTPUT: «(1, $(2, 3))␤»</code></pre></p><p>Binding a Scalar to a $-sigiled variable replaces the existing Scalar in that variable, if any, with the given Scalar. That means more than one variable may refer to the same Scalar. Because the Scalar may be mutated, this makes it possible to alter the value of both variables by altering only one of them:</p><p><pre><code>my $a = 1;\nmy $b := $a;\n$b = 2;\n$a.say;       # OUTPUT: «2␤»</code></pre></p><p> SSA-style constants bind directly to their value with no intervening Scalar, even when assignment (=) is used. They may be forced to use a Scalar by assigning a $-sigiled variable to them, at which point, they behave entirely like $-sigiled variables.</p><p><pre><code>my \\c = 1;\nc.^name.say;             # OUTPUT: «Int␤»\nc.VAR.^name.say;         # OUTPUT: «Int␤»\nmy $a = 1;\nmy \\d = $a;              # just \"my \\d = $ = 1\" works, too\nd.^name.say;             # OUTPUT: «Int␤»\nd.VAR.^name.say;         # OUTPUT: «Scalar␤»\nd = 2;                   # ok\nc = 2;                   # fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»</code></pre></p>","defs":{"dynamic":"<p><pre><code>method dynamic(Scalar:D: --> Bool)</code></pre></p><p>Returns whether the variable is visible in dynamic variable lookups.</p><p>Example:</p><p><pre><code>my $*FOO = 42;\nsay $*FOO.VAR.dynamic;          # OUTPUT: «True»</code></pre></p>","name":"<p><pre><code>method name(Scalar:D: --> Str)</code></pre></p><p>Returns the name associated with the container.</p><p>Example:</p><p><pre><code>my $x = 42;\nsay $x.VAR.name;                # OUTPUT: «$x»</code></pre></p>","default":"<p><pre><code>method default(Scalar:D: --> Str)</code></pre></p><p>Returns the default value associated with the container.</p><p>Example:</p><p><pre><code>my $x is default(666) = 42;\nsay $x.VAR.default;             # OUTPUT: «666»</code></pre></p>","&infix:<⚛=>":"<p><pre><code>multi sub infix:<⚛=>($target is rw, $value)</code></pre></p><p>Performs an atomic assignment of $value into the Scalar $target. The ⚛= operator ensures that any required barriers are performed such that the changed value will be \"published\" to other threads.</p>","of":"<p><pre><code>method of(Scalar:D: --> Mu)</code></pre></p><p>Returns the type constraint of the container.</p><p>Example:</p><p><pre><code>my Cool $x = 42;\nsay $x.VAR.of;                  # OUTPUT: «(Cool)»</code></pre></p>"}},"Associative":{"name":"Associative","prefix":"<p><pre><code>role Associative[::TValue = Mu, ::TKey = Str(Any)] { }</code></pre></p><p>A common role for types that support name-based lookup through postcircumfix:<{ }>, for example Hash and Map. It is used for type checks in operators that expect to find specific methods to call. See Subscripts for details.</p><p>The % sigil restricts variables to objects that do Associative, so you will have to mix in that role if you want to use it for your classes.</p><p><pre><code>class Whatever {};\nmy %whatever := Whatever.new;\n# OUTPUT: «Type check failed in binding; expected Associative but got Whatever\n</code></pre></p><p>Please note that we are using binding := here, since by default % assignments expect a Hash in the right-hand side. However, with the Associative role:</p><p><pre><code>class Whatever is Associative {};\nmy %whatever := Whatever.new;</code></pre></p><p>will be syntactically correct.</p>","defs":{"STORE":"<p><pre><code>method STORE(\\values, :$initialize)</code></pre></p><p>This method should only be supplied if you want to support the:</p><p><pre><code>my %h is Foo = a => 42, b => 666;\n</code></pre></p><p>syntax for binding your implementation of the Associative role.</p><p>Should accept the values to (re-)initialize the object with, which either could consist of Pairs, or separate key/value pairs. The optional named parameter will contain a True value when the method is called on the object for the first time. Should return the invocant.</p>","keyof":"<p>Defined as:</p><p><pre><code>method keyof()</code></pre></p><p>Returns the parameterized key used for the Associative role, which is Any coerced to Str by default. This is the class used as second parameter when you use the parameterized version of Associative.</p><p><pre><code>my %any-hash;\n%any-hash.keyof; #OUTPUT: «(Str(Any))␤»</code></pre></p>","of":"<p>Defined as:</p><p><pre><code>method of()</code></pre></p><p>Associative is actually a parameterized role which can use different classes for keys and values. As seen at the top of the document, by default it coerces to Str for the key and uses a very generic Mu for value.</p><p><pre><code>my %any-hash;\nsay %any-hash.of;#  OUTPUT: «(Mu)␤»</code></pre></p><p>The value is the first parameter you use when instantiating Associative with particular classes:</p><p><pre><code>class DateHash is Hash does Associative[Cool,DateTime] {};\nmy %date-hash := DateHash.new;\nsay %date-hash.of; # OUTPUT: «(Cool)␤»</code></pre></p>","AT-KEY":"<p><pre><code>method AT-KEY(\\key)</code></pre></p><p>Should return the value / container at the given key.</p>","EXISTS-KEY":"<p><pre><code>method EXISTS-KEY(\\key)</code></pre></p><p>Should return a Bool indicating whether the given key actually has a value.</p>"}},"X::Package::Stubbed":{"defs":{},"prefix":"<p><pre><code>class X::Package::Stubbed does X::Comp { }</code></pre></p><p>Thrown at CHECK time when there are packages stubbed but not later defined.</p><p>For example</p><p><pre><code>class A { ... }     # literal ...\nclass B { ... }     # literal ...\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThe following packages were stubbed but not defined:\n    A\n    B\n</code></pre></p>","name":"X::Package::Stubbed"},"X::Attribute::NoPackage":{"name":"X::Attribute::NoPackage","defs":{},"prefix":"<p><pre><code>class X::Attribute::NoPackage does X::Comp { }</code></pre></p><p>Compile time error thrown when an attribute is declared where it does not make sense (for example in the mainline).</p><p>For example</p><p><pre><code>has $.x;\n</code></pre></p><p>Dies with</p><p><pre><code>You cannot declare attribute '$.x' here; maybe you'd like a class or a role?\n</code></pre></p>"},"X::IO::Move":{"defs":{"from":"<p>Returns the source of the failed move operation</p>"},"prefix":"<p><pre><code>class X::IO::Move does X::IO is Exception { }\n</code></pre></p><p>Error class for a failed file move operation. A typical error message is</p><p><pre><code>Failed to move '/tmp/alpha.p6' to 'test.p6': :createonly specified and destination exists\n</code></pre></p>","name":"X::IO::Move"},"X::Scheduler::CueInNaNSeconds":{"name":"X::Scheduler::CueInNaNSeconds","defs":{},"prefix":"<p><pre><code>class X::Scheduler::CueInNaNSeconds is Exception { }</code></pre></p><p>When calling ThreadPoolScheduler.cue or CurrentThreadScheduler.cue with :at, :in, or :every as NaN, this exception gets thrown. For example, the following code:</p><p><pre><code>my Cancellation $c = $*SCHEDULER.cue({\n    say 'This will never output :(';\n}, at => NaN);\n</code></pre></p><p>Throws with:</p><p><pre><code>Cannot pass NaN as a number of seconds to Scheduler.cue\n</code></pre></p><p>This class only exists in releases 2019.05 and later.</p>"},"QuantHash":{"name":"QuantHash","prefix":"<p><pre><code>role QuantHash does Associative { }</code></pre></p><p>The QuantHash role provides the basic functionality shared by the Setty, Baggy and Mixy roles. These provide object hashes of which the values are limited in some way.</p><p>QuantHashes are what set operators use internally.</p>","defs":{"Baggy":"<p><pre><code>method Baggy(--> Baggy:D)</code></pre></p><p>Coerce the QuantHash object to the equivalent object that uses the Baggy role. Note that for Mixy type coercion items with negative values will be skipped.</p><p><pre><code>my %s is Set = <one two>;\nsay %s.Baggy; # OUTPUT: «Bag(one, two)␤»\nmy %m is Mix = one => 1, minus => -1;\nsay %m.Baggy; # OUTPUT: «Bag(one)␤»</code></pre></p>","Setty":"<p><pre><code>method Setty(--> Setty:D)</code></pre></p><p>Coerce the QuantHash object to the equivalent object that uses the Setty role. Note that for Mixy type coercion items with negative values will be skipped.</p><p><pre><code>my %b is Bag = one => 1, two => 2;\nsay %b.Setty; # OUTPUT: «set(one two)␤»\nmy %m is Mix = one => 1, minus => -1;\nsay %m.Setty; # OUTPUT: «set(one)␤»</code></pre></p>","Hash":"<p><pre><code>method Hash()</code></pre></p><p>Coerces the QuantHash object to a Hash (by stringifying the objects for the keys) without any limitations on the values, and returns that.</p>","keyof":"<p><pre><code>method keyof()</code></pre></p><p>Returns the type of value a key of this QuantHash may have. This is typically Mu.</p>","hash":"<p><pre><code>method hash()</code></pre></p><p>Coerces the QuantHash object to a Hash (by stringifying the objects for the keys) with the values of the hash limited to the same limitation as QuantHash, and returns that.</p>","of":"<p><pre><code>method of()</code></pre></p><p>Returns the type of value a value of this QuantHash may have. This is typically Bool for Setty, UInt for Baggy or Real for Mixy roles.</p>"}},"X::Proc::Unsuccessful":{"name":"X::Proc::Unsuccessful","prefix":"<p><pre><code>class X::Proc::Unsuccessful is Exception {}</code></pre></p>","defs":{}},"CompUnit::Repository::Installation":{"prefix":"<p><pre><code>class CompUnit::Repository::Installation\n    does CompUnit::Repository::Locally\n    does CompUnit::Repository::Installable\n    { }\n</code></pre></p><p>A CompUnit::Repository implementation backed by the filesystem, but uses an internal storage format to:</p>* <p>Handle case sensitivity issues on filesystems that may conflict as a CompUnit::Repository::FileSystem.</p><br>* <p>Handle allowable filename issues (e.g. unicode) on filesystems that don't support them.</p><br>* <p>Allow multiple distributions with the same name, but with different ver and/or auth and/or api values, to be installed and separately accessible in a single repository.</p><br>* <p>Enable faster module loading by providing module precompilation.</p><br><p>Because of the internal storage format the usual way to add a distribution is not by copying files but by calling CompUnit::Repository::Installation#method_install.</p>","defs":{"need":"<p><pre><code>method need(\n    CompUnit::DependencySpecification $spec,\n    CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n    CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n    --> CompUnit:D)\n</code></pre></p><p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","install":"<p><pre><code>method install(Distribution $distribution, Bool :$force)</code></pre></p><p>Copies modules into a special location so that they can be loaded afterwards.</p><p>:$force will allow installing over an existing distribution that has the same name, auth, api, and ver. Otherwise such a situation will result in Failure.</p><p><pre><code>my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\nmy $dist = Distribution::Path.new(...);\n$inst-repo.install($dist);</code></pre></p>","resolve":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","files":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming Zef is installed to the default location...\nmy $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\nsay $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»</code></pre></p>","uninstall":"<p><pre><code>method uninstall(Distribution $distribution)</code></pre></p><p>Removes the $distribution from the repository. $distribution should be obtained from the repository it is being removed from:</p><p><pre><code>my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\nmy $dist = $inst-repo.candidates(\"Acme::Unused\").head;\n$inst-repo.uninstall($dist);</code></pre></p>","candidates":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code>my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\nmy $inst-repo = CompUnit::Repository::Installation.new(prefix => $inst-repo-path);\nmy $dist = $inst-repo.candidates(\"Test\").head;\nsay \"Test version: \" ~ $dist.meta<ver>; # OUTPUT: «6.d␤»</code></pre></p>","load":"<p><pre><code>method load(IO::Path:D $file --> CompUnit:D)</code></pre></p><p>Load the $file and return a CompUnit object representing it.</p>","loaded":"<p><pre><code>method loaded(--> Iterable:D)</code></pre></p><p>Returns all CompUnits this repository has loaded.</p>"},"name":"CompUnit::Repository::Installation"},"Distribution::Hash":{"name":"Distribution::Hash","defs":{"new":"<p><pre><code>method new($hash, :$prefix)</code></pre></p><p>Creates a new Distribution::Hash instance from the metadata contained in $hash. All paths in the metadata will be prefixed with :$prefix.</p>","meta":"<p><pre><code>method meta()</code></pre></p><p>Returns a Hash with the representation of the metadata.</p>"},"prefix":"<p><pre><code>    class Distribution::Hash does Distribution::Locally { }\n</code></pre></p><p>A Distribution implementation backed by the filesystem. It does not require a META6.json file, essentially providing a lower level Distribution::Path.</p>"},"Nil":{"prefix":"<p><pre><code>class Nil is Cool { }</code></pre></p><p>The value Nil may be used to fill a spot where a value would normally go, and in so doing, explicitly indicate that no value is present. It may also be used as a cheaper and less explosive alternative to a Failure. (In fact, class Failure is derived from Nil, so smartmatching Nil will also match Failure.)</p><p>The class Nil is the same exact thing as its only possible value, Nil.</p><p><pre><code>say Nil === Nil.new;        # OUTPUT: «True␤»</code></pre></p><p>Along with Failure, Nil and its sub classes may always be returned from a routine even when the routine specifies a particular return type. It may also be returned regardless of the definedness of the return type, however, Nil is considered undefined for all other purposes.</p><p><pre><code>sub a( --> Int:D ) { return Nil }\na().say;                    # OUTPUT: «Nil␤»</code></pre></p><p>Nil is what is returned from empty routines or closure, or routines that use a bare return statement.</p><p><pre><code>sub a { }; a().say;         # OUTPUT: «Nil␤»\nsub b { return }; b().say;  # OUTPUT: «Nil␤»\nsay (if 1 { });             # OUTPUT: «Nil␤»\n{ ; }().say;                # OUTPUT: «Nil␤»\nsay EVAL \"\";                # OUTPUT: «Nil␤»</code></pre></p><p>In a list, Nil takes the space of one value. Iterating a Nil behaves like iteration of any non-iterable value, producing a sequence of one Nil. (When you need the other meaning, the special value Empty is available to take no spaces when inserted into list, and to return no values when iterated.)</p><p><pre><code>(1, Nil, 3).elems.say;      # OUTPUT: «3␤»\n(for Nil { $_ }).perl.say;  # OUTPUT: «(Nil,)␤»</code></pre></p><p>Any method call on Nil of a method that does not exist, and consequently, any subscripting operation, will succeed and return Nil.</p><p><pre><code>say Nil.ITotallyJustMadeThisUp;  # OUTPUT: «Nil␤»\nsay (Nil)[100];                  # OUTPUT: «Nil␤»\nsay (Nil){100};                  # OUTPUT: «Nil␤»</code></pre></p><p> When assigned to a container, the Nil value (but not any subclass of Nil) will attempt to revert the container to its default value; if no such default is declared, Raku assumes Any.</p><p>Since a hash assignment expects two elements, use Empty not Nil, e.g.</p><p><pre><code>my %h = 'a'..'b' Z=> 1..*;\n# stuff happens\n%h = Empty; # %h = Nil will generate an error</code></pre></p><p>However, if the container type is constrained with :D, assigning Nil to it will immediately throw an exception. (In contrast, an instantiated Failure matches :D because it's a definite value, but will fail to match the actual nominal type unless it happens to be a parent class of Failure.) Native types can not have default values nor hold a type object. Assigning Nil to a native type container will fail with a runtime error.</p><p><pre><code>my Int $x = 42;\n$x = Nil;\n$x.say;                     # OUTPUT: «(Int)␤»\n\nsub f( --> Int:D ){ Nil };  # this definedness constraint is ignored\nmy Int:D $i = f;            # this definedness constraint is not ignored, so throws\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)»\n\nsub g( --> Int:D ){ fail \"oops\" }; # this definedness constraint is ignored\nmy Any:D $h = g;                   # failure object matches Any:D, so is assigned</code></pre></p><p>but</p><p><pre><code>my Int:D $j = g;\n# It will throw both exceptions:\n# Earlier failure:\n#  oops\n#   in sub g at <unknown file> line 1\n#   in block <unit> at <unknown file> line 1\n#\n# Final error:\n#  Type check failed in assignment to $j; expected Int:D but got Failure (Failure.new(exception...)\n#   in block <unit> at <unknown file> line 1\n</code></pre></p><p>Because an untyped variable is type Any, assigning a Nil to one will result in an (Any) type object.</p><p><pre><code>my $x = Nil;\n$x.say;          # OUTPUT: «(Any)␤»\nmy Int $y = $x;  # will throw an exception\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)␤»</code></pre></p><p>If you are looking for a variable which transforms objects into type objects when said variable appears on the right-hand side, you can type the container as Nil.</p><p><pre><code>my Nil $x;\nmy Str $s = $x;\n$s.say;          # OUTPUT: «(Str)␤»</code></pre></p><p>There is an important exception to this transforms-into-type-object rule: assigning Nil to a variable which has a default will restore that default.</p><p><pre><code>my Int $x is default(42) = -1;\nmy $y = 1;\nfor $x, $y -> $val is rw { $val = Nil unless $val > 0 }\n$x.say;          # OUTPUT: «42␤»</code></pre></p>","defs":{"new":"<p><pre><code>method new(*@)</code></pre></p><p>Returns Nil</p>","Str":"<p><pre><code>method Str()</code></pre></p><p>Warns the user that they tried to stringify a Nil.</p>","gist":"<p><pre><code>method gist(--> Str:D)</code></pre></p><p>Returns \"Nil\".</p>","append":"<p><pre><code>method append(*@)</code></pre></p><p>Warns the user that they tried to append onto a Nil.</p>","prepend":"<p><pre><code>method prepend(*@)</code></pre></p><p>Warns the user that they tried to prepend onto a Nil.</p>","unshift":"<p><pre><code>method unshift(*@)</code></pre></p><p>Warns the user that they tried to unshift onto a Nil.</p>","FALLBACK":"<p><pre><code>method FALLBACK(| --> Nil) {}</code></pre></p><p>The fallback method takes any arguments and always returns a Nil.</p>","push":"<p><pre><code>method push(*@)</code></pre></p><p>Warns the user that they tried to push onto a Nil.</p>"},"name":"Nil"},"PositionalBindFailover":{"defs":{"cache":"<p><pre><code>method cache(PositionalBindFailover:D: --> List:D)</code></pre></p><p>Returns a List based on the iterator method, and caches it. Subsequent calls to cache always return the same List object.</p>","list":"<p><pre><code>method list(PositionalBindFailover:D: --> List:D)</code></pre></p><p>Returns a List based on the iterator method without caching it.</p>"},"prefix":"<p><pre><code>role PositionalBindFailover { ... }</code></pre></p><p>This role provides an interface by which an object can be coerced into a Positional when binding to Positional parameters.</p><p>For example, Seq type is not Positional, but you can still write the following, because it does PositionalBindFailover role:</p><p><pre><code>sub fifths(@a) {        # @a is constraint to Positional\n    @a[4];\n}\nmy $seq := gather {     # a Seq, which is not Positional\n    take $_ for 1..*;\n}\nsay fifths($seq);       # OUTPUT: «5␤»</code></pre></p><p>The invocation of fifths in the example above would ordinarily give a type error, because $seq is of type Seq, which doesn't do the Positional interface that the @-sigil implies.</p><p>But the signature binder recognizes that Seq does the PositionalBindFailover role, and calls its cache method to coerce it to a List, which does the Positional role.</p><p>The same happens with custom classes that do the role; they simply need to provide an iterator method that produces an Iterator:</p><p><pre><code>class Foo does PositionalBindFailover {\n    method iterator {\n        class :: does Iterator {\n            method pull-one {\n                return 42 unless $++;\n                IterationEnd\n            }\n        }.new\n    }\n}\n\nsub first-five (@a) { @a[^5].say }\nfirst-five Foo.new; # OUTPUT: # OUTPUT: «(42 Nil Nil Nil Nil)␤»</code></pre></p>","name":"PositionalBindFailover"},"Routine::WrapHandle":{"defs":{},"prefix":"<p>class WrapHandle { ... }</p><p>WrapHandle is a Rakudo private class created and returned by wrap. Its only use is to unwrap wrapped routines. Either call unwrap on a routine object or call the method restore on a Routine::WrapHandle object.</p><p><pre><code>sub f() { say 'f was called' }\nmy $wrap-handle = &f.wrap({ say 'before'; callsame; say 'after' });\nf;                    # OUTPUT: «before␤f was called␤after␤»\n$wrap-handle.restore;\nf;                    # OUTPUT: «f was called␤»</code></pre></p><p>As such private class, it may suffer any kind of changes without prior notice. It is only mentioned here since it is visible by the user who checks the return type of the Routine.wrap method.</p>","name":"Routine::WrapHandle"},"Metamodel::Primitives":{"name":"Metamodel::Primitives","prefix":"<p><pre><code>class Metamodel::Primitives {}</code></pre></p><p>Metamodel::Primitives provides low-level operations for working with types, which are otherwise only available as implementation-dependent directives. These primitives are available as class methods.</p><p>Here is an example that steals the metamodel instance from the Int class to create a custom type (usually you would create your own metaclass if you mess with something as low-level), which allows calling of just one method called why:</p><p><pre><code>my Mu $type := Metamodel::Primitives.create_type(Int.HOW, 'P6opaque');\n$type.^set_name('why oh why?');\nmy %methods =  why => sub ($) { say 42 };\nMetamodel::Primitives.install_method_cache($type, %methods, :authoritative);\n$type.why;      # 42\n$type.list;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Method::NotFound: Method 'list' not found for invocant of class 'why oh why?'␤»</code></pre></p>","defs":{"set_package":"<p><pre><code>method set_package(Mu $type, $package)</code></pre></p><p>Sets the package associated with the type.</p>","create_type":"<p><pre><code>method create_type(Mu $how, $repr = 'P6opaque')</code></pre></p><p>Creates and returns a new type from a metaobject $how and a representation name.</p>","install_method_cache":"<p><pre><code>method install_method_cache( Mu $type, %cache, :$authoritative = True)</code></pre></p><p>Installs a method cache, that is, a mapping from method names to code objects. If :authoritative is missing, or set to True, then calls of methods that do not exist in the cache will throw an exception of type X::Method::NotFound. If :authoritative is set to False, the usual fallback mechanism are tried.</p>","compose_type":"<p><pre><code>method compose_type(Mu $type, $configuration)</code></pre></p><p>Composes $type (that is, finalizes it to be ready for instantiation). See https://github.com/perl6/nqp/blob/master/docs/6model/repr-compose-protocol.markdown for what $configuration can contain (until we have better docs, sorry).</p>","rebless":"<p><pre><code>method rebless(Mu $object, Mu $type)</code></pre></p><p>Changes $obj to be of type $type. This only works if $type type-checks against the current type of $obj, and if the storage of $object is a subset of that of $type.</p>","configure_type_checking":"<p><pre><code>method configure_type_checking( Mu $type, @cache, :$authoritative = True,   :$call_accepts = False )</code></pre></p><p>Configures the type checking for $type. @cache is a list of known types against which $type checks positively (so in a classical class-based system, the type itself and all recursive superclasses). If :authoritative is missing or True, this type will fail checks against all types not in @cache. If :call_accepts is True, the method ACCEPTS will be called for type checks against this type.</p>","configure_destroy":"<p><pre><code>method configure_destroy(Mu $type, $destroy)</code></pre></p><p>Configures whether DESTROY methods are called (if present) when the garbage collector collects an object of this type (if $destroy is set to a true value). This comes with a performance overhead, so should only be set to a true value if necessary.</p>"}},"Metamodel::RolePunning":{"name":"Metamodel::RolePunning","defs":{},"prefix":"<p><pre><code>role Perl6::Metamodel::RolePunning {}</code></pre></p><p>Implements the ability to create objects from Roles without the intermediate need to use a class. Not intended to be used directly (will in fact error if it's used), but via punning of roles, as below. This is also Rakudo specific and not part of the spec.</p><p><pre><code>role A {\n    method b {\n      return \"punned\"\n    }\n};\nmy $a = A.new;\nsay $a.b; # OUTPUT: «punned␤»\n</code></pre></p>"},"X::IO::Rmdir":{"defs":{},"prefix":"<p><pre><code>my class X::IO::Rmdir does X::IO is Exception { }\n</code></pre></p><p>Error class for failed rmdir operations.</p><p>A typical error message is</p><p><pre><code>Failed to remove the directory 'lib': Directory not empty\n</code></pre></p>","name":"X::IO::Rmdir"},"Pod::Block::Named":{"prefix":"<p><pre><code>class Pod::Block::Named is Pod::Block { }</code></pre></p><p>Class for a named Pod block. For example</p><p><pre><code>=begin MySection\n...\n=end MySection\n</code></pre></p><p>creates a Pod::Block::Named with name MySection.</p>","defs":{},"name":"Pod::Block::Named"},"Seq":{"name":"Seq","prefix":"<p><pre><code>class Seq is Cool does Iterable does PositionalBindFailover { }</code></pre></p><p>A Seq represents anything that can lazily produce a sequence of values. A Seq is born in a state where iterating it will consume the values. However, calling .cache on a Seq will return a List that is still lazy, but stores the generated values for later access. However, assigning a Seq to an array consumes the Seq; alternatively, you can use the lazy statement prefix to avoid it from being iterated during the assignment:</p><p><pre><code># The Seq created by gather ... take is consumed on the spot here.\nmy @a = gather do { say 'consuming...'; take 'one' };  # OUTPUT: «consuming...␤»\n\n# The Seq here is only consumed as we iterate over @a later.\nmy @a = lazy gather do { say 'consuming...'; take 'one' };  # outputs nothing.\n.say for @a;  # OUTPUT: «consuming...␤one␤»\n</code></pre></p><p>A typical use case is method lines in IO::Handle, which could use a lot of memory if it stored all the lines read from the file. So</p><p><pre><code>for open('README.md').lines -> $line {\n    say $line;\n}\n</code></pre></p><p>won't keep all lines from the file in memory.</p><p>This implies that you cannot iterate the same Seq object twice (otherwise it couldn't throw away old values), so this dies:</p><p><pre><code>my @a = 1, 2, 3;\nmy @b = <a b c>;\nmy \\c = @a Z=> @b;\n.say for c;\n.say for c; # fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Seq::Consumed: This Seq has already been iterated, and its values consumed\n# (you might solve this by adding .cache on usages of the Seq, or\n# by assigning the Seq into an array)»</code></pre></p><p>A high-level construct to generate a Seq is gather/take, as well as many built-in methods like map and grep, low-level constructors to create a Seq from an iterator or from looping constructs are available too.</p><p>Caution: No program should ever assume a Seq may only be iterated once even if not cached by the program. Caching is a volatile state exposed to the developer as an optimization. The Seq may become cached by many operations, including calling perl on the Seq (if called prior to a non-cached iteration). From version 6.d, you .perl can be called on consumed <Seq>. If a program assumes a Seq can only iterate once, but then is later changed to call one of these operations during the loop, that assumption will fail.</p>","defs":{"new":"<p><pre><code>method new(Iterator:D $iter --> Seq:D)</code></pre></p><p>Creates a new Seq object from the iterator passed as the single argument.</p>","is-lazy":"<p><pre><code>method is-lazy(Seq:D: --> Bool:D)</code></pre></p><p>Returns True if the sequence is lazy and potentially infinite, and False otherwise. If called on an already consumed sequence, throws an error of type X::Seq::Consumed.</p>","eager":"<p><pre><code>method eager(Seq:D: --> List:D)</code></pre></p><p>Returns an eagerly evaluated List based on the invocant sequence, and marks it as consumed. If called on an already consumed sequence, throws an error of type X::Seq::Consumed.</p><p><pre><code>my $s = lazy 1..5;\n\nsay $s.is-lazy; # OUTPUT: «True␤»\nsay $s.eager;   # OUTPUT: «(1 2 3 4 5)␤»\n\nsay $s.eager;\nCATCH {\n    when X::Seq::Consumed {\n        say 'Throws exception if already consumed';\n    }\n}\n# OUTPUT: «Throws exception if already consumed␤»</code></pre></p>","iterator":"<p><pre><code>method iterator(Seq:D: --> Iterator:D)</code></pre></p><p>Returns the underlying iterator, and marks the invocant as consumed. If called on an already consumed sequence, throws an error of type X::Seq::Consumed.</p>","elems":"<p><pre><code>method elems(Seq:D:)</code></pre></p><p>If the caller Seq is not lazy, consumes and caches its values, returning their length. Otherwise, throws an error of type X::Cannot::Lazy.</p>","sink":"<p>Defined as:</p><p><pre><code>method sink(--> Nil)</code></pre></p><p>Calls sink-all if it is an Iterator, sink if the Sequence is a list.</p><p><pre><code>say (1 ... 1000).sink; # OUTPUT: «Nil␤»</code></pre></p><p>This is something you might want to do for the side effects of producing those values.</p>","from-loop":"<p><pre><code>multi method from-loop(&body --> Seq:D)\nmulti method from-loop(&body, &cond, :$repeat --> Seq:D)\nmulti method from-loop(&body, &cond, &afterward --> Seq:D)</code></pre></p><p>These methods create new Seq-based callbacks.</p><p>The first form produces an infinite Seq by calling &body each time a new element is requested, using the return value from &body as the item. This emulates (or implements) a loop { body } construct.</p><p>The second form calls &cond before each call to &body, and terminates the sequence if &cond returns a false value. If $repeat is set to a true value, the first call to &cond is omitted, and &body called right away. This emulates (or implements) while cond { body } and repeat { body } while cond loops.</p><p>The third form enables C-style looping by calling a third callback, &afterward, after each call to &body.</p>"}},"FatRat":{"prefix":"<p><pre><code>class FatRat is Cool does Rational[Int, Int] {}</code></pre></p><p>A FatRat is a rational number stored with arbitrary size numerator and denominator. Arithmetic operations involving a FatRat and optionally Int or Rat objects return a FatRat, avoiding loss of precision.</p><p>Since, unlike Rat, FatRat arithmetics do not fall back Num at some point, there is a risk that repeated arithmetic operations generate pathologically large numerators and denominators.</p><p>There are two common ways to generate FatRat objects: through the FatRat.new(Int, Int) constructor, which generates them from numerator and denominator, or by calling the .FatRat method on an Int or Rat object.</p>","defs":{},"name":"FatRat"},"Pod::Item":{"prefix":"<p><pre><code>class Pod::Item is Pod::Block { }</code></pre></p><p>Class for items in Pod enumeration lists.</p>","defs":{},"name":"Pod::Item"},"NumStr":{"prefix":"<p><pre><code>class NumStr is Num is Str { }</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = <42.1e0>; say $f.^name; # OUTPUT: «NumStr␤»</code></pre></p><p>As a subclass of both Num and Str, a NumStr will be accepted where either is expected. However, NumStr does not share object identity with Num- or Str-only variants:</p><p><pre><code>my $num-str = <42e10>;\nmy Num $num = $num-str; # OK!\nmy Str $str = $num-str; # OK!\nsay 42e10 ∈ <42e10  55  1>; # False; ∈ operator cares about object identity</code></pre></p>","defs":{"ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(NumStr:D: Any:D $value)</code></pre></p><p>If $value is Numeric (including another allomorph), checks if invocant's Numeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str part ACCEPTS the $value. If value is anything else, checks if both Numeric and Str parts ACCEPTS the $value.</p><p><pre><code>say <5e0> ~~ \"5.0\"; # OUTPUT: «False␤»\nsay <5e0> ~~  5.0 ; # OUTPUT: «True␤»\nsay <5e0> ~~ <5.0>; # OUTPUT: «True␤»</code></pre></p>","Str":"<p>Returns the string value of the NumStr.</p>","Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(NumStr:D: --> Num:D)\nmulti method Numeric(NumStr:U: --> Num:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0e0.</p>","new":"<p><pre><code>method new(Num $i, Str $s)</code></pre></p><p>The constructor requires both the Num and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = NumStr.new(42.1e0, \"forty two and a bit\");\nsay +$f; # OUTPUT: «42.1␤»\nsay ~$f; # OUTPUT: «\"forty two and a bit\"␤»</code></pre></p>","Num":"<p><pre><code>method Num</code></pre></p><p>Returns the Num value of the NumStr.</p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(NumStr:D: --> Num:D)\nmulti method Real(NumStr:U: --> Num:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0e0.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(NumStr:D: --> Bool:D)</code></pre></p><p>This method may be provided by the parent classes and not implemented in NumStr directly.</p><p>Returns False if the invocant is numerically ±0e0, otherwise returns True. String portion is not considered.</p>"},"name":"NumStr"},"X::TypeCheck::Return":{"prefix":"<p><pre><code>class X::TypeCheck::Return is X::TypeCheck { }</code></pre></p><p>Thrown when a return type check fails.</p><p>For example</p><p><pre><code>sub f(--> Int) { \"foo\" }\nf();\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Return: Type check failed for return value; expected Int but got Str (\"foo\")␤»</code></pre></p>","defs":{},"name":"X::TypeCheck::Return"},"Macro":{"name":"Macro","prefix":"<p><pre><code>class Macro is Routine { }</code></pre></p><p>A macro is a Routine whose invocation typically happens during parsing. By returning an AST, a macro can inject code into the calling location.</p>","defs":{}},"Parameter":{"name":"Parameter","defs":{"constraints":"<p>Returns additional constraints on the parameter (usually as an all-Junction).</p>","sub_signature":"<p>If the parameter has a sub-signature, returns a Signature object for it. Otherwise returns Any.</p>","twigil":"<p>Defined as:</p><p><pre><code>method twigil(Parameter:D: --> Str:D)</code></pre></p><p>Returns a string containing the twigil part of the parameter's name.</p>","slurpy":"<p>Defined as:</p><p><pre><code>method slurpy(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for slurpy parameters.</p>","type":"<p>Returns the nominal type constraint of the parameter.</p>","rw":"<p>Defined as:</p><p><pre><code>method rw(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for is rw parameters.</p><p><pre><code>my Signature $sig = :(Str $x is rw, Bool :$is-named);\nsay $sig.params[0].rw;                             # OUTPUT: «True␤»\nsay $sig.params[1].rw;                             # OUTPUT: «False␤»</code></pre></p>","optional":"<p>Defined as:</p><p><pre><code>method optional(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for optional parameters.</p>","capture":"<p>Defined as:</p><p><pre><code>method capture(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for parameters that capture the rest of the argument list into a single Capture object.</p><p><pre><code>sub how_many_extra_positionals($!, |capture) { capture.elems.say }\nhow_many_extra_positionals(0, 1, 2, 3);                        # RESULT: «3»\nsay &how_many_extra_positionals.signature.params[1].capture;   # OUTPUT: «True␤»</code></pre></p><p>Like raw parameters, Capture parameters do not force any context on the values bound to them, which is why their sigils are only used in declarations.</p>","coerce_type":"<p>Returns the coercion type of the parameter.</p>","positional":"<p>Defined as:</p><p><pre><code>method positional(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True if the parameter is positional.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named);\nsay $sig.params[0].positional;                     # OUTPUT: «True␤»\nsay $sig.params[1].positional;                     # OUTPUT: «False␤»</code></pre></p>","sigil":"<p>Defined as:</p><p><pre><code>method sigil(Parameter:D: --> Str:D)</code></pre></p><p>Returns a string containing the parameter's sigil, for a looser definition of \"sigil\" than what is considered part of the variable's name|method name. Still returns a sigil even if the parameter is anonymous.</p><p>This \"sigil\" is actually an introspection used to help determine the normal binding style of a parameter, if it has not been altered through a trait.</p><table class='sections'><tr><th>Sigil</th><th>Will bind to</th><th>Default behavior</th></tr>\n<tr><td>$</tr><td>Scalar</tr><td>Generate new Scalar, use instead of Scalar in argument, if any</tr></tr>\n<tr><td>@</tr><td>Positional</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>@</tr><td>PositionalBindFailover</tr><td>If binding failed, call argument's .cache method, bind to result</tr></tr>\n<tr><td>%</tr><td>Associative</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>&</tr><td>Callable</tr><td>Bind directly to the argument</tr></tr>\n<tr><td>\\</tr><td>(anything)</tr><td>Bind directly to the argument, keep existing Scalar, if any</tr></tr>\n</table><p>Also, | will bind to all remaining arguments and make new Capture if needed.</p>","copy":"<p>Defined as:</p><p><pre><code>method copy(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for is copy parameters.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named is copy);\nsay $sig.params[0].copy;                           # OUTPUT: «False␤»\nsay $sig.params[1].copy;                           # OUTPUT: «True␤»</code></pre></p>","type_captures":"<p>Defined as:</p><p><pre><code>method type_captures(Parameter:D: --> List:D)</code></pre></p><p>Returns a list of variable names of type captures associated with this parameter. Type captures define a type name within the attached code, which is an alias to the type gleaned from the argument during a call.</p><p><pre><code>sub a(::T ::U $x) { T.say }\na(8);                                       # OUTPUT: «(Int)␤»\nsay &a.signature.params[0].type_captures;   # OUTPUT: «(T U)␤»\nsub b($x) { $x.^name.say }\na(8);                                       # OUTPUT: «Int␤»</code></pre></p><p>The type used may change from call to call. Once they are defined, type captures can be used wherever you would use a type, even later in same the signature:</p><p><pre><code>sub c(::T $x, T $y, $z) { my T $zz = $z };\nc(4, 5, 6);          # OK\nc(4, 5, \"six\");      # Fails when assigning to $zz, wants Int not Str\nc(\"four\", 5, \"six\"); # Fails when binding $y, wants Str, not Int\n</code></pre></p><p>Type captures may be used at the same time as type constraints.</p><p><pre><code>sub d(::T Numeric $x, T $y) {};\nd(4, 5);            # OK\nd(4e0, 5e0);        # OK\nd(4e0, 5);          # Fails when binding $y\nd(\"four\", \"five\");  # Fails when binding $x\n</code></pre></p>","raw":"<p>Defined as:</p><p><pre><code>method raw(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for raw parameters.</p><p><pre><code>sub f($a, $b is raw, \\c) {\n    my $sig = &?ROUTINE.signature;\n    for ^$sig.params.elems {\n        say $sig.params[$_].raw;\n    }\n}\nf(17, \"4711\", 42); OUTPUT: «False␤True␤True␤»</code></pre></p><p>Raw parameters bind either a variable or a value passed to it, with no decontainerization taking place. That means that if a variable was passed to it, you can assign to the parameter. This is different from rw-parameter which can only bind to variables, never to values.</p><p>This is the normal behavior for parameters declared with a sigil of '\\', which is not really a sigil insofar as it is only used on the parameter.</p><p><pre><code>sub f(\\x) {\n    x = 5;\n}\nf(my $x);   # works\nf(42);      # dies\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»</code></pre></p><p>Other parameters may become raw through use of the 'is raw' trait. These still use their sigil in code.</p><p><pre><code>sub f($x is raw) {\n    $x = 5;\n}</code></pre></p>","readonly":"<p>Defined as:</p><p><pre><code>method readonly(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True for read-only parameters (the default).</p><p><pre><code>my Signature $sig = :(Str $x is rw, Bool :$is-named);\nsay $sig.params[0].readonly;                       # OUTPUT: «False␤»\nsay $sig.params[1].readonly;                       # OUTPUT: «True␤»</code></pre></p>","default":"<p>Returns a closure that upon invocation returns the default value for this parameter, or Any if no default was provided.</p>","invocant":"<p>Defined as:</p><p><pre><code>method invocant(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True if the parameter is the invocant parameter.</p>","named_names":"<p>Defined as:</p><p><pre><code>method named_names(Parameter:D: --> List:D)</code></pre></p><p>Returns the list of externally usable names/aliases for a named parameter.</p>","name":"<p>Returns the variable name, which includes all sigils and twigils. This name is used internally when applied to code, or in a declaration determines the name declared. This name is not necessarily usable by a caller – if it is, it will also appear as an alias. Often, the name will chosen descriptively as a form of self-documentation.</p><p>If the parameter is anonymous, Nil will be returned.</p>","named":"<p>Defined as:</p><p><pre><code>method named(Parameter:D: --> Bool:D)</code></pre></p><p>Returns True if it's a named parameter.</p><p><pre><code>my Signature $sig = :(Str $x, Bool :$is-named);\nsay $sig.params[0].named;                          # OUTPUT: «False␤»\nsay $sig.params[1].named;                          # OUTPUT: «True␤»</code></pre></p>"},"prefix":"<p><pre><code>class Parameter { }</code></pre></p><p>Represents a parameter, for purpose of introspection.</p><p>The usual way to obtain a Parameter object is to create a signature, and call .params on it to obtain a list of the Parameters.</p><p><pre><code>my $sig   = :(Str $x);\nmy $param = $sig.params[0];\nsay $param.type;              # OUTPUT: «Str()␤»</code></pre></p><p>See Signature for more information, and also for an explanation on what most of the concepts related to parameters mean.</p>"},"Metamodel::EnumHOW":{"name":"Metamodel::EnumHOW","defs":{"enum_values":"<p><pre><code>method enum_values($obj)</code></pre></p><p>Returns the values for the enum.</p><p><pre><code>enum Numbers <10 20>;\nsay Numbers.^enum_values;                   # OUTPUT: {10 => 0, 20 => 1}</code></pre></p>","set_export_callback":"<p><pre><code>method set_export_callback($obj, $callback)</code></pre></p><p>Sets the enum's export callback, which is invoked when calling .compose_values. This is called when applying the export trait to an enum. $callback should be a routine of some sort, taking no arguments, that handles exporting the enum's values.</p>","enum_from_value":"<p><pre><code>method enum_from_value($obj, $value)</code></pre></p><p>Given a value of the enum's base type, return the corresponding enum.</p><p><pre><code>enum Numbers <10 20>;\nsay Numbers.^enum_from_value(0);            # OUTPUT: 10</code></pre></p>","new_type":"<p><pre><code>method new_type(:$name!, :$base_type?, :$repr = 'P6opaque', :$is_mixin)</code></pre></p><p>Creates a new type object for an enum. $name is the enum name, $base_type is the type given when the enum is declared using a scoped declaration (if any), and $repr is the type representation passed to the enum using the repr trait. $is_mixin is unused.</p>","compose":"<p><pre><code>method compose($obj, :$compiler_services)</code></pre></p><p>Completes a type object for an enum. This is when any roles done by the enum are mixed in. This needs to be called before any enum values can be added using .add_enum_value.</p>","add_parent":"<p><pre><code>method add_parent($obj, $parent)</code></pre></p><p>Sets the base type of an enum. This can only be used if no base type was passed to .new_type.</p>","add_enum_value":"<p><pre><code>method add_enum_value($obj, $value)</code></pre></p><p>Adds a value to this enum. $value should be an instance of the enum itself, as type Enumeration.</p>","export_callback":"<p><pre><code>method export_callback($obj)</code></pre></p><p>Returns the export callback set by .set_export_callback.</p>","elems":"<p><pre><code>method elems($obj)</code></pre></p><p>Returns the number of values.</p><p><pre><code>enum Numbers <10 20>;\nsay Numbers.^elems;                         # OUTPUT: 2</code></pre></p>","compose_values":"<p><pre><code>method compose_values($obj)</code></pre></p><p>Calls the export callback set by .set_export_callback and removes it from state. This should be called after adding the enum's values using .add_enum_value.</p>","set_composalizer":"<p><pre><code>method set_composalizer($c)</code></pre></p><p>Sets the composalizer for an enum, which produces a type that can be mixed in with another. $c should be a routine of some that has the following signature:</p><p><pre><code>:($type, $name, @enum_values)</code></pre></p>","is_composed":"<p><pre><code>method is_composed($obj)</code></pre></p><p>Returns 1 if the enum is composed, otherwise returns 0.</p>","composalizer":"<p><pre><code>method composalizer($obj)</code></pre></p><p>Returns the composalizer set by .set_composalizer.</p>"},"prefix":"<p><pre><code>class Metamodel::EnumHOW\n    does Metamodel::Naming\n    does Metamodel::Documenting\n    does Metamodel::Stashing\n    does Metamodel::AttributeContainer\n    does Metamodel::MethodContainer\n    does Metamodel::MultiMethodContainer\n    does Metamodel::RoleContainer\n    does Metamodel::BaseType\n    does Metamodel::MROBasedMethodDispatch\n    does Metamodel::MROBasedTypeChecking\n    does Metamodel::BUILDPLAN\n    does Metamodel::BoolificationProtocol\n    does Metamodel::REPRComposeProtocol\n    does Metamodel::InvocationProtocol\n    does Metamodel::Mixins\n        { }</code></pre></p><p>Metamodel::EnumHOW is the metaclass behind the enum keyword.</p><p><pre><code>enum Numbers <1 2>;\nsay Numbers.HOW ~~ Metamodel::EnumHOW; # OUTPUT: «True␤»</code></pre></p><p>The following enum declaration:</p><p><pre><code>our Int enum Error <Warning Failure Exception Sorrow Panic>;</code></pre></p><p>Is roughly equivalent to this code using Metamodel::EnumHOW's methods:</p><p><pre><code>BEGIN {\n    my constant Error = Metamodel::EnumHOW.new_type: :name<Error>, :base_type(Int);\n    Error.^add_role: Enumeration;\n    Error.^add_role: NumericEnumeration;\n    Error.^compose;\n    for <Warning Failure Exception Sorrow Panic>.kv -> Int $v, Str $k {\n        # Note: Enumeration.pred and .succ will not work when adding enum\n        # values as pairs. They should be instances of the enum itself, but\n        # this isn't possible to do without nqp.\n        Error.^add_enum_value: $k => $v;\n        OUR::{$k} := Error.^enum_from_value: $v;\n    }\n    Error.^compose_values;\n    OUR::<Error> := Error;\n}</code></pre></p><p>Warning: This class is part of the Rakudo implementation, and is not a part of the language specification.</p>"},"X::Signature::Placeholder":{"prefix":"<p><pre><code>class X::Signature::Placeholder does X::Comp { }\n</code></pre></p><p>Compile time error thrown when a block has both an explicit signature and placeholder parameters.</p><p>For example</p><p><pre><code>sub f() { $^x }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPlaceholder variable '$^x' cannot override existing signature\n</code></pre></p>","defs":{},"name":"X::Signature::Placeholder"},"Submethod":{"name":"Submethod","prefix":"<p><pre><code>class Submethod is Routine {}</code></pre></p><p>A Submethod is a method that is not inherited by child classes. They are typically used for per-class initialization and tear-down tasks which are called explicitly per class in an inheritance tree, usually for enforcing a particular order. For example object construction with the BUILD submethod happens from the least-derived to most-derived, so that the most-derived (child) classes can depend on the parent already being initialized.</p><p>Submethods are of type Submethod, and are declared with the submethod declarator:</p><p><pre><code>class Area {\n    has $.size;\n    submethod BUILD(:$x, :$y, :$z) {\n        $!size = $x * $y * $z;\n    }\n}</code></pre></p>","defs":{}},"Proc::Async":{"name":"Proc::Async","prefix":"<p><pre><code>class Proc::Async {}\n</code></pre></p><p>Proc::Async allows you to run external commands asynchronously, capturing standard output and error handles, and optionally write to its standard input.</p><p><pre><code>my $file = ‘foo’.IO;\nspurt $file, “and\\nCamelia\\n♡\\nme\\n”;\n\nmy $proc = Proc::Async.new: :w, ‘tac’, ‘--’, $file, ‘-’;\n# my $proc = Proc::Async.new: :w, ‘sleep’, 15; # uncomment to try timeouts\n\nreact {\n    whenever $proc.stdout.lines { # split input on \\r\\n, \\n, and \\r\n        say ‘line: ’, $_\n    }\n    whenever $proc.stderr { # chunks\n        say ‘stderr: ’, $_\n    }\n    whenever $proc.ready {\n        say ‘PID: ’, $_ # Only in Rakudo 2018.04 and newer, otherwise Nil\n    }\n    whenever $proc.start {\n        say ‘Proc finished: exitcode=’, .exitcode, ‘ signal=’, .signal;\n        done # gracefully jump from the react block\n    }\n    whenever $proc.print: “I\\n♥\\nCamelia\\n” {\n        $proc.close-stdin\n    }\n    whenever signal(SIGTERM).merge: signal(SIGINT) {\n        once {\n            say ‘Signal received, asking the process to stop’;\n            $proc.kill; # sends SIGHUP, change appropriately\n            whenever signal($_).zip: Promise.in(2).Supply {\n                say ‘Kill it!’;\n                $proc.kill: SIGKILL\n            }\n        }\n    }\n    whenever Promise.in(5) {\n        say ‘Timeout. Asking the process to stop’;\n        $proc.kill; # sends SIGHUP, change appropriately\n        whenever Promise.in(2) {\n            say ‘Timeout. Forcing the process to stop’;\n            $proc.kill: SIGKILL\n        }\n    }\n}\n\nsay ‘Program finished’;\n</code></pre></p><p>Example above produces the following output:</p><p><pre><code>line: me\nline: ♡\nline: Camelia\nline: and\nline: Camelia\nline: ♥\nline: I\nProc finished. Exit code: 0\nProgram finished\n</code></pre></p><p>Alternatively, you can use Proc::Async without using a react block:</p><p><pre><code># command with arguments\nmy $proc = Proc::Async.new('echo', 'foo', 'bar');\n\n# subscribe to new output from out and err handles:\n$proc.stdout.tap(-> $v { print \"Output: $v\" }, quit => { say 'caught exception ' ~ .^name });\n$proc.stderr.tap(-> $v { print \"Error:  $v\" });\n\nsay \"Starting...\";\nmy $promise = $proc.start;\n\n# wait for the external program to terminate\nawait $promise;\nsay \"Done.\";</code></pre></p><p>This produces the following output:</p><p><pre><code>Starting...\nOutput: foo bar\nDone.\n</code></pre></p><p>An example that opens an external program for writing:</p><p><pre><code>my $prog = Proc::Async.new(:w, 'hexdump', '-C');\nmy $promise = $prog.start;\nawait $prog.write(Buf.new(12, 42));\n$prog.close-stdin;\nawait $promise;</code></pre></p><p>An example of piping several commands like echo \"Hello, world\" | cat -n:</p><p><pre><code>my $proc-echo = Proc::Async.new: 'echo', 'Hello, world';\nmy $proc-cat = Proc::Async.new: 'cat', '-n';\n$proc-cat.bind-stdin: $proc-echo.stdout;\nawait $proc-echo.start, $proc-cat.start;</code></pre></p>","defs":{"new":"<p><pre><code>multi method new(*@ ($path, *@args), :$w, :$enc, :$translate-nl --> Proc::Async:D)\nmulti method new(   :$path, :@args,  :$w, :$enc, :$translate-nl --> Proc::Async:D)</code></pre></p><p>Creates a new Proc::Async object with external program name or path $path and the command line arguments @args.</p><p>If :w is passed to new, then a pipe to the external program's standard input stream (stdin) is opened, to which you can write with write and say.</p><p>The :enc specifies the encoding for streams (can still be overridden in individual methods) and defaults to utf8.</p><p>If :translate-nl is set to True (default value), OS-specific newline terminators (e.g. \\r\\n on Windows) will be automatically translated to \\n.</p>","args":"<p><pre><code>method args(Proc::Async:D: --> Positional:D)</code></pre></p><p>Deprecated as of v6.d. Use command instead.</p><p>Returns the command line arguments for the external programs, as passed to the new method.</p>","w":"<p><pre><code>method w(Proc::Async:D:)</code></pre></p><p>Returns a true value if :w was passed to the constructor, that is, if the external program is started with its input stream made available to output to the program through the .print, .say and .write methods.</p>","write":"<p><pre><code>method write(Proc::Async:D: Blob:D $b, :$scheduler = $*SCHEDULER --> Promise:D)</code></pre></p><p>Write the binary data in $b to the standard input stream of the external program.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method write, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","started":"<p><pre><code>method started(Proc::Async:D: --> Bool:D)</code></pre></p><p>Returns False before .start has been called, and True afterwards.</p>","stderr":"<p><pre><code>method stderr(Proc::Async:D: :$bin --> Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard error stream. If :bin is passed, the standard error is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stderr.tap( -> $str {\n    say \"Got error '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stderr before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stderr is not called, the external program's standard error stream is not captured at all.</p><p>Note that you cannot call stderr both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","bind-stdin":"<p><pre><code>multi method bind-stdin(IO::Handle:D $handle)\nmulti method bind-stdin(Proc::Async::Pipe:D $pipe)</code></pre></p><p>Sets a handle (which must be opened) or a Pipe as a source of STDIN. The STDIN of the target process must be writable or X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"cat\", :in);\nmy $h = \"/etc/profile\".IO.open;\n$p.bind-stdin($h);\n$p.start;</code></pre></p><p>This is equivalent to</p><p><pre><code>cat < /etc/profile\n</code></pre></p><p>and will print the content of /etc/profile to standard output.</p>","bind-stderr":"<p><pre><code>method bind-stderr(IO::Handle:D $handle)</code></pre></p><p>Redirects STDERR of the target process to a handle (which must be opened). If STDERR is closed X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"ls\", \"--foo\", :err);\nmy $h = \"ls.err\".IO.open(:w);\n$p.bind-stderr($h);\n$p.start;</code></pre></p>","print":"<p><pre><code>method print(Proc::Async:D: Str(Any) $str, :$scheduler = $*SCHEDULER)</code></pre></p><p>Write the text data in $str to the standard input stream of the external program, encoding it as UTF-8.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method print, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","path":"<p><pre><code>method path(Proc::Async:D:)</code></pre></p><p>Deprecated as of v6.d. Use command instead.</p><p>Returns the name and/or path of the external program that was passed to the new method as first argument.</p>","Supply":"<p><pre><code>multi method Supply(Proc::Async:D: :$bin!)\nmulti method Supply(Proc::Async:D: :$enc, :$translate-nl)</code></pre></p><p>Returns a Supply of merged stdout and stderr streams. If :$bin named argument is provided, the Supply will be binary, producing Buf objects, otherwise, it will be in character mode, producing Str objects and :$enc named argument can specify encoding to use. The :$translate-nl option specifies whether new line endings should be translated for to match those used by the current operating system (e.g. \\r\\n on Windows).</p><p><pre><code>react {\n    with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n        whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n        whenever .start {}\n    }\n}\n</code></pre></p><p>It is an error to create both binary and non-binary .Supply. It is also an error to use both .Supply and either stderr or stdout supplies.</p>","say":"<p><pre><code>method say(Proc::Async:D: $output, :$scheduler = $*SCHEDULER)</code></pre></p><p>Calls method gist on the $output, adds a newline, encodes it as UTF-8, and sends it to the standard input stream of the external program, encoding it as UTF-8.</p><p>Returns a Promise that will be kept once the data has fully landed in the input buffer of the external program.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method say, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","stdout":"<p><pre><code>method stdout(Proc::Async:D: :$bin --> Supply:D)</code></pre></p><p>Returns the Supply for the external program's standard output stream. If :bin is passed, the standard output is passed along in binary as Blob, otherwise it is interpreted as UTF-8, decoded, and passed along as Str.</p><p><pre><code>my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n$proc.stdout.tap( -> $str {\n    say \"Got output '$str' from the external program\";\n});\nmy $promise = $proc.start;\nawait $promise;</code></pre></p><p>You must call stdout before you call #method start. Otherwise an exception of class X::Proc::Async::TapBeforeSpawn is thrown.</p><p>If stdout is not called, the external program's standard output is not captured at all.</p><p>Note that you cannot call stdout both with and without :bin on the same object; it will throw an exception of type X::Proc::Async::CharsOrBytes if you try.</p><p>Use .Supply for merged STDOUT and STDERR.</p>","bind-stdout":"<p><pre><code>method bind-stdout(IO::Handle:D $handle)</code></pre></p><p>Redirects STDOUT of the target process to a handle (which must be opened). If STDOUT is closed X::Proc::Async::BindOrUse will be thrown.</p><p><pre><code>my $p = Proc::Async.new(\"ls\", :out);\nmy $h = \"ls.out\".IO.open(:w);\n$p.bind-stdout($h);\n$p.start;</code></pre></p><p>This program will pipe the output of the ls shell command to a file called ls.out, which we are opened for reading.</p>","start":"<p><pre><code>method start(Proc::Async:D: :$scheduler = $*SCHEDULER, :$ENV, :$cwd = $*CWD)</code></pre></p><p>Initiates spawning of the external program. Returns a Promise that will be kept with a Proc object once the external program exits or broken if the program cannot be started. Optionally, you can use a scheduler instead of the default $*SCHEDULER, or change the environment the process is going to run in via the named argument :$ENV or the directory via the named argument :$cwd.</p><p>If start is called on a Proc::Async object on which it has already been called before, an exception of type X::Proc::Async::AlreadyStarted is thrown.</p><p>Note: If you wish to await the Promise and discard its result, using</p><p><pre><code>try await $p.start;\n</code></pre></p><p>will throw if the program exited with non-zero status, as the Proc returned as the result of the Promise throws when sunk and in this case it will get sunk outside the try. To avoid that, sink it yourself inside the try:</p><p><pre><code>try sink await $p.start;\n</code></pre></p>","pid":"<p><pre><code>method pid(Proc::Async:D: --> Promise:D)</code></pre></p><p>Equivalent to ready.</p><p>Returns a Promise that will be kept once the process has successfully started. Promise will be broken if the program fails to start. Returned promise will hold the process id (PID).</p><p>Implementation-specific note: Available starting from Rakudo 2018.04.</p>","close-stdin":"<p><pre><code>method close-stdin(Proc::Async:D: --> True)</code></pre></p><p>Closes the standard input stream of the external program. Programs that read from STDIN often only terminate when their input stream is closed. So if waiting for the promise from #method start hangs (for a program opened for writing), it might be a forgotten close-stdin.</p><p>The Proc::Async object must be created for writing (with Proc::Async.new(:w, $path, @args)). Otherwise an X::Proc::Async::OpenForWriting exception will the thrown.</p><p>start must have been called before calling method close-stdin, otherwise an X::Proc::Async::MustBeStarted exception is thrown.</p>","command":"<p><pre><code>method command(Proc::Async:D: --> List:D)</code></pre></p><p>Available as of v6.d.</p><p>Returns the command and arguments used for this Proc::Async object:</p><p><pre><code>my $p := Proc::Async.new: 'cat', 'some', 'files';\n$p.command.say; # OUTPUT: «(cat some files)␤»</code></pre></p>","ready":"<p><pre><code>method ready(Proc::Async:D: --> Promise:D)</code></pre></p><p>Returns a Promise that will be kept once the process has successfully started. Promise will be broken if the program fails to start.</p><p>Implementation-specific note: Starting from Rakudo 2018.04, the returned promise will hold the process id (PID).</p>"}},"CX::Redo":{"defs":{},"prefix":"<p><pre><code>role CX::Redo does X::Control { }</code></pre></p><p>A control exception thrown when redo is called.</p>","name":"CX::Redo"},"Dateish":{"defs":{"day":"<p>Defined as:</p><p><pre><code>method day(Date:D: --> Int:D)</code></pre></p><p>Returns the day of the month of the date (1..31).</p><p><pre><code>say Date.new('2015-12-31').day;                                  # OUTPUT: «31␤»\nsay DateTime.new(date => Date.new('2015-12-24'), hour => 1).day; # OUTPUT: «24␤»</code></pre></p>","day-of-year":"<p>Defined as:</p><p><pre><code>method day-of-year(Date:D: --> Int:D)</code></pre></p><p>Returns the day of the year (1..366).</p><p><pre><code>say Date.new('2015-12-31').day-of-year;                                  # OUTPUT: «365␤»\nsay DateTime.new(date => Date.new('2015-03-24'), hour => 1).day-of-year; # OUTPUT: «83␤»</code></pre></p>","daycount":"<p>Defined as:</p><p><pre><code>method daycount(Dateish:D: --> Int:D)</code></pre></p><p>Returns the number of days from the epoch Nov. 17, 1858 to the day of the invocant. The daycount returned by this method is the MJD, i.e. the Modified Julian Day, which is used routinely by e.g. astronomers, geodesists, scientists and others. The MJD convention is designed to facilitate simplified chronological calculations.</p><p><pre><code>say Date.new('1995-09-27').daycount;    # OUTPUT: «49987␤»</code></pre></p>","days-in-month":"<p>Defined as:</p><p><pre><code>method days-in-month(Dateish:D: --> Int:D)</code></pre></p><p>Returns the number of days in the month represented by the Dateish object:</p><p><pre><code>say Date.new(\"2016-01-02\").days-in-month;                # OUTPUT: «31␤»\nsay DateTime.new(:year<10000>, :month<2>).days-in-month; # OUTPUT: «29␤»</code></pre></p>","weekday-of-month":"<p>Defined as:</p><p><pre><code>method weekday-of-month(Date:D: --> Int:D)</code></pre></p><p>Returns a number (1..5) indicating the number of times a particular day-of-week has occurred so far during that month, the day itself included.</p><p><pre><code>say Date.new(\"2003-06-09\").weekday-of-month;  # 2  (second Monday of the month)</code></pre></p>","year":"<p>Defined as:</p><p><pre><code>method year(Date:D: --> Int:D)</code></pre></p><p>Returns the year of the date.</p><p><pre><code>say Date.new('2015-12-31').year;                                  # OUTPUT: «2015␤»\nsay DateTime.new(date => Date.new('2015-12-24'), hour => 1).year; # OUTPUT: «2015␤»</code></pre></p>","yyyy-mm-dd":"<p>Defined as:</p><p><pre><code>method yyyy-mm-dd(Date:D: --> Str:D)\n</code></pre></p><p>Returns the date in YYYY-MM-DD format (ISO 8601)</p><p><pre><code>say Date.new(\"2015-11-15\").yyyy-mm-dd;   # OUTPUT: «2015-11-15␤»\nsay DateTime.new(1470853583).yyyy-mm-dd; # OUTPUT: «2016-08-10␤»\n</code></pre></p>","week-number":"<p>Defined as:</p><p><pre><code>method week-number(Date:D: --> Int:D)</code></pre></p><p>Returns the week number (1..53) of the date specified by the invocant. The first week of the year is defined by ISO as the one which contains the fourth day of January. Thus, dates early in January often end up in the last week of the prior year, and similarly, the final few days of December may be placed in the first week of the next year.</p><p><pre><code>say Date.new(\"2014-12-31\").week-number;   # 1  (first week of 2015)\nsay Date.new(\"2016-01-02\").week-number;   # 53 (last week of 2015)</code></pre></p>","formatter":"<p>Defined as:</p><p><pre><code>method formatter(Dateish:D:)</code></pre></p><p>Returns the formatting function which is used for conversion to Str. If none was provided at object construction, a default formatter is used. In that case the method will return a Callable type object.</p><p>The formatting function is called by DateTime method Str with the invocant as its only argument.</p><p><pre><code>my $dt = Date.new('2015-12-31');  # (no formatter specified)\nsay $dt.formatter.^name;          # OUTPUT: «Callable␤»\nmy $us-format = sub ($self) { sprintf \"%02d/%02d/%04d\", .month, .day, .year given $self; };\n$dt = Date.new('2015-12-31', formatter => $us-format);\nsay $dt.formatter.^name;           # OUTPUT: «Sub␤»\nsay $dt;                          # OUTPUT: «12/31/2015␤»</code></pre></p>","is-leap-year":"<p>Defined as:</p><p><pre><code>method is-leap-year(--> Bool:D)</code></pre></p><p>Returns True if the year of the Dateish object is a leap year.</p><p><pre><code>say DateTime.new(:year<2016>).is-leap-year; # OUTPUT: «True␤»\nsay Date.new(\"1900-01-01\").is-leap-year;    # OUTPUT: «False␤»</code></pre></p>","day-of-week":"<p>Defined as:</p><p><pre><code>method day-of-week(Date:D: --> Int:D)</code></pre></p><p>Returns the day of the week, where 1 is Monday, 2 is Tuesday and Sunday is 7.</p><p><pre><code>say Date.new('2015-12-31').day-of-week;                                  # OUTPUT: «4␤»\nsay DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-week; # OUTPUT: «4␤»</code></pre></p>","month":"<p>Defined as:</p><p><pre><code>method month(Date:D: --> Int:D)</code></pre></p><p>Returns the month of the date (1..12).</p><p><pre><code>say Date.new('2015-12-31').month;                                  # OUTPUT: «12␤»\nsay DateTime.new(date => Date.new('2015-12-24'), hour => 1).month; # OUTPUT: «12␤»</code></pre></p>","day-of-month":"<p>Defined as:</p><p><pre><code>method day-of-month(Date:D: --> Int:D)</code></pre></p><p>Returns the day of the month of the date (1..31). Synonymous to the day method.</p><p><pre><code>say Date.new('2015-12-31').day-of-month;                                  # OUTPUT: «31␤»\nsay DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-month; # OUTPUT: «24␤»</code></pre></p>","week-year":"<p>Defined as:</p><p><pre><code>method week-year(Date:D: --> Int:D)</code></pre></p><p>Returns the week year of the date specified by the invocant. Normally week-year is equal to Date.year. Note however that dates early in January often end up in the last week of the prior year, and similarly, the final few days of December may be placed in the first week of the next year.</p><p><pre><code>say Date.new(\"2015-11-15\").week-year;   # 2015\nsay Date.new(\"2014-12-31\").week-year;   # 2015 (date belongs to the first week of 2015)\nsay Date.new(\"2016-01-02\").week-year;   # 2015 (date belongs to the last week of 2015)</code></pre></p>","week":"<p>Defined as:</p><p><pre><code>method week()</code></pre></p><p>Returns a list of two integers: the year, and the week number. This is because at the start or end of a year, the week may actually belong to the other year.</p><p><pre><code>my ($year, $week) = Date.new(\"2014-12-31\").week;\nsay $year;                       # OUTPUT: «2015␤»\nsay $week;                       # OUTPUT: «1␤»\nsay Date.new('2015-01-31').week; # OUTPUT: «(2015 5)␤»</code></pre></p>"},"prefix":"<p><pre><code>role Dateish { ... }</code></pre></p><p>Both Date and DateTime support accessing a year, month and day-of-month, as well as related functionality such as calculating the day of the week.</p>","name":"Dateish"},"X::Syntax::Reserved":{"name":"X::Syntax::Reserved","prefix":"<p><pre><code>class X::Syntax::Reserved does X::Syntax { }</code></pre></p><p>Syntax error thrown when a syntax is used which is reserved for future expansion.</p><p>For example</p><p><pre><code>my @a();\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThe () shape syntax in array declarations is reserved\n</code></pre></p>","defs":{"reserved":"<p><pre><code>method reserved(--> Str:D)</code></pre></p><p>Returns a text description of the reserved syntax.</p>"}},"X::Method::InvalidQualifier":{"defs":{"method":"<p><pre><code>method method(--> Str:D)</code></pre></p><p>Returns the name of the (unqualified) method.</p>","invocant":"<p>Returns the invocant of the failed, qualified method call</p>"},"prefix":"<p><pre><code>class X::Method::InvalidQualifier is Exception { }</code></pre></p><p>Thrown when a method is call in the form $invocant.TheClass::method if <$invocant> does not conform to TheClass.</p><p>For example</p><p><pre><code>1.Str::split(/a/);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Method::InvalidQualifier: Cannot dispatch to method split on Str because it is not inherited or done by Int␤»</code></pre></p>","name":"X::Method::InvalidQualifier"},"IO::Socket":{"name":"IO::Socket","prefix":"<p><pre><code>role IO::Socket { ... }</code></pre></p><p>IO::Socket contains read and write methods for sockets. It is usually used through IO::Socket::INET.</p>","defs":{"put":"<p><pre><code>method put(IO::Socket:D: Str(Cool) $string)</code></pre></p><p>Writes the supplied string, with a \\n appended to it, to the socket, thus sending it to other end of the connection.</p><p>Fails if the socket is not connected.</p>","read":"<p><pre><code>method read(IO::Socket:D: Int(Cool) $bytes)</code></pre></p><p>Reads $bytes bytes from the socket and returns them in a Blob.</p><p>Fails if the socket is not connected.</p>","get":"<p>Defined as:</p><p><pre><code>method get(IO::Socket:D: --> Str:D)</code></pre></p><p>Reads a single line of input from the socket, removing the trailing newline characters (as set by .nl-in). Returns Nil, if no more input is available.</p><p>Fails if the socket is not connected.</p>","recv":"<p><pre><code>method recv(IO::Socket:D: Cool $elems = Inf, :$bin)</code></pre></p><p>Receive a packet and return it, either as a Blob if :bin was passed, or a Str if not. Receives up to $elems or 65535 (whichever is smaller) bytes or characters.</p><p>Fails if the socket is not connected.</p>","write":"<p><pre><code>method write(IO::Socket:D: Blob:D $buf)</code></pre></p><p>Writes the supplied buffer to the socket, thus sending it to other end of the connection. The string version is #method print.</p><p>Fails if the socket is not connected.</p>","close":"<p><pre><code>method close(IO::Socket:D)</code></pre></p><p>Closes the socket.</p><p>Fails if the socket is not connected.</p>","print":"<p><pre><code>method print(IO::Socket:D: Str(Cool) $string)</code></pre></p><p>Writes the supplied string to the socket, thus sending it to other end of the connection. The binary version is #method write.</p><p>Fails if the socket is not connected.</p>"}},"Bag":{"name":"Bag","prefix":"<p><pre><code>class Bag does Baggy { }</code></pre></p><p>A Bag is an immutable bag/multiset implementing Associative, meaning a collection of distinct elements in no particular order that each have an integer weight assigned to them signifying how many copies of that element are considered \"in the bag\". (For mutable bags, see BagHash instead.)</p><p>Bags are often used for performing weighted random selections - see .pick and .roll.</p><p>Objects/values of any type are allowed as bag elements. Within a Bag, items that would compare positively with the === operator are considered the same element, with the number of how many there are as its weight. But of course you can also easily get back the expanded list of items (without the order):</p><p><pre><code>my $breakfast = bag <spam eggs spam spam bacon spam>;\n\nsay $breakfast.elems;      # OUTPUT: «3␤»\nsay $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\nsay $breakfast.total;      # OUTPUT: «6␤»\nsay $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n</code></pre></p><p>Bags can be treated as object hashes using the { } postcircumfix operator, or the < >  operator for literal string keys, which returns the corresponding integer weight for keys that are elements of the bag, and 0 for keys that aren't:</p><p><pre><code>my $breakfast = bag <spam eggs spam spam bacon spam>;\nsay $breakfast<bacon>;    # OUTPUT: «1␤»\nsay $breakfast<spam>;     # OUTPUT: «4␤»\nsay $breakfast<sausage>;  # OUTPUT: «0␤»</code></pre></p>","defs":{}},"X::Parameter::WrongOrder":{"defs":{"misplaced":"<p>Returns the kind of misplaced parameter (for example \"mandatory\", \"positional\").</p>","parameter":"<p>Returns the name of the (first) misplaced parameter</p>"},"prefix":"<p><pre><code>class X::Parameter::WrongOrder does X::Comp { }</code></pre></p><p>Compile time error that is thrown when parameters in a signature in the wrong order (for example if an optional parameter comes before a mandatory parameter).</p><p>For example</p><p><pre><code>sub f($a?, $b) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put required parameter $b after optional parameters\n</code></pre></p>","name":"X::Parameter::WrongOrder"},"X::Syntax::UnlessElse":{"defs":{},"prefix":"<p><pre><code>class X::Syntax::UnlessElse does X::Syntax { }</code></pre></p><p>Syntax error thrown when an unless clause is followed by an else clause.</p><p>For example</p><p><pre><code>unless 1 { } else { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n\"unless\" does not take \"else\", please rewrite using \"if\"\n</code></pre></p>","name":"X::Syntax::UnlessElse"},"Supplier":{"defs":{"new":"<p><pre><code>method new()</code></pre></p><p>The Supplier constructor.</p>","done":"<p><pre><code>method done(Supplier:D:)</code></pre></p><p>Calls the done callback on all the taps that have one.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply   = $supplier.Supply;\n$supply.tap(-> $v { say $v }, done => { say \"no more answers\" });\n$supplier.emit(42);\n$supplier.done;</code></pre></p><p>Will output:</p><p><pre><code>42\nno more answers\n</code></pre></p>","Supply":"<p><pre><code>method Supply(Supplier:D: --> Supply)</code></pre></p><p>This creates a new Supply object to which any values which are emitted on this supplier are passed. This is the factory for all live supplies.</p>","emit":"<p><pre><code>method emit(Supplier:D: Mu \\value)</code></pre></p><p>Sends the given value to all of the taps on all of the supplies created by Supply on this Supplier.</p>"},"prefix":"<p><pre><code>class Supplier { }</code></pre></p><p>This is a factory for live Supply objects, which provides the mechanism for emitting new values onto the supplies:</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply_1 = $supplier.Supply;\n$supply_1.tap(-> $v { say \"One $v\" });\nmy $supply_2 = $supplier.Supply;\n$supply_2.tap(-> $v { say \"Two $v\" });\n$supplier.emit(42);</code></pre></p><p>Will output:</p><p><pre><code>One 42\nTwo 42\n</code></pre></p><p>on demand supplies are created by the factory methods of the Supply class or by the supply keyword. A mixture of a live and on-demand Supply can be created with a Supplier::Preserving.</p>","name":"Supplier"},"List":{"prefix":"<p><pre><code>my class List does Iterable does Positional { }\n</code></pre></p><p>List stores items sequentially and potentially lazily.</p><p>Indexes into lists and arrays start at 0 by default.</p><p>You can assign to list elements if they are containers. Use Arrays to have every value of the list stored in a container.</p><p>List implements Positional and as such provides support for subscripts.</p>","defs":{"values":"<p>Defined as:</p><p><pre><code>sub    values($list --> Seq:D)\nmethod values(List:D: --> Seq:D)</code></pre></p><p>Returns a sequence of the list elements, in order.</p><p><pre><code>say (1,2,3,4).^name;        # OUTPUT: «List␤»\nsay (1,2,3,4).values.^name; # OUTPUT: «Seq␤»</code></pre></p>","combinations":"<p>Defined as:</p><p><pre><code>multi sub    combinations($from, $of = 0..*             --> Seq:D)\nmulti method combinations(List:D: Int() $of             --> Seq:D)\nmulti method combinations(List:D: Iterable:D $of = 0..* --> Seq:D)</code></pre></p><p>Returns a Seq with all $of-combinations of the invocant list. $of can be a numeric Range, in which case combinations of the range of item numbers it represents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item combinations>). Otherwise, $of is coerced to an Int.</p><p><pre><code>.say for <a b c>.combinations: 2;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)</code></pre></p><p>Above, there are three possible ways to combine the 2-items lists from the original list, which is what we receive in the output. See permutations if you want permutations instead of combinations.</p><p>With Range argument, we get both three 2-item combinations and one 3-item combination:</p><p><pre><code>.say for <a b c>.combinations: 2..3;\n# OUTPUT:\n# (a b)\n# (a c)\n# (b c)\n# (a b c)</code></pre></p><p>If $of is negative or is larger than there are items in the given list, an empty list will be returned. If $of is zero, a 1-item list containing an empty list will be returned (there's exactly 1 way to pick no items).</p><p>The subroutine form is equivalent to the method form called on the first argument ($from), with the exception that if $from is not an Iterable, it gets coerced to an Int and combinations are made from a Range constructed with 0..^$from instead:</p><p><pre><code>.say for combinations 3, 2\n# OUTPUT:\n# (0 1)\n# (0 2)\n# (1 2)</code></pre></p><p>Note: some implementations may limit the maximum value of non-Iterable $from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems have a limit of 2²⁸-1.</p>","produce":"<p>Defined as:</p><p><pre><code>multi sub    produce(&with, *@values)\nmulti method produce(List:D: &with)</code></pre></p><p>Generates a list of all intermediate \"combined\" values along with the final result by iteratively applying a function which knows how to combine two values.</p><p>If @values contains just a single element, a list containing that element is returned immediately. If it contains no elements, an exception is thrown, unless &with is an operator with a known identity value.</p><p>If &with is the function object of an operator, its inherent identity value and associativity is respected - in other words, (VAL1, VAL2, VAL3).produce(&[OP]) is the same as VAL1 OP VAL2 OP VAL3 even for operators which aren't left-associative:</p><p><pre><code># Raise 2 to the 81st power, because 3 to the 4th power is 81\n[2,3,4].produce(&[**]).say;        # OUTPUT: «(4 81 2417851639229258349412352)␤»\nsay produce &[**], (2,3,4);        # OUTPUT: «(4 81 2417851639229258349412352)␤»\nsay [\\**] (2,3,4);                 # OUTPUT: «(4 81 2417851639229258349412352)␤»\n\n# Subtract 4 from -1, because 2 minus 3 is -1\n[2,3,4].produce(&[-]).say;         # OUTPUT: «(2 -1 -5)␤»\nsay produce &[-], (2,3,4);         # OUTPUT: «(2 -1 -5)␤»\nsay [\\-] (2,3,4);                  # OUTPUT: «(2 -1 -5)␤»</code></pre></p><p>A triangle metaoperator [\\ ] provides a syntactic shortcut for producing with an infix operator:</p><p><pre><code># The following all do the same thing...\nmy @numbers = (1,2,3,4,5);\nsay produce { $^a + $^b }, @numbers;\nsay produce * + *, @numbers;\nsay produce &[+], @numbers; # operator does not need explicit identity\nsay [\\+] @numbers;          # most people write it this way</code></pre></p><p>The visual picture of a triangle [\\ is not accidental. To produce a triangular list of lists, you can use a \"triangular comma\":</p><p><pre><code>[\\,] 1..5;\n# (\n# (1)\n# (1 2)\n# (1 2 3)\n# (1 2 3 4)\n# (1 2 3 4 5)\n# )</code></pre></p><p>Since produce is an implicit loop, it responds to next, last and redo statements inside &with:</p><p><pre><code>say (2,3,4,5).produce: { last if $^a > 7; $^a + $^b }; # OUTPUT: «(2 5 9)␤»</code></pre></p>","roll":"<p>Defined as:</p><p><pre><code>multi sub    roll($count, *@list --> Seq:D)\nmulti method roll(List:D: $count --> Seq:D)\nmulti method roll(List:D: --> Mu)</code></pre></p><p>If $count is supplied: Returns a sequence of $count elements, each randomly selected from the list. Each random choice is made independently, like a separate die roll where each die face is a list element. If * is passed as $count returns a lazy, infinite sequence of randomly chosen elements from the original list.</p><p>If $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say <a b c d e>.roll;       # 1 random letter\nsay <a b c d e>.roll: 3;    # 3 random letters\nsay roll 8, <a b c d e>;    # 8 random letters\n\nmy $random-digits := (^10).roll(*);\nsay $random-digits[^15];    # 15 random digits</code></pre></p>","head":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>This method is directly inherited from Any, and it returns the first $n items of the list, an empty list if $n <= 0, or the first element with no argument. The version that takes a Callable uses a WhateverCode to specify all elements, starting from the first, but the last ones.</p><p>Examples:</p><p><pre><code>say <a b c d e>.head ;     # OUTPUT: «a␤»\nsay <a b c d e>.head(2);   # OUTPUT: «(a b)␤»\nsay <a b c d e>.head(*-3); # OUTPUT: «(a b)␤»</code></pre></p>","antipairs":"<p>Defined as:</p><p><pre><code>method antipairs(List:D: --> Seq:D)</code></pre></p><p>Returns a Seq of pairs, with the values as keys and the indexes as values, i.e. the direct opposite to pairs.</p><p><pre><code>say <a b c>.antipairs;  # OUTPUT: «(a => 0 b => 1 c => 2)␤»</code></pre></p>","pairs":"<p>Defined as:</p><p><pre><code>sub    pairs($list --> Seq:D)\nmethod pairs(List:D: --> Seq:D)</code></pre></p><p>Returns a sequence of pairs, with the indexes as keys and the list values as values.</p><p><pre><code><a b c>.pairs   # (0 => a 1 => b 2 => c)</code></pre></p>","Numeric":"<p>Defined as:</p><p><pre><code>method Numeric(List:D: --> Int:D)</code></pre></p><p>Returns the number of elements in the list (same as .elems).</p><p><pre><code>say (1,2,3,4,5).Numeric; # OUTPUT: «5␤»</code></pre></p>","from":"<p>Assumes the list contains Match objects and returns the value of .from called on the first element of the list.</p><p><pre><code>'abcdefg' ~~ /(c)(d)/;\nsay $/.list.from;         # OUTPUT: «2␤»\n\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.list.from;         # OUTPUT: «3␤»</code></pre></p>","batch":"<p>Defined As:</p><p><pre><code>multi method batch(Int:D $batch --> Seq)\nmulti method batch(Int:D :$elems --> Seq)</code></pre></p><p>Returns a Seq of the elements in batches of :$elems or $batch, respectively. If the number of elements is not a multiple of $batch, the last batch may have less than $batch elements, similar to .rotor($batch, :partial).</p>","eager":"<p>Defined as:</p><p><pre><code>multi method eager(List:D: --> List:D)\nmulti sub eager(*@elems --> List:D)</code></pre></p><p>Evaluates all elements in the List eagerly, and returns them as a List.</p><p><pre><code>my  \\ll = (lazy 1..5).cache;\n\nsay ll[];     # OUTPUT: «(...)␤»\nsay ll.eager  # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p>","to":"<p><pre><code>\"abc123def\" ~~ m:g/\\d/;\nsay $/.to; # OUTPUT: «6␤»</code></pre></p><p>Assumes the List contains Match objects, such as the $/ variable being a List, when using :g modifier in regexes. Returns the value of .to called on the last element of the list.</p>","Str":"<p>Defined as:</p><p><pre><code>method Str(List:D: --> Str:D)</code></pre></p><p>Stringifies the elements of the list and joins them with spaces (same as .join(' ')).</p><p><pre><code>say (1,2,3,4,5).Str; # OUTPUT: «1 2 3 4 5␤»</code></pre></p>","roundrobin":"<p>Defined as:</p><p><pre><code>sub roundrobin(+list-of-lists --> Seq)</code></pre></p><p>Builds a 'list of lists', returned as a sequence, from multiple input lists or other iterables. roundrobin returns an identical result to that of zip, except when the input lists are allowed to have an unequal number of elements.</p><p><pre><code>say roundrobin <a b c>, <d e f>, <g h i>;\n# OUTPUT: «((a d g) (b e h) (c f i))␤»\n\nsay .join(\",\") for roundrobin([1, 2], [2, 3], [3, 4]);\n# OUTPUT: «1,2,3␤\n# 2,3,4␤»</code></pre></p><p>roundrobin does not terminate once one or more of the input lists become exhausted, but proceeds until all elements from all lists have been processed.</p><p><pre><code>say roundrobin <a b c>, <d e f m n o p>, <g h i j>;\n# OUTPUT: «((a d g) (b e h) (c f i) (m j) (n) (o) (p))␤»\n\nsay .join(\",\") for roundrobin([1, 2], [2, 3, 57, 77], [3, 4, 102]);\n# OUTPUT: «1,2,3␤\n# 2,3,4␤\n# 57,102␤\n# 77␤»</code></pre></p><p>Therefore no data values are lost due in the 'zipping' operation. A record of which input list provided which element cannot be gleaned from the resulting sequence, however.</p><p>roundrobin can be useful in combining messy data to the point where a manual post-processing step can then be undertaken.</p>","rotor":"<p>Defined as:</p><p><pre><code>method rotor(*@cycle, Bool() :$partial --> Seq:D)</code></pre></p><p>Returns a sequence of lists, where each sublist is made up of elements of the invocant.</p><p>In the simplest case, @cycle contains just one integer, in which case the invocant list is split into sublists with as many elements as the integer specifies. If :$partial is True, the final chunk is included even if it doesn't satisfy the length requirement:</p><p><pre><code>say ('a'..'h').rotor(3).join('|');              # OUTPUT: «a b c|d e f␤»\nsay ('a'..'h').rotor(3, :partial).join('|');    # OUTPUT: «a b c|d e f|g h␤»</code></pre></p><p>If the element of @cycle is a Pair instead, the key of the pair specifies the length of the return sublist, and the value the gap between sublists; negative gaps produce overlap:</p><p><pre><code>say ('a'..'h').rotor(2 => 1).join('|');         # OUTPUT: «a b|d e|g h␤»\nsay ('a'..'h').rotor(3 => -1).join('|');        # OUTPUT: «a b c|c d e|e f g␤»</code></pre></p><p>If @cycle contains more than element, rotor cycles through it to find the number of elements for each sublist:</p><p><pre><code>say ('a'..'h').rotor(2, 3).join('|');           # OUTPUT: «a b|c d e|f g␤»\nsay ('a'..'h').rotor(1 => 1, 3).join('|');      # OUTPUT: «a|c d e|f␤»</code></pre></p><p>Combining multiple cycles and :partial also works:</p><p><pre><code>say ('a'..'h').rotor(1 => 1, 3 => -1, :partial).join('|');\n# OUTPUT: «a|c d e|e|g h␤»</code></pre></p><p>See this blog post for more elaboration on rotor.</p>","end":"<p>Defined as:</p><p><pre><code>sub    end($list --> Int:D)\nmethod end(List:D: --> Int:D)</code></pre></p><p>Returns the index of the last element.</p><p><pre><code>say (1,2,3,4).end; # OUTPUT: «3␤»</code></pre></p>","grep":"<p>Defined as:</p><p><pre><code>sub    grep(Mu $matcher, *@elems, :$k, :$kv, :$p, :$v --> Seq:D)\nmethod grep(List:D:  Mu $matcher, :$k, :$kv, :$p, :$v --> Seq:D)</code></pre></p><p>Returns a sequence of elements against which $matcher smartmatches. The elements are returned in the order in which they appear in the original list.</p><p>Examples:</p><p><pre><code>say ('hello', 1, 22/7, 42, 'world').grep: Int;              # OUTPUT: «(1 42)␤»\nsay grep { .Str.chars > 3 }, 'hello', 1, 22/7, 42, 'world'; # OUTPUT: «(hello 3.142857 world)␤»</code></pre></p><p>Note that if you want to grep for elements that do not match, you can use a none-Junction:</p><p><pre><code>say <a b 6 d 8 0>.grep(none Int);           # OUTPUT: «(a b d)␤»\nsay <a b c d e f>.grep(none /<[aeiou]>/);   # OUTPUT: «(b c d f)␤»</code></pre></p><p>Another option to grep for elements that do not match a regex is to use a block:</p><p><pre><code>say <a b c d e f>.grep({! /<[aeiou]>/})     # OUTPUT: «(b c d f)␤»</code></pre></p><p>The reason the example above works is because a regex in boolean context applies itself to $_. In this case, ! boolifies the /<[aeiou]>/ regex and negates the result. Smartmatching against a Callable (in this case a Block) returns the value returned from that callable, so the boolified result of a regex is then used to decide whether the current value should be kept in the result of a grep.</p><p>The optional named parameters :k, :kv, :p, :v provide the same functionality as on slices:</p>* <p>k</p><br><p>Only return the index values of the matching elements in order.</p>* <p>kv</p><br><p>Return both the index and matched elements in order.</p>* <p>p</p><br><p>Return the index and the matched element as a Pair, in order.</p>* <p>v</p><br><p>Only return the matched elements (same as not specifying any named parameter at all).</p><p>Examples:</p><p><pre><code>say ('hello', 1, 22/7, 42, 'world').grep: Int, :k;\n# OUTPUT: «(1 3)␤»\nsay grep { .Str.chars > 3 }, :kv, 'hello', 1, 22/7, 42, 'world';\n# OUTPUT: «(0 hello 2 3.142857 4 world)␤»\nsay grep { .Str.chars > 3 }, :p, 'hello', 1, 22/7, 42, 'world';\n# OUTPUT: «(0 => hello 2 => 3.142857 4 => world)␤»</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>multi method gist(List:D: --> Str:D)</code></pre></p><p>Returns the string containing the parenthesized \"gist\" of the List, listing up to the first 100 elements, separated by space, appending an ellipsis if the List has more than 100 elements. If List is-lazy, returns string '(...)'</p><p><pre><code>put (1, 2, 3).gist;   # OUTPUT «(1 2 3)␤»\nput (1..∞).List.gist; # OUTPUT «(...)␤»\n\nput (1..200).List.gist;\n# OUTPUT:\n# (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n# 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49\n# 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n# 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95\n# 96 97 98 99 100 ...)\n</code></pre></p>","keys":"<p>Defined as:</p><p><pre><code>sub    keys($list --> Seq:D)\nmethod keys(List:D: --> Seq:D)</code></pre></p><p>Returns a sequence of indexes into the list (e.g., 0..(@list.elems-1)).</p><p><pre><code>say (1,2,3,4).keys; # OUTPUT: «0..3␤»</code></pre></p>","cross":"<p><pre><code>sub cross(+@e, :&with --> Seq:D)</code></pre></p><p>Computes the cross-product of two or more lists or iterables. This returns a sequence of lists where the first item in each list is an item from the first iterable, the second is from the second given iterable, etc. Every item will be paired with every other item in all the other lists.</p><p><pre><code>say cross(<a b c>, <d e f>).map(*.join).join(\",\")\n# OUTPUT: «ad,ae,af,bd,be,bf,cd,ce,cf␤»</code></pre></p><p>The cross routine has an infix synonym as well, named X.</p><p><pre><code>say (<a b c> X <d e f>).map(*.join).join(\",\")\n# output is the same as the previous example</code></pre></p><p>If the optional with parameter is passed, it is used as a reduction operation to apply to each of the cross product items.</p><p><pre><code>say cross([1, 2, 3], [4, 5, 6], :with(&infix:<*>)).join(\",\");\n# OUTPUT: «4,5,6,8,10,12,12,15,18␤»</code></pre></p><p>The X operator can be combined with another operator as a metaoperator to perform a reduction as well:</p><p><pre><code>say ([1, 2, 3] X* [4, 5, 6]).join(\",\")\n# same output as the previous example</code></pre></p>","categorize":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&as)\nmulti method categorize($test, :&as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>These methods are directly inherited from Any; see Any.list for more examples.</p><p>This routine transforms a list of values into a hash representing the categorizations of those values according to $test, which is called once for every element in the list; each hash key represents one possible categorization for one or more of the incoming list values, and the corresponding hash value contains an array of those list values categorized by the $test, acting like a mapper, into the category of the associated key.</p><p>Note that, unlike classify, which assumes that the return value of the mapper is a single value, categorize always assumes that the return value of the mapper is a list of categories that are appropriate to the current value.</p><p>Example:</p><p><pre><code>sub mapper(Int $i) returns List {\n    $i %% 2 ?? 'even' !! 'odd',\n    $i.is-prime ?? 'prime' !! 'not prime'\n}\nsay categorize &mapper, (1, 7, 6, 3, 2);  # OUTPUT: «{even => [6 2], not prime => [1 6],\n                                          #          odd => [1 7 3], prime => [7 3 2]}␤»</code></pre></p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(List:D: $topic)</code></pre></p><p>If $topic is an Iterable, returns True or False based on whether the contents of the two Iterables match. A Whatever element in the invocant matches anything in the corresponding position of the $topic Iterable. A HyperWhatever matches any number of any elements, including no elements:</p><p><pre><code>say (1, 2, 3)       ~~ (1,  *, 3);  # OUTPUT: «True␤»\nsay (1, 2, 3)       ~~ (9,  *, 5);  # OUTPUT: «False␤»\nsay (1, 2, 3)       ~~ (   **, 3);  # OUTPUT: «True␤»\nsay (1, 2, 3)       ~~ (   **, 5);  # OUTPUT: «False␤»\nsay (1, 3)          ~~ (1, **, 3); # OUTPUT: «True␤»\nsay (1, 2, 4, 5, 3) ~~ (1, **, 3); # OUTPUT: «True␤»\nsay (1, 2, 4, 5, 6) ~~ (1, **, 5); # OUTPUT: «False␤»\nsay (1, 2, 4, 5, 6) ~~ (   **   ); # OUTPUT: «True␤»\nsay ()              ~~ (   **   ); # OUTPUT: «True␤»</code></pre></p><p>In addition, returns False if either the invocant or $topic is a lazy Iterable, unless $topic is the same object as the invocant, in which case True is returned.</p><p>If $topic is not an Iterable, returns the invocant if the invocant has no elements or its first element is a Match object (this behavior powers m:g// smartmatch), or False otherwise.</p>","reduce":"<p>Defined as:</p><p><pre><code>multi method reduce(Any:U: & --> Nil)\nmulti method reduce(Any:D: &with)\nmulti sub reduce (&with, +list)</code></pre></p><p>The first form is obviously a no-op. The second form generates a single \"combined\" value from a list of arbitrarily many values, by iteratively applying a function which knows how to combine two values.</p><p>If @values contains just a single element, the operator is applied to that single element if possible; if not, it returns the element itself.</p><p><pre><code>say [-] <10 5 3>; #OUTPUT: 2␤\nsay [-] 10;       #OUTPUT: 10␤</code></pre></p><p>If it contains no elements, an exception is thrown, unless &with is an operator with a known identity value. For this reason, you may want to prefix the input list with an explicit identity value:</p><p><pre><code>my @strings = (\"One good string!\", \"And one another good string!\");\nsay reduce { $^a ~ $^b }, '', |@strings;               # like @strings.join\nmy @numbers = (1,2,3,4,5);\nsay reduce { $^a > $^b ?? $^a !! $^b }, 0, |@numbers;  # like @numbers.max</code></pre></p><p>If &with is the function object of an operator, its inherent identity value and associativity is respected - in other words, (VAL1, VAL2, VAL3).reduce(&[OP]) is the same as VAL1 OP VAL2 OP VAL3 even for operators which aren't left-associative:</p><p><pre><code># Raise 2 to the 81st power, because 3 to the 4th power is 81\n[2,3,4].reduce(&[**]).lsb.say;        # OUTPUT: «81␤»\n(2**(3**4)).lsb.say;                  # OUTPUT: «81␤»\n(2**3**4).lsb.say;                    # OUTPUT: «81␤»\n\n# Subtract 4 from -1, because 2 minus 3 is -1\n[2,3,4].reduce(&[-]).say;             # OUTPUT: «-5␤»\n((2-3)-4).say;                        # OUTPUT: «-5␤»\n(2-3-4).say;                          # OUTPUT: «-5␤»</code></pre></p><p>Since reducing with an infix operator is a common thing to do, the [ ] metaoperator provides a syntactic shortcut:</p><p><pre><code># The following all do the same thing...\nmy @numbers = (1,2,3,4,5);\nsay reduce { $^a + $^b }, 0, |@numbers;\nsay reduce * + *, 0, |@numbers;\nsay reduce &[+], @numbers; # operator does not need explicit identity\nsay [+] @numbers;          # most people write it this way</code></pre></p><p>Please note also the use of reduce in sub form. Since reduce is an implicit loop, it responds to next, last and redo statements inside &with:</p><p><pre><code>say (2,3,4,5).reduce: { last if $^a > 7; $^a + $^b }; # says 9</code></pre></p><p>Practical example:</p><p><pre><code># Generate a random-ish math formula like \"(4 + ((3 * x) + 11) / 6))\"\n\nmy @ops = [Z] (<+ - * />, 1..20)».roll(4);\n\nsay ('x', |@ops).reduce: -> $formula, [$op, $number] {\n    Bool.pick ?? \"($formula $op $number)\"\n              !! \"($number $op $formula)\"\n}</code></pre></p><p>Note: In the functional programming world, this operation is generally called a fold. With a right-associative operator it is a right fold, otherwise (and usually) it is a left fold:</p><p><pre><code>sub infix:<foo>($a, $b) is assoc<right> { \"($a, $b)\" }\nsay [foo] 1, 2, 3, 4; # OUTPUT: «(1, (2, (3, 4)))␤»\n\nsub infix:<bar>($a, $b) is assoc<left> { \"($a, $b)\" }\nsay [bar] 1, 2, 3, 4; # OUTPUT: «(((1, 2), 3), 4)␤»</code></pre></p>","sort":"<p>Defined as:</p><p><pre><code>multi sub    sort(*@elems      --> Seq:D)\nmulti sub    sort(&custom-routine-to-use, *@elems --> Seq:D)\nmulti method sort(List:D:      --> Seq:D)\nmulti method sort(List:D: &custom-routine-to-use  --> Seq:D)</code></pre></p><p>Sorts the list, smallest element first. By default infix:<cmp>  is used for comparing list elements.</p><p>If &custom-routine-to-use is provided, and it accepts two arguments, it is invoked for pairs of list elements, and should return Order::Less, Order::Same or Order::More.</p><p>If &custom-routine-to-use accepts only one argument, the list elements are sorted according to custom-routine-to-use($a) cmp custom-routine-to-use($b) . The return values of &custom-routine-to-use are cached, so that &custom-routine-to-use is only called once per list element.</p><p>Examples:</p><p><pre><code>say (3, -4, 7, -1, 2, 0).sort;                  # OUTPUT: «(-4 -1 0 2 3 7)␤»\nsay (3, -4, 7, -1, 2, 0).sort: *.abs;           # OUTPUT: «(0 -1 2 3 -4 7)␤»\nsay (3, -4, 7, -1, 2, 0).sort: { $^b leg $^a }; # OUTPUT: «(7 3 2 0 -4 -1)␤»</code></pre></p><p>Additionally, if &custom-routine-to-use returns a List, elements will be sorted based upon multiple values with subsequent values in the List being used to break the tie if the comparison between the prior elements evaluate to Order::Same.</p><p><pre><code>my @resistance = (\n    %( first-name => 'Kyle',  last-name => 'Reese'  ),\n    %( first-name => 'Sarah', last-name => 'Connor' ),\n    %( first-name => 'John',  last-name => 'Connor' ),\n);\n.say for @resistance.sort: { .<last-name>, .<first-name> };\n\n#`(\nOUTPUT:\n  {first-name => John, last-name => Connor}\n  {first-name => Sarah, last-name => Connor}\n  {first-name => Kyle, last-name => Reese}\n)</code></pre></p><p>This sorting can be based on characteristics of a single element:</p><p><pre><code>say <ddd aaa bbb bb ccc c>.sort( {.chars, .Str} );\n# OUTPUT: «(c bb aaa bbb ccc ddd)␤»\n</code></pre></p><p>In this case, elements of the array are sorted in ascending order according first to the string length (.chars) and second to the actual alphabetical order .Str) if the length is exactly the same.</p><p>Any number of criteria can be used in this:</p><p><pre><code>say <01 11 111 2 20 02>.sort( { .Int, .comb.sum, .Str } );\n# OUTPUT: «(01 02 2 11 20 111)␤»\n</code></pre></p>","reverse":"<p>Defined as:</p><p><pre><code>multi sub    reverse(*@list  --> Seq:D)\nmulti method reverse(List:D: --> Seq:D)</code></pre></p><p>Returns a Seq with the same elements in reverse order.</p><p>Note that reverse always refers to reversing elements of a list; to reverse the characters in a string, use flip.</p><p>Examples:</p><p><pre><code>say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\nsay reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(--> Capture:D)</code></pre></p><p>Returns a Capture where each Pair, if any, in the List has been converted to a named argument (with the key of the Pair stringified). All other elements in the List are converted to positional arguments in the order they are found, i.e. the first non pair item in the list becomes the first positional argument, which gets index 0, the second non pair item becomes the second positional argument, getting index 1 etc.</p><p><pre><code>my $list = (7, 5, a => 2, b => 17);\nmy $capture = $list.Capture;\nsay $capture.keys;                                # OUTPUT: «(0 1 a b)␤»\nmy-sub(|$capture);                                # RESULT: «7, 5, 2, 17»\n\nsub my-sub($first, $second, :$a, :$b) {\n    say \"$first, $second, $a, $b\"\n}</code></pre></p><p>A more advanced example demonstrating the returned Capture being matched against a Signature.</p><p><pre><code>my $list = (7, 5, a => 2, b => 17);\nsay so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «True␤»\n\n$list = (8, 5, a => 2, b => 17);\nsay so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «False␤»</code></pre></p>","map":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &block;; :$label, :$item)\nmulti sub map(&code, +values)</code></pre></p><p>Examples applied to lists are included here for the purpose of illustration.</p><p>For a list, it invokes &code for each element and gathers the return values in a sequence and returns it. This happens lazily, i.e. &code is only invoked when the return values are accessed.Examples:</p><p><pre><code>say ('hello', 1, 22/7, 42, 'world').map: { .^name } # OUTPUT: «(Str Int Rat Int Str)␤»\nsay map *.Str.chars, 'hello', 1, 22/7, 42, 'world'; # OUTPUT: «(5 1 8 2 5)␤»\n</code></pre></p><p>map inspects the arity of the code object, and tries to pass as many arguments to it as expected:</p><p><pre><code>sub b($a, $b) { \"$a before $b\" };\nsay <a b x y>.map(&b).join(', ');   # OUTPUT: «a before b, x before y␤»</code></pre></p><p>iterates the list two items at a time.</p><p>Note that map does not flatten embedded lists and arrays, so</p><p><pre><code>((1, 2), <a b>).map({ .join(',')})</code></pre></p><p>passes (1, 2) and <a b>  in turn to the block, leading to a total of two iterations and the result sequence \"1,2\", \"a,b\". See method flatmap for an alternative that flattens.</p><p>If &code is a Block loop phasers will be executed and loop control statements will be treated as in loop control flow. Please note that return is executed in the context of its definition. It is not the return statement of the block but the surrounding Routine. Using a Routine will also handle loop control statements and loop phasers. Any Routine specific control statement or phaser will be handled in the context of that Routine.</p><p><pre><code>sub s {\n    my &loop-block = {\n        return # return from sub s\n    };\n    say 'hi';\n    (1..3).map: &loop-block;\n    say 'oi‽' # dead code\n};\ns\n# RESULT: «hi»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(List:D: --> Bool:D)</code></pre></p><p>Returns True if the list has at least one element, and False for the empty list.</p><p><pre><code>say ().Bool;  # OUTPUT: «False␤»\nsay (1).Bool; # OUTPUT: «True␤»</code></pre></p>","tail":"<p>Defined as:</p><p><pre><code>multi method tail(List:D:)\nmulti method tail(List:D: $n --> Seq:D)</code></pre></p><p>Returns a Seq containing the last $n items of the list. Returns an empty Seq if $n <= 0. Defaults to the last element if no argument is specified. Throws an exception if the list is lazy.</p><p>Examples:</p><p><pre><code>say <a b c d e>.tail(*-3);# OUTPUT: «(d e)␤»\nsay <a b c d e>.tail(2);  # OUTPUT: «(d e)␤»\nsay <a b c d e>.tail;     # OUTPUT: «e␤»\n</code></pre></p><p>In the first case, $n is taking the shape of a WhateverCode to indicate the number of elements from the beginning that will be excluded. $n can be either a Callable, in which case it will be called with the value 0, or anything else that can be converted to a number, in which case it will use that as the number of elements in the output Seq.</p><p><pre><code>say <a b c d e>.tail( { $_ - 2 } ); # OUTPUT: «(c d e)␤»</code></pre></p>","first":"<p>Defined as:</p><p><pre><code>sub    first(Mu $matcher, *@elems, :$k, :$kv, :$p, :$end)\nmethod first(List:D:  Mu $matcher?, :$k, :$kv, :$p, :$end)</code></pre></p><p>Returns the first item of the list which smartmatches against $matcher, returns Nil when no values match. The optional named parameter :end indicates that the search should be from the end of the list, rather than from the start.</p><p>Examples:</p><p><pre><code>say (1, 22/7, 42, 300).first: * > 5;                  # OUTPUT: «42␤»\nsay (1, 22/7, 42, 300).first: * > 5, :end;            # OUTPUT: «300␤»\nsay ('hello', 1, 22/7, 42, 'world').first: Complex;   # OUTPUT: «Nil␤»</code></pre></p><p>The optional named parameters :k, :kv, :p provide the same functionality as on slices:</p>* <p>k</p><br><p>Return the index value of the matching element. Index is always counted from the beginning of the list, regardless of whether the :end named parameter is specified or not.</p>* <p>kv</p><br><p>Return both the index and matched element.</p>* <p>p</p><br><p>Return the index and the matched element as a Pair.</p><p>Examples:</p><p><pre><code>say (1, 22/7, 42, 300).first: * > 5, :k;        # OUTPUT: «2␤»\nsay (1, 22/7, 42, 300).first: * > 5, :p;        # OUTPUT: «2 => 42␤»\nsay (1, 22/7, 42, 300).first: * > 5, :kv, :end; # OUTPUT: «(3 300)␤»</code></pre></p><p>In method form, the $matcher can be omitted, in which case the first available item (or last if :end is set) will be returned. See also head and tail methods.</p>","elems":"<p>Defined as:</p><p><pre><code>sub    elems($list --> Int:D)\nmethod elems(List:D: --> Int:D)</code></pre></p><p>Returns the number of elements in the list.</p><p><pre><code>say (1,2,3,4).elems; # OUTPUT: «4␤»</code></pre></p>","join":"<p>Defined as:</p><p><pre><code>sub    join($separator, *@list)\nmethod join(List:D: $separator = \"\")</code></pre></p><p>Treats the elements of the list as strings by calling .Str on each of them, interleaves them with $separator and concatenates everything into a single string. Note that you can omit the $separator if you use the method syntax.</p><p>Example:</p><p><pre><code>join ', ', <a b c>;             # RESULT: «a, b, c»</code></pre></p><p>Note that the method form does not flatten sublists:</p><p><pre><code>say (1, <a b c>).join('|');     # OUTPUT: «1|a b c␤»</code></pre></p><p>The method form also allows you to omit the separator:</p><p><pre><code>say <a b c>.join;               # OUTPUT: «abc␤»</code></pre></p><p>But it behaves slurpily, flattening all arguments after the first into a single list:</p><p><pre><code>say join('|', 3, 'þ', 1+4i);    # OUTPUT: «3|þ|1+4i␤»\nsay join ', ', <a b c>, 'd', 'e' , 'f'; # OUTPUT: «a, b, c, d, e, f␤»</code></pre></p><p>In this case, the first list <a b c is slurped and flattened, unlike what happens when join is invoked as a method.</p><p>If one of the elements of the list happens to be a Junction, then join will also return a Junction with concatenation done as much as possible:</p><p><pre><code>say (\"a\"|\"b\",\"c\",\"d\").join;     # OUTPUT: «any(acd,bcd)␤»</code></pre></p>","Set":"<p>In general, creates a set which has as members elements of the list.</p><p><pre><code>say <æ ß þ €>.Set;  # OUTPUT: «set(ß æ þ €)␤»</code></pre></p><p>However, there might be some unexpected changes in case the list includes non-scalar data structures. For instance, with Pairs:</p><p><pre><code>my @a = (:42a, :33b);\nsay @a;                # OUTPUT: «[a => 42 b => 33]␤»\nsay @a.Set;            # OUTPUT: «set(a b)␤»</code></pre></p><p>The set will be composed of the keys of the Pair whose corresponding value is not 0, eliminating all the values. Please check the Set documentation for more examples and a more thorough explanation.</p>","sink":"<p>Defined as:</p><p><pre><code>method sink(--> Nil) { }</code></pre></p><p>It does nothing, and returns Nil, as the definition clearly shows.</p><p><pre><code>sink [1,2,Failure.new(\"boo!\"),\"still here\"]; # OUTPUT: «»</code></pre></p>","invert":"<p>Defined as:</p><p><pre><code>method invert(List:D: --> Seq:D)</code></pre></p><p>Assumes every element of the List is a Pair. Returns all elements as a Seq of Pairs where the keys and values have been exchanged. If the value of a Pair is an Iterable, then it will expand the values of that Iterable into separate pairs.</p><p><pre><code>my $l = List.new('a' => (2, 3), 'b' => 17);\nsay $l.invert;   # OUTPUT: «(2 => a 3 => a 17 => b)␤»</code></pre></p>","permutations":"<p>Defined as:</p><p><pre><code>multi sub    permutations(Int()    $from --> Seq:D)\nmulti sub    permutations(Iterable $from --> Seq:D)\nmulti method permutations(List:D:        --> Seq:D)</code></pre></p><p>Returns all possible permutations of a list as a Seq of lists:</p><p><pre><code>.say for <a b c>.permutations;\n# OUTPUT:\n# (a b c)\n# (a c b)\n# (b a c)\n# (b c a)\n# (c a b)\n# (c b a)</code></pre></p><p>permutations treats all elements as unique, thus (1, 1, 2).permutations returns a list of 6 elements, even though there are only three distinct permutations, due to first two elements being the same.</p><p>The subroutine form behaves the same as the method form, computing permutations from its first argument $from. If $from is not an Iterable, coerces $from to an Int and picks from a Range constructed with 0..^$from:</p><p><pre><code>.say for permutations 3;\n# OUTPUT:\n# (0 1 2)\n# (0 2 1)\n# (1 0 2)\n# (1 2 0)\n# (2 0 1)\n# (2 1 0)</code></pre></p>","classify":"<p>Defined as:</p><p><pre><code>multi method classify($test, :$into!, :&as)\nmulti method classify($test, :&as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>Transforms a list of values into a hash representing the classification of those values; each hash key represents the classification for one or more of the incoming list values, and the corresponding hash value contains an array of those list values classified into the category of the associated key. $test will be an expression that will produce the hash keys according to which the elements are going to be classified.</p><p>Example:</p><p><pre><code>say classify { $_ %% 2 ?? 'even' !! 'odd' }, (1, 7, 6, 3, 2);\n# OUTPUT: «{even => [6 2], odd => [1 7 3]}␤»\nsay ('hello', 1, 22/7, 42, 'world').classify: { .Str.chars };\n# OUTPUT: «{1 => [1], 2 => [42], 5 => [hello world], 8 => [3.142857]}␤»</code></pre></p><p>It can also take :as as a named parameter, transforming the value before classifying it:</p><p><pre><code>say <Innie Minnie Moe>.classify( { $_.chars }, :as{ lc $_ });\n# OUTPUT: «{3 => [moe], 5 => [innie], 6 => [minnie]}␤»</code></pre></p><p>This code is classifying by number of characters, which is the expression that has been passed as $test parameter, but the :as block lowercases it before doing the transformation. The named parameter :into can also be used to classify into a newly defined variable:</p><p><pre><code><Innie Minnie Moe>.classify( { $_.chars }, :as{ lc $_ }, :into( my %words{Int} ) );\nsay %words; # OUTPUT: «{3 => [moe], 5 => [innie], 6 => [minnie]}␤»</code></pre></p><p>We are declaring the scope of %words{Int} on the fly, with keys that are actually integers; it gets created with the result of the classification.</p>","pick":"<p>Defined as:</p><p><pre><code>multi sub    pick($count, *@list --> Seq:D)\nmulti method pick(List:D: $count --> Seq:D)\nmulti method pick(List:D: --> Mu)</code></pre></p><p>If $count is supplied: Returns $count elements chosen at random and without repetition from the invocant. If * is passed as $count, or $count is greater than or equal to the size of the list, then all elements from the invocant list are returned in a random sequence; i.e. they are returned shuffled.</p><p>In method form, if $count is omitted: Returns a single random item from the list, or Nil if the list is empty</p><p>Examples:</p><p><pre><code>say <a b c d e>.pick;           # OUTPUT: «b␤»\nsay <a b c d e>.pick: 3;        # OUTPUT: «(c a e)␤»\nsay <a b c d e>.pick: *;        # OUTPUT: «(e d a b c)␤»</code></pre></p>","fmt":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s', $separator = ' ' --> Str:D)</code></pre></p><p>Returns a string where each element in the list has been formatted according to $format and where each element is separated by $separator.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>my @a = 8..11;\nsay @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»</code></pre></p>","sum":"<p>Defined as:</p><p><pre><code>sub    sum($list   --> Numeric:D)\nmethod sum(List:D: --> Numeric:D)</code></pre></p><p>Returns the sum of all elements in the list or 0 if the list is empty. Throws an exception if an element can not be coerced into Numeric.</p><p><pre><code>say (1, 3, pi).sum;       # OUTPUT: «7.14159265358979␤»\nsay (1, \"0xff\").sum;      # OUTPUT: «256␤»\nsay sum(0b1111, 5);       # OUTPUT: «20␤»</code></pre></p><p>When being called on native integer arrays, it is also possible to specify a :wrap named parameter. This will add the values as native integers, wrapping around if they exceed the size of a native integer. If you are sure you will not exceed that value, or if you don't mind, using :wrap will make the calculation about 20x as fast.</p><p><pre><code>my int @values = ^1_000_000;\nsay @a.sum(:wrap);        # OUTPUT: «499999500000␤»\n</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>method Int(List:D: --> Int:D)</code></pre></p><p>Returns the number of elements in the list (same as .elems).</p><p><pre><code>say (1,2,3,4,5).Int; # OUTPUT: «5␤»</code></pre></p>","zip":"<p>Defined as:</p><p><pre><code>sub zip(+@e, :&with --> Seq:D)</code></pre></p><p>Builds a 'list of lists', returned as a sequence, from multiple input lists or other iterables.</p><p>zip iterates through each of the input lists synchronously, 'Zipping' them together, so that elements are grouped according to their input list index, in the order that the lists are provided.</p><p><pre><code>say zip(<a b c>, <d e f>, <g h i>);\n# OUTPUT: «((a d g) (b e h) (c f i))␤»</code></pre></p><p>zip has an infix synonym, the Z operator.</p><p><pre><code>say <a b c> Z <d e f> Z <g h i>;                   # same output</code></pre></p><p>zip can provide input to a for loop :</p><p><pre><code>for <a b c> Z <d e f> Z <g h i> -> [$x,$y,$z] {say ($x,$y,$z).join(\",\")}\n# OUTPUT: «a,d,g␤\n# b,e,h␤\n# c,f,i␤»</code></pre></p><p>, or more succinctly:</p><p><pre><code>say .join(\",\") for zip <a b c>, <d e f>, <g h i>;  # same output</code></pre></p><p>Note, that if the input lists have an unequal number of elements, then zip terminates once the shortest input list is exhausted, and trailing elements from longer input lists are discarded.</p><p><pre><code>say <a b c> Z <d e f m n o p> Z <g h i>;\n# ((a d g) (b e h) (c f i))</code></pre></p><p>In cases where data clipping is possible, but undesired, then consider using roundrobin instead of zip.</p><p>The optional with parameter will additionally reduce the zipped lists. For example, the following multiplies corresponding elements together to return a single list of products.</p><p><pre><code>.say for zip <1 2 3>, [1, 2, 3], (1, 2, 3), :with(&infix:<*>);\n# OUTPUT: «1␤\n# 8␤\n# 27␤»</code></pre></p><p>The Z form can also be used to perform reduction by implicitly setting the with parameter with a metaoperator :</p><p><pre><code>.say for <1 2 3> Z* [1, 2, 3] Z* (1, 2, 3);        # same output</code></pre></p>","rotate":"<p>Defined as:</p><p><pre><code>multi sub    rotate(@list,  Int:D $n = 1 --> List:D)\nmulti method rotate(List:D: Int:D $n = 1 --> List:D)</code></pre></p><p>Returns the list rotated by $n elements.</p><p>Examples:</p><p><pre><code><a b c d e>.rotate(2);   # <c d e a b>\n<a b c d e>.rotate(-1);  # <e a b c d></code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>sub    kv($list --> Seq:D)\nmethod kv(List:D: --> Seq:D)</code></pre></p><p>Returns an interleaved sequence of indexes and values. For example</p><p><pre><code><a b c>.kv; # (0 a 1 b 2 c)</code></pre></p>","flatmap":"<p>Defined as:</p><p><pre><code>method flatmap(List:D: &code --> Seq:D)</code></pre></p><p>Like map iterates over the elements of the invocant list, feeding each element in turn to the code reference, and assembling the return values from these invocations in a result list.</p><p>The use of flatmap is strongly discouraged. Instead of .flatmap( ), please use .map( ).flat as it is clear when the .flat is called and is not confusing like .flatmap.</p><p>Unlike map it flattens non-itemized lists and arrays, so</p><p><pre><code>## flatmap\nmy @list = ('first1', ('second2', ('third3', 'third4'), 'second5'), 'first6');\nsay @list.flatmap({.reverse}).perl;\n# OUTPUT «(\"first1\", \"second5\", \"third3\", \"third4\", \"second2\", \"first6\").Seq␤»\n## map\nsay @list.map({\"$_ was a {.^name}\"}).perl;\n# OUTPUT «(\"first1 was a Str\", \"second2 third3 third4 second5 was a List\", \"first6 was a Str\").Seq␤»\n## .map .flat has the same output as .flatmap\nsay @list.map({.reverse}).flat.perl\n# OUTPUT «(\"first1\", \"second5\", \"third3\", \"third4\", \"second2\", \"first6\").Seq␤»</code></pre></p>"},"name":"List"},"X::Proc::Async::MustBeStarted":{"prefix":"<p><pre><code>class X::Proc::Async::MustBeStarted is Exception {}</code></pre></p><p>Several methods from Proc::Async expect that the external program has been spawned (by calling .start on it), including say, write, print and close-stdin. If one of those methods is called before .start was called, they throw an exception of type X::Proc::Async::MustBeStarted.</p><p><pre><code>Proc::Async.new('echo', :w).say(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::MustBeStarted: Process must be started first before calling 'say'␤»</code></pre></p>","defs":{},"name":"X::Proc::Async::MustBeStarted"},"X::IO::Dir":{"name":"X::IO::Dir","defs":{},"prefix":"<p><pre><code>class X::IO::Dir does X::IO is Exception { }\n</code></pre></p><p>Error class that is thrown when a dir call fails.</p><p>A typical error message is</p><p><pre><code>Failed to get the directory contents of '/tmp/': No such file or directory\n</code></pre></p>"},"X::Inheritance::NotComposed":{"name":"X::Inheritance::NotComposed","prefix":"<p><pre><code>class X::Inheritance::NotComposed is Exception {}</code></pre></p><p>When you try to inherit from a class that hasn't been composed, an exception of type X::Inheritance::NotComposed is thrown.</p><p>Usually this happens because it's not yet fully parsed, or that is stubbed:</p><p>For example</p><p><pre><code>class A { ... };    # literal ... for stubbing\nclass B is A { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n'B' cannot inherit from 'A' because 'A' isn't composed yet (maybe it is stubbed)\n</code></pre></p><p>The second common way to trigger this error is by trying to inherit from a class from within the class body.</p><p>For example</p><p><pre><code>class Outer {\n    class Inner is Outer {\n    }\n}\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n'Outer::Inner' cannot inherit from 'Outer' because 'Outer' isn't composed yet (maybe it is stubbed)\n</code></pre></p>","defs":{"child-name":"<p><pre><code>method child-name(X::Inheritance::NotComposed:D: --> Str:D)</code></pre></p><p>Returns the name of the type that tries to inherit.</p>"}},"CX::Last":{"prefix":"<p><pre><code>role CX::Last does X::Control { }</code></pre></p><p>A control exception that is thrown when last is called.</p>","defs":{},"name":"CX::Last"},"IO::Handle":{"defs":{"flush":"<p>Defined as:</p><p><pre><code>method flush(IO::Handle:D: --> True)</code></pre></p><p>Will flush the handle, writing any of the buffered data. Returns True on success; otherwise, fails with X::IO::Flush.</p><p><pre><code>given \"foo\".IO.open: :w {\n    LEAVE .close;\n    .print: 'something';\n    'foo'.IO.slurp.say; # (if the data got buffered) OUTPUT: «␤»\n    .flush;             # flush the handle\n    'foo'.IO.slurp.say; # OUTPUT: «something␤»\n}\n</code></pre></p>","t":"<p>Defined as:</p><p><pre><code>method t(IO::Handle:D: --> Bool:D)</code></pre></p><p>Returns True if the handle is opened to a TTY, False otherwise.</p>","path":"<p>Defined as:</p><p><pre><code>method path(IO::Handle:D:)</code></pre></p><p>For a handle opened on a file this returns the IO::Path that represents the file. For the standard I/O handles $*IN, $*OUT, and $*ERR it returns an IO::Special object.</p>","open":"<p>Defined as:</p><p><pre><code>method open(IO::Handle:D:\n    :$bin, :$enc, :$chomp, :$nl-in, Str:D :$nl-out,\n    Str :$mode,\n    :$r, :$w, :$a, :$x, :$update, :$rw, :$rx, :$ra,\n    :$create, :$append, :$truncate, :$exclusive,\n    :$out-buffer,\n    --> IO::Handle:D\n)\n</code></pre></p><p>Opens the handle in one of the modes. Fails with appropriate exception if the open fails.</p><p>See description of individual methods for the accepted values and behavior of :$chomp, :$nl-in, :$nl-out, and :$enc. The values for parameters default to the invocant's attributes and if any of them are provided, the attributes will be updated to the new values. Specify :$bin set to True instead of :$enc to indicate the handle should be opened in binary mode. Specifying undefined value as :$enc is equivalent to not specifying :$enc at all. Specifying both a defined encoding as :$enc and :$bin set to true will cause X::IO::BinaryAndEncoding exception to be thrown.</p><p>The open mode defaults to non-exclusive, read only (same as specifying :r) and can be controlled by a mix of the following arguments:</p><p><pre><code>:r      same as specifying   :mode<ro>  same as specifying nothing\n\n:w      same as specifying   :mode<wo>, :create, :truncate\n:a      same as specifying   :mode<wo>, :create, :append\n:x      same as specifying   :mode<wo>, :create, :exclusive\n\n:update same as specifying   :mode<rw>\n:rw     same as specifying   :mode<rw>, :create\n:ra     same as specifying   :mode<rw>, :create, :append\n:rx     same as specifying   :mode<rw>, :create, :exclusive\n</code></pre></p><p>Support for combinations of modes other than what is listed above is implementation-dependent and should be assumed unsupported. That is, specifying, for example, .open(:r :create) or .open(:mode<wo> :append :truncate) might work or might cause the Universe to implode, depending on a particular implementation. This applies to reads/writes to a handle opened in such unsupported modes as well.</p><p>The mode details are:</p><p><pre><code>:mode<ro>  means \"read only\"\n:mode<wo>  means \"write only\"\n:mode<rw>  means \"read and write\"\n\n:create    means the file will be created, if it does not exist\n:truncate  means the file will be emptied, if it exists\n:exclusive means .open will fail if the file already exists\n:append    means writes will be done at the end of file's current contents\n</code></pre></p><p>Attempts to open a directory, write to a handle opened in read-only mode or read from a handle opened in write-only mode, or using text-reading methods on a handle opened in binary mode will fail or throw.</p><p>In 6.c language, it's possible to open path '-', which will cause open to open (if closed) the $*IN handle if opening in read-only mode or to open the $*OUT handle if opening in write-only mode. All other modes in this case will result in exception being thrown.</p><p>As of 6.d language version, use path '-' is deprecated and it will be removed in future language versions entirely.</p><p>The :out-buffer controls output buffering and by default behaves as if it were Nil. See method out-buffer for details.</p><p>Note (Rakudo versions before 2017.09): Filehandles are NOT flushed or closed when they go out of scope. While they will get closed when garbage collected, garbage collection isn't guaranteed to get run. This means you should use an explicit close on handles opened for writing, to avoid data loss, and an explicit close is recommended on handles opened for reading as well, so that your program does not open too many files at the same time, triggering exceptions on further open calls.</p><p>Note (Rakudo versions 2017.09 and after): Open filehandles are automatically closed on program exit, but it is still highly recommended that you close opened handles explicitly.</p>","print":"<p>Defined as:</p><p><pre><code>multi method print(**@text --> True)\nmulti method print(Junction:D --> True)</code></pre></p><p>Writes the given @text to the handle, coercing any non-Str objects to Str by calling .Str method on them. Junction arguments autothread and the order of printed strings is not guaranteed. See write to write bytes.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open: :w;\n$fh.print: 'some text';\n$fh.close;\n</code></pre></p>","spurt":"<p>Defined as:</p><p><pre><code>multi method spurt(IO::Handle:D: Blob $data, :$close = False)\nmulti method spurt(IO::Handle:D: Cool $data, :$close = False)</code></pre></p><p>Writes all of the $data into the filehandle, closing it when finished, if $close is True. For Cool $data, will use the encoding the handle is set to use (IO::Handle.open or IO::Handle.encoding).</p><p>Behavior for spurting a Cool when the handle is in binary mode or spurting a Blob when the handle is NOT in binary mode is undefined.</p>","lock":"<p>Defined as:</p><p><pre><code>method lock(IO::Handle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)</code></pre></p><p>Places an advisory lock on the filehandle. If :$non-blocking is True will fail with X::IO::Lock if lock could not be obtained, otherwise will block until the lock can be placed. If :$shared is True will place a shared (read) lock, otherwise will place an exclusive (write) lock. On success, returns True; fails with X::IO::Lock if lock cannot be placed (e.g. when trying to place a shared lock on a filehandle opened in write mode or trying to place an exclusive lock on a filehandle opened in read mode).</p><p>You can use lock again to replace an existing lock with another one. To remove a lock, close the filehandle or use unlock.</p><p><pre><code># One program writes, the other reads, and thanks to locks either\n# will wait for the other to finish before proceeding to read/write\n\n# Writer\ngiven \"foo\".IO.open(:w) {\n    .lock;\n    .spurt: \"I ♥ Raku!\";\n    .close; # closing the handle unlocks it; we could also use `unlock` method for that\n}\n\n# Reader\ngiven \"foo\".IO.open {\n    .lock: :shared;\n    .slurp.say; # OUTPUT: «I ♥ Raku!␤»\n    .close;\n}\n</code></pre></p>","encoding":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::Handle:D: --> Str:D)\nmulti method encoding(IO::Handle:D: $enc --> Str:D)</code></pre></p><p>Returns a Str representing the encoding currently used by the handle, defaulting to \"utf8\". Nil indicates the filehandle is currently in binary mode. Specifying an optional positional $enc argument switches the encoding used by the handle; specify Nil as encoding to put the handle into binary mode.</p><p>The accepted values for encoding are case-insensitive. The available encodings vary by implementation and backend. On Rakudo MoarVM the following are supported:</p><p></p><p><pre><code>utf8\nutf16\nutf16le\nutf16be\nutf8-c8\niso-8859-1\nwindows-1251\nwindows-1252\nwindows-932\nascii\n</code></pre></p><p>The default encoding is utf8, which undergoes normalization into Unicode NFC (normalization form canonical). In some cases you may want to ensure no normalization is done; for this you can use utf8-c8. Before using utf8-c8 please read Unicode: Filehandles and I/O for more information on utf8-c8 and NFC.</p><p>As of Rakudo 2018.04 windows-932 is also supported which is a variant of ShiftJIS.</p><p>Implementation may choose to also provide support for aliases, e.g. Rakudo allows aliases latin-1 for iso-8859-1 encoding and dashed utf versions: utf-8 and utf-16.</p>","comb":"<p>Defined as:</p><p><pre><code>method comb(IO::Handle:D: Bool :$close, |args --> Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.comb does, taking the same arguments, closing the handle when done if $close is set to a true value. Implementations may slurp the file in its entirety when this method is called.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open;\nsay \"The file has {+$fh.comb: '♥', :close} ♥s in it\";\n</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>method gist(IO::Handle:D: --> Str:D)</code></pre></p><p>Returns a string containing information which .path, if any, the handle is created for and whether it is .opened.</p><p><pre><code>say IO::Handle.new; # IO::Handle<(Any)>(closed)\nsay \"foo\".IO.open;  # IO::Handle<\"foo\".IO>(opened)\n</code></pre></p>","close":"<p>Defined as:</p><p><pre><code>method close(IO::Handle:D: --> Bool:D)\nmulti sub close(IO::Handle $fh)</code></pre></p><p>Closes an open filehandle. It's not an error to call close on an already-closed filehandle. Returns True on success. If you close one of the standard filehandles (by default: $*IN, $*OUT, or $*ERR), that is any handle with native-descriptor 2 or lower, you won't be able to re-open such a handle.</p><p>It's a common idiom to use LEAVE phaser for closing the handles, which ensures the handle is closed regardless of how the block is left.</p><p><pre><code>if $do-stuff-with-the-file {\n    my $fh = open \"path-to-file\";\n    LEAVE close $fh;\n    # ... do stuff with the file\n}\n\nsub do-stuff-with-the-file (IO $path-to-file)\n  my $fh = $path-to-file.open;\n\n  # stick a `try` on it, since this will get run even when the sub is\n  # called with wrong arguments, in which case the `$fh` will be an `Any`\n  LEAVE try close $fh;\n\n  # ... do stuff with the file\n}\n\ngiven \"foo/bar\".IO.open(:w) {\n    .spurt: \"I ♥ Raku!\";\n    .close;\n}\n</code></pre></p><p>Note: unlike some other languages, Raku does not use reference counting, and so the filehandles are NOT closed when they go out of scope. While they will get closed when garbage collected, garbage collection isn't guaranteed to get run. This means you must use an explicit close on handles opened for writing, to avoid data loss, and an explicit close is recommended on handles opened for reading as well, so that your program does not open too many files at the same time, triggering exceptions on further open calls.</p><p>Note several methods allow for providing :close argument, to close the handle after the operation invoked by the method completes. As a simpler alternative, the IO::Path type provides many reading and writing methods that let you work with files without dealing with filehandles directly.</p>","Str":"<p>Returns the value of .path, coerced to Str.</p><p><pre><code>say \"foo\".IO.open.path; # OUTPUT: «\"foo\".IO␤»\n</code></pre></p>","opened":"<p>Defined as:</p><p><pre><code>method opened(IO::Handle:D: --> Bool:D)</code></pre></p><p>Returns True if the handle is open, False otherwise.</p>","tell":"<p>Defined as:</p><p><pre><code>method tell(IO::Handle:D: --> Int:D)</code></pre></p><p>Return the current position of the file pointer in bytes.</p>","write":"<p>Defined as:</p><p><pre><code>method write(IO::Handle:D: Blob:D $buf --> True)</code></pre></p><p>Writes $buf to the filehandle. This method can be called even when the handle is not in binary mode.</p><p>  </p>","out-buffer":"<p>Defined as:</p><p><pre><code>method out-buffer(--> Int:D) is rw</code></pre></p><p>Controls output buffering and can be set via an argument to open. Takes an int as the size of the buffer to use (zero is acceptable). Can take a Bool: True means to use default, implementation-defined buffer size; False means to disable buffering (equivalent to using 0 as buffer size).</p><p>Lastly, can take a Nil to enable TTY-based buffering control: if the handle is a TTY, the buffering is disabled, otherwise, default, implementation-defined buffer size is used.</p><p>See flush to write out data currently in the buffer. Changing buffer size flushes the filehandle.</p><p><pre><code>given 'foo'.IO.open: :w, :1000out-buffer {\n    .say: 'Hello world!'; # buffered\n    .out-buffer = 42;       # buffer resized; previous print flushed\n    .say: 'And goodbye';\n    .close; # closing the handle flushes the buffer\n}\n</code></pre></p>","words":"<p>Defined as:</p><p><pre><code>multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\nmulti method words(IO::Handle:D: $limit = Inf, :$close --> Seq:D)</code></pre></p><p>Similar to Str.words, separates the handle's stream on contiguous chunks of whitespace (as defined by Unicode) and returns a Seq of the resultant \"words.\" Takes an optional $limit argument that can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf), to indicate only up-to $limit words must be returned. If Bool :$close named argument is set to True, will automatically close the handle when the returned Seq is exhausted. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my %dict := bag $*IN.words;\nsay \"Most common words: \", %dict.sort(-*.value).head: 5;\n</code></pre></p><p>NOTE: implementations may read more data than necessary when a call to .words is made. That is, $handle.words(2) may read more data than two \"words\" worth of data and subsequent calls to read methods might not read from the place right after the two fetched words. After a call to .words, the file position should be treated as undefined.</p>","printf":"<p>Defined as:</p><p><pre><code>multi method printf(IO::Handle:D: Cool $format, *@args)</code></pre></p><p>Formats a string based on the given format and arguments and .prints the result into the filehandle. See sub sprintf for details on acceptable format directives.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = open 'path/to/file', :w;\n$fh.printf: \"The value is %d\\n\", 32;\n$fh.close;\n</code></pre></p>","print-nl":"<p>Defined as:</p><p><pre><code>method print-nl(IO::Handle:D: --> True)</code></pre></p><p>Writes the value of $.nl-out attribute into the handle. This attribute, by default, is ␤, but see the page on newline for the rules it follows in different platforms and environments.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open: :w, :nl-out(\"\\r\\n\");\n$fh.print: \"some text\";\n$fh.print-nl; # prints \\r\\n\n$fh.close;\n</code></pre></p>","eof":"<p>Defined as:</p><p><pre><code>method eof(IO::Handle:D: --> Bool:D)</code></pre></p><p>Non-blocking. Returns True if the read operations have exhausted the contents of the handle. For seekable handles, this means current position is at or beyond the end of file and seeking an exhausted handle back into the file's contents will result in eof returning False again.</p><p>On non-seekable handles and handles opened to zero-size files (including special files in /proc/), EOF won't be set until a read operation fails to read any bytes. For example, in this code, the first read consumes all of the data, but it's only until the second read that reads nothing would the EOF on a TTY handle be set:</p><p><pre><code>$ echo \"x\" | perl6 -e 'with $*IN { .read: 10000; .eof.say; .read: 10; .eof.say }'\nFalse\nTrue\n</code></pre></p>","chomp":"<p>Defined as:</p><p><pre><code>has $.chomp is rw = True</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to True. Takes a Bool specifying whether the line separators (as defined by .nl-in) should be removed from content when using .get or .lines methods.</p>","EOF":"<p>Defined as:</p><p><pre><code>method EOF(IO::Handle:D: --> Bool:D)</code></pre></p><p>Indicates whether \"end of file\" has been reached for the data source of the handle; i.e. no more data can be obtained by calling .READ method. Note that this is not the same as eof method, which will return True only if .EOF returns True and all the decoder buffers, if any were used by the handle, are also empty. See .READ for an example implementation.</p>","READ":"<p>Defined as:</p><p><pre><code>method READ(IO::Handle:D: Int:D \\bytes --> Buf:D)</code></pre></p><p>Called whenever a read operation is performed on the handle. Receives the number of bytes requested to read. Returns a Buf with those bytes which can be used to either fill the decoder buffer or returned from reading methods directly. The result is allowed to have fewer than the requested number of bytes, including no bytes at all.</p><p>If you provide your own .READ, you very likely need to provide your own .EOF as well, for all the features to behave correctly.</p><p>The compiler may call .EOF method any number of times during a read operation to ascertain whether a call to .READ should be made. More bytes than necessary to satisfy a read operation may be requested from .READ, in which case the extra data may be buffered by the IO::Handle or the decoder it's using, to fulfill any subsequent reading operations, without necessarily having to make another .READ call.</p><p><pre><code>class IO::Store is IO::Handle {\n    has @.lines = [];\n\n    submethod TWEAK {\n      self.encoding: 'utf8'; # set up encoder/decoder\n    }\n\n    method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n      @!lines.push: data;\n      True;\n    }\n\n    method whole() {\n      my Buf $everything = Buf.new();\n      for @!lines -> $b {\n        $everything ~= $b;\n      }\n      return $everything;\n    }\n\n    method READ(IO::Handle:D: Int:D \\bytes --> Buf:D) {\n      my Buf $everything := self.whole();\n      return $everything;\n    }\n\n    method EOF {\n      my $everything = self.whole();\n      !$everything;\n    }\n}\n\nmy $store := IO::Store.new();\n\n$store.print( $_ ) for <one two three>;\nsay $store.read(3).decode; # OUTPUT «one␤»\nsay $store.read(3).decode; # OUTPUT «two␤»\n</code></pre></p><p>In this case, we have programmed the two READ and EOF methods, as well as WRITE, which stores every line in an element in an array. The read method actually calls READ, returning 3 bytes, which correspond to the three characters in the first two elements. Please note that it's the IO::Handle base class the one that is taking care of cursor, since READ just provides a handle into the whole content of the object; the base class will READ 1024 * 1024 bytes at a time. If your object is planned to hold an amount of bytes bigger than that, you will have to handle an internal cursor yourself. That is why in this example we don't actually use the bytes argument.</p>","nl-out":"<p>Defined as:</p><p><pre><code>has Str:D $.nl-out is rw = \"\\n\";</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to \"\\n\". Takes a Str specifying output line ending for this handle, to be used by methods .put and .say.</p><p><pre><code>with 'test'.IO {\n    given .open: :w {\n        .put: 42;\n        .nl-out = 'foo';\n        .put: 42;\n        .close;\n    }\n    .slurp.perl.say; # OUTPUT: «\"42\\n42foo\"»\n}\n</code></pre></p>","native-descriptor":"<p>Defined as:</p><p><pre><code>method native-descriptor()</code></pre></p><p>This returns a value that the operating system would understand as a \"file descriptor\" and is suitable for passing to a native function that requires a file descriptor as an argument such as fcntl or ioctl.</p>","lines":"<p>Defined as:</p><p><pre><code>sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\nmethod lines(IO::Handle:D:               $limit = Inf, :$close --> Seq:D)</code></pre></p><p>Return a Seq each element of which is a line from the handle (that is chunks delineated by .nl-in). If the handle's .chomp attribute is set to True, then characters specified by .nl-in will be stripped from each line.</p><p>Reads up to $limit lines, where $limit can be a non-negative Int, Inf, or Whatever (which is interpreted to mean Inf). If :$close is set to True, will close the handle when the file ends or $limit is reached. Subroutine form defaults to $*ARGFILES, if no handle is provided.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p>NOTE: the lines are read lazily, so ensure the returned Seq is either fully reified or is no longer needed when you close the handle or attempt to use any other method that changes the file position.</p><p><pre><code>say \"The file contains \",\n  '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n  \" lines that mention Perl\";\n# OUTPUT: «The file contains 72 lines that mention Perl␤»\n</code></pre></p>","readchars":"<p>Defined as:</p><p><pre><code>method readchars(IO::Handle:D: Int(Cool:D) $chars = 65536 --> Str:D)</code></pre></p><p>Reading chars; reads and returns up to $chars chars (graphemes) from the filehandle. $chars defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $file = 'foo'.IO).spurt: 'I ♥ Perl';\ngiven $file.open {\n    say .readchars: 5; # OUTPUT: «I ♥ P␤»\n    .close;\n}\n</code></pre></p>","getc":"<p>Defined as:</p><p><pre><code>method getc(IO::Handle:D: --> Str:D)\nmulti sub getc (IO::Handle $fh = $*ARGFILES --> Str:D)</code></pre></p><p>Reads a single character from the input stream. Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown. The subroutine form defaults to $*ARGFILES if no handle is given. Returns Nil, if no more input is available, otherwise operation will block, waiting for at least one character to be available; these caveats apply:</p>","WRITE":"<p>Defined as:</p><p><pre><code>method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D)</code></pre></p><p>Called whenever a write operation is performed on the handle. Always receives the data as a Blob, even if a textual writing method has been called.</p><p><pre><code>class IO::Store is IO::Handle {\n    has @.lines = [];\n\n    submethod TWEAK {\n        self.encoding: 'utf8'; # set up encoder/decoder\n    }\n\n    method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n        @!lines.push: data.decode();\n        True;\n    }\n\n    method gist() {\n        return @!lines.join(\"\\n\" );\n    }\n}\nmy $store = IO::Store.new();\nmy $output = $PROCESS::OUT;\n$PROCESS::OUT = $store;\n.say for <one two three>;\n$PROCESS::OUT = $output;\nsay $store.lines(); # OUTPUT «[one␤ two␤ three␤]»\n</code></pre></p><p>In this example we are creating a simple WRITE redirection which stores anything written to the filehandle to an array. Se need to save the standard output first, which we do in $output, and then everything that is printed or said (through say) gets stored in the defined IO::Store class. Two things should be taken into account in this class. By default, IO::Handles are in binary mode, so we need to TWEAK the objects if we want them to work with text. Second, a WRITE operation should return True if successful. It will fail if it does not.</p>","IO":"<p>Defined as:</p><p><pre><code>method IO(IO::Handle:D:)</code></pre></p><p>Alias for .path</p>","read":"<p>Defined as:</p><p><pre><code>method read(IO::Handle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)</code></pre></p><p>Binary reading; reads and returns up to $bytes bytes from the filehandle. $bytes defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). This method can be called even when the handle is not in binary mode.</p><p><pre><code>(my $file = 'foo'.IO).spurt: 'I ♥ Perl';\ngiven $file.open {\n    say .read: 6; # OUTPUT: «Buf[uint8]:0x<49 20 e2 99 a5 20>␤»\n    .close;\n}\n</code></pre></p>","unlock":"<p>Defined as:</p><p><pre><code>method unlock(IO::Handle:D: --> True)</code></pre></p><p>Removes a lock from the filehandle.</p>","get":"<p>Defined as:</p><p><pre><code>method get(IO::Handle:D: --> Str:D)\nmulti sub get (IO::Handle $fh = $*ARGFILES --> Str:D)</code></pre></p><p>Reads a single line of input from the handle, removing the trailing newline characters (as set by .nl-in) if the handle's .chomp attribute is set to True. Returns Nil, if no more input is available. The subroutine form defaults to $*ARGFILES if no handle is given.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>$*IN.get.say;              # Read one line from the standard input\n\nmy $fh = open 'filename';\n$fh.get.say;               # Read one line from a file\n$fh.close;\n\nsay get;                   # Read one line from $*ARGFILES\n</code></pre></p>","put":"<p>Defined as:</p><p><pre><code>multi method put(**@text --> True)\nmulti method put(Junction:D --> True)</code></pre></p><p>Writes the given @text to the handle, coercing any non-Str objects to Str by calling .Str method on them, and appending the value of .nl-out at the end. Junction arguments autothread and the order of printed strings is not guaranteed.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open: :w;\n$fh.put: 'some text';\n$fh.close;\n</code></pre></p>","nl-in":"<p>Defined as:</p><p><pre><code>method nl-in(--> Str:D) is rw</code></pre></p><p>One of the attributes that can be set via .new or open. Defaults to [\"\\x0A\", \"\\r\\n\"]. Takes either a Str or Array of Str specifying input line ending(s) for this handle. If .chomp attribute is set to True, will strip these endings in routines that chomp, such as get and lines.</p><p><pre><code>with 'test'.IO {\n    .spurt: '1foo2bar3foo'; # write some data into our test file\n    my $fh will leave {.close} = .open; # can also set .nl-in via .open arg\n    $fh.nl-in = [<foo bar>]; # set two possible line endings to use;\n    $fh.lines.say; # OUTPUT: (\"1\", \"2\", \"3\").Seq\n}\n</code></pre></p>","Supply":"<p>Defined as:</p><p><pre><code>multi method Supply(IO::Handle:D: :$size = 65536)</code></pre></p><p>Returns a Supply that will emit the contents of the handle in chunks. The chunks will be Buf if the handle is in binary mode or, if it isn't, Str decoded using same encoding as IO::Handle.encoding.</p><p>The size of the chunks is determined by the optional :size named parameter and 65536 bytes in binary mode or 65536 characters in non-binary mode.</p><p><pre><code>\"foo\".IO.open(:bin).Supply(:size<10>).tap: *.perl.say;\n# OUTPUT:\n# Buf[uint8].new(73,32,226,153,165,32,80,101,114,108)\n# Buf[uint8].new(32,54,33,10)\n\n\"foo\".IO.open.Supply(:size<10>).tap: *.perl.say;\n# OUTPUT:\n# \"I ♥ Perl\"\n# \" 6!\\n\"\n</code></pre></p>","seek":"<p>Defined as:</p><p><pre><code>method seek(IO::Handle:D: Int:D $offset, SeekType:D $whence --> True)</code></pre></p><p>Move the file pointer (that is, the position at which any subsequent read or write operations will begin) to the byte position specified by $offset relative to the location specified by $whence which may be one of:</p>* <p>SeekFromBeginning: The beginning of the file.</p><br>* <p>SeekFromCurrent: The current position in the file.</p><br>* <p>SeekFromEnd: The end of the file. Please note that you need to specify a negative offset if you want to position before the end of the file.</p><br>","slurp":"<p>Defined as:</p><p><pre><code>method slurp(IO::Handle:D: :$close, :$bin)</code></pre></p><p>Returns all the content from the current file pointer to the end. If the invocant is in binary mode or if $bin is set to True, will return a Buf, otherwise will decode the content using invocant's current .encoding and return a Str.</p><p>If :$close is set to True, will close the handle when finished reading.</p><p>Note: On Rakudo this method was introduced with release 2017.04; $bin arg was added in 2017.10.</p>","slurp-rest":"<p>Defined as:</p><p><pre><code>multi method slurp-rest(IO::Handle:D: :$bin! --> Buf)\nmulti method slurp-rest(IO::Handle:D: :$enc --> Str)</code></pre></p><p>DEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not use it for new code, use .slurp method instead.</p><p>Returns the remaining content of the file from the current file position (which may have been set by previous reads or by seek.) If the adverb :bin is provided a Buf will be returned; otherwise the return will be a Str with the optional encoding :enc.</p>","say":"<p>Defined as:</p><p><pre><code>multi method say(IO::Handle:D: **@text --> True)</code></pre></p><p>This method is identical to put except that it stringifies its arguments by calling .gist instead of .Str.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = open 'path/to/file', :w;\n$fh.say(Complex.new(3, 4));        # RESULT: «3+4i\\n»\n$fh.close;\n</code></pre></p>","split":"<p>Defined as:</p><p><pre><code>method split(IO::Handle:D: :$close, |c)</code></pre></p><p>Slurps the handle's content and calls Str.split on it, forwarding any of the given arguments. If :$close named parameter is set to True, will close the invocant after slurping.</p><p>Attempting to call this method when the handle is in binary mode will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>my $fh = 'path/to/file'.IO.open;\n$fh.split: '♥', :close; # Returns file content split on ♥\n</code></pre></p>"},"prefix":"<p><pre><code>class IO::Handle { }</code></pre></p><p>Instances of IO::Handle encapsulate an handle to manipulate input/output resources. Usually there is no need to create directly an IO::Handle instance, since it will be done by other roles and methods. For instance, an IO::Path object provides an open method that returns an IO::Handle:</p><p><pre><code>my $fh = '/tmp/log.txt'.IO.open;\nsay $fh.^name; # OUTPUT: IO::Handle</code></pre></p><p>The first line is pretty much equivalent to the following piece of code:</p><p><pre><code>my $fh = IO::Handle.new( :path( '/tmp/log.txt'.IO.path ) ).open;</code></pre></p>","name":"IO::Handle"},"X::Method::Private::Unqualified":{"prefix":"<p><pre><code>class X::Method::Private::Unqualified does X::Comp { }</code></pre></p><p>Compile time error thrown when a private method call on anything but self is not fully qualified.</p><p>For example</p><p><pre><code>1!priv\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPrivate method call to priv must be fully qualified with the package containing the method\n</code></pre></p>","defs":{},"name":"X::Method::Private::Unqualified"},"X::Role::Initialization":{"defs":{},"prefix":"<p><pre><code>class X::Role::Initialization is Exception { }</code></pre></p><p>Thrown when the SomeRole($init) syntax is used, but SomeRole does not have exactly one public attribute.</p><p>For example:</p><p><pre><code>role R { }; \"D2\" but R(2)\nCATCH { default { put .^name, ': ', .Str } }\n# OUTPUT: «X::Role::Initialization: Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'R'␤»\n</code></pre></p>","name":"X::Role::Initialization"},"Pod::Block::Para":{"name":"Pod::Block::Para","defs":{},"prefix":"<p><pre><code>class Pod::Block::Para is Pod::Block { }</code></pre></p><p>Class for a Pod paragraph.</p>"},"IO::Path::Unix":{"name":"IO::Path::Unix","prefix":"<p><pre><code>class IO::Path::Unix is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Unix in the $.SPEC attribute.</p>","defs":{"new":"<p>Same as IO::Path.new, except :$SPEC cannot be set and defaults to IO::Spec::Unix, regardless of the operating system the code is being run on.</p>"}},"Buf":{"defs":{"unshift":"<p><pre><code>method unshift()</code></pre></p><p>Adds elements at the beginning of the buffer</p><p><pre><code>$bú.unshift( 0 );\nsay $bú.perl; # OUTPUT: «Buf.new(0,1,1,2,3,5,8,13,21,34,55,89)»\n</code></pre></p>","write-int64":"<p>Defined as:</p><p><pre><code>method write-int64(buf8: uint $pos, Int:D $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a signed 64-bit integer value at the given position with the given endianness.</p>","pop":"<p><pre><code>method pop()</code></pre></p><p>Extracts the last element of the buffer</p><p><pre><code>say $bú.pop(); # OUTPUT: «8»\nsay $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5)»\n</code></pre></p>","write-num32":"<p>Defined as:</p><p><pre><code>method write-num32(buf8: uint $pos, num32 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a native num32 IEEE floating point value at the given position with the given endianness.</p>","write-uint16":"<p>Defined as:</p><p><pre><code>method write-uint16(buf8: uint $pos, uint16 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes an unsigned 16-bit integer value at the given position with the given endianness.</p>","write-uint8":"<p>Defined as:</p><p><pre><code>method write-uint8(buf8: uint $pos, uint8 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes an unsigned 8-bit integer value at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","write-int8":"<p>Defined as:</p><p><pre><code>method write-int8(buf8: uint $pos, int8 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a signed 8-bit integer value at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","splice":"<p><pre><code>method splice( Buf:D: $start = 0, $elems?, *@replacement --> Buf)</code></pre></p><p>Substitutes elements of the buffer by other elements</p><p><pre><code>$bú.splice:  0, 3, <3 2 1>;\nsay $bú.perl; # OUTPUT: «Buf.new(3,2,1,2,3,5,8,13,21,34,55,89)»\n</code></pre></p>","write-uint64":"<p>Defined as:</p><p><pre><code>method write-uint64(buf8: uint $pos, uint64 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes an unsigned 64-bit integer value at the given position with the given endianness.</p>","write-num64":"<p>Defined as:</p><p><pre><code>method write-num64(buf8: uint $pos, num64 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a native num64 IEEE floating point value at the given position with the given endianness.</p>","list":"<p>Defined as:</p><p><pre><code>multi method list(Buf:D:)</code></pre></p><p>Returns a Seq of codepoints.</p><p><pre><code>say Buf.new(122,105,112,205).list; # OUTPUT: «(122 105 112 205)␤»</code></pre></p>","push":"<p><pre><code>method push( $elems )</code></pre></p><p>Adds elements at the end of the buffer</p><p><pre><code>my @φ =  1,1, * + * … ∞;\nmy $bú = Buf.new( @φ[^5] );\n$bú.push( @φ[5] );\nsay $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8)»</code></pre></p>","write-uint128":"<p>Defined as:</p><p><pre><code>method write-uint128(buf8: uint $pos, UInt:D $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes an unsigned 128-bit integer value at the given position with the given endianness.</p>","write-ubits":"<p>Defined as:</p><p><pre><code>method write-ubits(buf8: uint $pos, uint $bits, UInt:D $value --> buf8:D)</code></pre></p><p>Writes an unsigned integer value to the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian.</p>","write-int128":"<p>Defined as:</p><p><pre><code>method write-int128(buf8: uint $pos, Int:D $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a signed 128-bit integer value at the given position with the given endianness.</p>","write-int32":"<p>Defined as:</p><p><pre><code>method write-int32(buf8: uint $pos, int32 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a signed 32-bit integer value at the given position with the given endianness.</p>","write-uint32":"<p>Defined as:</p><p><pre><code>method write-uint32(buf8: uint $pos, uint32 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes an unsigned 32-bit integer value at the given position with the given endianness.</p>","subbuf-rw":"<p>Declared as</p><p><pre><code>multi sub subbuf-rw(Buf:D \\b) is rw\nmulti sub subbuf-rw(Buf:D \\b, Int() $from) is rw\nmulti sub subbuf-rw(Buf:D \\b, $from, $elems) is rw</code></pre></p><p>Returns a writable reference to a part of a buffer. Invokes the subbuf-rw method on the specified Buf:</p><p><pre><code>my Buf $b .= new(1,2,3);\nsubbuf-rw($b,2,1) = Buf.new(42);\nsay $b.perl;   # OUTPUT: «Buf.new(1,2,42)␤»</code></pre></p>","write-int16":"<p>Defined as:</p><p><pre><code>method write-int16(buf8: uint $pos, int16 $value, $endian = NativeEndian --> buf8:D)</code></pre></p><p>Writes a signed 16-bit integer value at the given position with the given endianness.</p>","write-bits":"<p>Defined as:</p><p><pre><code>method write-bits(buf8:D: uint $pos, uint $bits, Int:D $value --> Nil)</code></pre></p><p>Writes a signed integer value for the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian. Always returns Nil.</p>","append":"<p><pre><code>method append( $elems )</code></pre></p><p>Appends at the end of the buffer</p><p><pre><code>$bú.append( @φ[5..10] );\nsay $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8,13,21,34,55,89)»\n</code></pre></p>","reallocate":"<p><pre><code>method reallocate($elems)</code></pre></p><p>Change the number of elements of the Buf, returning the changed Buf. The size of Buf will be adapted depending on the number of $elems specified: if it is smaller than the actual size of the Buf the resulting Buf will be shrunk down, otherwise it will be enlarged to fit the number of $elems. In the case the Buf is enlarged, newly created items will be assigned a Virtual Machine specific null value, therefore you should not rely upon their value since it could be inconsistent across different virtual machines.</p><p><pre><code>my Buf $b .= new(^10);\n$b.reallocate(5);\nsay $b.perl;  # OUTPUT: «Buf.new(0,1,2,3,4)␤»\n\n$b = Buf.new( 1..3 );\n$b.reallocate( 10 );\n$b.perl.say; # OUTPUT: «Buf.new(1,2,3,0,0,0,0,0,0,0)␤»</code></pre></p>","shift":"<p><pre><code>method shift()</code></pre></p><p>Takes out the first element of the buffer</p><p><pre><code>$bú.shift();\nsay $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8,13,21,34,55,89)»\n</code></pre></p>","prepend":"<p><pre><code>method prepend( $elems )</code></pre></p><p>Adds elements at the beginning of the buffer</p><p><pre><code>$bú.prepend( 0 );\nsay $bú.perl; # OUTPUT: «Buf.new(0,1,1,2,3,5,8,13,21,34,55,89)»\n</code></pre></p>"},"prefix":"<p><pre><code>role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T){ ... }</code></pre></p><p>A Buf does the role of a mutable sequence of (usually unsigned) integers.</p><p><pre><code>my $b = Buf.new(1, 2, 3);\n$b[1] = 42;</code></pre></p><p>However, it's a parameterized type, and you can instantiate with several integer types:</p><p><pre><code>my $b = Buf[int32].new( 3, -3, 0xff32, -44)\n# OUTPUT: «Buf[int32]:0x<03 -3 FF32 -2C>»\n</code></pre></p><p>By default, Buf uses 8-bit unsigned integers, that is, it is equivalent to Buf[uint8]. Some other types of Bufs which are used often get their own class name.</p><p></p><table class='sections'><tr></tr>\n<tr><td>buf8</tr><td>Buf[uint8]</tr></tr>\n<tr><td>buf16</tr><td>Buf[uint16]</tr></tr>\n<tr><td>buf32</tr><td>Buf[uint32]</tr></tr>\n<tr><td>buf64</tr><td>Buf[uint64]</tr></tr>\n</table><p>You can use these in pretty much the same way you would with Buf:</p><p><pre><code>my $buf = buf8.new(3,6, 254);\nsay $buf; # OUTPUT: «Buf[uint8]:0x<03 06 fe>␤»</code></pre></p><p>Plus there are some object methods, like encode that might return a buf8 in some cases where it is the best representation for a particular encoding.</p>","name":"Buf"},"Pod::Block::Table":{"prefix":"<p><pre><code>class Pod::Block::Table is Pod::Block { }</code></pre></p><p>Class for a table in a Pod document.</p>","defs":{"caption":"<p><pre><code>method caption(--> Str:D)</code></pre></p><p>Returns the associated caption of the table.</p>"},"name":"Pod::Block::Table"},"Encoding":{"name":"Encoding","prefix":"<p><pre><code>role Encoding { ... }</code></pre></p><p>The Encoding role is implemented by classes that provide a character encoding, such as ASCII or UTF-8. Besides being used by the built-in character encodings, it may also be implemented by users to provide new encodings. Instances of objects doing this role are typically obtained using Encoding::Registry. For a list of supported encodings, see IO::Handle.</p><p>All methods provided by this role are stubs; they should be implemented by consumers of the role.</p>","defs":{"decoder":"<p><pre><code>method decoder(*%options --> Encoding::Decoder)</code></pre></p><p>Should get a character decoder instance for this encoding, configured with the provided options. Options vary by encoding. The built-in encodings all support translate-nl, which if True will translate \\r\\n into \\n while decoding.</p>","name":"<p><pre><code>method name(--> Str)</code></pre></p><p>Abstract method that would return the primary name of the encoding.</p>","alternative-names":"<p><pre><code>method alternative-names()</code></pre></p><p>Abstract methods that should get a list of alternative names for the encoding.</p>"}},"Pod::Defn":{"name":"Pod::Defn","defs":{},"prefix":"<p><pre><code>class Pod::Defn is Pod::Block { }</code></pre></p><p>Class for definition lists in a Pod document.</p>"},"X::Parameter::Twigil":{"name":"X::Parameter::Twigil","prefix":"<p><pre><code>class X::Parameter::Twigil does X::Comp { }</code></pre></p><p>Thrown when a parameter in a signature has a twigil that it may not have. Only !, . and * as twigils are allowed.</p><p>Example:</p><p><pre><code>sub f($=foo) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nIn signature parameter $=foo, it is illegal to use the = twigil\n</code></pre></p>","defs":{"parameter":"<p>The name of the offensive parameter ($=foo in the example above)</p>"}},"UInt":{"name":"UInt","prefix":"<p>The UInt is defined as a subset of Int:</p><p><pre><code>my subset UInt of Int where {not .defined or $_ >= 0};\n</code></pre></p><p>Consequently, it cannot be instantiated or subclassed; however, that shouldn't affect most normal uses.</p><p>Some examples of its behavior and uses:</p><p><pre><code>say UInt ~~ Int; # OUTPUT: «True␤»\nmy UInt $u = 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff; # 64-bit unsigned value\nsay $u.base(16); # OUTPUT: «FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF␤» (32 digits)\n++$u;\nsay $u.base(16); # OUTPUT: «100000000000000000000000000000000␤» (33 digits!)\nmy Int $i = $u;\nsay $i.base(16); # same as above\nsay $u.^name;    # OUTPUT: «Int␤» - UInt is a subset, so the type is still Int.\nsay $i.^name;    # OUTPUT: «Int␤»\n# Difference in assignment\nmy UInt $a = 5;  # nothing wrong\nmy UInt $b = -5; # Exception about failed type check\nmy UInt $c = 0;\n--$c;            # Exception again\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $b; expected UInt but got Int (-5)␤»\n\n# Non-assignment operations are fine\nmy UInt $d = 0;\nsay $d - 3;      # OUTPUT: «-3␤»</code></pre></p>","defs":{}},"Pod::Block::Comment":{"name":"Pod::Block::Comment","defs":{},"prefix":"<p><pre><code>class Pod::Block::Comment is Pod::Block { }</code></pre></p><p>Class for a Pod comment.</p>"},"X::Attribute::Required":{"prefix":"<p><pre><code>class X::Attribute::NoPackage does X::MOP { }</code></pre></p><p>Compile time error thrown when a required attribute is not assigned when creating an object.</p><p>For example</p><p><pre><code>my class Uses-required {\n    has $.req is required\n};\nmy $object = Uses-required.new()\n</code></pre></p><p>Dies with</p><p><pre><code>OUTPUT: «(exit code 1) The attribute '$!req' is required, but you did not provide a value for it.␤»\n</code></pre></p>","defs":{"name":"<p><pre><code>method name(--> Str:D)</code></pre></p><p>Returns the name of the attribute.</p>"},"name":"X::Attribute::Required"},"Regex":{"prefix":"<p><pre><code>class Regex is Method { }</code></pre></p><p>A regex is a kind of pattern that describes a set of strings. The process of finding out whether a given string is in the set is called matching. The result of such a matching is a Match object, which evaluates to True in boolean context if the string is in the set.</p><p>A regex is typically constructed by a regex literal</p><p><pre><code>rx/ ^ab /;      # describes all strings starting with 'ab'\n/ ^ ab /;       # same\nrx/ \\d ** 2/;   # describes all strings containing at least two digits</code></pre></p><p> A named regex can be defined with the regex declarator followed by its definition in curly braces. Since any regex does Callable introspection requires referencing via &-sigil.</p><p><pre><code>my regex R { \\N };\nsay &R.^name; # OUTPUT: «Regex␤»</code></pre></p><p>To match a string against a regex, you can use the smartmatch operator:</p><p><pre><code>my $match = 'abc' ~~ rx/ ^ab /;\nsay $match.Bool;                # OUTPUT: «True␤»\nsay $match.orig;                # OUTPUT: «abc␤»\nsay $match.Str;                 # OUTPUT: «ab␤»\nsay $match.from;                # OUTPUT: «0␤»\nsay $match.to;                  # OUTPUT: «2␤»</code></pre></p><p>Or you can evaluate the regex in boolean context, in which case it matches against the $_ variable</p><p><pre><code>$_ = 'abc';\nif / ^ab / {\n    say '\"abc\" begins with \"ab\"';\n}\nelse {\n    say 'This is a weird alternative Universe';\n}</code></pre></p>","defs":{"ACCEPTS":"<p><pre><code>multi method ACCEPTS(Regex:D: Mu --> Match:D)\nmulti method ACCEPTS(Regex:D: @)\nmulti method ACCEPTS(Regex:D: %)</code></pre></p><p>Matches the regex against the argument passed in. If the argument is Positional, it returns the first successful match of any list item. If the argument is Associative, it returns the first successful match of any key. Otherwise it interprets the argument as a Str and matches against it.</p><p>In the case of Positional and Associative matches, Nil is returned on failure.</p>"},"name":"Regex"},"X::Undeclared":{"name":"X::Undeclared","prefix":"<p><pre><code>class X::Undeclared does X::Comp {}</code></pre></p><p>Thrown when the compiler encounters a symbol that has not been declared, but needs to be.</p><p>Example</p><p><pre><code>$x;\n</code></pre></p><p>results in</p><p><pre><code>===SORRY!===\nVariable $x is not declared\n</code></pre></p>","defs":{"symbol":"<p>Returns the name of the undeclared symbol</p>"}},"X::ControlFlow":{"name":"X::ControlFlow","prefix":"<p><pre><code>class X::ControlFlow is Exception { }</code></pre></p><p>Thrown when a control flow construct (such as next or redo) is called outside the dynamic scope of an enclosing construct that is supposed to catch them.</p><p>For example</p><p><pre><code>last;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::ControlFlow: last without loop construct␤»</code></pre></p>","defs":{"illegal":"<p><pre><code>method illegal returns Str:D</code></pre></p><p>Returns the name of the control flow command that was called.</p>"}},"Metamodel::CurriedRoleHOW":{"name":"Metamodel::CurriedRoleHOW","prefix":"<p><pre><code>class Metamodel::CurriedRoleHOW\n    does Metamodel::Naming\n    does Metamodel::TypePretense\n    does Metamodel::RolePunning {}</code></pre></p><p>Sometimes, we see references to roles that provide parameters but do not fully resolve them. For example, in:</p><p><pre><code>class C does R[Type] { }\n</code></pre></p><p>We need to represent R[T], but we cannot yet fully specialize the role because we don't have the first parameter at hand. We may also run into the issue where we have things like:</p><p><pre><code>sub foo(R[T] $x) { ... }\nif $x ~~ R[T] { ... }\n</code></pre></p><p>Where we clearly want to talk about a partial parameterization of a role and actually want to do so in a way distinct from a particular instantiation of it. This metaobject represents those \"partial types\" as both a way to curry on your way to a full specialization, but also as a way to do type-checking or punning.</p><p>This class will show up in parameterized roles. For instance:</p><p><pre><code>role Zipi[::T] {\n    method zape { \"Uses \" ~ T.^name };\n}\nrole Zipi[::T, ::Y] {\n    method zape { \"Uses \" ~ T.^name ~ \" and \" ~ Y.^name };\n}\nfor Zipi[Int], Zipi[Int,Str] -> $role {\n    say $role.HOW;\n    say $role.new().zape;\n}\n# OUTPUT:\n# Perl6::Metamodel::CurriedRoleHOW.new\n# Uses Int\n# Perl6::Metamodel::CurriedRoleHOW.new\n# Uses Int and Str\n</code></pre></p><p>Since there are several variants of Zipi, providing a parameter curries it, but it's still up to the compiler to find out the actual realization taking into account the ParametricRoleGroup, so these (partially instantiated) roles show up as Metamodel::CurriedRoleHOW as shown in the example; even if there's a single parameter an instantiated role will also be of the same type:</p><p><pre><code>role Zape[::T] {};\nsay Zape[Int].HOW; #: «Perl6::Metamodel::CurriedRoleHOW.new␤»</code></pre></p><p>Note: As most of the Metamodel classes, this class is here mainly for illustration purposes and it's not intended for the final user to instantiate.</p>","defs":{}},"Numeric":{"defs":{"log":"<p><pre><code>multi sub    log(Numeric:D, Numeric $base = e --> Numeric:D)\nmulti method log(Numeric:D: Numeric $base = e --> Numeric:D)</code></pre></p><p>Calculates the logarithm to base $base. Defaults to the natural logarithm. Returns NaN if $base is negative. Throws an exception if $base is 1.</p>","Num":"<p><pre><code>method Num(Numeric:D: --> Num:D)</code></pre></p><p>If this Numeric is equivalent to a Real, return that Real as a Num as accurately as is possible. Fail with X::Numeric::Real otherwise.</p>","roots":"<p><pre><code>multi method roots(Numeric:D: Int:D $n --> Positional)</code></pre></p><p>Returns a list of the $n complex roots, which evaluate to the original number when raised to the $nth power.</p>","Int":"<p><pre><code>method Int(Numeric:D: --> Int:D)</code></pre></p><p>If this Numeric is equivalent to a Real, return the equivalent of calling truncate on that Real to get an Int. Fail with X::Numeric::Real otherwise.</p>","log10":"<p><pre><code>multi sub    log10(Numeric:D  --> Numeric:D)\nmulti method log10(Numeric:D: --> Numeric:D)</code></pre></p><p>Calculates the logarithm to base 10. Returns NaN for negative arguments and -Inf for 0.</p>","Bool":"<p><pre><code>multi method Bool(Numeric:D:)</code></pre></p><p>Returns False if the number is equivalent to zero, and True otherwise.</p>","narrow":"<p><pre><code>method narrow(Numeric:D --> Numeric:D)</code></pre></p><p>Returns the number converted to the narrowest type that can hold it without loss of precision.</p><p><pre><code>say (4.0 + 0i).narrow.perl;     # OUTPUT: «4␤»\nsay (4.0 + 0i).narrow.^name;    # OUTPUT: «Int␤»</code></pre></p>","Rat":"<p><pre><code>method Rat(Numeric:D: Real $epsilon = 1.0e-6 --> Rat:D)</code></pre></p><p>If this Numeric is equivalent to a Real, return a Rat which is within $epsilon of that Real's value. Fail with X::Numeric::Real otherwise.</p>","succ":"<p><pre><code>method succ(Numeric:D:)</code></pre></p><p>Returns the number incremented by one (successor).</p>","conj":"<p><pre><code>multi method conj(Numeric:D --> Numeric:D)</code></pre></p><p>Returns the complex conjugate of the number. Returns the number itself for real numbers.</p>","sqrt":"<p><pre><code>multi sub    sqrt(Numeric:D --> Numeric:D)\nmulti method sqrt(Numeric:D --> Numeric:D)</code></pre></p><p>Returns a square root of the number. For real numbers the positive square root is returned.</p><p>On negative real numbers, sqrt returns NaN rather than a complex number, in order to not confuse people who are not familiar with complex arithmetic. If you want to calculate complex square roots, coerce to Complex first, or use the roots method.</p>","ACCEPTS":"<p><pre><code>multi method ACCEPTS(Numeric:D: $other)</code></pre></p><p>Returns True if $other can be coerced to Numeric and is numerically equal to the invocant (or both evaluate to NaN).</p>","exp":"<p><pre><code>multi sub    exp(Numeric:D, Numeric:D $base = e --> Numeric:D)\nmulti method exp(Numeric:D: Numeric:D $base = e --> Numeric:D)</code></pre></p><p>Returns $base to the power of the number, or e to the power of the number if called without a second argument.</p>","abs":"<p><pre><code>multi sub    abs(Numeric:D  --> Real:D)\nmulti method abs(Numeric:D: --> Real:D)</code></pre></p><p>Returns the absolute value of the number.</p>","Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(Numeric:D: --> Numeric:D)\nmulti method Numeric(Numeric:U: --> Numeric:D)</code></pre></p><p>The :D variant simply returns the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns self.new.</p>"},"prefix":"<p><pre><code>role Numeric { ... }</code></pre></p><p>Common role for numbers and types that can act as numbers.</p><p>Binary numeric operations return an object of the \"wider\" type:</p><p><pre><code>Int         narrowest\nRat\nFatRat\nNum\nComplex     widest\n</code></pre></p><p>So for example the product of a Rat and an Int is a Rat.</p><p>Unary operations that in pure math usually return an irrational number generally return Num in Raku.</p>","name":"Numeric"},"X::IO::Copy":{"name":"X::IO::Copy","prefix":"<p><pre><code>class X::IO::Copy does X::IO is Exception { }\n</code></pre></p><p>Error class for failed file copy operations. A typical error message is</p><p><pre><code>Failed to copy 'source' to 'destination': permission denied\n</code></pre></p>","defs":{"from":"<p>Returns the source of the failed copy operation</p>"}},"X::Proc::Async::TapBeforeSpawn":{"name":"X::Proc::Async::TapBeforeSpawn","defs":{},"prefix":"<p><pre><code>class X::Proc::Async::TapBeforeSpawn is Exception {}</code></pre></p><p>If the stdout or stderr methods of Proc::Async are called after the program has been started, an exception of type X::Proc::Async::TapBeforeSpawn is thrown.</p><p><pre><code>my $proc = Proc::Async.new(\"echo\", \"foo\");\n$proc.start;\n$proc.stdout.tap(&print);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::TapBeforeSpawn: To avoid data races, you must tap stdout before running the process␤»</code></pre></p><p>The right way is the reverse order</p><p><pre><code>my $proc = Proc::Async.new(\"echo\", \"foo\");\n$proc.stdout.tap(&print);\nawait $proc.start;</code></pre></p>"},"X::DateTime::TimezoneClash":{"name":"X::DateTime::TimezoneClash","defs":{},"prefix":"<p><pre><code>class X::DateTime::TimezoneClash does X::Temporal is Exception { }\n</code></pre></p><p>This exception is thrown when code tries to create a DateTime object specifying both a time zone offset and the named argument :timezone.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200');                   # works\nsay DateTime.new('2015-12-24T12:23:00', timezone => 7200);      # works\nsay DateTime.new('2015-12-24T12:23:00+0200', timezone => 7200); # exception\n</code></pre></p>"},"X::Placeholder::Block":{"prefix":"<p><pre><code>class X::Placeholder::Block does X::Comp {}</code></pre></p><p>Thrown when a placeholder variable is used in a block that does not allow a signature.</p><p>For example</p><p><pre><code>class A { $^foo }\n</code></pre></p><p>dies with</p><p><pre><code>Placeholder variable $^foo may not be used here because the surrounding block takes no signature\n</code></pre></p>","defs":{},"name":"X::Placeholder::Block"},"X::Numeric::Real":{"defs":{"target":"<p><pre><code>method target()</code></pre></p><p>Returns the type to which the coercion was attempted.</p>","source":"<p><pre><code>method source(--> Numeric:D)</code></pre></p><p>Returns the number that failed to coerce to Real.</p>"},"prefix":"<p><pre><code>class X::Numeric::Real is Exception { }</code></pre></p><p>Occurs when an attempt to coerce a Numeric to a Real, Num, Int or Rat fails (due to a number with a nonzero imaginary part, for instance).</p><p>For example</p><p><pre><code>say (1+2i).Int;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Numeric::Real: Can not convert 1+2i to Int: imaginary part not zero␤»</code></pre></p>","name":"X::Numeric::Real"},"Metamodel::MultipleInheritance":{"name":"Metamodel::MultipleInheritance","defs":{"parents":"<p><pre><code>method parents(Metamodel::MultipleInheritance:D: $obj, :$all, :$tree)</code></pre></p><p>Returns the list of parent classes. By default it stops at Cool, Any or Mu, which you can suppress by supplying the :all adverb. With :tree, a nested list is returned.</p><p><pre><code>class D { };\nclass C1 is D { };\nclass C2 is D { };\nclass B is C1 is C2 { };\nclass A is B { };\n\nsay A.^parents(:all).perl;\n# OUTPUT: «(B, C1, C2, D, Any, Mu)␤»\nsay A.^parents(:all, :tree).perl;\n# OUTPUT: «[B, ([C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]])]␤»</code></pre></p>","hides":"<p><pre><code>method hides(Metamodel::MultipleInheritance:D: $obj)</code></pre></p><p>Returns a list of all hidden parent classes.</p>","hidden":"<p><pre><code>method hidden(Metamodel::MultipleInheritance:D: $obj)</code></pre></p><p>Returns a true value if (and only if) the class is marked with the trait is hidden.</p>","add_parent":"<p><pre><code>method add_parent(Metamodel::MultipleInheritance:D: $Obj, $parent, :$hides)</code></pre></p><p>Adds $parent as a parent type. If $hides is set to a true value, the parent type is added as a hidden parent.</p><p>$parent must be a fully composed typed. Otherwise an exception of type X::Inheritance::NotComposed is thrown.</p>"},"prefix":"<p><pre><code>role Metamodel::MultipleInheritance {}</code></pre></p><p>Classes, roles and grammars can have parent classes, that is, classes to which method lookups fall back to, and to whose type the child class conforms to.</p><p>This role implements the capability of having zero, one or more parent (or super) classes.</p><p>In addition, it supports the notion of hidden classes, whose methods are excluded from the normal dispatching chain, so that for example nextsame ignores it.</p><p>This can come in two flavors: methods from a class marked as is hidden are generally excluded from dispatching chains, and class A hides B adds B as a parent class to A, but hides it from the method resolution order, so that mro_unhidden skips it.</p>"},"Endian":{"name":"Endian","prefix":"<p><pre><code>enum Endian <NativeEndian LittleEndian BigEndian>;</code></pre></p><p>    An enum for indicating endianness, specifically with methods on blob8 and buf8. Consists of NativeEndian, LittleEndian and BigEndian.</p>","defs":{}},"Telemetry::Instrument::Thread":{"name":"Telemetry::Instrument::Thread","prefix":"<p><pre><code>class Telemetry::Instrument::Thread { }</code></pre></p><p>Note:  This class is a Rakudo-specific feature and not standard Raku.</p><p>Objects of this class are generally not created by themselves, but rather through making a snapshot.</p><p>This class provides the following data points (in alphabetical order):</p>* <p>tad</p><br><p>The number of threads that ended with an exception (threads-aborted).</p>* <p>tcd</p><br><p>The number of threads that completed without any problem (threads-completed).</p>* <p>thid</p><br><p>Highest OS thread ID seen (thread-highest-id).</p>* <p>tjd</p><br><p>The number of threads that were joined (threads-joined).</p>* <p>tsd</p><br><p>The number of threads that were started (threads-started).</p>* <p>tyd</p><br><p>The number of times a thread was yielded (threads-yielded).</p>","defs":{}},"CurrentThreadScheduler":{"name":"CurrentThreadScheduler","prefix":"<p><pre><code>class CurrentThreadScheduler does Scheduler {}\n</code></pre></p><p>CurrentThreadScheduler executes tasks on the current threads. This means that method cue blocks until the code has finished executing.</p>","defs":{}},"Sub":{"prefix":"<p><pre><code>class Sub is Routine { }</code></pre></p><p>A type for subroutines and operators. Subs are created with the sub declarator keyword followed by an optional identifier. This short tutorial explains how operators are declared. For details of a sub's parameter list, see Signature.</p><p>Note that subs that go by the same name as coercers will not take precedence over them. Use the &-sigil to call them.</p><p><pre><code>sub Int(Str $s){'what?'};\nsay [Int, Int('42'),&Int('42')];\n# OUTPUT: «[(Int) 42 what?]␤»</code></pre></p><p> Subs can be nested and scoped with my and our, whereby my is the default. A sub declared with my cannot be reached from any outer scope. An our scoped sub will not redefine a sub of the same name in the outer scope. Any sub can be accessed via a closure from any outer scope. For instance, in this example</p><p><pre><code>sub can-be-seener( $whatever ) {\n  my sub can-be-seen ( $objection ) {\n    return $whatever but $objection;\n  }\n  return &can-be-seen\n}\n\nmy $objectioner = can-be-seener( \"Really?\");\nsay $objectioner(42).Int; # OUTPUT: «42␤»</code></pre></p><p>$objectioner will contain the can-be-seen subroutine, even if it has been declared in another scope; calling it with 42 will return \"Really?\" with the number 42 mixed in, as shown in the last sentence.</p>","defs":{},"name":"Sub"},"X::Mixin::NotComposable":{"name":"X::Mixin::NotComposable","defs":{"target":"<p><pre><code>method target()</code></pre></p><p>Returns the target of the failed mixin operation.</p>"},"prefix":"<p><pre><code>class X::Mixin::NotComposable is Exception { }</code></pre></p><p>Thrown when a mixin with infix does or but is done with a composer that cannot be used for mixin.</p><p>For example</p><p><pre><code>class A { };\n1 but A;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Mixin::NotComposable: Cannot mix in non-composable type A into object of type Int␤»</code></pre></p><p>The compile-time equivalent of this error is X::Composition::NotComposable</p>"},"CX::Return":{"name":"CX::Return","prefix":"<p><pre><code>role CX::Next does X::Control { }</code></pre></p><p>A control exception to be used when return is called from within a sub.</p>","defs":{}},"utf8":{"name":"utf8","defs":{},"prefix":"<p><pre><code>class utf8 does Blob[uint8] is repr('VMArray') {}</code></pre></p><p>A utf8 is a subtype of Blob which is specifically uint8 data for holding UTF-8 encoded text.</p><p><pre><code>my utf8 $b = \"hello\".encode;\nsay $b[1].fmt(\"0x%X\"); # OUTPUT: «0x65␤»</code></pre></p>"},"X::Method::NotFound":{"name":"X::Method::NotFound","prefix":"<p><pre><code>class X::Method::NotFound is Exception {}</code></pre></p><p>Thrown when the user tries to call a method that isn't there.</p><p>For example</p><p><pre><code>1.no-such\n</code></pre></p><p>throws</p><p><pre><code>No such method 'no-such' for invocant of type 'Int'\n</code></pre></p>","defs":{"method":"<p><pre><code>method method(--> Str:D)</code></pre></p><p>Returns the method name that was invoked.</p>","private":"<p><pre><code>method private(--> Bool:D)</code></pre></p><p>Returns True for private methods, and False for public methods.</p>","typename":"<p><pre><code>method typename(--> Str:D)</code></pre></p><p>Returns the name of the invocant type.</p>"}},"X::NYI":{"prefix":"<p><pre><code>class X::NYI is Exception { }</code></pre></p><p>Error class for unimplemented features. NYI stands for Not Yet Implemented.</p><p>If a Raku compiler is not yet feature complete, it may throw an X::NYI exception when a program uses a feature that it can detect and is somehow specified is not yet implemented.</p><p>A full-featured Raku compiler must not throw such exceptions, but still provide the X::NYI class for compatibility reasons.</p><p>A typical error message is</p><p><pre><code>HyperWhatever is not yet implemented. Sorry.\n</code></pre></p>","defs":{"new":"<p><pre><code>method new( :$feature, :$did-you-mean, :$workaround)</code></pre></p><p>This is the default constructor for X:NYI which can take three parameters with obvious meanings.</p><p><pre><code>class Nothing {\n    method ventured( $sub, **@args) {\n        X::NYI.new( feature => &?ROUTINE.name,\n                    did-you-mean => \"gained\",\n                    workaround => \"Implement it yourself\" ).throw;\n    }\n}\n\nmy $nothing = Nothing.new;\n$nothing.ventured(\"Nothing\", \"Gained\");\n</code></pre></p><p>In this case, we are throwing an exception that indicates that the ventured routine has not been implemented; we use the generic &?ROUTINE.name to not tie the exception to the method name in case it is changed later on. This code effectively throws this exception</p><p><pre><code># OUTPUT:\n# ventured not yet implemented. Sorry.\n# Did you mean: gained?\n# Workaround: Implement it yourself\n#   in method ventured at NYI.p6 line 6\n#   in block <unit> at NYI.p6 line 14\n</code></pre></p><p>Using the exception properties, it composes the message that we see there.</p>","did-you-mean":"<p>Returns a Str indicating the optional feature that is already implemented.</p>","feature":"<p>Returns a Str describing the missing feature.</p>","workaround":"<p>It helpfully shows a possible workaround for the missing feature, if it's been declared.</p>"},"name":"X::NYI"},"Tap":{"name":"Tap","prefix":"<p><pre><code>class Tap {}</code></pre></p><p>A Tap is a subscription to a Supply.</p><p><pre><code>my $s = Supplier.new;\nmy $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n    -> $v { say \"the value is $v\" },\n    done    => { say \"Supply is done\" },\n    quit    => -> $ex { say \"Supply finished with error $ex\" },\n);\n\n# later\n$tap.close;</code></pre></p>","defs":{}},"Routine":{"prefix":"<p><pre><code>class Routine is Block { }</code></pre></p><p>A Routine is a code object meant for larger unities of code than Block. Routine is the common superclass for Sub (and therefore operators) and Method, the two primary code objects for code reuse.</p><p>Routines serve as a scope limiter for return (i.e. a return returns from the innermost outer Routine).</p><p>The routine level is also the one at which multiness (multi subs and multi methods) are handled. Subroutines can also be declared anon. See the documentation on the anon declarator for more information.</p>","defs":{"cando":"<p><pre><code>method cando(Capture $c)</code></pre></p><p>Returns a possibly-empty list of candidates that can be called with the given Capture, ordered by narrowest candidate first. For methods, the first element of the Capture needs to be the invocant:</p><p><pre><code>.signature.say for \"foo\".^can(\"comb\")[0].cando: \\(Cool, \"o\");\n# OUTPUT: «(Cool $: Str $matcher, $limit = Inf, *%_)␤»</code></pre></p>","wrap":"<p><pre><code>method wrap(Routine:D: &wrapper)</code></pre></p><p>Wraps (i.e. in-place modifies) the routine. That means a call to this routine first calls &wrapper, which then can (but doesn't have to) call the original routine with the callsame, callwith, nextsame and nextwith dispatchers. The return value from the routine is also the return value from the wrapper.</p><p>wrap returns an instance of a private class called Routine::WrapHandle, which you can pass to unwrap to restore the original routine.</p>","package":"<p><pre><code>method package(Routine:D:)</code></pre></p><p>Returns the package in which the routine is defined.</p>","multi":"<p><pre><code>method multi(Routine:D: --> Bool:D)</code></pre></p><p>Returns True if the routine is a multi sub or method. Note that the name of a multi sub refers to its proto and this method would return false if called on it. It needs to be called on the candidates themselves:</p><p><pre><code>multi foo ($, $) {};\nsay &foo.multi;             # OUTPUT: «False␤»\nsay &foo.candidates».multi; # OUTPUT: «(True)␤»</code></pre></p>","unwrap":"<p><pre><code>method unwrap($wraphandle)</code></pre></p><p>Restores the original routine after it has been wrapped with wrap. While the signature allows any type to be passed, only the Routine::WrapHandle type returned from wrap can usefully be.</p>","candidates":"<p><pre><code>method candidates(Routine:D: --> Positional:D)</code></pre></p><p>Returns a list of multi candidates, or a one-element list with itself if it's not a multi</p>","yada":"<p><pre><code>method yada(Routine:D: --> Bool:D)</code></pre></p><p>Returns True if the routine is a stub</p><p><pre><code>say (sub f() { ... }).yada;      # OUTPUT: «True␤»\nsay (sub g() { 1;  }).yada;      # OUTPUT: «False␤»</code></pre></p>","name":"<p><pre><code>method name(Routine:D: --> Str:D)</code></pre></p><p>Returns the name of the sub or method.</p>"},"name":"Routine"},"X::Syntax::Variable::Twigil":{"name":"X::Syntax::Variable::Twigil","defs":{"twigil":"<p><pre><code>method twigil(--> Str:D)</code></pre></p><p>Returns the twigil that was illegally used</p>"},"prefix":"<p><pre><code>class X::Syntax::Variable::Twigil does X::Syntax { }</code></pre></p><p>Syntax error thrown when a variable with a twigil is used in an incompatible declaration.</p><p>For example</p><p><pre><code>my $!foo;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use ! twigil on my variable\n</code></pre></p>"},"X::Proc::Async":{"prefix":"<p><pre><code>role X::Proc::Async is Exception { ... }</code></pre></p><p>All exceptions thrown by Proc::Async do this common role.</p>","defs":{},"name":"X::Proc::Async"},"Complex":{"name":"Complex","defs":{"round":"<p>Defined as:</p><p><pre><code>multi method round(Complex:D: --> Complex:D)\nmulti method round(Complex:D: Real() $scale --> Complex:D)</code></pre></p><p>With no arguments, rounds both the real and imaginary parts to the nearest integer and returns a new Complex number. If $scale is given, rounds both parts of the invocant to the nearest multiple of $scale. Uses the same algorithm as Real.round on each part of the number.</p><p><pre><code>say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\nsay (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»</code></pre></p>","abs":"<p>Defined as:</p><p><pre><code>method abs(Complex:D: --> Num:D)\nmulti sub abs(Complex:D $z --> Num:D)</code></pre></p><p>Returns the absolute value of the invocant (or the argument in sub form). For a given complex number $z the absolute value |$z| is defined as sqrt($z.re * $z.re + $z.im * $z.im).</p><p><pre><code>say (3+4i).abs;                 # OUTPUT: «5␤»\n                                # sqrt(3*3 + 4*4) == 5</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>multi method new(Real $re, Real $im --> Complex:D)</code></pre></p><p>Creates a new Complex object from real and imaginary parts.</p><p><pre><code>my $complex = Complex.new(1, 1);\nsay $complex;    # OUTPUT: «1+1i␤»</code></pre></p><p>When created without arguments, both parts are considered to be zero.</p><p><pre><code>say Complex.new; # OUTPUT: «0+0i␤»</code></pre></p>","im":"<p>Defined as:</p><p><pre><code>method im(Complex:D: --> Real:D)</code></pre></p><p>Returns the imaginary part of the complex number.</p><p><pre><code>say (3+5i).im;    # OUTPUT: «5␤»</code></pre></p>","re":"<p>Defined as:</p><p><pre><code>method re(Complex:D: --> Real:D)</code></pre></p><p>Returns the real part of the complex number.</p><p><pre><code>say (3+5i).re;    # OUTPUT: «3␤»</code></pre></p>","floor":"<p>Defined as:</p><p><pre><code>method floor(Complex:D: --> Complex:D)</code></pre></p><p>Returns self.re.floor + self.im.floor. That is, each of the real and imaginary parts is rounded to the highest integer not greater than the value of that part.</p><p><pre><code>say (1.2-3.8i).floor;           # OUTPUT: «1-4i␤»</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>method gist(Complex:D: --> Str:D)</code></pre></p><p>Returns a string representation of the form \"1+2i\", without internal spaces. (Str coercion also returns this.)</p><p><pre><code>say (1-4i).gist;                # OUTPUT: «1-4i␤»</code></pre></p>","isNaN":"<p>Defined as:</p><p><pre><code>method isNaN(Complex:D: --> Bool:D)</code></pre></p><p>Returns true if the real or imaginary part is NaN (not a number).</p><p><pre><code>say (NaN+5i).isNaN; # OUTPUT: «True␤»\nsay (7+5i).isNaN;   # OUTPUT: «False␤»</code></pre></p>","reals":"<p>Defined as:</p><p><pre><code>method reals(Complex:D: --> Positional:D)</code></pre></p><p>Returns a two-element list containing the real and imaginary parts for this value.</p><p><pre><code>say (3+5i).reals;    # OUTPUT: «(3 5)␤»</code></pre></p>","perl":"<p>Defined as:</p><p><pre><code>method perl(Complex:D: --> Str:D)</code></pre></p><p>Returns an implementation-specific string that produces an equivalent object when given to EVAL.</p><p><pre><code>say (1-3i).perl;                # OUTPUT: «<1-3i>␤»</code></pre></p>","&postfix:<i>":"<p>Adding a trailing i to a number literal makes it a Complex, for example:</p><p><pre><code>say 2i;     # same as Complex.new(0, 2);\nsay 1-2e3i; # same as Complex.new(1, -2e3);</code></pre></p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(Complex:D: --> Num:D)\nmulti method Real(Complex:U: --> Num:D)</code></pre></p><p>Coerces the invocant to Num. If the imaginary part isn't approximately zero, coercion fails with X::Numeric::Real.</p><p>The :D variant returns the result of that coercion. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0e0.</p>","ceiling":"<p>Defined as:</p><p><pre><code>method ceiling(Complex:D: --> Complex:D)</code></pre></p><p>Returns self.re.ceiling + self.im.ceiling. That is, each of the real and imaginary parts is rounded to the lowest integer not less than the value of that part.</p><p><pre><code>say (1.2-3.8i).ceiling;         # OUTPUT: «2-3i␤»</code></pre></p>","conj":"<p>Defined as:</p><p><pre><code>method conj(Complex:D: --> Complex:D)</code></pre></p><p>Returns the complex conjugate of the invocant (that is, the number with the sign of the imaginary part negated).</p><p><pre><code>say (1-4i).conj;                # OUTPUT: «1+4i␤»</code></pre></p>","sqrt":"<p>Defined as:</p><p><pre><code>method sqrt(Complex:D: --> Complex:D)</code></pre></p><p>Returns the complex square root of the invocant, i.e. the root where the real part is ≥ 0 and the imaginary part has the same sign as the imaginary part of the invocant.</p><p><pre><code>say (3-4i).sqrt;                # OUTPUT: «2-1i␤»\nsay (-3+4i).sqrt;               # OUTPUT: «1+2i␤»</code></pre></p>","truncate":"<p>Defined as:</p><p><pre><code>method truncate(Complex:D: --> Complex:D)</code></pre></p><p>Removes the fractional part of both the real and imaginary parts of the number, using Real.truncate, and returns the result as a new Complex.</p><p><pre><code>say (1.2-3.8i).truncate;        # OUTPUT: «1-3i␤»</code></pre></p>","polar":"<p>Defined as:</p><p><pre><code>method polar(Complex:D: --> Positional:D)</code></pre></p><p>Returns a two-element list of the polar coordinates for this value, i.e. magnitude and angle in radians.</p><p><pre><code>say (10+7i).polar; # OUTPUT: «(12.2065556157337 0.610725964389209)␤»</code></pre></p>"},"prefix":"<p><pre><code>class Complex is Cool does Numeric {}</code></pre></p><p>Represents a number in the complex plane.</p><p>Complex objects are immutable.</p>"},"Metamodel::ParametricRoleHOW":{"prefix":"<p><pre><code>class Metamodel::ParametricRoleHOW\n    does Metamodel::Naming\n    does Metamodel::Documenting\n    does Metamodel::Versioning\n    does Metamodel::MethodContainer\n    does Metamodel::PrivateMethodContainer\n    does Metamodel::MultiMethodContainer\n    does Metamodel::AttributeContainer\n    does Metamodel::RoleContainer\n    does Metamodel::MultipleInheritance\n    does Metamodel::Stashing\n    does Metamodel::TypePretense\n    does Metamodel::RolePunning\n    does Metamodel::ArrayType {}</code></pre></p><p>A Metamodel::ParametricRoleHOW represents a non-instantiated, possibly parameterized, role:</p><p><pre><code>(role Zape[::T] {}).HOW.say;# OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n(role Zape {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n</code></pre></p><p>As usual, .new_type will create a new object of this class.</p><p><pre><code>my \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zape\", group => \"Zape\");\nsay zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n</code></pre></p><p>The extra group argument will need to be used to integrate it in a parametric role group, which will need to be defined in advance.</p><p>Note: As most of the Metamodel classes, this one is here mainly for illustration purposes and it's not intended for the final user to instantiate, unless their intention is really to create a parametric role group.</p>","defs":{},"name":"Metamodel::ParametricRoleHOW"},"MixHash":{"name":"MixHash","prefix":"<p><pre><code>class MixHash does Mixy { }</code></pre></p><p>A MixHash is a mutable mix, meaning a collection of distinct elements in no particular order that each have a real-number weight assigned to them. (For immutable mixes, see Mix instead.)</p><p>Objects/values of any type are allowed as mix elements. Within a MixHash, items that would compare positively with the === operator are considered the same element, with a combined weight.</p><p><pre><code>my $recipe = (butter => 0.22, sugar => 0.1,\n              flour => 0.275, sugar => 0.02).MixHash;\n\nsay $recipe.elems;      # OUTPUT: «3␤»\nsay $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\nsay $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\nsay $recipe.total;      # OUTPUT: «0.615␤»\n</code></pre></p><p>MixHashes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding numeric weight for keys that are elements of the mix, and 0 for keys that aren't. It can also be used to modify weights; Setting a weight to 0 automatically removes that element from the mix, and setting a weight to a non-zero number adds that element if it didn't already exist:</p><p><pre><code>my $recipe = (butter => 0.22, sugar => 0.1,\n              flour => 0.275, sugar => 0.02).MixHash;\n\nsay $recipe<butter>;     # OUTPUT: «0.22␤»\nsay $recipe<sugar>;      # OUTPUT: «0.12␤»\nsay $recipe<chocolate>;  # OUTPUT: «0␤»\n\n$recipe<butter> = 0;\n$recipe<chocolate> = 0.30;\nsay $recipe.pairs;       # OUTPUT: «\"sugar\" => 0.12 \"flour\" => 0.275 \"chocolate\" => 0.3␤»\n</code></pre></p>","defs":{"Bag":"<p>Defined as:</p><p><pre><code>method Bag (--> Bag:D)</code></pre></p><p>Coerces the MixHash to a Bag. The weights are converted to Int, which means the number of keys in the resulting Bag can be fewer than in the original MixHash, if any of the weights are negative or truncate to zero.</p>","BagHash":"<p>Defined as:</p><p><pre><code>method BagHash (--> BagHash:D)</code></pre></p><p>Coerces the MixHash to a BagHash. The weights are converted to Int, which means the number of keys in the resulting BagHash can be fewer than in the original MixHash, if any of the weights are negative or truncate to zero.</p>"}},"Stringy":{"prefix":"<p><pre><code>role Stringy { ... }</code></pre></p><p>Common role for string types (such as Str).</p>","defs":{},"name":"Stringy"},"X::Eval::NoSuchLang":{"defs":{},"prefix":"<p><pre><code>class X::Eval::NoSuchLang is Exception { }</code></pre></p><p>Error thrown when EVAL($str, :$lang) specifies a language that the compiler does not know how to handle.</p><p>For example</p><p><pre><code>EVAL 'boo', lang => \"bar\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Eval::NoSuchLang: No compiler available for language 'bar'␤»</code></pre></p>","name":"X::Eval::NoSuchLang"},"Duration":{"defs":{},"prefix":"<p><pre><code>class Duration is Cool does Real { }</code></pre></p><p>A Duration represents a length of time in atomic seconds, with fractions. Like an Instant, it is epoch-agnostic.</p><p>Durations can be subtracted from or added to Instants to yield another, new Instant. Subtracting one Instant from another yields a Duration. A Duration can also result from mathematical operations between two Durations when it makes sense (namely, the addition, subtraction, or modulus of two Durations). It can also be added, subtracted or divided modulo Real numbers.</p><p>The type of object returned for other numeric operations is currently unspecified.</p>","name":"Duration"},"Promise":{"defs":{"kept":"<p><pre><code>multi method kept(Promise:U: \\result = True --> Promise:D)</code></pre></p><p>Returns a new promise that is already kept, either with the given value, or with the default value True.</p>","break":"<p><pre><code>multi method break(Promise:D: \\cause = False)</code></pre></p><p>Breaks a promise, optionally setting the cause. If no cause is passed, the cause will be False.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\n$p.break('sorry');\nsay $p.status;          # OUTPUT: «Broken␤»\nsay $p.cause;           # OUTPUT: «sorry␤»</code></pre></p>","Supply":"<p><pre><code>method Supply(Promise:D:)</code></pre></p><p>Returns a Supply that will emit the result of the Promise being Kept or quit with the cause if the Promise is Broken.</p>","Bool":"<p><pre><code>multi method Bool(Promise:D:)</code></pre></p><p>Returns True for a kept or broken promise, and False for one in state Planned.</p>","at":"<p><pre><code>method at(Promise:U: $at, :$scheduler = $*SCHEDULER --> Promise:D)</code></pre></p><p>Creates a new Promise that will be kept $at the given time—which is given as an Instant or equivalent Numeric—or as soon as possible after it.</p><p><pre><code>my $p = Promise.at(now + 2).then({ say \"2 seconds later\" });\n# do other stuff here\n\nawait $p;   # wait here until the 2 seconds are over</code></pre></p><p>If the given time is in the past, it will be treated as now (i.e. keeping the returned Promise right away).</p><p>Please note that situations like these are often more clearly handled with a react and whenever block.</p>","vow":"<p><pre><code>my class Vow {\n    has Promise $.promise;\n    method keep() { ... }\n    method break() { ... }\n}\nmethod vow(Promise:D: --> Vow:D)\n</code></pre></p><p>Returns an object that holds the sole authority over keeping or breaking a promise. Calling keep or break on a promise that has vow taken throws an exception of type X::Promise::Vowed.</p><p><pre><code>my $p   = Promise.new;\nmy $vow = $p.vow;\n$vow.keep($p);\nsay $p.status;          # OUTPUT: «Kept␤»</code></pre></p>","then":"<p><pre><code>method then(Promise:D: &code)</code></pre></p><p>Schedules a piece of code to be run after the invocant has been kept or broken, and returns a new promise for this computation. In other words, creates a chained promise.</p><p><pre><code>my $timer = Promise.in(2);\nmy $after = $timer.then({ say \"2 seconds are over!\"; 'result' });\nsay $after.result;  # 2 seconds are over\n                    # result</code></pre></p>","start":"<p><pre><code>method start(Promise:U: &code, :$scheduler = $*SCHEDULER --> Promise:D)</code></pre></p><p>Creates a new Promise that runs the given code object. The promise will be kept when the code terminates normally, or broken if it throws an exception. The return value or exception can be inspected with the result method.</p><p>The scheduler that handles this promise can be passed as a named argument.</p><p>There is also a statement prefix start that provides syntactic sugar for this method:</p><p><pre><code># these two are equivalent:\nmy $p1 = Promise.start({ ;#`( do something here ) });\nmy $p2 = start { ;#`( do something here ) };</code></pre></p><p>As of the 6.d version of the language, start statement prefix used in sink context will automatically attach an exceptions handler. If an exception occurs in the given code, it will be printed and the program will then exit, like if it were thrown without any start statement prefixes involved.</p><p><pre><code>use v6.c;\nstart { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n</code></pre></p><p><pre><code>use v6.d;\nstart { die }; sleep ⅓; say \"hello\";\n# OUTPUT:\n# Unhandled exception in code scheduled on thread 4\n# Died\n#     in block  at -e line 1\n</code></pre></p><p>If you wish to avoid this behavior, use start in non-sink context or catch the exception yourself:</p><p><pre><code># Don't sink it:\nmy $ = start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n# Catch yourself:\nstart { die; CATCH { default { say \"caught\" } } };\nsleep ⅓;\nsay \"hello\";\n# OUTPUT: «caught␤hello␤»\n</code></pre></p><p>This behavior exists only syntactically, by using an alternate .sink method for Promise objects created by start blocks in sink context, thus simply sinking a Promise object that was created by other means won't trigger this behavior.</p>","keep":"<p><pre><code>multi method keep(Promise:D: \\result = True)</code></pre></p><p>Keeps a promise, optionally setting the result. If no result is passed, the result will be True.</p><p>Throws an exception of type X::Promise::Vowed if a vow has already been taken. See method vow for more information.</p><p><pre><code>my $p = Promise.new;\n\nif Bool.pick {\n    $p.keep;\n}\nelse {\n     $p.break;\n}</code></pre></p>","result":"<p><pre><code>method result(Promise:D)</code></pre></p><p>Waits for the promise to be kept or broken. If it is kept, returns the result; otherwise throws the result as an exception.</p>","status":"<p><pre><code>method status(Promise:D --> PromiseStatus)</code></pre></p><p>Returns the current state of the promise: Kept, Broken or Planned:</p><p><pre><code>say \"promise got Kept\" if $promise.status ~~ Kept;\n</code></pre></p>","cause":"<p><pre><code>method cause(Promise:D)</code></pre></p><p>If the promise was broken, returns the result (or exception). Otherwise, throws an exception of type X::Promise::CauseOnlyValidOnBroken.</p>","anyof":"<p><pre><code>method anyof(Promise:U: *@promises --> Promise:D)</code></pre></p><p>Returns a new promise that will be kept as soon as any of the promises passed as arguments is kept or broken. The result of the completed Promise is not reflected in the result of the returned promise which will always be Kept.</p><p>You can use this to wait at most a number of seconds for a promise:</p><p><pre><code>my $timeout = 5;\nawait Promise.anyof(\n    Promise.in($timeout),\n    start {\n        # do a potentially long-running calculation here\n    },\n);</code></pre></p>","broken":"<p><pre><code>multi method broken(Promise:U: --> Promise:D)\nmulti method broken(Promise:U: \\exception --> Promise:D)</code></pre></p><p>Returns a new promise that is already broken, either with the given value, or with the default value X::AdHoc.new(payload => \"Died\")</p>","in":"<p><pre><code>method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER --> Promise:D)</code></pre></p><p>Creates a new Promise that will be kept in $seconds seconds, or later.</p><p><pre><code>my $proc = Proc::Async.new('perl6', '-e', 'sleep 10; warn \"end\"');\n\nmy $result = await Promise.anyof(\n    my $promise = $proc.start,  # may or may not work in time\n    Promise.in(5).then: {       # fires after 5 seconds no matter what\n        unless $promise {       # don't do anything if we were successful\n            note 'timeout';\n            $proc.kill;\n        }\n    }\n).then: { $promise.result }\n# OUTPUT: «timeout␤»</code></pre></p><p>$seconds can be fractional or negative. Negative values are treated as 0 (i.e. keeping the returned Promise right away).</p><p>Please note that situations like these are often more clearly handled with a react and whenever block.</p>","scheduler":"<p><pre><code>method scheduler(Promise:D:)</code></pre></p><p>Returns the scheduler that manages the promise.</p>","allof":"<p><pre><code>method allof(Promise:U: *@promises --> Promise:D)</code></pre></p><p>Returns a new promise that will be kept when all the promises passed as arguments are kept or broken. The result of the individual Promises is not reflected in the result of the returned promise: it simply indicates that all the promises have been completed in some way. If the results of the individual promises are important then they should be inspected after the allof promise is kept.</p><p>In the following requesting the result of a broken promise will cause the original Exception to be thrown. (You may need to run it several times to see the exception.)</p><p><pre><code>my @promises;\nfor 1..5 -> $t {\n    push @promises, start {\n        sleep $t;\n    };\n}\nmy $all-done = Promise.allof(@promises);\nawait $all-done;\n@promises>>.result;\nsay \"Promises kept so we get to live another day!\";</code></pre></p>"},"prefix":"<p><pre><code>my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));\nclass Promise {}</code></pre></p><p>A Promise is used to handle the result of a computation that might not have finished. It allows the user to execute code once the computation is done (with the then method), execution after a time delay (with in), combining promises, and waiting for results.</p><p><pre><code>my $p = Promise.start({ sleep 2; 42});\n$p.then({ say .result });   # will print 42 once the block finished\nsay $p.status;              # OUTPUT: «Planned␤»\n$p.result;                  # waits for the computation to finish\nsay $p.status;              # OUTPUT: «Kept␤»</code></pre></p><p>There are two typical scenarios for using promises. The first is to use a factory method (start, in, at, anyof, allof, kept, broken) on the type object; those will make sure that the promise is automatically kept or broken for you, and you can't call break or keep on these promises yourself.</p><p>The second is to create your promises yourself with Promise.new. If you want to ensure that only your code can keep or break the promise, you can use the vow method to get a unique handle, and call keep or break on it:</p><p><pre><code>sub async-get-with-promise($user-agent, $url) {\n    my $p = Promise.new;\n    my $v = $p.vow;\n\n    # do an asynchronous call on a fictive user agent,\n    # and return the promise:\n    $user-agent.async-get($url,\n            on-error => -> $error {\n                $v.break($error);\n            },\n            on-success => -> $response {\n                $v.keep($response);\n            }\n    );\n    return $p;\n}\n</code></pre></p><p>Further examples can be found in the concurrency page.</p>","name":"Promise"},"Perl":{"name":"Perl","prefix":"<p><pre><code>class Perl does Systemic { }</code></pre></p><p>Built-in class for providing perl related information. Usually accessed through the $*PERL dynamic variable.</p>","defs":{"DISTROnames":"<p>Instance / Class method returning the names of the Distro objects that are supported by this version of Perl.</p>","KERNELnames":"<p>Instance / Class method returning the names of the Kernel objects that are supported by this version of Perl.</p>","VMnames":"<p>Instance / Class method returning the names of the VM objects that are supported by this version of Perl.</p>","compiler":"<p>Instance method returning the compiler object, of type Compiler, associated with the Perl object.</p>"}},"Rational":{"prefix":"<p><pre><code>role Rational[::NuT, ::DeT] does Real { ... }</code></pre></p><p>Rational is the common role for numbers that are stored as pairs of numerator and denominator. It is parameterized by the types of the numerator (NuT) and denominator (DeT). By default, these are Int, but other types of Rational are possible by using a different parameterization. In addition, Rational objects are immutable throughout their life.</p><p><pre><code>class Positive does Rational[UInt] {};\nmy Positive $one-third = Positive.new(1,3);\nsay $one-third;                         # OUTPUT: «0.333333␤»\nmy Positive $fail =Positive.new(-2,3);  # OUTPUT: «Type check failed in binding to parameter 'nu'; expected UInt but got Int (-2)␤»</code></pre></p><p>Please note that, since DeT is by default equal to NuT, in this case both are instantiated to UInt. Built into Raku are Rat and FatRat, which both do the Rational role.</p>","defs":{"Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(Rational:D: --> Bool:D)</code></pre></p><p>Returns False if numerator is 0, otherwise returns True. This applies for <0/0> zero-denominator Rational as well, despite ?<0/0>.Num being True.</p>","ceiling":"<p>Defined as:</p><p><pre><code>method ceiling(Rational:D: --> Int:D)</code></pre></p><p>Return the smallest integer not less than the invocant. If denominator is zero, fails with X::Numeric::DivideByZero.</p>","norm":"<p><pre><code>method norm(Rational:D: --> Rational:D)</code></pre></p><p>DEPRECATED as of 6.d. The method is no longer needed, because as of 6.d language version, it's required for Rational type to be normalized on creation.</p><p>Returns a normalized Rational object, i.e. with positive denominator, and numerator and denominator coprime. The denominator can also by zero, but using it in any operation or a conversion to string will result in an exception.</p><p><pre><code>use v6.c;\nmy Rational $by-zero = 3/0;\nsay $by-zero.norm.perl; # OUTPUT: «<1/0>␤»\n</code></pre></p><p><pre><code>say $by-zero; # OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤\n</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>method Int(Rational:D: --> Int:D)</code></pre></p><p>Coerces the invocant to Int by truncating non-whole portion of the represented number, if any. If the denominator is zero, will fail with X::Numeric::DivideByZero.</p>","Num":"<p>Defined as:</p><p><pre><code>method Num(Rational:D: --> Num:D)</code></pre></p><p>Coerces the invocant to Num by dividing numerator by denominator. If denominator is 0, returns Inf, -Inf, or NaN, based on whether numerator is a positive number, negative number, or 0, respectively.</p>","base-repeating":"<p><pre><code>method base-repeating(Rational:D: Int:D() $base = 10)</code></pre></p><p>Returns a list of two strings that, when concatenated, represent the number in base $base. The second element is the one that repeats. For example:</p><p><pre><code>my ($non-rep, $repeating) = (19/3).base-repeating(10);\nsay $non-rep;                               # OUTPUT: «6.␤»\nsay $repeating;                             # OUTPUT: «3␤»\nprintf '%s(%s)', $non-rep, $repeating;      # OUTPUT: «6.(3)»</code></pre></p><p>19/3 is 6.333333... with the 3 repeating indefinitely.</p><p>If no repetition occurs, the second string is empty:</p><p><pre><code>say (5/2).base-repeating(10).perl;          # OUTPUT: «(\"2.5\", \"\")␤»</code></pre></p><p>The precision for determining the repeating group is limited to 1000 characters, above that, the second string is ???.</p><p>$base defaults to 10.</p>","nude":"<p><pre><code>method nude(Rational:D: --> Positional)</code></pre></p><p>Returns a list of the numerator and denominator.</p>","new":"<p><pre><code>    method new(NuT:D $numerator, DeT:D $denominator --> Rational:D)\n</code></pre></p><p>Creates a new rational object from numerator and denominator, which it normalizes to the lowest terms. The $denominator can be zero, in which case the numerator is normalized to -1, 0, or 1 depending on whether the original is negative, zero, or positive, respectively.</p>","numerator":"<p><pre><code>    method numerator(Rational:D: --> NuT:D)\n</code></pre></p><p>Returns the numerator.</p>","isNaN":"<p><pre><code>method isNaN(Rational:D: --> Bool:D)</code></pre></p><p>Tests whether the invocant's Num value is a NaN, an acronym for Not available Number. That is both its numerator and denominator are zero.</p>","denominator":"<p><pre><code>    method denominator(Rational:D: --> DeT:D)\n</code></pre></p><p>Returns the denominator.</p>","floor":"<p>Defined as:</p><p><pre><code>method floor(Rational:D: --> Int:D)</code></pre></p><p>Return the largest integer not greater than the invocant. If denominator is zero, fails with X::Numeric::DivideByZero.</p>"},"name":"Rational"},"X::Phaser::Multiple":{"prefix":"<p><pre><code>class X::Phaser::Multiple does X::Comp { }</code></pre></p><p>Thrown when multiple phasers of the same type occur in a block, but only one is allowed (for example CATCH or CONTROL).</p><p>For example</p><p><pre><code>CATCH { }; CATCH { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nOnly one CATCH block is allowed\n</code></pre></p>","defs":{},"name":"X::Phaser::Multiple"},"IO::Spec::Win32":{"name":"IO::Spec::Win32","defs":{"catfile":"<p>Alias for catdir.</p>","split":"<p>Defined as:</p><p><pre><code>method split(Cool:D $path --> List:D)</code></pre></p><p>Splits the given $path into \"volume\", \"dirname\", and \"basename\" and returns the result as a List of three Pairs, in that order. The \"volume\" is always an empty string and exists for consistency with other IO::Spec classes.</p><p><pre><code>IO::Spec::Win32.split('C:/foo/bar.txt').perl.say;\n# OUTPUT: «(:volume(\"C:\"), :dirname(\"/foo\"), :basename(\"bar.txt\"))␤»\n\nIO::Spec::Win32.split('/foo/').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\nIO::Spec::Win32.split('///').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"\\\\\"))␤»\n\nIO::Spec::Win32.split('./').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Win32.split('.').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Win32.split('').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»\n</code></pre></p>","catpath":"<p>Defined as:</p><p><pre><code>method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)</code></pre></p><p>Concatenates a path from given volume, a chain of directories, and file. An empty string can be given for any of the three arguments. No attempt to make the path canonical is made. Use canonpath for that purpose.</p><p><pre><code>IO::Spec::Win32.catpath('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir\\foo.txt␤»\n\nIO::Spec::Win32.catpath('C:', '/some/dir', '').say;\n# OUTPUT: «C:/some/dir␤»\n\nIO::Spec::Win32.catpath('', '/some/dir', 'foo.txt').say;\n# OUTPUT: «/some/dir\\foo.txt␤»\n\nIO::Spec::Win32.catpath('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>","join":"<p>Defined as:</p><p><pre><code>method join (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)</code></pre></p><p>Similar to catpath, takes two path fragments and concatenates them, adding or removing a path separator, if necessary, except it will return just $file if both $dir and $file are string '/' or if $dir is the string '.'. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Win32.join('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir\\and/more␤»\n\nIO::Spec::Win32.join('C:', '.', 'foo.txt').say;\n# OUTPUT: «C:foo.txt␤»\n\nIO::Spec::Win32.join('C:', ｢\\｣, '/').say;\n# OUTPUT: «C:\\␤»\n\nIO::Spec::Win32.join('//server/share', ｢\\｣, '/').say;\n# OUTPUT: «//server/share␤»\n\nIO::Spec::Win32.join('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>","devnull":"<p>Defined as:</p><p><pre><code>method devnull(--> Str:D)</code></pre></p><p>Returns the string \"nul\" representing the \"Null device\":</p><p><pre><code>$*SPEC.devnull.IO.spurt: \"foo bar baz\";\n</code></pre></p>","splitdir":"<p>Defined as:</p><p><pre><code>method splitdir(Cool:D $path --> List:D)</code></pre></p><p>Splits the given $path on slashes and backslashes.</p><p><pre><code>IO::Spec::Win32.splitdir('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\", \"foo\", \"bar.txt\")␤»\n\nIO::Spec::Win32.splitdir('/foo/').perl.say;\n# OUTPUT: «(\"\", \"foo\", \"\")␤»\n\nIO::Spec::Win32.splitdir('///').perl.say;\n# OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\nIO::Spec::Win32.splitdir('./').perl.say;\n# OUTPUT: «(\".\", \"\")␤»\n\nIO::Spec::Win32.splitdir('.').perl.say;\n# OUTPUT: «(\".\",)␤»\n\nIO::Spec::Win32.splitdir('').perl.say;\n# OUTPUT: «(\"\",)␤»\n</code></pre></p>","dir-sep":"<p>Defined as:</p><p><pre><code>method dir-sep(--> Str:D)</code></pre></p><p>Returns the string ｢\\｣ representing canonical directory separator character.</p><p><pre><code>IO::Spec::Win32.dir-sep.say; # OUTPUT: «\\␤»\n</code></pre></p>","is-absolute":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --> Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\") or backslash (\"\\\"), even if they have combining character on them, optionally preceded by a volume:</p><p><pre><code>say IO::Spec::Win32.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\nsay IO::Spec::Win32.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","catdir":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --> Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Win32.catdir(<foo/bar ber perl>).say;\n# OUTPUT: «foo\\bar\\ber\\perl␤»</code></pre></p>","splitpath":"<p>Defined as:</p><p><pre><code>method splitpath(Cool:D $path, :$nofile --> List:D)</code></pre></p><p>Splits the given $path into a list of 3 strings: volume, dirname, and file. The volume is always an empty string, returned for API compatibility with other IO::Spec types. If :$nofile named argument is set to True, the content of the file string is undefined and should be ignored; this is a means to get a performance boost, as implementations may use faster code path when file is not needed.</p><p><pre><code>IO::Spec::Win32.splitpath('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\", \"\\\\foo/\", \"bar.txt\")␤»\n\nIO::Spec::Win32.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n# OUTPUT: «(\"C:\", \"\\\\foo/bar.txt\", \"\")␤»\n\nIO::Spec::Win32.splitpath('/foo/').perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Win32.splitpath('/foo/', :nofile).perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Win32.splitpath('///').perl.say;\n# OUTPUT: «(\"\", \"///\", \"\")␤»\n\nIO::Spec::Win32.splitpath('./').perl.say;\n# OUTPUT: «(\"\", \"./\", \"\")␤»\n\nIO::Spec::Win32.splitpath('.').perl.say;\n# OUTPUT: «(\"\", \"\", \".\")␤»\n\nIO::Spec::Win32.splitpath('').perl.say;\n# OUTPUT: «(\"\", \"\", \"\")␤»\n</code></pre></p>","rootdir":"<p>Defined as:</p><p><pre><code>method rootdir(--> Str:D)</code></pre></p><p>Returns string ｢\\｣, representing root directory.</p>","canonpath":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --> Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem.</p><p><pre><code>IO::Spec::Win32.canonpath(\"C:/foo//../bar/../ber\").say;\n# OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\nIO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\").say;\n# OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\nIO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «C:\\ber␤»</code></pre></p>","rel2abs":"<p>Defined as:</p><p><pre><code>method rel2abs(Str() $path, $base = $*CWD --> Str:D)</code></pre></p><p>Returns a string representing $path converted to absolute path, based at $base, which defaults to $*CWD. If $base is not an absolute path, it will be made absolute relative to $*CWD, unless $*CWD and $base are the same.</p><p><pre><code>say $*CWD;                                   # OUTPUT: «\"C:\\Users\\camelia\".IO␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo';          # OUTPUT: «C:\\Users\\camelia\\foo␤»\nsay IO::Spec::Win32.rel2abs: './';           # OUTPUT: «C:\\Users\\camelia␤»\nsay IO::Spec::Win32.rel2abs: 'foo/../../';   # OUTPUT: «C:\\Users\\camelia\\foo\\..\\..␤»\nsay IO::Spec::Win32.rel2abs: '/foo/';        # OUTPUT: «C:\\foo␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo', 'bar';   # OUTPUT: «C:\\Users\\camelia\\bar\\foo␤»\nsay IO::Spec::Win32.rel2abs: './', '/bar';   # OUTPUT: «\\bar␤»\nsay IO::Spec::Win32.rel2abs: '/foo/', 'bar'; # OUTPUT: «C:\\foo␤»\n\nsay IO::Spec::Win32.rel2abs: 'foo/../../', 'bar';\n# OUTPUT: «C:\\Users\\camelia\\bar\\foo\\..\\..␤»\n</code></pre></p>","basename":"<p>Defined as:</p><p><pre><code>method basename(Str:D $path --> Str:D)</code></pre></p><p>Takes a path as a string and returns a possibly-empty portion after the last slash or backslash:</p><p><pre><code>IO::Spec::Win32.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Win32.basename(\"foo/bar\\\\\").perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Win32.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\nIO::Spec::Win32.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»</code></pre></p>","path":"<p>Defined as:</p><p><pre><code>method path(--> Seq:D)</code></pre></p><p>Splits the value of %*ENV<PATH> (or %*ENV<Path> if the former is not set) on semicolons (\";\") and returns a Seq with each of the resultant parts, always adding element \".\" to the head. Removes all double quotes (\") it finds.</p><p><pre><code>%*ENV<PATH> = 'foo;\"bar\"/\"ber\"';\nIO::Spec::Win32.path.perl.say; # OUTPUT: «(\".\", \"foo\", \"bar/ber\").Seq␤»</code></pre></p>"},"prefix":"<p><pre><code>class IO::Spec::Win32 is IO::Spec { }</code></pre></p><p>Objects of this class are used not directly but as a sub-class specific to the platform Raku is running on via the $*SPEC variable, which will contain an object of the appropriate type.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>"},"NFD":{"name":"NFD","defs":{},"prefix":"<p><pre><code>class NFD is Uni {}</code></pre></p><p>A Codepoint string in the \"D\" Unicode Normalization Form</p>"},"Lock::Async":{"defs":{"protect":"<p>Defined as:</p><p><pre><code>method protect(Lock::Async:D: &code)</code></pre></p><p>Calls lock, does an await to wait for the lock to be available, and reliably calls unlock afterwards, even if the code throws an exception.</p><p>Note that the Lock::Async itself needs to be created outside the portion of the code that gets threaded and it needs to protect. In the first example below, Lock::Async is first created and assigned to $lock, which is then used inside the Promises to protect the sensitive code. In the second example, a mistake is made, the Lock::Async is created right inside the Promise, so the code ends up with a bunch of separate locks, created in a bunch of threads, and thus they don't actually protect the code we want to protect.</p><p><pre><code># Right: $lock is instantiated outside the portion of the\n# code that will get threaded and be in need of protection\nmy $lock = Lock::Async.new;\nawait ^20 .map: {\n    start {\n        $lock.protect: {\n            print \"Foo\";\n            sleep rand;\n            say \"Bar\";\n        }\n    }\n}\n\n# !!! WRONG !!! Lock::Async is instantiated inside threaded area!\nawait ^20 .map: {\n    start {\n        my $lock = Lock::Async.new;\n        $lock.protect: {\n            print \"Foo\"; sleep rand; say \"Bar\";\n        }\n    }\n}</code></pre></p>","protect-or-queue-on-recursion":"<p>Defined as:</p><p><pre><code>method protect-or-queue-on-recursion(Lock::Async:D: &code)</code></pre></p><p>When calling protect on a Lock::Async instance that is already locked, the method is forced to block until the lock gets unlocked. protect-or-queue-on-recursion avoids this issue by either behaving the same as protect if the lock is unlocked or the lock was locked by something outside the caller chain, returning Nil, or queueing the call to &code and returning a Promise if the lock had already been locked at another point in the caller chain.</p><p><pre><code>my Lock::Async $lock .= new;\nmy Int         $count = 0;\n\n# The lock is unlocked, so the code runs instantly.\n$lock.protect-or-queue-on-recursion({\n    $count++\n});\n\n# Here, we have caller recursion. The outer call only returns a Promise\n# because the inner one does. If we try to await the inner call's Promise\n# from the outer call, the two calls will block forever since the inner\n# caller's Promise return value is just the outer's with a then block.\n$lock.protect-or-queue-on-recursion({\n    $lock.protect-or-queue-on-recursion({\n        $count++\n    }).then({\n        $count++\n    })\n});\n\n# Here, the lock is locked, but not by anything else on the caller chain.\n# This behaves just like calling protect would in this scenario.\nfor 0..^2 {\n    $lock.protect-or-queue-on-recursion({\n        $count++;\n    });\n}\n\nsay $count; # OUTPUT: 5</code></pre></p>","unlock":"<p>Defined as:</p><p><pre><code>method unlock(Lock::Async:D: --> Nil)</code></pre></p><p>Releases the lock. If there are any outstanding lock Promises, the one at the head of the queue will then be kept, and potentially code scheduled on the thread pool (so the cost of calling unlock is limited to the work needed to schedule another piece of code that wants to obtain the lock, but not to execute that code).</p><p><pre><code>my $l = Lock::Async.new;\nawait $l.lock;\n$l.unlock;</code></pre></p><p>Prefer to use protect instead of explicit calls to lock and unlock. However, if wishing to use the methods separately, it is wise to use a LEAVE block to ensure that unlock is reliably called. Failing to unlock will mean that nobody can ever lock this particular Lock::Async instance again.</p><p><pre><code>my $l = Lock::Async.new;\n{\n    await $l.lock;\n    LEAVE $l.unlock;\n}</code></pre></p>","lock":"<p>Defined as:</p><p><pre><code>method lock(Lock::Async:D: --> Promise:D)</code></pre></p><p>Returns a Promise that will be kept when the lock is available. In the case that the lock is already available, an already kept Promise will be returned. Use await to wait for the lock to be available in a non-blocking manner.</p><p><pre><code>my $l = Lock::Async.new;\nawait $l.lock;</code></pre></p><p>Prefer to use protect instead of explicit calls to lock and unlock.</p>"},"prefix":"<p><pre><code>class Lock::Async {}</code></pre></p><p>A Lock::Async instance provides a mutual exclusion mechanism: when the lock is held, any other code wishing to lock must wait until the holder calls unlock.</p><p>Unlike Lock, which provides a traditional OS-backed mutual exclusion mechanism, Lock::Async works with the high-level concurrency features of Raku. The lock method returns a Promise, which will be kept when the lock is available. This Promise can be used with non-blocking await. This means that a thread from the thread pool need not be consumed while waiting for the Lock::Async to be available, and the code trying to obtain the lock will be resumed once it is available.</p><p>The result is that it's quite possible to have many thousands of outstanding Lock::Async lock requests, but just a small number of threads in the pool. Attempting that with a traditional Lock would not go so well!</p><p>There is no requirement that a Lock::Async is locked and unlocked by the same physical thread, meaning it is possible to do a non-blocking await while holding the lock. The flip side of this is Lock::Async is not re-entrant.</p><p>While Lock::Async works in terms of higher-level Raku concurrency mechanisms, it should be considered a building block. Indeed, it lies at the heart of the Supply concurrency model. Prefer to structure programs so that they communicate results rather than mutate shared data structures, using mechanisms like Promise, Channel and Supply.</p>","name":"Lock::Async"},"Metamodel::MethodContainer":{"name":"Metamodel::MethodContainer","defs":{"method_table":"<p><pre><code>method method_table(Metamodel::MethodContainer:D: $obj --> Hash:D)</code></pre></p><p>Returns a hash where the keys are method names, and the values are methods. Note that the keys are the names by which the methods can be called, not necessarily the names by which the methods know themselves.</p>","add_method":"<p><pre><code>method add_method(Metamodel::MethodContainer: $obj, $name, $code)</code></pre></p><p>Adds a method to the metaclass, to be called with name $name. This should only be done before a type is composed.</p>","methods":"<p><pre><code>method methods(Metamodel::MethodContainer: $obj, :$all, :$local)</code></pre></p><p>Returns a list of public methods available on the class (which includes methods from superclasses and roles). By default this stops at the classes Cool, Any or Mu; to really get all methods, use the :all adverb. If :local is set, only methods declared directly in the class are returned.</p><p><pre><code>class A {\n    method x() { };\n}\n\nsay A.^methods();                   # x\nsay A.^methods(:all);               # x infinite defined ...</code></pre></p><p>The returned list contains objects of type Method, which you can use to introspect their signatures and call them.</p><p>Some introspection method-look-alikes like WHAT will not show up, although they are present in any Raku object. They are handled at the grammar level and will likely remain so for bootstrap reasons.</p>"},"prefix":"<p><pre><code>role Metamodel::MethodContainer {}</code></pre></p><p>roles, classes, grammars and enums can contain methods. This role implements the API around storing and introspecting them.</p><p><pre><code>say .name for Int.^methods(:all);\n\n# don't do that, because it changes type Int globally.\n# just for demonstration purposes.\nInt.^add_method('double', method ($x:) { 2 * $x });\nsay 21.double; # OUTPUT: «42␤»</code></pre></p>"},"RaceSeq":{"name":"RaceSeq","defs":{"grep":"<p><pre><code>method grep(RaceSeq:D: $matcher, *%options)</code></pre></p><p>Applies grep to the RaceSeq similarly to how it would do it on a Seq.</p><p><pre><code>my @raced = (^10000).map(*²).race;\n@raced.grep( * %% 3 ).say;\n# OUTPUT: «(0 9 36 81 144 …»\n</code></pre></p><p>When you use race on a Seq, this is the method that is actually called.</p>","race":"<p><pre><code>method race(RaceSeq:D:)</code></pre></p><p>Returns the object.</p>","is-lazy":"<p><pre><code>method is-lazy(--> False )</code></pre></p><p>Returns False.</p>","serial":"<p><pre><code>multi method serial(RaceSeq:D:)</code></pre></p><p>Converts the object to a Seq and returns it.</p>","hyper":"<p><pre><code>method hyper(RaceSeq:D:)</code></pre></p><p>Creates a HyperSeq object out of the current one.</p>","invert":"<p><pre><code>method invert(RaceSeq:D:)</code></pre></p><p>Inverts the RaceSeq created from a Seq by .race.</p>","iterator":"<p><pre><code>method iterator(RaceSeq:D: --> Iterator:D)</code></pre></p><p>Returns the underlying iterator.</p>","map":"<p><pre><code>method map(RaceSeq:D: $matcher, *%options)</code></pre></p><p>Uses maps on the RaceSeq, generally created by application of .race to a preexisting Seq.</p>"},"prefix":"<p><pre><code>class RaceSeq does Iterable does Sequence { }</code></pre></p><p>An RaceSeq is the intermediate object used when the operator race is invoked on a Seq. In general, it's not intended for direct consumption by the developer.</p>"},"X::Syntax::Variable::Match":{"defs":{},"prefix":"<p><pre><code>class X::Syntax::Variable::Match does X::Syntax { }</code></pre></p><p>Syntax error thrown when a match variable like $<thing>  was declared.</p><p>For example</p><p><pre><code>my $<thing>;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot declare a match variable\n</code></pre></p>","name":"X::Syntax::Variable::Match"},"X::Str::Numeric":{"defs":{"pos":"<p><pre><code>method pos(--> Int:D)</code></pre></p><p>Gives the position into the string where the parsing failed.</p>","source":"<p><pre><code>method source(--> Str:D)</code></pre></p><p>Returns the string that was attempted to convert to a number</p>"},"prefix":"<p><pre><code>class X::Str::Numeric is Exception { }</code></pre></p><p>Error thrown (or wrapped in a Failure) when a conversion from string to a number fails.</p><p>For example</p><p><pre><code>say +\"42 answers\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Str::Numeric: Cannot convert string to number: trailing characters after number in '42⏏ answers' (indicated by ⏏)␤»</code></pre></p>","name":"X::Str::Numeric"},"X::Obsolete":{"name":"X::Obsolete","defs":{"old":"<p><pre><code>method old(--> Str:D)</code></pre></p><p>Returns a textual description of the obsolete syntax construct</p>","replacement":"<p><pre><code>method replacement(--> Str:D)</code></pre></p><p>Describes what to use instead of the obsolete syntax.</p>"},"prefix":"<p><pre><code>class X::Obsolete does X::Comp { }</code></pre></p><p>Syntax error thrown when the user is attempting to use constructs from other languages.</p><p>For example</p><p><pre><code>m/abc/i\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nUnsupported use of /i; in Raku please use :i\n</code></pre></p>"},"X::Pod":{"name":"X::Pod","prefix":"<p><pre><code>role X::Pod { }</code></pre></p><p>Common role for Pod related errors.</p>","defs":{}},"X::Comp":{"defs":{"line":"<p>The line number in which the compilation error occurred.</p>","filename":"<p>The filename in which the compilation error occurred</p>"},"prefix":"<p><pre><code>role X::Comp is Exception { }</code></pre></p><p>Common role for compile-time errors.</p><p>Note that since the backtrace of a compile time error generally shows routines from the compiler, not from user-space programs, the Backtrace returned from the backtrace method is not very informative. Instead the exception carries its own filename, line and column attributes and public accessors.</p><p>If an error occurs while creating an object (like a class or routine) at compile time, generally the exception associated with it does not hold a reference to the object (for example a class would not be fully composed, and thus not usable). In those cases the name of the would-be-created object is included in the error message instead.</p>","name":"X::Comp"},"X::IO::Mkdir":{"defs":{"path":"<p>Returns the path that the mkdir operation failed to create.</p>"},"prefix":"<p><pre><code>class X::IO::Mkdir does X::IO is Exception { }\n</code></pre></p><p>Error class for failed mkdir operations.</p><p>A typical error message is</p><p><pre><code>Failed to create directory 'destination' with mode '0o755': File exists\n</code></pre></p>","name":"X::IO::Mkdir"},"Pod::Block::Code":{"name":"Pod::Block::Code","defs":{},"prefix":"<p><pre><code>class Pod::Block::Code is Pod::Block { }</code></pre></p><p>Class for a code (verbatim) Pod block.</p>"},"Str":{"defs":{"trim-trailing":"<p><pre><code>method trim-trailing(Str:D: --> Str)</code></pre></p><p>Removes the whitespace characters from the end of a string. See also trim.</p>","succ":"<p><pre><code>method succ(Str:D --> Str:D)</code></pre></p><p>Returns the string incremented by one.</p><p>String increment is \"magical\". It searches for the last alphanumeric sequence that is not preceded by a dot, and increments it.</p><p><pre><code>'12.34'.succ;      # RESULT: «13.34»\n'img001.png'.succ; # RESULT: «img002.png»</code></pre></p><p>The actual increment step works by mapping the last alphanumeric character to a character range it belongs to, and choosing the next character in that range, carrying to the previous letter on overflow.</p><p><pre><code>'aa'.succ;   # RESULT: «ab»\n'az'.succ;   # RESULT: «ba»\n'109'.succ;  # RESULT: «110»\n'α'.succ;    # RESULT: «β»\n'a9'.succ;   # RESULT: «b0»</code></pre></p><p>String increment is Unicode-aware, and generally works for scripts where a character can be uniquely classified as belonging to one range of characters.</p>","uniparse":"<p><pre><code>sub    uniparse(Str:D $names  --> Str:D)\nmethod uniparse(Str:D $names: --> Str:D)</code></pre></p><p>Takes string with comma-separated Unicode names of characters and returns a string composed of those characters. Will fail if any of the characters' names are empty or not recognized. Whitespace around character names is ignored.</p><p><pre><code>say \"I {uniparse 'TWO HEARTS'} Raku\"; # OUTPUT: «I \uD83D\uDC95 Raku␤»\n'TWO HEARTS, BUTTERFLY'.uniparse.say; # OUTPUT: «\uD83D\uDC95\uD83E\uDD8B␤»</code></pre></p><p>Note that unlike \\c[...] construct available in string interpolation, uniparse does not accept decimal numerical values. Use chr routine to convert those:</p><p><pre><code>say \"\\c[1337]\"; # OUTPUT: «Թ␤»\nsay '1337'.chr; # OUTPUT: «Թ␤»</code></pre></p><p>Note: before being standardized in 2017.12, this routine was known under its working name of parse-names. This denomination will be removed in the 6.e version.</p>","ends-with":"<p><pre><code>multi method ends-with(Str:D: Str(Cool) $needle --> Bool:D)</code></pre></p><p>Returns True if the invocant is identical to or ends with $needle.</p><p><pre><code>say \"Hello, World\".ends-with('Hello');      # OUTPUT: «False␤»\nsay \"Hello, World\".ends-with('ld');         # OUTPUT: «True␤»</code></pre></p>","fc":"<p><pre><code>multi sub    fc(Str:D  --> Str:D)\nmulti method fc(Str:D: --> Str:D)</code></pre></p><p>Does a Unicode \"fold case\" operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p>","flip":"<p><pre><code>multi sub    flip(Str:D  --> Str:D)\nmulti method flip(Str:D: --> Str:D)</code></pre></p><p>Returns the string reversed character by character.</p><p>Examples:</p><p><pre><code>\"Perl\".flip;  # RESULT: «lreP»\n\"ABBA\".flip;  # RESULT: «ABBA»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(Str:D: --> Bool:D)</code></pre></p><p>Returns False if the string is empty, True otherwise.</p>","split":"<p><pre><code>multi sub    split(  Str:D $delimiter, Str:D $input, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p><pre><code>multi sub    split(Regex:D $delimiter, Str:D $input, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p><pre><code>multi sub    split(List:D $delimiters, Str:D $input, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p><pre><code>multi method split(Str:D:   Str:D $delimiter, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p><pre><code>multi method split(Str:D: Regex:D $delimiter, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p><pre><code>multi method split(Str:D: List:D $delimiters, $limit = Inf,\n  :$skip-empty, :$v, :$k, :$kv, :$p)\n</code></pre></p><p>Splits a string up into pieces based on delimiters found in the string.</p><p>If DELIMITER is a string, it is searched for literally and not treated as a regex. If DELIMITER is the empty string, it effectively returns all characters of the string separately (plus an empty string at the begin and at the end). If PATTERN is a regular expression, then that will be used to split up the string. If DELIMITERS is a list, then all of its elements will be considered a delimiter (either a string or a regular expression) to split the string on.</p><p>The optional LIMIT indicates in how many segments the string should be split, if possible. It defaults to Inf (or *, whichever way you look at it), which means \"as many as possible\". Note that specifying negative limits will not produce any meaningful results.</p><p>A number of optional named parameters can be specified, which alter the result being returned. The :v, :k, :kv and :p named parameters all perform a special action with regards to the delimiter found.</p>* <p>:skip-empty</p><br><p>If specified, do not return empty strings before or after a delimiter.</p>* <p>:v</p><br><p>Also return the delimiter. If the delimiter was a regular expression, then this will be the associated Match object. Since this stringifies as the delimiter string found, you can always assume it is the delimiter string if you're not interested in further information about that particular match.</p>* <p>:k</p><br><p>Also return the index of the delimiter. Only makes sense if a list of delimiters was specified: in all other cases, this will be 0.</p>* <p>:kv</p><br><p>Also return both the index of the delimiter, as well as the delimiter.</p>* <p>:p</p><br><p>Also return the index of the delimiter and the delimiter as a Pair.</p><p>Examples:</p><p><pre><code>say split(\";\", \"a;b;c\").perl;           # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\nsay split(\";\", \"a;b;c\", :v).perl;       # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\nsay split(\";\", \"a;b;c\", 2).perl;        # OUTPUT: «(\"a\", \"b;c\").Seq␤»\nsay split(\";\", \"a;b;c\", 2, :v).perl;    # OUTPUT: «(\"a\", \";\", \"b;c\").Seq␤»\nsay split(\";\", \"a;b;c,d\").perl;         # OUTPUT: «(\"a\", \"b\", \"c,d\").Seq␤»\nsay split(/\\;/, \"a;b;c,d\").perl;        # OUTPUT: «(\"a\", \"b\", \"c,d\").Seq␤»\nsay split(<; ,>, \"a;b;c,d\").perl;       # OUTPUT: «(\"a\", \"b\", \"c\", \"d\").Seq␤»\nsay split(/<[;,]>/, \"a;b;c,d\").perl;    # OUTPUT: «(\"a\", \"b\", \"c\", \"d\").Seq␤»\nsay split(<; ,>, \"a;b;c,d\", :k).perl;   # OUTPUT: «(\"a\", 0, \"b\", 0, \"c\", 1, \"d\").Seq␤»\nsay split(<; ,>, \"a;b;c,d\", :kv).perl;  # OUTPUT: «(\"a\", 0, \";\", \"b\", 0, \";\", \"c\", 1, \",\", \"d\").Seq␤»\n\nsay \"\".split(\"x\").perl;                 # OUTPUT: «(\"\",).Seq␤»\nsay \"\".split(\"x\", :skip-empty).perl;    # OUTPUT: «().Seq␤»\n\nsay \"abcde\".split(\"\").perl;             # OUTPUT: «(\"\", \"a\", \"b\", \"c\", \"d\", \"e\", \"\").Seq␤»\nsay \"abcde\".split(\"\",:skip-empty).perl; # OUTPUT: «(\"a\", \"b\", \"c\", \"d\", \"e\").Seq␤»</code></pre></p>","parse-names":"<p><pre><code>sub    parse-names(Str:D $names  --> Str:D)\nmethod parse-names(Str:D $names: --> Str:D)</code></pre></p><p>DEPRECATED. Use uniparse instead. Existed in Rakudo implementation as a proof of viability implementation before being renamed and will be removed when 6.e language is released.</p>","index":"<p><pre><code>multi method index(Str:D: Cool:D $needle --> Int:D)\nmulti method index(Str:D: Str:D $needle --> Int:D)\nmulti method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\nmulti method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)</code></pre></p><p>Searches for $needle in the string starting from $pos (if present). It returns the offset into the string where $needle was found, and Nil if it was not found.</p><p>Examples:</p><p><pre><code>say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\nsay index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\nsay index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\nsay index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\nsay index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\nsay index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»</code></pre></p><p>Other forms of index, including a sub, are inherited from Cool. Check them there.</p>","Rat":"<p>Defined as:</p><p><pre><code>method Rat(Str:D: --> Rational:D)</code></pre></p><p>Coerces the string to a Rat object, using the same rules as Str.Numeric. If the denominator is larger than 64-bits is it still kept and no degradation to Num occurs.</p>","uc":"<p><pre><code>multi sub    uc(Str:D  --> Str:D)\nmulti method uc(Str:D: --> Str:D)</code></pre></p><p>Returns an uppercase version of the string.</p>","tclc":"<p><pre><code>multi sub    tclc(Str:D  --> Str:D)\nmulti method tclc(Str:D: --> Str:D)</code></pre></p><p>Turns the first character to title case, and all other characters to lower case</p>","trim":"<p><pre><code>method trim(Str:D: --> Str)</code></pre></p><p>Remove leading and trailing whitespace. It can be used both as a method on strings and as a function. When used as a method it will return the trimmed string. In order to do in-place trimming, one needs to write .=trim</p><p><pre><code>my $line = '   hello world    ';\nsay '<' ~ $line.trim ~ '>';        # OUTPUT: «<hello world>␤»\nsay '<' ~ trim($line) ~ '>';       # OUTPUT: «<hello world>␤»\n$line.trim;\nsay '<' ~ $line ~ '>';             # OUTPUT: «<   hello world    >␤»\n$line.=trim;\nsay '<' ~ $line ~ '>';             # OUTPUT: «<hello world>␤»</code></pre></p><p>See also trim-trailing and trim-leading.</p>","lines":"<p>Defined as:</p><p><pre><code>multi method lines(Str:D: $limit)\nmulti method lines(Str:D:)</code></pre></p><p>Returns a list of lines (without trailing newline characters), i.e. the same as a call to $input.comb( / ^^ \\N* /, $limit ) would.</p><p>Examples:</p><p><pre><code>say lines(\"a\\nb\").perl;    # OUTPUT: «(\"a\", \"b\").Seq␤»\nsay lines(\"a\\nb\").elems;   # OUTPUT: «2␤»\nsay \"a\\nb\".lines.elems;    # OUTPUT: «2␤»\nsay \"a\\n\".lines.elems;     # OUTPUT: «1␤»</code></pre></p><p>You can limit the number of lines returned by setting the $limit variable to a non-zero, non-Infinity value:</p><p><pre><code>say <not there yet>.join(\"\\n\").lines( 2 ); # OUTPUT: «(not there)␤»</code></pre></p><p>DEPRECATED as of 6.d language, the :count argument was used to return the total number of lines:</p><p><pre><code>say <not there yet>.join(\"\\n\").lines( :count ); # OUTPUT: «3␤»</code></pre></p><p>Use elems call on the returned Seq instead:</p><p><pre><code>say <not there yet>.join(\"\\n\").lines.elems; # OUTPUT: «3␤»</code></pre></p>","trans":"<p><pre><code>multi method trans(Str:D: Pair:D \\what, *%n --> Str)\nmulti method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --> Str)</code></pre></p><p>Replaces one or many characters with one or many characters. Ranges are supported, both for keys and values. Regexes work as keys. In case a list of keys and values is used, substrings can be replaced as well. When called with :complement anything but the matched value or range is replaced with a single value; with :delete the matched characters without corresponding replacement are removed. Combining :complement and :delete will remove anything but the matched values, unless replacement characters have been specified, in which case, :delete would be ignored. The adverb :squash will reduce repeated matched characters to a single character.</p><p>Example:</p><p><pre><code>my $str = 'say $x<b> && $y<a>';\n$str.=trans( '<' => '«' );\n$str.=trans( '<' => '«', '>' => '»' );\n\n$str.=trans( [ '<'   , '>'   , '&' ] =>\n             [ '&lt;', '&gt;', '&amp;' ]);\n\n$str.=trans( ['a'..'y'] => ['A'..'z'] );\n\n\"abcdefghij\".trans(/<[aeiou]> \\w/ => '');                     # RESULT: «cdgh»\n\n\"a123b123c\".trans(['a'..'z'] => 'x', :complement);            # RESULT: «axxxbxxxc»\n\"aaa1123bb123c\".trans('a'..'z' => 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n\"aaa1123bb123c\".trans('a'..'z' => 'x', :complement, :squash); # RESULT: «aaaxbbxc»</code></pre></p><p>In general, the strings will have the same length after the substitution:</p><p><pre><code>say \"a123b123c\".trans('23' => '4');   # OUTPUT: «a144b144c␤»\nsay \"a123b123c\".trans('123' => 'þð'); # OUTPUT: «aþðþbþðþc␤»</code></pre></p><p>:squash and :delete will have the same effect in this case making it a strict substitution:</p><p><pre><code>say \"a123b123c\".trans('123' => 'þð', :squash); # OUTPUT: «aþðbþðc␤»\nsay \"a123b123c\".trans('123' => 'þð', :delete); # OUTPUT: «aþðbþðc␤»</code></pre></p><p>:delete will also remove non-matched characters from the original string:</p><p><pre><code>say \"abc\".trans(\"abc\".comb => 1..2, :delete);  # OUTPUT: «12␤»</code></pre></p><p>Please note that the behavior of the two versions of the multi method is slightly different. The first form will transpose only one character if the origin is also one character:</p><p><pre><code>say \"abcd\".trans( \"a\" => \"zz\" );  # OUTPUT: «zbcd␤»\nsay \"abcd\".trans( \"ba\" => \"yz\" ); # OUTPUT: «zycd␤»\n</code></pre></p><p>In the second case, behavior is as expected, since the origin is more than one char long. However, if the Pair in the multi method does not have a Str as an origin or target, it is handled to the second multi method, and behavior changes:</p><p><pre><code>say \"abcd\".trans: [\"a\"] => [\"zz\"]; # OUTPUT: «zzbcd␤»</code></pre></p><p>In this case, neither origin nor target in the Pair are Str; the method with the Pair signature then calls the second, making this call above equivalent to \"abcd\".trans: [\"a\"] => [\"zz\"],  (with the comma behind, making it a Positional, instead of a Pair), resulting in the behavior shown as output.</p>","pred":"<p><pre><code>method pred(Str:D: --> Str:D)</code></pre></p><p>Returns the string decremented by one.</p><p>String decrementing is \"magical\" just like string increment (see succ). It fails on underflow</p><p><pre><code>'b0'.pred;           # RESULT: «a9»\n'a0'.pred;           # Failure\n'img002.png'.pred;   # RESULT: «img001.png»\n</code></pre></p>","encode":"<p><pre><code>multi method encode(Str:D $encoding = 'utf8', :$replacement, Bool() :$translate-nl = False, :$strict)</code></pre></p><p>Returns a Blob which represents the original string in the given encoding and normal form. The actual return type is as specific as possible, so $str.encode('UTF-8') returns a utf8 object, $str.encode('ISO-8859-1') a buf8. If :translate-nl is set to True, it will translate newlines from \\n to \\r\\n, but only in Windows. $replacement indicates how characters are going to be replaced in the case they are not available in the current encoding, while $strict indicates whether unmapped codepoints will still decode; for instance, codepoint 129 which does not exist in windows-1252.</p><p><pre><code>my $str = \"Þor is mighty\";\nsay $str.encode(\"ascii\", :replacement( 'Th') ).decode(\"ascii\");\n# OUTPUT: «Thor is mighty␤»</code></pre></p><p>In this case, any unknown character is going to be substituted by Th. We know in advance that the character that is not known in the ascii encoding is Þ, so we substitute it by its latin equivalent, Th. In the absence of any replacement set of characters, :replacement is understood as a Bool:</p><p><pre><code>say $str.encode(\"ascii\", :replacement).decode(\"ascii\"); # OUTPUT: «?or is mighty␤»\n</code></pre></p><p>If :replacement is not set or assigned a value, the error Error encoding ASCII string: could not encode codepoint 222 will be issued (in this case, since þ is codepoint 222).</p><p>Since the Blob returned by encode is the original string in normal form, and every element of a Blob is a byte, you can obtain the length in bytes of a string by calling a method that returns the size of the Blob on it:</p><p><pre><code>say \"þor\".encode.bytes; # OUTPUT: «4␤»\nsay \"þor\".encode.elems; # OUTPUT: «4␤»\n</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>method Int(Str:D: --> Int:D)</code></pre></p><p>Coerces the string to Int, using the same rules as Str.Numeric.</p>","lc":"<p>Defined as:</p><p><pre><code>multi sub    lc(Str:D  --> Str:D)\nmulti method lc(Str:D: --> Str:D)</code></pre></p><p>Returns a lower-case version of the string.</p><p>Examples:</p><p><pre><code>lc(\"A\"); # RESULT: «\"a\"»\n\"A\".lc;  # RESULT: «\"a\"»</code></pre></p>","unival":"<p><pre><code>multi method unival(Str:D --> Numeric)</code></pre></p><p>Returns the numeric value that the first codepoint in the invocant represents, or NaN if it's not numeric.</p><p><pre><code>say '4'.unival;     # OUTPUT: «4␤»\nsay '¾'.unival;     # OUTPUT: «0.75␤»\nsay 'a'.unival;     # OUTPUT: «NaN␤»</code></pre></p>","contains":"<p>Defined as:</p><p><pre><code>multi method contains(Str:D: Cool:D $needle --> Bool:D)\nmulti method contains(Str:D: Str:D $needle --> Bool:D)\nmulti method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\nmulti method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)</code></pre></p><p>Coerces the invocant (represented in the signature by Str:D:, that would be the haystack) and first argument (which we are calling $needle) to Str (if it's not already, that is, in the first and third multi forms), and searches for $needle in the invocant (or haystack) starting from $pos characters into the string, if that is included as an argument.</p><p>Returns True if $needle is found. $pos is an optional parameter, and if it's not present, contains will search from the beginning of the string (using the first two forms of the multi).</p><p><pre><code>say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\nsay \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\nsay \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\nsay \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\nsay \"Hello, World\".contains(',');          # OUTPUT: «True␤»\nsay \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\nsay \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»</code></pre></p><p>In the first example, coercion is used to convert a List to a Str. In the 4th case, the 'Hello' string is not found since we have started looking at the second position in it (index 1). Note that because of how a List or Array is coerced into a Str, the results may sometimes be surprising. See traps.</p>","NFC":"<p><pre><code>method NFC(Str:D: --> NFC:D)</code></pre></p><p>Returns a codepoint string in NFC format (Unicode Normalization Form C / Composed).</p>","NFKD":"<p><pre><code>method NFKD(Str:D: --> NFKD:D)</code></pre></p><p>Returns a codepoint string in NFKD format (Unicode Normalization Form KD / Compatibility Decomposed).</p>","NFKC":"<p><pre><code>method NFKC(Str:D: --> NFKC:D)</code></pre></p><p>Returns a codepoint string in NFKC format (Unicode Normalization Form KC / Compatibility Composed).</p>","substr":"<p><pre><code>multi sub    substr(Str:D $s, $from, $chars?  --> Str:D)\nmulti sub    substr(Str:D $s, Range  $from-to --> Str:D)\nmulti method substr(Str:D $s: $from, $chars?  --> Str:D)\nmulti method substr(Str:D $s: Range $from-to  --> Str:D)</code></pre></p><p>Returns a substring of the original string, between the indices specified by $from-to's endpoints (coerced to Int) or from index $from and of length $chars.</p><p>Both $from and $chars can be specified as Callable, which will be invoked with the length of the original string and the returned value will be used as the value for the argument. If $from or $chars are not Callable, they'll be coerced to Int.</p><p>If $chars is omitted or is larger than the available characters, the string from $from until the end of the string is returned. If $from-to's starting index or $from is less than zero, X::OutOfRange exception is thrown. The $from-to's ending index is permitted to extend past the end of string, in which case it will be equivalent to the index of the last character.</p><p><pre><code>say substr(\"Long string\", 3..6);     # RESULT: «g st␤»\nsay substr(\"Long string\", 6, 3);     # RESULT: «tri␤»\nsay substr(\"Long string\", 6);        # RESULT: «tring␤»\nsay substr(\"Long string\", 6, *-1);   # RESULT: «trin␤»\nsay substr(\"Long string\", *-3, *-1); # RESULT: «in␤»</code></pre></p>","trim-leading":"<p><pre><code>method trim-leading(Str:D: --> Str)</code></pre></p><p>Removes the whitespace characters from the beginning of a string. See also trim.</p>","starts-with":"<p><pre><code>multi method starts-with(Str:D: Str(Cool) $needle --> Bool:D)</code></pre></p><p>Returns True if the invocant is identical to or starts with $needle.</p><p><pre><code>say \"Hello, World\".starts-with(\"Hello\");     # OUTPUT: «True␤»\nsay \"https://raku.org/\".starts-with('ftp');  # OUTPUT: «False␤»</code></pre></p>","chars":"<p><pre><code>multi sub    chars(Cool  $x --> Int:D)\nmulti sub    chars(Str:D $x --> Int:D)\nmulti sub    chars(str   $x --> int)\nmulti method chars(Str:D:   --> Int:D)</code></pre></p><p>Returns the number of characters in the string in graphemes. On the JVM, this currently erroneously returns the number of codepoints instead.</p>","chop":"<p><pre><code>multi method chop(Str:D:)\nmulti method chop(Str:D: Int() $chopping)</code></pre></p><p>Returns the string with $chopping characters removed from the end.</p><p><pre><code>say \"Whateverable\".chop(3.6);  # OUTPUT: «Whatevera␤»\nmy $string= \"Whateverable\";\nsay $string.chop(\"3\");         # OUTPUT: «Whatevera␤»</code></pre></p><p>The $chopping positional is converted to Int before being applied to the string.</p>","indices":"<p>Defined as:</p><p><pre><code>multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\nmulti method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)</code></pre></p><p>Searches for all occurrences of $needle in the string starting from position $start, or zero if it is not specified, and returns a List with all offsets in the string where $needle was found, or an empty list if it was not found.</p><p>If the optional parameter :overlap is specified the search continues from the index directly following the previous match, otherwise the search will continue after the previous match.</p><p><pre><code>say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\nsay \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\nsay \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\nsay \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»</code></pre></p>","samemark":"<p><pre><code>multi sub samemark(Str:D $string, Str:D $pattern --> Str:D)\nmethod    samemark(Str:D: Str:D $pattern --> Str:D)</code></pre></p><p>Returns a copy of $string with the mark/accent information for each character changed such that it matches the mark/accent of the corresponding character in $pattern. If $string is longer than $pattern, the remaining characters in $string receive the same mark/accent as the last character in $pattern. If $pattern is empty no changes will be made.</p><p>Examples:</p><p><pre><code>say 'åäö'.samemark('aäo');                        # OUTPUT: «aäo␤»\nsay 'åäö'.samemark('a');                          # OUTPUT: «aao␤»\n\nsay samemark('Pêrl', 'a');                        # OUTPUT: «Perl␤»\nsay samemark('aöä', '');                          # OUTPUT: «aöä␤»</code></pre></p>","words":"<p><pre><code>multi method words(Str:D: $limit)\nmulti method words(Str:D:)</code></pre></p><p>Returns a list of non-whitespace bits, i.e. the same as a call to $input.comb( / \\S+ /, $limit ) would.</p><p>Examples:</p><p><pre><code>say \"a\\nb\\n\".words.perl;       # OUTPUT: «(\"a\", \"b\").Seq␤»\nsay \"hello world\".words.perl;  # OUTPUT: «(\"hello\", \"world\").Seq␤»\nsay \"foo:bar\".words.perl;      # OUTPUT: «(\"foo:bar\",).Seq␤»\nsay \"foo:bar\\tbaz\".words.perl; # OUTPUT: «(\"foo:bar\", \"baz\").Seq␤»</code></pre></p><p>It can also be used as a subroutine, turning the first argument into the invocant. $limit is optional, but if it is provided (and not equal to Inf), it will return only the first $limit words.</p><p><pre><code>say words(\"I will be very brief here\", 2); # OUTPUT: «(I will)␤»</code></pre></p>","Numeric":"<p>Defined as:</p><p><pre><code>method Numeric(Str:D: --> Numeric:D)</code></pre></p><p>Coerces the string to Numeric using semantics equivalent to val routine. Fails with X::Str::Numeric if the coercion to a number cannot be done.</p><p>Only Unicode characters with property Nd, as well as leading and trailing whitespace are allowed, with the special case of the empty string being coerced to 0. Synthetic codepoints (e.g. \"7\\x[308]\") are forbidden.</p><p>While Nl and No characters can be used as numeric literals in the language, their conversion via Str.Numeric will fail, by design. See unival if you need to coerce such characters to Numeric.</p>","chomp":"<p>Defined as:</p><p><pre><code>multi sub    chomp(Str:D  --> Str:D)\nmulti method chomp(Str:D: --> Str:D)</code></pre></p><p>Returns the string with a logical newline (any codepoint that has the NEWLINE property) removed from the end.</p><p>Examples:</p><p><pre><code>say chomp(\"abc\\n\");       # OUTPUT: «abc␤»\nsay \"def\\r\\n\".chomp;      # OUTPUT: «def␤» NOTE: \\r\\n is a single grapheme!\nsay \"foo\\r\".chomp;        # OUTPUT: «foo␤»</code></pre></p>","indent":"<p><pre><code>multi method indent(Int $steps where { $_ == 0 } )\nmulti method indent(Int $steps where { $_ > 0  } )\nmulti method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )</code></pre></p><p>Indents each line of the string by $steps. If $steps is negative, it outdents instead. If $steps is *, then the string is outdented to the margin:</p><p><pre><code>\"  indented by 2 spaces\\n    indented even more\".indent(*)\n    eq \"indented by 2 spaces\\n  indented even more\"</code></pre></p>","wordcase":"<p><pre><code>multi sub    wordcase(Cool $x  --> Str)\nmulti sub    wordcase(Str:D $x --> Str)\nmulti method wordcase(Str:D: :&filter = &tclc, Mu :$where = True --> Str)\n</code></pre></p><p>Returns a string in which &filter has been applied to all the words that match $where. By default, this means that the first letter of every word is capitalized, and all the other letters lowercased.</p>","rindex":"<p><pre><code>multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\nmulti method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)</code></pre></p><p>Returns the last position of $needle in $haystack not after $startpos. Returns Nil if $needle wasn't found.</p><p>Examples:</p><p><pre><code>say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\nsay rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»</code></pre></p>","ACCEPTS":"<p><pre><code>multi method ACCEPTS(Str:D: $other)</code></pre></p><p>Returns True if the string is the same as $other.</p>","ords":"<p><pre><code>multi method ords(Str:D: --> Seq)</code></pre></p><p>Returns a list of Unicode codepoint numbers that describe the codepoints making up the string.</p><p>Example:</p><p><pre><code>\"aå«\".ords; # (97 229 171)</code></pre></p><p>Strings are represented as graphemes. If a character in the string is represented by multiple codepoints, then all of those codepoints will appear in the result of ords. Therefore, the number of elements in the result may not always be equal to chars, but will be equal to codes; codes computes the codepoints in a different way, so the result might be faster.</p><p>The codepoints returned will represent the string in NFC. See the NFD, NFKC, and NFKD methods if other forms are required.</p>","ord":"<p><pre><code>multi sub    ord(Str:D  --> Int:D)\nmulti method ord(Str:D: --> Int:D)</code></pre></p><p>Returns the codepoint number of the base characters of the first grapheme in the string.</p><p>Example:</p><p><pre><code>ord(\"A\"); # 65\n\"«\".ord;  # 171</code></pre></p>","substr-rw":"<p><pre><code>method substr-rw($from, $length = *)</code></pre></p><p>A version of substr that returns a Proxy functioning as a writable reference to a part of a string variable. Its first argument, $from specifies the index in the string from which a substitution should occur, and its last argument, $length specifies how many characters are to be replaced. If not specified, $length defaults to the length of the string.</p><p>For example, in its method form, if one wants to take the string \"abc\" and replace the second character (at index 1) with the letter \"z\", then one does this:</p><p><pre><code>my $string = \"abc\";\n$string.substr-rw(1, 1) = \"z\";\n$string.say;                         # OUTPUT: «azc␤»</code></pre></p><p>Note that new characters can be inserted as well:</p><p><pre><code>my $string = 'azc';\n$string.substr-rw(2, 0) = \"-Zorro-\"; # insert new characters BEFORE the character at index 2\n$string.say;                         # OUTPUT: «az-Zorro-c␤»</code></pre></p><p>substr-rw also has a function form, so the above examples can also be written like so:</p><p><pre><code>my $string = \"abc\";\nsubstr-rw($string, 1, 1) = \"z\";\n$string.say;                          # OUTPUT: «azc␤»\nsubstr-rw($string, 2, 0) = \"-Zorro-\";\n$string.say;                          # OUTPUT: «az-Zorro-c␤»</code></pre></p><p>It is also possible to alias the writable reference returned by substr-rw for repeated operations:</p><p><pre><code>my $string = \"A character in the 'Flintstones' is: barney\";\n$string ~~ /(barney)/;\nmy $ref := substr-rw($string, $0.from, $0.to-$0.from);\n$string.say;\n# OUTPUT: «A character in the 'Flintstones' is: barney␤»\n$ref = \"fred\";\n$string.say;\n# OUTPUT: «A character in the 'Flintstones' is: fred␤»\n$ref = \"wilma\";\n$string.say;\n# OUTPUT: «A character in the 'Flintstones' is: wilma␤»</code></pre></p>","substr-eq":"<p><pre><code>multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\nmulti method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)</code></pre></p><p>Returns True if the $test-string exactly matches the String object, starting from the given initial index $from. For example, beginning with the string \"foobar\", the substring \"bar\" will match from index 3:</p><p><pre><code>my $string = \"foobar\";\nsay $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»</code></pre></p><p>However, the substring \"barz\" starting from index 3 won't match even though the first three letters of the substring do match:</p><p><pre><code>my $string = \"foobar\";\nsay $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»</code></pre></p><p>Naturally, to match the entire string, one merely matches from index 0:</p><p><pre><code>my $string = \"foobar\";\nsay $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»</code></pre></p><p>Since this method is inherited from the Cool type, it also works on integers. Thus the integer 42 will match the value 342 starting from index 1:</p><p><pre><code>my $integer = 342;\nsay $integer.substr-eq(42, 1);      # OUTPUT: «True␤»</code></pre></p><p>As expected, one can match the entire value by starting at index 0:</p><p><pre><code>my $integer = 342;\nsay $integer.substr-eq(342, 0);     # OUTPUT: «True␤»</code></pre></p><p>Also using a different value or an incorrect starting index won't match:</p><p><pre><code>my $integer = 342;\nsay $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\nsay $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»</code></pre></p>","subst-mutate":"<p>NOTE: .subst-mutate is deprecated in the 6.d version, and will be removed in future ones. You can use subst with .= method call assignment operator or s/// substitution operator instead. </p><p>Where subst returns the modified string and leaves the original unchanged, it is possible to mutate the original string by using subst-mutate. If the match is successful, the method returns a Match object representing the successful match, otherwise returns Nil. If :nth (or one of its aliases) with Iterable value, :g, :global, or :x arguments are used, returns a List of Match objects, or an empty List if no matches occurred.</p><p><pre><code>my $some-string = \"Some foo\";\nmy $match = $some-string.subst-mutate(/foo/, \"string\");\nsay $some-string;  # OUTPUT: «Some string␤»\nsay $match;        # OUTPUT: «｢foo｣␤»\n$some-string.subst-mutate(/<[oe]>/, '', :g); # remove every o and e, notice the :g named argument from .subst</code></pre></p><p>If a Regex $matcher is used, the $/ special variable will be set to Nil (if no matches occurred), a Match object, or a List of Match objects (if multi-match options like :g are used).</p>","subst":"<p><pre><code>multi method subst(Str:D: $matcher, $replacement, *%opts)</code></pre></p><p>Returns the invocant string where $matcher is replaced by $replacement (or the original string, if no match was found).</p><p>There is an in-place syntactic variant of subst spelled s/matcher/replacement/ and with adverb following the s or inside the matcher.</p><p>$matcher can be a Regex, or a literal Str. Non-Str matcher arguments of type Cool are coerced to Str for literal matching. If a Regex $matcher is used, the $/ special variable will be set to Nil (if no matches occurred), a Match object, or a List of Match objects (if multi-match options like :g are used).</p>","univals":"<p><pre><code>multi method univals(Str:D --> List)</code></pre></p><p>Returns a list of numeric values represented by each codepoint in the invocant string, and NaN for non-numeric characters.</p><p><pre><code>say \"4a¾\".univals;  # OUTPUT: «(4 NaN 0.75)␤»</code></pre></p>","comb":"<p><pre><code>multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\nmulti sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\nmulti sub    comb(Int:D $size, Str:D $input, $limit = Inf)\nmulti method comb(Str:D $input:)\nmulti method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\nmulti method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\nmulti method comb(Str:D $input: Int:D $size, $limit = Inf)</code></pre></p><p>Searches for $matcher in $input and returns a Seq of non-overlapping matches limited to at most $limit matches. If $matcher is a Regex, each Match object is converted to a Str, unless $match is set.</p><p>If no matcher is supplied, a Seq of characters in the string is returned, as if the matcher was rx/./.</p><p>Examples:</p><p><pre><code>say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\nsay \"abc\".comb(:match).perl;         # OUTPUT: «(｢a｣ ｢b｣ ｢c｣)␤»\nsay 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\nsay 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\nsay comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\nsay comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\nsay comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\nsay comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\nsay comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»</code></pre></p><p>If the matcher is an integer value, comb behaves as if the matcher was rx/ . ** {1..$matcher} /, but which is optimized to be much faster.</p><p>Note that a Regex matcher may control which portion of the matched text is returned by using features which explicitly set the top-level capture.</p>","tc":"<p><pre><code>multi sub    tc(Str:D  --> Str:D)\nmulti method tc(Str:D: --> Str:D)</code></pre></p><p>Does a Unicode \"titlecase\" operation, that is changes the first character in the string to title case, or to upper case if the character has no title case mapping</p>","NFD":"<p><pre><code>method NFD(Str:D: --> NFD:D)</code></pre></p><p>Returns a codepoint string in NFD format (Unicode Normalization Form D / Decomposed).</p>","parse-base":"<p><pre><code>multi sub    parse-base(Str:D $num, Int:D $radix --> Numeric)\nmulti method parse-base(Str:D $num: Int:D $radix --> Numeric)</code></pre></p><p>Performs the reverse of base by converting a string with a base-$radix number to its Numeric equivalent. Will fail if radix is not in range 2..36 or if the string being parsed contains characters that are not valid for the specified base.</p><p><pre><code>1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n'Raku'.parse-base(36).say;        # OUTPUT: «1273422␤»\n'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»</code></pre></p><p>See also: :16<FF> syntax for number literals</p>","match":"<p><pre><code>method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)</code></pre></p><p>Performs a match of the string against $pat and returns a Match object if there is a successful match; it returns (Any) otherwise. Matches are stored in the default match variable $/. If $pat is not a Regex object, match will coerce the argument to a Str and then perform a literal match against $pat.</p><p>A number of optional named parameters can be specified, which alter how the match is performed.</p>* <p>:continue</p><br><p>The :continue adverb takes as an argument the position where the regex should start to search. If no position is specified for :c it will default to 0 unless $/ is set, in which case it defaults to $/.to.</p>* <p>:pos</p><br><p>Takes a position as an argument. Fails if regex cannot be matched from that position, unlike :continue.</p>* <p>:global</p><br><p>Instead of searching for just one match and returning a Match object, search for every non-overlapping match and return them in a List.</p>* <p>:overlap</p><br><p>Finds all matches including overlapping matches, but only returns one match from each starting position.</p>* <p>:exhaustive</p><br><p>Finds all possible matches of a regex, including overlapping matches and matches that start at the same position.</p>* <p>:st, :nd, :rd, :nth</p><br><p>Returns the nth match in the string. The argument can be a Numeric or an Iterable producing monotonically increasing numbers (that is, the next produced number must be larger than the previous one). The Iterable will be lazily reified and if non-monotonic sequence is encountered an exception will be thrown.</p><p>If Iterable argument is provided the return value and $/ variable will be set to a possibly-empty List of Match objects.</p>* <p>:x</p><br><p>Takes as an argument the number of matches to return, stopping once the specified number of matches has been reached. The value must be a Numeric or a Range; other values will cause .match to return a Failure containing X::Str::Match::x exception.</p><p>Examples:</p><p><pre><code>say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\nsay \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\nsay \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\nsay \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\nsay \"abracadabra\".match(/ a .* a /, :exhaustive);\n# OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\nsay 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\nsay 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\nsay \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\nsay \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\nsay \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\nsay \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\nsay \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»\n</code></pre></p>"},"prefix":"<p><pre><code>class Str is Cool does Stringy { }</code></pre></p><p>Built-in class for strings. Objects of type Str are immutable, but read the FAQ to understand precisely what this means.</p>","name":"Str"},"Mix":{"name":"Mix","defs":{"Bag":"<p>Defined as:</p><p><pre><code>method Bag (--> Bag:D)</code></pre></p><p>Coerces the Mix to a Bag. The weights are convert to Int, which means the number of keys in the resulting Bag can be fewer than in the original Mix, if any of the weights are negative or truncate to zero.</p>","BagHash":"<p>Defined as:</p><p><pre><code>method BagHash (--> BagHash:D)</code></pre></p><p>Coerces the Mix to a BagHash. The weights are convert to Int, which means the number of keys in the resulting BagHash can be fewer than in the original Mix, if any of the weights are negative or truncate to zero.</p>","reverse":"<p>Note: This method is inherited from Any, however, Mixes do not have an inherent order and you should not trust it returning a consistent output.</p>"},"prefix":"<p><pre><code>class Mix does Mixy { }</code></pre></p><p>A Mix is an immutable collection of distinct elements in no particular order that each have a real-number weight assigned to them. (For mutable mixes, see MixHash instead.)</p><p>Mixes are often used for performing weighted random selections - see .roll.</p><p>Objects/values of any type are allowed as mix elements. Within a Mix, items that would compare positively with the === operator are considered the same element, with a combined weight.</p><p><pre><code>my $recipe = (butter => 0.22, sugar => 0.1,\n              flour => 0.275, sugar => 0.02).Mix;\n\nsay $recipe.elems;      # OUTPUT: «3␤»\nsay $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\nsay $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\nsay $recipe.total;      # OUTPUT: «0.615␤»\n</code></pre></p><p>Mixes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding numeric weight for keys that are elements of the mix, and 0 for keys that aren't:</p><p><pre><code>my $recipe = (butter => 0.22, sugar => 0.1,\n              flour => 0.275, sugar => 0.02).Mix;\nsay $recipe<butter>;     # OUTPUT: «0.22␤»\nsay $recipe<sugar>;      # OUTPUT: «0.12␤»\nsay $recipe<chocolate>;  # OUTPUT: «0␤»</code></pre></p>"},"IO::Socket::Async":{"name":"IO::Socket::Async","defs":{"peer-host":"<p><pre><code>method peer-host(--> Str)</code></pre></p><p>Returns the IP address of the remote end of this socket.</p>","socket-port":"<p><pre><code>method socket-port(--> Int)</code></pre></p><p>Returns the port of the local end of this socket.</p>","Supply":"<p><pre><code>method Supply(:$bin, :$buf = buf8.new --> Supply)</code></pre></p><p>Returns a Supply which can be tapped to obtain the data read from the connected IO::Socket::Async as it arrives. By default the data will be emitted as characters, but if the :bin adverb is provided a Buf of bytes will be emitted instead, optionally in this case you can provide your own Buf with the :buf named parameter.</p><p>A UDP socket in character mode will treat each packet as a complete message and decode it. In the event of a decoding error, the Supply will quit.</p><p>On the other hand, a TCP socket treats the incoming packets as part of a stream, and feeds the incoming bytes into a streaming decoder. It then emits whatever characters the decoder considers ready. Since strings work at grapheme level in Raku, this means that only known complete graphemes will be emitted. For example, if the UTF-8 encoding were being used and the last byte in the packet decoded to a, this would not be emitted since the next packet may include a combining character that should form a single grapheme together with the a. Control characters (such as \\n) always serve as grapheme boundaries, so any text-based protocols that use newlines or null bytes as terminators will not need special consideration. A TCP socket will also quit upon a decoding error.</p>","listen":"<p><pre><code>method listen(Str $host, Int $port --> Supply)</code></pre></p><p>Creates a listening socket on the specified $host and $port, returning a Supply to which the accepted client IO::Socket::Asyncs will be emitted. This Supply should be tapped start listening for client connections. You can use $port = 0 if you want the operating system to find one for you.</p><p>To close the underlying listening socket, the Tap returned by tapping the listener should be closed.</p><p>For example, when using tap:</p><p><pre><code>my $listener = IO::Socket::Async.listen('127.0.0.1', 8080);\nmy $tap = $listener.tap({ ... });\n\n# When you want to close the listener\n$tap.close;\n</code></pre></p><p>Or when using whenever:</p><p><pre><code>my $listener = IO::Socket::Async.listen('127.0.0.1', 5000);\nmy $tap;\nreact {\n    $tap = do whenever $listener -> $conn { ... }\n}\n\n# When you want to close the listener, you can still use:\n$tap.close;\n</code></pre></p>","udp":"<p><pre><code>method udp(IO::Socket::Async:U: :$broadcast --> IO::Socket::Async)</code></pre></p><p>Returns an initialized IO::Socket::Async client object that is configured to send UDP messages using print-to or write-to. The :broadcast adverb will set the SO_BROADCAST option which will allow the socket to send packets to a broadcast address.</p>","connect":"<p><pre><code>method connect(Str $host, Int $port --> Promise)</code></pre></p><p>Attempts to connect to the TCP server specified by $host and $port, returning a Promise that will either be kept with a connected IO::Socket::Async or broken if the connection cannot be made.</p>","close":"<p><pre><code>method close()</code></pre></p><p>Close the connected client IO::Socket::Async which will have been obtained from the listen Supply or the connect Promise.</p><p>In order to close the underlying listening socket created by listen you can close the Tap. See listen for examples.</p>","print-to":"<p><pre><code>method print-to(IO::Socket::Async:D: Str() $host, Int() $port, Str() $str --> Promise)</code></pre></p><p>This is the equivalent of print for UDP sockets that have been created with the udp method, it will try send a UDP message of $str to the specified $host and $port returning a Promise that will be kept when the data is successfully sent or broken if it was unable to send the data. In order to send to a broadcast address the :broadcast flag must have been specified when the socket was created.</p>","print":"<p><pre><code>method print(Str $str --> Promise)</code></pre></p><p>Attempt to send $str on the IO::Socket::Async that will have been obtained indirectly via connect or listen, returning a Promise that will be kept with the number of bytes sent or broken if there was an error sending.</p>","write-to":"<p><pre><code>method write-to(IO::Socket::Async:D: Str() $host, Int() $port, Blob $b --> Promise)</code></pre></p><p>This is the equivalent of write for UDP sockets that have been created with the udp method. It will try send a UDP message comprised of the bytes in the Blob $b to the specified $host and $port returning a Promise that will be kept when the data is successfully sent or broken if it was unable to send the data. In order to send to a broadcast address the :broadcast flag must have been specified when the socket was created.</p>","peer-port":"<p><pre><code>method peer-port(--> Int)</code></pre></p><p>Returns the port of the remote end of this socket.</p>","bind-udp":"<p><pre><code>method bind-udp(IO::Socket::Async:U: Str() $host, Int() $port, :$broadcast --> IO::Socket::Async)</code></pre></p><p>This returns an initialized IO::Socket::Async server object that is configured to receive UDP messages sent to the specified $host and $port and is equivalent to listen for a TCP socket. The :broadcast adverb can be specified to allow the receipt of messages sent to the broadcast address.</p>","socket-host":"<p><pre><code>method socket-host(--> Str)</code></pre></p><p>Returns the IP address of the local end of this socket.</p>","write":"<p><pre><code>method write(Blob $b --> Promise)</code></pre></p><p>This method will attempt to send the bytes in $b on the IO::Socket::Async that will have been obtained indirectly via connect or listen, returning a Promise that will be kept with the number of bytes sent or broken if there was an error sending.</p>"},"prefix":"<p><pre><code>class IO::Socket::Async {}</code></pre></p><p>IO::Socket::Async|/type/IO::Socket::Async provides asynchronous sockets, for both the server and the client side.</p><p>Here is a simple example of a simple \"hello world\" HTTP server that listens on port 3333:</p><p><pre><code>react {\n    whenever IO::Socket::Async.listen('0.0.0.0', 3333) -> $conn {\n        whenever $conn.Supply.lines -> $line {\n            $conn.print: qq:heredoc/END/;\n                HTTP/1.1 200 OK\n                Content-Type: text/html; charset=UTF-8\n                Content-Encoding: UTF-8\n\n                <html>\n                <body>\n                    <h1>Hello World!</h1>\n                    <p>{ $line }</p>\n                </body>\n                </html>\n                END\n            $conn.close;\n        }\n    }\n    CATCH {\n        default {\n            say .^name, ': ', .Str;\n            say \"handled in $?LINE\";\n        }\n    }\n}\n</code></pre></p><p>And a client that connects to it, and prints out what the server answers:</p><p><pre><code>await IO::Socket::Async.connect('127.0.0.1', 3333).then( -> $promise {\n    given $promise.result {\n        .print(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\");\n        react {\n            whenever .Supply() -> $v {\n                $v.print;\n                done;\n            }\n        }\n        .close;\n    }\n});\n</code></pre></p><p>IO::Socket::Async can also send and receive UDP messages An example server that outputs all the data it receives would be:</p><p><pre><code>my $socket = IO::Socket::Async.bind-udp('localhost', 3333);\n\nreact {\n    whenever $socket.Supply -> $v {\n        if $v.chars > 0 {\n            say $v;\n        }\n    }\n}\n</code></pre></p><p>And an associated client might be:</p><p><pre><code>my $socket = IO::Socket::Async.udp();\nawait $socket.print-to('localhost', 3333, \"Hello, Raku!\");\n</code></pre></p><p>The CATCH phaser can be included to deal specifically with problems that might occur in this kind of sockets, such as a port being already taken:</p><p><pre><code>react {\n    whenever IO::Socket::Async.listen('0.0.0.0', 3000) -> $conn {\n        whenever $conn.Supply.lines -> $line {\n            $conn.print: qq:heredoc/END/;\n                HTTP/1.1 200 OK\n                Content-Type: text/html; charset=UTF-8\n                Content-Encoding: UTF-8\n\n                <html>\n                <body>\n                    <h1>Hello World!</h1>\n                    <p>{ $line }</p>\n                </body>\n                </html>\n                END\n            $conn.close;\n        }\n        QUIT {\n            default {\n                say .^name, '→ ', .Str;\n                say \"handled in line $?LINE\";\n            }\n        }\n    }\n\n}\n# Will print this, if address 3000 is already in use:\n# X::AdHoc→ address already in use\n# handled in 23\n</code></pre></p><p>Main difference with using other phasers such as CATCH is that this kind of exception will be caught within the whenever block and will put exiting the program, or not, under your control.</p>"},"X::Syntax::Regex::Adverb":{"prefix":"<p><pre><code>class X::Syntax::Regex::Adverb does X::Syntax { }</code></pre></p><p>Syntax error thrown when an unrecognized or illegal regex adverb is encountered.</p><p>For example</p><p><pre><code>rx:g/a/\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nAdverb g not allowed on rx\n</code></pre></p><p>because :g belongs to a match operation, not a regex itself.</p>","defs":{"adverb":"<p><pre><code>method adverb(--> Str:D)</code></pre></p><p>Returns the illegally used adverb</p>"},"name":"X::Syntax::Regex::Adverb"},"X::Composition::NotComposable":{"defs":{"target-name":"<p><pre><code>method target-name(--> Str:D)</code></pre></p><p>Returns the name of the type that should be composed, but failed.</p>"},"prefix":"<p><pre><code>class X::Composition::NotComposable is Exception { }</code></pre></p><p>Thrown when trying to compose a type into a target type, but the composer type cannot be used for composition (roles and enums are generally OK).</p><p>For example</p><p><pre><code>class A { }\nclass B does A { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\n␤A is not composable, so B cannot compose it\n</code></pre></p><p>because does is reserved for role composition, and A is not a role, nor something that knows how to turn into a role.</p><p>The fix is to either make A a role, or use inheritance (class B is A { }) instead.</p>","name":"X::Composition::NotComposable"},"Array":{"prefix":"<p><pre><code>class Array is List {}</code></pre></p><p>An Array is a List which forces all its elements to be scalar containers, which means you can assign to array elements.</p><p>Array implements Positional and as such provides support for subscripts.</p><p>Note from version 6.d, .perl can be called on multi-dimensional arrays.</p>","defs":{"prepend":"<p>Defined as</p><p><pre><code>sub prepend(\\array, |elems)\nmulti method prepend(Array:D: \\values)\nmulti method prepend(Array:D: **@values is raw)</code></pre></p><p>Adds the elements from LIST to the front of the array, modifying it in-place.</p><p>Example:</p><p><pre><code>my @foo = <a b c>;\n@foo.prepend: 1, 3 ... 11;\nsay @foo;                   # OUTPUT: «[1 3 5 7 9 11 a b c]␤»</code></pre></p><p>The difference from method unshift is that if you prepend a single array or list argument, prepend will flatten that array / list, whereas unshift prepends the list / array as just a single element.</p>","shift":"<p>Defined as:</p><p><pre><code>multi sub    shift(Array:D )\nmulti method shift(Array:D:)</code></pre></p><p>Removes and returns the first item from the array. Fails for an empty arrays.</p><p>Example:</p><p><pre><code>my @foo = <a b>;\nsay @foo.shift;             # OUTPUT: «a␤»\nsay @foo.shift;             # OUTPUT: «b␤»\nsay @foo.shift;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Cannot::Empty: Cannot shift from an empty Array␤»</code></pre></p>","of":"<p>Defined as:</p><p><pre><code>method of</code></pre></p><p>Returns the type constraint for the values of the invocant. By default, i.e. if no type constraint is given during declaration, the method returns (Mu).</p><p><pre><code>my @a1 = 1, 'two', 3.14159;              # (no type constraint specified)\nsay @a1.of;                              # OUTPUT: «(Mu)␤»\n\nmy Int @a2 = 1, 2, 3;                    # (values must be of type Int)\nsay @a2.of;                              # OUTPUT: «(Int)␤»\n@a2.push: 'd';\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to @a2; expected Int but got Str (\"d\")␤»</code></pre></p>","append":"<p>Defined as</p><p><pre><code>sub append(\\array, |elems)\nmulti method append(Array:D: \\values)\nmulti method append(Array:D: **@values is raw)</code></pre></p><p>Appends the argument list to the array passed as the first argument. This modifies the array in-place. Returns the modified array. Throws for lazy arrays.</p><p>The difference from method push is that if you append a single array or list argument, append will flatten that array / list, whereas push appends the list / array as just a single element.</p><p>Example:</p><p><pre><code>my @a = <a b c>;\nmy @b = <d e f>;\n@a.append: @b;\nsay @a.elems;               # OUTPUT: «6␤»\nsay @a;                     # OUTPUT: «[a b c d e f]␤»</code></pre></p>","gist":"<p>Exactly the same as List.gist, except using square brackets for surrounding delimiters.</p>","clone":"<p>Defined as:</p><p><pre><code>method clone(Array:D: --> Array:D)</code></pre></p><p>Clones the original Array. Modifications of elements in the clone are not propagated to the original and vice-versa:</p><p><pre><code>my @a = <a b c>; my @b = @a.clone;\n@b[1] = 42; @a.push: 72;\nsay @b; # OUTPUT: «[a 42 c]␤»\nsay @a; # OUTPUT: «[a b c 72]␤»</code></pre></p><p>However, note that the reifier is shared between the two Arrays, so both Arrays will have the same elements even when each is randomly-generated on reification and each element will be reified just once, regardless of whether the reification was done by the clone or the original Array. Note: just as reifying an Array from multiple threads is not safe, so is, for example, reifying the clone from one thread while reifying the original from another thread is not safe.</p><p><pre><code>my @a = 1, {rand} … ∞; my @b = @a.clone;\nsay @b[^3]; # OUTPUT: «(1 0.0216426755282736 0.567660896142156)␤»\nsay @a[^3]; # OUTPUT: «(1 0.0216426755282736 0.567660896142156)␤»</code></pre></p>","default":"<p>Defined as:</p><p><pre><code>method default</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when trying to access an element in the Array which has not been previously initialized or when accessing an element which has explicitly been set to Nil. Unless the Array is declared as having a default value by using the is default trait the method returns the type object (Any).</p><p><pre><code>my @a1 = 1, \"two\", 2.718;\nsay @a1.default;                               # OUTPUT: «(Any)␤»\nsay @a1[4];                                    # OUTPUT: «(Any)␤»\n\nmy @a2 is default(17) = 1, \"two\", 3;\nsay @a2.default;                               # OUTPUT: «17␤»\nsay @a2[4];                                    # OUTPUT: «17␤»\n@a2[1] = Nil;                                  # (resets element to its default)\nsay @a2[1];                                    # OUTPUT: «17␤»\n</code></pre></p>","push":"<p>Defined as:</p><p><pre><code>multi sub    push(Array:D, **@values --> Array:D)\nmulti method push(Array:D: **@values --> Array:D)</code></pre></p><p>Adds the @values to the end of the array, and returns the modified array. Throws for lazy arrays.</p><p>Example:</p><p><pre><code>my @foo = <a b c>;\n@foo.push: 'd';\nsay @foo;                   # OUTPUT: «[a b c d]␤»</code></pre></p><p>Note that push does not attempt to flatten its argument list. If you pass an array or list as the thing to push, it becomes one additional element:</p><p><pre><code>my @a = <a b c>;\nmy @b = <d e f>;\n@a.push: @b;\nsay @a.elems;               # OUTPUT: «4␤»\nsay @a[3].join;             # OUTPUT: «def␤»</code></pre></p><p>Only if you supply multiple values as separate arguments to push are multiple values added to the array:</p><p><pre><code>my @a = '1';\nmy @b = <a b>;\nmy @c = <E F>;\n@a.push: @b, @c;\nsay @a.elems;                # OUTPUT: «3␤»</code></pre></p><p>See method append for when you want to append multiple values that are stored in a single array.</p>","splice":"<p>Defined as:</p><p><pre><code>multi sub    splice(@list,   $start = 0, $elems?, *@replacement --> Array)\nmulti method splice(Array:D: $start = 0, $elems?, *@replacement --> Array)</code></pre></p><p>Deletes $elems elements starting from index $start from the Array, returns them and replaces them by @replacement. If $elems is omitted or is larger than the number of elements starting from $start, all the elements starting from index $start are deleted. If both $start and $elems are omitted, all elements are deleted from the Array and returned.</p><p>Each of $start and $elems can be specified as a Whatever or as a Callable that returns an int-compatible value.</p><p>A Whatever $start uses the number of elements of @list (or invocant). A Callable $start is called with one argument—the number of elements in @list—and its return value is used as $start.</p><p>A Whatever $elems deletes from $start to end of @list (same as no $elems). A Callable $elems is called with just one argument—the number of elements in @list minus the value of $start—and its return value is used the value of $elems.</p><p>Example:</p><p><pre><code>my @foo = <a b c d e f g>;\nsay @foo.splice(2, 3, <M N O P>);        # OUTPUT: «[c d e]␤»\nsay @foo;                                # OUTPUT: «[a b M N O P f g]␤»</code></pre></p>","shape":"<p>Defined as:</p><p><pre><code>method shape() { (*,) }</code></pre></p><p>Returns the shape of the array as a list.</p><p>Example:</p><p><pre><code>my @foo[2;3] = ( < 1 2 3 >, < 4 5 6 > ); # Array with fixed dimensions\nsay @foo.shape;                          # OUTPUT: «(2 3)␤»\nmy @bar = ( < 1 2 3 >, < 4 5 6 > );      # Normal array (of arrays)\nsay @bar.shape;                          # OUTPUT: «(*)␤»</code></pre></p>","unshift":"<p>Defined as:</p><p><pre><code>multi sub    unshift(Array:D, **@values --> Array:D)\nmulti method unshift(Array:D: **@values --> Array:D)</code></pre></p><p>Adds the @values to the start of the array, and returns the modified array. Fails if @values is a lazy list.</p><p>Example:</p><p><pre><code>my @foo = <a b c>;\n@foo.unshift: 1, 3 ... 11;\nsay @foo;                   # OUTPUT: «[(1 3 5 7 9 11) a b c]␤»</code></pre></p><p>The notes in the documentation for method push apply, regarding how many elements are added to the array.</p><p>#method prepend is the equivalent for adding multiple elements from one list or array.</p>","elems":"<p>Defined as:</p><p><pre><code>method elems(Array:D: --> Int:D)</code></pre></p><p>Returns the number of elements in the invocant. Throws X::Cannot::Lazy exception if the invocant is lazy. For shaped arrays, returns the outer dimension; see shape if you need information for all dimensions.</p><p><pre><code>say [<foo bar ber>] .elems; # OUTPUT: «3␤»\nsay (my @a[42;3;70]).elems; # OUTPUT: «42␤»\n\ntry [-∞...∞].elems;\nsay $!.^name;               # OUTPUT: «X::Cannot::Lazy␤»</code></pre></p>","pop":"<p>Defined as:</p><p><pre><code>multi sub    pop(Array:D )\nmulti method pop(Array:D:)</code></pre></p><p>Removes and returns the last item from the array. Fails for an empty array.</p><p>Example:</p><p><pre><code>my @foo = <a b>; # a b\n@foo.pop;        # b\npop @foo;        # a\npop @foo;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Cannot::Empty: Cannot pop from an empty Array␤»</code></pre></p>"},"name":"Array"},"IO::ArgFiles":{"name":"IO::ArgFiles","defs":{},"prefix":"<p><pre><code>class IO::ArgFiles is IO::CatHandle { }</code></pre></p><p>This class exists for backwards compatibility reasons and provides no additional methods to IO::CatHandle, so it can be used in the same way as it, for instance, in this way:</p><p><pre><code>my $argfiles = IO::ArgFiles.new(@*ARGS);\n.say for $argfiles.lines;\n</code></pre></p><p>If invoked with perl6 io-argfiles.p6 *.p6 it will print the contents of all the files with that extension in the directory. However, that is totally equivalent to:</p><p><pre><code>my $argfiles = IO::CatHandle.new(@*ARGS);\n.say for $argfiles.lines;\n</code></pre></p>"},"Variable":{"prefix":"<p><pre><code>class Variable {}</code></pre></p><p>Variables have a wealth of compile-time information, but at runtime, accesses to a variable usually act on the value stored inside it, not the variable itself. The runtime class of a variable is Scalar.</p><p>Class Variable holds the compile-time information that traits can use to introspect and manipulate variables.</p>","defs":{},"name":"Variable"},"X::Control":{"name":"X::Control","defs":{},"prefix":"<p><pre><code>role X::Control is Exception { }</code></pre></p><p>This role turns an exception into a control exception, such as CX::Next or CX::Take. It has got no code other than the definition.</p><p>Since Rakudo 2019.03, throwing an object that mixes in this role X::Control can raise a control exception which is caught by the CONTROL phaser instead of CATCH. This allows to define custom control exceptions.</p><p>For example, the custom CX::Oops control exception we define below:</p><p><pre><code>class CX::Vaya does X::Control {\n    has $.message\n}\n\nsub ea {\n    CONTROL {\n        default {\n            say \"Controlled { .^name }: { .message }\"\n        }\n    }\n    CX::Vaya.new( message => \"I messed up!\" ).throw;\n\n}\nea;\n# OUTPUT: «Controlled CX::Vaya: I messed up!␤»\n</code></pre></p>"},"Metamodel::Trusting":{"name":"Metamodel::Trusting","defs":{"trusts":"<p><pre><code>method trusts(Metamodel::Trusting:D: $type --> List)</code></pre></p><p>Returns a list of types that the invocant trusts.</p><p><pre><code>class A { trusts Int; };\nsay .^name for A.^trusts;       # Int</code></pre></p>","add_trustee":"<p><pre><code>method add_trustee(Metamodel::Trusting:D: $type, Mu $trustee)</code></pre></p><p>Trust $trustee.</p><p><pre><code>class A {\n    BEGIN A.^add_trustee(B);\n    # same as 'trusts B';\n}\n</code></pre></p>"},"prefix":"<p><pre><code>role Metamodel::Trusting is SuperClass { ... }\n</code></pre></p><p>Normally, code in a class or role can only access its own private methods. If another type declares that it trusts that first class, then access to private methods of that second type is possible. Metamodel::Trusting implements that aspect of the Raku object system.</p><p><pre><code>class A {\n    my class B {\n        trusts A;   # that's where Metamodel::Trusting comes in\n        method !private_method() {\n            say \"Private method in B\";\n        }\n    }\n    method build-and-poke {\n        # call a private method from B\n        # disallowed if A doesn't trust B\n        B.new()!B::private_method();\n    }\n};\n\nA.build-and-poke;   # Private method in A</code></pre></p>"},"Systemic":{"prefix":"<p>Built-in class for providing built system related information. Usually accessed through dynamic variables mixing this role such as the $*KERNEL, $*VM, or $*PERL.</p>","defs":{"version":"<p>Instance method returning the version of the object as a Version object. Returns a Version object \"unknown\" if the version could not be established.</p>","name":"<p>Instance method returning the name of the object.</p>","config":"<p>Instance returning a hash with object configuration information. Subject to change without notice, but can be helpful in environments where only one type of virtual machine is in use, or to find about the configuration of any other object that mixes in this role.</p>","desc":"<p>Instance method returning the \"desc\" (as in \"description\") of the VM object. Returns a Str type object if the \"desc\" could not be established.</p>","gist":"<p><pre><code>method gist( Systemic:D: )</code></pre></p><p>Instance method returning the name and version of the object.</p><p><pre><code>say $*PERL.gist; # OUTPUT: «Raku (6.c)␤»</code></pre></p><p>$*PERL is an object of the Perl type, which mixes in this role and thus implements this method.</p>","auth":"<p>Instance method returning the \"auth\" (as in \"author\" or \"authority\") of the object. Returns \"unknown\" if the \"auth\" could not be established.</p>","signature":"<p>Instance method returning the signature of the object. Returns a Blob type object if the signature could not be established.</p>"},"name":"Systemic"},"atomicint":{"name":"atomicint","prefix":"<p><pre><code>class atomicint is Int is repr('P6int') { }</code></pre></p><p>An atomicint is a native integer sized such that CPU-provided atomic operations can be performed upon it. On a 32-bit CPU it will typically be 32 bits in size, and on an a 64-bit CPU it will typically be 64 bits in size. It exists to allow writing portable code that uses atomic operations.</p><p>Note: Rakudo releases before 2017.08 had no support for atomicints.</p><p><pre><code># Would typically only work on a 64-bit machine and VM build.\nmy int64 $active = 0;\n$active⚛++;\n\n# Would typically only work on a 32-bit machine and VM build.\nmy int32 $active = 0;\n$active⚛++;\n\n# Will work portably, though can only portably assume range of 32 bits.\nmy atomicint $active = 0;\n$active⚛++;</code></pre></p><p>The use of the atomicint type does not automatically provide atomicity; it must be used in conjunction with the atomic operations.</p><p><pre><code># Correct (will always output 80000)\nmy atomicint $total = 0;\nawait start { for ^20000 { $total⚛++ } } xx 4;\nsay $total;\n\n# *** WRONG *** due to lack of use of the atomicint type.\n# Either works correctly or dies, depending on platform.\nmy int $total = 0;\nawait start { for ^20000 { $total⚛++ } } xx 4;\nsay $total;\n\n# *** WRONG *** due to lack of use of the atomic increment operator.\nmy atomicint $total = 0;\nawait start { for ^20000 { $total++ } } xx 4;\nsay $total;</code></pre></p>","defs":{"&prefix:<--⚛>":"<p><pre><code>multi sub prefix:<--⚛>(atomicint $ is rw)</code></pre></p><p>Performs an atomic decrement on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Returns the value resulting from the decrement. Overflow will wrap around silently.</p>","&infix:<⚛-=>":"<p>Defined as:</p><p><pre><code>multi sub infix:<⚛-=>(atomicint $ is rw, int $value)\nmulti sub infix:<⚛-=>(atomicint $ is rw, Int() $value)</code></pre></p><p>Performs an atomic subtraction on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Evaluates to the result of the subtraction. Underflow will wrap around silently. If $value is too big to unbox to a 64-bit integer, an exception will be thrown. If $value otherwise overflows atomicint then it will be silently truncated before the subtraction is performed.</p>","&postfix:<⚛-->":"<p><pre><code>multi sub postfix:<⚛-->(atomicint $ is rw)</code></pre></p><p>Performs an atomic decrement on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Returns the value as seen before decrementing it. Overflow will wrap around silently.</p>","&postfix:<⚛++>":"<p><pre><code>multi sub postfix:<⚛++>(atomicint $ is rw)</code></pre></p><p>Performs an atomic increment on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Returns the value as seen before incrementing it. Overflow will wrap around silently.</p>","&prefix:<⚛>":"<p><pre><code>multi sub prefix:<⚛>(atomicint $ is rw)</code></pre></p><p>Performs an atomic read of a native integer, which may live in a lexical, attribute, or native array element. Using this operator instead of simply using the variable ensures that the latest update to the variable from other threads will be seen, both by doing any required hardware barriers and also preventing the compiler from lifting reads. For example:</p><p><pre><code>my atomicint $i = 0;\nstart { $i ⚛= 1 }\nwhile ⚛$i == 0 { }</code></pre></p><p>Is certain to terminate, while in:</p><p><pre><code>my atomicint $i = 0;\nstart { $i ⚛= 1 }\nwhile $i == 0 { }</code></pre></p><p>It would be legal for a compiler to observe that $i is not updated in the loop, and so lift the read out of the loop, thus causing the program to never terminate.</p>","&infix:<⚛=>":"<p><pre><code>multi sub infix:<⚛=>(atomicint $ is rw, int $value)\nmulti sub infix:<⚛=>(atomicint $ is rw, Int() $value)</code></pre></p><p>Performs an atomic assignment to a native integer, which may be in a lexical, attribute, or native array element. If $value cannot unbox to a 64-bit native integer due to being too large, an exception will be thrown. If the size of atomicint is only 32 bits, then an out of range $value will be silently truncated. The ⚛= operator ensures that any required barriers are performed such that the changed value will be \"published\" to other threads.</p>","&prefix:<++⚛>":"<p><pre><code>multi sub prefix:<++⚛>(atomicint $ is rw)</code></pre></p><p>Performs an atomic increment on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Returns the value resulting from the increment. Overflow will wrap around silently.</p>","&infix:<⚛+=>":"<p>Defined as:</p><p><pre><code>multi sub infix:<⚛+=>(atomicint $ is rw, int $value)\nmulti sub infix:<⚛+=>(atomicint $ is rw, Int() $value)</code></pre></p><p>Performs an atomic addition on a native integer. This will be performed using hardware-provided atomic operations. Since the operation is atomic, it is safe to use without acquiring a lock. Evaluates to the result of the addition. Overflow will wrap around silently. If $value is too big to unbox to a 64-bit integer, an exception will be thrown. If $value otherwise overflows atomicint then it will be silently truncated before the addition is performed.</p>"}},"X::IO::Unlink":{"name":"X::IO::Unlink","prefix":"<p><pre><code>class X::IO::Unlink does X::IO is Exception { }\n</code></pre></p><p>Error class for failed unlink operation.</p><p>A typical error message is</p><p><pre><code>Failed to remove the file 'secret': Permission defined\n</code></pre></p>","defs":{}},"X::Dynamic::NotFound":{"prefix":"<p><pre><code>class X::Dynamic::NotFound is Exception {}</code></pre></p><p>This exception is raised when a dynamic variable that has not been declared is used.</p><p><pre><code>$*dynamic-not-found = 33;\n# OUTPUT: «Dynamic variable $*dynamic-not-found not found␤»\n</code></pre></p>","defs":{},"name":"X::Dynamic::NotFound"},"X::Syntax::P5":{"name":"X::Syntax::P5","defs":{},"prefix":"<p><pre><code>class X::Syntax::P5 does X::Syntax { }</code></pre></p><p>Syntax error thrown when some piece of code is clearly Perl 5, not Raku.</p><p>For example</p><p><pre><code>for my $a (1, 2) { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nThis appears to be Perl 5 code\n</code></pre></p>"},"X::Proc::Async::OpenForWriting":{"name":"X::Proc::Async::OpenForWriting","prefix":"<p><pre><code>class X::Proc::Async::OpenForWriting is Exception {}</code></pre></p><p>When a Proc::Async object is opened only for reading from the external program (no :w passed to open), and a write operation such as write, print and say is performed, an exception of type X::Proc::Async::OpenForWriting is thrown:</p><p><pre><code>my $proc = Proc::Async.new(\"echo\");\n$proc.start;\n$proc.say(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::OpenForWriting: Process must be opened for writing with :w to call 'say'␤»</code></pre></p><p>To fix that you can use writable commands with :w flag:</p><p><pre><code>my $prog = Proc::Async.new(:w, 'cat');\n$prog.stdout.tap( -> $str {\n    print $str;\n});\nmy $promise = $prog.start;\nawait $prog.say('foo');\n$prog.close-stdin;\nawait $promise;</code></pre></p>","defs":{}},"IO::Spec::QNX":{"name":"IO::Spec::QNX","prefix":"<p><pre><code>class IO::Spec::QNX is IO::Spec { }</code></pre></p><p>This sub-class of IO::Spec specific to QNX will be available via $*SPEC if the perl is running on QNX.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","defs":{}},"IO::Path::Cygwin":{"name":"IO::Path::Cygwin","defs":{"new":"<p>Same as IO::Path.new, except :$SPEC cannot be set and defaults to IO::Spec::Cygwin, regardless of the operating system the code is being run on.</p>"},"prefix":"<p><pre><code>class IO::Path::Cygwin is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Cygwin in the $.SPEC attribute.</p>"},"Distro":{"name":"Distro","defs":{"is-win":"<p>Instance method returning a Bool indicating whether the distribution is a version of the Windows operating system.</p>","path-sep":"<p>Instance method returning the string that can be used to delimit elements in a path specification.</p>"},"prefix":"<p><pre><code>class Distro does Systemic { }</code></pre></p><p>Built-in class for providing distribution related information. Usually accessed through the $*DISTRO dynamic variable.</p>"},"Supplier::Preserving":{"prefix":"<p><pre><code>class Supplier::Preserving is Supplier { }</code></pre></p><p>This is a factory for live Supply-type objects, and it provides the mechanism for emitting new values onto the supplies, whereby values are kept when no consumer has tapped into the Supply. Any tapping will consume the already stored and future values.</p><p>Starting a preserving Supply and consuming its values after it is done:</p><p><pre><code>my $p = Supplier::Preserving.new;\nstart for ^3 {\n    $p.emit($_);\n    LAST {\n        say „done after { now - BEGIN now}s“;\n        $p.done;\n    }\n}\nsleep 2;\nreact {\n    whenever $p.Supply { $_.say; }\n    whenever Promise.in(2) { done }\n}\nsay „also done after { now - BEGIN now }s“</code></pre></p><p>Will output:</p><p><pre><code>done after 0.0638467s\n0\n1\n2\nalso done after 4.0534119s\n</code></pre></p>","defs":{},"name":"Supplier::Preserving"},"X::Attribute::Package":{"prefix":"<p><pre><code>class X::Attribute::Package does X::Comp { }</code></pre></p><p>Compile time error, thrown when the compiler encounters an attribute declaration inside a package that does not support attributes.</p><p>For example</p><p><pre><code>module A { has $.x }\n</code></pre></p><p>dies with</p><p><pre><code>A module cannot have attributes, but you tried to declare '$.x'\n</code></pre></p>","defs":{"name":"<p><pre><code>method name(--> Str:D)</code></pre></p><p>Returns the name of the attribute that triggered this error.</p>"},"name":"X::Attribute::Package"},"X::Promise::Vowed":{"prefix":"<p><pre><code>class X::Promise::Vowed is Exception { }</code></pre></p><p>This exception is thrown when code tries to keep/break an already vowed promise without going through the corresponding Vow object.</p>","defs":{},"name":"X::Promise::Vowed"},"VM":{"name":"VM","prefix":"<p><pre><code>class VM does Systemic { }</code></pre></p><p>Built-in class for providing information about the virtual machine in which Raku is running. Usually accessed through the $*VM dynamic variable.</p>","defs":{"precomp-target":"<p>Instance method returning a string of the value of the compilation target that should be used when precompiling source-files with the VM object.</p>","osname":"<p>Defined as:</p><p><pre><code>multi method osname(VM:U:)\nmulti method osname(VM:D:)</code></pre></p><p>Instance / Class method returning the name of the Operating System, as known by the configuration of the VM object / currently running virtual machine.</p>","precomp-ext":"<p>Instance method returning a string of the extension that should be used for precompiled files of the VM object.</p>"}},"X::TypeCheck::Splice":{"defs":{},"prefix":"<p><pre><code>class X::TypeCheck::Splice is X::TypeCheck does X::Comp { }</code></pre></p><p>Compile time error thrown when a Macro or an unquote/hole in a quasi quote does not return an AST.</p><p>For example</p><p><pre><code>use experimental :macros;\nmacro quasi-ast { quasi { {{{'not AST'}}} };};\nsay quasi-ast;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nType check failed in macro application; expected AST but got Str(\"not AST\")\n</code></pre></p><p>This is because you are purposefully creating something that does not evaluate to an abstract syntax tree. To fix, instead write</p><p><pre><code>use experimental :macros;\nmacro an-ast {\n    quasi { 'yes AST' }\n}\nsay an-ast;              # OUTPUT: «yes AST␤»\n</code></pre></p>","name":"X::TypeCheck::Splice"},"Order":{"name":"Order","prefix":"<p><pre><code>enum Order (:Less(-1), :Same(0), :More(1));</code></pre></p>","defs":{"&infix:<cmp>":"<p><pre><code>multi sub infix:<cmp>(\\a, \\b --> Order:D)</code></pre></p><p>cmp will first try to compare operands as strings (via coercion to Stringy), and, failing that, will try to compare numerically via the <=> operator or any other type-appropriate comparison operator. See also the documentation for the cmp operator.</p>"}},"Metamodel::Versioning":{"prefix":"<p><pre><code>role Metamodel::Versioning { ... }</code></pre></p><p>Metamodel role for (optionally) versioning metaobjects.</p><p>When you declare a type, you can pass it a version, author, and/or API and get them, like so:</p><p><pre><code>class Versioned:ver<0.0.1>:auth<github:Kaiepi>:api<1> { }\n\nsay Versioned.^ver;  # OUTPUT: «v0.0.1␤»\nsay Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\nsay Versioned.^api;  # OUTPUT: «1␤»\n</code></pre></p><p>This is roughly equivalent to the following, which also sets them explicitly:</p><p><pre><code>BEGIN {\n    class Versioned { }\n    Versioned.^set_ver:  v0.0.1;\n    Versioned.^set_auth: 'github:Kaiepi';\n    Versioned.^set_api:  <1>;\n}\n\nsay Versioned.^ver;  # OUTPUT: «v0.0.1␤»\nsay Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\nsay Versioned.^api;  # OUTPUT: «1␤»\n</code></pre></p>","defs":{"set_auth":"<p><pre><code>method set_auth($obj, $auth)</code></pre></p><p>Sets the author of the metaobject.</p>","auth":"<p><pre><code>method auth($obj)</code></pre></p><p>Returns the author of the metaobject, if any, otherwise returns an empty string.</p>","set_ver":"<p><pre><code>method set_ver($obj, $ver)</code></pre></p><p>Sets the version of the metaobject.</p>","api":"<p><pre><code>method api($obj)</code></pre></p><p>Returns the API of the metaobject, if any, otherwise returns an empty string.</p>","ver":"<p><pre><code>method ver($obj)</code></pre></p><p>Returns the version of the metaobject, if any, otherwise returns Mu.</p>"},"name":"Metamodel::Versioning"},"X::Bind":{"name":"X::Bind","prefix":"<p><pre><code>class X::Bind is Exception {}</code></pre></p><p>If you write code like this:</p><p><pre><code>floor(1.1) := 42;\n</code></pre></p><p>it dies with an X::Bind exception:</p><p><pre><code>Cannot use bind operator with this left-hand side\n</code></pre></p>","defs":{}},"Telemetry::Instrument::ThreadPool":{"prefix":"<p><pre><code>class Telemetry::Instrument::ThreadPool { }</code></pre></p><p>Note: This class is a Rakudo-specific feature and not standard Raku.</p><p>Objects of this class are generally not created directly, but rather through making a snapshot. They provide the following attributes (in alphabetical order):</p>* <p>atc</p><br><p>The number of tasks completed by affinity thread workers (affinity-tasks-completed).</p>* <p>atq</p><br><p>The number of tasks queued for execution for affinity thread workers (affinity-tasks-queued).</p>* <p>aw</p><br><p>The number of affinity thread workers (affinity-workers).</p>* <p>gtc</p><br><p>The number of tasks completed by general workers (general-tasks-completed).</p>* <p>gtq</p><br><p>The number of tasks queued for execution by general worker (general-tasks-queued).</p>* <p>gw</p><br><p>The number of general workers (general-workers).</p>* <p>s</p><br><p>The number of supervisor threads running, usually 0 or 1 (supervisor).</p>* <p>ttc</p><br><p>The number of tasks completed by timer workers (timer-tasks-completed).</p>* <p>ttq</p><br><p>The number of tasks queued for execution by timer workers (timer-tasks-queued).</p>* <p>tw</p><br><p>The number of timer workers (timer-workers).</p>","defs":{},"name":"Telemetry::Instrument::ThreadPool"},"Instant":{"name":"Instant","defs":{"to-posix":"<p><pre><code>method to-posix()</code></pre></p><p>Converts the invocant to a POSIX timestamp and returns a two element list containing the POSIX timestamp and a Bool. It is the inverse of #method from-posix, except that the second return value is True if *and only if* this Instant is in a leap second.</p><p><pre><code>say DateTime.new(\"1999-01-01T00:00:00Z\").Instant.to-posix; # OUTPUT: «(915148800 False)␤»\nsay DateTime.new('1998-12-31T23:59:60Z').Instant.to-posix; # OUTPUT: «(915148800 True)␤»</code></pre></p>","from-posix":"<p><pre><code>method from-posix($posix, Bool $prefer-leap-second = False)</code></pre></p><p>Converts the POSIX timestamp $posix to an Instant. If $prefer-leap-second is True, the return value will be the first of the two possible seconds in the case of a leap second.</p><p><pre><code>say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\nsay DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»</code></pre></p>","Date":"<p>Defined as:</p><p><pre><code>method Date(Instant:D: --> Date:D)</code></pre></p><p>Coerces the invocant to Date.</p><p><pre><code>my $i = \"/etc/passwd\".IO.modified;\nsay $i;             # OUTPUT: «Instant:1451489025.878018␤»\nsay $i.Date;        # OUTPUT: «2015-12-30␤»</code></pre></p>"},"prefix":"<p><pre><code>class Instant is Cool does Real { }</code></pre></p><p>An Instant is a particular moment in time measured in atomic seconds, with fractions. It is not tied to or aware of any epoch.</p><p>An Instant can be used to create a DateTime object set to that Instant. The pseudo-constant now returns the current time as an Instant.</p><p>Basic math is defined for Instants (as well as Durations). Adding an Instant to a Duration returns another Instant. Subtracting two Instants will yield a Duration. Adding two Instants is explicitly disallowed. All other operations with Instants are undefined.</p>"},"SetHash":{"prefix":"<p><pre><code>class SetHash does Setty { }</code></pre></p><p>A SetHash is a mutable set, meaning a collection of distinct elements in no particular order. (For immutable sets, see Set instead.)</p><p>Objects/values of any type are allowed as set elements. Within a Set, every element is guaranteed to be unique (in the sense that no two elements would compare positively with the === operator):</p><p><pre><code>my $fruits = <peach apple orange apple apple>.SetHash;\n\nsay $fruits.elems;      # OUTPUT: «3␤»\nsay $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n</code></pre></p><p>SetHashes can be treated as object hashes using the { } postcircumfix operator, which returns the value True for keys that are elements of the set, and False for keys that aren't. Assigning a value that boolifies to True or False, respectively, can be used to add or remove a set element:</p><p><pre><code>my $fruits = <peach apple orange apple apple>.SetHash;\n\nsay $fruits<apple>;     # OUTPUT: «True␤»\nsay $fruits<kiwi>;      # OUTPUT: «False␤»\n\n$fruits<apple kiwi> = False, True;\nsay $fruits.keys.sort;  # OUTPUT: «kiwi orange peach␤»\n</code></pre></p><p>Here is a convenient shorthand idiom for adding and removing SetHash elements:</p><p><pre><code>my SetHash $fruits .= new;\nsay $fruits<cherry>;      # OUTPUT: «False␤»\n$fruits<cherry>++;\nsay $fruits<cherry>;      # OUTPUT: «True␤»\n$fruits<apple banana kiwi>»++; # Add multiple elements\n\n$fruits<cherry>--;\nsay $fruits<cherry>;      # OUTPUT: «False␤»\n$fruits<banana kiwi>»--; # Remove multiple elements\n\n</code></pre></p>","defs":{},"name":"SetHash"},"HyperWhatever":{"prefix":"<p><pre><code>class HyperWhatever { }</code></pre></p><p>HyperWhatever is very similar in functionality to Whatever. The difference lies in HyperWhatever standing in for multiple values, rather than a single one.</p>","defs":{},"name":"HyperWhatever"},"Metamodel::ConcreteRoleHOW":{"defs":{},"prefix":"<p><pre><code>class Metamodel::ConcreteRoleHOW\n    does Metamodel::Naming\n    does Metamodel::Versioning\n    does Metamodel::PrivateMethodContainer\n    does Metamodel::MethodContainer\n    does Metamodel::MultiMethodContainer\n    does Metamodel::AttributeContainer\n    does Metamodel::RoleContainer\n    does Metamodel::MultipleInheritance\n    does Metamodel::ArrayType\n    does Metamodel::Concretization {}</code></pre></p><p>You can use this to build roles, in the same way that ClassHOW can be used to build classes:</p><p><pre><code>my $a = Metamodel::ConcreteRoleHOW.new_type(name => \"Bar\");\n$a.^compose;\nsay $a.^roles; # OUTPUT: «(Mu)␤»\n</code></pre></p><p>The main difference with ClassHOW.new_type is that you can mix-in roles in this newly created one.</p><p>This class is Rakudo specific, and provided only for completeness. Not really intended to be used by the final user.</p>","name":"Metamodel::ConcreteRoleHOW"},"X::Syntax::Confused":{"prefix":"<p><pre><code>class X::Syntax::Confused does X::Syntax { }\n</code></pre></p><p>The most general syntax error, if no more specific error message can be given.</p><p>For example</p><p><pre><code>1∞\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nConfused\n</code></pre></p>","defs":{},"name":"X::Syntax::Confused"},"Telemetry::Instrument::Usage":{"name":"Telemetry::Instrument::Usage","defs":{},"prefix":"<p><pre><code>class Telemetry::Instrument::Usage { }</code></pre></p><p>Note:  This class is a Rakudo-specific feature and not standard Raku.</p><p>Objects of this class are generally not created by themselves, but rather through making a snapshot.</p>"},"X::Syntax::InfixInTermPosition":{"prefix":"<p><pre><code>class X::Syntax::InfixInTermPosition does X::Syntax { }</code></pre></p><p>Syntax error thrown when the parser expects a term, but finds an infix operator instead.</p><p>For example</p><p><pre><code>1, => 2;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nPreceding context expects a term, but found infix => instead\n</code></pre></p>","defs":{},"name":"X::Syntax::InfixInTermPosition"},"BagHash":{"name":"BagHash","defs":{},"prefix":"<p><pre><code>class BagHash does Baggy { }</code></pre></p><p>A BagHash is a mutable bag/multiset, meaning a collection of distinct elements in no particular order that each have an integer weight assigned to them signifying how many copies of that element are considered \"in the bag\". (For immutable bags, see Bag instead.)</p><p>Objects/values of any type are allowed as bag elements. Within a BagHash, items that would compare positively with the === operator are considered the same element, with the number of how many there were as its weight. But of course you can also easily get back the expanded list of items (without the order):</p><p><pre><code>my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n\nsay $breakfast.elems;      # OUTPUT: «3␤»\nsay $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\nsay $breakfast.total;      # OUTPUT: «6␤»\nsay $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n</code></pre></p><p>BagHashes can be treated as object hashes using the { } postcircumfix operator, which returns the corresponding integer weight for keys that are elements of the bag, and 0 for keys that aren't. It can also be used to modify weights; setting a weight to 0 automatically removes that element from the bag, and setting a weight to a positive number adds that element if it didn't already exist:</p><p><pre><code>my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\nsay $breakfast<bacon>;     # OUTPUT: «1␤»\nsay $breakfast<spam>;      # OUTPUT: «4␤»\nsay $breakfast<sausage>;   # OUTPUT: «0␤»\n\n$breakfast<sausage> = 2;\n$breakfast<bacon>--;\nsay $breakfast.kxxv.sort;  # OUTPUT: «eggs sausage sausage spam spam spam spam␤»\n</code></pre></p>"},"Backtrace::Frame":{"prefix":"<p><pre><code>class Backtrace::Frame { }</code></pre></p><p>A single backtrace frame. It identifies a location in the source code.</p>","defs":{"line":"<p>Defined as:</p><p><pre><code>method line(Backtrace::Frame:D --> Int)</code></pre></p><p>Returns the line number (line numbers start counting from 1).</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.line;</code></pre></p>","code":"<p>Defined as:</p><p><pre><code>method code(Backtrace::Frame:D)</code></pre></p><p>Returns the code object into which .file and .line point, if available.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.code;</code></pre></p>","is-routine":"<p>Defined as:</p><p><pre><code>method is-routine(Backtrace::Frame:D --> Bool:D)</code></pre></p><p>Return True if the frame points into a routine (and not into a mere Block).</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.is-routine;</code></pre></p>","subname":"<p>Defined as:</p><p><pre><code>method subname(Backtrace::Frame:D --> Str)</code></pre></p><p>Returns the name of the enclosing subroutine.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.subname;</code></pre></p>","file":"<p>Defined as:</p><p><pre><code>method file(Backtrace::Frame:D --> Str)</code></pre></p><p>Returns the file name.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.file;</code></pre></p>","is-hidden":"<p>Defined as:</p><p><pre><code>method is-hidden(Backtrace::Frame:D --> Bool:D)</code></pre></p><p>Returns True if the frame is marked as hidden with the is hidden-from-backtrace trait.</p><p><pre><code>my $bt = Backtrace.new;\nmy $btf = $bt[0];\nsay $btf.is-hidden;</code></pre></p>"},"name":"Backtrace::Frame"},"Kernel":{"defs":{"hardware":"<p>Defined as</p><p><pre><code>method hardware</code></pre></p><p>Instance method returning the hardware information of the Kernel object. Dies if the hardware information could not be established.</p><p><pre><code>say $*KERNEL.hardware; # OUTPUT: «x86_64␤»</code></pre></p>","arch":"<p><pre><code>method arch</code></pre></p><p>Instance method returning the \"arch\" (as in \"architecture\") information of the Kernel object. Dies if the \"arch\" could not be established.</p>","free-memory":"<p><pre><code>method free-memory(--> Int)</code></pre></p><p>Instance / Class method returning the available memory on the system. When using the JVM, this returns the available memory to the JVM instead. This method is only available in release v2019.06 and later.</p>","total-memory":"<p><pre><code>method total-memory(--> Int)</code></pre></p><p>Instance / Class method returning the total memory available to the system. When using the JVM, this returns the total memory available to the JVM instead. This method is only available in release v2019.06 and later.</p>","release":"<p><pre><code>method release</code></pre></p><p>Instance method returning the release information of the Kernel object. Dies if the release information could not be established.</p>","archname":"<p><pre><code>method archname</code></pre></p><p>Instance method returning the concatenation of hardware and name.</p>","hostname":"<p><pre><code>method hostname</code></pre></p><p>Instance method returning the hostname of the Kernel object.</p>","bits":"<p><pre><code>method bits</code></pre></p><p>Instance method returning the number of bits used in the architecture of the processor. Usually 32 or 64.</p>","cpu-usage":"<p><pre><code>method cpu-usage(--> Int)</code></pre></p><p>Instance / Class method returning the amount of CPU uses since the start of the program (in microseconds).</p>","signal":"<p>Defined as:</p><p><pre><code>multi method signal(Kernel:D: Str:D $signal --> Int:D)\nmulti method signal(Kernel:D: Signal:D \\signal --> Int:D)\nmulti method signal(Kernel:D: Int:D \\signal --> Int:D)</code></pre></p><p>Instance method returning the Signal numeric code for a given name for the Kernel object.</p><p><pre><code>say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»</code></pre></p>","endian":"<p><pre><code>method endian(--> Endian:D)</code></pre></p><p>Class method that returns the Endian object associated with the kernel architecture (either LittleEndian or BigEndian).</p>","cpu-cores":"<p><pre><code>method cpu-cores(--> Int)</code></pre></p><p>Instance / Class method returning the number of CPU cores that are available.</p><p><pre><code>say $*KERNEL.cpu-cores; # OUTPUT: «8␤»</code></pre></p>"},"prefix":"<p><pre><code>class Kernel does Systemic { }</code></pre></p><p>Built-in class for providing kernel related information. Usually accessed through the $*KERNEL dynamic variable.</p>","name":"Kernel"},"Metamodel::PrivateMethodContainer":{"defs":{"add_private_method":"<p><pre><code>method add_private_method(Metamodel::PrivateMethodContainer: $obj, $name, $code)</code></pre></p><p>Adds a private method $code with name $name.</p>"},"prefix":"<p><pre><code>role Metamodel::PrivateMethodContainer { ... }</code></pre></p><p>In Raku, classes, roles and grammars can have private methods, that is, methods that are only callable from within the class, and are not inherited by types derived by inheritance.</p><p><pre><code>class A {\n    # the ! declares a private method\n    method !double($x) {\n        say 2 * $x;\n    }\n    method call-double($y) {\n        # call with ! instead of .\n        self!double($y);\n    }\n}</code></pre></p><p>For the purposes of dispatching and scoping, private methods are closer to subroutines than to methods. However they share access to self and attributes with methods.</p>","name":"Metamodel::PrivateMethodContainer"},"ForeignCode":{"name":"ForeignCode","defs":{"name":"<p><pre><code>method name()</code></pre></p><p>Returns the name of the enclosed code, or <anon> if it has not received any.</p>","gist":"<p><pre><code>method gist( ForeignCode:D: )</code></pre></p><p>Returns the name of the code by calling name.</p>","arity":"<p><pre><code>method arity()</code></pre></p><p>Returns the arity of the enclosed code.</p>","count":"<p><pre><code>method count()</code></pre></p><p>Returns the number of arguments the enclosed code needs.</p>","signature":"<p><pre><code>method signature( ForeignCode:D: )</code></pre></p><p>Returns the signature of the enclosed code.</p>"},"prefix":"<p><pre><code>class ForeignCode does Callable {}</code></pre></p><p>This is a Rakudo specific class, and as such it is advisable not to use it in your own code, since its interface might change or even disappear in the future. This is provided here only as a reference</p><p>ForeignCode is a Raku wrapper around code that is not written originally in that language; its intention is to use these blocks of code in Callable contexts easily. For instance, subs have some anonymous functions that are actually ForeignCode.</p><p><pre><code>sub does-nothing(){};\nsay $_.name ~ ' → ' ~ $_.^name for &does-nothing.^methods;\n# OUTPUT: «<anon> → ForeignCode␤<anon> → ForeignCode␤soft → Method␤…»\n</code></pre></p><p>This script will map method names to their class, and it shows that routines, in particular, have several methods that are actually ForeignCode instead of Methods.</p>"},"IO::Path::Win32":{"name":"IO::Path::Win32","prefix":"<p><pre><code>class IO::Path::Win32 is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::Win32 in the $.SPEC attribute.</p>","defs":{"new":"<p>Same as IO::Path.new, except :$SPEC cannot be set and defaults to IO::Spec::Win32, regardless of the operating system the code is being run on.</p>"}},"X::Syntax::Number::RadixOutOfRange":{"defs":{},"prefix":"<p><pre><code>class X::Syntax::Number::RadixOutOfRange does X::Syntax { }</code></pre></p><p>Syntax error that is thrown when the radix of a radix number is not allowed, like :1<1>  or :42<ouch> .</p>","name":"X::Syntax::Number::RadixOutOfRange"},"CompUnit":{"prefix":"<p><pre><code>class CompUnit {}</code></pre></p><p>The CompUnit represents the metainformation about a compilation unit. This usually relates to source code that resides in a file on a filesystem, rather than code that is executed using an EVAL statement.</p>","defs":{"from":"<p><pre><code>method from(--> Str:D)</code></pre></p><p>Returns the name of the language with which the CompUnit object was created (if any). It will be Perl6 by default.</p>","repo-id":"<p><pre><code>method repo-id(--> Str:D)</code></pre></p><p>Returns the identification string with which the CompUnit object can be identified in the associated repo.</p>","auth":"<p><pre><code>method auth(--> Str:D)</code></pre></p><p>Returns the authority information with which the CompUnit object was created (if any).</p>","repo":"<p><pre><code>method repo(--> CompUnit::Repository:D)</code></pre></p><p>Returns the CompUnit::Repository object with which the CompUnit object was created.</p>","precompiled":"<p><pre><code>method precompiled(--> Bool:D)</code></pre></p><p>Returns whether the CompUnit object originated from a precompiled source.</p>","short-name":"<p><pre><code>method short-name(--> Str:D)</code></pre></p><p>Returns The short name with which the CompUnit object was created (if any).</p>","distribution":"<p><pre><code>method distribution(--> Distribution:D)</code></pre></p><p>Returns the Distribution object with which the CompUnit object was created (if any).</p>"},"name":"CompUnit"},"Hash":{"name":"Hash","defs":{"classify-list":"<p>Defined as:</p><p><pre><code>multi method classify-list(&mapper, *@list, :&as --> Hash:D)\nmulti method classify-list(%mapper, *@list, :&as --> Hash:D)\nmulti method classify-list(@mapper, *@list, :&as --> Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>","default":"<p>Defined as:</p><p><pre><code>method default()</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when a non existing key is used to access an element in the Hash. Unless the Hash is declared as having a default value by using the is default trait the method returns the type object (Any).</p><p><pre><code>my %h1 = 'apples' => 3, 'oranges' => 7;\nsay %h1.default;                                       # OUTPUT: «(Any)␤»\nsay %h1{'bananas'};                                    # OUTPUT: «(Any)␤»\n\nmy %h2 is default(1) = 'apples' => 3, 'oranges' => 7;\nsay %h2.default;                                       # OUTPUT: «1␤»\nsay %h2{'apples'} + %h2{'bananas'};                    # OUTPUT: «4␤»</code></pre></p>","append":"<p>Defined as:</p><p><pre><code>method append(+@values)</code></pre></p><p>Append the provided Pairs or even sized list to the Hash. If a key already exists, turn the existing value into an Array and push new value onto that Array. Please note that you can't mix even sized lists and lists of Pairs. Also, bare Pairs or colon pairs will be treated as named arguments to .append.</p><p><pre><code>my %h = a => 1;\n%h.append('b', 2, 'c', 3);\n%h.append( %(d => 4) );\nsay %h;\n# OUTPUT: «{a => 1, b => 2, c => 3, d => 4}␤»\n%h.append('a', 2);\n# OUTPUT: «{{a => [1 2], b => 2, c => 3, d => 4}␤»</code></pre></p><p>Note: Compared to push, append will slip in the given value, whereas push will add it as is:</p><p><pre><code>my %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\nsay %hb; # OUTPUT: «{a => [42 a b c a]}␤»\n\nmy %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\nsay %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»</code></pre></p>","of":"<p>Defined as:</p><p><pre><code>method of()</code></pre></p><p>Returns the type constraint for the values of the invocant. By default, i.e., if no type constraint is given during declaration, the method returns (Mu).</p><p><pre><code>my %h1 = 'apples' => 3, 'oranges' => 7;  # (no type constraint specified)\nsay %h1.of;                              # OUTPUT: «(Mu)␤»\n\nmy Int %h2 = 'oranges' => 7;             # (values must be of type Int)\nsay %h2.of;                              # OUTPUT: «(Int)␤»</code></pre></p>","push":"<p>Defined as:</p><p><pre><code>multi method push(Hash:D: *@new)</code></pre></p><p>Adds the @new elements to the hash with the same semantics as hash assignment, but with three exceptions:</p>* <p>The hash isn't emptied first, i.e. old pairs are not deleted.</p><br>* <p>If a key already exists in the hash, and the corresponding value is an Array, the new value is pushed onto the array (instead of replacing it).</p><br>* <p>If a key already exists in the hash, and the corresponding value is not an Array, old and new value are both placed into an array in the place of the old value.</p><br><p>Example:</p><p><pre><code>my %h  = a => 1;\n%h.push: (a => 1);              # a => [1,1]\n%h.push: (a => 1) xx 3 ;        # a => [1,1,1,1,1]\n%h.push: (b => 3);              # a => [1,1,1,1,1], b => 3\n%h.push('c' => 4);              # a => [1,1,1,1,1], b => 3, c => 4\npush %h, 'd' => 5;              # a => [1,1,1,1,1], b => 3, c => 4, d => 5</code></pre></p><p>Please note that Pairs or colon pairs as arguments to push will be treated as extra named arguments and as such wont end up the Hash. The same applies to the sub push.</p><p><pre><code>my %h .= push(e => 6);\npush %h, f => 7;\nsay %h.perl;\n# OUTPUT: «{}␤»</code></pre></p><p>Also note that push can be used as a replacement for assignment during hash initialization very useful ways. Take for instance the case of an inverted index:</p><p><pre><code>my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\n(my %inv).push: %wc.invert;\nsay %inv;                     # OUTPUT: «{322 => pair, 323 => [pipe hash]}␤»</code></pre></p><p>Note that such an initialization could also be written as</p><p><pre><code>my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\nmy %inv .= push: %wc.invert;</code></pre></p><p>Note: Compared to append, push will add the given value as is, whereas append will slip it in:</p><p><pre><code>my %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\nsay %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»\n\nmy %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\nsay %hb; # OUTPUT: «{a => [42 a b c a]}␤»</code></pre></p>","dynamic":"<p>Defined as:</p><p><pre><code>method dynamic(--> Bool:D)</code></pre></p><p>Returns True if the invocant has been declared with the is dynamic trait.</p><p><pre><code>my %a;\nsay %a.dynamic;                          # OUTPUT: «False␤»\n\nmy %b is dynamic;\nsay %b.dynamic;                          # OUTPUT: «True␤»</code></pre></p><p>If you declare a variable with the * twigil is dynamic is implied.</p><p><pre><code>my %*b;\nsay %*b.dynamic;                         # OUTPUT: «True␤»</code></pre></p><p>Note that in the Scalar case you have to use the VAR method in order to get correct information.</p><p><pre><code>my $s is dynamic = %('apples' => 5);\nsay $s.dynamic;                   # OUTPUT: «False␤»  (wrong, don't do this)\nsay $s.VAR.dynamic;               # OUTPUT: «True␤»   (correct approach)</code></pre></p>","keyof":"<p>Defined as:</p><p><pre><code>method keyof()</code></pre></p><p>Returns the type constraint for the keys of the invocant. For normal hashes the method returns the coercion type (Str(Any)) while for non-string keys hashes the type used in the declaration of the Hash is returned.</p><p><pre><code>my %h1 = 'apples' => 3, 'oranges' => 7;  # (no key type specified)\nsay %h1.keyof;                           # OUTPUT: «(Str(Any))␤»\n\nmy %h2{Str} = 'oranges' => 7;            # (keys must be of type Str)\nsay %h2.keyof;                           # (Str)\n%h2{3} = 'apples';                       # throws exception\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Binding: Type check failed in binding to key; expected Str but got Int (3)␤»\n\nmy %h3{Int};                             # (this time, keys must be of type Int)\n%h3{42} = 4096;\nsay %h3.keyof;                           # (Int)</code></pre></p>","categorize-list":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\nmulti method categorize-list(%mapper, *@list, :&as --> Hash:D)\nmulti method categorize-list(@mapper, *@list, :&as --> Hash:D)</code></pre></p><p>Populates a Hash by classifying the possibly-empty @list of values using the given mapper, optionally altering the values using the :&as Callable. The @list cannot be lazy.</p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p>"},"prefix":"<p><pre><code>class Hash is Map { }</code></pre></p><p>A Hash is a mutable Map; it implements Associative through its inheritance of Map and as such provides support for looking up values using keys, providing support for associative subscripting.</p><p>Although the order of the hashes is guaranteed to be random in every single call, still successive calls to .keys and .values are guaranteed to return them in the same order:</p><p><pre><code>my %orig = :1a, :2b; my %new = :5b, :6c;\n%orig{ %new.keys } = %new.values;\nsay %orig.perl; # OUTPUT: «{:a(1), :b(5), :c(6)}␤»</code></pre></p><p>In this case, b will always be associated to 5 and c to 6; even if two successive calls to keys will return them in different order. Successive calls to any of them separately and repeatedly will always return the same order in any program invocation.</p><p>Please see the section on hash literals for different ways to declare a hash. Additionally, they can be declared using curly braces as long as these rules are followed:</p>* <p>Empty curly braces will always declare an empty hash.</p><br>* <p>A reference to $_ (even implicit) will instead declare a block.</p><br>* <p>A Pair or variable with % as the first element will declare a hash.</p><br><p><pre><code>given 3 { say WHAT {3 => 4, :b}  };     # OUTPUT: «(Hash)␤»\ngiven 3 { say WHAT {3 => 4, :b($_)} };  # OUTPUT: «(Block)␤»\ngiven 3 { say WHAT {3 => 4, :b(.Num)} };# OUTPUT: «(Block)␤»\nsay { 'a',:b(3), 'c' }.^name;           # OUTPUT: «Block␤»\n</code></pre></p><p>The next-to-last two cases are examples of the generation of Blocks in the presence of the topic variable $_. The last case does not meet the third criterium for generating a hash, and thus generates a Block.</p><p>A % in front of parentheses or square brackets will generate a Hash as long as the elements can be paired.</p><p><pre><code>say %( 'a', 3, :b(3), 'c', 3 ).^name; # OUTPUT: «Hash␤»</code></pre></p><p>Elements in this hash can be paired both sides of the Pair :b(3).</p><p><pre><code>say %(«a b c 1 2 3»).^name;           # OUTPUT: «Hash␤»</code></pre></p><p>An empty hash can be initialized either with empty curly braces or, since 6.d, %().</p><p><pre><code>say %().^name; # OUTPUT: «Hash␤»\nsay {}.^name;  # OUTPUT: «Hash␤»</code></pre></p>"},"IO::CatHandle":{"name":"IO::CatHandle","defs":{"READ":"<p>Defined as:</p><p><pre><code>multi method EOF(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","nl-out":"<p>Defined as:</p><p><pre><code>multi method nl-out(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","handles":"<p>Defines as:</p><p><pre><code>method handles(IO::CatHandle:D: --> Seq:D)</code></pre></p><p>Returns a Seq containing the currently-active handle, as well as all the remaining source handles produced by calling next-handle. If the invocant has already been fully-consumed, returns an empty Seq.</p><p>This method is especially handy when working with IO::ArgFiles, where you want to treat each filehandle separately:</p><p><pre><code># print at most the first 2 lines of each file in $*ARGFILES:\n.say for flat $*ARGFILES.handles.map: *.lines: 2</code></pre></p><p>It is acceptable to call this method multiple times; .handles.head is a valid idiom for obtaining the currently-active handle. If, between reification of the elements of the returned Seq the handles get switched by some other means, the next element produced by the Seq would be the next handle of the invocant, not the handle that would've been produced if no switching occurred:</p><p><pre><code>(my $file1 := 'file1'.IO).spurt: \"1a\\n1b\\n1c\";\n(my $file2 := 'file2'.IO).spurt: \"2a\\n2b\\n2c\";\n(my $file3 := 'file3'.IO).spurt: \"3a\\n3b\\n3c\";\nmy $cat := IO::CatHandle.new: $file1, $file2, $file3;\nfor $cat.handles {\n    say .lines: 2;\n    $cat.next-handle;\n}\n# OUTPUT: «(1a 1b)␤(3a 3b)␤»</code></pre></p><p>Likewise, reifying the returned Seq consumes the invocant's source handles and once it is fully reified the invocant becomes fully-consumed.</p>","on-switch":"<p>Defined as:</p><p><pre><code>has &.on-switch is rw</code></pre></p><p>One of the attributes that can be set during .new call and changed later by assigning to. By default is not specified. Takes a Callable with .count of 0, 1, 2, or Inf. Gets called every time .next-handle is, which happens once during .new call and then each time a source handle is switched to the next one in the queue, or when the .next-handle method is called manually.</p><p>If the .count of &.on-switch is 0, it receives no arguments; if it's 1, it receives the currently active handle, and if it's 2 or Inf, it receives the currently active handle, and the last active handle as positional arguments (in that order). On the very first &.on-switch execution, the \"last active handle\" argument is Nil. Upon source handle queue exhaustion the \"currently active handle\" argument is Nil, and all the executions made afterwards have both arguments as Nil.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\nmy $line;\nmy $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\nsay \"{$cat.path}:{$line++} $_\" for $cat.lines;\n# OUTPUT:\n# foo:1 A\n# foo:2 B\n# foo:3 C\n# bar:1 D\n# bar:2 E\n</code></pre></p><p><pre><code>my @old-stuff;\nsub on-switch ($new, $old) {\n    $new and $new.seek: 1, SeekFromBeginning;\n    $old and @old-stuff.push: $old.open.slurp: :close;\n}\n\n(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\nmy $cat = IO::CatHandle.new: :&on-switch, $f1, $f2;\n$cat.lines.perl.say; # OUTPUT: «(\"\", \"B\", \"C\", \"\", \"E\").Seq␤»\n@old-stuff.perl.say; # OUTPUT: «[\"A\\nB\\nC\", \"D\\nE\"]␤»\n</code></pre></p>","native-descriptor":"<p>Defined as:</p><p><pre><code>method native-descriptor(IO::CatHandle:D: --> Int:D)</code></pre></p><p>Returns the native-descriptor of the currently active source handle or Nil if the source handle queue has been exhausted.</p><p>Since the CatHandle closes a source handle, once it's done with it, it's possible for successive source handles to have the same native descriptor, if they were passed to .new as Cool or IO::Path objects.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nwith IO::CatHandle.new: $f1, $f2, $*IN {\n    repeat { .native-descriptor.say } while .next-handle;\n    # OUTPUT: «13␤13␤9␤»\n}\n</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>method new(*@handles, :&on-switch, :$chomp = True,\n           :$nl-in = [\"\\n\", \"\\r\\n\"], Str :$encoding, Bool :$bin)\n</code></pre></p><p>Creates a new IO::CatHandle object.</p><p>The @handles positional argument indicates a source of handles for the IO::CatHandle to read from and can deal with a mixed collection of Cool, IO::Path, and IO::Handle (including IO::Pipe) objects. As input from IO::CatHandle is processed (so operations won't happen during .new call, but only when @handles' data is needed), it will walk through the @handles list, processing each argument as follows:</p>* <p>the Cool objects will be coerced to IO::Path;</p><br>* <p>IO::Path objects will be opened for reading using the IO::CatHandle's (invocant's) attributes for open calls;</p><br>* <p>un-opened IO::Handle objects will be opened in the same fashion as IO::Path objects;</p><br>* <p>and already opened IO::Handle objects will have all of their attributes set to the attributes of the invocant IO::CatHandle.</p><br><p>In short, all the @handles end up as IO::Handle objects opened in the same mode and with the same attributes as the invocant IO::CatHandle.</p><p>See .on-switch method for details on the :&on-switch named argument, which by default is not set.</p><p>The :$encoding named argument specifies the handle's encoding and accepts the same values as IO::Handle.encoding. Set :$bin named argument to True if you wish the handle to be in binary mode. Attempting to specify both a defined :$encoding and a True :$bin is a fatal error resulting in X::IO::BinaryAndEncoding exception thrown. If neither :$encoding is set nor :$bin set to a true value, the handle will default to utf8 encoding.</p><p>The :$chomp and :$nl-in arguments have the same meaning as in IO::Handle and take and default to the same values.</p>","print-nl":"<p>Defined as:</p><p><pre><code>multi method print-nl(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","write":"<p>Defined as:</p><p><pre><code>multi method write(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","printf":"<p>Defined as:</p><p><pre><code>multi method printf(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","out-buffer":"<p>Defined as:</p><p><pre><code>multi method out-buffer(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","words":"<p>Defined as:</p><p><pre><code>method words(IO::CatHandle:D: $limit = Inf, :$close --> Seq:D)</code></pre></p><p>Same as IO::Handle.words (including the caveat about more data read than needed to make some number of words). Note that a boundary between source handles is considered to be word boundary.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo bar';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nIO::CatHandle.new($f1, $f2).words.perl.say;\n# OUTPUT: «(\"foo\", \"bar\", \"meow\").Seq␤»\n</code></pre></p><p>Note: if :$close is False, fully-consumed handles are still going to be closed.</p>","tell":"<p>Defined as:</p><p><pre><code>method tell(IO::CatHandle:D: --> Int:D)</code></pre></p><p>Calls .tell on the currently active source handle and returns the result. Returns Nil if the source handle queue has been exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    .get.say;                   # OUTPUT: «foo␤»\n    .tell.say;                  # OUTPUT: «3␤»\n    .seek: -2, SeekFromCurrent;\n    .tell.say;                  # OUTPUT: «1␤»\n    say .readchars: 3;          # OUTPUT: «oob␤»\n    .tell.say;                  # OUTPUT: «2␤»\n    }\n</code></pre></p>","eof":"<p>Defined as:</p><p><pre><code>method eof(IO::CatHandle:D: --> Bool:D)</code></pre></p><p>Returns True if the read operations have exhausted the source handle queue, including the contents of the last handle. Note: calling this method may cause one or more .on-switch calls, while the source handle queue is examined, and the source handle queue may get exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nwith IO::CatHandle.new: :on-switch{ print 'SWITCH! ' }, $f1, $f2 {\n                   # OUTPUT: «SWITCH! »\n    .eof.say;      # OUTPUT: «False␤»\n    .readchars(3);\n    .eof.say;      # OUTPUT: «SWITCH! False␤»\n\n    .slurp;        # OUTPUT: «SWITCH! »\n    .eof.say;      # OUTPUT: «True␤»\n}\n</code></pre></p><p>The same caveats for non-seekable handles and empty files that apply to IO::Handle.eof apply here.</p>","opened":"<p>Defined as:</p><p><pre><code>method opened(IO::CatHandle:D: --> Bool:D)</code></pre></p><p>Returns True if the invocant has any source handles, False otherwise.</p><p><pre><code>say IO::CatHandle.new      .opened; # OUTPUT: «False␤»\nsay IO::CatHandle.new($*IN).opened; # OUTPUT: «True␤»\n\n(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\nwith IO::CatHandle.new: $f1 {\n    .opened.say; # OUTPUT: «True␤»\n    .slurp;\n    .opened.say; # OUTPUT: «False␤»\n}\n</code></pre></p>","chomp":"<p>Defined as:</p><p><pre><code>method chomp(IO::CatHandle:D:) is rw</code></pre></p><p>Sets the invocant's $.chomp attribute to the assigned value. All source handles, including the active one will use the provided $.chomp value.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\\n\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\\n\";\nwith IO::CatHandle.new: $f1, $f2 {\n    # .chomp is True by default:\n    (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n    .chomp = False;\n    (.get xx 3).perl.say; # OUTPUT: «(\"C\\n\", \"D\\n\", \"E\\n\").Seq␤»\n    .close\n}\n</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>method Str(IO::CatHandle:D: --> Str:D)</code></pre></p><p>Calls .Str on the currently active source handle and returns the result. If the source handle queue has been exhausted, returns an implementation-defined string ('<closed IO::CatHandle>' in Rakudo).</p>","close":"<p>Defined as:</p><p><pre><code>method close(IO::CatHandle:D: --> True)</code></pre></p><p>Closes the currently active source handle, as well as any already-open source handles, and empties the source handle queue. Unlike a regular IO::Handle, an explicit call to .close is often not necessary on a CatHandle, as merely exhausting all the input closes all the handles that need to be closed.</p><p><pre><code>with IO::CatHandle.new: @bunch-of-handles {\n    say .readchars: 42;\n    .close; # we are done; close all the open handles\n}\n</code></pre></p>","print":"<p>Defined as:</p><p><pre><code>multi method print(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","t":"<p>Defined as:</p><p><pre><code>method t(IO::CatHandle:D: --> Bool:D)</code></pre></p><p>Calls .t, which tells if the handle is a TTY, on the currently active source handle and returns the result. If the source handle queue has been exhausted, returns False.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\nwith IO::CatHandle.new: $f1, $*IN {\n    repeat { .t.say } while .next-handle; # OUTPUT: «False␤True␤»\n}\n</code></pre></p>","flush":"<p>Defined as:</p><p><pre><code>multi method flush(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","lock":"<p>Defined as:</p><p><pre><code>method lock(IO::CatHandle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)</code></pre></p><p>Same as IO::Handle.lock. Returns Nil if the source handle queue has been exhausted.</p><p>Locks only the currently active source handle. The .on-switch Callable can be used to conveniently lock/unlock the handles as they're being processed by the CatHandle.</p>","path":"<p>Defined as:</p><p><pre><code>method path(IO::CatHandle:D:)</code></pre></p><p>Returns the value of .path attribute of the currently active source handle, or Nil if the source handle queue has been exhausted. Basically, if your CatHandle is based on files, this is the way to get the path of the file the CatHandle is currently reading from.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\nmy $line;\nmy $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\nsay \"{$cat.path}:{$line++} $_\" for $cat.lines;\n# OUTPUT:\n# foo:1 A\n# foo:2 B\n# foo:3 C\n# bar:1 D\n# bar:2 E\n</code></pre></p>","open":"<p>Defined as:</p><p><pre><code>method open(IO::CatHandle:D: --> IO::CatHandle:D)</code></pre></p><p>Returns the invocant. The intent of this method is to merely make CatHandle workable with things that open IO::Handle. You never have to call this method intentionally.</p>","encoding":"<p>Defined as:</p><p><pre><code>multi method encoding(IO::CatHandle:D:)\nmulti method encoding(IO::CatHandle:D: $new-encoding)</code></pre></p><p>Sets the invocant's $.encoding attribute to the provided value. Valid values are the same as those accepted by IO::Handle.encoding (use value Nil to switch to binary mode). All source handles, including the active one will use the provided $.encoding value.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nwith IO::CatHandle.new: $f1, $f2 {\n    # .encoding is 'utf8' by default:\n    .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n    .encoding: Nil; # switch to binary mode\n    .slurp.say; # OUTPUT: «Buf[uint8]:0x<72 6c 6d 65 6f 77>␤»\n}\n</code></pre></p>","comb":"<p>Defined as:</p><p><pre><code>method comb(IO::CatHandle:D: |args --> Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.comb does, taking the same arguments. Implementations may slurp the contents of all the source handles in their entirety when this method is called.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nIO::CatHandle.new($f1, $f2).comb(2).perl.say;\n# OUTPUT: «(\"fo\", \"ob\", \"ar\").Seq␤»\n</code></pre></p>","say":"<p>Defined as:</p><p><pre><code>multi method say(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","split":"<p>Defined as:</p><p><pre><code>method split(IO::CatHandle:D: |args --> Seq:D)</code></pre></p><p>Read the handle and processes its contents the same way Str.split does, taking the same arguments. Implementations may slurp the contents of all the source handles in their entirety when this method is called.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nIO::CatHandle.new($f1, $f2).split(/o+/).perl.say;\n# OUTPUT: «(\"f\", \"bar\").Seq␤»\n</code></pre></p>","Supply":"<p>Defined as:</p><p><pre><code>method Supply(IO::CatHandle:D: :$size = 65536 --> Supply:D)</code></pre></p><p>Returns a Supply fed with either .read, if the handle is in binary mode, or with .readchars, if it isn't, with reads of :$size bytes or characters. :$size defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536).</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\nreact whenever IO::CatHandle.new($f1, $f2).Supply: :2size {.say}\n# OUTPUT: «fo␤ob␤ar␤»\n\nreact whenever IO::CatHandle.new(:bin, $f1, $f2).Supply: :2size {.say}\n# OUTPUT: «Buf[uint8]:0x<66 6f>␤Buf[uint8]:0x<6f 62>␤Buf[uint8]:0x<61 72>␤»\n</code></pre></p>","seek":"<p>Defined as:</p><p><pre><code>method seek(IO::CatHandle:D: |c)</code></pre></p><p>Calls .seek on the currently active source handle, forwarding it all the arguments, and returns the result. Returns Nil if the source handle queue has been exhausted. NOTE: this method does NOT perform any source handle switching, so seeking past the end of the current source handle will NOT seek to the next source handle in the queue and seeking past the beginning of the current source handle is a fatal error. Also see .next-handle, to learn the details on when source handles are switched.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    .get.say;                     # OUTPUT: «foo␤»\n    .seek: -2, SeekFromCurrent;\n    .readchars(2).say;            # OUTPUT: «oo␤»\n    .seek: 1000, SeekFromCurrent; # this doesn't switch to second handle!\n    .readchars(3).say;            # OUTPUT: «bar␤»\n    try .seek: -4;                # this won't seek to previous handle!\n    say ~$!;                      # OUTPUT: «Failed to seek in filehandle: 22␤»\n}\n</code></pre></p>","slurp":"<p>Defined as:</p><p><pre><code>method slurp(IO::CatHandle:D:)</code></pre></p><p>Reads all of the available input from all the source handles and returns it as a Buf if the handle is in binary mode or as a Str otherwise. Returns Nil if the source handle queue has been exhausted.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'foo';\n(my $f2 = 'bar'.IO).spurt: 'bar';\n\nIO::CatHandle.new(      $f1, $f2).slurp.say; # OUTPUT: «foobar␤»\nIO::CatHandle.new(:bin, $f1, $f2).slurp.say; # OUTPUT: «Buf[uint8]:0x<66 6f 6f 62 61 72>␤»\nIO::CatHandle.new                .slurp.say; # OUTPUT: «Nil␤»\n</code></pre></p>","put":"<p>Defined as:</p><p><pre><code>multi method put(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","DESTROY":"<p>Defined as:</p><p><pre><code>method DESTROY(IO::CatHandle:D:)</code></pre></p><p>Calls .close. This method isn't to be used directly, but is something that's called during garbage collection.</p>","nl-in":"<p>Defined as:</p><p><pre><code>method nl-in(IO::CatHandle:D:) is rw</code></pre></p><p>Sets the invocant's $.nl-in attribute to the assigned value, which can be a Str or a List of Str, where each Str object represents the end-of-line string. All source handles, including the active one will use the provided $.nl-in value. Note that source handle boundary is always counted as a new line break.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n(my $f2 = 'bar'.IO).spurt: \"DxEx\";\nwith IO::CatHandle.new: $f1, $f2 {\n    # .nl-in is [\"\\n\", \"\\r\\n\"] by default:\n    (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n    .nl-in = 'x';\n    (.get xx 3).perl.say; # OUTPUT: «(\"C\", \"D\", \"E\").Seq␤»\n    .close\n}\n</code></pre></p>","next-handle":"<p>Defined as:</p><p><pre><code>method next-handle(IO::CatHandle:D: --> IO::Handle:D)</code></pre></p><p>Switches the active source handle to the next handle in the source handle queue, which is the sources given in @handles attribute to .new. The return value is the currently active source handle or Nil if the source handle queue has been exhausted.</p><p>Coerces Cool source \"handles\" to IO::Path; opens IO::Path and unopened IO::Handle source handles for reading using the invocant's $.nl-in, $.chomp, and $.encoding attributes; those same attributes of already-opened IO::Handle objects will be changed to the values of the invocant's attributes.</p><p>This method is called automatically whenever CatHandle's methods require a switch to the next source handle, triggers .on-switch Callable to be called, and is called once during .new call. The .on-switch will continue to be triggered each time this method is called, even after the source handle queue has been exhausted. Note that generally reaching the EOF of the currently active source handle does not trigger the .next-handle call, but rather further read operations that need more data do.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"a\\nb\";\n(my $f2 = 'bar'.IO).spurt: \"c\\nd\";\nwith IO::CatHandle.new: :on-switch{ say '▸ Switching' }, $f1, $f2 {\n    say 'one';\n    .next-handle.^name.say;\n    say 'two';\n    .next-handle.^name.say;\n    say 'three';\n    .next-handle.^name.say;\n    # OUTPUT:\n    # ▸ Switching\n    # one\n    # ▸ Switching\n    # IO::Handle\n    # two\n    # ▸ Switching\n    # Nil\n    # three\n    # ▸ Switching\n    # Nil\n}\n</code></pre></p>","WRITE":"<p>Defined as:</p><p><pre><code>multi method WRITE(|)</code></pre></p><p>The IO::CatHandle type overrides this method to throw a X::NYI exception. If you have a good idea for how this method should behave, tell Rakudo developers about it!</p>","unlock":"<p>Defined as:</p><p><pre><code>method unlock(IO::CatHandle:D:)</code></pre></p><p>Same as IO::Handle.unlock. Returns Nil if the source handle queue has been exhausted.</p><p>Unlocks only the currently active source handle. The .on-switch Callable can be used to conveniently lock/unlock the handles as they're being processed by the CatHandle.</p>","read":"<p>Defined as:</p><p><pre><code>method read(IO::CatHandle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)</code></pre></p><p>Reads up to $bytes bytes from the handle and returns them in a Buf. $bytes defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). It is permitted to call this method on handles that are not in binary mode.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'meow';\n(my $f2 = 'bar'.IO).spurt: Blob.new: 4, 5, 6;\nwith IO::CatHandle.new: :bin, $f1, $f2 {\n    say .read: 2;    # OUTPUT: «Buf[uint8]:0x<6d 65>␤»\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x<6f 77 04 05 06>␤»\n}\n\n# Non-binary mode is OK too:\nwith IO::CatHandle.new: $f1, $f2 {\n    say .get;        # OUTPUT: «meow␤»\n    say .read: 2000; # OUTPUT: «Buf[uint8]:0x<04 05 06>␤»\n}\n</code></pre></p>","get":"<p>Defined as:</p><p><pre><code>method get(IO::CatHandle:D: --> Bool:D)</code></pre></p><p>Returns a single line of input from the handle, with the new line string defined by the value(s) of $.nl-in attribute, which will be removed from the line if $.chomp attribute is set to True. Returns Nil when there is no more input. It is an error to call this method when the handle is in binary mode, resulting in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"a\\nb\\nc\";\n(my $f2 = 'bar'.IO).spurt: \"d\\ne\";\nmy $cat = IO::CatHandle.new: $f1, $f2;\n.say while $_ = $cat.get; # OUTPUT: «a␤b␤c␤d␤e␤»\n</code></pre></p>","IO":"<p>Defined as:</p><p><pre><code>method IO(IO::CatHandle:D:)</code></pre></p><p>Alias for .path</p>","lines":"<p>Defined as:</p><p><pre><code>method lines(IO::CatHandle:D: $limit = Inf, :$close --> Seq:D)</code></pre></p><p>Same as IO::Handle.lines. Note that a boundary between source handles is considered to be a newline break.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: \"foo\\nbar\";\n(my $f2 = 'bar'.IO).spurt: 'meow';\nIO::CatHandle.new($f1, $f2).lines.perl.say;\n# OUTPUT: «(\"foo\", \"bar\", \"meow\").Seq␤»\n</code></pre></p><p>Note: if :$close is False, fully-consumed handles are still going to be closed.</p>","readchars":"<p>Defined as:</p><p><pre><code>method readchars(IO::CatHandle:D: Int(Cool:D) $chars = 65536 --> Str:D)</code></pre></p><p>Returns a Str of up to $chars characters read from the handle. $chars defaults to an implementation-specific value (in Rakudo, the value of $*DEFAULT-READ-ELEMS, which by default is set to 65536). It is NOT permitted to call this method on handles opened in binary mode and doing so will result in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'Perl loves to';\n(my $f2 = 'bar'.IO).spurt: ' meow';\n\nwith IO::CatHandle.new: $f1, $f2 {\n    say .readchars: 11;   # OUTPUT: «Perl loves ␤»\n    say .readchars: 1000; # OUTPUT: «to meow␤»\n}\n</code></pre></p>","getc":"<p>Defined as:</p><p><pre><code>method getc(IO::CatHandle:D: --> Bool:D)</code></pre></p><p>Returns a single character of input from the handle. All the caveats described in IO::Handle.getc apply. Returns Nil when there is no more input. It is an error to call this method when the handle is in binary mode, resulting in X::IO::BinaryMode exception being thrown.</p><p><pre><code>(my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n(my $f2 = 'bar'.IO).spurt: 'meow';\nmy $cat = IO::CatHandle.new: $f1, $f2;\n.say while $_ = $cat.getc; # OUTPUT: «I␤ ␤♥␤ ␤P␤e␤r␤l␤m␤e␤o␤w␤»\n</code></pre></p>"},"prefix":"<p><pre><code>class IO::CatHandle is IO::Handle { }</code></pre></p><p>This class has been available in Rakudo since version 2017.06.</p><p>The IO::CatHandle|/type/IO::CatHandle class provides a means to create an IO::Handle that seamlessly gathers input from multiple IO::Handle and IO::Pipe sources.</p><p>All of the IO::Handle's methods are implemented, and while attempt to use write methods will (currently) throw and exception, an IO::CatHandle is usable anywhere a read-only IO::Handle can be used.</p>"},"Attribute":{"name":"Attribute","defs":{"type":"<p>Defined as:</p><p><pre><code>method type(Attribute:D: --> Mu)</code></pre></p><p>Returns the type constraint of the attribute.</p><p><pre><code>class TypeHouse {\n    has Int @.array;\n    has $!scalar;\n    has @.mystery;\n}\nmy @types = TypeHouse.^attributes(:local)[0..2];\nfor 0..2 { say @types[$_].type }\n# OUTPUT: «(Positional[Int])\n# (Mu)\n# (Positional)␤»</code></pre></p>","rw":"<p>Defined as:</p><p><pre><code>method rw(Attribute:D: --> Bool:D)</code></pre></p><p>Returns True for attributes that have the \"is rw\" trait applied to them.</p><p><pre><code>class Library {\n    has $.address; # Read-only value\n    has @.new-books is rw;\n}\nmy $addr = Library.^attributes(:local)[0];\nmy $new-books = Library.^attributes(:local)[1];\nsay $addr.rw;      # OUTPUT: «False␤»\nsay $new-books.rw; # OUTPUT: «True␤»</code></pre></p>","get_value":"<p>Defined as:</p><p><pre><code>method get_value(Mu $obj)</code></pre></p><p>Returns the value stored in this attribute of object $obj.</p><p><pre><code>class Violated {\n    has $!private-thing = 5;\n}\nmy $private = Violated.^attributes(:local)[0];\nsay $private.get_value(Violated.new); # OUTPUT: «5␤»</code></pre></p><p>Note that this method violates encapsulation of the object, and should be used with care. Here be dragons.</p>","set_value":"<p>Defined as:</p><p><pre><code>method set_value(Mu $obj, Mu \\new_val)</code></pre></p><p>Binds the value new_val to this attribute of object $obj.</p><p><pre><code>class A {\n    has $!a = 5;\n    method speak() { say $!a; }\n}\nmy $attr = A.^attributes(:local)[0];\nmy $a = A.new;\n$a.speak; # OUTPUT: «5␤»\n$attr.set_value($a, 42);\n$a.speak; # OUTPUT: «42␤»</code></pre></p><p>Note that this method violates encapsulation of the object, and should be used with care. Here be dragons.</p>","package":"<p>Defined as:</p><p><pre><code>method package()</code></pre></p><p>Returns the package (class/grammar/role) to which this attribute belongs.</p><p><pre><code>class Boo {\n    has @!baz;\n}\nmy $a = Boo.^attributes(:local)[0];\nsay $a.package;         # OUTPUT: «(Boo)␤»</code></pre></p>","gist":"<p>Defined as</p><p><pre><code>multi method gist(Attribute:D:)</code></pre></p><p>Returns the name of the type followed by the name of the attribute.</p><p><pre><code>class Hero {\n    has @!inventory;\n    has Str $.name;\n    submethod BUILD( :$name, :@inventory ) {\n        $!name = $name;\n        @!inventory = @inventory\n    }\n}\nsay Hero.^attributes(:local)[0]; # OUTPUT: «Positional @!inventory»\n</code></pre></p><p>Since say implicitly calls .gist, that is what produces the output here.</p>","required":"<p>Defined as:</p><p><pre><code>method required(Attribute:D: --> Any:D)</code></pre></p><p>Returns 1 for attributes that have the \"is required\" trait applied, or Mu if the attribute did not have that trait applied. If the \"is required\" trait is applied with a string, then that string will be returned instead of 1.</p><p><pre><code>class Library {\n    has $.address is required;\n    has @.new-books is required(\"we always need more books\");\n}\nmy $addr = Library.^attributes(:local)[0];\nmy $new-books = Library.^attributes(:local)[1];\nsay $addr.required;      # OUTPUT: «1␤»\nsay $new-books.readonly; # OUTPUT: «\"we always need more books\"␤»</code></pre></p>","readonly":"<p>Defined as:</p><p><pre><code>method readonly(Attribute:D: --> Bool:D)</code></pre></p><p>Returns True for readonly attributes, which is the default, or False for attributes marked as is rw.</p><p><pre><code>class Library {\n    has $.address; # Read-only value\n    has @.new-books is rw;\n}\nmy $addr = Library.^attributes(:local)[0];\nmy $new-books = Library.^attributes(:local)[1];\nsay $addr.readonly;      # OUTPUT: «True␤»\nsay $new-books.readonly; # OUTPUT: «False␤»</code></pre></p>","has_accessor":"<p>Defined as:</p><p><pre><code>method has_accessor(Attribute:D: --> Bool:D)</code></pre></p><p>Returns True if the attribute has a public accessor method.</p><p><pre><code>class Container {\n    has $!private;\n    has $.public;\n}\nmy $private = Container.^attributes(:local)[0];\nmy $public = Container.^attributes(:local)[1];\nsay $private.has_accessor; # OUTPUT: «False␤»\nsay $public.has_accessor;  # OUTPUT: «True␤»</code></pre></p>","name":"<p>Defined as:</p><p><pre><code>method name(Attribute:D: --> Str:D)</code></pre></p><p>Returns the name of the attribute. Note that this is always the private name, so if an attribute is declared as has $.a, the name returned is $!a.</p><p><pre><code>class Foo {\n    has @!bar;\n}\nmy $a = Foo.^attributes(:local)[0];\nsay $a.name;            # OUTPUT: «@!bar␤»</code></pre></p>"},"prefix":"<p><pre><code>class Attribute { }</code></pre></p><p>In Raku lingo, an attribute refers to a per-instance/object storage slot. An Attribute is used to talk about classes' and roles' attributes at the metalevel.</p><p>Normal usage of attributes does not require the user to use this class explicitly.</p>"},"X::Syntax::Augment::WithoutMonkeyTyping":{"defs":{},"prefix":"<p><pre><code>class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax { }</code></pre></p><p>Compile time error thrown when augment is used without use MONKEY-TYPING.</p><p>Since augment is considered a rather unsafe and impolite action, you have to pre-declare your intent with the use MONKEY-TYPING; pragma.</p><p>If you don't do that, like here</p><p><pre><code>augment class Int { };\n</code></pre></p><p>you get the error</p><p><pre><code>===SORRY!===\naugment not allowed without 'use MONKEY-TYPING'\n</code></pre></p>","name":"X::Syntax::Augment::WithoutMonkeyTyping"},"X::Promise::CauseOnlyValidOnBroken":{"name":"X::Promise::CauseOnlyValidOnBroken","defs":{"promise":"<p><pre><code>method promise()</code></pre></p><p>Returns the Promise that was asked about.</p>"},"prefix":"<p><pre><code>class X::Promise::CauseOnlyValidOnBroken is Exception { }</code></pre></p><p>This exception is thrown when code expects a Promise to be broken, and asks why it has been broken, but the Promise has in fact, not yet been broken.</p>"},"X::IO::Chmod":{"defs":{},"prefix":"<p><pre><code>class X::IO::Chmod does X::IO is Exception { }\n</code></pre></p><p>Error class for failed chmod calls.</p><p>A typical error message is</p><p><pre><code>Failed to set the mode of '/home/other' to '0o777': Permission denied\n</code></pre></p>","name":"X::IO::Chmod"},"Rat":{"prefix":"<p><pre><code>class Rat is Cool does Rational[Int, uint64] { }</code></pre></p><p>Rat objects store rational numbers as a pair of a numerator and denominator. Number literals with a dot but without exponent produce Rats.</p><p><pre><code>say 3.1;          # OUTPUT: «3.1␤»      (same as: Rat.new(31, 10))\nsay 3.1.^name;    # OUTPUT: «Rat␤»\nsay 3.1.nude;     # OUTPUT: «(31 10)␤»\n\nsay <1/2>;        # OUTPUT: «0.5␤»      (same as: Rat.new(1, 2))\nsay <1/2>.^name;  # OUTPUT: «Rat␤»\nsay <1/2>.nude;   # OUTPUT: «(1 2)␤»</code></pre></p><p>Thus arithmetic with short dotted-decimal numbers does not suffer from floating point errors.</p><p>To prevent the numerator and denominator from becoming pathologically large, the denominator is limited to 64 bit storage. On overflow of the denominator a Num (floating-point number) is returned instead.</p><p>For example this function crudely approximates a square root, and overflows the denominator quickly:</p><p><pre><code>sub approx-sqrt($n, $iterations) {\n    my $x = $n;\n    $x = ($x + $n / $x) / 2 for ^$iterations;\n    return $x;\n}\nsay approx-sqrt(2, 5).^name;     # OUTPUT: «Rat␤»\nsay approx-sqrt(2, 10).^name;    # OUTPUT: «Num␤»</code></pre></p><p>If you want arbitrary precision arithmetic with rational numbers, use the FatRat type instead.</p><p>Rat objects are immutable.</p>","defs":{},"name":"Rat"},"Mu":{"name":"Mu","prefix":"<p><pre><code>class Mu { }</code></pre></p><p>The root of the Raku type hierarchy. For the origin of the name, see https://en.wikipedia.org/wiki/Mu_%28negative%29. One can also say that there are many undefined values in Raku, and Mu is the most undefined value.</p><p>Note that most classes do not derive from Mu directly, but rather from Any.</p>","defs":{"gist":"<p><pre><code>multi sub    gist(+args --> Str)\nmulti method gist(   --> Str)</code></pre></p><p>Returns a string representation of the invocant, optimized for fast recognition by humans. As such lists will be truncated at 100 elements. Use .perl to get all elements.</p><p>The default gist method in Mu re-dispatches to the perl method for defined invocants, and returns the type name in parenthesis for type object invocants. Many built-in classes override the case of instances to something more specific that may truncate output.</p><p>gist is the method that say calls implicitly, so say $something and say $something.gist generally produce the same output.</p><p><pre><code>say Mu.gist;        # OUTPUT: «(Mu)␤»\nsay Mu.new.gist;    # OUTPUT: «Mu.new␤»</code></pre></p>","Str":"<p><pre><code>multi method Str(--> Str)</code></pre></p><p>Returns a string representation of the invocant, intended to be machine readable. Method Str warns on type objects, and produces the empty string.</p><p><pre><code>say Mu.Str;   # Use of uninitialized value of type Mu in string context.\nmy @foo = [2,3,1];\nsay @foo.Str  # OUTPUT: «2 3 1␤»</code></pre></p>","print":"<p><pre><code>multi method print(--> Bool:D)</code></pre></p><p>Prints value to $*OUT after stringification using .Str method without adding a newline at end.</p><p><pre><code>\"abc\\n\".print;          # RESULT: «abc␤»</code></pre></p>","WHY":"<p><pre><code>multi method WHY(--> Pod::Block::Declarator)</code></pre></p><p>Returns the attached Pod::Block::Declarator.</p><p>For instance:</p><p><pre><code>#| Initiate a specified spell normally\nsub cast(Spell $s) {\n  do-raw-magic($s);\n}\n#= (do not use for class 7 spells)\nsay &cast.WHY;\n# OUTPUT: «Initiate a specified spell normally␤(do not use for class 7 spells)␤»\n</code></pre></p><p>See Pod declarator blocks for details about attaching Pod to variables, classes, functions, methods, etc.</p>","WHERE":"<p><pre><code>method WHERE(--> Int)</code></pre></p><p>Returns an Int representing the memory address of the object.</p>","WHICH":"<p><pre><code>multi method WHICH(--> ObjAt:D)</code></pre></p><p>Returns an object of type ObjAt which uniquely identifies the object. Value types override this method which makes sure that two equivalent objects return the same return value from WHICH.</p><p><pre><code>say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»</code></pre></p>","ACCEPTS":"<p><pre><code>multi method ACCEPTS(Mu:U: $other)</code></pre></p><p>ACCEPTS is the method that smartmatching with the infix ~~ operator and given/when invokes on the right-hand side (the matcher).</p><p>The Mu:U multi performs a type check. Returns True if $other conforms to the invocant (which is always a type object or failure).</p><p><pre><code>say 42 ~~ Mu;           # OUTPUT: «True␤»\nsay 42 ~~ Int;          # OUTPUT: «True␤»\nsay 42 ~~ Str;          # OUTPUT: «False␤»</code></pre></p><p>Note that there is no multi for defined invocants; this is to allow autothreading of junctions, which happens as a fallback mechanism when no direct candidate is available to dispatch to.</p>","perl":"<p><pre><code>multi method perl(--> Str)</code></pre></p><p>Returns a Perlish representation of the object (i.e., can usually be re-evaluated with EVAL to regenerate the object). The exact output of perl is implementation specific, since there are generally many ways to write a Perl expression that produces a particular value.</p>","new":"<p><pre><code>multi method new(*%attrinit)\nmulti method new($, *@)</code></pre></p><p>Default method for constructing (create + initialize) new objects of a class. This method expects only named arguments which are then used to initialize attributes with accessors of the same name.</p><p>Classes may provide their own new method to override this default.</p><p>new triggers an object construction mechanism that calls submethods named BUILD in each class of an inheritance hierarchy, if they exist. See the documentation on object construction for more information.</p>","return":"<p><pre><code>method return()</code></pre></p><p>The method return will stop execution of a subroutine or method, run all relevant phasers and provide invocant as a return value to the caller. If a return type constraint is provided it will be checked unless the return value is Nil. A control exception is raised and can be caught with CONTROL.</p><p><pre><code>sub f { (1|2|3).return };\nsay f(); # OUTPUT: «any(1, 2, 3)␤»</code></pre></p>","take":"<p><pre><code>sub take(\\item)</code></pre></p><p>Takes the given item and passes it to the enclosing gather block.</p><p><pre><code>#| randomly select numbers for lotto\nmy $num-selected-numbers = 6;\nmy $max-lotto-numbers = 49;\ngather for ^$num-selected-numbers {\n    take (1 .. $max-lotto-numbers).pick(1);\n}.say;    # six random values</code></pre></p>","clone":"<p><pre><code>multi method clone(Mu:U: *%twiddles)\nmulti method clone(Mu:D: *%twiddles)</code></pre></p><p>This method will clone type objects, or die if it's invoked with any argument.</p><p><pre><code>say Num.clone( :yes )\n# OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block <unit>␤␤»\n</code></pre></p><p>If invoked with value objects, it creates a shallow clone of the invocant, including shallow cloning of private attributes. Alternative values for public attributes can be provided via named arguments with names matching the attributes' names.</p><p><pre><code>class Point2D {\n    has ($.x, $.y);\n    multi method gist(Point2D:D:) {\n        \"Point($.x, $.y)\";\n    }\n}\n\nmy $p = Point2D.new(x => 2, y => 3);\n\nsay $p;                     # OUTPUT: «Point(2, 3)␤»\nsay $p.clone(y => -5);      # OUTPUT: «Point(2, -5)␤»\n</code></pre></p><p>Note that .clone does not go the extra mile to shallow-copy @. and %. sigiled attributes and, if modified, the modifications will still be available in the original object:</p><p><pre><code>class Foo {\n    has $.foo is rw = 42;\n    has &.boo is rw = { say \"Hi\" };\n    has @.bar       = <a b>;\n    has %.baz       = <a b c d>;\n}\n\nmy $o1 = Foo.new;\nwith my $o2 = $o1.clone {\n    .foo = 70;\n    .bar = <Z Y>;\n    .baz = <Z Y X W>;\n    .boo = { say \"Bye\" };\n}\n\n# Hash and Array attribute modifications in clone appear in original as well:\nsay $o1;\n# OUTPUT: «Foo.new(foo => 42, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\nsay $o2;\n# OUTPUT: «Foo.new(foo => 70, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n$o1.boo.(); # OUTPUT: «Hi␤»\n$o2.boo.(); # OUTPUT: «Bye␤»\n</code></pre></p><p>To clone those, you could implement your own .clone that clones the appropriate attributes and passes the new values to Mu.clone, for example, via nextwith.</p><p><pre><code>class Bar {\n    has $.quux;\n    has @.foo = <a b>;\n    has %.bar = <a b c d>;\n    method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n}\n\nmy $o1 = Bar.new( :42quux );\nwith my $o2 = $o1.clone {\n    .foo = <Z Y>;\n    .bar = <Z Y X W>;\n}\n\n# Hash and Array attribute modifications in clone do not affect original:\nsay $o1;\n# OUTPUT: «Bar.new(quux => 42, foo => [\"a\", \"b\"], bar => {:a(\"b\"), :c(\"d\")})␤»\nsay $o2;\n# OUTPUT: «Bar.new(quux => 42, foo => [\"Z\", \"Y\"], bar => {:X(\"W\"), :Z(\"Y\")})␤»\n</code></pre></p><p>The |%_ is needed to slurp the rest of the attributes that would have been copied via shallow copy.</p>","bless":"<p><pre><code>method bless(*%attrinit --> Mu:D)</code></pre></p><p>Low-level object construction method, usually called from within new, implicitly from the default constructor, or explicitly if you create your own constructor. bless creates a new object of the same type as the invocant, using the named arguments to initialize attributes and returns the created object.</p><p>It is usually invoked within custom new method implementations:</p><p><pre><code>class Point {\n    has $.x;\n    has $.y;\n    multi method new($x, $y) {\n        self.bless(:$x, :$y);\n    }\n}\nmy $p = Point.new(-1, 1);\n</code></pre></p><p>In this case we are declaring new as a multi method so that we can still use the default constructor like this: Point.new( x => 3, y => 8 ). In this case we are declaring this new method simply to avoid the extra syntax of using pairs when creating the object. self.bless returns the object, which is in turn returned by new.</p><p>However, in general, implementing a customized new method might not be the best way of initializing a class, even more so if the default constructor is disabled, since it can make it harder to correctly initialize the class from a subclass. For instance, in the above example, the new implementation takes two positional arguments that must be passed from the subclass to the superclass in the exact order. That is not a real problem if it's documented, but take into account bless will eventually be calling BUILD in the class that is being instantiated. This might result in some unwanted problems, like having to create a BUILD submethod to serve it correctly:</p><p><pre><code>class Point {\n    has Int $.x;\n    has Int $.y;\n    multi method new($x, $y) {\n        self.bless(:$x, :$y);\n    }\n}\n\nclass Point-with-ID is Point {\n    has Int $.ID  is rw = 0;\n\n    submethod BUILD( *%args ) {\n        say %args;                # OUTPUT: «{x => 1, y => 2}␤»\n        for self.^attributes -> $attr {\n            if $attr.Str ~~ /ID/ {\n                $attr.set_value( self, \"*\" ~ %args<x> ~ \"-\" ~ %args<y> ) ;\n            }\n        }\n    }\n}\n\nmy $p = Point-with-ID.new(1,2);\nsay $p.perl;\n# OUTPUT: «Point-with-ID.new(ID => \"*1-2\", x => 1, y => 2)␤»\n</code></pre></p><p>In this code, bless, called within Point.new, is eventually calling BUILD with the same parameters. We have to create a convoluted way of using the $.ID attribute using the metaobject protocol so that we can instantiate it and thus serve that new constructor, which can be called on Point-with-ID since it is a subclass.</p><p>We might have to use something similar if we want to instantiate superclasses. bless will help us with that, since it is calling across all the hierarchy:</p><p><pre><code>class Str-with-ID is Str {\n    my $.counter = 0;\n    has Int $.ID  is rw = 0;\n\n    multi method new( $str ) {\n        self.bless( value => $str, ID => $.counter++ );\n    }\n\n    submethod BUILD( *%args ) {\n        for self.^attributes -> $attr {\n            if $attr.Str ~~ /ID/ {\n                $attr.set_value( self, %args<ID> ) ;\n            }\n        }\n    }\n}\n\nsay Str-with-ID.new(\"1.1,2e2\").ID;                  # OUTPUT: «0␤»\nmy $enriched-str = Str-with-ID.new(\"3,4\");\nsay \"$enriched-str, {$enriched-str.^name}, {$enriched-str.ID}\";\n# OUTPUT: «3,4, Str-with-ID, 1␤»\n</code></pre></p><p>We are enriching Str with an auto-incrementing ID. We create a new since we want to initialize it with a string and, besides, we need to instantiate the superclass. We do so using bless from within new. bless is going to call Str.BUILD. It will *capture* the value it's looking for, the pair value = $str> and initialize itself. But we have to initialize also the properties of the subclass, which is why within BUILD we use the previously explained method to initialize $.ID with the value that is in the %args variable. As shown in the output, the objects will be correctly initialized with its ID, and will correctly behave as Str, converting themselves in just the string in the say statement, and including the ID property as required.</p><p>For more details see the documentation on object construction.</p>","so":"<p><pre><code>method so()</code></pre></p><p>Evaluates the item in boolean context (and thus, for instance, collapses Junctions), and returns the result. It is the opposite of not, and equivalent to the ? operator.</p><p>One can use this method similarly to the English sentence: \"If that is so, then do this thing\". For instance,</p><p><pre><code>my @args = <-a -e -b -v>;\nmy $verbose-selected = any(@args) eq '-v' | '-V';\nif $verbose-selected.so {\n    say \"Verbose option detected in arguments\";\n} # OUTPUT: «Verbose option detected in arguments␤»</code></pre></p><p>The $verbose-selected variable in this case contains a Junction, whose value is any(any(False, False), any(False, False), any(False, False), any(True, False)). That is actually a truish value; thus, negating it will yield False. The negation of that result will be True. so is performing all those operations under the hood.</p>","take-rw":"<p><pre><code>sub take-rw(\\item)</code></pre></p><p>Returns the given item to the enclosing gather block, without introducing a new container.</p><p><pre><code>my @a = 1...3;\nsub f(@list){ gather for @list { take-rw $_ } };\nfor f(@a) { $_++ };\nsay @a;\n# OUTPUT: «[2 3 4]␤»</code></pre></p>","emit":"<p><pre><code>method emit()</code></pre></p><p>Emits the invocant into the enclosing supply or react block.</p><p><pre><code>react { whenever supply { .emit for \"foo\", 42, .5 } {\n    say \"received {.^name} ($_)\";\n}}\n\n# OUTPUT:\n# received Str (foo)\n# received Int (42)\n# received Rat (0.5)</code></pre></p>","self":"<p><pre><code>method self(--> Mu)</code></pre></p><p>Returns the object it is called on.</p>","Capture":"<p>Declared as:</p><p><pre><code>method Capture(Mu:D: --> Capture:D)</code></pre></p><p>Returns a Capture with named arguments corresponding to invocant's public attributes:</p><p><pre><code>class Foo {\n    has $.foo = 42;\n    has $.bar = 70;\n    method bar { 'something else' }\n}.new.Capture.say; # OUTPUT: «\\(:bar(\"something else\"), :foo(42))␤»</code></pre></p>","say":"<p><pre><code>multi method say()</code></pre></p><p>Will say to standard output.</p><p><pre><code>say 42;                 # OUTPUT: «42␤»</code></pre></p><p>What say actually does is, thus, deferred to the actual subclass. In most cases it calls .gist on the object, returning a compact string representation.</p><p>In non-sink context, say will always return True.</p><p><pre><code>say (1,[1,2],\"foo\",Mu).map: so *.say ;\n# OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»</code></pre></p><p>However, this behavior is just conventional and you shouldn't trust it for your code. It's useful, however, to explain certain behaviors.</p><p>say is first printing out in *.say, but the outermost say is printing the True values returned by the so operation.</p>","iterator":"<p>Defined as:</p><p><pre><code>method iterator(--> Iterator)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses iterator on it.</p><p><pre><code>my $it = Mu.iterator;\nsay $it.pull-one; # OUTPUT: «(Mu)␤»\nsay $it.pull-one; # OUTPUT: «IterationEnd␤»</code></pre></p>","Bool":"<p><pre><code>multi sub    Bool(Mu --> Bool:D)\nmulti method Bool(   --> Bool:D)</code></pre></p><p>Returns False on the type object, and True otherwise.</p><p>Many built-in types override this to be False for empty collections, the empty string or numerical zeros</p><p><pre><code>say Mu.Bool;                    # OUTPUT: «False␤»\nsay Mu.new.Bool;                # OUTPUT: «True␤»\nsay [1, 2, 3].Bool;             # OUTPUT: «True␤»\nsay [].Bool;                    # OUTPUT: «False␤»\nsay %( hash => 'full' ).Bool;   # OUTPUT: «True␤»\nsay {}.Bool;                    # OUTPUT: «False␤»\nsay \"\".Bool;                    # OUTPUT: «False␤»\nsay 0.Bool;                     # OUTPUT: «False␤»\nsay 1.Bool;                     # OUTPUT: «True␤»\nsay \"0\".Bool;                   # OUTPUT: «True␤»</code></pre></p>","return-rw":"<p>Same as method return except that return-rw returns a writable container to the invocant (see more details here: return-rw).</p>","item":"<p><pre><code>method item(Mu \\item:) is raw</code></pre></p><p>Forces the invocant to be evaluated in item context and returns the value of it.</p><p><pre><code>say [1,2,3].item.perl;          # OUTPUT: «$[1, 2, 3]␤»\nsay %( apple => 10 ).item.perl; # OUTPUT: «${:apple(10)}␤»\nsay \"abc\".item.perl;            # OUTPUT: «\"abc\"␤»</code></pre></p>","put":"<p><pre><code>multi method put(--> Bool:D)</code></pre></p><p>Prints value to $*OUT, adding a newline at end, and if necessary, stringifying non-Str object using the .Str method.</p><p><pre><code>\"abc\".put;              # RESULT: «abc␤»</code></pre></p>","CREATE":"<p><pre><code>method CREATE(--> Mu:D)</code></pre></p><p>Allocates a new object of the same type as the invocant, without initializing any attributes.</p><p><pre><code>say Mu.CREATE.defined;  # OUTPUT: «True␤»</code></pre></p>","does":"<p><pre><code>method does(Mu $type --> Bool:D)</code></pre></p><p>Returns True if and only if the invocant conforms to type $type.</p><p><pre><code>my $d = Date.new('2016-06-03');\nsay $d.does(Dateish);             # True    (Date does role Dateish)\nsay $d.does(Any);                 # True    (Date is a subclass of Any)\nsay $d.does(DateTime);            # False   (Date is not a subclass of DateTime)\n</code></pre></p><p>Unlike isa, which returns True only for superclasses, does includes both superclasses and roles.</p><p><pre><code>say $d.isa(Dateish); # OUTPUT: «False␤»\n</code></pre></p><p>Using the smartmatch operator ~~ is a more idiomatic alternative.</p><p><pre><code>my $d = Date.new('2016-06-03');\nsay $d ~~ Dateish;                # OUTPUT: «True␤»\nsay $d ~~ Any;                    # OUTPUT: «True␤»\nsay $d ~~ DateTime;               # OUTPUT: «False␤»</code></pre></p>","isa":"<p><pre><code>multi method isa(Mu $type     --> Bool:D)\nmulti method isa(Str:D $type  --> Bool:D)</code></pre></p><p>Returns True if the invocant is an instance of class $type, a subset type or a derived class (through inheritance) of $type. does is similar, but includes roles.</p><p><pre><code>my $i = 17;\nsay $i.isa(\"Int\");   # OUTPUT: «True␤»\nsay $i.isa(Any);     # OUTPUT: «True␤»\nrole Truish {};\nmy $but-true = 0 but Truish;\nsay $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\nsay $but-true.does(Truish); # OUTPUT: «True␤»\nsay $but-true.isa(Truish);  # OUTPUT: «False␤»</code></pre></p>","defined":"<p>Declared as</p><p><pre><code>multi sub defined(Mu --> Bool:D)</code></pre></p><p>invokes the .defined method on the object and returns its result.</p>"}},"HyperSeq":{"name":"HyperSeq","defs":{"is-lazy":"<p><pre><code>method is-lazy(--> False )</code></pre></p><p>Returns False.</p>","serial":"<p><pre><code>multi method serial(HyperSeq:D:)</code></pre></p><p>Converts the object to a Seq and returns it.</p>","race":"<p><pre><code>method race(HyperSeq:D:)</code></pre></p><p>Creates a RaceSeq object out of the current one.</p>","grep":"<p><pre><code>method grep(HyperSeq:D: $matcher, *%options)</code></pre></p><p>Applies grep to the HyperSeq similarly to how it would do it on a Seq.</p><p><pre><code>my @hyped = (^10000).map(*²).hyper;\n@hyped.grep( * %% 3 ).say;\n# OUTPUT: «(0 9 36 81 144…»\n</code></pre></p><p>When you use hyper on a Seq, this is the method that is actually called.</p>","hyper":"<p><pre><code>method hyper(HyperSeq:D:)</code></pre></p><p>Returns the object.</p>","invert":"<p><pre><code>method invert(HyperSeq:D:)</code></pre></p><p>Inverts the HyperSeq created from a Seq by .hyper.</p>","map":"<p><pre><code>method map(HyperSeq:D: $matcher, *%options)</code></pre></p><p>Uses maps on the HyperSeq, generally created by application of hyper to a preexisting Seq.</p>","iterator":"<p><pre><code>method iterator(HyperSeq:D: --> Iterator:D)</code></pre></p><p>Returns the underlying iterator.</p>"},"prefix":"<p><pre><code>class HyperSeq does Iterable does Sequence { }</code></pre></p><p>An HyperSeq is the intermediate object used when the operator hyper is invoked on a Seq. In general, it's not intended for direct consumption by the developer.</p>"},"Real":{"name":"Real","prefix":"<p><pre><code>role Real does Numeric { ... }</code></pre></p><p>Common role for non-Complex numbers.</p>","defs":{"Real":"<p>Defined as:</p><p><pre><code>multi method Real(Real:D: --> Real:D)\nmulti method Real(Real:U: --> Real:D)</code></pre></p><p>The :D variant simply returns the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns self.new.</p>","ceiling":"<p><pre><code>method ceiling(Real:D --> Int:D)</code></pre></p><p>Returns the smallest integer not less than the number.</p>","Rat":"<p><pre><code>method Rat(Real:D: Real $epsilon = 1e-6)</code></pre></p><p>Converts the number to a Rat with the precision $epsilon.</p>","truncate":"<p><pre><code>method truncate(Real:D --> Int:D)</code></pre></p><p>Rounds the number towards zero.</p>","sign":"<p><pre><code>method sign(Real:D:)</code></pre></p><p>Returns -1 if the number is negative, 0 if it is zero and 1 otherwise.</p>","Bridge":"<p>Defined as:</p><p><pre><code>method Bridge(Real:D:)</code></pre></p><p>Default implementation coerces the invocant to Num and that's the behavior of this method in core Real types. This method primarily exist to make it easy to implement custom Real types by users, with the Bridge method returning one of the core Real types (NOT necessarily a Num) that best represent the custom Real type. In turn, this lets all the core operators and methods obtain a usable value they can work with.</p><p>As an example, we can implement a custom Temperature type. It has a unit of measure and the value, which are given during instantiation. We can implement custom operators or conversion methods that work with this type. When it comes to regular mathematical operators, however, we can simply use the .Bridge method to convert the Temperature to Kelvin expressed in one of the core numeric types:</p><p><pre><code>class Temperature is Real {\n    has Str:D  $.unit  is required where any <K F C>;\n    has Real:D $.value is required;\n    method new ($value, :$unit = 'K') { self.bless :$value :$unit }\n    # Note: implementing .new() that handles $value of type Temperature is left as an exercise\n\n    method Bridge {\n        when $!unit eq 'F' { ($!value + 459.67) × 5/9 }\n        when $!unit eq 'C' {  $!value + 273.15 }\n        $!value\n    }\n    method gist { self.Str }\n    method Str  { \"$!value degrees $!unit\" }\n}\n\nsub postfix:<℃> { Temperature.new: $^value, :unit<C> }\nsub postfix:<℉> { Temperature.new: $^value, :unit<F> }\nsub postfix:<K> { Temperature.new: $^value, :unit<K> }\n\nmy $human := 36.6℃;\nmy $book  := 451℉;\nmy $sun   := 5778K;\nsay $human;                # OUTPUT: «36.6 degrees C␤»\nsay $human + $book + $sun; # OUTPUT: «6593.677777777778␤»\nsay 123K + 456K;           # OUTPUT: «579␤»</code></pre></p><p>As we can see from the last two lines of the output, the type of the bridged result is not forced to be any particular core type. It is a Rat, when we instantiated Temperature with a Rat or when conversion was involved, and it is an Int when we instantiated Temperature with an Int.</p>","polymod":"<p><pre><code>method polymod(Real:D: +@mods)</code></pre></p><p>Returns the remainders after applying sequentially all divisors in the @mods argument; the last element of the array will be the last remainder.</p><p><pre><code>say (1e8+1).polymod(10 xx 8);  # OUTPUT: «(1 0 0 0 0 0 0 0 1)␤»</code></pre></p><p>10 xx 8 is simply an array with eight number 10s; the first division by 10 will return 1 as a remainder, while the rest, up to the last, will return 0. With 8 divisors, as above, the result will have one more elements, in this case for the last remainder.</p>","round":"<p><pre><code>method round(Real:D: $scale = 1)</code></pre></p><p>Rounds the number to scale $scale. If $scale is 1, rounds to an integer. If scale is 0.1, rounds to one digit after the comma etc.</p>","rand":"<p><pre><code>sub term:<rand> (--> Num:D)\nmethod rand(Real:D: --> Real:D)</code></pre></p><p>Returns a pseudo-random number between zero (inclusive) and the number (non-inclusive). The Bridge method is used to coerce the Real to a numeric that supports rand method.</p><p>The term form returns a pseudo-random Num between 0e0 (inclusive) and 1e0 (non-inclusive.)</p>","Complex":"<p><pre><code>method Complex(Real:D: --> Complex:D)</code></pre></p><p>Converts the number to a Complex with the number converted to a Num as its real part and 0e0 as the imaginary part.</p>","floor":"<p><pre><code>method floor(Real:D --> Int:D)</code></pre></p><p>Return the largest integer not greater than the number.</p>"}},"X::Syntax::NegatedPair":{"name":"X::Syntax::NegatedPair","defs":{},"prefix":"<p><pre><code>class X::Syntax::NegatedPair does X::Syntax { }</code></pre></p><p>Thrown if a colonpair illegally has a value, for example :!a(1). This is an error because the ! negation implies that the value is False.</p><p>A typical error message from this class is Argument not allowed on negated pair with key 'a'.</p>"},"Metamodel::PackageHOW":{"name":"Metamodel::PackageHOW","defs":{"new_type":"<p>Defined as:</p><p><pre><code>method new_type(:$name = '<anon>', :$repr, :$ver, :$auth)</code></pre></p><p>Creates a new package, with optional representation, version and auth field.</p>","new":"<p>Defined as:</p><p><pre><code>method new(*%named)</code></pre></p><p>Creates a new PackageHOW.</p>","archetypes":"<p>Defined as:</p><p><pre><code>method archetypes()</code></pre></p><p>Returns the archetypes for this model, that is, the properties a metatype can implement.</p>"},"prefix":"<p><pre><code>class Metamodel::PackageHOW\n  does Metamodel::Naming\n  does Metamodel::Documenting\n  does Metamodel::Stashing\n  does Metamodel::TypePretense\n  does Metamodel::MethodDelegation { }</code></pre></p><p>Metamodel::ClassHOW is the metaclass behind the package keyword.</p><p><pre><code>package P {};\nsay P.HOW; # OUTPUT: «Perl6::Metamodel::PackageHOW.new␤»</code></pre></p><p>Warning: This class is part of the Rakudo implementation, not a part of the language itself.</p>"},"X::Parameter::Placeholder":{"name":"X::Parameter::Placeholder","prefix":"<p><pre><code>class X::Parameter::Placeholder does X::Comp { }</code></pre></p><p>Thrown when a placeholder parameter is used inside a signature where a normal parameter is expected. The reason is often that a named parameter :$param was misspelled as $:param.</p><p>For example</p><p><pre><code>sub f($:param) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nIn signature parameter, placeholder variables like $:param are illegal\nyou probably meant a named parameter: ':$param'\n</code></pre></p>","defs":{"parameter":"<p>The text of the offensive parameter declaration ($:param in the example above).</p>"}},"X::Syntax::Signature::InvocantMarker":{"prefix":"<p><pre><code>class X::Syntax::Signature::InvocantMarker does X::Syntax { }</code></pre></p><p>Syntax error when the invocant in a signature is anywhere else than after the first parameter.</p><p>For example</p><p><pre><code>:($a, $b: $c);\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCan only use : as invocant marker in a signature after the first parameter\n</code></pre></p><p>See also: Signature.</p>","defs":{},"name":"X::Syntax::Signature::InvocantMarker"},"Pod::Block::Declarator":{"name":"Pod::Block::Declarator","prefix":"<p><pre><code>class Pod::Block::Declarator is Pod::Block { }</code></pre></p><p>Class for a declarator Pod block</p>","defs":{"trailing":"<p><pre><code>method trailing(--> Str)</code></pre></p><p>Returns the trailing Pod comment attached to the declarator</p>","leading":"<p><pre><code>method leading(--> Str)</code></pre></p><p>Returns the leading Pod comment attached to the declarator</p>"}},"X::Declaration::Scope":{"name":"X::Declaration::Scope","defs":{"scope":"<p><pre><code>method scope(--> Str:D)</code></pre></p><p>Returns a string representation of the scope, usually the same keyword that is used for the declaration (\"my\", \"our\", \"has\", ...);</p>"},"prefix":"<p><pre><code>class X::Declaration::Scope does X::Comp { }\n</code></pre></p><p>Compile time error thrown when a declaration does not harmonize with the declared scope.</p><p>For example</p><p><pre><code>has sub f() { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use 'has' with sub declaration\n</code></pre></p>"},"Method":{"name":"Method","defs":{},"prefix":"<p><pre><code>class Method is Routine { }</code></pre></p><p>A type for methods that behave the same way as Routine with some exceptions listed in the following. For details of a method's parameter list see Signature.</p><p>To create a method outside a class definition, use the declarators my and method. If an identifier is provided the methods name will be injected into the scope specified by the declarator.</p><p><pre><code>my $m = method ($invocant: $param) {\n    say \"$invocant: '$param'\";\n}\n\"greeting\".$m(\"hello\");  # OUTPUT: «greeting: 'hello'␤»\n\n<a b c>.&(my method (List:D:) { say self.perl; self }).say;\n# OUTPUT: «(\"a\", \"b\", \"c\")␤(a b c)␤»</code></pre></p><p>The invocant of a method defaults to self. A type constraint including a type-smiley can be used and is honored both for methods defined in a class and for free floating methods. Call the latter with .& on an object.</p><p><pre><code>my method m(Int:D: $b){\n    say self.^name\n}\nmy $i = 1;\n$i.&m(<a>);\n# OUTPUT: «Int␤»</code></pre></p><p> Methods will ignore extra named arguments where other types of Routine will throw at runtime. Extra arguments will be forwarded by nextsame and friends.</p><p><pre><code>class A {\n    multi method m(:$a, :$b) { say \"2 named\" }\n}\n\nclass B is A {\n    method m(:$a) { say \"1 named\"; nextsame }\n}\nB.m( :1a, :2b );\n# OUTPUT: «1 named␤2 named␤»</code></pre></p>"},"Mixy":{"prefix":"<p><pre><code>role Mixy does Baggy { }</code></pre></p><p>A role for collections of weighted values. See Mix and MixHash. Mixy objects differ from Baggy objects in that the weights of Mixy are Reals rather than Ints.</p>","defs":{"roll":"<p><pre><code>method roll($count = 1)</code></pre></p><p>Similar to a Bag.roll, but with Real weights rather than integral ones.</p>","total":"<p><pre><code>method total(--> Real)</code></pre></p><p>Returns the sum of all the weights</p><p><pre><code>say mix('a', 'b', 'c', 'a', 'a', 'd').total == 6;  # OUTPUT: «True␤»\nsay %(a => 5.6, b => 2.4).Mix.total == 8;          # OUTPUT: «True␤»</code></pre></p>"},"name":"Mixy"},"Capture":{"prefix":"<p> </p><p><pre><code>class Capture { }\n</code></pre></p><p>A Capture is a container for passing arguments to a code object. Captures are the flip-side of Signatures – Captures are the caller defined arguments, while Signatures are the callee defined parameters.</p><p>When you call print $a, $b, the $a, $b part is a Capture.</p><p>Captures contain a list-like part for positional arguments and a hash-like part for named arguments, thus behaving as Positional and Associative, although it does not actually mixes in those roles. For the named arguments, Captures use a slightly different syntax than a normal List. There are two easy ways to make a named argument: 1) use an unquoted key naming a parameter, followed by =>, followed by the argument and 2) use a colon-pair literal named after the parameter:</p><p><pre><code>say unique 1, -2, 2, 3, as => { abs $_ };   # OUTPUT: «(1 -2 3)␤»\n# ... is the same thing as:\nsay unique 1, -2, 2, 3, :as({ abs $_ });    # OUTPUT: «(1 -2 3)␤»\n# Be careful not to quote the name of a named parameter:\nsay unique 1, -2, 2, 3, 'as' => { abs $_ };\n# OUTPUT: «(1 -2 2 3 as => -> ;; $_? is raw { #`(Block|78857320) ... })␤»</code></pre></p><p>A stand-alone Capture can also be made, stored, and used later. A literal Capture can be created by prefixing a term with a backslash \\. Commonly, this term will be a List of terms, from which any Pair literal will be placed in the named part, and all other terms will be placed in the positional part.</p><p><pre><code>my $c = \\(42);          # Capture with one positional part\n$c = \\(1, 2, a => 'b'); # Capture with two positional and one named parts</code></pre></p><p>To use such a Capture, you may use '|' before it in a function call, and it will be as if the values in the Capture were passed directly to the function as arguments – named arguments will be passed as named arguments and positional arguments will be passed as positional arguments. You may re-use the Capture as many times as you want, even with different functions.</p><p><pre><code>my $c = \\(4, 2, 3);\nreverse(|$c).say; # OUTPUT: «3 2 4␤»\nsort(5,|$c).say;  # OUTPUT: «2 3 4 5␤»</code></pre></p><p>Inside a Signature, a Capture may be created by prefixing a sigilless parameter with a vertical bar |. This packs the remainder of the argument list into that parameter.</p><p><pre><code>f(1, 2, 3, a => 4, b => 5);\nsub f($a, |c) {\n    # c  is  \\(2, 3, a => 4, b => 5)\n}</code></pre></p><p>Note that Captures are still Lists in that they may contain containers, not just values:</p><p><pre><code>my $b = 1;\nmy $c = \\(4, 2, $b, 3);\nsort(|$c).say;        # OUTPUT: «1 2 3 4␤»\n$b = 6;\nsort(|$c).say;        # OUTPUT: «2 3 4 6␤»</code></pre></p>","defs":{"keys":"<p>Defined as:</p><p><pre><code>multi method keys(Capture:D: --> Seq:D)</code></pre></p><p>Returns a Seq containing all positional keys followed by all named keys. For positional arguments the keys are the respective arguments ordinal position starting from zero.</p><p><pre><code>my $capture = \\(2, 3, 5, apples => (red => 2));\nsay $capture.keys;                             # OUTPUT: «(0 1 2 apples)␤»</code></pre></p>","pairs":"<p>Defined as:</p><p><pre><code>multi method pairs(Capture:D: --> Seq:D)</code></pre></p><p>Returns all arguments, the positional followed by the named, as a Seq of Pairs. Positional arguments have their respective ordinal value, starting at zero, as key while the named arguments have their names as key.</p><p><pre><code>my Capture $c = \\(2, 3, apples => (red => 2));\nsay $c.pairs;                                     # OUTPUT: «(0 => 2 1 => 3 apples => red => 2)␤»</code></pre></p>","antipairs":"<p>Defined as:</p><p><pre><code>multi method antipairs(Capture:D: --> Seq:D)</code></pre></p><p>Returns all arguments, the positional followed by the named, as a Seq of pairs where the keys and values have been swapped, i.e. the value becomes the key and the key becomes the value. This behavior is the opposite of the pairs method.</p><p><pre><code>my $capture = \\(2, 3, apples => (red => 2));\nsay $capture.antipairs;                           # OUTPUT: «(2 => 0 3 => 1 (red => 2) => apples)␤»</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>multi method values(Capture:D: --> Seq:D)</code></pre></p><p>Returns a Seq containing all positional values followed by all named argument values.</p><p><pre><code>my $capture = \\(2, 3, 5, apples => (red => 2));\nsay $capture.values;                           # OUTPUT: «(2 3 5 red => 2)␤»</code></pre></p>","hash":"<p>Defined as:</p><p><pre><code>method hash(Capture:D:)</code></pre></p><p>Returns the named/hash part of the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples => (red => 2));\nsay $c.hash; # OUTPUT: «Map.new((:apples(:red(2))))␤»</code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>multi method kv(Capture:D: --> Seq:D)</code></pre></p><p>Returns a Seq of alternating keys and values. The positional keys and values, if any, comes first followed by the named keys and values.</p><p><pre><code>my $capture = \\(2, 3, apples => (red => 2));\nsay $capture.kv;                                  # OUTPUT: «(0 2 1 3 apples red => 2)␤»</code></pre></p>","list":"<p>Defined as:</p><p><pre><code>method list(Capture:D:)</code></pre></p><p>Returns the positional part of the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples => (red => 2));\nsay $c.list;                                      # OUTPUT: «(2 3 5)␤»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(Capture:D: --> Capture:D)</code></pre></p><p>Returns itself, i.e. the invocant.</p><p><pre><code>say \\(1,2,3, apples => 2).Capture; # OUTPUT: «\\(1, 2, 3, :apples(2))␤»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(Capture:D: --> Bool:D)</code></pre></p><p>Returns True if the Capture contains at least one named or one positional argument.</p><p><pre><code>say \\(1,2,3, apples => 2).Bool;                   # OUTPUT: «True␤»\nsay \\().Bool;                                     # OUTPUT: «False␤»</code></pre></p>","elems":"<p>Defined as:</p><p><pre><code>method elems(Capture:D: --> Int:D)</code></pre></p><p>Returns the number of positional elements in the Capture.</p><p><pre><code>my Capture $c = \\(2, 3, 5, apples => (red => 2));\nsay $c.elems;                                  # OUTPUT: «3␤»</code></pre></p>"},"name":"Capture"},"IO::Notification":{"defs":{},"prefix":"<p><pre><code>enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));\n</code></pre></p><p><pre><code>class IO::Notification  {\n    class Change {\n        has $.path;\n        has $.event;\n    }\n    ...\n}\n</code></pre></p><p>IO::Notification.watch-path($path) produces a Supply of IO::Notification::Change events for a file or directory.</p><p>Here is a small example that prints the first ten FileChanged-notifications for the current working directory:</p><p><pre><code>my $finish = Promise.new;\nmy $count = 0;\nIO::Notification.watch-path($*CWD).act( -> $change {\n    $count++ if $change.event ~~ FileChanged;\n    say \"($count) $change.path(): $change.event()\";\n    $finish.keep if $count >= 10;\n});\nawait $finish;\n</code></pre></p><p>The type of the change is very much dependent both on the platform and on specific system calls that were used initiate the change. At this point in time you should not rely on the type of change in general, and test your particular situation.</p>","name":"IO::Notification"},"Backtrace":{"name":"Backtrace","prefix":"<p><pre><code>class Backtrace {}</code></pre></p><p>A backtrace contains the dynamic call stack, usually leading up to a point where an exception was thrown, and is a List of Backtrace::Frame objects. Its default stringification excludes backtrace frames that are deemed unnecessary or confusing; for example routines like &die are hidden by default. Being a list, you can also access individual elements.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry {\n    zipi;\n}\nif ($!) {\n    say $!.backtrace[*-1].perl;\n}\n</code></pre></p><p>This will print the last frame in the list, pointing at the line where it's happened.</p>","defs":{"map":"<p>Defined as:</p><p><pre><code>multi method map(Backtrace:D: &block --> Seq:D)</code></pre></p><p>It invokes &block for each element and gathers the return values in a sequence and returns it.</p><p>This program:</p><p><pre><code>sub inner { Backtrace.new.map({ say \"{$_.file}: {$_.line}\" }); }\nsub outer { inner; }\nouter;</code></pre></p><p>results in:</p><p><pre><code>SETTING::src/core/Backtrace.pm6: 85\nSETTING::src/core/Backtrace.pm6: 85\ntest.p6: 1\ntest.p6: 2\ntest.p6: 3\ntest.p6: 1\n</code></pre></p>","nice":"<p>Defined as:</p><p><pre><code>method nice(Backtrace:D: :$oneline)</code></pre></p><p>Returns the backtrace as a list of interesting frames. If :$oneline is set, will stop after the first frame.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.nice( :oneline ) if $!;\n# OUTPUT: «  in sub zipi at /tmp/... line 1␤␤»\n</code></pre></p>","full":"<p>Defined as:</p><p><pre><code>multi method full(Backtrace:D:)</code></pre></p><p>Returns a full string representation of the backtrace, including hidden frames, compiler-specific frames, and those from the setting.</p><p><pre><code>my $backtrace = Backtrace.new;\nsay $backtrace.full;</code></pre></p>","concise":"<p>Defined as:</p><p><pre><code>method concise(Backtrace:D:)</code></pre></p><p>Returns a concise string representation of the backtrace, filtered by !.is-hidden && .is-routine && !.is-setting.</p><p>This program:</p><p><pre><code>sub inner { say Backtrace.new.concise }\nsub outer { inner; }\nouter;</code></pre></p><p>results in:</p><p><pre><code>in sub inner at test.p6 line 1\nin sub outer at test.p6 line 2\n</code></pre></p>","next-interesting-index":"<p>Defined as:</p><p><pre><code>method next-interesting-index(Backtrace:D: Int $idx = 0, :$named, :$noproto, :$setting)</code></pre></p><p>Returns the index of the next interesting frame, once hidden and other settings are taken into account. $named will decide whether to printed only those with a name, $noproto will hide protos, and $setting will hide those are considered setting.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.next-interesting-index;           # OUTPUT: «2␤»\nsay $!.backtrace.next-interesting-index( :named ); #  OUTPUT: «4␤»\n</code></pre></p>","summary":"<p>Defined as:</p><p><pre><code>method summary(Backtrace:D: --> Str:D)</code></pre></p><p>Returns a summary string representation of the backtrace, filtered by !.is-hidden && (.is-routine || !.is-setting).</p><p>This program:</p><p><pre><code>sub inner { say Backtrace.new.summary }\nsub outer { inner; }\nouter;</code></pre></p><p>results in:</p><p><pre><code>in method new at SETTING::src/core/Backtrace.pm6 line 85\nin sub inner at test.p6 line 1\nin sub outer at test.p6 line 2\nin block <unit> at test.p6 line 3\n</code></pre></p>","list":"<p>Defined as:</p><p><pre><code>multi method list(Backtrace:D:)</code></pre></p><p>Returns a list of Backtrace::Frame objects for this backtrace.</p>","new":"<p>Defined as:</p><p><pre><code>multi method new()\nmulti method new(Int:D $offset)\nmulti method new(Mu \\ex)\nmulti method new(Mu \\ex, Int:D $offset)\nmulti method new(List:D $bt)\nmulti method new(List:D $bt, Int:D $offset)</code></pre></p><p>Creates a new backtrace, using its calling location as the origin of the backtrace or the $offset that is passed as a parameter. If an object or a list (that will already contain a backtrace in list form) is passed, they will be used instead of the current code.</p><p><pre><code>my $backtrace = Backtrace.new;</code></pre></p>","outer-caller-idx":"<p>Defined as:</p><p><pre><code>method outer-caller-idx(Backtrace:D: Int $startidx)</code></pre></p><p>Returns as a list the index of the frames that called the current one.</p><p><pre><code>sub zipi { { { die \"Something bad happened\" }() }() };\ntry zipi;\nsay $!.backtrace.outer-caller-idx( 4 ); # OUTPUT: «[6]␤»\n</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Backtrace:D:)</code></pre></p><p>Returns a concise string representation of the backtrace, omitting routines marked as is hidden-from-backtrace, and at the discretion of the implementation, also some routines from the setting.</p><p><pre><code>my $backtrace = Backtrace.new;\nsay $backtrace.Str;</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>multi method gist(Backtrace:D:)</code></pre></p><p>Returns string \"Backtrace(42 frames)\" where the number indicates the number of frames available via list method.</p>"}},"CX::Warn":{"prefix":"<p><pre><code>role CX::Warn does X::Control { }</code></pre></p><p>A control exception triggered when warn is called to warn about any incidence.</p>","defs":{},"name":"CX::Warn"},"IO::Path::QNX":{"prefix":"<p><pre><code>class IO::Path::QNX is IO::Path { }</code></pre></p><p>This sub-class of IO::Path, pre-loaded with IO::Spec::QNX in the $.SPEC attribute.</p>","defs":{"new":"<p>Same as IO::Path.new, except :$SPEC cannot be set and defaults to IO::Spec::QNX, regardless of the operating system the code is being run on.</p>"},"name":"IO::Path::QNX"},"X::IO::Link":{"name":"X::IO::Link","prefix":"<p><pre><code>class X::IO::Link does X::IO is Exception { }\n</code></pre></p><p>Error class for failed link operation.</p><p>A typical error message is</p><p><pre><code>Failed to create link called 'my-link' on target 'does-not exist': Failed to link file\n</code></pre></p>","defs":{"target":"<p>Returns the name of the link target, i.e. the existing file.</p>"}},"X::ControlFlow::Return":{"name":"X::ControlFlow::Return","prefix":"<p><pre><code>class X::ControlFlow::Return is X::ControlFlow { }</code></pre></p><p>Thrown when a return is called from outside a routine.</p><p><pre><code>return;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»</code></pre></p>","defs":{}},"Label":{"defs":{"name":"<p>Defined as:</p><p><pre><code>method name()</code></pre></p><p>Not terribly useful, returns the name of the defined label:</p><p><pre><code>A: while True {\n  say A.name; # OUTPUT: «A»\n  last A;\n}</code></pre></p>","next":"<p>Defined as:</p><p><pre><code>method next(Label:)</code></pre></p><p>Begin the next iteration of the loop associated with the label.</p><p><pre><code>MY-LABEL:\nfor 1..10 {\n    next MY-LABEL if $_ < 5;\n    print \"$_ \";\n}\n\n# OUTPUT: «5 6 7 8 9 10 »</code></pre></p>","redo":"<p>Defined as:</p><p><pre><code>method redo(Label:)</code></pre></p><p>Repeat the same iteration of the loop associated with the label.</p><p><pre><code>my $has-repeated = False;\n\nMY-LABEL:\nfor 1..10 {\n    print \"$_ \";\n    if $_ == 5 {\n        LEAVE $has-repeated = True;\n        redo MY-LABEL unless $has-repeated;\n    }\n}\n\n# OUTPUT: «1 2 3 4 5 5 6 7 8 9 10 »</code></pre></p>"},"prefix":"<p><pre><code>class Label {}</code></pre></p><p>Labels are used in Raku to tag loops so that you can specify the one you want to jump to with statements such as last. You can use it to jump out of loops and get to outer ones, instead of just exiting the current loop or going to the statement before.</p><p><pre><code>USERS:          # the label\nfor @users -> $u {\n    for $u.pets -> $pet {\n        # usage of a label\n        next USERS if $pet.barks;\n    }\n    say \"None of {$u}'s pets barks\";\n}\nsay USERS.^name;        # OUTPUT: «Label␤»\n</code></pre></p><p>Those label are objects of type Label, as shown in the last statement. Labels can be used in any loop construct, as long as they appear right before the loop statement.</p><p><pre><code>my $x = 0;\nmy $y = 0;\nmy $t = '';\nA: while $x++ < 2 {\n    $t ~= \"A$x\";\n    B: while $y++ < 2 {\n        $t ~= \"B$y\";\n        redo A if $y++ == 1;\n        last A\n    }\n}\nsay $t; # OUTPUT: «A1B1A1A2»\n</code></pre></p><p>Putting them on the line before the loop or the same line is optional. Labels must follow the syntax of ordinary identifiers, although traditionally we will use the latin alphabet in uppercase so that they stand out in the source. You can use, however, other alphabets like here:</p><p><pre><code>駱駝道: while True {\n  say 駱駝道.name;\n  last 駱駝道;\n}</code></pre></p>","name":"Label"},"IntStr":{"prefix":"<p><pre><code>class IntStr is Int is Str { }</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = <42>; say $f.^name; # OUTPUT: «IntStr␤»</code></pre></p><p>As a subclass of both Int and Str, an IntStr will be accepted where either is expected. However, IntStr does not share object identity with Int- or Str-only variants:</p><p><pre><code>my $int-str = <42>;\nmy Int $int = $int-str; # OK!\nmy Str $str = $int-str; # OK!\nsay 42 ∈ <42  55  1>;   # False; ∈ operator cares about object identity</code></pre></p>","defs":{"Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(IntStr:D: --> Int:D)\nmulti method Numeric(IntStr:U: --> Int:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0.</p>","new":"<p><pre><code>method new(Int $i, Str $s)</code></pre></p><p>The constructor requires both the Int and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = IntStr.new(42, \"forty two\");\nsay +$f; # OUTPUT: «42␤»\nsay ~$f; # OUTPUT: «\"forty two\"␤»</code></pre></p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(IntStr:D: Any:D $value)</code></pre></p><p>If $value is Numeric (including another allomorph), checks if invocant's Numeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str part ACCEPTS the $value. If value is anything else, checks if both Numeric and Str parts ACCEPTS the $value.</p><p><pre><code>say <5> ~~ \"5.0\"; # OUTPUT: «False␤»\nsay <5> ~~  5.0 ; # OUTPUT: «True␤»\nsay <5> ~~ <5.0>; # OUTPUT: «True␤»</code></pre></p>","Str":"<p>Returns the string value of the IntStr.</p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(IntStr:D: --> Int:D)\nmulti method Real(IntStr:U: --> Int:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(IntStr:D: --> Bool:D)</code></pre></p><p>This method may be provided by the parent classes and not implemented in IntStr directly.</p><p>Returns False if the invocant is numerically 0, otherwise returns True. String portion is not considered.</p>","Int":"<p><pre><code>method Int</code></pre></p><p>Returns the integer value of the IntStr.</p>"},"name":"IntStr"},"X::Proc::Async::BindOrUse":{"name":"X::Proc::Async::BindOrUse","defs":{},"prefix":"<p><pre><code>    class X::Proc::Async::BindOrUse does X::Proc::Async {}\n</code></pre></p><p>In general, it occurs when there's some mistake in the direction the stream flows, for instance:</p><p><pre><code>my $p = Proc::Async.new(\"ls\", :w);\nmy $h = \"ls.out\".IO.open(:w);\n$p.bind-stdin($h);\n# Fails with OUTPUT: «Cannot both bind stdin to a handle and also use :w␤»\n</code></pre></p><p>In this case, stdin is already bound and cannot be used again; one of them should flow :out and the other one :w to work correctly.</p>"},"X::Bind::NativeType":{"defs":{},"prefix":"<p><pre><code>class X::Bind::NativeType does X::Comp { }</code></pre></p><p>Compile-time error thrown when trying to bind to a natively typed variable.</p><p>Since native variables explicitly don't have the concept of a container at runtime, it does not make sense to support both binding and assignment; Raku supports only assignment (which makes more sense, because native types are value types).</p><p>For example the code</p><p><pre><code>my int $x := 3;\n</code></pre></p><p>dies with</p><p><pre><code>Cannot bind to natively typed variable '$x'; use assignment instead\n</code></pre></p><p>and can be fixed by writing it as</p><p><pre><code>my int $x = 3;</code></pre></p>","name":"X::Bind::NativeType"},"ObjAt":{"defs":{},"prefix":"<p><pre><code>class ObjAt is Any {}</code></pre></p><p>Objects of type ObjAt are the return value of .WHICH calls on other objects, and identify an object uniquely.</p><p>If two objects compare equally via ===, their .WHICH methods return the same ObjAt object.</p><p>See also ValueObjAt for value types.</p>","name":"ObjAt"},"Telemetry::Sampler":{"name":"Telemetry::Sampler","defs":{"new":"<p><pre><code>method new(Telemetry::Sampler: @instruments --> Telemetry::Sampler:D)\n</code></pre></p><p>The new method takes a list of instruments. If no instruments are specified, then it will look at the RAKUDO_TELEMETRY_INSTRUMENTS environment variable to find specification of instruments. If that is not available either, then Telemetry::Instrument::Usage and Telemetry::Instrument::ThreadPool will be assumed.</p><p>Instruments can be specified by either the type object of the instrument class (e.g. Telemetry::Instrument::Usage) or by a string, in which case it will be automatically prefixed with \"Telemetry::Instrument::\", so \"Usage\" would be the same as Telemetry::Instrument::Usage.</p>"},"prefix":"<p><pre><code>class Telemetry::Sampler { }\n</code></pre></p><p>Note:  This class is a Rakudo-specific feature and not standard Raku.</p><p><pre><code>use Telemetry;\n$*SAMPLER.set-instruments(<Usage ThreadPool>); # default setting\n</code></pre></p><p>One usually does not create any Telemetry::Sampler objects: when the Telemetry module is loaded, a Telemetry::Sampler object is automatically created in the $*SAMPLER dynamic variable.</p><p>An object of the Telemetry::Sampler class knows about which instruments to use when making a snapshot.</p>"},"Supply":{"name":"Supply","defs":{"unique":"<p><pre><code>method unique(Supply:D: :$as, :$with, :$expires --> Supply:D)</code></pre></p><p>Creates a supply that only provides unique values, as defined by the optional :as and :with parameters (same as with List.unique). The optional :expires parameter how long to wait (in seconds) before \"resetting\" and not considering a value to have been seen, even if it's the same as an old value.</p>","produce":"<p><pre><code>method produce(Supply:D: &with --> Supply:D)</code></pre></p><p>Creates a \"producing\" supply with the same semantics as List.produce.</p><p><pre><code>my $supply = Supply.from-list(1..5).produce({$^a + $^b});\n$supply.tap(-> $v { say \"$v\" }); # OUTPUT: «1␤3␤6␤10␤15␤»</code></pre></p>","wait":"<p><pre><code>method wait(Supply:D:)</code></pre></p><p>Taps the Supply it is called on, and blocks execution until the either the supply is done (in which case it evaluates to the final value that was emitted on the Supply, or Nil if not value was emitted) or quit (in which case it will throw the exception that was passed to quit).</p><p><pre><code>my $s = Supplier.new;\nstart {\n  sleep 1;\n  say \"One second: running.\";\n  sleep 1;\n  $s.emit(42);\n  $s.done;\n}\n$s.Supply.wait;\nsay \"Two seconds: done\";</code></pre></p>","head":"<p><pre><code>method head(Supply:D: Int(Cool) $number = 1 --> Supply:D)</code></pre></p><p>Creates a \"head\" supply with the same semantics as List.head.</p><p><pre><code>my $s = Supply.from-list(4, 10, 3, 2);\nmy $hs = $s.head(2);\n$hs.tap(&say);           # OUTPUT: «4␤10␤»</code></pre></p>","do":"<p><pre><code>method do(Supply:D: &do --> Supply:D)</code></pre></p><p>Creates a supply to which all values seen in the given supply, are emitted again. The given code, executed for its side-effects only, is guaranteed to be only executed by one thread at a time.</p>","minmax":"<p><pre><code>method minmax(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)</code></pre></p><p>Creates a supply that emits a Range every time a new minimum or maximum values is seen from the given supply. The optional parameter specifies the comparator, just as with Any.minmax.</p>","words":"<p><pre><code>method words(Supply:D: --> Supply:D)</code></pre></p><p>Creates a supply that will emit the characters coming in word for word from a supply that's usually created by some asynchronous I/O operation.</p><p><pre><code>my $s = Supply.from-list(\"Hello Word!\".comb);\nmy $ws = $s.words;\n$ws.tap(&say);           # OUTPUT: «Hello␤Word!␤»</code></pre></p>","batch":"<p><pre><code>method batch(Supply:D: :$elems, :$seconds --> Supply:D)</code></pre></p><p>Creates a new supply that batches the values of the given supply by either the number of elements in the batch (using :elems) or the maximum number of seconds (using the :seconds) or both. Any remaining values are emitted in a final batch when the supply is done.</p>","merge":"<p><pre><code>method merge(Supply @*supplies --> Supply:D)</code></pre></p><p>Creates a supply to which any value seen from the given supplies, is emitted. The resulting supply is done Only when all given supplies are done. Can also be called as a class method.</p>","Promise":"<p><pre><code>method Promise(Supply:D: --> Promise:D)</code></pre></p><p>Returns a Promise that will be kept when the Supply is done. If the Supply also emits any values, then the Promise will be kept with the final value. Otherwise, it will be kept with Nil. If the Supply ends with a quit instead of a done, then the Promise will be broken with that exception.</p><p><pre><code>my $supplier = Supplier.new;\nmy $s = $supplier.Supply;\nmy $p = $s.Promise;\n$p.then(-> $v { say \"got $v.result()\" });\n$supplier.emit('cha');         # not output yet\n$supplier.done();              # got cha</code></pre></p><p>The Promise method is most useful when dealing with supplies that will tend to produce just one value, when only the final value is of interest, or when only completion (successful or not) is relevant.</p>","squish":"<p><pre><code>method squish(Supply:D: :$as, :$with --> Supply:D)</code></pre></p><p>Creates a supply that only provides unique values, as defined by the optional :as and :with parameters (same as with List.squish).</p>","stable":"<p><pre><code>method stable(Supply:D: $time, :$scheduler = $*SCHEDULER --> Supply:D)</code></pre></p><p>Creates a new supply that only passes on a value flowing through the given supply if it wasn't superseded by another value in the given $time (in seconds). Optionally uses another scheduler than the default scheduler, using the :scheduler parameter.</p><p>To clarify the above, if, during the timeout $time, additional values are emitted to the Supplier all but the last one will be thrown away. Each time an additional value is emitted to the Supplier, during the timeout, $time is reset.</p><p>This method can be quite useful when handling UI input, where it is not desired to perform an operation until the user has stopped typing for a while rather than on every keystroke.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply1 = $supplier.Supply;\n$supply1.tap(-> $v { say \"Supply1 got: $v\" });\n$supplier.emit(42);\n\nmy Supply $supply2 = $supply1.stable(5);\n$supply2.tap(-> $v { say \"Supply2 got: $v\" });\nsleep(3);\n$supplier.emit(43);  # will not be seen by $supply2 but will reset $time\n$supplier.emit(44);\nsleep(10);\n# OUTPUT: «Supply1 got: 42␤Supply1 got: 43␤Supply1 got: 44␤Supply2 got: 44␤»\n</code></pre></p><p>As can be seen above, $supply1 received all values emitted to the Supplier while $supply2 only received one value. The 43 was thrown away because it was followed by another 'last' value 44 which was retained and sent to $supply2 after approximately eight seconds, this due to the fact that the timeout $time was reset after three seconds.</p>","rotor":"<p><pre><code>method rotor(Supply:D: @cycle --> Supply:D)</code></pre></p><p>Creates a \"rotoring\" supply with the same semantics as List.rotor.</p>","grep":"<p><pre><code>method grep(Supply:D: Mu $test --> Supply:D)</code></pre></p><p>Creates a new supply that only emits those values from the original supply that smartmatch against $test.</p><p><pre><code>my $supplier = Supplier.new;\nmy $all      = $supplier.Supply;\nmy $ints     = $all.grep(Int);\n$ints.tap(&say);\n$supplier.emit($_) for 1, 'a string', 3.14159;   # prints only 1</code></pre></p>","grab":"<p><pre><code>method grab(Supply:D: &when-done --> Supply:D)</code></pre></p><p>Taps the Supply it is called on. When it is done, calls &when-done and then emits the list of values that it returns on the result Supply. If the original Supply quits, then the exception is immediately conveyed on the return Supply.</p><p><pre><code>my $s = Supply.from-list(4, 10, 3, 2);\nmy $t = $s.grab(&sum);\n$t.tap(&say);           # OUTPUT: «19␤»</code></pre></p>","tail":"<p><pre><code>method tail(Supply:D: Int(Cool) $number = 1 --> Supply:D)</code></pre></p><p>Creates a \"tail\" supply with the same semantics as List.tail.</p><p><pre><code>my $s = Supply.from-list(4, 10, 3, 2);\nmy $ts = $s.tail(2);\n$ts.tap(&say);           # OUTPUT: «3␤2␤»</code></pre></p>","skip":"<p><pre><code>method skip(Supply:D: Int(Cool) $number = 1 --> Supply:D)</code></pre></p><p>Returns a new Supply which will emit all values from the given Supply except for the first $number values, which will be thrown away.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply = $supplier.Supply;\n$supply = $supply.skip(3);\n$supply.tap({ say $_ });\n$supplier.emit($_) for 1..10; # OUTPUT: «4␤5␤6␤7␤8␤9␤10␤»\n</code></pre></p>","reduce":"<p><pre><code>method reduce(Supply:D: &with --> Supply:D)</code></pre></p><p>Creates a \"reducing\" supply with the same semantics as List.reduce.</p><p><pre><code>my $supply = Supply.from-list(1..5).reduce({$^a + $^b});\n$supply.tap(-> $v { say \"$v\" }); # OUTPUT: «15␤»</code></pre></p>","elems":"<p><pre><code>method elems(Supply:D: $seconds? --> Supply:D)</code></pre></p><p>Creates a new supply in which changes to the number of values seen are emitted. It optionally also takes an interval (in seconds) if you only want to be updated every so many seconds.</p>","map":"<p><pre><code>method map(Supply:D: &mapper --> Supply:D)</code></pre></p><p>Returns a new supply that maps each value of the given supply through &mapper and emits it to the new supply.</p><p><pre><code>my $supplier = Supplier.new;\nmy $all      = $supplier.Supply;\nmy $double   = $all.map(-> $value { $value * 2 });\n$double.tap(&say);\n$supplier.emit(4);           # RESULT: «8»</code></pre></p>","reverse":"<p><pre><code>method reverse(Supply:D: --> Supply:D)</code></pre></p><p>Taps the Supply it is called on. Once that Supply emits done, all of the values it emitted will be emitted on the returned Supply in reverse order. If the original Supply quits, then the exception is immediately conveyed on the return Supply.</p><p><pre><code>my $s = Supply.from-list(1, 2, 3);\nmy $t = $s.reverse;\n$t.tap(&say);           # OUTPUT: «3␤2␤1␤»</code></pre></p>","sort":"<p><pre><code>method sort(Supply:D: &custom-routine-to-use? --> Supply:D)</code></pre></p><p>Taps the Supply it is called on. Once that Supply emits done, all of the values that it emitted will be sorted, and the results emitted on the returned Supply in the sorted order. Optionally accepts a comparator Block. If the original Supply quits, then the exception is immediately conveyed on the return Supply.</p><p><pre><code>my $s = Supply.from-list(4, 10, 3, 2);\nmy $t = $s.sort();\n$t.tap(&say);           # OUTPUT: «2␤3␤4␤10␤»</code></pre></p>","tap":"<p><pre><code>method tap(Supply:D: &emit = -> $ { },\n        :&done,\n        :&quit,\n        :&tap\n    --> Tap:D)\n</code></pre></p><p>Creates a new tap (a kind of subscription if you will), in addition to all existing taps. The first positional argument is a piece of code that will be called when a new value becomes available through the emit call.</p><p>The &done callback can be called in a number of cases: if a supply block is being tapped, when a done routine is reached; if a supply block is being tapped, it will be automatically triggered if the supply block reaches the end; if the done method is called on the parent Supplier (in the case of a supply block, if there are multiple Suppliers referenced by whenever, they must all have their done method invoked for this to trigger the &done callback of the tap as the block will then reach its end).</p><p>The &quit callback is called if the tap is on a supply block which exits with an error. It is also called if the quit method is invoked on the parent Supplier (in the case of a supply block any one Supplier quitting with an uncaught exception will call the &quit callback as the block will exit with an error). The error is passed as a parameter to the callback.</p><p>The &tap callback is called once the Tap object is created, which is passed as a parameter to the callback. The callback is called ahead of emit/done/quit, providing a reliable way to get the Tap object. One case where this is useful is when the Supply begins emitting values synchronously, since the call to .tap won't return the Tap object until it is done emitting, preventing it from being stopped if needed.</p><p>Method tap returns an object of type Tap, on which you can call the close method to cancel the subscription.</p><p><pre><code>my $s = Supply.from-list(0 .. 5);\nmy $t = $s.tap(-> $v { say $v }, done => { say \"no more ticks\" });</code></pre></p><p>Produces:</p><p><pre><code>0\n1\n2\n3\n4\n5\nno more ticks\n</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(Supply:D --> Capture:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","live":"<p><pre><code>method live(Supply:D: --> Bool:D)</code></pre></p><p>Returns True if the supply is \"live\", that is, values are emitted to taps as soon as they arrive. Always returns True in the default Supply (but for example on the supply returned from Supply.from-list it's False).</p><p><pre><code>say Supplier.new.Supply.live;    # OUTPUT: «True␤»</code></pre></p>","min":"<p><pre><code>method min(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)</code></pre></p><p>Creates a supply that only emits values from the given supply if they are smaller than any value seen before. In other words, from a continuously descending supply it will emit all the values. From a continuously ascending supply it will only emit the first value. The optional parameter specifies the comparator, just as with Any.min.</p>","on-close":"<p><pre><code>method on-close(Supply:D: &on-close --> Supply:D)</code></pre></p><p>Returns a new Supply which will run &on-close whenever a Tap of that Supply is closed. This includes if further operations are chained on to the Supply. (for example, $supply.on-close(&on-close).map(*.uc)). When using a react or supply block, using the CLOSE phaser is usually a better choice.</p><p><pre><code>my $s = Supplier.new;\nmy $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n    -> $v { say \"the value is $v\" },\n    done    => { say \"Supply is done\" },\n    quit    => -> $ex { say \"Supply finished with error $ex\" },\n);\n\n$s.emit('Raku');\n$tap.close;        # OUTPUT: «Tap closed␤»</code></pre></p>","share":"<p><pre><code>method share(Supply:D: --> Supply:D)</code></pre></p><p>Creates a live supply from an on-demand supply, thus making it possible to share the values of the on-demand supply on multiple taps, instead of each tap seeing its own copy of all values from the on-demand supply.</p><p><pre><code># this says in turn: \"first 1\" \"first 2\" \"second 2\" \"first 3\" \"second 3\"\nmy $s = Supply.interval(1).share;\n$s.tap: { \"first $_\".say };\nsleep 1.1;\n$s.tap: { \"second $_\".say };\nsleep 2</code></pre></p>","schedule-on":"<p><pre><code>method schedule-on(Supply:D: Scheduler $scheduler)</code></pre></p><p>Runs the emit, done and quit callbacks on the specified scheduler.</p><p>This is useful for GUI toolkits that require certain actions to be run from the GUI thread.</p>","zip-latest":"<p><pre><code>method zip-latest(Supply @*supplies, :&with = &[,], :$initial --> Supply:D)</code></pre></p><p>Creates a supply that emits combined values as soon as there is a new value seen on any of the supplies. By default, Lists are created, but this can be changed by specifying your own combiner with the :with parameter. The optional :initial parameter can be used to indicate the initial state of the combined values. By default, all supplies have to have at least one value emitted on them before the first combined values is emitted on the resulting supply. The resulting supply is done as soon as any of the given supplies are done. Can also be called as a class method.</p>","flat":"<p><pre><code>method flat(Supply:D: --> Supply:D)</code></pre></p><p>Creates a supply on which all of the values seen in the given supply are flattened before being emitted again.</p>","migrate":"<p><pre><code>method migrate(Supply:D: --> Supply:D)</code></pre></p><p>Takes a Supply which itself has values that are of type Supply as input. Each time the outer Supply emits a new Supply, this will be tapped and its values emitted. Any previously tapped Supply will be closed. This is useful for migrating between different data sources, and only paying attention to the latest one.</p><p>For example, imagine an application where the user can switch between different stocks. When they switch to a new one, a connection is established to a web socket to get the latest values, and any previous connection should be closed. Each stream of values coming over the web socket would be represented as a Supply, which themselves are emitted into a Supply of latest data sources to watch. The migrate method could be used to flatten this supply of supplies into a single Supply of the current values that the user cares about.</p><p>Here is a simple simulation of such a program:</p><p><pre><code>my Supplier $stock-sources .= new;\n\nsub watch-stock($symbol) {\n    $stock-sources.emit: supply {\n        say \"Starting to watch $symbol\";\n        whenever Supply.interval(1) {\n            emit \"$symbol: 111.\" ~ 99.rand.Int;\n        }\n        CLOSE say \"Lost interest in $symbol\";\n    }\n}\n\n$stock-sources.Supply.migrate.tap: *.say;\n\nwatch-stock('GOOG');\nsleep 3;\nwatch-stock('AAPL');\nsleep 3;\n</code></pre></p><p>Which produces output like:</p><p><pre><code>Starting to watch GOOG\nGOOG: 111.67\nGOOG: 111.20\nGOOG: 111.37\nLost interest in GOOG\nStarting to watch AAPL\nAAPL: 111.55\nAAPL: 111.6\nAAPL: 111.6\n</code></pre></p>","start":"<p><pre><code>method start(Supply:D: &startee --> Supply:D)</code></pre></p><p>Creates a supply of supplies. For each value in the original supply, the code object is scheduled on another thread, and returns a supply either of a single value (if the code succeeds), or one that quits without a value (if the code fails).</p><p>This is useful for asynchronously starting work that you don't block on.</p><p>Use migrate to join the values into a single supply again.</p>","max":"<p><pre><code>method max(Supply:D: &custom-routine-to-use = &infix:<cmp> --> Supply:D)</code></pre></p><p>Creates a supply that only emits values from the given supply if they are larger than any value seen before. In other words, from a continuously ascending supply it will emit all the values. From a continuously descending supply it will only emit the first value. The optional parameter specifies the comparator, just as with Any.max.</p>","throttle":"<p><pre><code>method throttle(Supply:D:\n  $limit,                 # values / time or simultaneous processing\n  $seconds or $callable,  # time-unit / code to process simultaneously\n  $delay = 0,             # initial delay before starting, in seconds\n  :$control,              # supply to emit control messages on (optional)\n  :$status,               # supply to tap status messages from (optional)\n  :$bleed,                # supply to bleed messages to (optional)\n  :$vent-at,              # bleed when so many buffered (optional)\n  :$scheduler,            # scheduler to use, default $*SCHEDULER\n  --> Supply:D)\n</code></pre></p><p>Produces a Supply from a given Supply, but makes sure the number of messages passed through, is limited.</p><p>It has two modes of operation: per time-unit or by maximum number of execution of a block of code: this is determined by the second positional parameter.</p><p>The first positional parameter specifies the limit that should be applied.</p><p>If the second positional parameter is a Callable, then the limit indicates the maximum number of parallel processes executing the Callable, which is given the value that was received. The emitted values in this case will be the Promises that were obtained from starting the Callable.</p><p>If the second positional parameter is a numeric value, it is interpreted as the time-unit (in seconds). If you specify .1 as the value, then it makes sure you don't exceed the limit for every tenth of a second.</p><p>If the limit is exceeded, then incoming messages are buffered until there is room to pass on / execute the Callable again.</p><p>The third positional parameter is optional: it indicates the number of seconds the throttle will wait before passing on any values.</p><p>The :control named parameter optionally specifies a Supply that you can use to control the throttle while it is in operation. Messages that can be sent, are strings in the form of \"key:value\". Please see below for the types of messages that you can send to control the throttle.</p><p>The :status named parameter optionally specifies a Supply that will receive any status messages. If specified, it will at least send one status message after the original Supply is exhausted. See status message below.</p><p>The :bleed named parameter optionally specifies a Supply that will receive any values that were either explicitly bled (with the bleed control message), or automatically bled (if there's a vent-at active).</p><p>The :vent-at named parameter indicates the number of values that may be buffered before any additional value will be routed to the :bleed Supply. Defaults to 0 if not specified (causing no automatic bleeding to happen). Only makes sense if a :bleed Supply has also been specified.</p><p>The :scheduler named parameter indicates the scheduler to be used. Defaults to $*SCHEDULER.</p>","zip":"<p><pre><code>method zip(Supply @*supplies, :&with = &[,] --> Supply:D)</code></pre></p><p>Creates a supply that emits combined values as soon as there is a new value seen on all of the supplies. By default, Lists are created, but this can be changed by specifying your own combiner with the :with parameter. The resulting supply is done as soon as any of the given supplies are done. Can also be called as a class method.</p>","lines":"<p><pre><code>method lines(Supply:D: :$chomp = True --> Supply:D)</code></pre></p><p>Creates a supply that will emit the characters coming in line by line from a supply that's usually created by some asynchronous I/O operation. The optional :chomp parameter indicates whether to remove line separators: the default is True.</p>","interval":"<p><pre><code>method interval(Supply:U: $interval, $delay = 0, :$scheduler = $*SCHEDULER --> Supply:D)</code></pre></p><p>Creates a supply that emits a value every $interval seconds, starting $delay seconds from the call. The emitted value is an integer, starting from 0, and is incremented by one for each value emitted.</p><p>Implementations may treat too-small values as lowest resolution they support, possibly warning in such situations; e.g. treating 0.0001 as 0.001. For 6.d language version, the minimal value specified is 0.001.</p>","delayed":"<p><pre><code>method delayed(Supply:D: $seconds, :$scheduler = $*SCHEDULER --> Supply:D)</code></pre></p><p>Creates a new supply in which all values flowing through the given supply are emitted, but with the given delay in seconds.</p>","from-list":"<p><pre><code>method from-list(Supply:U: +@values --> Supply:D)</code></pre></p><p>Creates an on-demand supply from the values passed to this method.</p><p><pre><code>my $s = Supply.from-list(1, 2, 3);\n$s.tap(&say);           # OUTPUT: «1␤2␤3␤»</code></pre></p>","act":"<p><pre><code>method act(Supply:D: &act --> Tap:D)</code></pre></p><p>Creates a tap on the given supply with the given code. Differently from tap, the given code is guaranteed to be only executed by one thread at a time.</p>","list":"<p><pre><code>method list(Supply:D: --> List:D)</code></pre></p><p>Taps the Supply it is called on, and returns a lazy list that will be reified as the Supply emits values. The list will be terminated once the Supply is done. If the Supply quits, then an exception will be thrown once that point in the lazy list is reached.</p>","Channel":"<p><pre><code>method Channel(Supply:D: --> Channel:D)</code></pre></p><p>Returns a Channel object that will receive all future values from the supply, and will be closed when the Supply is done, and quit (shut down with error) when the supply is quit.</p>"},"prefix":"<p><pre><code>class Supply {}</code></pre></p><p>A supply is a thread-safe, asynchronous data stream like a Channel, but it can have multiple subscribers (taps) that all get the same values flowing through the supply.</p><p>It is a thread-safe implementation of the Observer Pattern, and central to supporting reactive programming in Raku.</p><p>There are two types of Supplies: live and on demand. When tapping into a live supply, the tap will only see values that are flowing through the supply after the tap has been created. Such supplies are normally infinite in nature, such as mouse movements. Closing such a tap does not stop mouse events from occurring, it just means that the values will go by unseen. All tappers see the same flow of values.</p><p>A tap on an on demand supply will initiate the production of values, and tapping the supply again may result in a new set of values. For example, Supply.interval produces a fresh timer with the appropriate interval each time it is tapped. If the tap is closed, the timer simply stops emitting values to that tap.</p><p>A live Supply is obtained from the Supplier factory method Supply. New values are emitted by calling emit on the Supplier object.</p><p><pre><code>my $supplier = Supplier.new;\nmy $supply = $supplier.Supply;\n$supply.tap(-> $v { say \"$v\" });\n$supplier.emit(42); # Will cause the tap to output \"42\"</code></pre></p><p>The live method returns True on live supplies. Factory methods such as interval, from-list will return on demand supplies.</p><p>A live Supply that keeps values until tapped the first time can be created with Supplier::Preserving.</p><p>Further examples can be found in the concurrency page.</p>"},"Any":{"name":"Any","defs":{"flat":"<p>Defined as:</p><p><pre><code>method flat() is nodal</code></pre></p><p>Interprets the invocant as a list, flattens non-containerized Iterables into a flat list, and returns that list. Keep in mind Map and Hash types are Iterable and so will be flattened into lists of pairs.</p><p><pre><code>say ((1, 2), (3), %(:42a));      # OUTPUT: «((1 2) 3 {a => 42})␤»\nsay ((1, 2), (3), %(:42a)).flat; # OUTPUT: «(1 2 3 a => 42)␤»</code></pre></p><p>Note that Arrays containerize their elements by default, and so flat will not flatten them. You can use hyper method call to call .List method on all the inner Iterables and so de-containerize them, so that flat can flatten them:</p><p><pre><code>say [[1, 2, 3], [(4, 5), 6, 7]]      .flat; # OUTPUT: «([1 2 3] [(4 5) 6 7])␤»\nsay [[1, 2, 3], [(4, 5), 6, 7]]».List.flat; # OUTPUT: «(1 2 3 4 5 6 7)␤»</code></pre></p><p>For more fine-tuned options, see deepmap, duckmap, and signature destructuring</p>","cache":"<p>Defined as:</p><p><pre><code>method cache()</code></pre></p><p>Provides a List representation of the object itself, calling the method list on the instance.</p>","pick":"<p>Defined as:</p><p><pre><code>multi method pick(--> Any)\nmulti method pick($n --> Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.pick on it.</p><p><pre><code>my Range $rg = 'α'..'ω';\nsay $rg.pick(3); # OUTPUT: «(β α σ)␤»</code></pre></p>","nodemap":"<p>Defined as:</p><p><pre><code>method nodemap(&block --> List) is nodal</code></pre></p><p>nodemap will apply &block to each element and return a new List with the return values of &block. In contrast to deepmap it will not descend recursively into sublists if it finds elements which do the Iterable role.</p><p><pre><code>say [[1,2,3], [[4,5],6,7], 7].nodemap(*+1);\n# OUTPUT: «(4, 4, 8)␤»\n\nsay [[2, 3], [4, [5, 6]]]».nodemap(*+1)\n# OUTPUT: «((3 4) (5 3))␤»</code></pre></p><p>The examples above would have produced the exact same results if we had used map instead of nodemap. The difference between the two lies in the fact that map flattens out slips while nodemap doesn't.</p><p><pre><code>say [[2,3], [[4,5],6,7], 7].nodemap({.elems == 1 ?? $_ !! slip});\n# OUTPUT: «(() () 7)␤»\nsay [[2,3], [[4,5],6,7], 7].map({.elems == 1 ?? $_ !! slip});\n# OUTPUT: «(7)␤»</code></pre></p><p>When applied to Associatives, it will act on the values:</p><p><pre><code>{ what => \"is\", this => \"thing\" }.nodemap( *.flip ).say;\n# OUTPUT: «{this => gniht, what => si}␤»</code></pre></p>","collate":"<p>Defined as:</p><p><pre><code>method collate()</code></pre></p><p>Collate sorts taking into account Unicode grapheme characteristics; that is, sorting more or less as one would expect instead of using the order in which their codepoints appear. collate will behave this way if the object it is applied to is Iterable.</p><p><pre><code>say ('a', 'Z').sort; # (Z a)\nsay ('a', 'Z').collate; # (a Z)\nsay <ä a o ö>.collate; # (a ä o ö)\nmy %hash = 'aa' => 'value', 'Za' => 'second';\nsay %hash.collate; # (aa => value Za => second);\n</code></pre></p><p>This method is affected by the $*COLLATION variable, which configures the four collation levels. While the Primary, Secondary and Tertiary mean different things for different scripts, for the Latin script used in English they mostly correspond with Primary being Alphabetic, Secondary being Diacritics and Tertiary being Case.</p><p>In the example below you can see how when we disable tertiary collation which in Latin script generally is for case, and also disable quaternary which breaks any ties by checking the codepoint values of the strings, we get Same back for A and a:</p><p><pre><code>$*COLLATION.set(:quaternary(False), :tertiary(False));\nsay 'a' coll 'A'; #OUTPUT: «Same␤»\nsay ('a','A').collate == ('A','a').collate; # OUTPUT: «True␤»</code></pre></p><p>The variable affects the coll operator as shown as well as this method.</p>","classify":"<p>Defined as:</p><p><pre><code>multi method classify()\nmulti method classify(Whatever)\nmulti method classify($test, :$into!, :&as)\nmulti method classify($test, :&as)\nmulti sub classify($test, +items, :$into!, *%named )\nmulti sub classify($test, +items, *%named )</code></pre></p><p>The two first forms will fail. The rest include a $test, which is a function that will return a scalar for every input; these will be used as keys of a hash whose values will be arrays with the elements that output that key for the test function.</p><p><pre><code>my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n@years.classify( *.is-leap-year , into => my %leap-years );\nsay %leap-years;\n# OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n#           True => [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>Similarly to .categorize, elements can be normalized by the Callable passed with the :as argument, and it can use the :into named argument to pass a Hash the results will be classified into; in the example above, it's defined on the fly.</p><p>From version 6.d, .classify will also work with Junctions.</p>","max":"<p>Defined as:</p><p><pre><code>multi method max()\nmulti method max(&by)\nmulti sub max(+args, :&by!)\nmulti sub max(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically largest element; in the case of Hashes, the Pair with the highest value.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and the return value is compared instead of the original value. The original value is still the one returned from max.</p><p><pre><code>say (1,7,3).max();                # OUTPUT:«7␤»\nsay (1,7,3).max({1/$_});          # OUTPUT:«1␤»\nsay max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\nsay max(1,7,3);                   # OUTPUT: «7␤»\nmax( %(a => 'B', b=> 'C' ) ).say; # OUTPUT: «b => C␤»</code></pre></p>","permutations":"<p>Defined as:</p><p><pre><code>method permutations(|c)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.permutations on it.</p><p><pre><code>say <a b c>.permutations;\n# OUTPUT: «((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»\nsay set(1,2).permutations;\n# OUTPUT: «((2 => True 1 => True) (1 => True 2 => True))␤»</code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>multi method kv(Any:U:)\nmulti method kv(Any:D:)\nmulti sub    kv($x)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>Sub.kv.say ;# OUTPUT: «()␤»</code></pre></p><p>It calls list on the invocant for value objects and returns the result of List.kv on it as a list where keys and values will be ordered and contiguous</p><p><pre><code><1 2 3>.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»</code></pre></p><p>In the case of Positionals, the indices will be considered keys.</p>","list":"<p>Defined as:</p><p><pre><code>multi method list(Any:U: --> List)\nmulti method list(Any:D \\SELF: --> List)</code></pre></p><p>Applies the infix , operator to the invocant and returns the resulting List:</p><p><pre><code>say 42.list.^name;           # OUTPUT: «List␤»\nsay 42.list.elems;           # OUTPUT: «1␤»</code></pre></p><p>Subclasses of Any may choose to return any core type that does the Positional role from .list. Use .List to coerce specifically to List.</p><p> @ can also be used as a list or Positional contextualizer:</p><p><pre><code>my $not-a-list-yet = $[1,2,3];\nsay $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\nmy @maybe-a-list = @$not-a-list-yet;\nsay @maybe-a-list.^name;              # OUTPUT: «Array␤»\n</code></pre></p><p>In the first case, the list is itemized. @ as a prefix puts the initial scalar in a list context by calling .list and turning it into an Array.</p>","maxpairs":"<p>Defined as:</p><p><pre><code>multi method maxpairs(Any:D:)</code></pre></p><p>Calls .pairs and returns a Seq with all of the Pairs with maximum values, as judged by the cmp operator:</p><p><pre><code><a b c a b c>.maxpairs.perl.put; # OUTPUT: «(2 => \"c\", 5 => \"c\").Seq␤»\n%(:42a, :75b).maxpairs.perl.put; # OUTPUT: «(:b(75),).Seq␤»</code></pre></p>","flatmap":"<p>Defined as:</p><p><pre><code>method flatmap(&block, :$label)</code></pre></p><p>DEPRECATION NOTICE: This method is deprecated in 6.d and will be removed in 6.e. Use .map followed by .flat instead.</p><p>Applies map to every element with the block and Label used as an argument and flattens out the result using .flat.</p><p><pre><code>say \"aabbccc\".comb.Mix.flatmap: \"→ \" ~ *; # OUTPUT: «(→ b␉2 → c␉3 → a␉2)␤»</code></pre></p><p>In this case, the elements of the Mix are itemized to key␉value, and then mapped and flattened. Same result as</p><p><pre><code>say \"aabbccc\".comb.Mix.map( \"→ \" ~ * ).flat</code></pre></p><p>Which is why it is deprecated in 6.d and will be eventually eliminated in 6.e.</p>","push":"<p>Defined as:</p><p><pre><code>method push(|values --> Positional:D)</code></pre></p><p>The method push is defined for undefined invocants and allows for autovivifying undefined to an empty Array, unless the undefined value implements Positional already. The argument provided will then be pushed into the newly created Array.</p><p><pre><code>my %h;\nsay %h<a>;     # OUTPUT: «(Any)␤»      <-- Undefined\n%h<a>.push(1); # .push on Any\nsay %h;        # OUTPUT: «{a => [1]}␤» <-- Note the Array</code></pre></p>","one":"<p>Defined as:</p><p><pre><code>method one(--> Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates a one-Junction from it.</p><p><pre><code>say so 1 == (1, 2, 3).one;      # OUTPUT: «True␤»\nsay so 1 == (1, 2, 1).one;      # OUTPUT: «False␤»</code></pre></p>","Slip":"<p>Defined as:</p><p><pre><code>method Slip(--> Slip:D) is nodal</code></pre></p><p>Coerces the invocant to Slip.</p>","none":"<p>Defined as:</p><p><pre><code>method none(--> Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates a none-Junction from it.</p><p><pre><code>say so 1 == (1, 2, 3).none;     # OUTPUT: «False␤»\nsay so 4 == (1, 2, 3).none;     # OUTPUT: «True␤»</code></pre></p>","elems":"<p>Defined as:</p><p><pre><code>multi method elems(Any:U: --> 1)\nmulti method elems(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the number of elements in the list.</p><p><pre><code>say 42.elems;                   # OUTPUT: «1␤»\nsay <a b c>.elems;              # OUTPUT: «3␤»\nsay Whatever.elems ;            # OUTPUT: «1␤»</code></pre></p><p>It will also return 1 for classes.</p>","map":"<p>Defined as:</p><p><pre><code>multi method map(Hash:D \\hash)\nmulti method map(Iterable:D \\iterable)\nmulti method map(|c)\nmulti method map(\\SELF: &block;; :$label, :$item)\nmulti sub map(&code, +values)</code></pre></p><p>map will iterate over the invocant and apply the number of positional parameters of the code object from the invocant per call. The returned values of the code object will become elements of the returned Seq.</p><p>The :$label and :$item are useful only internally, since for loops get converted to maps. The :$label takes an existing Label to label the .map's loop with and :$item controls whether the iteration will occur over (SELF,) (if :$item is set) or SELF.</p><p>In sub form, will apply the code block to the values, which will be used as invocant.</p><p>The form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will fail with X::Cannot::Map, and are mainly meant to catch common traps.</p>","Hash":"<p>Defined as:</p><p><pre><code>multi method Hash( --> Hash:D)</code></pre></p><p>Coerces the invocant to Hash.</p>","iterator":"<p>Defined as:</p><p><pre><code>multi method iterator(Any:)</code></pre></p><p>Returns the object as an iterator after converting it to a list. This is the function called from the for statement.</p><p><pre><code>.say for 3; # OUTPUT: «3␤»</code></pre></p><p>Most subclasses redefine this method for optimization, so it's mostly types that do not actually iterate the ones that actually use this implementation.</p>","unshift":"<p>Defined as:</p><p><pre><code>multi method unshift(--> Array)\nmulti method unshift(@values --> Array)</code></pre></p><p>Initializes Any variable as empty Array and calls Array.unshift on it.</p><p><pre><code>my $a;\nsay $a.unshift; # OUTPUT: «[]␤»\nsay $a;         # OUTPUT: «[]␤»\nmy $b;\nsay $b.unshift([1,2,3]); # OUTPUT: «[[1 2 3]]␤»</code></pre></p>","reduce":"<p>Defined as:</p><p><pre><code>multi method reduce(Any:U: & --> Nil)\nmulti method reduce(Any:D: &with)\nmulti sub reduce (&with, +list)</code></pre></p><p>Applying it to a class will always produce Nil. Applies its argument (or first argument, in case it's a sub) as an operator to all the elements in the object (or second argument), producing a single result. The argument must be an infix operator or take, in any case, two positional arguments.</p><p><pre><code>(1..13).reduce( &[*] ).say; # OUTPUT: «6227020800␤»</code></pre></p>","tail":"<p>Defined as:</p><p><pre><code>multi method tail() is raw\nmulti method tail($n)</code></pre></p><p>Returns the last or the list of the $n last elements of an object. $n can be a Callable, usually a WhateverCode, which will be used to get all but the first n elements of the object.</p><p><pre><code>say (^12).reverse.tail ;     # OUTPUT: «0␤»\nsay (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\nsay (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»\n</code></pre></p>","sort":"<p>Defined as:</p><p><pre><code>multi method sort()\nmulti method sort(&custom-routine-to-use)</code></pre></p><p>Sorts iterables with cmp or given code object and returns a new Seq. Optionally, takes a Callable as a positional parameter, specifying how to sort.</p><p>Examples:</p><p><pre><code>say <b c a>.sort;                           # OUTPUT: «(a b c)␤»\nsay 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\nsay 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\nsay '231'.comb.sort(&infix:«<=>»).join;     # OUTPUT: «123␤»</code></pre></p>","first":"<p>Defined as:</p><p><pre><code>multi method first(Bool:D $t)\nmulti method first(Regex:D $test, :$end, *%a)\nmulti method first(Callable:D $test, :$end, *%a is copy)\nmulti method first(Mu $test, :$end, *%a)\nmulti method first(:$end, *%a)\nmulti sub first(Bool:D $t, |)\nmulti sub first(Mu $test, +values, *%a)</code></pre></p><p>In general, coerces the invocant to a list by applying its .list method and uses List.first on it.</p><p>However, this is a multi with different signatures, which are implemented with (slightly) different behavior, although using it as a subroutine is equivalent to using it as a method with the second argument as the object.</p><p>For starters, using a Bool as the argument will always return a Failure. The form that uses a $test will return the first element that smartmatches it, starting from the end if :end is used.</p><p><pre><code>say (3..33).first;           # OUTPUT: «3␤»\nsay (3..33).first(:end);     # OUTPUT: «33␤»\nsay (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\nsay first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\nsay (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»</code></pre></p><p>The third and fourth examples use the Mu $test forms which smartmatches and returns the first element that does. The last example uses as a test a regex for numbers with two figures, and thus the first that meets that criterion is number 10. This last form uses the Callable multi:</p><p><pre><code>say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»</code></pre></p><p>Besides, the search for first will start from the :end and returns the set of key/values in a list; the key in this case is simply the position it occupies in the Seq. The :kv argument, which is part of the %a argument in the definitions above, modifies what first returns, providing it as a flattened list of keys and values; for a listy object, the key will always be the index.</p><p>From version 6.d, the test can also be a Junction:</p><p><pre><code>say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»</code></pre></p>","reverse":"<p>Defined as:</p><p><pre><code>multi sub    reverse(*@list  --> Seq:D)\nmulti method reverse(List:D: --> Seq:D)</code></pre></p><p>Returns a Seq with the same elements in reverse order.</p><p>Note that reverse always refers to reversing elements of a list; to reverse the characters in a string, use flip.</p><p>Examples:</p><p><pre><code>say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\nsay reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»</code></pre></p>","skip":"<p>Defined as:</p><p><pre><code>multi method skip()\nmulti method skip(Whatever)\nmulti method skip(Callable:D $w)\nmulti method skip(Int() $n)</code></pre></p><p>Creates a Seq from 1-item list's iterator and uses Seq.skip on it, please check that document for real use cases; calling skip without argument is equivalent to skip(1).</p><p>Calling it with Whatever will return an empty iterator:</p><p><pre><code>say <1 2 3>.skip(*);   # OUTPUT: «()␤»</code></pre></p><p>The multi that uses a Callable is intended mainly to be used this way:</p><p><pre><code>say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»</code></pre></p><p>Instead of throwing away the first $n elements, it throws away everything but the elements indicated by the WhateverCode, in this case all but the last one.</p>","Supply":"<p>Defined as:</p><p><pre><code>method Supply(--> Supply:D) is nodal</code></pre></p><p>First, it coerces the invocant to a list by applying its .list method, and then to a Supply.</p>","repeated":"<p>Defined as:</p><p><pre><code>multi method repeated()\nmulti method repeated( :&as!, :&with! )\nmulti method repeated( :&as! )\nmulti method repeated( :&with! )</code></pre></p><p>Similarly to unique, finds repeated elements in values (as a routine) or in the object, using the :as associative argument as a normalizing function and :with as equality function.</p><p><pre><code><1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n(3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»</code></pre></p><p>It returns the last repeated element before normalization, as shown in the example above. See repeated for more examples that use its sub form.</p>","all":"<p>Defined as:</p><p><pre><code>method all(--> Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates an all-Junction from it.</p><p><pre><code>say so 1 < <2 3 4>.all;         # OUTPUT: «True␤»\nsay so 3 < <2 3 4>.all;         # OUTPUT: «False␤»</code></pre></p>","deepmap":"<p>Defined as:</p><p><pre><code>method deepmap(&block --> List) is nodal</code></pre></p><p>deepmap will apply &block to each element and return a new List with the return values of &block, unless the element does the Iterable role. For those elements deepmap will descend recursively into the sublist.</p><p><pre><code>say [[1,2,3],[[4,5],6,7]].deepmap(* + 1);\n# OUTPUT: «[[2 3 4] [[5 6] 7 8]]␤»</code></pre></p><p>In the case of Associatives, it will be applied to its values:</p><p><pre><code>{ what => \"is\", this => \"thing\", a => <real list> }.deepmap( *.flip ).say\n# OUTPUT: «{a => (laer tsil), this => gniht, what => si}␤»\n</code></pre></p>","Set":"<p>Defined as:</p><p><pre><code>method Set(--> Set:D) is nodal</code></pre></p><p>Coerces the invocant to Set, whereby Positionals are treated as lists of values.</p>","Map":"<p>Defined as:</p><p><pre><code>method Map(--> Map:D) is nodal</code></pre></p><p>Coerces the invocant to Map.</p>","min":"<p>Defined as:</p><p><pre><code>multi method min()\nmulti method min(&by)\nmulti sub min(+args, :&by!)\nmulti sub min(+args)</code></pre></p><p>Coerces the invocant to Iterable and returns the numerically smallest element; in the case of Hashes, it returns the Pair with the lowest value. In sub form, the invocant is passed as an argument.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original value is still the one returned from min.</p><p><pre><code>say (1,7,3).min();              # OUTPUT:«1␤»\nsay (1,7,3).min({1/$_});        # OUTPUT:«7␤»\nsay min(1,7,3);                 # OUTPUT: «1␤»\nsay min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\nmin( %(a => 3, b=> 7 ) ).say ;  # OUTPUT: «a => 3␤»</code></pre></p>","invert":"<p>Defined as:</p><p><pre><code>multi method invert(Any:U:)\nmulti method invert(Any:D:)</code></pre></p><p>Applied to a type object will return an empty list; applied to an object will convert it to a list and apply List.invert to it, that is, interchange key with value in every Pair. The resulting list needs to be a list of Pairs.</p><p><pre><code>\"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 => c 3 => a 2 => b)␤»</code></pre></p><p>In this case, a Bag can be converted to a list of Pairs. If the result of converting the object to a list is not a list of pairs, the method will fail.</p>","toggle":"<p>Defined as:</p><p><pre><code>method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)</code></pre></p><p>Iterates over the invocant, producing a Seq, toggling whether the received values are propagated to the result on and off, depending on the results of calling Callables in @conditions:</p><p><pre><code>say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\nsay (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n</code></pre></p><p>Imagine a switch that's either on or off (True or False), and values are produced if it's on. By default, the initial state of that switch is in \"on\" position, unless :$off is set to a true value, in which case the initial state will be \"off\".</p><p>A Callable from the head of @conditions is taken (if any are available) and it becomes the current tester. Each value from the original sequence is tested by calling the tester Callable with that value. The state of our imaginary switch is set to the return value from the tester: if it's truthy, set switch to \"on\", otherwise set it to \"off\".</p><p>Whenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from \"on\" to \"off\"), the current tester Callable is replaced by the next Callable in @conditions, if available, which will be used to test any further values. If no more tester Callables are available, the switch will remain in its current state until the end of iteration.</p><p><pre><code># our original sequence of elements:\nsay list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n# toggled result:\nsay ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n# First tester Callable is `* < 4` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 => 0 < 4 === True  switch is on, value gets into result, switch is\n#                      toggled, so we keep using the same Callable:\n# 1 => 1 < 4 === True  same\n# 2 => 2 < 4 === True  same\n# 3 => 3 < 4 === True  same\n# 4 => 4 < 4 === False switch is now off, \"4\" does not make it into the\n#                      result. In addition, our switch got toggled, so\n#                      we're switching to the next tester Callable\n# 5 => 5 %% 2 === False  switch is still off, keep trying to find a value\n# 6 => 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n#                        toggled, so we'll use the next tester Callable\n# 7 => is-prime(7) === True  switch is still on, take value and keep going\n# 8 => is-prime(8) === False switch is now off, \"8\" does not make it into\n#                            the result. The switch got toggled, but we\n#                            don't have any more tester Callables, so it\n#                            will remain off for the rest of the sequence.\n</code></pre></p><p>Since the toggle of the switch's state loads the next tester Callable, setting :$off to a True value affects when first tester is discarded:</p><p><pre><code># our original sequence of elements:\nsay <0 1 2>; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»\n\n# First tester Callable is `* > 1` and initial state of switch is \"on\".\n# As we iterate over our original sequence:\n# 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n#                      In addition, switch got toggled, so we change the\n#                      tester Callable, and since we don't have any more\n#                      of them, the switch will remain \"off\" until the end\n</code></pre></p><p>The behavior changes when :off is used:</p><p><pre><code># our original sequence of elements:\nsay <0 1 2>; # OUTPUT: «(0 1 2)␤»\n# toggled result:\nsay <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»\n\n# First tester Callable is `* > 1` and initial state of switch is \"off\".\n# As we iterate over our original sequence:\n# 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n#                       The switch did NOT get toggled this time, so we\n#                       keep using our current tester Callable\n# 1 => 1 > 1 === False  same\n# 2 => 2 > 1 === True   switch is on, \"2\" makes it into the result\n</code></pre></p>","duckmap":"<p>Defined as:</p><p><pre><code>method duckmap(&block) is rw is nodal</code></pre></p><p>duckmap will apply &block on each element that behaves in such a way that &block can be applied. If it fails, it will descend recursively if possible, or otherwise return the item without any transformation. It will act on values if the object is Associative.</p><p><pre><code><a b c d e f g>.duckmap(-> $_ where <c d e>.any { .uc }).say;\n# OUTPUT: «(a b C D E f g)␤»\n(('d', 'e'), 'f').duckmap(-> $_ where <e f>.any { .uc }).say;\n# OUTPUT: «((d E) F)␤»\n{ first => ('d', 'e'), second => 'f'}.duckmap(-> $_ where <e f>.any { .uc }).say;\n# OUTPUT: «{first => (d E), second => F}␤»\n</code></pre></p><p>In the first case, it is applied to c, d and e which are the ones that meet the conditions for the block ({ .uc }) to be applied; the rest are returned as is.</p><p>In the second case, the first item is a list that does not meet the condition, so it's visited; that flat list will behave in the same way as the first one. In this case:</p><p><pre><code>say [[1,2,3],[[4,5],6,7]].duckmap( *² ); # OUTPUT: «[9 9]␤»</code></pre></p><p>You can square anything as long as it behaves like a number. In this case, there are two arrays with 3 elements each; these arrays will be converted into the number 3 and squared. In the next case, however</p><p><pre><code>say [[1,2,3],[[4,5],6.1,7.2]].duckmap( -> Rat $_ { $_²} );\n# OUTPUT: «[[1 2 3] [[4 5] 37.21 51.84]]␤»</code></pre></p><p>3-item lists are not Rat, so it descends recursively, but eventually only applies the operation to those that walk (or slither, as the case may be) like a Rat.</p><p>Although on the surface (and name), duckmap might look similar to deepmap, the latter is applied recursively regardless of the type of the item.</p>","join":"<p>Defined as</p><p><pre><code>method join($separator = '') is nodal</code></pre></p><p>Converts the object to a list by calling self.list, and calls .join on the list. Can take a separator, which is an empty string by default.</p><p><pre><code>(1..3).join.say;       # OUTPUT: «123␤»\n<a b c>.join(\"❧\").put; # OUTPUT: «a❧b❧c␤»</code></pre></p>","grep":"<p>Defined as:</p><p><pre><code>method grep(Mu $matcher, :$k, :$kv, :$p, :$v --> Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.grep on it.</p><p>Based on $matcher value can be either ((Any)) or empty List.</p><p><pre><code>my $a;\nsay $a.grep({ True }); # OUTPUT: «((Any))␤»\nsay $a.grep({ $_ });   # OUTPUT: «()␤»</code></pre></p>","rotor":"<p>Defined as:</p><p><pre><code>multi method rotor(Any:D: Int:D $batch, :$partial)\nmulti method rotor(Any:D: *@cycle, :$partial)</code></pre></p><p>Groups the elements of the object in lists of $batch elements.</p><p><pre><code>say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»</code></pre></p><p>With the :partial named argument, it will also include lists that do not get to be the $batch size:</p><p><pre><code>say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»</code></pre></p><p>.rotor can be called with an array of integers and pairs, which will be applied in turn. While integers will establish the batch size, as above, Pairs will use the key as batch size and the value as number of elements to skip if it's positive, or overlap if it's negative.</p><p><pre><code>say (3..11).rotor(3, 2 => 1, 3 => -2, :partial);\n# OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»</code></pre></p><p>In this case, the first batch (ruled by an integer) has 3 elements; the second one has 2 elements (key of the pair), but skips one (the number 8); the third one has size 2 (because partials are allowed), and an overlap of 2 also.</p><p>Please see also list.rotor for examples applied to lists.</p>","append":"<p>Defined as:</p><p><pre><code>multi method append(Any:U \\SELF: |values --> Array)</code></pre></p><p>In the case the instance is not a positional-thing, it instantiates it as a new Array, otherwise clone the current instance. After that, it appends the values passed as arguments to the array obtained calling Array.append on it.</p><p><pre><code>my $a;\nsay $a.append; # OUTPUT: «[]␤»\nmy $b;\nsay $b.append((1,2,3)); # OUTPUT: «[1 2 3]␤»</code></pre></p>","MixHash":"<p>Defined as:</p><p><pre><code>method MixHash(--> MixHash:D) is nodal</code></pre></p><p>Coerces the invocant to MixHash, whereby Positionals are treated as lists of values.</p>","squish":"<p>Defined as:</p><p><pre><code>multi method squish( :&as!, :&with = &[===] )\nmulti method squish( :&with = &[===] )</code></pre></p><p>Similar to .repeated, returns the sequence of first elements of contiguous sequences of equal elements, after normalization by the function :as, if present, and using as an equality operator the :with argument or === by default.</p><p><pre><code>\"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n\"aABbccdDaa\".comb.squish( :as(&lc) ).say; # OUTPUT: «(a B c d a)␤»\n(3+2i,3+3i,4+0i).squish( as => *.re, with => &[==]).put; #OUTPUT: «3+2i 4+0i␤»\n</code></pre></p><p>As shown in the last example, a sequence can contain a single element. See squish for additional sub examples.</p>","end":"<p><pre><code>multi method end(Any:U: --> 0)\nmulti method end(Any:D:)</code></pre></p><p>Interprets the invocant as a list, and returns the last index of that list.</p><p><pre><code>say 6.end;                      # OUTPUT: «0␤»\nsay <a b c>.end;                # OUTPUT: «2␤»</code></pre></p>","Mix":"<p>Defined as:</p><p><pre><code>method Mix(--> Mix:D) is nodal</code></pre></p><p>Coerces the invocant to Mix, whereby Positionals are treated as lists of values.</p>","Array":"<p>Defined as:</p><p><pre><code>method Array(--> Array:D) is nodal</code></pre></p><p>Coerces the invocant to an Array.</p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(Any:D: Mu $other)</code></pre></p><p>Usage:</p><p><pre><code>EXPR.ACCEPTS(EXPR);\n</code></pre></p><p>Returns True if $other === self (i.e. it checks object identity).</p><p>Many built-in types override this for more specific comparisons.</p>","keys":"<p>Defined as:</p><p><pre><code>multi method keys(Any:U: --> List)\nmulti method keys(Any:D: --> List)</code></pre></p><p>For defined Any returns its keys after calling list on it, otherwise calls list and returns it.</p><p><pre><code>my $setty = Set(<Þor Oðin Freija>);\nsay $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»</code></pre></p><p>See also List.keys.</p><p>Trying the same on a class will return an empty list, since most of them don't really have keys.</p>","prepend":"<p>Defined as:</p><p><pre><code>multi method prepend(--> Array)\nmulti method prepend(@values --> Array)</code></pre></p><p>Called with no arguments on an empty variable, it initializes it as an empty Array; if called with arguments, it creates an array and then applies Array.prepend on it.</p><p><pre><code>my $a;\nsay $a.prepend; # OUTPUT: «[]␤»\nsay $a;         # OUTPUT: «[]␤»\nmy $b;\nsay $b.prepend(1,2,3); # OUTPUT: «[1 2 3]␤»</code></pre></p>","any":"<p>Defined as:</p><p><pre><code>method any(--> Junction:D)</code></pre></p><p>Interprets the invocant as a list and creates an any-Junction from it.</p><p><pre><code>say so 2 == <1 2 3>.any;        # OUTPUT: «True␤»\nsay so 5 == <1 2 3>.any;        # OUTPUT: «False␤»</code></pre></p>","categorize":"<p>Defined as:</p><p><pre><code>multi method categorize()\nmulti method categorize(Whatever)\nmulti method categorize($test, :$into!, :&as)\nmulti method categorize($test, :&as)\nmulti sub categorize($test, +items, :$into!, *%named )\nmulti sub categorize($test, +items, *%named )</code></pre></p><p>The two first forms fail with an error message.</p><p>In its simplest form, it uses a $test whose result will be used as a key; the values of the key will be an array of the elements that produced that key as a result of the test.</p><p><pre><code>say (1..13).categorize( * %% 3);\nsay categorize( * %% 3, 1..13)\n# OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n</code></pre></p><p>The :as argument will normalize before categorizing</p><p><pre><code>say categorize( * %% 3, -5..5, as => &abs )\n# OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n</code></pre></p><p>The $into associative argument can be used to put the result instead of returning a new Hash</p><p><pre><code>my %leap-years;\nmy @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n@years.categorize( *.is-leap-year , into => %leap-years );\nsay %leap-years\n# OUTPUT:\n# «{ False\n# => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n#    True => [2004-01-01 2008-01-01]}␤»\n</code></pre></p><p>The function used to categorize can return an array indicating all possible bins their argument can be put into:</p><p><pre><code>sub divisible-by( Int $n --> Array(Seq) ) {\n    gather {\n        for <2 3 5 7> {\n            take $_ if $n %% $_;\n        }\n    }\n}\n\nsay (3..13).categorize( &divisible-by );\n# OUTPUT:\n# «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n</code></pre></p><p>In this case, every number in the range is classified in as many bins as it can be divided by.</p>","BagHash":"<p>Defined as:</p><p><pre><code>method BagHash(--> BagHash:D) is nodal</code></pre></p><p>Coerces the invocant to BagHash, whereby Positionals are treated as lists of values.</p>","SetHash":"<p>Defined as:</p><p><pre><code>method SetHash(--> SetHash:D) is nodal</code></pre></p><p>Coerces the invocant to SetHash, whereby Positionals are treated as lists of values.</p>","head":"<p>Defined as:</p><p><pre><code>multi method head(Any:D:) is raw\nmulti method head(Any:D: Callable:D $w)\nmulti method head(Any:D: $n)</code></pre></p><p>Returns either the first element in the object, or the first $n if that's used.</p><p><pre><code>\"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n\"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\nsay ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\nsay ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\nsay ^10 .head;              # OUTPUT: «0␤»\nsay ^∞ .head;               # OUTPUT: «0␤»</code></pre></p><p>In the first two cases, the results are different since there's no defined order in Mixes. In the other cases, it returns a Seq. A Callable can be used to return all but the last elements:</p><p><pre><code>say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»</code></pre></p>","tree":"<p>Defined as:</p><p><pre><code>multi method tree(Any:U:)\nmulti method tree(Any:D:)\nmulti method tree(Any:D: Whatever )\nmulti method tree(Any:D: Int(Cool) $count)\nmulti method tree(Any:D: @ [&first, *@rest])\nmulti method tree(Any:D: &first, *@rest)</code></pre></p><p>Returns the class if it's undefined or if it's not Iterable, returns the result of applying the tree method to its invocant otherwise.</p><p><pre><code>say Any.tree; # OUTPUT: «Any␤»</code></pre></p><p>.tree has different prototypes for Iterable elements.</p><p><pre><code>my @floors = ( 'A', ('B','C', ('E','F','G')));\nsay @floors.tree(1).flat.elems; # OUTPUT: «6␤»\nsay @floors.tree(2).flat.elems; # OUTPUT: «2␤»\nsay @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n</code></pre></p><p>With a number, it iteratively applies tree to every element in the lower level; the first instance will apply .tree(0) to every element in the array, and likewise for the next example.</p><p>The second prototype applies the Whatever code passed as arguments to every level in turn; the first argument will go to level 1 and so on. tree can, thus, be a great way to process complex all levels of complex, multi-level, data structures.</p>","pairs":"<p>Defined as:</p><p><pre><code>multi method pairs(Any:U:)\nmulti method pairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object:</p><p><pre><code>say Num.pairs; # OUTPUT: «()␤»</code></pre></p><p>For a value object, it converts the invocant to a List via the list method and returns the result of List.pairs on it.</p><p><pre><code><1 2 2 3 3 3>.Bag.pairs.say;# OUTPUT: «(1 => 1 3 => 3 2 => 2)␤»</code></pre></p><p>In this case, every element (with weight) in a bag is converted to a pair.</p>","antipairs":"<p>Defined as:</p><p><pre><code>multi method antipairs(Any:U:)\nmulti method antipairs(Any:D:)</code></pre></p><p>Returns an empty List if the invocant is a type object</p><p><pre><code>Range.antipairs.say; # OUTPUT: «()␤»</code></pre></p><p>If it's a value object, it returns the inverted list of pairs after converting it to a list of pairs; the values will become keys and the other way round.</p><p><pre><code>%(s => 1, t=> 2, u => 3).antipairs.say ;# OUTPUT: «(2 => t 1 => s 3 => u)␤»</code></pre></p>","unique":"<p>Defined as:</p><p><pre><code>multi method unique()\nmulti method unique( :&as!, :&with! )\nmulti method unique( :&as! )\nmulti method unique( :&with! )</code></pre></p><p>Creates a sequence of unique elements either of the object or of values in the case it's called as a sub.</p><p><pre><code><1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\nsay unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»</code></pre></p><p>The :as and :with parameters receive functions that are used for transforming the item before checking equality, and for checking equality, since by default the === operator is used:</p><p><pre><code>(\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»</code></pre></p><p>Please see unique for additional examples that use its sub form.</p>","pairup":"<p>Defined as:</p><p><pre><code>multi method pairup(Any:U:)\nmulti method pairup(Any:D:)</code></pre></p><p>Returns an empty Seq if the invocant is a type object</p><p><pre><code>Range.pairup.say; # OUTPUT: «()␤»</code></pre></p><p>Interprets the invocant as a list, and constructs a list of pairs from it, in the same way that assignment to a Hash does. That is, it takes two consecutive elements and constructs a pair from them, unless the item in the key position already is a pair (in which case the pair is passed through, and the next list item, if any, is considered to be a key again). It returns a Seq of Pairs.</p><p><pre><code>say (a => 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»</code></pre></p><p></p>","serial":"<p>Defined as</p><p><pre><code>multi method serial()</code></pre></p><p>This method is Rakudo specific, and is not included in the Raku spec.</p><p>The method returns the self-reference to the instance itself:</p><p><pre><code>my $b;                 # defaults to Any\nsay $b.serial.^name;   # OUTPUT: «Any␤»\nsay $b.^name;          # OUTPUT: «Any␤»\nmy $breakfast = 'food';\n$breakfast.serial.say; # OUTPUT: «food␤»\n</code></pre></p><p>This is apparently a no-op, as exemplified by the third example above. However, in HyperSeqs and RaceSeqs it returns a serialized Seq, so it can be considered the opposite of the hyper/race methods. As such, it ensures that we are in serial list-processing mode, as opposed to the autothreading mode of those methods.</p>","roll":"<p>Defined as:</p><p><pre><code>multi method roll(--> Any)\nmulti method roll($n --> Seq)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.roll on it.</p><p><pre><code>my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\nsay $m.roll;    # OUTPUT: «ð␤»\nsay $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»</code></pre></p><p>$m, in this case, is converted into a list and then a (weighted in this case) dice is rolled on it. See also List.roll for more information.</p>","hash":"<p>Defined as:</p><p><pre><code>multi method hash(Any:U:)\nmulti method hash(Any:D:)</code></pre></p><p>When called on a type object, returns an empty Hash. On instances, it is equivalent to assigning the invocant to a %-sigiled variable and returning that.</p><p>Subclasses of Any may choose to return any core type that does the Associative role from .hash. Use .Hash to coerce specifically to Hash.</p><p><pre><code>my $d; # $d is Any\nsay $d.hash; # OUTPUT: {}\n\nmy %m is Map = a => 42, b => 666;\nsay %m.hash;  # Map.new((a => 42, b => 666))\nsay %m.Hash;  # {a => 42, b => 666}\n</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>multi method values(Any:U:)\nmulti method values(Any:D:)</code></pre></p><p>Will return an empty list for undefined or class arguments, and the object converted to a list otherwise.</p><p><pre><code>say (1..3).values; # OUTPUT: «(1 2 3)␤»\nsay List.values;   # OUTPUT: «()␤»</code></pre></p>","produce":"<p>Defined as:</p><p><pre><code>multi method produce(Any:U: & --> Nil)\nmulti method produce(Any:D: &with)\nmulti sub produce (&with, +list)</code></pre></p><p>This is similar to reduce, but returns a list with the accumulated values instead of a single result.</p><p><pre><code><10 5 3>.reduce( &[*] ).say ; # OUTPUT: «150␤»\n<10 5 3>.produce( &[*] ).say; # OUTPUT: «(10 50 150)␤»\n</code></pre></p><p>The last element of the produced list would be the output produced by the .reduce method.</p><p>If it's a class, it will simply return Nil.</p>","combinations":"<p>Defined as:</p><p><pre><code>method combinations(|c)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.combinations on it.</p><p><pre><code>say (^3).combinations; # OUTPUT: «(() (0) (1) (2) (0 1) (0 2) (1 2) (0 1 2))␤»\n</code></pre></p>","nl-out":"<p>Defined as:</p><p><pre><code>method nl-out(--> Str)</code></pre></p><p>Returns Str with the value of \"\\n\". See IO::Handle.nl-out for the details.</p><p><pre><code>Num.nl-out.print;     # OUTPUT: «␤»\nWhatever.nl-out.print;# OUTPUT: «␤»\n33.nl-out.print;      # OUTPUT: «␤»</code></pre></p>","Bag":"<p>Defined as:</p><p><pre><code>method Bag(--> Bag:D) is nodal</code></pre></p><p>Coerces the invocant to Bag, whereby Positionals are treated as lists of values.</p>","List":"<p>Defined as:</p><p><pre><code>method List(--> List:D) is nodal</code></pre></p><p>Coerces the invocant to List, using the list method.</p>","minmax":"<p>Defined as:</p><p><pre><code>multi method minmax()\nmulti method minmax(&by)\nmulti sub minmax(+args, :&by!)\nmulti sub minmax(+args)</code></pre></p><p>Returns a Range from the smallest to the largest element.</p><p>If a Callable positional argument is provided, each value is passed into the filter, and its return value is compared instead of the original value. The original values are still used in the returned Range.</p><p><pre><code>say (1,7,3).minmax();        # OUTPUT:«1..7␤»\nsay (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\nsay minmax(1,7,3);           # OUTPUT: «1..7␤»\nsay minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»</code></pre></p>","eager":"<p>Defined as:</p><p><pre><code>method eager() is nodal</code></pre></p><p>Interprets the invocant as a List, evaluates it eagerly, and returns that List.</p><p><pre><code>my  $range = 1..5;\nsay $range;         # OUTPUT: «1..5␤»\nsay $range.eager;   # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p>","batch":"<p>Defined as:</p><p><pre><code>multi method batch(Int:D $batch)\nmulti method batch(Int:D :$elems!)</code></pre></p><p>Coerces the invocant to a list by applying its .list method and uses List.batch on it.</p>","minpairs":"<p>Defined as:</p><p><pre><code>multi method minpairs(Any:D:)</code></pre></p><p>Calls .pairs and returns a Seq with all of the Pairs with minimum values, as judged by the cmp operator:</p><p><pre><code><a b c a b c>.minpairs.perl.put; # OUTPUT: «(0 => \"a\", 3 => \"a\").Seq␤»\n%(:42a, :75b).minpairs.perl.put; # OUTPUT: «(:a(42),).Seq␤»</code></pre></p>"},"prefix":"<p><pre><code>class Any is Mu {}</code></pre></p><p>While Mu is the root of the Raku class hierarchy, Any is the class that serves as a default base class for new classes, and as the base class for most built-in classes.</p><p>Since Raku intentionally confuses items and single-element lists, most methods in Any are also present on class List, and coerce to List or a list-like type.</p>"},"Bool":{"prefix":"<p><pre><code>enum Bool <False True></code></pre></p><p>   An enum for boolean true/false decisions.</p>","defs":{"ACCEPTS":"<p><pre><code>method ACCEPTS(Bool:D: --> Bool:D)</code></pre></p><p>Used for smartmatch comparison. When the right side is True returns always True, when the right side of the match is False returns always False. In particular, ACCEPTS returns always the instance on which it is invoked, that is the right side of a smartmatch. As an example:</p><p><pre><code>my $b = Bool.new( True );\n# when True on the right side returns\n# always True\nTrue  ~~ $b;     # True\nFalse ~~ $b;     # True\n\n$b = Bool.new( False );\n# when False on the right side\n# returns always False\nFalse ~~ $b;     # False\nTrue ~~ $b;      # False\n</code></pre></p>","roll":"<p><pre><code>multi method roll(Bool:U --> Bool:D)\nmulti method roll(Bool:U $count --> Seq:D)</code></pre></p><p>Returns True or False if called without any argument. Otherwise returns $count elements chosen at random. Note that each random choice from the enum is made independently, like a separate coin toss where each side of the coin represents one of the two values of the enum. If * is passed as $count an infinite Seq of Bools is returned.</p><p><pre><code>say Bool.roll;                                    # OUTPUT: «True␤»\nsay Bool.roll(3);                                 # OUTPUT: «(True False False)␤»\nsay Bool.roll(*);                                 # OUTPUT: «(...)␤»</code></pre></p>","Numeric":"<p><pre><code>multi method Numeric(Bool:D --> Int:D)</code></pre></p><p>Returns the value part of the enum pair.</p><p><pre><code>say False.Numeric;                                # OUTPUT: «0␤»\nsay True.Numeric;                                 # OUTPUT: «1␤»</code></pre></p>","&prefix:<?>":"<p><pre><code>multi sub prefix:<?>(Mu --> Bool:D)</code></pre></p><p>Coerces its argument to Bool.</p>","enums":"<p><pre><code>method enums(--> Hash:D)</code></pre></p><p>Returns a Hash of enum-pairs. Works on both the Bool type and any key.</p><p><pre><code>say Bool.enums;                                   # OUTPUT: «{False => 0, True => 1}␤»\nsay False.enums;                                  # OUTPUT: «{False => 0, True => 1}␤»</code></pre></p>","pick":"<p><pre><code>multi method pick(Bool:U --> Bool:D)\nmulti method pick(Bool:U $count --> Seq:D)</code></pre></p><p>Returns True or False if called without any argument. Otherwise returns $count elements chosen at random (without repetition) from the enum. If * is passed as $count, or $count is greater than or equal to two, then both elements are returned in random order.</p><p><pre><code>say Bool.pick;                                    # OUTPUT: «True␤»\nsay Bool.pick(1);                                 # OUTPUT: «(False)␤»\nsay Bool.pick(*);                                 # OUTPUT: «(False True)␤»</code></pre></p>","pred":"<p><pre><code>method pred(--> Bool:D)</code></pre></p><p>Returns False.</p><p><pre><code>say True.pred;                                    # OUTPUT: «False␤»\nsay False.pred;                                   # OUTPUT: «False␤»</code></pre></p><p>pred is short for \"predecessor\"; it returns the previous enum value. Bool is a special enum with only two values, False and True. When sorted, False comes first, so False is the predecessor to True. And since False is the \"lowest\" Bool enum value, its own predecessor is also False.</p>","Int":"<p><pre><code>multi method Int(Bool:D --> Int:D)</code></pre></p><p>Returns the value part of the enum pair.</p><p><pre><code>say False.Int;                                # OUTPUT: «0␤»\nsay True.Int;                                 # OUTPUT: «1␤»</code></pre></p>","succ":"<p><pre><code>method succ(--> Bool:D)</code></pre></p><p>Returns True.</p><p><pre><code>say True.succ;                                    # OUTPUT: «True␤»\nsay False.succ;                                   # OUTPUT: «True␤»</code></pre></p><p>succ is short for \"successor\"; it returns the next enum value. Bool is a special enum with only two values, False and True. When sorted, False comes first, so True is its successor. And since True is the \"highest\" Bool enum value, its own successor is also True.</p>"},"name":"Bool"},"WhateverCode":{"prefix":"<p><pre><code>class WhateverCode is Code { }</code></pre></p><p>WhateverCode objects are the result of Whatever-currying. See the Whatever documentation for details.</p><p>When you wish to control how a method or function interprets any Whatever star, you may use multi dispatch with Whatever and WhateverCode parameters to do so, as in the following example:</p><p><pre><code>class Cycle {\n      has $.pos;\n      has @.vals;\n}\n\nmulti sub get-val(Cycle $c, Int $idx) {\n      $c.vals[$idx % $c.vals.elems]\n}\n\n# Define what to do with a stand-alone * as the second argument\nmulti sub get-val(Cycle $c, Whatever $idx) {\n    get-val($c, $c.pos);\n}\n\n# Define what to do with a * WhateverCode in an expression\nmulti sub get-val(Cycle $c, WhateverCode $idx) {\n    get-val($c, $idx($c.pos));\n}\n\nmy Cycle $c .= new(:pos(2), :vals(0..^10));\n\nsay get-val($c, 3);   # OUTPUT: «3␤»\nsay get-val($c, *);   # OUTPUT: «2␤»\nsay get-val($c, *-1); # OUTPUT: «1␤»</code></pre></p><p>The WhateverCode does the Callable role, so it should be possible to introspect the type of Callable it contains; for instance, continuing the previous example, we can add a multi that handles a WhateverCode with two arguments via checking the signature:</p><p><pre><code># Define what to do with two * in an expression\nmulti sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {\n    get-val($c, $idx($c.pos, $c.vals.elems));\n}\n\nsay get-val($c, * + * div 2); # 2 + 10/2 = 7\n</code></pre></p><p>Note, though, that subexpressions may impose their own Whatever star rules:</p><p><pre><code>my @a = (0, 1, 2);\nsay get-val($c, @a[*-1]) # 2, because the star belongs to the Array class\n</code></pre></p><p>This can make the ownership of Whatever stars become confusing rather quickly, so be careful not to overdo it.</p><p>You may instead type-constrain using Callable type in order to accept any Callable, including WhateverCode:</p><p><pre><code>sub run-with-rand (Callable $code) { $code(rand) };\nrun-with-rand *.say;           # OUTPUT: «0.773672071688484␤»\nrun-with-rand {.say};          # OUTPUT: «0.38673179353983␤»\nrun-with-rand sub { $^v.say }; # OUTPUT: «0.0589543603685792␤»</code></pre></p><p>Type-constraining with &-sigiled parameter works equally well and is shorter to type:</p><p><pre><code>sub run-with-rand (&code) { code time };</code></pre></p>","defs":{},"name":"WhateverCode"},"Lock":{"name":"Lock","prefix":"<p><pre><code>class Lock {}</code></pre></p><p>A Lock is a low-level concurrency control construct. It provides mutual exclusion, meaning that only one thread may hold the lock at a time. Once the lock is unlocked, another thread may then lock it.</p><p>A Lock is typically used to protect access to one or more pieces of state. For example, in this program:</p><p><pre><code>my $x = 0;\nmy $l = Lock.new;\nawait (^10).map: {\n    start {\n        $l.protect({ $x++ });\n    }\n}\nsay $x;         # OUTPUT: «10␤»</code></pre></p><p>The Lock is used to protect operations on $x. An increment is not an atomic operation; without the lock, it would be possible for two threads to both read the number 5 and then both store back the number 6, thus losing an update. With the use of the Lock, only one thread may be running the increment at a time.</p><p>A Lock is re-entrant, meaning that a thread that holds the lock can lock it again without blocking. That thread must unlock the same number of times before the lock can be obtained by another thread (it works by keeping a recursion count).</p><p>It's important to understand that there is no direct connection between a Lock and any particular piece of data; it is up to the programmer to ensure that the Lock is held during all operations that involve the data in question. The OO::Monitors module, while not a complete solution to this problem, does provide a way to avoid dealing with the lock explicitly and encourage a more structured approach.</p><p>The Lock class is backed by operating-system provided constructs, and so a thread that is waiting to acquire a lock is, from the point of view of the operating system, blocked.</p><p>Code using high-level Raku concurrency constructs should avoid using Lock. Waiting to acquire a Lock blocks a real Thread, meaning that the thread pool (used by numerous higher-level Raku concurrency mechanisms) cannot use that thread in the meantime for anything else.</p><p>Any await performed while a Lock is held will behave in a blocking manner; the standard non-blocking behavior of await relies on the code following the `await` resuming on a different Thread from the pool, which is incompatible with the requirement that a Lock be unlocked by the same thread that locked it. See Lock::Async for an alternative mechanism that does not have this shortcoming.</p><p>By their nature, Locks are not composable, and it is possible to end up with hangs should circular dependencies on locks occur. Prefer to structure concurrent programs such that they communicate results rather than modify shared data structures, using mechanisms like Promise, Channel and Supply.</p>","defs":{"lock":"<p>Defined as:</p><p><pre><code>method lock(Lock:D:)</code></pre></p><p>Acquires the lock. If it is currently not available, waits for it.</p><p><pre><code>my $l = Lock.new;\n$l.lock;</code></pre></p><p>Since a Lock is implemented using OS-provided facilities, a thread waiting for the lock will not be scheduled until the lock is available for it. Since Lock is re-entrant, if the current thread already holds the lock, calling lock will simply bump a recursion count.</p><p>While it's easy enough to use the lock method, it's more difficult to correctly use unlock. Instead, prefer to use the protect method instead, which takes care of making sure the lock/unlock calls always both occur.</p>","protect":"<p>Defined as:</p><p><pre><code>method protect(Lock:D: &code)</code></pre></p><p>Obtains the lock, runs &code, and releases the lock afterwards. Care is taken to make sure the lock is released even if the code is left through an exception.</p><p>Note that the Lock itself needs to be created outside the portion of the code that gets threaded and it needs to protect. In the first example below, Lock is first created and assigned to $lock, which is then used inside the Promises to protect the sensitive code. In the second example, a mistake is made: the Lock is created right inside the Promise, so the code ends up with a bunch of separate locks, created in a bunch of threads, and thus they don't actually protect the code we want to protect.</p><p><pre><code># Right: $lock is instantiated outside the portion of the\n# code that will get threaded and be in need of protection\nmy $lock = Lock.new;\nawait ^20 .map: {\n    start {\n        $lock.protect: {\n            print \"Foo\";\n            sleep rand;\n            say \"Bar\";\n        }\n    }\n}\n\n# !!! WRONG !!! Lock is created inside threaded area!\nawait ^20 .map: {\n    start {\n        Lock.new.protect: {\n            print \"Foo\"; sleep rand; say \"Bar\";\n        }\n    }\n}</code></pre></p>","unlock":"<p>Defined as:</p><p><pre><code>method unlock(Lock:D:)</code></pre></p><p>Releases the lock.</p><p><pre><code>my $l = Lock.new;\n$l.lock;\n$l.unlock;</code></pre></p><p>It is important to make sure the Lock is always released, even if an exception is thrown. The safest way to ensure this is to use the protect method, instead of explicitly calling lock and unlock. Failing that, use a LEAVE phaser.</p><p><pre><code>my $l = Lock.new;\n{\n    $l.lock;\n    LEAVE $l.unlock;\n}</code></pre></p>"}},"X::Phaser::PrePost":{"name":"X::Phaser::PrePost","prefix":"<p><pre><code>class X::Phaser::PrePost is Exception { }\n</code></pre></p><p>Thrown when the condition inside a PRE or POST phaser evaluate to a false value.</p><p>For example</p><p><pre><code>sub f($x) { PRE { $x ~~ Int } };\nf \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: X::Phaser::PrePost: Precondition '{ $x ~~ Int }' failed«␤»</code></pre></p>","defs":{"phaser":"<p><pre><code>method phaser(--> Str:D)</code></pre></p><p>Returns the name of the failed phaser, \"PRE\" or \"POST\".</p>"}},"X::Syntax::Self::WithoutObject":{"name":"X::Syntax::Self::WithoutObject","prefix":"<p><pre><code>class X::Syntax::Self::WithoutObject does X::Syntax { }</code></pre></p><p>Syntax error thrown when self is referenced in a place where no invocant is available.</p><p>For example</p><p><pre><code>self;\n</code></pre></p><p>outside a class or role declaration dies with</p><p><pre><code>===SORRY!===\n'self' used where no object is available\n</code></pre></p>","defs":{}},"Grammar":{"prefix":"<p><pre><code>class Grammar is Match {}</code></pre></p><p>Every type declared with grammar and not explicitly stating its superclass, becomes a subclass of Grammar.</p><p><pre><code>grammar Identifier {\n    token TOP       { <initial> <rest>* }\n    token initial   { <+myletter +[_]> }\n    token rest      { <+myletter +mynumber +[_]> }\n    token myletter  { <[A..Za..z]> }\n    token mynumber  { <[0..9]> }\n}\n\nsay Identifier.isa(Grammar);                # OUTPUT: «True␤»\nmy $match = Identifier.parse('W4anD0eR96');\nsay ~$match;                                # OUTPUT: «W4anD0eR96␤»</code></pre></p><p>More documentation on grammars is available.</p>","defs":{"parse":"<p>Defined as:</p><p><pre><code>method parse($target, :$rule = 'TOP',  Capture() :$args = \\(), Mu :$actions = Mu, *%opt)</code></pre></p><p>Parses the $target, which will be coerced to Str if it isn't one, using $rule as the starting rule. Additional $args will be passed to the starting rule if provided.</p><p><pre><code>grammar RepeatChar {\n    token start($character) { $character+ }\n}\n\nsay RepeatChar.parse('aaaaaa', :rule('start'), :args(\\('a')));\nsay RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')));\n\n# OUTPUT:\n# ｢aaaaaa｣\n# ｢bbbbbb｣</code></pre></p><p>If the action named argument is provided, it will be used as an action object, that is, for each successful regex match, a method of the same name, if it exists, is called on the action object, passing the match object as the sole positional argument.</p><p><pre><code>my $actions = class { method TOP($/) { say \"7\" } };\ngrammar { token TOP { a { say \"42\" } b } }.parse('ab', :$actions);\n# OUTPUT : «42␤7␤»</code></pre></p><p>Additional named arguments are used as options for matching, so you can specify things like :pos(4) to start parsing from the fourth (zero-base) character. All matching adverbs are allowed, but not all of them take effect. There are several types of adverbs that a regex can have, some of which apply at compile time, like :s and :i. You cannot pass those to .parse, because the regexes have already been compiled. But, you can pass those adverbs that affect the runtime behavior, such as :pos and :continue.</p><p><pre><code>say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')), :pos(4)).Str;\n# OUTPUT : «bb␤»\n</code></pre></p><p>Method parse only succeeds if the cursor has arrived at the end of the target string when the match is over. Use method subparse if you want to be able to stop in the middle.</p><p>Returns a Match object on success, and Nil on failure.</p>","subparse":"<p>Defined as:</p><p><pre><code>method subparse($target, :$rule = 'TOP', Capture() :$args = \\(),  Mu :$actions = Mu, *%opt)</code></pre></p><p>Does exactly the same as method parse, except that cursor doesn't have to reach the end of the string to succeed. That is, it doesn't have to match the whole string.</p><p>Note that unlike method parse, subparse always returns a Match object, which will be a failed match (and thus falsy), if the grammar failed to match.</p><p><pre><code>grammar RepeatChar {\n    token start($character) { $character+ }\n}\n\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('b')));\nsay RepeatChar.parse('bbbabb', :rule('start'), :args(\\('b')));\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')));\nsay RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')), :pos(3));\n\n\n# OUTPUT:\n# ｢bbb｣\n# Nil\n# #<failed match>\n# ｢a｣</code></pre></p>"},"name":"Grammar"},"Sequence":{"name":"Sequence","prefix":"<p><pre><code>class Sequence does PositionalBindFailover { }</code></pre></p><p>A Sequence implements a series of methods for converting high-level Seqs into different types of objects, from positional to other.</p>","defs":{}},"Collation":{"name":"Collation","prefix":"<p><pre><code>class Collation { }\n</code></pre></p><p>Collation is the class that allows proper sorting, taking into account all Unicode characteristics. It's the class the object $*COLLATION is instantiated to, and thus includes collation levels, that is, what kind of features should be looked up when comparing two strings and in which order.</p>","defs":{"primary":"<p>Defined as:</p><p><pre><code>method primary</code></pre></p><p>Returns the state of the primary collation level.</p>","secondary":"<p>Defined as:</p><p><pre><code>method secondary</code></pre></p><p>Returns the state of the secondary collation level.</p>","tertiary":"<p>Defined as:</p><p><pre><code>method tertiary</code></pre></p><p>Returns the state of the tertiary collation level.</p>"}},"Exception":{"defs":{"gist":"<p>Defined as:</p><p><pre><code>multi method gist(Exception:D:)</code></pre></p><p>Returns whatever the exception printer should produce for this exception. The default implementation returns message and backtrace separated by a newline.</p><p><pre><code>my $e = X::AdHoc.new(payload => \"This exception is pretty bad\");\ntry $e.throw;\nif ($!) { say $!.gist; };\n# OUTPUT: «This exception is pretty bad\n#   in block <unit> at <unknown file> line 1␤»</code></pre></p>","fail":"<p>Defined as:</p><p><pre><code>multi sub    fail(*@text)\nmulti sub    fail(Exception $e)\nmethod fail(Exception:D:)</code></pre></p><p>Exits the calling Routine and returns a Failure object wrapping the exception $e - or, for the *@text form, an X::AdHoc exception constructed from the concatenation of @text. If the caller activated fatal exceptions via the pragma use fatal;, the exception is thrown instead of being returned as a Failure.</p><p><pre><code># A custom exception defined\nclass ForbiddenDirectory is Exception {\n    has Str $.name;\n\n    method message { \"This directory is forbidden: '$!name'\" }\n}\n\nsub copy-directory-tree ($dir) {\n    # We don't allow for non-directories to be copied\n    fail \"$dir is not a directory\" if !$dir.IO.d;\n    # We don't allow 'foo' directory to be copied too\n    fail ForbiddenDirectory.new(:name($dir)) if $dir eq 'foo';\n    # or above can be written in method form as:\n    # ForbiddenDirectory.new(:name($dir)).fail if $dir eq 'foo';\n    # Do some actual copying here\n    ...\n}\n\n# A Failure with X::AdHoc exception object is returned and\n# assigned, so no throwing Would be thrown without an assignment\nmy $result = copy-directory-tree(\"cat.jpg\");\nsay $result.exception; # OUTPUT: «cat.jpg is not a directory␤»\n\n# A Failure with a custom Exception object is returned\n$result = copy-directory-tree('foo');\nsay $result.exception; # OUTPUT: «This directory is forbidden: 'foo'␤»</code></pre></p>","throw":"<p>Defined as:</p><p><pre><code>method throw(Exception:D:)</code></pre></p><p>Throws the exception.</p><p><pre><code>my $exception = X::AdHoc.new;    # Totally fine\ntry $exception.throw;            # Throws\nif ($!) { #`( some handling ) }; # Suppress the exception</code></pre></p>","resume":"<p>Defined as:</p><p><pre><code>method resume(Exception:D:)</code></pre></p><p>Resumes control flow where .throw left it when handled in a CATCH block.</p><p><pre><code># For example, resume control flow for any exception\nCATCH { default { .resume } }</code></pre></p>","message":"<p>Defined as:</p><p><pre><code>method message(Exception:D: --> Str:D)</code></pre></p><p>This is a stub that must be overwritten by subclasses, and should return the exception message.</p><p>Special care should be taken that this method does not produce an exception itself.</p><p><pre><code>try die \"Something bad happened\";\nif ($!) {\n    say $!.message; # OUTPUT: «Something bad happened.␤»\n}</code></pre></p>","rethrow":"<p>Defined as:</p><p><pre><code>method rethrow(Exception:D:)</code></pre></p><p>Rethrows an exception that has already been thrown at least once. This is different from throw in that it preserves the original backtrace.</p><p><pre><code>my $e = X::AdHoc.new(payload => \"Bad situation\");\nsub f() { die 'Bad' };\nsub g() { try f; CATCH { default { .rethrow } } };\ng;\nCATCH { default { say .backtrace.full } };</code></pre></p>","backtrace":"<p>Defined as:</p><p><pre><code>method backtrace(Exception:D:)</code></pre></p><p>Returns the backtrace associated with the exception in a Backtrace object or an empty string if there is none. Only makes sense on exceptions that have been thrown at least once.</p><p><pre><code>try die \"Something bad happened\";\nwith $! { .backtrace.print ; }</code></pre></p>"},"prefix":"<p><pre><code>class Exception {}</code></pre></p><p>All exceptions that are placed into the $! variable (or into $_ in CATCH blocks) inherit from Exception. When you call die or fail with a non-Exception argument, it is wrapped into an X::AdHoc object, which also inherits from Exception.</p><p>User-defined exception classes should inherit from Exception too, and define at least a method message.</p><p><pre><code>class X::YourApp::SomeError is Exception {\n    method message() {\n        \"A YourApp-Specific error occurred: out of coffee!\";\n    }\n}</code></pre></p>","name":"Exception"},"Metamodel::RoleContainer":{"name":"Metamodel::RoleContainer","prefix":"<p><pre><code>role Metamodel::RoleContainer {}</code></pre></p><p>Implements the ability to hold roles to be held for composition.</p><p><pre><code>class A does SomeRole {}\n</code></pre></p><p>roughly corresponds to</p><p><pre><code>class A {\n    BEGIN A.^add_role(SomeRole);\n}\n</code></pre></p>","defs":{"add_role":"<p><pre><code>method add_role(Metamodel::RoleContainer:D: $obj, Mu $role)</code></pre></p><p>Adds the $role to the list of roles to be composed.</p>"}},"Metamodel::Naming":{"name":"Metamodel::Naming","prefix":"<p><pre><code>role Metamodel::Naming { }</code></pre></p><p>Metamodel role for (optionally) named things, like classes, roles and enums.</p>","defs":{"name":"<p><pre><code>method name($type)</code></pre></p><p>Returns the name of the metaobject, if any.</p><p><pre><code>say 42.^name;       # OUTPUT: «Int␤»</code></pre></p>"}},"X::IO::Rename":{"prefix":"<p><pre><code>class X::IO::Rename does X::IO is Exception { }\n</code></pre></p><p>Error class for failed file or directory rename operations. A typical error message is</p><p><pre><code>Failed to rename 'source' to 'destination': is a directory\n</code></pre></p>","defs":{"from":"<p>Returns the source of the failed rename operation</p>"},"name":"X::IO::Rename"},"X::Caller::NotDynamic":{"name":"X::Caller::NotDynamic","prefix":"<p><pre><code>class X::Caller::NotDynamic is Exception { }</code></pre></p><p>Thrown when trying to access a non dynamic variable through CALLER</p><p>A typical error message is</p><p><pre><code>Cannot access '$x' through CALLER, because it is not declared as dynamic\n</code></pre></p>","defs":{}},"Compiler":{"name":"Compiler","prefix":"<p><pre><code>class Compiler does Systemic {}</code></pre></p><p>Built-in class for providing compiler related information. Usually accessed through the compiler attribute of the $*PERL dynamic variable.</p><p><pre><code>say $*PERL.compiler; # OUTPUT: «rakudo (2019.03.1.385.ga.643.b.8.be.1)␤»</code></pre></p>","defs":{"release":"<p>It's empty, but it might contain the release number for specific releases.</p>","build-date":"<p><pre><code>method build-date()</code></pre></p><p>Up to version 2019.03.1, it returns the date when it was built.</p><p><pre><code>say $*PERL.compiler.build-date; #OUTPUT: «2018-05-05T21:49:43Z␤»</code></pre></p>","id":"<p>Returns an unique identifier, a long hexadecimal string</p>","codename":"<p>It's empty, but it might contain the codename for specific releases.</p>"}},"X::AdHoc":{"defs":{"payload":"<p>Returns the original object which was passed to die.</p>","Numeric":"<p>Defined as</p><p><pre><code>method Numeric()</code></pre></p><p>Converts the payload to Numeric and returns it</p>"},"prefix":"<p><pre><code>class X::AdHoc is Exception { }\n</code></pre></p><p>X::AdHoc is the type into which objects are wrapped if they are thrown as exceptions, but don't inherit from Exception.</p><p>Its benefit over returning non-Exception objects is that it gives access to all the methods from class Exception, like backtrace and rethrow.</p><p>You can obtain the original object with the payload method.</p><p><pre><code>try {\n    die [404, 'File not found']; # throw non-exception object\n}\nprint \"Got HTTP code \",\n    $!.payload[0],          # 404\n    \" and backtrace \",\n    $!.backtrace.Str;</code></pre></p><p>Note that young code will often be prototyped using X::AdHoc and then later be revised to use more specific subtypes of Exception. As such it is usually best not to explicitly rely on receiving an X::AdHoc – in many cases using the string returned by the .message method, which all Exceptions must have, is preferable. Please note that we need to explicitly call .Str to stringify the backtrace correctly.</p>","name":"X::AdHoc"},"CX::Next":{"name":"CX::Next","prefix":"<p><pre><code>role CX::Next does X::Control { }</code></pre></p><p>A control exception that is triggered when next is called.</p><p><pre><code>for ^10 {\n    CONTROL {\n      when CX::Next { say \"We're next\" };\n    }\n    next if $_ %% 2;\n    say \"We're in $_\";\n}\n</code></pre></p><p>This will print:</p><p><pre><code>We're next\nWe're in 1\nWe're next\nWe're in 3\nWe're next\nWe're in 5\nWe're next\nWe're in 7\nWe're next\nWe're in 9\n</code></pre></p>","defs":{}},"CX::Emit":{"defs":{},"prefix":"<p><pre><code>role CX::Emit does X::Control { }</code></pre></p><p>A control exception to be used when emit is used inside a Supply block.</p>","name":"CX::Emit"},"Metamodel::ParametricRoleGroupHOW":{"defs":{},"prefix":"<p><pre><code>class Metamodel::ParametricRoleGroupHOW\n    does Metamodel::Naming\n    does Metamodel::Documenting\n    does Metamodel::Stashing\n    does Metamodel::TypePretense\n    does Metamodel::RolePunning\n    does Metamodel::BoolificationProtocol {}</code></pre></p><p>A ParametricRoleGroupHOW groups a set of ParametricRoleHOW, every one of them representing a single role declaration with their own parameter sets.</p><p><pre><code>(role Zape[::T] {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\nZape.HOW.say ; # OUTPUT: «Perl6::Metamodel::ParametricRoleGroupHOW.new␤»\n</code></pre></p><p>ParametricRoleHOWs need to be added to this kind of group:</p><p><pre><code>my \\zape := Metamodel::ParametricRoleGroupHOW.new_type( name => \"zape\");\nmy \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zipi\", group => zape);\nsay zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n</code></pre></p><p>Note: As most of the Metamodel classes, this class is here mainly for illustration purposes and it's not intended for the final user to instantiate.</p>","name":"Metamodel::ParametricRoleGroupHOW"},"X::Attribute::Undeclared":{"name":"X::Attribute::Undeclared","defs":{"package-kind":"<p>Returns the kind of package the attribute was used in (for example class, grammar)</p>"},"prefix":"<p><pre><code>class X::Attribute::Undeclared is X::Undeclared { }</code></pre></p><p>Thrown when code refers to an attribute that has not been declared.</p><p>For example the code</p><p><pre><code>class A { method m { $!notthere } }\n</code></pre></p><p>Produces the error</p><p><pre><code>Attribute $!notthere not declared in class A\n</code></pre></p>"},"X::Does::TypeObject":{"defs":{},"prefix":"<p><pre><code>class X::Does::TypeObject is Exception {}</code></pre></p><p>When you try to add one or more roles to a type object with does after it has been composed, an error of type X::Does::TypeObject is thrown:</p><p><pre><code>Mu does Numeric;    # Cannot use 'does' operator with a type object.\n</code></pre></p><p>The correct way to apply roles to a type is at declaration time:</p><p><pre><code>class GrassmannNumber does Numeric { ... };\nrole AlgebraDebugger does IO { ... };\ngrammar IntegralParser does AlgebraParser { ... };\n</code></pre></p><p>Roles may only be runtime-mixed into defined object instances:</p><p><pre><code>GrassmannNumber.new does AlgebraDebugger;\n</code></pre></p><p>(This restriction may be worked around by using augment or supersede, or with dark Metamodel magics, but this will likely result in a significant performance penalty.)</p>","name":"X::Does::TypeObject"},"X::Sequence::Deduction":{"prefix":"<p><pre><code>class X::Sequence::Deduction is Exception { }</code></pre></p><p>Exception type thrown when the ... sequence operator is being called without an explicit closure, and the sequence cannot be deduced.</p>","defs":{},"name":"X::Sequence::Deduction"},"X::StubCode":{"name":"X::StubCode","prefix":"<p><pre><code>class X::StubCode is Exception { }</code></pre></p><p>Thrown when a piece of stub code (created via !!! or ...) is executed.</p>","defs":{}},"Set":{"prefix":"<p><pre><code>class Set does Setty { }</code></pre></p><p>A Set is an immutable set, meaning a collection of distinct elements in no particular order. (For mutable sets, see SetHash instead.)</p><p>Objects/values of any type are allowed as set elements. Within a Set, every element is guaranteed to be unique (in the sense that no two elements would compare positively with the === operator):</p><p><pre><code>my $fruits = set <peach apple orange apple apple>;\n\nsay $fruits.elems;      # OUTPUT: «3␤»\nsay $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n</code></pre></p><p>Sets can be treated as object hashes using the { } postcircumfix operator, which returns the value True for keys that are elements of the set, and False for keys that aren't:</p><p><pre><code>my $fruits = set <peach apple orange apple apple>;\nsay $fruits<apple>;  # OUTPUT: «True␤»\nsay $fruits<kiwi>;   # OUTPUT: «False␤»</code></pre></p>","defs":{},"name":"Set"},"Pod::FormattingCode":{"defs":{"type":"<p><pre><code>method type(--> Mu)</code></pre></p>"},"prefix":"<p><pre><code>class Pod::FormattingCode is Pod::Block { }</code></pre></p><p>Class for formatting codes in a Pod document.</p>","name":"Pod::FormattingCode"},"Range":{"defs":{"WHICH":"<p>Defined as</p><p><pre><code>multi method WHICH (Range:D:)</code></pre></p><p>This returns a string that identifies the object. The string is composed by the type of the instance (Range) and the min and max attributes:</p><p><pre><code>say (1..2).WHICH # OUTPUT: «Range|1..2␤»</code></pre></p>","perl":"<p>Defined as</p><p><pre><code>multi method perl(Range:D:)</code></pre></p><p>Returns an implementation-specific string that produces an equivalent object when given to EVAL.</p><p><pre><code>say (1..2).perl # OUTPUT: «1..2␤»</code></pre></p>","ACCEPTS":"<p>Defined as</p><p><pre><code>multi method ACCEPTS(Range:D: Mu \\topic)\nmulti method ACCEPTS(Range:D: Range \\topic)\nmulti method ACCEPTS(Range:D: Cool:D \\got)\nmulti method ACCEPTS(Range:D: Complex:D \\got)</code></pre></p><p>Indicates if the Range contains (overlaps with) another Range. As an example:</p><p><pre><code>my $p = Range.new( 3, 5  );\nmy $r = Range.new( 1, 10 );\n\nsay $p.ACCEPTS( $r );    # OUTPUT: «False␤»\nsay $r.ACCEPTS( $p );    # OUTPUT: «True␤»\nsay $r ~~ $p;            # OUTPUT: «False␤»  (same as $p.ACCEPTS( $r )\nsay $p ~~ $r;            # OUTPUT: «True␤»   (same as $r.ACCEPTS( $p )</code></pre></p><p>Of course, an infinite Range always contains another Range, therefore:</p><p><pre><code>say 1..10 ~~ -∞..∞;    # OUTPUT: «True␤»\nsay 1..10 ~~ -∞^..^∞;  # OUTPUT: «True␤»</code></pre></p><p>Similarly, a Range with open boundaries often includes other ranges:</p><p><pre><code>say 1..2 ~~ *..10;  # OUTPUT: «True␤»\nsay 2..5 ~~ 1..*;   # OUTPUT: «True␤»</code></pre></p><p>It is also possible to use non-numeric ranges, for instance string based ones:</p><p><pre><code>say 'a'..'j' ~~ 'b'..'c';  # OUTPUT: «False␤»\nsay 'b'..'c' ~~ 'a'..'j';  # OUTPUT: «True␤»\nsay 'perl' ~~ -∞^..^∞;     # OUTPUT: «True␤»\nsay 'perl' ~~ -∞..∞;       # OUTPUT: «True␤»\nsay 'perl' ~~ 1..*;        # OUTPUT: «True␤»</code></pre></p><p>When smartmatching a Range of integers with a Cool (string) the ACCEPTS methods exploits the before and after operators in order to check that the Cool value is overlapping the range:</p><p><pre><code>say 1.10 ~~ '5';   # OUTPUT: «False␤»\nsay '5' before 1;  # OUTPUT: «False␤»\nsay '5' after 10;  # OUTPUT: «True␤»\nsay '5' ~~ *..10;  # OUTPUT: «False␤»</code></pre></p><p>In the above example, since the '5' string is after the 10 integer value, the Range does not overlap with the specified value.</p><p>When matching with a Mu instance (i.e., a generic instance), the cmp operator is used.</p>","infinite":"<p><pre><code>method infinite(Range:D: --> Bool:D)</code></pre></p><p>Returns True if either end point was declared with ∞ or *.</p><p><pre><code>say (1..5).infinite;                              # OUTPUT: «False␤»\nsay (1..*).infinite;                              # OUTPUT: «True␤»</code></pre></p>","EXISTS-POS":"<p>Defined as</p><p><pre><code>multi method EXISTS-POS(Range:D: int \\pos)\nmulti method EXISTS-POS(Range:D: Int \\pos)</code></pre></p><p>Returns True if pos is greater or equal than zero and lower than self.elems. Returns False otherwise.</p><p><pre><code>say (6..10).EXISTS-POS(2); # OUTPUT: «True␤»\nsay (6..10).EXISTS-POS(7); # OUTPUT: «False␤»</code></pre></p>","minmax":"<p>Defined as:</p><p><pre><code>multi method minmax(Range:D: --> List:D)</code></pre></p><p>If the Range is an integer range (as indicated by is-int), then this method returns a list with the first and last value it will iterate over (taking into account excludes-min and excludes-max). If the range is not an integer range, the method will return a two element list containing the start and end point of the range unless either of excludes-min or excludes-max are True in which case a Failure is returned.</p><p><pre><code>my $r1 = (1..5); my $r2 = (1^..5);\nsay $r1.is-int, ', ', $r2.is-int;                 # OUTPUT: «True, True␤»\nsay $r1.excludes-min, ', ', $r2.excludes-min;     # OUTPUT: «False, True␤»\nsay $r1.minmax, ', ', $r2.minmax;                 # OUTPUT: «(1 5), (2 5)␤»\n\nmy $r3 = (1.1..5.2); my $r4 = (1.1..^5.2);\nsay $r3.is-int, ', ', $r4.is-int;                 # OUTPUT: «False, False␤»\nsay $r3.excludes-max, ', ', $r4.excludes-max;     # OUTPUT: «False, True␤»\nsay $r3.minmax;                                   # OUTPUT: «(1.1 5.2)␤»\nsay $r4.minmax;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::AdHoc: Cannot return minmax on Range with excluded ends␤»</code></pre></p>","excludes-max":"<p><pre><code>method excludes-max(Range:D: --> Bool:D)</code></pre></p><p>Returns True if the end point is excluded from the range, and False otherwise.</p><p><pre><code>say (1..5).excludes-max;                          # OUTPUT: «False␤»\nsay (1^..^5).excludes-max;                        # OUTPUT: «True␤»</code></pre></p>","roll":"<p><pre><code>multi method roll(Range:D:         --> Any:D)\nmulti method roll(Range:D: $number --> Seq:D)</code></pre></p><p>Performs the same function as Range.list.roll, but attempts to optimize by not actually generating the list if it is not necessary.</p>","AT-POS":"<p>Defined as</p><p><pre><code>multi method AT-POS(Range:D: int \\pos)\nmulti method AT-POS(Range:D: int:D \\pos)</code></pre></p><p>Checks if the Int position exists and in that case returns the element in that position.</p><p><pre><code>say (1..4).AT-POS(2) # OUTPUT: «3␤»</code></pre></p>","rand":"<p>Defined as:</p><p><pre><code>method rand(Range:D --> Num:D)</code></pre></p><p>Returns a pseudo-random value belonging to the range.</p><p><pre><code>say (1^..5).rand;                              # OUTPUT: «1.02405550417031␤»\nsay (0.1..0.3).rand;                           # OUTPUT: «0.2130353370062␤»</code></pre></p>","excludes-min":"<p><pre><code>method excludes-min(Range:D: --> Bool:D)</code></pre></p><p>Returns True if the start point is excluded from the range, and False otherwise.</p><p><pre><code>say (1..5).excludes-min;                          # OUTPUT: «False␤»\nsay (1^..^5).excludes-min;                        # OUTPUT: «True␤»</code></pre></p>","fmt":"<p>Defined as</p><p><pre><code>method fmt(|c)</code></pre></p><p>Returns a string where min and max in the Range have been formatted according to |c.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>say (1..2).fmt(\"Element: %d\", \",\") # OUTPUT: «Element: 1,Element: 2␤»</code></pre></p>","list":"<p><pre><code>method list(Range:D: --> List:D)</code></pre></p><p>Generates the list of elements that the range represents.</p><p><pre><code>say (1..5).list;                                  # OUTPUT: «(1 2 3 4 5)␤»\nsay (1^..^5).list;                                # OUTPUT: «(2 3 4)␤»</code></pre></p>","sum":"<p><pre><code>multi method sum(--> Numeric:D)</code></pre></p><p>Returns the sum of all elements in the Range. Throws X::Str::Numeric if an element can not be coerced into Numeric.</p><p><pre><code>(1..10).sum                                       # 55</code></pre></p>","flat":"<p><pre><code>method flat(Range:D: --> List:D)</code></pre></p><p>Generates the list of elements that the range represents.</p>","pick":"<p><pre><code>multi method pick(Range:D:         --> Any:D)\nmulti method pick(Range:D: $number --> Seq:D)</code></pre></p><p>Performs the same function as Range.list.pick, but attempts to optimize by not actually generating the list if it is not necessary.</p>","max":"<p><pre><code>method max(Range:D:)</code></pre></p><p>Returns the end point of the range.</p><p><pre><code>say (1..5).max;                                   # OUTPUT: «5␤»\nsay (1^..^5).max;                                 # OUTPUT: «5␤»</code></pre></p>","bounds":"<p><pre><code>method bounds()</code></pre></p><p>Returns a list consisting of the start and end point.</p><p><pre><code>say (1..5).bounds;                                # OUTPUT: «(1 5)␤»\nsay (1^..^5).bounds;                              # OUTPUT: «(1 5)␤»</code></pre></p>","min":"<p><pre><code>method min(Range:D:)</code></pre></p><p>Returns the start point of the range.</p><p><pre><code>say (1..5).min;                                   # OUTPUT: «1␤»\nsay (1^..^5).min;                                 # OUTPUT: «1␤»</code></pre></p>","int-bounds":"<p><pre><code>proto method int-bounds(|)\nmulti method int-bounds()\nmulti method int-bounds($from is rw, $to is rw --> Bool:D)</code></pre></p><p>If the Range is an integer range (as indicated by is-int), then this method returns a list with the first and last value it will iterate over (taking into account excludes-min and excludes-max). Returns a Failure if it is not an integer range.</p><p><pre><code>say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\nsay (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»</code></pre></p><p>If called with (writable) arguments, these will take the values of the higher and lower bound and returns whether integer bounds could be determined from the Range:</p><p><pre><code>if (3..5).int-bounds( my $min, my $max) {\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»\n}\nelse {\n    say \"Could not determine integer bounds\";\n}</code></pre></p>","is-int":"<p><pre><code>method is-int(Range:D: --> Bool:D)</code></pre></p><p>Returns True if both end points are Int values.</p><p><pre><code>say ('a'..'d').is-int;                            # OUTPUT: «False␤»\nsay (1..^5).is-int;                               # OUTPUT: «True␤»\nsay (1.1..5.5).is-int;                            # OUTPUT: «False␤»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(Range --> Capture:D)</code></pre></p><p>Returns a Capture with values of .min .max, .excludes-min, .excludes-max, .infinite, and .is-int as named arguments.</p>","elems":"<p><pre><code>method elems(Range:D: --> Numeric:D)</code></pre></p><p>Returns the number of elements in the range, e.g. when being iterated over, or when used as a List. Returns Inf if either end point was specified as Inf or *.</p><p><pre><code>say (1..5).elems;                                 # OUTPUT: «5␤»\nsay (1^..^5).elems;                               # OUTPUT: «3␤»</code></pre></p>","reverse":"<p><pre><code>method reverse(Range:D: --> Seq:D)</code></pre></p><p>Returns a Seq where all elements that the Range represents have been reversed. Note that reversing an infinite Range won't produce any meaningful results.</p><p><pre><code>say (1^..5).reverse;                            # OUTPUT: «(5 4 3 2)␤»\nsay ('a'..'d').reverse;                         # OUTPUT: «(d c b a)␤»\nsay (1..∞).reverse;                             # OUTPUT: «(Inf Inf Inf ...)␤»\n</code></pre></p>"},"prefix":"<p><pre><code>class Range is Cool does Iterable does Positional {}</code></pre></p><p>Ranges serve two main purposes: to generate lists of consecutive numbers or strings, and to act as a matcher to check if a number or string is within a certain range.</p><p>Ranges are constructed using one of the four possible range operators, which consist of two dots, and optionally a caret which indicates that the endpoint marked with it is excluded from the range.</p><p><pre><code>1 .. 5;  # 1 <= $x <= 5\n1^.. 5;  # 1 <  $x <= 5\n1 ..^5;  # 1 <= $x <  5\n1^..^5;  # 1 <  $x <  5</code></pre></p><p>The caret is also a prefix operator for constructing numeric ranges starting from zero:</p><p><pre><code>my $x = 10;\nsay ^$x;     # same as 0 ..^ $x.Numeric</code></pre></p><p>Iterating a range (or calling the list method) uses the same semantics as the ++ prefix and postfix operators, i.e., it calls the succ method on the start point, and then the generated elements.</p><p>Ranges always go from small to larger elements; if the start point is bigger than the end point, the range is considered empty.</p><p><pre><code>for 1..5 { .say };       # OUTPUT: «1␤2␤3␤4␤5␤»\n('a' ^..^ 'f').list;     # RESULT: «'b', 'c', 'd', 'e'»\n5 ~~ ^5;                 # RESULT: «False»\n4.5 ~~ 0..^5;            # RESULT: «True»\n(1.1..5).list;           # RESULT: «(1.1, 2.1, 3.1, 4.1)»</code></pre></p><p>Use the ... sequence operator to produce lists of elements that go from larger to smaller values, or to use offsets other than increment-by-1 and other complex cases.</p><p>Use ∞ or * (Whatever) to indicate an end point to be open-ended.</p><p><pre><code>for 1..* { .say };       # start from 1, continue until stopped\nfor 1..∞ { .say };       # the same\n</code></pre></p><p>Beware that a WhateverCode end point, instead of a plain Whatever, will go through the range operator and create another WhateverCode which returns a Range:</p><p><pre><code># A Whatever produces the 1..Inf range\nsay (1..*).^name;        # OUTPUT: «Range␤»\nsay (1..*);              # OUTPUT: «1..Inf␤»\n# Upper end point is now a WhateverCode\nsay (1..*+20).^name;     # OUTPUT: «{ ... }␤»\nsay (1..*+20).WHAT;      # OUTPUT: «(WhateverCode)␤»\nsay (1..*+20).(22);      # OUTPUT: «1..42␤»\n</code></pre></p><p>Ranges implement Positional interface, so its elements can be accessed using an index. In a case when the index given is bigger than the Range object's size, Nil object will be returned. The access works for lazy Range objects as well.</p><p><pre><code>say (1..5)[1];  # OUTPUT: «2␤»\nsay (1..5)[10]; # OUTPUT: «Nil␤»\nsay (1..*)[10]; # OUTPUT: «11␤»\n</code></pre></p>","name":"Range"},"X::Assignment::RO":{"prefix":"<p><pre><code>class X::Assignment::RO is Exception {}</code></pre></p><p>Code like</p><p><pre><code>sub f() { 42 };\nf() = 'new value';  # throws an X::Assignment::RO\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»</code></pre></p><p>throws an exception of type X::Assignment::RO.</p>","defs":{},"name":"X::Assignment::RO"},"X::Channel::ReceiveOnClosed":{"defs":{},"prefix":"<p><pre><code>class X::Channel::ReceiveOnClosed {}</code></pre></p><p>This exception is thrown when a calling receive on a Channel that has been closed:</p><p><pre><code>my $s = Channel.new;\n$s.close;\n$s.receive;     # Cannot receive a message on a closed channel\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::ReceiveOnClosed: Cannot receive a message on a closed channel␤»</code></pre></p>","name":"X::Channel::ReceiveOnClosed"},"X::IO::DoesNotExist":{"name":"X::IO::DoesNotExist","prefix":"<p><pre><code>class X::IO::DoesNotExist does X::IO is Exception { }\n</code></pre></p><p>Thrown when doing file test operations on a non existing path.</p><p>A typical error message is</p><p><pre><code>Failed to find 'euler-5.p6' while trying to do '.f'\n</code></pre></p>","defs":{"path":"<p>Returns the path that was passed to the failed call.</p>"}},"Baggy":{"prefix":"<p><pre><code>role Baggy does QuantHash { }</code></pre></p><p>A role for collections of weighted objects. See Bag, BagHash, and Mixy.</p>","defs":{"ACCEPTS":"<p>Defined as:</p><p><pre><code>method ACCEPTS($other --> Bool:D)</code></pre></p><p>Used in smartmatching if the right-hand side is a Baggy.</p><p>If the right-hand side is the type object, i.e. Baggy, the method returns True if $other does Baggy otherwise False is returned.</p><p>If the right-hand side is a Baggy object, True is returned only if $other has the same elements, with the same weights, as the invocant.</p><p><pre><code>my $breakfast = bag <eggs bacon>;\nsay $breakfast ~~ Baggy;                            # OUTPUT: «True␤»\nsay $breakfast.does(Baggy);                         # OUTPUT: «True␤»\n\nmy $second-breakfast = (eggs => 1, bacon => 1).Mix;\nsay $breakfast ~~ $second-breakfast;                # OUTPUT: «True␤»\n\nmy $third-breakfast = (eggs => 1, bacon => 2).Bag;\nsay $second-breakfast ~~ $third-breakfast;          # OUTPUT: «False␤»</code></pre></p>","keys":"<p>Defined as:</p><p><pre><code>method keys(Baggy:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all keys in the Baggy object without taking their individual weights into account as opposed to kxxv.</p><p><pre><code>my $breakfast = bag <eggs spam spam spam>;\nsay $breakfast.keys.sort;                        # OUTPUT: «(eggs spam)␤»\n\nmy $n = (\"a\" => 5, \"b\" => 2).BagHash;\nsay $n.keys.sort;                                # OUTPUT: «(a b)␤»</code></pre></p>","SetHash":"<p>Defined as:</p><p><pre><code>method SetHash(--> SetHash:D)</code></pre></p><p>Returns a SetHash whose elements are the keys of the invocant.</p><p><pre><code>my $breakfast = (eggs => 2, bacon => 3).BagHash;\nmy $sh = $breakfast.SetHash;\nsay $sh.^name;                            # OUTPUT: «SetHash␤»\nsay $sh.elems;                            # OUTPUT: «2␤»</code></pre></p>","grab":"<p>Defined as:</p><p><pre><code>multi method grab(Baggy:D: --> Any)\nmulti method grab(Baggy:D: $count --> Seq:D)</code></pre></p><p>Like pick, a grab returns a random selection of elements, weighted by the values corresponding to each key. Unlike pick, it works only on mutable structures, e.g. BagHash. Use of grab on an immutable structure results in an X::Immutable exception. If * is passed as $count, or $count is greater than or equal to the total of the invocant, then total elements from the invocant are returned in a random sequence; i.e. they are returned shuffled.</p><p>Grabbing decrements the grabbed key's weight by one (deleting the key when it reaches 0). By definition, the total of the invocant also decreases by one, so the probabilities stay consistent through subsequent grab operations.</p><p><pre><code>my $cars = ('Ford' => 2, 'Rover' => 3).BagHash;\nsay $cars.grab;                                   # OUTPUT: «Ford␤»\nsay $cars.grab(2);                                # OUTPUT: «(Rover Rover)␤»\nsay $cars.grab(*);                                # OUTPUT: «(Rover Ford)␤»\n\nmy $breakfast = ('eggs' => 2, 'bacon' => 3).Bag;\nsay $breakfast.grab;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Immutable: Cannot call 'grab' on an immutable 'Bag'␤»</code></pre></p>","grabpairs":"<p>Defined as:</p><p><pre><code>multi method grabpairs(Baggy:D: --> Any)\nmulti method grabpairs(Baggy:D: $count --> Seq:D)</code></pre></p><p>Returns a Pair or a Seq of Pairs depending on the version of the method being invoked. Each Pair returned has an element of the invocant as its key and the elements weight as its value. Unlike pickpairs, it works only on mutable structures, e.g. BagHash. Use of grabpairs on 'an immutable structure results in an X::Immutable exception. If * is passed as $count, or $count is greater than or equal to the number of elements of the invocant, then all element/weight Pairs from the invocant are returned in a random sequence.</p><p>What makes grabpairs different from pickpairs is that the 'grabbed' elements are in fact removed from the invocant.</p><p><pre><code>my $breakfast = (eggs => 2, bacon => 3).BagHash;\nsay $breakfast.grabpairs;                         # OUTPUT: «bacon => 3␤»\nsay $breakfast;                                   # OUTPUT: «BagHash.new(eggs(2))␤»\nsay $breakfast.grabpairs(1);                      # OUTPUT: «(eggs => 2)␤»\nsay $breakfast.grabpairs(*);                      # OUTPUT: «()␤»\n\nmy $diet = ('eggs' => 2, 'bacon' => 3).Bag;\nsay $diet.grabpairs;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Immutable: Cannot call 'grabpairs' on an immutable 'Bag'␤»</code></pre></p>","kxxv":"<p>Defined as:</p><p><pre><code>method kxxv(Baggy:D: --> Seq:D)</code></pre></p><p>Returns a Seq of the keys of the invocant, with each key multiplied by its weight. Note that kxxv only works for Baggy types which have integer weights, i.e. Bag and BagHash.</p><p><pre><code>my $breakfast = bag <spam eggs spam spam bacon>;\nsay $breakfast.kxxv.sort;                         # OUTPUT: «(bacon eggs spam spam spam)␤»\n\nmy $n = (\"a\" => 0, \"b\" => 1, \"b\" => 2).BagHash;\nsay $n.kxxv;                                      # OUTPUT: «(b b b)␤»</code></pre></p>","classify-list":"<p>Defined as:</p><p><pre><code>multi method classify-list(&mapper, *@list --> Baggy:D)\nmulti method classify-list(%mapper, *@list --> Baggy:D)\nmulti method classify-list(@mapper, *@list --> Baggy:D)</code></pre></p><p>Populates a mutable Baggy by classifying the possibly-empty @list of values using the given mapper. The @list cannot be lazy.</p><p><pre><code>say BagHash.new.classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n# OUTPUT: BagHash.new(even(5), odd(5))\n\nmy @mapper = <zero one two three four five>;\nsay MixHash.new.classify-list: @mapper, 1, 2, 3, 4, 4, 6;\n# OUTPUT: MixHash.new((Any), two, three, four(2), one)</code></pre></p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p><p>The mapper's value is used as the key of the Baggy that will be incremented by 1. See .categorize-list if you wish to classify an item into multiple categories at once.</p><p>Note: unlike the Hash's .classify-list, returning an Iterable mapper's value will throw, as Baggy types do not support nested classification. For the same reason, Baggy's .classify-list does not accept :&as parameter.</p>","default":"<p>Defined as:</p><p><pre><code>method default(Baggy:D: --> Int:D)</code></pre></p><p>Returns zero.</p><p><pre><code>my $breakfast = bag <eggs bacon>;\nsay $breakfast.default;                           # OUTPUT: «0␤»</code></pre></p>","hash":"<p>Defined as:</p><p><pre><code>method hash(Baggy:D: --> Hash:D)</code></pre></p><p>Returns a Hash where the elements of the invocant are the keys and their respective weights the values.</p><p><pre><code>my $breakfast = bag <eggs bacon bacon>;\nmy $h = $breakfast.hash;\nsay $h.^name;                    # OUTPUT: «Hash[Any,Any]␤»\nsay $h;                          # OUTPUT: «{bacon => 2, eggs => 1}␤»</code></pre></p>","antipairs":"<p>Defined as:</p><p><pre><code>method antipairs(Baggy:D: --> Seq:D)</code></pre></p><p>Returns all elements and their respective weights as a Seq of Pairs, where the element itself is the value and the weight of that element is the key, i.e. the opposite of method pairs.</p><p><pre><code>my $breakfast = bag <bacon eggs bacon>;\nmy $seq = $breakfast.antipairs;\nsay $seq.sort;                                    # OUTPUT: «(1 => eggs 2 => bacon)␤»</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>method values(Baggy:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all values, i.e. weights, in the Baggy object.</p><p><pre><code>my $breakfast = bag <eggs spam spam spam>;\nsay $breakfast.values.sort;                      # OUTPUT: «(1 3)␤»\n\nmy $n = (\"a\" => 5, \"b\" => 2, \"a\" => 1).BagHash;\nsay $n.values.sort;                              # OUTPUT: «(2 6)␤»</code></pre></p>","pairs":"<p>Defined as:</p><p><pre><code>method pairs(Baggy:D: --> Seq:D)</code></pre></p><p>Returns all elements and their respective weights as a Seq of Pairs where the key is the element itself and the value is the weight of that element.</p><p><pre><code>my $breakfast = bag <bacon eggs bacon>;\nmy $seq = $breakfast.pairs;\nsay $seq.sort;                                    # OUTPUT: «(bacon => 2 eggs => 1)␤»</code></pre></p>","pickpairs":"<p>Defined as:</p><p><pre><code>multi method pickpairs(Baggy:D: --> Pair:D)\nmulti method pickpairs(Baggy:D: $count --> Seq:D)</code></pre></p><p>Returns a Pair or a Seq of Pairs depending on the version of the method being invoked. Each Pair returned has an element of the invocant as its key and the elements weight as its value. The elements are 'picked' without replacement. If * is passed as $count, or $count is greater than or equal to the number of elements of the invocant, then all element/weight Pairs from the invocant are returned in a random sequence.</p><p>Note that each pickpairs invocation maintains its own private state and has no effect on subsequent pickpairs invocations.</p><p><pre><code>my $breakfast = bag <eggs bacon bacon bacon>;\nsay $breakfast.pickpairs;                         # OUTPUT: «eggs => 1␤»\nsay $breakfast.pickpairs(1);                      # OUTPUT: «(bacon => 3)␤»\nsay $breakfast.pickpairs(*);                      # OUTPUT: «(eggs => 1 bacon => 3)␤»</code></pre></p>","roll":"<p>Defined as:</p><p><pre><code>multi method roll(Baggy:D: --> Any:D)\nmulti method roll(Baggy:D: $count --> Seq:D)</code></pre></p><p>Like an ordinary list roll, but returns keys of the invocant weighted by their values, as if the keys were replicated the number of times indicated by the corresponding value and then list roll used. The underlying metaphor for rolling is that you're throwing $count dice that are independent of each other, which (in bag terms) is equivalent to picking a colored marble out your bag and then putting it back, and doing this $count times. In dice terms, the number of marbles corresponds to the number of sides, and the number of marbles of the same color corresponds to the number of sides with the same color. (For \"picking without replacement\" see pick instead).</p><p>If * is passed to $count, returns a lazy, infinite sequence of randomly chosen elements from the invocant.</p><p><pre><code>my $breakfast = bag <eggs bacon bacon bacon>;\nsay $breakfast.roll;                                  # OUTPUT: «bacon␤»\nsay $breakfast.roll(3);                               # OUTPUT: «(bacon eggs bacon)␤»\n\nmy $random_dishes := $breakfast.roll(*);\nsay $random_dishes[^5];                               # OUTPUT: «(bacon eggs bacon bacon bacon)␤»</code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>method kv(Baggy:D: --> Seq:D)</code></pre></p><p>Returns a Seq of keys and values interleaved.</p><p><pre><code>my $breakfast = bag <eggs spam spam spam>;\nsay $breakfast.kv;                                # OUTPUT: «(spam 3 eggs 1)␤»\n\nmy $n = (\"a\" => 5, \"b\" => 2, \"a\" => 1).BagHash;\nsay $n.kv;                                        # OUTPUT: «(a 6 b 2)␤»</code></pre></p>","total":"<p>Defined as:</p><p><pre><code>method total(Baggy:D:)</code></pre></p><p>Returns the sum of weights for all elements in the Baggy object.</p><p><pre><code>my $breakfast = bag <eggs spam spam bacon>;\nsay $breakfast.total;                             # OUTPUT: «4␤»\n\nmy $n = (\"a\" => 5, \"b\" => 1, \"b\" => 2).BagHash;\nsay $n.total;                                     # OUTPUT: «8␤»</code></pre></p>","categorize-list":"<p>Defined as:</p><p><pre><code>multi method categorize-list(&mapper, *@list --> Baggy:D)\nmulti method categorize-list(%mapper, *@list --> Baggy:D)\nmulti method categorize-list(@mapper, *@list --> Baggy:D)</code></pre></p><p>Populates a mutable Baggy by categorizing the possibly-empty @list of values using the given mapper. The @list cannot be lazy.</p><p><pre><code>say BagHash.new.categorize-list: {\n    gather {\n        take 'largish' if $_ > 5;\n        take .is-prime ?? 'prime' !! 'non-prime';\n        take $_ %% 2   ?? 'even'  !! 'odd';\n    }\n}, ^10;\n# OUTPUT: BagHash.new(largish(4), even(5), non-prime(6), prime(4), odd(5))\n\nmy %mapper = :sugar<sweet white>, :lemon<sour>, :cake('sweet', 'is a lie');\nsay MixHash.new.categorize-list: %mapper, <sugar lemon cake>;\n# OUTPUT: MixHash.new(is a lie, sour, white, sweet(2))</code></pre></p><p>The mapper can be a Callable that takes a single argument, an Associative, or an Iterable. With Associative and an Iterable mappers, the values in the @list represent the key and index of the mapper's value respectively. A Callable mapper will be executed once per each item in the @list, with that item as the argument and its return value will be used as the mapper's value.</p><p>The mapper's value is used as a possibly-empty list of keys of the Baggy that will be incremented by 1.</p><p>Note: unlike the Hash's .categorize-list, returning a list of Iterables as mapper's value will throw, as Baggy types do not support nested categorization. For the same reason, Baggy's .categorize-list does not accept :&as parameter.</p>","pick":"<p>Defined as:</p><p><pre><code>multi method pick(Baggy:D: --> Any)\nmulti method pick(Baggy:D: $count --> Seq:D)</code></pre></p><p>Like an ordinary list pick, but returns keys of the invocant weighted by their values, as if the keys were replicated the number of times indicated by the corresponding value and then list pick used. The underlying metaphor for picking is that you're pulling colored marbles out a bag. (For \"picking with replacement\" see roll instead). If * is passed as $count, or $count is greater than or equal to the total of the invocant, then total elements from the invocant are returned in a random sequence.</p><p>Note that each pick invocation maintains its own private state and has no effect on subsequent pick invocations.</p><p><pre><code>my $breakfast = bag <eggs bacon bacon bacon>;\nsay $breakfast.pick;                              # OUTPUT: «eggs␤»\nsay $breakfast.pick(2);                           # OUTPUT: «(eggs bacon)␤»\n\nsay $breakfast.total;                             # OUTPUT: «4␤»\nsay $breakfast.pick(*);                           # OUTPUT: «(bacon bacon bacon eggs)␤»</code></pre></p>","invert":"<p>Defined as:</p><p><pre><code>method invert(Baggy:D: --> Seq:D)</code></pre></p><p>Returns all elements and their respective weights as a Seq of Pairs, where the element itself is the value and the weight of that element is the key, i.e. the opposite of method pairs. Except for some esoteric cases invert on a Baggy type returns the same result as antipairs.</p><p><pre><code>my $breakfast = bag <bacon eggs bacon>;\nmy $seq = $breakfast.invert;\nsay $seq.sort;                                    # OUTPUT: «(1 => eggs 2 => bacon)␤»</code></pre></p>","Set":"<p>Defined as:</p><p><pre><code>method Set(--> Set:D)</code></pre></p><p>Returns a Set whose elements are the keys of the invocant.</p><p><pre><code>my $breakfast = (eggs => 2, bacon => 3).BagHash;\nsay $breakfast.Set;                               # OUTPUT: «set(bacon, eggs)␤»</code></pre></p>","elems":"<p>Defined as:</p><p><pre><code>method elems(Baggy:D: --> Int:D)</code></pre></p><p>Returns the number of elements in the Baggy object without taking the individual elements weight into account.</p><p><pre><code>my $breakfast = bag <eggs spam spam spam>;\nsay $breakfast.elems;                             # OUTPUT: «2␤»\n\nmy $n = (\"b\" => 9.4, \"b\" => 2).MixHash;\nsay $n.elems;                                     # OUTPUT: «1␤»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(Baggy:D: --> Bool:D)</code></pre></p><p>Returns True if the invocant contains at least one element.</p><p><pre><code>my $breakfast = ('eggs' => 1).BagHash;\nsay $breakfast.Bool;                              # OUTPUT: «True   (since we have one element)␤»\n$breakfast<eggs> = 0;                             # weight == 0 will lead to element removal\nsay $breakfast.Bool;                              # OUTPUT: «False␤»</code></pre></p>","new-from-pairs":"<p>Defined as:</p><p><pre><code>method new-from-pairs(*@pairs --> Baggy:D)</code></pre></p><p>Constructs a Baggy objects from a list of Pair objects given as positional arguments:</p><p><pre><code>say Mix.new-from-pairs: 'butter' => 0.22, 'sugar' => 0.1, 'sugar' => 0.02;\n# OUTPUT: «mix(butter(0.22), sugar(0.12))␤»</code></pre></p><p>Note: be sure you aren't accidentally passing the Pairs as positional arguments; the quotes around the keys in the above example are significant.</p>"},"name":"Baggy"},"PredictiveIterator":{"name":"PredictiveIterator","prefix":"<p>A PredictiveIterator is a special kind of Iterator that can know how many values it will (still) generate without actually needing to generate those values.</p><p>The main addition to the API of the Iterator role, is the count-only method, which should return the number of values the Iterator is still able to generate.</p><p>The other addition is the bool-only method, that should return a Bool indicating whether the Iterator is still capable of producing values (aka, is not exhausted yet). By default, this is the Booleanification of the result of the call to the count-only method.</p>","defs":{"count-only":"<p>Defined as:</p><p><pre><code>method count-only(--> Int:D) { ... }</code></pre></p><p>It is expected to return the number of values the iterator can still produce without actually producing them. The returned number must adjust itself for items already pulled, so that the method can be called on a partially consumed Iterator.</p><p>It will be used in situations where only the number of values of an iterator is needed, e.g. when the .elems method is called.</p><p>Important: it's expected the Iterators that implement this method can return that number without producing any values. In other words, it's expected the user of the class will be able to still pull-one after calling this method, and eventually receive as many values as the return value of this method indicated.</p>"}},"X::Proc::Async::CharsOrBytes":{"prefix":"<p><pre><code>class X::Proc::Async::CharsOrBytes is Exception {}</code></pre></p><p>A Proc::Async object allows subscription to the output or error stream either for bytes (Blob) or for text data (Str), but not for both. If you do try both, it throws an exception of type X::Proc::Async::CharsOrBytes.</p><p><pre><code>my $proc = Proc::Async.new('echo');\n$proc.stdout.tap(&print);\n$proc.stdout(:bin).tap(&print);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::CharsOrBytes: Can only tap one of chars or bytes supply for stdout␤»</code></pre></p>","defs":{},"name":"X::Proc::Async::CharsOrBytes"},"X::Syntax::NoSelf":{"prefix":"<p><pre><code>class X::Syntax::NoSelf does X::Syntax { }</code></pre></p><p>Compile time error thrown when $.foo style calls are used where no invocant is available.</p><p>For example the code</p><p><pre><code>$.meth;\n</code></pre></p><p>in the program body throws the error</p><p><pre><code>===SORRY!===\nVariable $.meth used where no 'self' is available\n</code></pre></p><p>because $.meth is short for $(self.meth), and there is no self available in mainline.</p>","defs":{},"name":"X::Syntax::NoSelf"},"Telemetry::Period":{"prefix":"<p><pre><code>class Telemetry::Period is Telemetry { }\n</code></pre></p><p>Note:  This class is a Rakudo-specific feature and not standard Raku.</p><p><pre><code># basic usage\nuse Telemetry;\nmy $t0 = Telemetry.new;\n# execute some code\nmy $t1 = Telemetry.new;\nmy $period = $t1 - $t0;  # creates Telemetry::Period object\nsay \"Code took $period<wallclock> microseconds to execute\";\n</code></pre></p><p>A Telemetry::Period object contains the difference between two Telemetry objects. It is generally not created by calling .new, but it can be if needed. For all practical purposes, it is the same as the Telemetry object, but the meaning of the values is different (and the values are generally much smaller, as they usually are the difference of two big values of the Telemetry objects from which it was created).</p>","defs":{},"name":"Telemetry::Period"},"Date":{"defs":{"truncated-to":"<p>Defined as:</p><p><pre><code>method truncated-to(Date:D: Cool $unit)</code></pre></p><p>Returns a Date truncated to the first day of its year, month or week. For example</p><p><pre><code>my $c = Date.new('2012-12-24');\nsay $c.truncated-to('year');     # OUTPUT: «2012-01-01␤»\nsay $c.truncated-to('month');    # OUTPUT: «2012-12-01␤»\nsay $c.truncated-to('week');     # OUTPUT: «2012-12-24␤», because it's Monday already</code></pre></p>","DateTime":"<p>Defined as:</p><p><pre><code>multi method DateTime(Date:U --> DateTime:U)\nmulti method DateTime(Date:D --> DateTime:D)</code></pre></p><p>Converts the invocant to DateTime</p><p><pre><code>say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\nsay Date.DateTime;                   # OUTPUT: «(DateTime)␤»</code></pre></p>","pred":"<p>Defined as:</p><p><pre><code>method pred(Date:D: --> Date:D)</code></pre></p><p>Returns a Date of the previous day. \"pred\" is short for \"predecessor\".</p><p><pre><code>say Date.new(\"2016-01-01\").pred;   # OUTPUT: «2015-12-31␤»</code></pre></p>","Date":"<p>Defined as:</p><p><pre><code>method Date(--> Date)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say Date.new('2015-12-24').Date;  # OUTPUT: «2015-12-24␤»\nsay Date.Date;                    # OUTPUT: «(Date)␤»</code></pre></p>","succ":"<p>Defined as:</p><p><pre><code>method succ(Date:D: --> Date:D)</code></pre></p><p>Returns a Date of the following day. \"succ\" is short for \"successor\".</p><p><pre><code>say Date.new(\"2016-02-28\").succ;   # OUTPUT: «2016-02-29␤»</code></pre></p>","new-from-daycount":"<p>Defined as:</p><p><pre><code>method new-from-daycount($daycount,:&formatter --> Date:D)</code></pre></p><p>Creates a new Date object given $daycount which is the number of days from epoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a formatter as a named parameter.</p><p><pre><code>say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»</code></pre></p>","today":"<p>Defined as:</p><p><pre><code>method today(:&formatter --> Date:D)</code></pre></p><p>Returns a Date object for the current day. Optionally accepts a formatter named parameter.</p><p><pre><code>say Date.today;</code></pre></p>","later":"<p>Defined as:</p><p><pre><code>method later(Date:D: *%unit)</code></pre></p><p>Returns a Date object based on the current one, but with a date delta applied. The date delta can be passed as a named argument where the argument name is the unit.</p><p>Allowed units are day, days, week, weeks, month, months, year, years. Please note that the plural forms can only be used with the later method.</p><p>Please note that the special \":2nd\" named parameter syntax can be a compact and self-documenting way of specifying the delta</p><p><pre><code>say Date.new('2015-12-24').later(:2years);  # OUTPUT: «2017-12-24␤»</code></pre></p><p>Since addition of several different time units is not commutative, only one unit may be passed.</p><p><pre><code>my $d = Date.new('2015-02-27');\nsay $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29␤»\nsay $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01␤»\nsay $d.later(days => 2).later(:month);   # same, as +True === 1</code></pre></p><p>Negative offsets are allowed, though #method earlier is more idiomatic for that.</p>","earlier":"<p>Defined as:</p><p><pre><code>method earlier(Date:D: *%unit)</code></pre></p><p>Returns a Date object based on the current one, but with a date delta towards the past applied. See #method later for usage.</p><p><pre><code>my $d = Date.new('2015-02-27');\nsay $d.earlier(month => 5).earlier(:2days);  # OUTPUT: «2014-09-25␤»</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>multi method gist(Date:D: --> Str:D)</code></pre></p><p>Returns the date in YYYY-MM-DD format (ISO 8601)</p><p><pre><code>say Date.new('2015-12-24').gist;                    # OUTPUT: «2015-12-24␤»</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Date:D: --> Str:D)</code></pre></p><p>Returns a string representation of the invocant, as specified by the formatter. If no formatter was specified, an (ISO 8601) date will be returned.</p><p><pre><code>say Date.new('2015-12-24').Str;                     # OUTPUT: «2015-12-24␤»\n\nmy $fmt = { sprintf \"%02d/%02d/%04d\", .month, .day, .year };\nsay Date.new('2015-12-24', formatter => $fmt).Str;  # OUTPUT: «12/24/2015␤»</code></pre></p>","clone":"<p>Defined as:</p><p><pre><code>method clone(:$year, :$month, :$day, :&formatter)</code></pre></p><p>Creates a new Date object based on the invocant, but with the given arguments overriding the values from the invocant.</p><p><pre><code>say Date.new('2015-11-24').clone(month => 12);    # OUTPUT: «2015-12-24␤»</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>multi method new($year, $month, $day, :&formatter --> Date:D)\nmulti method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\nmulti method new(Str $date                        --> Date:D)\nmulti method new(Instant:D $dt                    --> Date:D)\nmulti method new(DateTime:D $dt                   --> Date:D)</code></pre></p><p>Creates a new Date object, either from a triple of (year, month, day) that can be coerced to integers, or from a string of the form YYYY-MM-DD (ISO 8601), or from an Instant or DateTime object. Optionally accepts a formatter as a named parameter.</p><p><pre><code>my $date = Date.new(2042, 1, 1);\n$date = Date.new(year => 2042, month => 1, day => 1);\n$date = Date.new(\"2042-01-01\");\n$date = Date.new(Instant.from-posix: 1482155532);\n$date = Date.new(DateTime.now);</code></pre></p>"},"prefix":"<p><pre><code>class Date { }</code></pre></p><p>A Date is an immutable object identifying a day in the Gregorian calendar.</p><p>Date objects support addition and subtraction of integers, where an integer is interpreted as the number of days. You can compare Date objects with the numeric comparison operators ==, <, <=, >, >=, != . Their stringification in YYYY-MM-DD format means that comparing them with the string operators eq, lt, le etc. also gives the right result.</p><p>Date.today creates an object the current day according to the system clock.</p><p><pre><code>my $d = Date.new(2015, 12, 24); # Christmas Eve!\nsay $d;                         # OUTPUT: «2015-12-24␤»\nsay $d.year;                    # OUTPUT: «2015␤»\nsay $d.month;                   # OUTPUT: «12␤»\nsay $d.day;                     # OUTPUT: «24␤»\nsay $d.day-of-week;             # OUTPUT: «4␤» (Thursday)\nsay $d.later(days => 20);       # OUTPUT: «2016-01-13␤»\nmy $n = Date.new('2015-12-31'); # New Year's Eve\nsay $n - $d;                    # OUTPUT: «7␤», 7 days between New Years/Christmas Eve\nsay $n + 1;                     # OUTPUT: «2016-01-01␤»</code></pre></p><p>Note since version 6.d, .perl can be called on Date.</p>","name":"Date"},"Map":{"prefix":"<p><pre><code>class Map does Associative does Iterable { }</code></pre></p><p>A Map is an immutable mapping from string keys to values of arbitrary types. It serves as a base class for Hash, which is mutable.</p><p>In list context a Map behaves as a list of Pair objects.</p><p>Note that the order in which keys, values and pairs are retrieved is generally arbitrary, but the keys, values and pairs methods return them always in the same order when called on the same object.</p><p><pre><code>my %e := Map.new('a', 1, 'b', 2);\nsay %e.keys;    # can print \"a b\\n\" or \"b a\\n\";\nsay %e.values;  # prints \"1 2\\n\" if the previous line\n                # printed \"a b\\n\", \"b a\\n\" otherwise</code></pre></p><p>To retrieve a value from the Map by key, use the { } postcircumfix operator:</p><p><pre><code>my $map = Map.new('a', 1, 'b', 2);\nsay $map{'a'};      # OUTPUT: «1␤»\nsay $map{ 'a', 'b' }; # OUTPUT: «(1 2)␤»</code></pre></p><p>To check whether a given key is stored in a Map, modify the access with the :exists adverb:</p><p><pre><code>my $map = Map.new('a', 1, 'b', 2);\nmy $key = 'a';\nif $map{$key}:exists {\n    say \"$map{} has key $key\";\n}</code></pre></p><p>Being an immutable instance, it is not possible to add keys after a Map has been initialized:</p><p><pre><code>my $m = Map.new( 'a', 1, 'b', 2 );\n$m{ 'c' } = 'foo'; # WRONG!\n                   # Cannot modify an immutable Str</code></pre></p>","defs":{"gist":"<p>Defined as:</p><p><pre><code>method gist(Map:D: --> Str:D)</code></pre></p><p>Returns the string containing the \"gist\" of the Map, sorts the pairs and lists up to the first 100, appending an ellipsis if the Map has more than 100 pairs.</p>","keys":"<p>Defined as:</p><p><pre><code>method keys(Map:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all keys in the Map.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.keys; # OUTPUT: «(a b)␤»</code></pre></p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(Map:D: Positional $topic)\nmulti method ACCEPTS(Map:D: Cool:D     $topic)\nmulti method ACCEPTS(Map:D: Regex      $topic)\nmulti method ACCEPTS(Map:D: Any        $topic)</code></pre></p><p>Used in smartmatching if the right-hand side is an Map.</p><p>If the topic is list-like (Positional), returns True if any of the list elements exist as a key in the Map.</p><p>If the topic is of type Cool (strings, integers etc.), returns True if the topic exists as a key.</p><p>If the topic is a regex, returns True if any of the keys match the regex.</p><p>As a fallback, the topic is coerced to a list, and the Positional behavior is applied.</p>","antipairs":"<p>Defined as:</p><p><pre><code>method antipairs(Map:D: --> Seq:D)</code></pre></p><p>Returns all keys and their respective values as a Seq of Pairs where the keys and values have been exchanged, i.e. the opposite of method pairs. Unlike the invert method, there is no attempt to expand list values into multiple pairs.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.antipairs;                                  # OUTPUT: «((2 3) => a 17 => b)␤»</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>method values(Map:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all values in the Map.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.values; # OUTPUT: «((2 3) 17)␤»</code></pre></p>","pairs":"<p>Defined as:</p><p><pre><code>method pairs(Map:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all pairs in the Map.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.pairs; # OUTPUT: «(a => (2 3) b => 17)␤»</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>method new(*@args)</code></pre></p><p>Creates a new Map from a list of alternating keys and values, with the same semantics as described for hash assigning in the Hash documentation, except, for literal pair handling. To ensure pairs correctly get passed, add extra parentheses around all the arguments.</p><p><pre><code>my %h = Map.new('a', 1, 'b', 2);\n\n# WRONG: :b(2) interpreted as named argument\nsay Map.new('a', 1, :b(2) ).keys; # OUTPUT: «(a)␤»\n\n# RIGHT: :b(2) interpreted as part of Map's contents\nsay Map.new( ('a', 1, :b(2)) ).keys; # OUTPUT: «(a b)␤»</code></pre></p>","Numeric":"<p>Defined as:</p><p><pre><code>method Numeric(Map:D: --> Int:D)</code></pre></p><p>Returns the number of pairs stored in the Map (same as .elems).</p><p><pre><code>my $m = Map.new('a' => 2, 'b' => 17);\nsay $m.Numeric;                                   # OUTPUT: «2␤»</code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>method kv(Map:D: --> Seq:D)</code></pre></p><p>Returns a Seq of keys and values interleaved.</p><p><pre><code>Map.new('a', 1, 'b', 2).kv  # (a 1 b 2)</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>method Int(Map:D: --> Int:D)</code></pre></p><p>Returns the number of pairs stored in the Map (same as .elems).</p><p><pre><code>my $m = Map.new('a' => 2, 'b' => 17);\nsay $m.Int;                                       # OUTPUT: «2␤»</code></pre></p>","list":"<p>Defined as:</p><p><pre><code>method list(Map:D: --> List:D)</code></pre></p><p>Returns a List of all keys and values in the Map.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.list;                                      # OUTPUT: «(b => 17 a => (2 3))␤»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(Map:D: --> Bool:D)</code></pre></p><p>Returns True if the invocant contains at least one key/value pair.</p><p><pre><code>my $m = Map.new('a' => 2, 'b' => 17);\nsay $m.Bool;                                      # OUTPUT: «True␤»</code></pre></p>","sort":"<p>Defined as:</p><p><pre><code>multi method sort(Map:D: --> Seq:D)</code></pre></p><p>Returns a Seq of Pair objects, which are the pairs of the hash, sorted by key. Equivalent to %hash.sort: *.key</p><p><pre><code># These are equivalent:\nsay Map.new(<c 3 a 1 b 2>).sort;        # OUTPUT: «(a => 1 b => 2 c => 3)␤»\nsay Map.new(<c 3 a 1 b 2>).sort: *.key; # OUTPUT: «(a => 1 b => 2 c => 3)␤»</code></pre></p><p>See Any.sort for additional available candidates.</p>","elems":"<p>Defined as:</p><p><pre><code>method elems(Map:D: --> Int:D)</code></pre></p><p>Returns the number of pairs stored in the Map.</p><p><pre><code>my %map = Map.new('a', 1, 'b', 2);\nsay %map.elems; # OUTPUT: «2␤»</code></pre></p>","invert":"<p>Defined as:</p><p><pre><code>method invert(Map:D: --> Seq:D)</code></pre></p><p>Returns all keys and their respective values as a Seq of Pairs where the keys and values have been exchanged. The difference between invert and antipairs is that invert expands list values into multiple pairs.</p><p><pre><code>my $m = Map.new('a' => (2, 3), 'b' => 17);\nsay $m.invert;                                    # OUTPUT: «(2 => a 3 => a 17 => b)␤»</code></pre></p>"},"name":"Map"},"IO::Spec":{"name":"IO::Spec","prefix":"<p><pre><code>class IO::Spec { }</code></pre></p><p>Objects of this class are not used directly but as a sub-class specific to the platform perl is running on via the $*SPEC variable which will contain an object of the appropriate type.</p><p>The sub-classes are documented separately, with the platform-specific differences documented in IO::Spec::Cygwin, IO::Spec::QNX, IO::Spec::Unix and IO::Spec::Win32.</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","defs":{}},"CompUnit::Repository::FileSystem":{"prefix":"<p><pre><code>class CompUnit::Repository::FileSystem\n    does CompUnit::Repository::Locally\n    does CompUnit::Repository\n    { }\n</code></pre></p><p>A CompUnit::Repository implementation backed by the filesystem typically used in development situations. This is what is used by -I . / -I lib (which are actually -I file#. and -I file#lib) or use lib \".\" / use lib \"lib\". Unlike CompUnit::Repository::Installation, this represents a single distribution.</p>","defs":{"need":"<p><pre><code>    method need(\n        CompUnit::DependencySpecification $spec,\n        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n        --> CompUnit:D)\n</code></pre></p><p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","resolve":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","files":"<p><pre><code>multi method files(Str:D $name, :$auth, :$ver, :$api)\nmulti method files(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that match the specified auth ver and api, and contains a non-module file matching the specified $name.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\nsay $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\nsay $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\nsay $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\nsay $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»</code></pre></p>","candidates":"<p><pre><code>multi method candidates(Str:D $name, :$auth, :$ver, :$api)\nmulti method candidates(CompUnit::DependencySpecification $spec)</code></pre></p><p>Return all distributions that contain a module matching the specified $name, auth, ver, and api.</p><p><pre><code># assuming one is cloned into the zef git repository...\nmy $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\nwith $repo.candidates(\"Zef\").head -> $dist {\n    say \"Zef version: \" ~ $dist.meta<version>;\n}\nelse {\n    say \"No candidates for 'Zef' found\";\n}</code></pre></p>","loaded":"<p><pre><code>method loaded(--> Iterable:D)</code></pre></p><p>Returns all CompUnits this repository has loaded.</p>","load":"<p><pre><code>method load(IO::Path:D $file --> CompUnit:D)</code></pre></p><p>Load the $file and return a CompUnit object representing it.</p>"},"name":"CompUnit::Repository::FileSystem"},"X::Bind::Slice":{"prefix":"<p><pre><code>class X::Bind::Slice is Exception {}</code></pre></p><p>When you try to bind to an array or hash slice:</p><p><pre><code>my @a; @a[0, 1] := [42];\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Bind::Slice: Cannot bind to Array slice␤»</code></pre></p><p>and</p><p><pre><code>my %h; %h<a b> := {};\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Bind::Slice: Cannot bind to Hash slice␤»</code></pre></p><p>you get an exception of type ::Bind::Slice</p>","defs":{},"name":"X::Bind::Slice"},"Iterator":{"name":"Iterator","prefix":"<p><pre><code>constant IterationEnd\nrole Iterator { }\n</code></pre></p><p>A Iterator is an object that can generate or provide elements of a sequence. Users usually don't have to care about iterators, their usage is hidden behind iteration APIs such as for @list { }, map, grep, head, tail, skip and list indexing with .[$idx].</p><p>The main API is the pull-one method, which either returns the next value, or the sentinel value IterationEnd if no more elements are available. Each class implementing Iterator must provide a pull-one method. All other non-optional Iterator API methods are implemented in terms of pull-one, but can also be overridden by consuming classes for performance or other reasons. There are also optional Iterator API methods that will only be called if they are implemented by the consuming class: these are not implemented by the Iterator role.</p><p></p>","defs":{"pull-one":"<p>Defined as:</p><p><pre><code>method pull-one(Iterator:D: --> Mu)</code></pre></p><p>This method stub ensures that classes implementing the Iterator role provide a method named pull-one.</p><p>The pull-one method is supposed to produce and return the next value if possible, or return the sentinel value IterationEnd if no more values could be produced.</p><p><pre><code>my $i = (1 .. 3).iterator;\nsay $i.pull-one;       # OUTPUT: «1␤»\nsay $i.pull-one;       # OUTPUT: «2␤»\nsay $i.pull-one;       # OUTPUT: «3␤»\nsay $i.pull-one.perl;  # OUTPUT: «IterationEnd␤»</code></pre></p><p>As a more illustrative example of its use, here is a count down iterator along with a simplistic subroutine re-implementation of the for loop.</p><p><pre><code># works the same as (10 ... 1, 'lift off')\nclass CountDown does Iterator {\n    has Int:D $!current = 10;\n\n    method pull-one ( --> Mu ) {\n        my $result = $!current--;\n        if $result ==  0 { return 'lift off' }\n        if $result == -1 { return IterationEnd }\n\n        # calling .pull-one again after it returns IterationEnd is undefined\n        if $result <= -2 {\n            # so for fun we will give them nonsense data\n            return (1..10).pick;\n        }\n\n        return $result;\n    }\n}\n\nsub for( Iterable:D $sequence, &do --> Nil ) {\n    my Iterator:D $iterator = $sequence.iterator;\n\n    loop {\n        # must bind the result so that =:= works\n        my Mu $pulled := $iterator.pull-one;\n\n        # always check the result and make sure that .pull-one\n        # is not called again after it returns IterationEnd\n        if $pulled =:= IterationEnd { last }\n\n        do( $pulled );\n    }\n}\n\nfor( Seq.new(CountDown.new), &say );  # OUTPUT: «10␤9␤8␤7␤6␤5␤4␤3␤2␤1␤lift off␤»</code></pre></p><p>It would be more idiomatic to use while or until, and a sigilless variable.</p><p><pre><code>until IterationEnd =:= (my \\pulled = $iterator.pull-one) {\n    do( pulled );\n}\n</code></pre></p>","skip-at-least-pull-one":"<p>Defined as:</p><p><pre><code>method skip-at-least-pull-one(Iterator:D: $target, int $to-skip --> Mu)</code></pre></p><p>Should skip producing $to-skip values and if the iterator is still not exhausted, produce and return the next value. Should return IterationEnd if the iterator got exhausted at any point:</p><p><pre><code>my $i = <a b c>.iterator;\nsay $i.skip-at-least-pull-one(2);\nsay $i.skip-at-least-pull-one(20) =:= IterationEnd;\n# OUTPUT: «c␤True␤»</code></pre></p><p>The Iterator role implements this method as calling skip-at-least and then calling pull-one if it was not exhausted yet.</p>","push-exactly":"<p>Defined as:</p><p><pre><code>method push-exactly(Iterator:D: $target, int $count --> Mu)</code></pre></p><p>Should produce $count elements, and for each of them, call $target.push($value).</p><p>If fewer than $count elements are available from the iterator, it should return the sentinel value IterationEnd. Otherwise it should return $count.</p><p><pre><code>my @array;\nsay (1 .. ∞).iterator.push-exactly(@array, 3); # OUTPUT: «3␤»\nsay @array; # OUTPUT: «[1 2 3]␤»</code></pre></p><p>The Iterator role implements this method in terms of pull-one. In general, this is a method that is not intended to be called directly from the end user who, instead, should implement it in classes that mix the iterator role. For instance, this class implements that role:</p><p><pre><code>class DNA does Iterable does Iterator {\n    has $.chain;\n    has Int $!index = 0;\n\n    method new ($chain where {\n                       $chain ~~ /^^ <[ACGT]>+ $$ / and\n                       $chain.chars %% 3 } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator( ){ self }\n\n    method pull-one( --> Mu){\n      if $!index < $.chain.chars {\n         my $codon = $.chain.comb.rotor(3)[$!index div 3];\n         $!index += 3;\n         return $codon;\n      } else {\n        return IterationEnd;\n      }\n    }\n\n    method push-exactly(Iterator:D: $target, int $count --> Mu) {\n        return IterationEnd if $.chain.elems / 3 < $count;\n        for ^($count) {\n            $target.push: $.chain.comb.rotor(3)[ $_ ];\n        }\n    }\n\n};\n\nmy $b := DNA.new(\"AAGCCT\");\nfor $b -> $a, $b, $c { say \"Never mind\" }; # Does not enter the loop\nmy $þor := DNA.new(\"CAGCGGAAGCCT\");\nfor $þor -> $first, $second {\n    say \"Coupled codons: $first, $second\";\n    # OUTPUT: «Coupled codons: C A G, C G G␤Coupled codons: A A G, C C T␤»\n}\n</code></pre></p><p>This code, which groups DNA chains in triplets (usually called codons) returns those codons when requested in a loop; if too many are requested, like in the first case for $b -> $a, $b, $c, it simply does not enter the loop since push-exactly will return IterationEnd since it is not able to serve the request for exactly 3 codons. In the second case, however, it requests exactly two codons in each iteration of the loop; push-exactly is being called with the number of loop variables as the $count variable.</p>","is-lazy":"<p>Defined as:</p><p><pre><code>method is-lazy(Iterator:D: --> Bool:D)</code></pre></p><p>Should return True for iterators that consider themselves lazy, and False otherwise.</p><p>Built-in operations that know that they can produce infinitely many values return True here, for example (1..6).roll(*).</p><p><pre><code>say (1 .. 100).is-lazy; # OUTPUT: «False␤»\nsay (1 .. ∞).is-lazy; # OUTPUT: «True␤»</code></pre></p><p>The Iterator role implements this method returning False, indicating a non-lazy iterator.</p>","sink-all":"<p>Defined as:</p><p><pre><code>method sink-all(Iterator:D: --> IterationEnd)</code></pre></p><p>Should exhaust the iterator purely for the side-effects of producing the values, without actually saving them in any way. Should always return IterationEnd. If there are no side-effects associated with producing a value, then it can be implemented by a consuming class to be a virtual no-op.</p><p><pre><code>say (1 .. 1000).iterator.sink-all;  # OUTPUT: «IterationEnd␤»</code></pre></p><p>The Iterator role implements this method as a loop that calls pull-one until it is exhausted.</p>","push-until-lazy":"<p>Defined as:</p><p><pre><code>method push-until-lazy(Iterator:D: $target --> Mu)</code></pre></p><p>Should produce values until it considers itself to be lazy, and push them onto $target.</p><p>The Iterator role implements this method as a no-op if is-lazy returns a True value, or as a synonym of push-all if not.</p><p>This matters mostly for iterators that have other iterators embedded, some of which might be lazy, while others aren't.</p>","push-all":"<p>Defined as:</p><p><pre><code>method push-all(Iterator:D: $target)</code></pre></p><p>Should produce all elements from the iterator and push them to $target.</p><p><pre><code>my @array;\nsay (1 .. 1000).iterator.push-all(@array); # All 1000 values are pushed</code></pre></p><p>The Iterator role implements this method in terms of push-at-least. As in the case of the other push-* methods, it is mainly intended for developers implementing this role. push-all is called when assigning an object with this role to an array, for instance, like in this example:</p><p><pre><code>class DNA does Iterable does Iterator {\n    has $.chain;\n    has Int $!index = 0;\n\n    method new ($chain where {\n                       $chain ~~ /^^ <[ACGT]>+ $$ / and\n                       $chain.chars %% 3 } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator( ){ self }\n    method pull-one( --> Mu){\n      if $!index < $.chain.chars {\n         my $codon = $.chain.comb.rotor(3)[$!index div 3];\n         $!index += 3;\n         return $codon;\n      } else {\n        return IterationEnd;\n      }\n    }\n\n    method push-all(Iterator:D: $target) {\n        for $.chain.comb.rotor(3) -> $codon {\n            $target.push: $codon;\n        }\n    }\n\n};\n\nmy $b := DNA.new(\"AAGCCT\");\nmy @dna-array = $b;\nsay @dna-array; # OUTPUT: «[(A A G) (C C T)]␤»\n</code></pre></p><p>The push-all method implemented pushes to the target iterator in lists of three aminoacid representations; this is called under the covers when we assign $b to @dna-array.</p>","skip-at-least":"<p>Defined as:</p><p><pre><code>method skip-at-least(Iterator:D: $target, int $to-skip --> Mu)</code></pre></p><p>Should skip producing $to-skip values. The return value should be truthy if the skip was successful and falsy if there were not enough values to be skipped:</p><p><pre><code>my $i = <a b c>.iterator;\nsay $i.skip-at-least(2); say $i.pull-one; say $i.skip-at-least(20);\n# OUTPUT: «1␤c␤0␤»</code></pre></p><p>The Iterator role implements this method as a loop calling skip-one and returning whether it returned a truthy value sufficient number of times.</p>","skip-one":"<p>Defined as:</p><p><pre><code>method skip-one(Iterator:D: $target --> Mu)</code></pre></p><p>Should skip producing one value. The return value should be truthy if the skip was successful and falsy if there were no values to be skipped:</p><p><pre><code>my $i = <a b>.iterator;\nsay $i.skip-one; say $i.pull-one; say $i.skip-one\n# OUTPUT: «1␤b␤0␤»</code></pre></p><p>The Iterator role implements this method as a call pull-one and returning whether the value obtained was not IterationEnd.</p>","push-at-least":"<p>Defined as:</p><p><pre><code>method push-at-least(Iterator:D: $target, int $count --> Mu)</code></pre></p><p>Should produce at least $count elements, and for each of them, call $target.push($value).</p><p>If fewer than $count elements are available from the iterator, it should return the sentinel value IterationEnd. Otherwise it should return $count.</p><p>Iterators with side effects should produce exactly $count elements; iterators without side effects (such as Range iterators) can produce more elements to achieve better performance.</p><p><pre><code>my @array;\nsay (1 .. ∞).iterator.push-at-least(@array, 10); # OUTPUT: «10␤»\nsay @array; # OUTPUT: «[1 2 3 4 5 6 7 8 9 10]␤»</code></pre></p><p>The Iterator role implements this method in terms of pull-one. In general, it is also not intended to be called directly as in the example above. It can be implemented, if unhappy with this default implementation, by those using this role. See the documentation for push-exactly for an example implementation.</p>"}},"Uni":{"prefix":"<p><pre><code>class Uni does Positional[uint32] does Stringy { }</code></pre></p><p>Unlike Str, which is made of Grapheme clusters, Uni is string strictly made of Unicode codepoints. That is, base characters and combining characters are separate elements of a Uni instance.</p><p>Uni presents itself with a list-like interface of integer Codepoints.</p><p>Typical usage of Uni is through one of its subclasses, NFC, NFD, NFKD and NFKC, which represent strings in one of the Unicode Normalization Forms of the same name.</p>","defs":{"codes":"<p><pre><code>method codes(Uni:D: --> Int:D)</code></pre></p><p>Returns the number of codepoints in the invocant.</p>","NFC":"<p><pre><code>method NFC(Uni:D: --> NFC:D)</code></pre></p><p>Returns a NFC (Normal Form Composed)-converted version of the invocant.</p>","NFKD":"<p><pre><code>method NFKD(Uni:D: --> NFKD:D)</code></pre></p><p>Returns a NFKD (Normal Form Compatibility Decomposed)-converted version of the invocant.</p>","NFKC":"<p><pre><code>method NFKC(Uni:D: --> NFKC:D)</code></pre></p><p>Returns a NFKC (Normal Form Compatibility Composed)-converted version of the invocant.</p>","new":"<p><pre><code>method new(*@codes --> Uni:D)</code></pre></p><p>Creates a new Uni instance from the given codepoint numbers.</p>","NFD":"<p><pre><code>method NFD(Uni:D: --> NFD:D)</code></pre></p><p>Returns a NFD (Normal Form Decomposed)-converted version of the invocant.</p>"},"name":"Uni"},"AST":{"defs":{},"prefix":"<p><pre><code>class AST { }</code></pre></p><p>An AST or Abstract Syntax Tree is a partially processed representation of a program. ASTs are return values of the quasi quoting construct, and are typically used within macros to generate code that is inserted in the calling location of the macro.</p><p>There is no API defined for ASTs yet. Hopefully that will emerge as part of the work on macros.</p>","name":"AST"},"CompUnit::PrecompilationRepository":{"defs":{"load-unit":"<p><pre><code>method load-unit(CompUnit::PrecompilationId $compiler-id,\n            CompUnit::PrecompilationId $precomp-id)\n{ ... }</code></pre></p><p>Load the precompilation identified by the pairing of the specified compiler and precompilation ID.</p>","store-file":"<p><pre><code>method store-file(CompUnit::PrecompilationId $compiler-id,\n             CompUnit::PrecompilationId $precomp-id,\n             IO::Path:D $path,\n             :$extension = '')\n{ ... }</code></pre></p><p>Store the file at the specified path in the precompilation store, under the given compiler ID and precompilation ID.</p>","store-repo-id":"<p><pre><code>method store-repo-id(CompUnit::PrecompilationId $compiler-id,\n             CompUnit::PrecompilationId $precomp-id,\n             :$repo-id!)\n{ ... }</code></pre></p><p>Store the given repo-id for a precompilation under the given compiler ID and precompilation ID.</p>","delete":"<p><pre><code>method delete(CompUnit::PrecompilationId $compiler-id,\n              CompUnit::PrecompilationId $precomp-id)\n{ ... }</code></pre></p><p>Delete an individual precompilation.</p>","new-unit":"<p><pre><code>method new-unit(| --> CompUnit::PrecompilationUnit:D)\n{ ... }</code></pre></p><p>Prepare a new implementation specific PrecompilationUnit for storage</p>","store-unit":"<p><pre><code>method store-unit(CompUnit::PrecompilationId $compiler-id,\n             CompUnit::PrecompilationId $precomp-id,\n             CompUnit::PrecompilationUnit $unit)\n{ ... }</code></pre></p><p>Store the given precompilation unit in the precompilation store under the given compiler ID and precompilation ID.</p>","load-repo-id":"<p><pre><code>method load-repo-id(CompUnit::PrecompilationId $compiler-id,\n            CompUnit::PrecompilationId $precomp-id)\n{ ... }</code></pre></p><p>Return the repository id for which the specified precomp file's dependencies have been validated</p>"},"prefix":"<p>This class provides stubs for each of the following methods. The methods are provided by sub-classes, such as PrecompilationRepository::File. Sub-classes are implementation dependent.</p>","name":"CompUnit::PrecompilationRepository"},"Pod::Heading":{"name":"Pod::Heading","prefix":"<p><pre><code>class Pod::Heading is Pod::Block { }</code></pre></p><p>Class for headings in a Pod document.</p>","defs":{}},"X::Temporal::InvalidFormat":{"defs":{"invalid-str":"<p>Returns the invalid format string (12/25/2015 in the example above)</p>","target":"<p>Returns the target type (Date in the example above)</p>"},"prefix":"<p><pre><code>class X::Temporal::InvalidFormat does X::Temporal is Exception { }\n</code></pre></p><p>This exception is thrown when code tries to create a DateTime or Date object using an invalid format.</p><p><pre><code>my $dt = Date.new(\"12/25/2015\");\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Temporal::InvalidFormat: Invalid Date string '12/25/2015'; use yyyy-mm-dd instead␤»\n</code></pre></p>","name":"X::Temporal::InvalidFormat"},"X::Temporal":{"defs":{},"prefix":"<p><pre><code>role X::Temporal is Exception { }</code></pre></p><p>A common exception type for all errors related to DateTime or Date.</p>","name":"X::Temporal"},"CallFrame":{"defs":{"annotations":"<p><pre><code>method annotations()</code></pre></p><p>Returns a Map containing the invocants annotations, i.e. line and file. An easier way to get hold of the annotation information is to use one of the convenience methods instead.</p><p><pre><code>say callframe.annotations.^name;                   # OUTPUT: «Map␤»\nsay callframe.annotations<file> eq callframe.file; # OUTPUT: «True␤»</code></pre></p>","code":"<p><pre><code>method code()</code></pre></p><p>Return the callable code for the current block. When called on the object returned by callframe(0), this will be the same value found in &?BLOCK.</p><p><pre><code>my $frame;\nfor ^3 { FIRST $frame = callframe; say $_ * 3 };\nsay $frame.code()\n</code></pre></p><p>The $frame variable will hold the Code for the block inside the loop in this case.</p>","line":"<p><pre><code>method line()</code></pre></p><p>This is a shortcut for looking up the line annotation. For example, the following two calls are identical.</p><p><pre><code>say callframe(1).line;\nsay callframe(1).annotations<line>;</code></pre></p>","my":"<p><pre><code>method my()</code></pre></p><p>Return a Hash that names all the variables and their values associated with the lexical scope of the frame.</p><p><pre><code>sub some-value {\n    my $the-answer = 42;\n    callframe(0);\n}\n\nmy $frame = some-value();\nsay $frame.my<$the-answer>; # OUTPUT: «42␤»</code></pre></p>","file":"<p><pre><code>method file()</code></pre></p><p>This is a shortcut for looking up the file annotation. Therefore, the following code prints True.</p><p><pre><code>my $frame = callframe(0);\nsay $frame.file eq $frame.annotations<file>;</code></pre></p>"},"prefix":"<p><pre><code>class CallFrame {}</code></pre></p><p>A CallFrame will be usually captured from the current state of a program using the callframe subroutine.</p><p><pre><code>my $frame = callframe;\nsay \"The above line of code ran at {$frame.file}:{$frame.line}.\";</code></pre></p><p>With no arguments the callframe will give you frame information for the line calling callframe. The file and line annotations will be identical to those in $?FILE and $?LINE.</p><p>You may, however, pass a number to callframe to specify a different frame level. A positive number will move upward through the levels of frame. A negative number will move downward into the callframe method and class itself at the point at which they are running to construct this information for you.</p><p>The frames themselves do not necessarily match only method or subroutine calls. Perl constructs a frames for blocks and such as well, so if you need a callframe for a particular method call, do not assume it is a fixed number of levels up.</p><p>Each frame stores annotations, including the file and line annotations, which have convenience methods for accessing them directly. You can also retrieve a reference to the code block of the currently executing frame using the code method. The frame also captures all lexical variables stored with the frame, which are available by calling my on the frame object.</p><p>Here's a short example that will find the calling routine and print the package of the caller using the callframe interface.</p><p><pre><code>sub calling-frame() {\n    for 1..* -> $level {\n        given callframe($level) -> $frame {\n            when $frame ~~ CallFrame {\n                    next unless $frame.code ~~ Routine;\n                    say $frame.code.package;\n                    last;\n            }\n            default {\n                    say \"no calling routine or method found\";\n                    last;\n            }\n        }\n    }\n}\n\ncalling-frame;</code></pre></p><p>If you just need to trace caller information, Backtrace may provide a better means of getting it. CallFrame contains more information about a specific frame, but provides a tedious interface for enumerating a call stack.</p>","name":"CallFrame"},"X::OS":{"defs":{},"prefix":"<p><pre><code>role X::OS { has $.os-error }</code></pre></p><p>Common role for all exceptions that are triggered by some error reported by the operating system (failed IO, system calls, fork, memory allocation).</p>","name":"X::OS"},"X::Syntax::Perl5Var":{"prefix":"<p><pre><code>class X::Syntax::Perl5Var does X::Syntax { }</code></pre></p><p>Syntax error thrown when some piece of code tries to use one of the old Perl 5 variables (and it does not error for some other reason).</p><p><pre><code>say $];\n</code></pre></p><p>dies with</p><p><pre><code>Unsupported use of $] variable; in Raku please use $*PERL.version or $*PERL.compiler.version\n</code></pre></p><p>For every unsupported variable (which include most $^'letter' constructs, as well as others like $\", the error message will mention that the variable is unsupported and the equivalent commands you could use.</p>","defs":{},"name":"X::Syntax::Perl5Var"},"RatStr":{"prefix":"<p><pre><code>class RatStr is Rat is Str {}</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = <42.1>; say $f.^name; # OUTPUT: «RatStr␤»</code></pre></p><p>As a subclass of both Rat and Str, a RatStr will be accepted where either is expected. However, RatStr does not share object identity with Rat- or Str-only variants:</p><p><pre><code>my $rat-str = <42.1>;\nmy Rat $rat = $rat-str; # OK!\nmy Str $str = $rat-str; # OK!\nsay 42.1 ∈ <42.1  55  1>; # False; ∈ operator cares about object identity</code></pre></p>","defs":{"Rat":"<p><pre><code>method Rat</code></pre></p><p>Returns the Rat value of the RatStr.</p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(Real:D: --> Rat:D)\nmulti method Real(Real:U: --> Rat:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0.0.</p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(RatStr:D --> Capture:D)</code></pre></p><p>Equivalent to Mu.Capture.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(RatStr:D: --> Bool:D)</code></pre></p><p>This method may be provided by the parent classes and not implemented in RatStr directly.</p><p>Returns False if the numerator of the numeric portion is 0, otherwise returns True. This applies for < 0/0 > zero-denominator RatStr as well, despite ?< 0/0 >.Num being True. String portion is not considered.</p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(RatStr:D: Any:D $value)</code></pre></p><p>If $value is Numeric (including another allomorph), checks if invocant's Numeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str part ACCEPTS the $value. If value is anything else, checks if both Numeric and Str parts ACCEPTS the $value.</p><p><pre><code>say <5.0> ~~ \"5\"; # OUTPUT: «False␤»\nsay <5.0> ~~  5 ; # OUTPUT: «True␤»\nsay <5.0> ~~ <5>; # OUTPUT: «True␤»</code></pre></p>","Str":"<p>Returns the string value of the RatStr.</p>","Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(RatStr:D: --> Rat:D)\nmulti method Numeric(RatStr:U: --> Rat:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0.0.</p>","new":"<p><pre><code>method new(Rat $i, Str $s)</code></pre></p><p>The constructor requires both the Rat and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = RatStr.new(42.1, \"forty two and a bit\");\nsay +$f; # OUTPUT: «42.1␤»\nsay ~$f; # OUTPUT: «\"forty two and a bit\"␤»</code></pre></p>"},"name":"RatStr"},"Distribution::Path":{"prefix":"<p><pre><code>    class Distribution::Path does Distribution::Locally { }\n</code></pre></p><p>A Distribution implementation backed by the filesystem. It requires a META6.json file at its root.</p>","defs":{"meta":"<p><pre><code>method meta()</code></pre></p><p>Returns a Hash with the representation of the metadata.</p>","new":"<p><pre><code>method new(IO::Path $prefix, IO::Path :$meta-file = IO::Path)</code></pre></p><p>Creates a new Distribution::Path instance from the META6.json file found at the given $prefix, and from which all paths in the metadata will be prefixed with. :$meta-file may optionally be passed if a filename other than META6.json needs to be used.</p>"},"name":"Distribution::Path"},"Match":{"defs":{"ast":"<p>Alias for #method made.</p>","postmatch":"<p>Defined as:</p><p><pre><code>method postmatch(Match:D: --> Str:D)</code></pre></p><p>Returns the part of the original string following the match.</p><p><pre><code>'abcdefg' ~~ /cd/;\nsay $/.postmatch;         # OUTPUT: «efg␤»\n\n# will return a list of three match objects\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.[1].postmatch;     # OUTPUT: «3def␤»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>method Bool(Capture:D: --> Bool:D)</code></pre></p><p>Returns True on successful and False on unsuccessful matches. Please note that any zero-width match can also be successful.</p><p><pre><code>say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\nsay $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»</code></pre></p>","orig":"<p>Returns the original input to the regex engine, which is usually a string, but doesn't need to be (could be anything that can be coerced to a string):</p><p><pre><code>42 ~~ /.+/;\nsay $/.orig;            # OUTPUT: «42»\nsay $/.orig.^name;      # OUTPUT: «Int»</code></pre></p><p>See #method target for a close equivalent that always returns a string.</p>","chars":"<p>Returns the numbers of characters in the matched string.</p><p>Returns the same as .Str.chars.</p>","Int":"<p>Defined as:</p><p><pre><code>method Int(Match:D: --> Int:D)</code></pre></p><p>Tries to convert stringified result of the matched text into Int.</p><p><pre><code>say ('12345' ~~ /234/).Int;       # OUTPUT: «234␤»\nsay ('12345' ~~ /234/).Int.^name; # OUTPUT: «Int␤»\n# the next line produces a warning about using Nil (result of a no match) in numeric context\nsay ('one-two' ~~ /234/).Int;     # OUTPUT: «0␤» # because Nil.Int returns 0</code></pre></p>","list":"<p>Returns a list of positional submatches.</p>","made":"<p>Returns the payload that was set with make.</p>","hash":"<p>Returns a hash of named submatches.</p>","prematch":"<p>Defined as:</p><p><pre><code>method prematch(Match:D: --> Str:D)</code></pre></p><p>Returns the part of the original string leading up to the match.</p><p><pre><code>'abcdefg' ~~ /cd/;\nsay $/.prematch;          # OUTPUT: «ab␤»\n\n# will return a list of three match objects\n\"abc123def\" ~~ m:g/\\d/;\nsay $/.[1].prematch;      # OUTPUT: «abc1␤»</code></pre></p>","caps":"<p>Returns a list of pairs, with the index or submatch name as key and the submatches as values. The list is ordered by starting position of the submatches.</p>","clone":"<p>Defined as:</p><p><pre><code>method clone()</code></pre></p><p>Clones the Match object.</p>","actions":"<p><pre><code>method actions(Match:D: --> Mu)</code></pre></p><p>Returns the actions object (if any was set; else Mu) that the grammar used from which this Match object was created.</p>","from":"<p>Returns the index of the starting position of the match.</p>","to":"<p>Returns the index of the end position of the match.</p>","Str":"<p>Defined as:</p><p><pre><code>method Str(Match:D: --> Str:D)</code></pre></p><p>Returns the matched text.</p><p><pre><code>\"abc123def\" ~~ /\\d+/;\nsay $/.Str;               # OUTPUT: «123␤»</code></pre></p>","pos":"<p><pre><code>method pos()</code></pre></p><p>Returns the current position as a string index into Match.target for a regex match in progress:</p><p><pre><code>my $a = 'abcdef';\n$a ~~ /b. {say $/.pos }../; say $/.pos;     # OUTPUT: «3␤»</code></pre></p><p>You should not use this method on finished Match, as the output can be implementation specific.</p>","chunks":"<p>Returns a list of pairs, with the index or submatch name as key and the submatches as values. The list is ordered by starting position of the submatches.</p><p>Those parts of the string that were not matched by submatches are interleaved with the other pairs, with the string ~ as key.</p>","target":"<p><pre><code>method target()</code></pre></p><p>Returns a string representation of the object against which the regex matches. This is the value that the regex engine works with internally.</p><p><pre><code>my $a = \"þor\" ~~ /o/;\nsay $a.target # OUTPUT: «þor␤»</code></pre></p>","make":"<p>Defined as</p><p><pre><code>method make(Match:D: Mu $payload)\nsub make(Mu $payload)</code></pre></p><p>Sets the .ast attribute, which will be retrieved using .made.</p><p><pre><code>$/.make(\"your payload here\");</code></pre></p><p>That is, it stores an arbitrary payload into the Match object that can later be retrieved via .made method.</p><p>This is typically used in a grammar's actions class methods, where a piece of data is stored by one method and then later retrieved by another. It's up to you what data you store. It could be a tree node, result of a calculation, or a list of values.</p><p>The sub form operates on the current Match $/, which can be a convenient shortcut:</p><p><pre><code>method my-action ($/) {\n    make \"foo: $/\";\n}</code></pre></p>"},"prefix":"<p><pre><code>class Match is Capture is Cool does NQPMatchRole {}</code></pre></p><p>Match objects are the result of a successful regex match, this does include any zero-width match. They store a reference to the original string (.orig), positional and named captures, the positions of the start and end of the match in the original string, and a payload referred to as AST (abstract syntax tree), which can be used to build data structures from complex regexes and grammars.</p><p>The last match is also stored in the $¢ Match object, which is lexically scoped to the regex, that is, only available from within the regular expression, as shown here:</p><p><pre><code>my $c;\n'abc' ~~ /.$${ $c = $¢ }/;\nsay $c; # OUTPUT: «｢c｣␤»</code></pre></p><p>In this case, we are running the code among curly braces when the match occurs, in this case the last letter in the string (actually, the last, indicated by the double $, character); $c gets the value of the cursor $¢, which contains the Match; when used with say, the Match is stringified by calling .Str on it. This $¢ offers a way of capturing the Match inside a regular expression; outside, you need to use $/</p><p><pre><code>my $c; 'camelia' ~~ /<[ l m ]> {$c = $¢}/;\nsay $c; # OUTPUT: «｢m｣␤»\nsay $/; # OUTPUT: «｢m｣␤»</code></pre></p><p>Note: This feature works only from Raku version 2018.02. It would have returned Nil with any previous version. Alternatively and prior to that version, you could use $/ which, inside the regex, has the same value:</p><p><pre><code>'123' ~~ / (\\d) { say $0; say $/; } \\d+ /; # OUTPUT: «｢1｣␤｢1｣␤ 0 => ｢1｣␤»</code></pre></p><p>The main difference between $/ and $¢ is scope: the latter only has a value inside the regex:</p><p><pre><code>'123' ~~ / (\\d) { say $/; say $¢; } \\d+ /; # OUTPUT: «｢1｣␤ 0 => ｢1｣␤｢1｣␤ 0 => ｢1｣␤»\nsay \"¢ → \", $¢, \"/ is $/\"; ; # OUTPUT: «¢ → Nil/ is 123␤»\n</code></pre></p><p>Submatches are also Match objects (or lists of Match objects, if the corresponding regex was quantified), so each match object can be seen as the root of a tree of match objects.</p><p>A Match object can also hold the result of a match in progress (while the grammar engine is running), in which case the pos method returns the current position. This view on Match objects is only visible if you call code from within a regex.</p><p>Note (deprecated): There is a synonym for this class, Cursor, defined as:</p><p><pre><code>my constant Cursor = Match</code></pre></p><p>Initially, it was used to keep track of initial position in regex matches. In current versions, it's an alias for Match.</p>","name":"Match"},"X::Parameter::Default":{"name":"X::Parameter::Default","defs":{"how":"<p>Returns a string describing how the parameter is qualified that makes it disallow default values, for example \"slurpy\" or \"mandatory\".</p>"},"prefix":"<p><pre><code>class X::Parameter::Default does X::Comp { }</code></pre></p><p>Compile-time error thrown when a parameter in a signature has default value, but isn't allowed to have one. That is the case with slurpy parameters (because a slurpy always binds successfully, even to zero arguments) and with mandatory parameters.</p><p>Example:</p><p><pre><code>sub f($x! = 3) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put default on required parameter $x\n</code></pre></p><p>And</p><p><pre><code>sub f(*@ = 3) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot put default on anonymous slurpy parameter\n</code></pre></p>"},"Enumeration":{"prefix":"<p><pre><code>role Enumeration { }</code></pre></p><p>This is the role implemented by the enum-pairs in the enum type. In general, it is used to create constant sets, the elements of which become also constant symbols in the current namespace and to establish a relationship between the symbols belonging to the same set. In general, you will find Enumeration in enum types:</p><p><pre><code>enum norse-gods <Þor Oðin Loki>;\nmy $one-of-them = norse-gods.pick;\nsay $one-of-them ~~ Enumeration; # OUTPUT: «True␤»</code></pre></p><p>but nothing prevents you from using it in your own programs if you want to restrict somehow the relationship between the key and the value:</p><p><pre><code>class DNA does Enumeration {\n    my %pairings = %( A => \"T\",\n                      T => \"A\",\n                      C => \"G\",\n                      G => \"C\" );\n\n    method new( $base-pair where \"A\" | \"C\" | \"G\" | \"T\" )  {\n        self.bless( key => $base-pair,\n                    value => %pairings{$base-pair});\n    }\n\n    multi method gist(::?CLASS:D:) {\n        return \"$!key → $!value\";\n    }\n\n}\n\nenum Chain ();\nconstant length = 16;\nfor <A C G T>.roll( length ) -> $letter {\n    my DNA $base = DNA.new( $letter );\n    Chain.HOW.add_enum_value( Chain, $base );\n}\n\nfor ^length {\n    my $base = Chain.pick;\n    say \"{$base.key} and {$base.value}\";\n}\n</code></pre></p><p>In this code, DNA consumes the Enumeration role, which is from this point of view a pair of key and value; we can use the generated DNA objects to compose an enum type from which elements can be picked one by one, with the output shown below.</p><p><pre><code>T and A\nC and G\nT and A\n# and so on...\n</code></pre></p>","defs":{"key":"<p>An Enumeration property.</p><p><pre><code>enum Norse-gods <Þor Oðin Freija>;\nsay Freija.key; # OUTPUT: «Freija␤»</code></pre></p>","value":"<p>These are Enumeration properties.</p><p><pre><code>enum Norse-gods <Þor Oðin Freija>;\nsay Oðin.value; # OUTPUT: «1␤»</code></pre></p><p>The value is assigned automatically by the enum type starting at 0. Oðin gets 1 since it is the second in the enum.</p>","pair":"<p>Defined as:</p><p><pre><code>method pair(::?CLASS:D:)</code></pre></p><p>Returns it as a Pair.</p><p><pre><code>say g.pair; # OUTPUT: «g => 1␤»\n</code></pre></p>","Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(::?CLASS:D:)</code></pre></p><p>Takes a value of an enum and returns it after coercion to Numeric:</p><p><pre><code>enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\nsay cool.Numeric;       # OUTPUT: «42␤»\nsay almost-pi.Numeric;  # OUTPUT: «3.14␤»\nsay sqrt-n-one.Numeric; # OUTPUT: «0+1i␤»</code></pre></p><p>Note that if the value cannot be coerced to Numeric, an exception will be thrown.</p>","enums":"<p>Defined as:</p><p><pre><code>method enums()</code></pre></p><p>Returns a Map of enum values. Works both on the enum type and any key.</p><p><pre><code>enum Mass ( mg => 1/1000, g => 1/1, kg => 1000/1 );\nsay Mass.enums; # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»\nsay g.enums;    # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»</code></pre></p>","CALL-ME":"<p>Defined as:</p><p><pre><code>multi method CALL-ME(|)</code></pre></p><p>Returns an Enumeration instance given an enum value.</p><p><pre><code>enum Mass ( mg => 1/1000, g => 1/1, kg => 1000/1 );\nsay Mass(1/1000); # OUTPUT: mg</code></pre></p>","roll":"<p>Defined as:</p><p><pre><code>multi method roll(::?CLASS:U:)\nmulti method roll(::?CLASS:U: \\n)\nmulti method roll(::?CLASS:D: *@pos)</code></pre></p><p>They work on the defined class selecting one or n elements without eliminating them.</p><p><pre><code>say Norse-gods.roll() for ^3;  # OUTPUT: «Freija␤Freija␤Oðin␤»\n</code></pre></p>","kv":"<p>Defined as:</p><p><pre><code>multi method kv(::?CLASS:D:)</code></pre></p><p>Returns a list with key and value of the enum-pair.</p><p><pre><code>say g.kv; # OUTPUT: «(g 1)␤»\n</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>multi method Int(::?CLASS:D:)</code></pre></p><p>Takes a value of an enum and returns it after coercion to Int:</p><p><pre><code>enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\nsay cool.Int;           # OUTPUT: «42␤»\nsay almost-pi.Int;      # OUTPUT: «3␤»\ntry say sqrt-n-one.Int;\nsay $!.message if $!;   # OUTPUT: «Cannot convert 0+1i to Int: imaginary part not zero␤»</code></pre></p><p>Note that if the value cannot be coerced to Int, an exception will be thrown.</p>","pred":"<p>Defined as:</p><p><pre><code>method pred(::?CLASS:D:)</code></pre></p><p><pre><code>say Freija.pred;  # OUTPUT: «Oðin␤»\n</code></pre></p>","pick":"<p>Defined as:</p><p><pre><code>multi method pick(::?CLASS:U:)\nmulti method pick(::?CLASS:U: \\n)\nmulti method pick(::?CLASS:D: *@pos)</code></pre></p><p>It works on the defined class, selecting one element and eliminating it.</p><p><pre><code>say Norse-gods.pick() for ^3;  # OUTPUT: «Þor␤Freija␤Oðin␤»\n</code></pre></p>","succ":"<p>Defined as:</p><p><pre><code>method succ(::?CLASS:D:)</code></pre></p><p><pre><code>say Oðin.succ;  # OUTPUT: «Freija␤»\n</code></pre></p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(::?CLASS:D:)</code></pre></p><p>Takes a value of an enum and returns it after coercion to Real:</p><p><pre><code>enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\nsay cool.Real;           # OUTPUT: «42␤»\nsay almost-pi.Real;      # OUTPUT: «3.14␤»\ntry say sqrt-n-one.Real;\nsay $!.message if $!;    # OUTPUT: «Cannot convert 0+1i to Real: imaginary part not zero␤»</code></pre></p><p>Note that if the value cannot be coerced to Real, an exception will be thrown.</p>"},"name":"Enumeration"},"Setty":{"prefix":"<p><pre><code>role Setty does QuantHash { }</code></pre></p><p>A role for collections which make sure that each element can only appear once. See Set and SetHash.</p>","defs":{"total":"<p><pre><code>method total(--> Int)</code></pre></p><p>The total of all the values of the QuantHash object. For a Setty object, this is just the number of elements.</p>","pick":"<p><pre><code>multi method pick($count = 1)</code></pre></p><p>Returns $count elements chosen at random (without repetition) from the set.</p><p>If * is passed as $count, or $count is greater than or equal to the size of the set, then all its elements are returned in random order (shuffled).</p>","kv":"<p>Defined as:</p><p><pre><code>multi method kv(Setty:D: --> Seq:D)</code></pre></p><p>Returns a Seq of the set's elements and True values interleaved.</p><p><pre><code>my $s = Set.new(1, 2, 3);\nsay $s.kv;                                        # OUTPUT: «(3 True 1 True 2 True)␤»</code></pre></p>","maxpairs":"<p>Defined As:</p><p><pre><code>multi method maxpairs(Setty:D: --> Seq:D)</code></pre></p><p>Returns the value of self.pairs (as all Pairs have maximum values). See also Any.maxpairs</p>","new-from-pairs":"<p>Defined as:</p><p><pre><code>method new-from-pairs(*@pairs --> Setty:D)</code></pre></p><p>Constructs a Setty object from a list of Pair objects given as positional arguments:</p><p><pre><code>say Set.new-from-pairs: 'butter' => 0.22, 'salt' => 0, 'sugar' => 0.02;\n# OUTPUT: «set(butter, sugar)␤»</code></pre></p><p>Note: be sure you aren't accidentally passing the Pairs as positional arguments; the quotes around the keys in the above example are significant.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(Setty:D: --> Bool:D)</code></pre></p><p>Returns True if the invocant contains at least one element.</p><p><pre><code>my $s1 = Set.new(1, 2, 3);\nsay $s1.Bool;                                     # OUTPUT: «True␤»\n\nmy $s2 = $s1 ∩ Set.new(4, 5);                     # set intersection operator\nsay $s2.Bool;                                     # OUTPUT: «False␤»</code></pre></p>","elems":"<p><pre><code>method elems(--> Int)</code></pre></p><p>The number of elements of the set.</p>","MixHash":"<p>Defined as:</p><p><pre><code>method MixHash(Setty:D: --> MixHash:D)</code></pre></p><p>Returns a MixHash containing the elements of the invocant.</p><p><pre><code>my MixHash $b = Set.new(1, 2, 3).MixHash;\nsay $b;                                           # OUTPUT: «MixHash.new(3, 1, 2)␤»</code></pre></p>","Mix":"<p>Defined as:</p><p><pre><code>method Mix(Setty:D: --> Mix:D)</code></pre></p><p>Returns a Mix containing the elements of the invocant.</p><p><pre><code>my Mix $b = Set.new(1, 2, 3).Mix;\nsay $b;                                           # OUTPUT: «mix(3, 1, 2)␤»</code></pre></p>","grab":"<p><pre><code>method grab($count = 1)</code></pre></p><p>Removes and returns $count elements chosen at random (without repetition) from the set.</p><p>If * is passed as $count, or $count is greater than or equal to the size of the set, then all its elements are removed and returned in random order.</p><p>Only works on mutable sets; When used on an immutable set, it results in an exception.</p>","ACCEPTS":"<p><pre><code>method ACCEPTS($other)</code></pre></p><p>Returns True if $other and self contain all the same elements, and no others.</p>","BagHash":"<p>Defined as:</p><p><pre><code>method BagHash(Setty:D: --> BagHash:D)</code></pre></p><p>Returns a BagHash containing the elements of the invocant.</p><p><pre><code>my BagHash $b = Set.new(1, 2, 3).BagHash;\nsay $b;                                           # OUTPUT: «BagHash.new(3, 1, 2)␤»</code></pre></p>","keys":"<p>Defined as:</p><p><pre><code>multi method keys(Setty:D: --> Seq:D)</code></pre></p><p>Returns a Seq of all elements of the set.</p><p><pre><code>my $s = Set.new(1, 2, 3);\nsay $s.keys;                                      # OUTPUT: «(3 1 2)␤»</code></pre></p>","default":"<p>Defined as:</p><p><pre><code>method default(--> False)</code></pre></p><p>Returns the default value of the invocant, i.e. the value which is returned when trying to access an element in the Setty object which has not been previously initialized or when accessing an element which has explicitly been set to Nil or False.</p><p><pre><code>my $s1 = SetHash.new(1, 2, 3);\nsay $s1{2};                                           # OUTPUT: «True␤»\n$s1{2} = Nil;\nsay $s1{2};                                           # OUTPUT: «False␤»\n# access non initialized element\nsay $s1{4};                                           # OUTPUT: «False␤»</code></pre></p>","Bag":"<p>Defined as:</p><p><pre><code>method Bag(Setty:D: --> Bag:D)</code></pre></p><p>Returns a Bag containing the elements of the invocant.</p><p><pre><code>my Bag $b = Set.new(1, 2, 3).Bag;\nsay $b;                                           # OUTPUT: «bag(3, 1, 2)␤»</code></pre></p>","antipairs":"<p>Defined as:</p><p><pre><code>multi method antipairs(Setty:D: --> Seq:D)</code></pre></p><p>Returns all elements in the set and True as a Seq of Pairs, where the element itself is the value, i.e. the opposite of method pairs.</p><p><pre><code>my $s = Set.new(1, 2, 3, 1);\nsay $s.antipairs.sort;                            # OUTPUT: «(True => 1 True => 2 True => 3)␤»</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>multi method values(Setty:D: --> Seq:D)</code></pre></p><p>Returns a Seq containing as many True values as the set has elements.</p><p><pre><code>my $s = Set.new(1, 2, 3);\nsay $s.values;                                    # OUTPUT: «(True True True)␤»</code></pre></p>","roll":"<p><pre><code>multi method roll($count = 1)</code></pre></p><p>Returns a lazy list of $count elements, each randomly selected from the set. Each random choice is made independently, like a separate die roll where each die face is a set element.</p><p>If * is passed as $count, the list is infinite.</p>","pickpairs":"<p>Defined as:</p><p><pre><code>multi method pickpairs(Setty:D: --> Pair:D)\nmulti method pickpairs(Setty:D: $count --> Seq:D)</code></pre></p><p>Returns a Pair or a Seq of Pairs depending on the candidate of the method being invoked. Each Pair returned has an element of the invocant as its key and True as its value. In contrast to grabpairs, the elements are 'picked' without replacement.</p><p>If * is passed as $count, or $count is greater than or equal to the number of elements of the invocant, then all element/True Pairs from the invocant are returned in a random sequence; i.e. they are returned shuffled;</p><p>Note that each pickpairs invocation maintains its own private state and has no effect on subsequent pickpairs invocations.</p><p><pre><code>my $numbers = set (4, 2, 3);\nsay $numbers.pickpairs;                           # OUTPUT: «4 => True␤»\nsay $numbers.pickpairs(1);                        # OUTPUT: «(3 => True)␤»\nsay $numbers.pickpairs(*);                        # OUTPUT: «(2 => True 4 => True 3 => True)␤»</code></pre></p>","minpairs":"<p>Defined As:</p><p><pre><code>multi method minpairs(Setty:D: --> Seq:D)</code></pre></p><p>Returns the value of self.pairs (as all Pairs have minimum values). See also Any.minpairs</p>","grabpairs":"<p><pre><code>method grabpairs($count = 1)</code></pre></p><p>Removes $count elements chosen at random (without repetition) from the set, and returns a list of Pair objects whose keys are the grabbed elements and whose values are True.</p><p>If * is passed as $count, or $count is greater than or equal to the size of the set, then all its elements are removed and returned as Pairs in the aforementioned way in random order.</p><p>Only works on mutable sets; When used on an immutable set, it results in an exception.</p>"},"name":"Setty"},"Positional":{"name":"Positional","prefix":"<p><pre><code>role Positional { ... }</code></pre></p><p>Role for objects which support indexing them using postcircumfix:«[ ]» (usually list-like objects). Example types with Positional role include List, Array, Range, and Buf.</p>","defs":{"EXISTS-POS":"<p><pre><code>method EXISTS-POS(\\position)</code></pre></p><p>Should return a Bool indicating whether the given position actually has a value.</p>","of":"<p><pre><code>method of()</code></pre></p><p>Returns the type constraint for elements of the positional container. Defaults to Mu.</p>","AT-POS":"<p><pre><code>method AT-POS(\\position)</code></pre></p><p>Should return the value / container at the given position.</p>","STORE":"<p><pre><code>method STORE(\\values, :$initialize)</code></pre></p><p>This method should only be supplied if you want to support the:</p><p><pre><code>my @a is Foo = 1,2,3;\n</code></pre></p><p>syntax for binding your implementation of the Positional role.</p><p>Should accept the values to (re-)initialize the object with. The optional named parameter will contain a True value when the method is called on the object for the first time. Should return the invocant.</p>","elems":"<p><pre><code>method elems()</code></pre></p><p>Should return the number of available elements in the instantiated object.</p>"}},"X::Syntax::Term::MissingInitializer":{"name":"X::Syntax::Term::MissingInitializer","prefix":"<p><pre><code>class X::Syntax::Term::MissingInitializer does X::Syntax { }</code></pre></p><p>Syntax error when a term (a backslash variable) is declared without initialization assignment.</p><p>For example</p><p><pre><code>my \\foo;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nTerm definition requires an initializer\n</code></pre></p><p>Valid code would be</p><p><pre><code>my \\foo = 42;\n</code></pre></p>","defs":{}},"X::Inheritance::Unsupported":{"defs":{"child-typename":"<p>The name of the type that tries to inherit.</p>"},"prefix":"<p><pre><code>class X::Inheritance::Unsupported does X::Comp { }</code></pre></p><p>Compile time error thrown when trying to inherit from a type that does not support inheritance (like a package or an enum).</p><p>For example</p><p><pre><code>enum A <Ax Ay>;\nclass B is A { };\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nA does not support inheritance, so B cannot inherit from it\n</code></pre></p>","name":"X::Inheritance::Unsupported"},"NFKC":{"name":"NFKC","prefix":"<p><pre><code>class NFKC is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form KC. It is created by Compatibility Decomposition, followed by Canonical Composition. For more information on what this means, see Unicode TR15.</p>","defs":{}},"Signature":{"name":"Signature","prefix":"<p><pre><code>class Signature { }</code></pre></p><p>A signature is a static description of the parameter list of a code object. That is, it describes what and how many arguments you need to pass to the code or function in order to call it.</p><p>Passing arguments to a signature binds the arguments, contained in a Capture, to the signature.</p><p> </p>","defs":{"Capture":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","arity":"<p><pre><code>method arity(Signature:D: --> Int:D)</code></pre></p><p>Returns the minimal number of positional arguments required to satisfy the signature.</p>","count":"<p><pre><code>method count(Signature:D: --> Real:D)</code></pre></p><p>Returns the maximal number of positional arguments which can be bound to the signature. Returns Inf if there is a slurpy positional parameter.</p>","params":"<p><pre><code>method params(Signature:D: --> Positional)</code></pre></p><p>Returns the list of Parameter objects that make up the signature.</p>","returns":"<p>Whatever the Signature's return constraint is:</p><p><pre><code>:($a, $b --> Int).returns # OUTPUT: «(Int)»</code></pre></p>","ACCEPTS":"<p><pre><code>multi method ACCEPTS(Signature:D: Signature $topic)\nmulti method ACCEPTS(Signature:D: Capture $topic)\nmulti method ACCEPTS(Signature:D: Mu \\topic)</code></pre></p><p>If $topic is a Signature returns True if anything accepted by $topic would also be accepted by the invocant, otherwise returns False:</p><p><pre><code>:($a, $b) ~~ :($foo, $bar, $baz?);   # OUTPUT: «True»\n:(Int $n) ~~ :(Str);                 # OUTPUT: «False»</code></pre></p><p>The $topic is a Capture, returns True if it can be bound to the invocant, i.e., if a function with invocant's Signature would be able to be called with the $topic:</p><p><pre><code>\\(1, 2, :foo) ~~ :($a, $b, :foo($bar)); # OUTPUT: «True»\n\\(1, :bar)    ~~ :($a);                 # OUTPUT: «False»</code></pre></p><p>Lastly, the candidate with Mu \\topic converts topic to Capture and follows the same semantics as Capture $topic:</p><p><pre><code><a b c d>  ~~ :(Int $a);      # OUTPUT: «False»\n42         ~~ :(Int);         # OUTPUT: «False» (Int.Capture throws)\nset(<a b>) ~~ :(:$a, :$b);    # OUTPUT: «True»</code></pre></p><p>Since where clauses are not introspectable, the method cannot determine whether two signatures ACCEPTS the same sort of where-constrained parameters. Such comparisons will return False. This includes signatures with literals, which are just sugar for the where-constraints:</p><p><pre><code>say :(42) ~~ :($ where 42)    # OUTPUT: «False␤»</code></pre></p>"}},"X::Anon::Augment":{"name":"X::Anon::Augment","defs":{},"prefix":"<p><pre><code>class X::Anon::Augment does X::Comp { }</code></pre></p><p>Compile time error thrown when trying to augment an anonymous package.</p><p>For example</p><p><pre><code>use MONKEY-TYPING;\naugment class { }\n</code></pre></p><p>Dies with</p><p><pre><code>Cannot augment anonymous class\n</code></pre></p>"},"X::Syntax::Malformed":{"prefix":"<p><pre><code>class X::Syntax::Malformed does X::Syntax {}</code></pre></p><p>The Raku compiler throws errors of type X::Syntax::Malformed when it knows what kind of declaration it is parsing, and encounters a syntax error, but can't give a more specific error message.</p><p><pre><code>my Int a;   # throws an X::Syntax::Malformed\n</code></pre></p><p>produces</p><p><pre><code>===SORRY!===\nMalformed my\nat -e:1\n------> my Int ⏏a\n</code></pre></p>","defs":{},"name":"X::Syntax::Malformed"},"Cancellation":{"defs":{},"prefix":"<p><pre><code>my class Cancellation {}</code></pre></p><p>A low level part of the Raku concurrency system. Some Scheduler objects return a Cancellation with the .cue method which can be used to cancel the scheduled execution before normal completion. Cancellation.cancelled is a boolean that is true after #cancel is called.</p>","name":"Cancellation"},"X::IO":{"prefix":"<p><pre><code>role X::IO does X::OS {}</code></pre></p><p>Common role for IO related errors.</p><p>This role does not provide any additional methods.</p>","defs":{},"name":"X::IO"},"Proc":{"name":"Proc","defs":{"sink":"<p>Defined as:</p><p><pre><code>method sink(--> Nil)</code></pre></p><p>When sunk, the Proc object will throw X::Proc::Unsuccessful if the process it ran exited unsuccessfully.</p><p><pre><code>shell 'ls /qqq';\n# OUTPUT: «(exit code 1) ls: cannot access '/qqq': No such file or directory␤The spawned command 'ls /qqq' exited unsuccessfully (exit code: 2)␤\nn block <unit> at /tmp/3169qXElwq line 1␤␤»\n</code></pre></p>","exitcode":"<p><pre><code>method exitcode(Proc:D: --> Int:D)</code></pre></p><p>Returns the exit code of the external process, or -1 if it has not exited yet.</p>","pid":"<p><pre><code>method pid()</code></pre></p><p>Returns the PID value of the process if available, or Nil.</p>","command":"<p><pre><code>method command(Proc:D: --> List:D)</code></pre></p><p>The command method is an accessor to a list containing the arguments that were passed when the Proc object was executed via spawn or shell or run.</p>","shell":"<p><pre><code>method shell($cmd, :$cwd = $*CWD, :$env --> Bool:D)</code></pre></p><p>Runs the Proc object with the given command and environment which are passed through to the shell for parsing and execution. See shell for an explanation of which shells are used by default in the most common operating systems.</p>","new":"<p><pre><code>method new(Proc:U:\n        :$in = '-',\n        :$out = '-',\n        :$err = '-',\n        Bool :$bin = False,\n        Bool :$chomp = True,\n        Bool :$merge = False,\n        Str:D :$enc = 'UTF-8',\n        Str:D :$nl = \"\\n\",\n    --> Proc:D)\n\nsub shell(\n        $cmd,\n        :$in = '-',\n        :$out = '-',\n        :$err = '-',\n        Bool :$bin = False,\n        Bool :$chomp = True,\n        Bool :$merge = False,\n        Str:D :$enc = 'UTF-8',\n        Str:D :$nl = \"\\n\",\n        :$cwd = $*CWD,\n        Hash() :$env = %*ENV\n    --> Proc:D)\n</code></pre></p><p>new creates a new Proc object, whereas run or shell create one and spawn it with the command and arguments provided in @args or $cmd, respectively.</p><p>$in, $out and $err are the three standard streams of the to-be-launched program, and default to \"-\" meaning they inherit the stream from the parent process. Setting one (or more) of them to True makes the stream available as an IO::Pipe object of the same name, like for example $proc.out. You can set them to False to discard them. Or you can pass an existing IO::Handle object (for example IO::Pipe) in, in which case this handle is used for the stream.</p><p>Please bear in mind that the process streams reside in process variables, not in the dynamic variables that make them available to our programs. Thus, modifying the dynamic filehandle variables (such as $*OUT) inside the host process will have no effect in the spawned process, unlike $*CWD and $*ENV, whose changes will be actually reflected in it.</p><p><pre><code>my $p-name = \"/tmp/program.p6\";\nmy $program = Q:to/END/;\n    #!/usr/bin/env perl6\n\n    $*OUT.say( qq/\\t$*PROGRAM: This goes to standard output/ );\nEND\n\nspurt $p-name, $program;\n\n$*OUT.put: \"1. standard output before doing anything weird\";\n\n{\n    temp $*OUT = open '/tmp/out.txt', :w;\n    $*OUT.put: \"2. temp redefine standard output before this message\";\n    shell( \"perl6 $p-name\" ).so;\n}\n\n$*OUT.put: \"3. everything should be back to normal\";\n# OUTPUT\n# 1. standard output before doing anything weird\n#     /tmp/program.p6: This goes to standard output\n# 3. everything should be back to normal\n\n# /tmp/out.txt will contain:\n# 2. temp redefine standard output before this message\n</code></pre></p><p>This program shows that the program spawned with shell is not using the temporary $*OUT value defined in the host process (redirected to /tmp/out.txt), but the initial STDOUT defined in the process.</p><p>$bin controls whether the streams are handled as binary (i.e. Blob object) or text (i.e. Str objects). If $bin is False, $enc holds the character encoding to encode strings sent to the input stream and decode binary data from the output and error streams.</p><p>With $chomp set to True, newlines are stripped from the output and err streams when reading with lines or get. $nl controls what your idea of a newline is.</p><p>If $merge is set to True, the standard output and error stream end up merged in $proc.out.</p>","spawn":"<p><pre><code>method spawn(*@args ($, *@), :$cwd = $*CWD, Hash() :$env = %*ENV --> Bool:D)</code></pre></p><p>Runs the Proc object with the given command, argument list, working directory, and environment.</p>"},"prefix":"<p><pre><code>class Proc {}</code></pre></p><p>Proc is a representation of an invocation of an external process. It provides access to the input, output and error stream as well as the exit code. It is typically created through the run subroutine:</p><p><pre><code>my $proc = run 'echo', 'Hallo world', :out;\nmy $captured-output = $proc.out.slurp: :close;\nsay \"Output was $captured-output.perl()\";# OUTPUT: «Output was \"Hallo world\\n\"␤»\n</code></pre></p><p>Piping several commands is easy too. To achieve the equivalent of the pipe echo \"Hello, world\" | cat -n in Raku, and capture the output from the second command, you can do</p><p><pre><code>my $p1 = run 'echo', 'Hello, world', :out;\nmy $p2 = run 'cat', '-n', :in($p1.out), :out;\nsay $p2.out.get;\n</code></pre></p><p>You can also feed the :in (standard input) pipe directly from your program, by setting it to True, which will make the pipe available via .in method on the Proc:</p><p><pre><code>my $p = run \"cat\", \"-n\", :in, :out;\n$p.in.say: \"Hello,\\nworld!\";\n$p.in.close;\nsay $p.out.slurp: :close;\n# OUTPUT: «1  Hello,␤\n#          2  world!␤»\n</code></pre></p><p>In order to capture the standard error, :err can be supplied:</p><p><pre><code>my $p = run \"ls\", \"-l\", \".\", \"qqrq\", :out, :err;\nmy $captured-output = $p.out.slurp: :close;\nmy $captured-error  = $p.err.slurp: :close;\nmy $exit-code       = $p.exitcode;\n</code></pre></p><p>In sink context, a Proc will call its sink method, throwing an exception if the process has exited with an exit code different from zero:</p><p><pre><code>shell 'exit 1'\n# OUTPUT: «(exit code 1) The spawned command 'exit 1' exited unsuccessfully (exit code: 1)␤»\n</code></pre></p><p>Note: Versions of Rakudo older than 2017.04 do not have .slurp available on IO::Pipe objects; use .slurp-rest instead.</p><p>Use Proc::Async for non-blocking operations.</p>"},"IO::Path":{"defs":{"resolve":"<p>Defined as:</p><p><pre><code>method resolve(IO::Path:D: :$completely --> IO::Path)</code></pre></p><p>Returns a new IO::Path object with all symbolic links and references to the parent directory (..) resolved. This means that the filesystem is examined for each directory in the path, and any symlinks found are followed.</p><p><pre><code># bar is a symlink pointing to \"/baz\"\nmy $io = \"foo/./bar/..\".IO.resolve;      # now \"/\" (the parent of \"/baz\")</code></pre></p><p>If :$completely, which defaults to False, is set to a true value, the method will fail with X::IO::Resolve if it cannot completely resolve the path, otherwise, it will resolve as much as possible, and will merely perform cleanup of the rest of the path. The last part of the path does NOT have to exist to :$completely resolve the path.</p><p>NOTE: Currently (April 2017) this method doesn't work correctly on all platforms, e.g. Windows, since it assumes POSIX semantics.</p>","split":"<p>Defined as:</p><p><pre><code>method split(IO::Path:D: |args --> Seq:D)</code></pre></p><p>Opens the file and processes its contents the same way Str.split does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>","slurp":"<p>Defined as:</p><p><pre><code>multi method slurp(IO::Path:D: :$bin, :$enc)</code></pre></p><p>Read all of the file's content and return it as either Buf, if :$bin is True, or if not, as Str decoded with :$enc encoding, which defaults to utf8. File will be closed afterwards. See &open for valid values for :$enc.</p>","copy":"<p>Defined as:</p><p><pre><code>method copy(IO::Path:D: IO() $to, :$createonly --> Bool:D)\nsub    copy(IO() $from, IO() $to, :$createonly --> Bool:D)</code></pre></p><p>Copies a file. Returns True on success; fails with X::IO::Copy if :$createonly is True and the $to path already exists or if the operation failed for some other reason, such as when $to and $from are the same file.</p>","x":"<p>Defined as:</p><p><pre><code>method x(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is executable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","chmod":"<p>Defined as:</p><p><pre><code>method chmod(IO::Path:D: Int() $mode --> Bool)</code></pre></p><p>Changes the POSIX permissions of a file or directory to $mode. Returns True on success; on failure, fails with X::IO::Chmod.</p><p>The mode is expected as an integer following the standard numeric notation, and is best written as an octal number:</p><p><pre><code>'myfile'.IO.chmod(0o444);          # make a file read-only\n'somedir'.IO.chmod(0o777);         # set 0777 permissions on a directory\n</code></pre></p><p>Make sure you don't accidentally pass the intended octal digits as a decimal number (or string containing a decimal number):</p><p><pre><code>'myfile'.IO.chmod:  '0444';        # BAD!!! (interpreted as mode 0o674)\n'myfile'.IO.chmod: '0o444';        # OK (an octal in a string)\n'myfile'.IO.chmod:  0o444;         # Also OK (an octal literal)\n</code></pre></p>","rename":"<p>Defined as:</p><p><pre><code>method rename(IO::Path:D: IO() $to, :$createonly = False --> Bool:D)\nsub    rename(IO() $from, IO() $to, :$createonly = False --> Bool:D)</code></pre></p><p>Renames a file or directory. Returns True on success; fails with X::IO::Rename if :$createonly is True and the $to path already exists or if the operation failed for some other reason.</p><p>Note: some renames will always fail, such as when the new name is on a different storage device. See also: move.</p>","watch":"<p>Defined as:</p><p><pre><code>method watch(IO::Path:D: --> Supply:D)</code></pre></p><p>Equivalent to calling IO::Notification.watch-path with the invocant as the argument.</p>","succ":"<p>Defined as:</p><p><pre><code>method succ(IO::Path:D: --> IO::Path:D)</code></pre></p><p>Returns a new IO::Path constructed from the invocant, with .basename changed by calling Str.succ on it.</p><p><pre><code>\"foo/file02.txt\".IO.succ.say; # OUTPUT: «\"foo/file03.txt\".IO␤»</code></pre></p>","changed":"<p>Returns an Instant object indicating the metadata of the file or directory was last changed (e.g. permissions, or files created/deleted in directory). Compare with modified.</p><p><pre><code>say \"path/to/file\".IO.changed;           # Instant:1424089165\nsay \"path/to/file\".IO.changed.DateTime;  # 2015-02-16T12:18:50Z\n</code></pre></p>","dirname":"<p>Defined as:</p><p><pre><code>method dirname(IO::Path:D:)</code></pre></p><p>Returns the directory name portion of the path object. That is, it returns the path excluding the volume and the base name. Unless the dirname consist of only the directory separator (i.e. it's the top directory), the trailing directory separator will not be included in the return value.</p><p><pre><code>say IO::Path.new(\"/home/camelia/myfile.p6\").dirname; # OUTPUT: «/home/camelia␤»\nsay IO::Path::Win32.new(\"C:/home/camelia\").dirname;  # OUTPUT: «/home␤»\nsay IO::Path.new(\"/home\").dirname;                   # OUTPUT: «/␤»</code></pre></p>","sibling":"<p>Defined as:</p><p><pre><code>method sibling(IO::Path:D: Str() $sibling --> IO::Path:D)</code></pre></p><p>Allows to reference a sibling file or directory. Returns a new IO::Path based on the invocant, with the .basename changed to $sibling. The $sibling is allowed to be a multi-part path fragment; see also .add.</p><p><pre><code>say '.bashrc'.IO.sibling: '.bash_aliases'; # OUTPUT: «.bash_aliases\".IO␤»\nsay '/home/camelia/.bashrc'.IO.sibling: '.bash_aliases';\n# OUTPUT: «/home/camelia/.bash_aliases\".IO␤»\n\nsay '/foo/' .IO.sibling: 'bar';  # OUTPUT: «/bar\".IO␤»\nsay '/foo/.'.IO.sibling: 'bar';  # OUTPUT: «/foo/bar\".IO␤»</code></pre></p>","add":"<p>Defined as:</p><p><pre><code>method add(IO::Path:D: Str() $what --> IO::Path:D)</code></pre></p><p>Concatenates a path fragment to the invocant and returns the resultant IO::Path. If adding ../ to paths that end with a file, you may need to call resolve for the resultant path to be accessible by other IO::Path methods like dir or open. See also sibling and parent.</p><p><pre><code>\"foo/bar\".IO.mkdir;\n\"foo/bar\".IO.add(\"meow\")    .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n\"foo/bar\".IO.add(\"/meow\")   .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n\"foo/bar\".IO.add(\"meow.txt\").resolve.relative.say; # OUTPUT: «foo/bar/meow.txt␤»\n\"foo/bar\".IO.add(\"../meow\") .resolve.relative.say; # OUTPUT: «foo/meow␤»\n\"foo/bar\".IO.add(\"../../\")  .resolve.relative.say; # OUTPUT: «.␤»</code></pre></p>","volume":"<p>Defined as:</p><p><pre><code>method volume(IO::Path:D:)</code></pre></p><p>Returns the volume portion of the path object. On Unix system, this is always the empty string.</p><p><pre><code>say IO::Path::Win32.new(\"C:\\\\Windows\\\\registry.ini\").volume;    # OUTPUT: «C:␤»</code></pre></p>","parent":"<p>Defined as:</p><p><pre><code>multi method parent(IO::Path:D:)\nmulti method parent(IO::Path:D: UInt:D $level)</code></pre></p><p>Returns the parent path of the invocant. Note that no actual filesystem access is made, so the returned parent is physical and not the logical parent of symlinked directories.</p><p><pre><code>'/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n'./'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n'/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\nIO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»</code></pre></p><p>If $level is specified, the call is equivalent to calling .parent() $level times:</p><p><pre><code>say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»\n</code></pre></p>","is-relative":"<p>Defined as:</p><p><pre><code>method is-relative(IO::Path:D: --> Bool)</code></pre></p><p>Returns True if the path is a relative path, and False otherwise. Windows caveats for .is-absolute apply.</p>","child":"<p>Defined as:</p><p><pre><code>method child(IO::Path:D: Str() $childname --> IO::Path:D)</code></pre></p><p>Alias for .add. NOTE: This method has been deprecated as of the 6.d version, and will be removed in the future. For any new code, please use .add</p>","IO":"<p>Defined as:</p><p><pre><code>method IO(IO::Path:D: --> IO::Path)</code></pre></p><p>Returns the invocant.</p>","d":"<p>Defined as:</p><p><pre><code>method d(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a directory. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","z":"<p>Defined as:</p><p><pre><code>method z(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and has size of 0. May be called on paths that are directories, in which case the reported file size (and thus the result of this method) is dependent on the operating system. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","extension":"<p>Defined as:</p><p><pre><code>multi method extension(IO::Path:D:                                         --> Str:D)\nmulti method extension(IO::Path:D:               Int :$parts               --> Str:D)\nmulti method extension(IO::Path:D:             Range :$parts               --> Str:D)\nmulti method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\nmulti method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)</code></pre></p><p>Returns the extension consisting of $parts parts (defaults to 1), where a \"part\" is defined as a dot followed by possibly-empty string up to the end of the string, or previous part. That is \"foo.tar.gz\" has an extension of two parts: first part is \"gz\" and second part is \"tar\" and calling \"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the specified number of $parts is not found, returns an empty string.</p><p>$parts can be a Range, specifying the minimum number of parts and maximum number of parts the extension should have. The routine will attempt to much the most parts it can. If $parts range's endpoints that are smaller than 0 they'll be treated as 0; implementations may treat endpoints larger than 2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to be thrown.</p><p>If $subst is provided, the extension will be instead replaced with $subst and a new IO::Path object will be returned. It will be joined to the file's name with $joiner, which defaults to an empty string when $subst is an empty string and to \".\" when $subst is not empty. Note: if as the result of replacement the basename of the path ends up being empty, it will be assumed to be . (a single dot).</p><p><pre><code># Getting an extension:\nsay \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\nsay \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\nsay \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n# Replacing an extension\nsay \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n# Replacing an extension using non-standard joiner:\nsay \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                       :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                       :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n# EDGE CASES:\n\n# There is no 5-part extension, so returned value is an empty string\nsay \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n# There is no 5-part extension, so we replaced nothing:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n# Replacing a 0-part extension is just appending:\nsay \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n# Replace 1-part of the extension, using '.' joiner\nsay \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n# Replace 1-part of the extension, using empty string joiner\nsay \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n# Remove 1-part extension; results in empty basename, so result is \".\".IO\nsay \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»</code></pre></p>","rw":"<p>Defined as:</p><p><pre><code>method rw(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is readable and writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","s":"<p>Defined as:</p><p><pre><code>method s(--> Int:D)</code></pre></p><p>Returns the file size in bytes. May be called on paths that are directories, in which case the reported size is dependent on the operating system. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p><p><pre><code>say $*EXECUTABLE.IO.s; # OUTPUT : «467␤»</code></pre></p>","Int":"<p>Defined as:</p><p><pre><code>method Int(IO::Path:D: --> Int:D)</code></pre></p><p>Coerces .basename to Int. Fails with X::Str::Numeric if base name is not numerical.</p><p> </p>","is-absolute":"<p>Defined as:</p><p><pre><code>method is-absolute(IO::Path:D: --> Bool)</code></pre></p><p>Returns True if the path is an absolute path, and False otherwise.</p><p><pre><code>\"/foo\".IO.is-absolute.say; # OUTPUT: «True␤»\n\"bars\".IO.is-absolute.say; # OUTPUT: «False␤»</code></pre></p><p>Note that on Windows a path that starts with a slash or backslash is still considered absolute even if no volume was given, as it is absolute for that particular volume:</p><p><pre><code>IO::Path::Win32.new(\"/foo\"  ).is-absolute.say; # OUTPUT: «True␤»\nIO::Path::Win32.new(\"C:/foo\").is-absolute.say; # OUTPUT: «True␤»\nIO::Path::Win32.new(\"C:foo\" ).is-absolute.say; # OUTPUT: «False␤»</code></pre></p>","pred":"<p>Defined as:</p><p><pre><code>method pred(IO::Path:D: --> IO::Path:D)</code></pre></p><p>Returns a new IO::Path constructed from the invocant, with .basename changed by calling Str.pred on it.</p><p><pre><code>\"foo/file02.txt\".IO.pred.say; # OUTPUT: «\"foo/file01.txt\".IO␤»</code></pre></p>","dir":"<p>Defined as:</p><p><pre><code>sub    dir(Cool $path = '.', Mu :$test = none('.', '..'))\nmethod dir(IO::Path:D: Mu :$test = none('.', '..'))</code></pre></p><p>Returns the contents of a directory as a lazy list of IO::Path objects representing relative paths, filtered by smartmatching their names (as strings) against the :test parameter.</p><p>Since the tests are performed against Str arguments, not IO, the tests are executed in the $*CWD, instead of the target directory. When testing against file test operators, this won't work:</p><p><pre><code>dir('mydir', test => { .IO.d })</code></pre></p><p>while this will:</p><p><pre><code>dir('mydir', test => { \"mydir/$_\".IO.d })</code></pre></p><p>NOTE: a dir call opens a directory for reading, which counts towards maximum per-process open files for your program. Be sure to exhaust returned Seq before doing something like recursively performing more dir calls. You can exhaust it by assigning to a @-sigiled variable or simply looping over it. Note how examples below push further dirs to look through into an Array, rather than immediately calling dir on them. See also IO::Dir module that gives you finer control over closing dir handles.</p><p>Examples:</p><p><pre><code># To iterate over the contents of the current directory:\nfor dir() -> $file {\n    say $file;\n}\n\n# As before, but include even '.' and '..' which are filtered out by\n# the default :test matcher:\nfor dir(test => *) -> $file {\n    say $file;\n}\n\n# To get the names of all .jpg and .jpeg files in ~/Downloads:\nmy @jpegs = $*HOME.dir: test => /:i '.' jpe?g $/;</code></pre></p><p>An example program that lists all files and directories recursively:</p><p><pre><code>sub MAIN($dir = '.') {\n    my @todo = $dir.IO;\n    while @todo {\n        for @todo.pop.dir -> $path {\n            say $path.Str;\n            @todo.push: $path if $path.d;\n        }\n    }\n}</code></pre></p><p>A lazy way to find the first three files ending in \".p6\" recursively starting from the current directory:</p><p><pre><code>my @stack = '.'.IO;\nmy $perl-files = gather while @stack {\n    with @stack.pop {\n        when :d { @stack.append: .dir }\n        .take when .extension.lc eq 'p6'\n    }\n}\n.put for $perl-files[^3];\n</code></pre></p>","f":"<p>Defined as:</p><p><pre><code>method f(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a file. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","lines":"<p>Defined as:</p><p><pre><code>method lines(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)</code></pre></p><p>Opens the invocant and returns its lines.</p><p>The behavior is equivalent to opening the file specified by the invocant, forwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open, then calling IO::Handle.lines on that handle, forwarding any of the remaining arguments to that method, and returning the resultant Seq.</p><p>NOTE: the lines are ready lazily and the handle used under the hood won't get closed until the returned Seq is fully reified, so ensure it is, or you'll be leaking open filehandles. (TIP: use the $limit argument)</p><p><pre><code>say \"The file contains \",\n  '50GB-file'.IO.lines.grep(*.contains: 'Perl').elems,\n  \" lines that mention Perl\";\n# OUTPUT: «The file contains 72 lines that mention Perl␤»\n</code></pre></p>","rmdir":"<p>Defined as:</p><p><pre><code>sub    rmdir(*@dirs --> List:D)\nmethod rmdir(IO::Path:D: --> True)</code></pre></p><p>Remove the invocant, or in sub form, all of the provided directories in the given list, which can contain any Cool object. Only works on empty directories.</p><p>Method form returns True on success and returns a Failure of type X::IO::Rmdir if the directory cannot be removed (e.g. the directory is not empty, or the path is not a directory). Subroutine form returns a list of directories that were successfully deleted.</p><p>To delete non-empty directory, see rmtree in File::Directory::Tree module.</p>","accessed":"<p>Return an Instant object representing the timestamp when the file was last accessed. Note: depending on how the filesystem was mounted, the last accessed time may not update on each access to the file, but only on the first access after modifications.</p><p><pre><code>say \"path/to/file\".IO.accessed;          # Instant:1424353577\nsay \"path/to/file\".IO.accessed.DateTime; # 2015-02-19T13:45:42Z\n</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\nmulti method new(\n    :$basename!, :$dirname = '.', :$volume = ''\n    IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n)\n</code></pre></p><p>Creates a new IO::Path object from a path string (which is being parsed for volume, directory name and basename), or from volume, directory name and basename passed as named arguments.</p><p>The path's operation will be performed using :$SPEC semantics (defaults to current $*SPEC) and will use :$CWD as the directory the path is relative to (defaults to $*CWD).</p>","cleanup":"<p>Defined as:</p><p><pre><code>method cleanup(IO::Path:D: --> IO::Path:D)</code></pre></p><p>Returns a new path that is a canonical representation of the invocant path, cleaning up any extraneous path parts:</p><p><pre><code>\"foo/./././..////bar\".IO.cleanup.say;      # OUTPUT: «\"foo/../bar\".IO␤»\nIO::Path::Win32.new(\"foo/./././..////bar\")\n    .cleanup.say; \"foo\\..\\bar\".IO;         # OUTPUT: «\"foo\\..\\bar\".IO␤»</code></pre></p><p>Note that no filesystem access is made. See also resolve.</p>","l":"<p>Defined as:</p><p><pre><code>method l(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is a symlink. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","r":"<p>Defined as:</p><p><pre><code>method r(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is accessible. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","chdir":"<p>Defined as:</p><p><pre><code>multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)</code></pre></p><p>DEPRECATION NOTICE: this method will be deprecated in 6.d language and removed in 6.e. Do not use it for new code. Instead, create a new path or use add method. For altering current working directory see &chdir and &*chdir subroutines.</p><p>Contrary to the name, the .chdir method does not change any directories, but merely concatenates the given $path to the invocant and returns the resultant IO::Path. Optional file tests can be performed by providing :d, :r, :w, or :x Bool named arguments; when set to True, they'll perform .d, .r, .w, and .x tests respectively. By default, only :d is set to True.</p>","relative":"<p>Defined as:</p><p><pre><code>method relative(IO::Path:D: $base = $*CWD --> Str)</code></pre></p><p>Returns a new Str object with the path relative to the $base. If $base is not provided, $*CWD is used in its place. If the invocant is not an absolute path, it's first made to be absolute using the .CWD attribute the object was created with, and then is made relative to $base.</p>","link":"<p>Defined as:</p><p><pre><code>method link(IO::Path:D $target: IO() $link --> Bool:D)\nsub    link(      IO() $target, IO() $link --> Bool:D)</code></pre></p><p>Create a new hard link $link to existing $target. Returns True on success; fails with X::IO::Link if the hard link could not be created. To create a symbolic link, see symlink.</p>","move":"<p>Defined as:</p><p><pre><code>method move(IO::Path:D: IO() $to, :$createonly --> Bool:D)\nsub    move(IO() $from, IO() $to, :$createonly --> Bool:D)</code></pre></p><p>Copies a file and then removes the original. If removal fails, it's possible to end up with two copies of the file. Returns True on success; fails with X::IO::Move if :$createonly is True and the $to path already exists or if the operation failed for some other reason, such as when $to and $from are the same file.</p><p>To avoid copying, you can use rename, if the files are on the same storage device. It also works with directories, while move does not.</p>","w":"<p>Defined as:</p><p><pre><code>method w(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","modified":"<p>Returns an Instant object indicating when the content of the file was last modified. Compare with changed.</p><p><pre><code>say \"path/to/file\".IO.modified;          # Instant:1424089165\nsay \"path/to/file\".IO.modified.DateTime; # 2015-02-16T12:18:50Z\n</code></pre></p>","Numeric":"<p>Defined as:</p><p><pre><code>method Numeric(IO::Path:D: --> Numeric:D)</code></pre></p><p>Coerces .basename to Numeric. Fails with X::Str::Numeric if base name is not numerical.</p>","unlink":"<p>Defined as:</p><p><pre><code>method unlink(IO::Path:D: --> True)\nsub    unlink(*@filenames --> List:D)</code></pre></p><p>Delete all specified ordinary files, links, or symbolic links for which there are privileges to do so. See rmdir to delete directories.</p><p>The subroutine form returns the names of all the files in the list, excluding those for which the filesystem raised some error; since trying to delete a file that does not exist does not raise any error at that level, this list will include the names of the files in the list that do not exist.</p><p>The method form returns True on success, or fails with X::IO::Unlink if the operation could not be completed. If the file to be deleted does not exist, the routine treats it as success.</p><p><pre><code>'foo.txt'.IO.open(:w).close;\n'bar'.IO.mkdir;\nsay unlink <foo.txt  bar  not-there.txt>; # OUTPUT: «[foo.txt not-there.txt]␤»\n# `bar` is not in output because it failed to delete (it's a directory)\n# `not-there.txt` is present. It never existed, so that's deemed a success.\n\n# Method form `fail`s:\nsay .exception.message without 'bar'.IO.unlink;\n# OUTPUT: «Failed to remove the file […] illegal operation on a directory␤»\n</code></pre></p>","e":"<p>Defined as:</p><p><pre><code>method e(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists.</p>","basename":"<p>Defined as:</p><p><pre><code>method basename(IO::Path:D:)</code></pre></p><p>Returns the basename part of the path object, which is the name of the filesystem object itself that is referenced by the path.</p><p><pre><code>\"docs/README.pod\".IO.basename.say; # OUTPUT: «README.pod␤»\n\"/tmp/\".IO.basename.say;           # OUTPUT: «tmp␤»</code></pre></p><p>Note that in IO::Spec::Win32 semantics, the basename of a Windows share is \\, not the name of the share itself:</p><p><pre><code>IO::Path::Win32.new('//server/share').basename.say; # OUTPUT: «\\␤»</code></pre></p>","words":"<p>Defined as:</p><p><pre><code>method words(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)</code></pre></p><p>Opens the invocant and returns its words.</p><p>The behavior is equivalent to opening the file specified by the invocant, forwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open, then calling IO::Handle.words on that handle, forwarding any of the remaining arguments to that method, and returning the resultant Seq.</p><p>NOTE: words are lazily read. The handle used under the hood is not closed until the returned Seq is fully reified, and this could lead to leaking open filehandles. It is possible to avoid leaking open filehandles using the $limit argument to cut down the Seq of words to be generated.</p><p><pre><code>my %dict := bag 'my-file.txt'.IO.words;\nsay \"Most common words: \", %dict.sort(-*.value).head: 5;\n</code></pre></p>","gist":"<p>Defined as:</p><p><pre><code>method gist(IO::Path:D: --> Str:D)</code></pre></p><p>Returns a string, part of which contains either the value of .absolute (if path is absolute) or .path. Note that no escaping of special characters is made, so e.g. \"\\b\" means a path contains a backslash and letter \"b\", not a backspace.</p><p><pre><code>say \"foo/bar\".IO;                       # OUTPUT: «\"foo/bar\".IO␤»\nsay IO::Path::Win32.new: ｢C:\\foo/bar\\｣; # OUTPUT: «\"C:\\foo/bar\\\".IO␤»</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>method Str(IO::Path:D: --> Str)</code></pre></p><p>Alias for IO::Path.path. In particular, note that default stringification of an IO::Path does NOT use the value of $.CWD attribute. To stringify while retaining full path information use .absolute or .relative methods.</p>","rwx":"<p>Defined as:</p><p><pre><code>method rwx(--> Bool:D)</code></pre></p><p>Returns True if the invocant is a path that exists and is executable, readable, and writable. The method will fail with X::IO::DoesNotExist if the path points to a non-existent filesystem entity.</p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(IO::Path:D: Cool:D $other --> Bool:D)</code></pre></p><p>Coerces the argument to IO::Path, if necessary. Returns True if .absolute method on both paths returns the same string. NOTE: it's possible for two paths that superficially point to the same resource to NOT smartmatch as True, if they were constructed differently and were never fully resolved:</p><p><pre><code>say \"foo/../bar\".IO ~~ \"bar\".IO # False</code></pre></p><p>The reason is the two paths above may point to different resources when fully resolved (e.g. if foo is a symlink). Resolve the paths before smartmatching to check they point to same resource:</p><p><pre><code>say \"foo/../bar\".IO.resolve(:completely) ~~ \"bar\".IO.resolve(:completely) # True</code></pre></p>","SPEC":"<p>Defined as:</p><p><pre><code>method SPEC(IO::Path:D: --> IO::Spec)</code></pre></p><p>Returns the IO::Spec object that was (implicitly) specified at object creation time.</p><p><pre><code>my $io = IO::Path.new(\"/bin/bash\");\nsay $io.SPEC;                            # OUTPUT: «(Unix)␤»\nsay $io.SPEC.dir-sep;                    # OUTPUT: «/␤»</code></pre></p>","absolute":"<p>Defined as:</p><p><pre><code>multi method absolute(IO::Path:D: --> Str)\nmulti method absolute(IO::Path:D: $base --> Str)</code></pre></p><p>Returns a new Str object that is an absolute path. If the invocant is not already an absolute path, it is first made absolute using $base as base, if it is provided, or the .CWD attribute the object was created with if it is not.</p>","spurt":"<p>Defined as:</p><p><pre><code>method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)</code></pre></p><p>Opens the file path for writing, and writes all of the $data into it. File will be closed, afterwards. Will fail if it cannot succeed for any reason. The $data can be any Cool type or any Blob type. Arguments are as follows:</p>* <p>:$enc — character encoding of the data. Takes same values as :$enc in IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.</p><br>* <p>:$append — open the file in append mode, preserving existing contents, and appending data to the end of the file.</p><br>* <p>:$createonly — fail if the file already exists.</p><br>","parts":"<p>Defined as:</p><p><pre><code>method parts(IO::Path:D: --> Map:D)</code></pre></p><p>Returns a Map with the keys volume, dirname, basename whose values are the same as available via methods .volume, .dirname, and .basename respectively.</p><p><pre><code>say IO::Path::Win32.new(\"C:/rakudo/perl6.bat\").parts.perl;\n# OUTPUT: «Map.new((:basename(\"perl6.bat\"),:dirname(\"/rakudo\"),:volume(\"C:\")))␤»</code></pre></p>","symlink":"<p>Defined as:</p><p><pre><code>method symlink(IO::Path:D $target: IO() $link --> Bool:D)\nsub    symlink(      IO() $target, IO() $link --> Bool:D)</code></pre></p><p>Create a new symbolic link $link to existing $target. Returns True on success; fails with X::IO::Symlink if the symbolic link could not be created. If $target does not exist, creates a dangling symbolic link. To create a hard link, see link.</p><p>Note: on Windows, creation of symbolic links may require escalated privileges.</p><p> </p>","comb":"<p>Defined as:</p><p><pre><code>method comb(IO::Path:D: |args --> Seq:D)</code></pre></p><p>Opens the file and processes its contents the same way Str.comb does, taking the same arguments. Implementations may slurp the file in its entirety when this method is called.</p>","perl":"<p>Defined as:</p><p><pre><code>method perl(IO::Path:D: --> Str:D)</code></pre></p><p>Returns a string that, when given passed through EVAL gives the original invocant back.</p><p><pre><code>\"foo/bar\".IO.perl.say;\n# OUTPUT: IO::Path.new(\"foo/bar\", :SPEC(IO::Spec::Unix), :CWD(\"/home/camelia\"))</code></pre></p><p>Note that this string includes the value of the .CWD attribute that is set to $*CWD when the path object was created, by default.</p>","open":"<p>Defined as:</p><p><pre><code>method open(IO::Path:D: *%opts)</code></pre></p><p>Opens the path as a file; the named options control the mode, and are the same as the open function accepts.</p>"},"prefix":"<p><pre><code>class IO::Path is Cool does IO { }\n</code></pre></p><p>IO::Path is the workhorse of IO operations.</p><p>Conceptually, an IO::Path object consists of a volume, a directory, and a basename. It supports both purely textual operations, and operations that access the filesystem, e.g. to resolve a path, or to read all content of a file.</p><p>At creation, each IO::Path object is given information about the current working directory the path might be relative to using the $.CWD attribute (defaults to $*CWD), as well as what operating system semantics should be used for path manipulation using the special IO::Spec type given in the $.SPEC attribute.</p><p>The $.SPEC defaults to the value of $*SPEC, which uses the object suitable for the operating system the code is currently running on. This is the default most code will be comfortable with.</p><p>In certain situations, e.g. testing, you may wish to force $*SPEC to use one of the specific SPEC modules: IO::Spec::Unix, IO::Spec::Win32, IO::Spec::Cygwin, and IO::Spec::QNX, or to create IO::Path objects via shortcut subclasses IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin, and IO::Path::QNX that pre-set the $.SPEC attribute for you.</p><p>The rest of this document silently assumes Unix semantics in its examples, unless stated otherwise.</p>","name":"IO::Path"},"X::Syntax::Regex::SolitaryQuantifier":{"name":"X::Syntax::Regex::SolitaryQuantifier","prefix":"<p><pre><code>class X::Syntax::Regex::SolitaryQuantifier does X::Syntax { }</code></pre></p><p>Syntax error when a stand alone quantifier (without a preceding atom to quantify) is encountered in a regular expression.</p><p>For example</p><p><pre><code>/ * /;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nQuantifier quantifies nothing\n</code></pre></p>","defs":{}},"X::Method::Private::Permission":{"name":"X::Method::Private::Permission","defs":{"method":"<p><pre><code>method method(--> Str:D)</code></pre></p><p>The name of the private method</p>","source-package":"<p><pre><code>method source-package(--> Mu:D)</code></pre></p><p>Returns the type object that (supposedly) contains the private method.</p>"},"prefix":"<p><pre><code>class X::Method::Private::Permission does X::Comp { }</code></pre></p><p>Compile time error thrown when the code contains a call to a private method that isn't defined in the current class, and when no appropriate trusts relation is defined that permits the private method call.</p><p>For example</p><p><pre><code>1!Int::foo\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot call private method 'foo' on package Int because it does not trust GLOBAL\n</code></pre></p>"},"X::Augment::NoSuchType":{"defs":{"package-kind":"<p><pre><code>method package-kind(--> Str:D)</code></pre></p><p>Returns the kind of package (class, grammar) that is being tried to augment</p>"},"prefix":"<p><pre><code>class X::Augment::NoSuchType does X::Comp { }</code></pre></p><p>Thrown when trying to augment a type which doesn't exist.</p><p>For example</p><p><pre><code>use MONKEY-TYPING;\naugment class NoSuch { }\n</code></pre></p><p>dies with</p><p><pre><code>You tried to augment class NoSuch, but it does not exist\n</code></pre></p>","name":"X::Augment::NoSuchType"},"Junction":{"defs":{"new":"<p>Defined as:</p><p><pre><code>multi method new(Junction: \\values, Str :$type!)\nmulti method new(Junction: Str:D \\type, \\values)</code></pre></p><p>Constructor to define a new Junction from the type that defines de Junction and a set of values.</p><p><pre><code>my $j = Junction.new(<Þor Oðinn Loki>, type => \"all\");\nmy $n = Junction.new( \"one\", 1..6 )</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Junction:D:)</code></pre></p><p>Autothreads the .Str method over its elements and returns results as a Junction. Output methods that use .Str method (print and put) are special-cased to autothread junctions, despite being able to accept a Mu type.</p>","gist":"<p>Defined as:</p><p><pre><code>multi method gist(Junction:D:)</code></pre></p><p>Collapses the Junction and returns a Str composed of the type of the junction and the gists of its components:</p><p><pre><code><a 42 c>.all.say; # OUTPUT: «all(a, 42, c)␤»</code></pre></p>","perl":"<p>Defined as:</p><p><pre><code>multi method perl(Junction:D:)</code></pre></p><p>Collapses the Junction and returns a Str composed of perls of its components that evaluates to the equivalent Junction with equivalent components:</p><p><pre><code><a 42 c>.all.perl.put; # OUTPUT: «all(\"a\", IntStr.new(42, \"42\"), \"c\")␤»</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(Junction:D:)</code></pre></p><p>Collapses the Junction and returns a single Boolean value according to the type and the values it holds. Every element is transformed to Bool.</p><p><pre><code>my $n = Junction.new( \"one\", 1..6 );\nsay $n.Bool;                         # OUTPUT: «False␤»\n</code></pre></p><p>All elements in this case are converted to True, so it's false to assert that only one of them is.</p><p><pre><code>my $n = Junction.new( \"one\", <0 1> );\nsay $n.Bool;                         # OUTPUT: «True␤»\n</code></pre></p><p>Just one of them is truish in this case, 1, so the coercion to Bool returns True.</p>","defined":"<p>Defined as:</p><p><pre><code>multi method defined(Junction:D:)</code></pre></p><p>Checks for definedness instead of Boolean values.</p><p><pre><code>say ( 3 | Str).defined ;   # OUTPUT: «True␤»\nsay (one 3, Str).defined;  # OUTPUT: «True␤»\nsay (none 3, Str).defined; # OUTPUT: «False␤»</code></pre></p><p>Failures are also considered non-defined:</p><p><pre><code>my $foo=Failure.new;\nsay (one 3, $foo).defined; # OUTPUT: «True␤»</code></pre></p><p>Since 6.d, this method will autothread.</p>","&infix:<~>":"<p>Defined as:</p><p><pre><code>multi sub infix:<~>(Str:D $a, Junction:D $b)\nmulti sub infix:<~>(Junction:D $a, Str:D $b)\nmulti sub infix:<~>(Junction:D \\a, Junction:D \\b)</code></pre></p><p>The infix ~ concatenation can be used to merge junctions into a single one or merge Junctions with strings. The resulting junction will have all elements merged as if they were joined into a nested loop:</p><p><pre><code>my $odd  = 1|3|5;\nmy $even = 2|4|6;\n\nmy $merged = $odd ~ $even;\nsay $merged; #OUTPUT: «any(12, 14, 16, 32, 34, 36, 52, 54, 56)␤»\n\nsay \"Found 34!\" if 34 == $merged; #OUTPUT: «Found 34!␤»\nmy $prefixed = \"0\" ~ $odd;\nsay \"Found 03\" if \"03\" == $prefixed; #OUTPUT: «Found 03!␤»\n\nmy $postfixed = $odd ~ \"1\";\nsay \"Found 11\" if 11 == $postfixed; #OUTPUT: «Found 11!␤»\n</code></pre></p><p>On the other hand, the versions of ~ that use a string as one argument will just concatenate the string to every member of the Junction, creating another Junction with the same number of elements.</p>"},"prefix":"<p><pre><code>class Junction is Mu { }</code></pre></p><p>A junction is an unordered composite value of zero or more values. Junctions autothread over many operations, which means that the operation is carried out for each junction element (also known as eigenstate), and the result is junction of the return values of all those operators.</p><p>Junctions collapse into a single value in boolean context, so when used in a conditional, a negation or an explicit coercion to Bool through the so or ? prefix operators. The semantics of this collapse depend on the junction type, which can be all, any, one or none.</p><table class='sections'><tr><th>type</th><th>constructor</th><th>operator</th><th>True if ...</th></tr>\n<tr><td>all</tr><td>all</tr><td>&</tr><td>no value evaluates to False</tr></tr>\n<tr><td>any</tr><td>any</tr><td>|</tr><td>at least one value evaluates to True</tr></tr>\n<tr><td>one</tr><td>one</tr><td>^</tr><td>exactly one value evaluates to True</tr></tr>\n<tr><td>none</tr><td>none</tr><td></tr><td>no value evaluates to True</tr></tr>\n</table><p>As the table shows, in order to create junctions, you use the string that represents the type followed by any object, or else call .all, .none or .one on the object.</p><p><pre><code>say so 3 == (1..30).one;         # OUTPUT: «True␤»\nsay so (\"a\" ^ \"b\" ^ \"c\") eq \"a\"; # OUTPUT: «True␤»</code></pre></p><p>Junctions are very special objects. They fall outside the Any hierarchy, being only, as any other object, subclasses of Mu. That enables a feature for most methods: autothreading. Autothreading happens when a junction is bound to a parameter of a code object that doesn't accept values of type Junction. Instead of producing an error, the signature binding is repeated for each value of the junction.</p><p>Example:</p><p><pre><code>my $j = 1|2;\nif 3 == $j + 1 {\n    say 'yes';\n}</code></pre></p><p>First autothreads over the infix:<+>  operator, producing the Junction 2|3. The next autothreading step is over infix:<==> , which produces False|True. The if conditional evaluates the junction in boolean context, which collapses it to True. So the code prints yes\\n.</p><p>The type of a Junction does not affect the number of items in the resultant Junction after autothreading. For example, using a one Junction during Hash key lookup, still results in a Junction with several items. It is only in boolean context would the type of the Junction come into play:</p><p><pre><code>my %h = :42foo, :70bar;\nsay    %h{one <foo meow>}:exists; # OUTPUT: «one(True, False)␤»\nsay so %h{one <foo meow>}:exists; # OUTPUT: «True␤»\nsay    %h{one <foo  bar>}:exists; # OUTPUT: «one(True, True)␤»\nsay so %h{one <foo  bar>}:exists; # OUTPUT: «False␤»</code></pre></p><p>Note that the compiler is allowed, but not required, to parallelize autothreading (and Junction behavior in general), so it is usually an error to autothread junctions over code with side effects.</p><p>Autothreading implies that the function that's autothreaded will also return a Junction of the values that it would usually return.</p><p><pre><code>(1..3).head( 2|3 ).say; # OUTPUT: «any((1 2), (1 2 3))␤»</code></pre></p><p>Since .head returns a list, the autothreaded version returns a Junction of lists.</p><p><pre><code>(1..3).contains( 2&3 ).say; # OUTPUT: «all(True, True)␤»</code></pre></p><p>Likewise, .contains returns a Boolean; thus, the autothreaded version returns a Junction of Booleans. In general, all methods and routines that take an argument of type T and return type TT, will also accept junctions of T, returning junctions of TT.</p><p>Implementations are allowed to short-circuit Junctions. For example one or more routine calls (a(), b(), or c()) in the code below might not get executed at all, if the result of the conditional has been fully determined from routine calls already performed (only one truthy return value is enough to know the entire Junction is true):</p><p><pre><code>if a() | b() | c() {\n    say \"At least one of the routines was called and returned a truthy value\"\n}\n</code></pre></p><p>Junctions are meant to be used as matchers in boolean context; introspection of junctions is not supported. If you feel the urge to introspect a junction, use a Set or a related type instead.</p><p>Usage examples:</p><p><pre><code>my @list = <1 2 \"Great\">;\n@list.append(True).append(False);\nmy @bool_or_int = grep Bool|Int, @list;\n\nsub is_prime(Int $x) returns Bool {\n    # 'so' is for boolean context\n    so $x %% none(2..$x.sqrt);\n}\nmy @primes_ending_in_1 = grep &is_prime & / 1$ /, 2..100;\nsay @primes_ending_in_1;        # OUTPUT: «[11 31 41 61 71]␤»\n\nmy @exclude = <~ .git>;\nfor dir(\".\") { say .Str if .Str.ends-with(none @exclude) }</code></pre></p><p>Special care should be taken when using all with arguments that may produce an empty list:</p><p><pre><code>my @a = ();\nsay so all(@a) # True, because there are 0 False's</code></pre></p><p>To express \"all, but at least one\", you can use @a && all(@a)</p><p><pre><code>my @a = ();\nsay so @a && all(@a);   # OUTPUT: «False␤»</code></pre></p><p>Negated operators are special-cased when it comes to autothreading. $a !op $b is rewritten internally as !($a op $b). The outer negation collapses any junctions, so the return value always a plain Bool.</p><p><pre><code>my $word = 'yes';\nmy @negations = <no none never>;\nif $word !eq any @negations {\n    say '\"yes\" is not a negation';\n}</code></pre></p><p>Note that without this special-casing, an expression like $word ne any @words would always evaluate to True for non-trivial lists on one side.</p><p>For this purpose, infix:<ne>  counts as a negation of infix:<eq> .</p><p>In general it is more readable to use a positive comparison operator and a negated junction:</p><p><pre><code>my $word = 'yes';\nmy @negations = <no none never>;\nif $word eq none @negations {\n    say '\"yes\" is not a negation';\n}</code></pre></p>","name":"Junction"},"X::Seq::Consumed":{"defs":{},"prefix":"<p><pre><code>class X::Seq::Consumed is Exception { }</code></pre></p><p>This exception is thrown when a piece of code tries to reuse a Seq which has already been iterated.</p>","name":"X::Seq::Consumed"},"NFKD":{"name":"NFKD","prefix":"<p><pre><code>class NFKD is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form KD. It is created by Compatibility Decomposition. For more information on what this means, see Unicode TR15.</p>","defs":{}},"Whatever":{"prefix":"<p><pre><code>class Whatever { }</code></pre></p><p>Whatever is a class whose objects don't have any explicit meaning; it gets its semantics from other routines that accept Whatever-objects as markers to do something special. Using the * literal as an operand creates a Whatever object.</p><p>Much of *'s charm comes from Whatever-currying. When * is used in term position, that is, as an operand, in combination with most operators, the compiler will transform the expression into a closure of type WhateverCode, which is actually a Block that can be used wherever Callables are accepted.</p><p><pre><code>my $c = * + 2;          # same as   -> $x { $x + 2 };\nsay $c(4);              # OUTPUT: «6␤»</code></pre></p><p>Multiple * in one expression generate closures with as many arguments:</p><p><pre><code>my $c = * + *;          # same as   -> $x, $y { $x + $y }</code></pre></p><p>Using * in complex expressions will also generate closures:</p><p><pre><code>my $c = 4 * * + 5;      # same as   -> $x { 4 * $x + 5 }</code></pre></p><p>Calling a method on * also creates a closure:</p><p><pre><code><a b c>.map: *.uc;      # same as    <a b c>.map: -> $char { $char.uc }\n</code></pre></p><p>As mentioned before, not all operators and syntactic constructs curry * (or Whatever-stars) to WhateverCode. In the following cases, * will remain a Whatever object.</p><table class='sections'><tr><th>Exception</th><th>Example</th><th>What it does</th></tr>\n<tr><td>comma</tr><td>1, *, 2</tr><td>generates a List with a * element</tr></tr>\n<tr><td>range operators</tr><td>1 .. *</tr><td>Range.new(:from(1), :to(*));</tr></tr>\n<tr><td>series operator</tr><td>1 ... *</tr><td>infinite list</tr></tr>\n<tr><td>assignment</tr><td>$x = *</tr><td>assign * to $x</tr></tr>\n<tr><td>binding</tr><td>$x := *</tr><td>bind * to $x</tr></tr>\n<tr><td>list repetition</tr><td>1 xx *</tr><td>generates an infinite list</tr></tr>\n</table><p>The range operators are handled specially. They do not curry with Whatever-stars, but they do curry with WhateverCode</p><p><pre><code>say (1..*).^name;       # OUTPUT: «Range␤»\nsay ((1..*-1)).^name;   # OUTPUT: «WhateverCode␤»</code></pre></p><p>This allows all these constructs to work:</p><p><pre><code>.say for 1..*;          # infinite loop\n</code></pre></p><p>and</p><p><pre><code>my @a = 1..4;\nsay @a[0..*];           # OUTPUT: «(1 2 3 4)␤»\nsay @a[0..*-2];         # OUTPUT: «(1 2 3)␤»</code></pre></p><p>Because Whatever-currying is a purely syntactic compiler transform, you will get no runtime currying of stored Whatever-stars into WhateverCodes.</p><p><pre><code>my $x = *;\n$x + 2;   # Not a closure, dies because it can't coerce $x to Numeric\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Multi::NoMatch: Cannot resolve caller Numeric(Whatever: );\n# none of these signatures match:␤\n# (Mu:U \\v: *%_)»\n</code></pre></p><p>The use cases for stored Whatever-stars involve those curry-exception cases mentioned above. For example, if you want an infinite series by default.</p><p><pre><code>my $max    = potential-upper-limit() // *;\nmy $series = known-lower-limit() ... $max;\n</code></pre></p><p>A stored * will also result in the generation of a WhateverCode in the specific case of smartmatch. Note that this is not actually the stored * which is being curried, but rather the * on the left-hand side.</p><p><pre><code>my $constraint           = find-constraint() // *;\nmy $maybe-always-matcher = * ~~ $constraint;\n</code></pre></p><p>If this hypothetical find-constraint were to have found no constraint, $maybe-always-matcher would evaluate to True for anything.</p><p><pre><code>$maybe-always-matcher(555);      # True\n$maybe-always-matcher(Any);      # True\n</code></pre></p><p>HyperWhatever's functionality is similar to Whatever, except it refers to multiple values, instead of a single one.</p>","defs":{"ACCEPTS":"<p><pre><code>multi method ACCEPTS(Whatever:D: Mu $other)\nmulti method ACCEPTS(Whatever:U: Mu $other)</code></pre></p><p>If the invocant is an instance, always returns True. If the invocant is a type object, performs a typecheck.</p><p><pre><code>say 42 ~~ (*);       # OUTPUT: «True␤»\nsay 42 ~~ Whatever;  # OUTPUT: «False␤»</code></pre></p>"},"name":"Whatever"},"ValueObjAt":{"name":"ValueObjAt","defs":{},"prefix":"<p><pre><code>class ValueObjAt is ObjAt { }</code></pre></p><p>A subclass of ObjAt that should be used to indicate that a class produces objects that are value types (in other words: are immutable after they have been initialized.</p><p><pre><code>my %h = a => 42;        # mutable Hash\nsay %h.WHICH;           # OUTPUT: «ObjAt.new(\"Hash|1402...888\")␤»\n\nmy %m is Map = a => 42; # immutable Map\nsay %m.WHICH;           # OUTPUT: «ValueObjAt.new(\"Map|AAF...09F61F\")␤»</code></pre></p><p>If you create a class that should be considered a value type, you should add a WHICH method to that class that returns a ValueObjAt object, for instance:</p><p><pre><code>class YourClass {\n    has $.foo;  # note these are not mutable\n    has $.bar;\n\n    method WHICH() {\n        ValueObjAt.new(\"YourClass|$!foo|$!bar\");\n    }\n}</code></pre></p><p>Note that it is customary to always start the identifying string with the name of the object, followed by a \"|\". This to prevent confusion with other classes that may generate similar string values: the name of the class should then be enough of a differentiator to prevent collisions.</p>"},"NFC":{"name":"NFC","defs":{},"prefix":"<p><pre><code>class NFC is Uni {}</code></pre></p><p>A Codepoint string in Unicode Normalization Form C. It is created by Canonical Decomposition, followed by Canonical Composition. For more information on what this means, see Unicode TR15.</p>"},"Proxy":{"name":"Proxy","prefix":"<p><pre><code>class Proxy {}</code></pre></p><p>A Proxy is an object that allows you to set a hook that executes whenever a value is retrieved from a container (FETCH) or when it is set (STORE). Please note that Proxy can introduce mutability at places where it would break behavior, e.g. in Hash keys.</p><p>To create a container that returns twice what was stored in it, you do something like this:</p><p><pre><code>sub double() is rw {\n    my $storage = 0;\n    Proxy.new(\n        FETCH => method ()     { $storage * 2    },\n        STORE => method ($new) { $storage = $new },\n    )\n }\n my $doubled := double();\n $doubled = 4;\n say $doubled;       # OUTPUT: «8␤»</code></pre></p>","defs":{}},"Semaphore":{"prefix":"<p><pre><code>class Semaphore { }</code></pre></p><p>Protect your shared code, data or device access using semaphores. An example is a printer manager managing a pool of printers without the need of storing print jobs when all printers are occupied. The next job is just blocked until a printer becomes available.</p><p><pre><code>class print-manager {\n  has Array $!printers;\n  has Semaphore $!print-control;\n\n  method BUILD( Int:D :$nbr-printers ) {\n    for ^$nbr-printers -> $pc {\n      $!printers[$pc] = { :name{\"printer-$pc\"} };\n    }\n\n    $!print-control .= new($nbr-printers);\n  }\n\n  method find-available-printer-and-print-it($job) { say \"Is printed!\"; }\n\n  method print( $print-job ) {\n    $!print-control.acquire;\n\n    self.find-available-printer-and-print-it($print-job);\n\n    $!print-control.release;\n  }\n}</code></pre></p><p>Another example is a protection around code updating sensitive data. In such a case the semaphore is typically initialized to 1.</p><p>It is important to have a release on every exit of your program! While this is obvious, it is easy to fall in traps such as throwing an exception caused by some event. When the program dies there is no problem. When the exception is caught your program might eventually come back to the acquire method and will hang indefinitely.</p>","defs":{"new":"<p><pre><code>method new( int $permits )</code></pre></p><p>Initialize the semaphore with the number of permitted accesses. E.g. when set to 2, program threads can pass the acquire method twice until it blocks on the third time acquire is called.</p>","try_acquire":"<p><pre><code>method try_acquire(--> Bool)</code></pre></p><p>Same as acquire but will not block. Instead it returns True if access is permitted or False otherwise.</p>","acquire":"<p><pre><code>method acquire()</code></pre></p><p>Acquire access. When other threads have called the method before and the number of permits are used up, the process blocks until threads passed before releases the semaphore.</p>"},"name":"Semaphore"},"IO::Spec::Unix":{"defs":{"abs2rel":"<p>Defined as:</p><p><pre><code>method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)</code></pre></p><p>Returns a string that represents $path, but relative to $base path. Both $path and $base may be relative paths. $base defaults to $*CWD.</p>","path":"<p>Defined as:</p><p><pre><code>method path(--> Seq:D)</code></pre></p><p>Splits the value of %*ENV<PATH> on colons (\":\"), replaces empty parts with \".\", and returns a Seq with each of the resultant parts. Returns an empty Seq if %*ENV<PATH> is not set or is an empty string.</p><p><pre><code>%*ENV<PATH> = 'foo:bar/ber::foo:';\nIO::Spec::Unix.path.perl.say;\n# OUTPUT: «(\"foo\", \"bar/ber\", \".\", \"foo\", \".\").Seq␤»</code></pre></p>","rootdir":"<p>Defined as:</p><p><pre><code>method rootdir(--> Str:D)</code></pre></p><p>Returns string '/', representing root directory.</p>","splitpath":"<p>Defined as:</p><p><pre><code>method splitpath(Cool:D $path, :$nofile --> List:D)</code></pre></p><p>Splits the given $path into a list of 3 strings: volume, dirname, and file. The volume is always an empty string, returned for API compatibility with other IO::Spec types. If :$nofile named argument is set to True, the content of the file string is undefined and should be ignored; this is a means to get a performance boost, as implementations may use faster code path when file is not needed.</p><p><pre><code>IO::Spec::Unix.splitpath('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"\", \"C:\\\\foo/\", \"bar.txt\")␤»\n\nIO::Spec::Unix.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n# OUTPUT: «(\"\", \"C:\\\\foo/bar.txt\", \"\")␤»\n\nIO::Spec::Unix.splitpath('/foo/').perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Unix.splitpath('/foo/', :nofile).perl.say;\n# OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\nIO::Spec::Unix.splitpath('///').perl.say;\n# OUTPUT: «(\"\", \"///\", \"\")␤»\n\nIO::Spec::Unix.splitpath('./').perl.say;\n# OUTPUT: «(\"\", \"./\", \"\")␤»\n\nIO::Spec::Unix.splitpath('.').perl.say;\n# OUTPUT: «(\"\", \"\", \".\")␤»\n\nIO::Spec::Unix.splitpath('').perl.say;\n# OUTPUT: «(\"\", \"\", \"\")␤»\n</code></pre></p>","canonpath":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --> Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem, so no symlinks are followed.</p><p><pre><code>IO::Spec::Unix.canonpath(\"foo//../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Unix.canonpath(\"foo///./../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Unix.canonpath(\"foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «ber␤»</code></pre></p>","basename":"<p>Defined as:</p><p><pre><code>method basename(Str:D $path --> Str:D)</code></pre></p><p>Takes a path as a string and returns a possibly-empty portion after the last slash:</p><p><pre><code>IO::Spec::Unix.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\nIO::Spec::Unix.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\nIO::Spec::Unix.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»</code></pre></p>","rel2abs":"<p>Defined as:</p><p><pre><code>method rel2abs(Str() $path, $base = $*CWD --> Str:D)</code></pre></p><p>Returns a string representing $path converted to absolute path, based at $base, which defaults to $*CWD. If $base is not an absolute path, it will be made absolute relative to $*CWD, unless $*CWD and $base are the same.</p><p><pre><code>say $*CWD;                                  # OUTPUT: «\"/home/camelia\".IO␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo';          # OUTPUT: «/home/camelia/foo␤»\nsay IO::Spec::Unix.rel2abs: './';           # OUTPUT: «/home/camelia␤»\nsay IO::Spec::Unix.rel2abs: 'foo/../../';   # OUTPUT: «/home/camelia/foo/../..␤»\nsay IO::Spec::Unix.rel2abs: '/foo/';        # OUTPUT: «/foo␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo', 'bar';   # OUTPUT: «/home/camelia/bar/foo␤»\nsay IO::Spec::Unix.rel2abs: './', '/bar';   # OUTPUT: «/bar␤»\nsay IO::Spec::Unix.rel2abs: '/foo/', 'bar'; # OUTPUT: «/foo␤»\n\nsay IO::Spec::Unix.rel2abs: 'foo/../../', 'bar';\n# OUTPUT: «/home/camelia/bar/foo/../..␤»\n</code></pre></p>","splitdir":"<p>Defined as:</p><p><pre><code>method splitdir(Cool:D $path --> List:D)</code></pre></p><p>Splits the given $path on slashes.</p><p><pre><code>IO::Spec::Unix.splitdir('C:\\foo/bar.txt').perl.say;\n# OUTPUT: «(\"C:\\\\foo\", \"bar.txt\")␤»\n\nIO::Spec::Unix.splitdir('/foo/').perl.say;\n# OUTPUT: «(\"\", \"foo\", \"\")␤»\n\nIO::Spec::Unix.splitdir('///').perl.say;\n# OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\nIO::Spec::Unix.splitdir('./').perl.say;\n# OUTPUT: «(\".\", \"\")␤»\n\nIO::Spec::Unix.splitdir('.').perl.say;\n# OUTPUT: «(\".\",)␤»\n\nIO::Spec::Unix.splitdir('').perl.say;\n# OUTPUT: «(\"\",)␤»\n</code></pre></p>","dir-sep":"<p>Defined as:</p><p><pre><code>method dir-sep(--> Str:D)</code></pre></p><p>Returns the string \"/\" representing canonical directory separator character.</p><p><pre><code>IO::Spec::Unix.dir-sep.say; # OUTPUT: «/␤»\n</code></pre></p>","catdir":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --> Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Unix.catdir(<foo/bar ber perl>).say; # OUTPUT: «foo/bar/ber/perl␤»</code></pre></p>","is-absolute":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --> Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\"), even if it has combining character on it:</p><p><pre><code>say IO::Spec::Unix.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Unix.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Unix.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","extension":"<p>NOTE: Most users would want to use the higher-level routine IO::Path.extension instead of this lower-level version.</p><p>Defined as:</p><p><pre><code>method extension(Str:D $path --> Str:D)</code></pre></p><p>Takes a string representing a base name and returns the characters after the last dot (\".\"), or empty string if no dots are present. The routine makes no attempt to detect path separators and will return everything after the last dot.</p><p><pre><code>$*SPEC.extension('foo.'      ).perl.say;  # OUTPUT: «\"\"␤»\n$*SPEC.extension('foo.txt'   ).perl.say;  # OUTPUT: «\"txt\"␤»\n$*SPEC.extension('foo.tar.gz').perl.say;  # OUTPUT: «\"gz\"␤»\n$*SPEC.extension('foo'       ).perl.say;  # OUTPUT: «\"\"␤»\n$*SPEC.extension('bar.foo/foo').perl.say; # OUTPUT: «\"foo/foo\"␤»</code></pre></p>","curupdir":"<p>Defined as:</p><p><pre><code>method curupdir()</code></pre></p><p>Returns a none Junction of strings representing the current directory and the \"one directory up\":</p><p><pre><code>say $*SPEC.curupdir;                  # OUTPUT: «none(., ..)␤»\nmy @dirs = <. foo .. bar>;\nsay @dirs.grep(* eq $*SPEC.curupdir); # OUTPUT: «(foo bar)␤»\n</code></pre></p><p>Neither foo nor bar are equal to the representation of the current or parent directory, that is why they are returned by grep.</p>","split":"<p>Defined as:</p><p><pre><code>method split(Cool:D $path --> List:D)</code></pre></p><p>Splits the given $path into \"volume\", \"dirname\", and \"basename\" and returns the result as a List of three Pairs, in that order. The \"volume\" is always an empty string and exists for consistency with other IO::Spec classes.</p><p><pre><code>IO::Spec::Unix.split('C:/foo/bar.txt').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"C:/foo\"), :basename(\"bar.txt\"))␤»\n\nIO::Spec::Unix.split('/foo/').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\nIO::Spec::Unix.split('///').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"/\"))␤»\n\nIO::Spec::Unix.split('./').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Unix.split('.').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\nIO::Spec::Unix.split('').perl.say;\n# OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»\n</code></pre></p>","catfile":"<p>Alias for catdir.</p>","catpath":"<p>Defined as:</p><p><pre><code>method catpath ($, Str:D $part1, Str:D $part2 --> Str:D)</code></pre></p><p>Takes two path fragments and concatenates them, adding or removing a path separator, if necessary. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec|/type/IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Unix.catpath($, 'some/dir', 'and/more').say;\n# OUTPUT: «some/dir/and/more␤»</code></pre></p>","join":"<p>Defined as:</p><p><pre><code>method join ($, Str:D $dir, Str:D $file --> Str:D)</code></pre></p><p>Similar to catpath, takes two path fragments and concatenates them, adding or removing a path separator, if necessary, except it will return just $file if both $dir and $file are string '/' or if $dir is the string '.'. The first argument is ignored (it exists to maintain consistent interface with other IO::Spec types for systems that have volumes).</p><p><pre><code>IO::Spec::Unix.join($, 'foo', 'bar').say; # OUTPUT: «foo/bar␤»\nIO::Spec::Unix.join($, '/', '/').say;     # OUTPUT: «/␤»\nIO::Spec::Unix.join($, '.', 'foo').say;   # OUTPUT: «foo␤»\nsay $*SPEC.join(True,\".\",\"/foo\");         # OUTPUT: «/foo␤»</code></pre></p>","tmpdir":"<p>Defined as:</p><p><pre><code>method tmpdir(--> IO::Path:D)</code></pre></p><p>Attempts to locate a system's temporary directory by checking several typical directories and environmental variables. Uses current directory if no suitable directories are found.</p>","curdir":"<p>Defined as:</p><p><pre><code>method curdir()</code></pre></p><p>Returns a string representing the current directory:</p><p><pre><code>say '.' eq $*SPEC.curdir; # OUTPUT: «True␤»</code></pre></p>","devnull":"<p>Defined as:</p><p><pre><code>method devnull(--> Str:D)</code></pre></p><p>Returns the string \"/dev/null\" representing the \"Null device\":</p><p><pre><code>$*SPEC.devnull.IO.spurt: \"foo bar baz\";\n</code></pre></p>"},"prefix":"<p><pre><code>class IO::Spec::Unix is IO::Spec  { }</code></pre></p><p>On object of this type is available via the variable $*SPEC if the Raku interpreter is running on a Unix-like platform.</p><p>The IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>Beware that no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>","name":"IO::Spec::Unix"},"X::NoDispatcher":{"name":"X::NoDispatcher","prefix":"<p><pre><code>class X::NoDispatcher is Exception { }</code></pre></p><p>When a redispatcher like nextsame is called without being in the dynamic scope of a call where a redispatch is possible, an X::NoDispatcher is thrown.</p><p>For example</p><p><pre><code>nextsame; # In the mainline\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::NoDispatcher: nextsame is not in the dynamic scope of a dispatcher␤»</code></pre></p>","defs":{}},"Failure":{"name":"Failure","defs":{"self":"<p>Defined as:</p><p><pre><code>method self(Failure:D: --> Failure:D)</code></pre></p><p>If the invocant is a handled Failure, returns it as is. If not handled, throws its Exception. Since Mu type provides .self for every class, calling this method is a handy way to explosively filter out Failures:</p><p><pre><code>my $num1 = '♥'.Int;\n# $num1 now contains a Failure object, which may not be desirable\n\nmy $num2 = '♥'.Int.self;\n# .self method call on Failure causes an exception to be thrown\n\nmy $num3 = '42'.Int.self;\n# Int type has a .self method, so here $num3 has `42` in it\n\n(my $stuff = '♥'.Int).so;\nsay $stuff.self; # OUTPUT: «(HANDLED) Cannot convert string to number…»\n# Here, Failure is handled, so .self just returns it as is</code></pre></p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(Failure:D: --> Bool:D)</code></pre></p><p>Returns False, and marks the failure as handled.</p><p><pre><code>sub f() { fail }; my $v = f; say $v.handled; $v.Bool; say $v.handled;\n# OUTPUT: «False␤\n# True␤»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture if the invocant is a type object or a handled Failure. Otherwise, throws the invocant's exception.</p>","handled":"<p>Defined as:</p><p><pre><code>method handled(Failure:D: --> Bool:D)</code></pre></p><p>Returns True for handled failures, False otherwise.</p><p><pre><code>sub f() { fail }; my $v = f; say $v.handled; # OUTPUT: «False␤»</code></pre></p><p>The handled method is an lvalue, which means you can also use it to set the handled state:</p><p><pre><code>sub f() { fail }\nmy $v = f;\n$v.handled = True;\nsay $v.handled; # OUTPUT: «True␤»</code></pre></p>","exception":"<p>Defined as:</p><p><pre><code>method exception(Failure:D: --> Exception)</code></pre></p><p>Returns the Exception object that the failure wraps.</p><p><pre><code>sub failer() { fail };\nmy $failure = failer;\nmy $ex = $failure.exception;\nput \"$ex.^name(): $ex\";\n# OUTPUT: «X::AdHoc: Failed␤»</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>method new(Failure:D: $payload --> Failure)</code></pre></p><p>Returns a new Failure instance with the given payload. The latter can be either an Exception or a payload for an Exception. A typical payload would be a Str with an error message. A list of payloads is also accepted.</p><p><pre><code>my $e = Failure.new(now.DateTime, 'WELP‼');\nsay $e;\nCATCH{ default { say .^name, ': ', .Str } }\n# OUTPUT: «X::AdHoc: 2017-09-10T11:56:05.477237ZWELP‼␤»</code></pre></p>"},"prefix":"<p><pre><code>class Failure is Nil { }</code></pre></p><p>A Failure is a soft or unthrown Exception, usually generated by calling &fail. It acts as a wrapper around an Exception object.</p><p>Sink (void) context causes a Failure to throw, i.e. turn into a normal exception. The use fatal pragma causes this to happen in all contexts within the pragma's scope. Inside try blocks, use fatal is automatically set, and you can disable it with no fatal.</p><p>That means that Failures are generally only useful in cases of code that normally would produce an rvalue; Failures are more or less equivalent to Exceptions in code that will frequently be called in sink context (i.e., for its side-effects, such as with say).</p><p>Similarly, you should generally use &fail only inside code that is normally expected to return something.</p><p>Checking a Failure for truth (with the Bool method) or definedness (with the defined method) marks the failure as handled, and causes it not to throw in sink context anymore.</p><p>You can call the handled method to check if a failure has been handled.</p><p>Calling methods on unhandled failures propagates the failure. The specification says the result is another Failure, in Rakudo it causes the failure to throw.</p><p>Because a Failure is Nil, which is undefined, a common idiom for safely executing code that may fail uses a with/else statement:</p><p><pre><code>sub may_fail( --> Numeric:D ) {\n  my $value = (^10).pick || fail \"Zero is unacceptable\";\n  fail \"Odd is also not okay\" if $value % 2;\n  return $value;\n}\n\nwith may_fail() -> $value { # defined, so didn't fail\n  say \"I know $value isn't zero or odd.\"\n} else { # undefined, so failed, and the Failure is the topic\n  say \"Uh-oh: {.exception.message}.\"\n}\n</code></pre></p>"},"IO::Pipe":{"name":"IO::Pipe","defs":{"IO":"<p>Defined as:</p><p><pre><code>method IO(IO::Pipe: --> IO::Path:U)</code></pre></p><p>Returns an IO::Path type object.</p>","path":"<p>Defined as:</p><p><pre><code>method path(IO::Pipe: --> IO::Path:U)</code></pre></p><p>Returns an IO::Path type object.</p>","close":"<p>Defined as:</p><p><pre><code>method close(IO::Pipe: --> Proc:D)</code></pre></p><p>Closes the pipe and returns Proc object from which the pipe originates.</p>"},"prefix":"<p><pre><code>class IO::Pipe is IO::Handle {}</code></pre></p><p>An IO::Pipe object closely corresponds to a UNIX pipe. It has one end where it consumes string or binary data, and another where it reproduces the same data. It is buffered, so that a write without a read doesn't immediately block.</p><p>Pipes can be easily constructed with sub run and Proc::Async.new.</p>"},"X::Proc::Async::AlreadyStarted":{"prefix":"<p><pre><code>class X::Proc::Async::AlreadyStarted is Exception {}</code></pre></p><p>When you call start twice on the same Proc::Async object, the second invocation will die with an X::Proc::Async::AlreadyStarted exception.</p><p><pre><code>my $proc = Proc::Async.new(\"echo\");\n$proc.start;\n$proc.start;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Proc::Async::AlreadyStarted: Process has already been started␤»</code></pre></p>","defs":{},"name":"X::Proc::Async::AlreadyStarted"},"CX::Proceed":{"name":"CX::Proceed","prefix":"<p><pre><code>role CX::Proceed does X::Control { }</code></pre></p><p>A control exception to be used when proceed is used within when or default blocks.</p>","defs":{}},"Metamodel::Finalization":{"prefix":"<p></p><p><pre><code>role Metamodel::Finalization { ... }</code></pre></p><p>This role takes care that DESTROY submethods are called (if they exist) when an object is garbage-collected.</p>","defs":{"setup_finalization":"<p><pre><code>method setup_finalization(Metamodel::Finalization:D: $obj)</code></pre></p><p>Collects the DESTROY submethods from this class and all its superclasses, and marks the class as needing action on garbage collection.</p><p>A metamodel for a kind that implements finalization semantics must call this method at type composition time.</p>"},"name":"Metamodel::Finalization"},"ThreadPoolScheduler":{"name":"ThreadPoolScheduler","prefix":"<p><pre><code>class ThreadPoolScheduler does Scheduler {}\n</code></pre></p><p>The ThreadPoolScheduler has a range of number of threads that it maintains, and it distributes work among those threads. When the upper limit of threads isn't reached yet, and there is work pending, it spawns new threads to handle the work.</p>","defs":{}},"X::Placeholder::Mainline":{"prefix":"<p><pre><code>class X::Placeholder::Mainline is X::Placeholder::Block { }</code></pre></p><p>Thrown when a placeholder variable is used in the mainline, i.e. outside of any explicit block.</p><p>For example</p><p><pre><code>$^x;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot use placeholder parameter $^x outside of a sub or block\n</code></pre></p><p>Note that this error can also occur when you think something is a block, but it really is a postcircumfix:<{ }>, for example</p><p><pre><code>my %h;\nsay %h{ $^x };\n#     ^^^^^^^  not a block, so $^x is part of the mainline\n</code></pre></p>","defs":{},"name":"X::Placeholder::Mainline"},"X::Constructor::Positional":{"defs":{},"prefix":"<p><pre><code>class X::Constructor::Positional is Exception { }</code></pre></p><p>Thrown from Mu.new when positional arguments are passed to it.</p><p>For example</p><p><pre><code>class A { };\nA.new(2, 3);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Constructor::Positional: Default constructor for 'A' only takes named arguments␤»</code></pre></p>","name":"X::Constructor::Positional"},"X::Export::NameClash":{"name":"X::Export::NameClash","defs":{},"prefix":"<p><pre><code>class X::Export::NameClash does X::Comp { }</code></pre></p><p>Compile time error thrown when a symbol is exported twice.</p><p>For example</p><p><pre><code>sub f() is export { };\n{\n    sub f() is export { }\n}\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nA symbol '&f' has already been exported\n</code></pre></p>"},"Distribution::Locally":{"name":"Distribution::Locally","defs":{"prefix":"<p>A prefix path to be used in conjuncture with the paths found in the metadata.</p>"},"prefix":"<p><pre><code>role Distribution::Locally does Distribution { }</code></pre></p><p>Provides read access to specific files pointed at by a distributions metadata, providing the Distribution#method_content method for Distribution::Path and Distribution::Hash.</p>"},"Pair":{"defs":{"invert":"<p>Defined as:</p><p><pre><code>method invert(Pair:D: --> Seq:D)</code></pre></p><p>Returns a Seq. If the .value of the invocant is NOT an Iterable, the Seq will contain a single Pair whose .key is the .value of the invocant and whose .value is the .key of the invocant:</p><p><pre><code>:foo<bar>.invert.perl.say; # OUTPUT: «(:bar(\"foo\"),).Seq»</code></pre></p><p>If invocant's .value is an Iterable, the returned Seq will contain the same number of Pairs as items in the .value, with each of those items a .key of a pair and the .key of the invocant the .value of that pair:</p><p><pre><code>:foo<Perl is great>.invert.perl.say;\n# OUTPUT: «(:Perl(\"foo\"), :is(\"foo\"), :great(\"foo\")).Seq»\n\n:foo{ :42a, :72b }.invert.perl.say;\n# OUTPUT: «((:a(42)) => \"foo\", (:b(72)) => \"foo\").Seq»</code></pre></p><p>To perform the exact .key and .value swap, use .antipair method.</p>","kv":"<p>Defined as:</p><p><pre><code>multi method kv(Pair:D: --> List:D)</code></pre></p><p>Returns a two-element List with the key and value parts of Pair, in that order. This method is a special case of the same-named method on Hash, which returns all its entries as a list of keys and values.</p><p><pre><code>my $p = (Perl => 6);\nsay $p.kv[0]; # OUTPUT: «Perl␤»\nsay $p.kv[1]; # OUTPUT: «6␤»</code></pre></p>","freeze":"<p>Defined as:</p><p><pre><code>method freeze(Pair:D:)</code></pre></p><p>Makes the value of the Pair read-only, by removing it from its Scalar container, and returns it.</p><p><pre><code>my $str = \"apple\";\nmy $p = Pair.new('key', $str);\n$p.value = \"orange\";              # this works as expected\n$p.say;                           # OUTPUT: «key => orange␤»\n$p.freeze.say;                    # OUTPUT: «orange␤»\n$p.value = \"a new apple\";         # Fails\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Assignment::RO: Cannot modify an immutable Str (apple)␤»</code></pre></p><p>NOTE: this method is deprecated as of 6.d language version. Instead, create a new Pair, with a decontainerized key/value.</p><p><pre><code>$p.=Map.=head.say;                                    # OUTPUT: «orange␤»\n</code></pre></p>","fmt":"<p>Defined as:</p><p><pre><code>multi method fmt(Pair:D: Str:D $format --> Str:D)</code></pre></p><p>Takes a format string, and returns a string the key and value parts of the Pair formatted. Here's an example:</p><p><pre><code>my $pair = :Earth(1);\nsay $pair.fmt(\"%s is %.3f AU away from the sun\")\n# OUTPUT: «Earth is 1.000 AU away from the sun␤»</code></pre></p><p>For more about format strings, see sprintf.</p>","antipair":"<p>Defined as:</p><p><pre><code>method antipair(--> Pair:D)</code></pre></p><p>Returns a new Pair object with key and value exchanged.</p><p><pre><code>my $p = (6 => 'Perl').antipair;\nsay $p.key;         # OUTPUT: «Perl␤»\nsay $p.value;       # OUTPUT: «6␤»</code></pre></p>","&infix:<cmp>":"<p>Defined as:</p><p><pre><code>multi sub infix:<cmp>(Pair:D, Pair:D)</code></pre></p><p>The type-agnostic comparator; compares two Pairs. Compares first their key parts, and then compares the value parts if the keys are equal.</p><p><pre><code>my $a = (Apple => 1);\nmy $b = (Apple => 2);\nsay $a cmp $b; # OUTPUT: «Less␤»</code></pre></p>","antipairs":"<p>Defined as:</p><p><pre><code>multi method antipairs(Pair:D:)</code></pre></p><p>Returns a List containing the antipair of the invocant.</p><p><pre><code>my $p = (6 => 'Perl').antipairs;\nsay $p.^name;                                     # OUTPUT: «List␤»\nsay $p.first;                                     # OUTPUT: «Perl => 6␤»\nsay $p.first.^name;                               # OUTPUT: «Pair␤»</code></pre></p>","values":"<p>Defined as:</p><p><pre><code>multi method values(Pair:D: --> List:D)</code></pre></p><p>Returns a List containing the value of the invocant.</p><p><pre><code>say ('Perl' => 6).values;                         # OUTPUT: «(6)␤»</code></pre></p>","pairs":"<p>Defined as:</p><p><pre><code>multi method pairs(Pair:D:)</code></pre></p><p>Returns a list of one Pair, namely this one.</p><p><pre><code>my $p = (Perl => 6);\nsay $p.pairs.^name; # OUTPUT: «List␤»\nsay $p.pairs[0];    # OUTPUT: «Perl => 6␤»</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>multi method new(Pair: Mu  $key, Mu  $value)\nmulti method new(Pair: Mu :$key, Mu :$value)</code></pre></p><p>Constructs a new Pair object.</p>","keys":"<p>Defined as:</p><p><pre><code>multi method keys(Pair:D: --> List:D)</code></pre></p><p>Returns a List containing the key of the invocant.</p><p><pre><code>say ('Perl' => 6).keys;                           # OUTPUT: «(Perl)␤»</code></pre></p>","key":"<p>Defined as:</p><p><pre><code>multi method key(Pair:D:)</code></pre></p><p>Returns the key part of the Pair.</p><p><pre><code>my $p = (Perl => 6);\nsay $p.key; # OUTPUT: «Perl␤»</code></pre></p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(Pair:D $: %topic)\nmulti method ACCEPTS(Pair:D $: Pair:D $topic)\nmulti method ACCEPTS(Pair:D $: Mu $topic)</code></pre></p><p>If %topic is an Associative, looks up the value using invocant's key in it and checks invocant's value .ACCEPTS that value:</p><p><pre><code>say %(:42a) ~~ :42a; # OUTPUT: «True␤»\nsay %(:42a) ~~ :10a; # OUTPUT: «False␤»</code></pre></p><p>If $topic is another Pair, checks the invocant's value .ACCEPTS the $topic's value. Note that the keys are not considered and can be different:</p><p><pre><code>say :42a ~~ :42a; # OUTPUT: «True␤»\nsay :42z ~~ :42a; # OUTPUT: «True␤»\nsay :10z ~~ :42a; # OUTPUT: «False␤»</code></pre></p><p>If $topic is any other value, the invocant Pair's key is treated as a method name. This method is called on $topic, the boolean result of which is compared against the invocant Pair's boolean value. For example, primality can be tested using smartmatch:</p><p><pre><code>say 3 ~~ :is-prime;             # OUTPUT: «True␤»\nsay 3 ~~  is-prime => 'truthy'; # OUTPUT: «True␤»\nsay 4 ~~ :is-prime;             # OUTPUT: «False␤»</code></pre></p><p>This form can also be used to check Bool values of multiple methods on the same object, such as IO::Path, by using Junctions:</p><p><pre><code>say \"foo\" .IO ~~ :f & :rw; # OUTPUT: «False␤»\nsay \"/tmp\".IO ~~ :!f;      # OUTPUT: «True␤»\nsay \".\"   .IO ~~ :f | :d;  # OUTPUT: «True␤»</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Pair:D: --> Str:D)</code></pre></p><p>Returns a string representation of the invocant formatted as key ~ \\t ~ value.</p><p><pre><code>my $b = eggs => 3;\nsay $b.Str;                                       # OUTPUT: «eggs  3␤»</code></pre></p>","value":"<p>Defined as:</p><p><pre><code>multi method value(Pair:D:) is rw</code></pre></p><p>Returns the value part of the Pair.</p><p><pre><code>my $p = (Perl => 6);\nsay $p.value; # OUTPUT: «6␤»</code></pre></p>"},"prefix":"<p><pre><code>class Pair does Associative {}</code></pre></p><p>Consists of two parts, a key and a value. Pairs can be seen as the atomic units in Hashes, and they are also used in conjunction with named arguments and parameters.</p><p>     There are many syntaxes for creating Pairs:</p><p><pre><code>Pair.new('key', 'value'); # The canonical way\n'key' => 'value';         # this...\n:key<value>;              # ...means the same as this\n:key<value1 value2>;      # But this is  key => <value1 value2>\n:foo(127);                # short for  foo => 127\n:127foo;                  # the same   foo => 127</code></pre></p><p>Note that last form supports Non-ASCII numerics as well:</p><p><pre><code># use MATHEMATICAL DOUBLE-STRUCK DIGIT THREE\nsay (:\uD835\uDFDBmath-three);         # OUTPUT: «math-three => 3␤»</code></pre></p><p>You can also use an identifier-like literal as key; this will not need the quotes as long as it follows the syntax of ordinary identifiers:</p><p><pre><code>(foo => 127)              # the same   foo => 127</code></pre></p><p>Variants of this are</p><p><pre><code>:key;                     # same as   key => True\n:!key;                    # same as   key => False</code></pre></p><p>And this other variant, to be used in routine invocation</p><p><pre><code>sub colon-pair( :$key-value ) {\n    say $key-value;\n}\nmy $key-value = 'value';\ncolon-pair( :$key-value );               # OUTPUT: «value␤»\ncolon-pair( key-value => $key-value );   # OUTPUT: «value␤»\n</code></pre></p><p> Colon pairs can be chained without a comma to create a List of Pairs. Depending on context you may have to be explicit when assigning colon lists.</p><p><pre><code>sub s(*%h){ say %h.perl };\ns :a1:b2;\n# OUTPUT: «{:a1, :b2}␤»\n\nmy $manna = :a1:b2:c3;\nsay $manna.^name;\n# OUTPUT: «Pair␤»\n\n$manna = (:a1:b2:c3);\nsay $manna.^name;\n# OUTPUT: «List␤»</code></pre></p><p>Any variable can be turned into a Pair of its name and its value.</p><p><pre><code>my $bar = 10;\nmy $p   = :$bar;\nsay $p; # OUTPUT: «bar => 10␤»</code></pre></p><p>It is worth noting that when assigning a Scalar as value of a Pair the value holds the container of the value itself. This means that it is possible to change the value from outside of the Pair itself:</p><p><pre><code>my $v = 'value A';\nmy $pair = a => $v;\n$pair.say;  # OUTPUT: «a => value A␤»\n\n$v = 'value B';\n$pair.say;  # OUTPUT: «a => value B␤»\n</code></pre></p><p>Please also note that this behavior is totally unrelated to the way used to build the Pair itself (i.e., explicit usage of new, use of colon, fat arrow), as well as if the Pair is bound to a variable.</p><p>It is possible to change the above behavior forcing the Pair to remove the scalar container and to hold the effective value itself via the method freeze:</p><p><pre><code>my $v = 'value B';\nmy $pair = a => $v;\n$pair.freeze;\n$v = 'value C';\n$pair.say; # OUTPUT: «a => value B␤»\n</code></pre></p><p>As Pair implements Associative role, its value can be accessed using Associative subscription operator, however, due to Pair's singular nature, the pair's value will be only returned for the pair's key. Nil object will be returned for any other key. Subscript adverbs such as :exists can be used on Pair.</p><p><pre><code>my $pair = a => 5;\nsay $pair<a>;           # OUTPUT: «5␤»\nsay $pair<a>:exists;    # OUTPUT: «True␤»\nsay $pair<no-such-key>; # OUTPUT: «Nil␤»\n</code></pre></p>","name":"Pair"},"Metamodel::AttributeContainer":{"defs":{"set_rw":"<p><pre><code>method set_rw(Metamodel::AttributeContainer: $obj)</code></pre></p><p>Marks a type whose attributes default to having a write accessor. For example in</p><p><pre><code>class Point is rw {\n    has $.x;\n    has $.y;\n}</code></pre></p><p>The is rw trait on the class calls the set_rw method on the metaclass, making all the attributes implicitly writable, so that you can write;</p><p><pre><code>my $p = Point.new(x => 1, y => 2);\n$p.x = 42;\n</code></pre></p>","add_attribute":"<p><pre><code>method add_attribute(Metamodel::AttributeContainer: $obj, $attribute)</code></pre></p><p>Adds an attribute. $attribute must be an object that supports the methods name, type and package, which are called without arguments. It can for example be of type Attribute.</p>","attributes":"<p><pre><code>method attributes(Metamodel::AttributeContainer: $obj)</code></pre></p><p>Returns a list of attributes. For most Raku types, these will be objects of type Attribute.</p>"},"prefix":"<p><pre><code>role Metamodel::AttributeContainer {}</code></pre></p><p>Classes, roles and grammars can have attributes. Storage and introspection of attributes is implemented by this role.</p>","name":"Metamodel::AttributeContainer"},"Iterable":{"name":"Iterable","defs":{"lazy":"<p>Defined as:</p><p><pre><code>method lazy(--> Iterable)</code></pre></p><p>Returns a lazy iterable wrapping the invocant.</p><p><pre><code>say (1 ... 1000).is-lazy;      # OUTPUT: «False␤»\nsay (1 ... 1000).lazy.is-lazy; # OUTPUT: «True␤»</code></pre></p>","flat":"<p>Defined as:</p><p><pre><code>method flat(--> Iterable)</code></pre></p><p>Returns another Iterable that flattens out all iterables that the first one returns.</p><p>For example</p><p><pre><code>say (<a b>, 'c').elems;         # OUTPUT: «2␤»\nsay (<a b>, 'c').flat.elems;    # OUTPUT: «3␤»</code></pre></p><p>because <a b>  is a List and thus iterable, so  (<a b>, 'c').flat  returns ('a', 'b', 'c'), which has three elems.</p><p>Note that the flattening is recursive, so (((\"a\", \"b\"), \"c\"), \"d\").flat returns (\"a\", \"b\", \"c\", \"d\"), but it does not flatten itemized sublists:</p><p><pre><code>say ($('a', 'b'), 'c').perl;    # OUTPUT: «($(\"a\", \"b\"), \"c\")␤»</code></pre></p>","hyper":"<p>Defined as:</p><p><pre><code>method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4)</code></pre></p><p>Returns another Iterable that is potentially iterated in parallel, with a given batch size and degree of parallelism.</p><p>The order of elements is preserved.</p><p><pre><code>say ([1..100].hyper.map({ $_ +1 }).list);</code></pre></p><p>Use hyper in situations where it is OK to do the processing of items in parallel, and the output order should be kept relative to the input order. See race for situations where items are processed in parallel and the output order does not matter.</p>","iterator":"<p>Defined as:</p><p><pre><code>method iterator(--> Iterator:D)</code></pre></p><p>Method stub that ensures all classes doing the Iterable role have a method iterator.</p><p>It is supposed to return an Iterator.</p><p><pre><code>say (1..10).iterator;</code></pre></p>"},"prefix":"<p><pre><code>role Iterable { }</code></pre></p><p>Iterable serves as an API for objects that can be iterated with for and related iteration constructs, like assignment to a Positional variable.</p><p>Iterable objects nested in other Iterable objects (but not within scalar containers) flatten in certain contexts, for example when passed to a slurpy parameter (*@a), or on explicit calls to flat.</p><p>Its most important aspect is a method stub for iterator.</p><p><pre><code>class DNA does Iterable {\n    has $.chain;\n    method new ($chain where { $chain ~~ /^^ <[ACGT]>+ $$ / } ) {\n        self.bless( :$chain );\n    }\n\n    method iterator(DNA:D:) {\n        $!chain.comb.rotor(3).iterator;\n    }\n}\n\nmy $a := DNA.new('GAATCC');\n.say for $a; # OUTPUT: «(G A A)␤(T C C)␤»\n</code></pre></p><p>This example mixes in the Iterable role to offer a new way of iterating over what is essentially a string (constrained by where to just the four DNA letters). In the last statement, for actually hooks to the iterator role printing the letters in groups of 3.</p>"},"Metamodel::MROBasedMethodDispatch":{"defs":{"can":"<p><pre><code>method can($obj, $name)</code></pre></p><p>Returns the list of methods of that name the object can do.</p>","find_method_qualified":"<p><pre><code>method find_method_qualified($obj, $type, $name)</code></pre></p><p>Given a method name and a type, returns the method from that type. This is used in calls like</p><p><pre><code>self.SomeParentClass::the_method();\n</code></pre></p>","find_method":"<p><pre><code>method find_method($obj, $name, $no_fallback, *%adverbs)</code></pre></p><p>Given a method name, it returns the method object of that name which is closest in the method resolution order (MRO). If no method can be found, it returns a VM-specific sentinel value (typically a low-level NULL value) that can be tested for with a test for definedness:</p><p><pre><code>for <upper-case  uc> {\n    Str.^find_method: $^meth andthen .(\"foo\").say\n        orelse \"method `$meth` not found\".say\n}\n# OUTPUT:\n# method `upper-case` not found\n# FOO</code></pre></p><p>If :no_fallback is supplied, fallback methods are not considered.</p>"},"prefix":"<p><pre><code>role Metamodel::MROBasedMethodDispatch { }</code></pre></p><p>This role implements locating methods based on the method resolution order of related (usually \"super\"/\"parent\") types.</p>","name":"Metamodel::MROBasedMethodDispatch"},"X::Syntax::Comment::Embedded":{"name":"X::Syntax::Comment::Embedded","prefix":"<p><pre><code>class X::Syntax::Comment::Embedded does X::Syntax { }</code></pre></p><p>Syntax error thrown when #` is encountered and it is not followed by an opening curly brace.</p><p>For example</p><p><pre><code>#`\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nOpening bracket is required for #` comment\n</code></pre></p>","defs":{}},"Cool":{"defs":{"tan":"<p>Defined as:</p><p><pre><code>sub tan(Numeric(Cool))\nmethod tan()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, interprets it as radians, returns its tangent.</p><p><pre><code>say tan(3);                 # OUTPUT: «-0.142546543074278␤»\nsay 3.tan;                  # OUTPUT: «-0.142546543074278␤»</code></pre></p>","ords":"<p>Defined as:</p><p><pre><code>sub ords(Str(Cool) $str)\nmethod ords()</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and returns a list of Unicode codepoints for each character.</p><p><pre><code>say \"Camelia\".ords;              # OUTPUT: «67 97 109 101 108 105 97␤»\nsay ords 10;                     # OUTPUT: «49 48␤»</code></pre></p><p>This is the list-returning version of ord. The inverse operation in chrs. If you are only interested in the number of codepoints, codes is a possibly faster option.</p>","acos":"<p>Defined as:</p><p><pre><code>sub acos(Numeric(Cool))\nmethod acos()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, and returns its arc-cosine in radians.</p><p><pre><code>say 1.acos;                 # OUTPUT: «0␤»\nsay acos(-1);               # OUTPUT: «3.14159265358979␤»</code></pre></p>","atan2":"<p>Defined as:</p><p><pre><code>method atan2($y = 1e0)</code></pre></p><p>Coerces self and argument to Numeric, using them to compute the two-argument arc-tangent in radians.</p><p><pre><code>say 3.atan2;                # OUTPUT: «1.24904577239825␤»\nsay ⅔.atan2(⅓);             # OUTPUT: «1.1071487177940904␤»</code></pre></p><p>The first argument defaults to 1, so in the first case the function will return the angle θ in radians between a vector that goes from origin to the point (3, 1) and the x axis.</p>","sec":"<p>Defined as:</p><p><pre><code>sub sec(Numeric(Cool))\nmethod sec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its secant, that is, the reciprocal of its cosine.</p><p><pre><code>say 45.sec;                 # OUTPUT: «1.90359440740442␤»\nsay sec(45);                # OUTPUT: «1.90359440740442␤»</code></pre></p>","cotan":"<p>Defined as:</p><p><pre><code>sub cotan(Numeric(Cool))\nmethod cotan()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its cotangent, that is, the reciprocal of its tangent.</p><p><pre><code>say 45.cotan;               # OUTPUT: «0.617369623783555␤»\nsay cotan(45);              # OUTPUT: «0.617369623783555␤»</code></pre></p>","ord":"<p>Defined as:</p><p><pre><code>sub ord(Str(Cool))\nmethod ord()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the Unicode code point number of the first code point.</p><p><pre><code>say 'a'.ord;            # OUTPUT: «97␤»</code></pre></p><p>The inverse operation is chr.</p><p>Mnemonic: returns an ordinal number</p>","path":"<p>Defined as:</p><p><pre><code>method path()</code></pre></p><p>DEPRECATED. It's been deprecated as of the 6.d version. Will be removed in the next ones.</p><p>Stringifies the invocant and converts it to IO::Path object. Use the .IO method instead.</p>","substr-rw":"<p>Defined as:</p><p><pre><code>multi method substr-rw(|) is rw\nmulti sub substr-rw(|) is rw</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr-rw with the arguments.</p>","subst":"<p>Defined as:</p><p><pre><code>method subst(|)</code></pre></p><p>Coerces the invocant to Stringy and calls Str.subst.</p>","comb":"<p>Defined as:</p><p><pre><code>multi sub comb(Regex $matcher, Cool $input, $limit = *)\nmulti sub comb(Str $matcher, Cool $input, $limit = *)\nmulti sub comb(Int:D $size, Cool $input, $limit = *)\nmulti method comb(|c)</code></pre></p><p>Returns a Seq of all (or if supplied, at most $limit) matches of the invocant (method form) or the second argument (sub form) against the Regex, string or defined number.</p><p><pre><code>say \"6 or 12\".comb(/\\d+/).join(\", \");           # OUTPUT: «6, 12␤»\nsay comb(/\\d <[1..9]> /,(11..30)).join(\"--\");\n# OUTPUT:\n# «11--12--13--14--15--16--17--18--19--21--22--23--24--25--26--27--28--29␤»</code></pre></p><p>The second statement exemplifies the first form of comb, with a Regex that excludes multiples of ten, and a Range (which is Cool) as $input. comb stringifies the Range before applying .comb on the resulting string. Check Str.comb for its effect on different kind of input strings. When the first argument is an integer, it indicates the (maximum) size of the chunks the input is going to be divided in</p><p><pre><code>say comb(3,[3,33,333,3333]).join(\"*\");  # OUTPUT: «3 3*3 3*33 *333*3␤»</code></pre></p><p>In this case the input is a list, which after transformation to Str (which includes the spaces) is divided in chunks of size 3.</p>","atan":"<p>Defined as:</p><p><pre><code>sub atan(Numeric(Cool))\nmethod atan()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, and returns its arc-tangent in radians.</p><p><pre><code>say atan(3);                # OUTPUT: «1.24904577239825␤»\nsay 3.atan;                 # OUTPUT: «1.24904577239825␤»</code></pre></p>","tanh":"<p>Defined as:</p><p><pre><code>sub tanh(Numeric(Cool))\nmethod tanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians and returns its Tangent hyperbolicus.</p><p><pre><code>say tanh(0.5);              # OUTPUT: «0.46211715726001␤»\nsay tanh(atanh(0.5));       # OUTPUT: «0.5␤»</code></pre></p>","match":"<p>Defined as:</p><p><pre><code>method match(|)</code></pre></p><p>Coerces the invocant to Stringy and calls Str.match.</p>","cosec":"<p>Defined as:</p><p><pre><code>sub cosec(Numeric(Cool))\nmethod cosec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, interprets it as radians, returns its cosecant, that is, the reciprocal of its sine.</p><p><pre><code>say 0.45.cosec;             # OUTPUT: «2.29903273150897␤»\nsay cosec(0.45);            # OUTPUT: «2.29903273150897␤»</code></pre></p>","cosech":"<p>Defined as:</p><p><pre><code>sub cosech(Numeric(Cool))\nmethod cosech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Hyperbolic cosecant.</p><p><pre><code>say cosech(pi/2);           # OUTPUT: «0.434537208094696␤»</code></pre></p>","tc":"<p>Defined as:</p><p><pre><code>sub tc(Str(Cool))\nmethod tc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the first letter case-folded to title case (or where not available, upper case).</p><p><pre><code>say \"abC\".tc;       # OUTPUT: «AbC␤»</code></pre></p>","samecase":"<p>Defined as:</p><p><pre><code>sub samecase(Cool $string, Cool $pattern)\nmethod samecase(Cool:D: Cool $pattern)</code></pre></p><p>Coerces the invocant (or in sub form, the first argument) to Str, and returns a copy of $string with case information for each individual character changed according to $pattern.</p><p>Note: The pattern string can contain three types of characters, i.e. uppercase, lowercase and caseless. For a given character in $pattern its case information determines the case of the corresponding character in the result.</p><p>If $string is longer than $pattern, the case information from the last character of $pattern is applied to the remaining characters of $string.</p><p><pre><code>say \"raKu\".samecase(\"A_a_\"); # OUTPUT: «Raku␤»\nsay \"rAKU\".samecase(\"Ab\");   # OUTPUT: «Raku␤»</code></pre></p>","asin":"<p>Defined as:</p><p><pre><code>sub asin(Numeric(Cool))\nmethod asin()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric, and returns its arc-sine in radians.</p><p><pre><code>say 0.1.asin;               # OUTPUT: «0.10016742116156␤»\nsay asin(0.1);              # OUTPUT: «0.10016742116156␤»</code></pre></p>","acosech":"<p>Defined as:</p><p><pre><code>sub acosech(Numeric(Cool))\nmethod acosech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic cosecant.</p><p><pre><code>say acosech(4.5);           # OUTPUT: «0.220432720979802␤»</code></pre></p>","floor":"<p>Defined as:</p><p><pre><code>multi sub floor(Numeric(Cool))\nmulti method floor</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it downwards to the nearest integer.</p><p><pre><code>say \"1.99\".floor;       # OUTPUT: «1␤»\nsay \"-1.9\".floor;       # OUTPUT: «-2␤»\nsay 0.floor;            # OUTPUT: «0␤»</code></pre></p>","cotanh":"<p>Defined as:</p><p><pre><code>sub cotanh(Numeric(Cool))\nmethod cotanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Hyperbolic cotangent.</p><p><pre><code>say cotanh(pi);             # OUTPUT: «1.00374187319732␤»</code></pre></p>","chomp":"<p>Defined as:</p><p><pre><code>sub chomp(Str(Cool))\nmethod chomp()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the last character removed, if it is a logical newline.</p><p><pre><code>say 'ab'.chomp.chars;                   # OUTPUT: «2␤»\nsay \"a\\n\".chomp.chars;                  # OUTPUT: «1␤»</code></pre></p>","asec":"<p>Defined as:</p><p><pre><code>sub asec(Numeric(Cool))\nmethod asec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-secant in radians.</p><p><pre><code>say 1.asec;                 # OUTPUT: «0␤»\nsay sqrt(2).asec;           # OUTPUT: «0.785398163397448␤»</code></pre></p>","acotanh":"<p>Defined as:</p><p><pre><code>sub acotanh(Numeric(Cool))\nmethod acotanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic cotangent.</p><p><pre><code>say acotanh(2.5);           # OUTPUT: «0.423648930193602␤»</code></pre></p>","cis":"<p>Defined as:</p><p><pre><code>sub cis(Numeric(Cool))\nmethod cis()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns cos(argument) + i*sin(argument).</p><p><pre><code>say cis(pi/4);              # OUTPUT: «0.707106781186548+0.707106781186547i␤»</code></pre></p>","cos":"<p>Defined as:</p><p><pre><code>sub cos(Numeric(Cool))\nmethod cos()</code></pre></p><p>Coerces the invocant (or in sub form, the argument) to Numeric, interprets it as radians, returns its cosine.</p><p><pre><code>say 0.cos;                  # OUTPUT: «1␤»\nsay pi.cos;                 # OUTPUT: «-1␤»\nsay cos(pi/2);              # OUTPUT: «6.12323399573677e-17␤»</code></pre></p>","words":"<p>Defined as:</p><p><pre><code>method words(Cool:D: |c)</code></pre></p><p>Coerces the invocant (or first argument, if it is called as a subroutine) to Str, and returns a list of words that make up the string. Check Str.words for additional arguments and its meaning.</p><p><pre><code>say <The quick brown fox>.words.join('|');     # OUTPUT: «The|quick|brown|fox␤»\nsay <The quick brown fox>.words(2).join('|');  # OUTPUT: «The|quick␤»\n</code></pre></p><p>Cool is the base class for many other classes, and some of them, like Match, can be converted to a string. This is what happens in this case:</p><p><pre><code>say ( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/).words(Inf);\n# OUTPUT: «(easy easy)␤»\nsay words( \"easy come, easy goes\" ~~ m:g/(ea\\w+)/ , ∞);\n# OUTPUT: «(easy easy)␤»</code></pre></p><p>The example above illustrates two of the ways words can be invoked, with the first argument turned into invocant by its signature. Of course, Inf is the default value of the second argument, so in both cases (and forms) it can be simply omitted.</p><p>Only whitespace (including no-break space) counts as word boundaries</p><p><pre><code>say <Flying on a Boeing 747>.words.join('|');  # OUTPUT: «Flying|on|a|Boeing|747␤»</code></pre></p><p>In this case, \"Boeing 747\" includes a (visible only in the source) no-break space; words still splits the (resulting) Str on it, even if the original array only had 4 elements:</p><p><pre><code>say <Flying on a Boeing 747>.join('|');        # OUTPUT: «Flying|on|a|Boeing 747␤»</code></pre></p><p>Please see Str.words for more examples and ways to invoke it.</p>","unpolar":"<p>Defined as:</p><p><pre><code>method unpolar(Numeric(Cool))</code></pre></p><p>Coerces the arguments (including the invocant in the method form) to Numeric, and returns a complex number from the given polar coordinates. The invocant (or the first argument in sub form) is the magnitude while the argument (i.e. the second argument in sub form) is the angle. The angle is assumed to be in radians.</p><p><pre><code>say sqrt(2).unpolar(pi/4);      # OUTPUT: «1+1i␤»</code></pre></p>","wordcase":"<p>Defined as:</p><p><pre><code>sub wordcase(Str(Cool) $input, :&filter = &tclc, Mu :$where = True)\nmethod wordcase(:&filter = &tclc, Mu :$where = True)</code></pre></p><p>Coerces the invocant (or in sub form, the first argument) to Str, and filters each word that smartmatches against $where through the &filter. With the default filter (first character to upper case, rest to lower) and matcher (which accepts everything), this title-cases each word:</p><p><pre><code>say \"raku programming\".wordcase;        # OUTPUT: «Raku Programming␤»</code></pre></p><p>With a matcher:</p><p><pre><code>say \"have fun working on perl\".wordcase(:where({ .chars > 3 }));\n                                        # Have fun Working on Perl</code></pre></p><p>With a customer filter too:</p><p><pre><code>say \"have fun working on perl\".wordcase(:filter(&uc), :where({ .chars > 3 }));\n                                        # HAVE fun WORKING on PERL</code></pre></p>","EVAL":"<p>Defined as:</p><p><pre><code>method EVAL(*%_)\n</code></pre></p><p>It calls the subroutine form with the invocant as the first argument, $code, passing along named args, if any.</p>","rand":"<p>Defined as:</p><p><pre><code>method rand()</code></pre></p><p>Coerces the invocant to Num and returns a pseudo-random value between zero and the number.</p><p><pre><code>say 1e5.rand;           # OUTPUT: «33128.495184283␤»</code></pre></p>","exp":"<p>Defined as:</p><p><pre><code>multi sub exp(Cool:D $pow, Cool:D $base?)\nmulti method exp(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method from) to Numeric, and returns $base raised to the power of the first number. If no $base is supplied, e (Euler's Number) is used.</p><p><pre><code>say 0.exp;      # OUTPUT: «1␤»\nsay 1.exp;      # OUTPUT: «2.71828182845905␤»\nsay 10.exp;     # OUTPUT: «22026.4657948067␤»</code></pre></p>","round":"<p>Defined as:</p><p><pre><code>multi sub round(Numeric(Cool))\nmulti method round(Cool:D: $unit = 1)</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it to the unit of $unit. If $unit is 1, rounds to the nearest integer.</p><p><pre><code>say 1.7.round;          # OUTPUT: «2␤»\nsay 1.07.round(0.1);    # OUTPUT: «1.1␤»\nsay 21.round(10);       # OUTPUT: «20␤»</code></pre></p><p>Always rounds up if the number is at mid-point:</p><p><pre><code>say (−.5 ).round;       # OUTPUT: «0␤»\nsay ( .5 ).round;       # OUTPUT: «1␤»\nsay (−.55).round(.1);   # OUTPUT: «-0.5␤»\nsay ( .55).round(.1);   # OUTPUT: «0.6␤»</code></pre></p><p>Pay attention to types when using this method, as ending up with the wrong type may affect the precision you seek to achieve. For Real types, the type of the result is the type of the argument (Complex argument gets coerced to Real, ending up a Num). If rounding a Complex, the result is Complex as well, regardless of the type of the argument.</p><p><pre><code>9930972392403501.round(1)      .perl.say; # OUTPUT: «9930972392403501␤»\n9930972392403501.round(1e0)    .perl.say; # OUTPUT: «9.9309723924035e+15␤»\n9930972392403501.round(1e0).Int.perl.say; # OUTPUT: «9930972392403500␤»</code></pre></p>","abs":"<p>Defined as:</p><p><pre><code>sub abs(Numeric() $x)\nmethod abs()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric and returns the absolute value (that is, a non-negative number).</p><p><pre><code>say (-2).abs;       # OUTPUT: «2␤»\nsay abs \"6+8i\";     # OUTPUT: «10␤»</code></pre></p>","rindex":"<p>Defined as:</p><p><pre><code>multi sub    rindex(Str(Cool) $haystack, Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)\nmulti method rindex(Str(Cool) $haystack: Str(Cool) $needle, Int(Cool) $startpos = $haystack.chars)</code></pre></p><p>Coerces the first two arguments (including the invocant in method form) to Str and $startpos to Int, and returns the last position of $needle in $haystack not after $startpos. Returns an undefined value if $needle wasn't found.</p><p>See the documentation in type Str for examples.</p>","contains":"<p>Defined as:</p><p><pre><code>method contains(Cool:D: |c)</code></pre></p><p>Coerces the invocant to a Str, and calls Str.contains on it. Please refer to that version of the method for arguments and general syntax.</p><p><pre><code>say 123.contains(\"2\")# OUTPUT: «True␤»</code></pre></p><p>Since Int is a subclass of Cool, 123 is coerced to a Str and then contains is called on it.</p><p><pre><code>say (1,1, * + * … * > 250).contains(233)# OUTPUT: «True␤»</code></pre></p><p>Seqs are also subclasses of Cool, and they are stringified to a comma-separated form. In this case we are also using an Int, which is going to be stringified also; \"233\" is included in that sequence, so it returns True. Please note that this sequence is not lazy; the stringification of lazy sequences does not include each and every one of their components for obvious reasons.</p>","trans":"<p>Defined as:</p><p><pre><code>method trans(|)</code></pre></p><p>Coerces the invocant to Str and calls Str.trans</p>","roots":"<p>Defined as:</p><p><pre><code>multi sub roots(Numeric(Cool) $x, Int(Cool) $n)\nmulti method roots(Int(Cool) $n)</code></pre></p><p>Coerces the first argument (and in method form, the invocant) to Numeric and the second ($n) to Int, and produces a list of $n Complex $n-roots, which means numbers that, raised to the $nth power, approximately produce the original number.</p><p>For example</p><p><pre><code>my $original = 16;\nmy @roots = $original.roots(4);\nsay @roots;\n\nfor @roots -> $r {\n    say abs($r ** 4 - $original);\n}\n\n# OUTPUT:«2+0i 1.22464679914735e-16+2i -2+2.44929359829471e-16i -3.67394039744206e-16-2i␤»\n# OUTPUT:«1.77635683940025e-15␤»\n# OUTPUT:«4.30267170434156e-15␤»\n# OUTPUT:«8.03651692704705e-15␤»\n# OUTPUT:«1.04441561648202e-14␤»\n</code></pre></p>","lines":"<p>Defined as:</p><p><pre><code>sub lines(Str(Cool))\nmethod lines()</code></pre></p><p>Coerces the invocant (and in sub form, the argument) to Str, decomposes it into lines (with the newline characters stripped), and returns the list of lines.</p><p><pre><code>say lines(\"a\\nb\\n\").join('|');          # OUTPUT: «a|b␤»\nsay \"some\\nmore\\nlines\".lines.elems;    # OUTPUT: «3␤»</code></pre></p><p>This method can be used as part of an IO::Path to process a file line-by-line, since IO::Path objects inherit from Cool, e.g.:</p><p><pre><code>for 'huge-csv'.IO.lines -> $line {\n    # Do something with $line\n}\n\n# or if you'll be processing later\nmy @lines = 'huge-csv'.IO.lines;\n</code></pre></p><p>Without any arguments, sub lines operates on $*ARGFILES, which defaults to $*IN in the absence of any filenames.</p><p>To modify values in place use is copy to force a writable container.</p><p><pre><code>for $*IN.lines -> $_ is copy { s/(\\w+)/{$0 ~ $0}/; .say }\n</code></pre></p>","sech":"<p>Defined as:</p><p><pre><code>sub sech(Numeric(Cool))\nmethod sech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Secant hyperbolicus.</p><p><pre><code>say 0.sech;                 # OUTPUT: «1␤»</code></pre></p>","fmt":"<p>Defined as:</p><p><pre><code>method fmt($format = '%s')</code></pre></p><p>Uses $format to return a formatted representation of the invocant; equivalent to calling sprintf with $format as format and the invocant as the second argument. The $format will be coerced to Stringy and defaults to '%s'.</p><p>For more information about formats strings, see sprintf.</p><p><pre><code>say 11.fmt('This Int equals %03d');         # OUTPUT: «This Int equals 011␤»\nsay '16'.fmt('Hexadecimal %x');             # OUTPUT: «Hexadecimal 10␤»</code></pre></p>","acosh":"<p>Defined as:</p><p><pre><code>sub acosh(Numeric(Cool))\nmethod acosh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse Cosine hyperbolicus.</p><p><pre><code>say acosh(45);              # OUTPUT: «4.4996861906715␤»</code></pre></p>","lc":"<p>Defined as:</p><p><pre><code>sub lc(Str(Cool))\nmethod lc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it case-folded to lower case.</p><p><pre><code>say \"ABC\".lc;       # OUTPUT: «abc␤»</code></pre></p>","trim":"<p>Defined as:</p><p><pre><code>sub trim(Str(Cool))\nmethod trim()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with both leading and trailing whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim;\nsay \"<$stripped>\";          # OUTPUT: «<abc>␤»</code></pre></p>","substr":"<p>Defined as:</p><p><pre><code>sub substr(Str(Cool) $str, |c)\nmethod substr(|c)</code></pre></p><p>Coerces the invocant (or in the sub form, the first argument) to Str, and calls Str.substr with the arguments.</p>","uninames":"<p>Defined as:</p><p><pre><code>sub uninames(Str:D)\nmethod uninames()</code></pre></p><p>Returns of a Seq of Unicode names for the all the codepoints in the Str provided.</p><p><pre><code>say ‘»ö«’.uninames.perl;\n# OUTPUT: «(\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\", \"LATIN SMALL LETTER O WITH DIAERESIS\", \"LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\").Seq␤»</code></pre></p><p>Note this example, which gets a Seq where each element is a Seq of all the codepoints in that character.</p><p><pre><code>say \"Ḍ̇'oh\".comb>>.uninames.perl;\n# OUTPUT: «((\"LATIN CAPITAL LETTER D WITH DOT BELOW\", \"COMBINING DOT ABOVE\").Seq, (\"APOSTROPHE\",).Seq, (\"LATIN SMALL LETTER O\",).Seq, (\"LATIN SMALL LETTER H\",).Seq)␤»</code></pre></p><p>See uniparse for the opposite direction.</p>","asinh":"<p>Defined as:</p><p><pre><code>sub asinh(Numeric(Cool))\nmethod asinh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse Sine hyperbolicus.</p><p><pre><code>say 1.asinh;                # OUTPUT: «0.881373587019543␤»\nsay asinh(1);               # OUTPUT: «0.881373587019543␤»</code></pre></p>","codes":"<p>Defined as:</p><p><pre><code>sub codes(Str(Cool))\nmethod codes()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the number of Unicode code points.</p><p><pre><code>say 'møp'.codes;    # OUTPUT: «3␤»</code></pre></p><p>The same result will be obtained with</p><p><pre><code>say +'møp'.ords;    # OUTPUT: «3␤»</code></pre></p><p>ords first obtains the actual codepoints, so there might be a difference in speed.</p>","trim-leading":"<p>Defined as:</p><p><pre><code>sub trim-leading(Str(Cool))\nmethod trim-leading()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with leading whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim-leading;\nsay \"<$stripped>\";          # OUTPUT: «<abc >␤»</code></pre></p>","chop":"<p>Defined as:</p><p><pre><code>sub chop(Str(Cool))\nmethod chop()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the last character removed.</p><p><pre><code>say 'perl'.chop;                        # OUTPUT: «per␤»</code></pre></p>","sinh":"<p>Defined as:</p><p><pre><code>sub sinh(Numeric(Cool))\nmethod sinh()</code></pre></p><p>Coerces the invocant (or in method form, its argument) to Numeric, and returns its Sine hyperbolicus.</p><p><pre><code>say 1.sinh;                 # OUTPUT: «1.1752011936438␤»\nsay sinh(1);                # OUTPUT: «1.1752011936438␤»</code></pre></p>","sign":"<p>Defined as:</p><p><pre><code>method sign()</code></pre></p><p>Coerces the invocant to Numeric and returns its sign, that is, 0 if the number is 0, 1 for positive and -1 for negative values.</p><p><pre><code>say 6.sign;             # OUTPUT: «1␤»\nsay (-6).sign;          # OUTPUT: «-1␤»\nsay \"0\".sign;           # OUTPUT: «0␤»</code></pre></p>","asech":"<p>Defined as:</p><p><pre><code>sub asech(Numeric(Cool))\nmethod asech()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse hyperbolic secant.</p><p><pre><code>say 0.8.asech;              # OUTPUT: «0.693147180559945␤»</code></pre></p>","log":"<p>Defined as:</p><p><pre><code>multi sub log(Numeric(Cool) $number, Numeric(Cool) $base?)\nmulti method log(Cool:D: Cool:D $base?)</code></pre></p><p>Coerces the arguments (including the invocant in the method form) to Numeric, and returns its Logarithm to base $base, or to base e (Euler's Number) if no base was supplied (Natural logarithm). Returns NaN if $base is negative. Throws an exception if $base is 1.</p><p><pre><code>say (e*e).log;              # OUTPUT: «2␤»</code></pre></p>","chars":"<p>Defined as:</p><p><pre><code>multi sub chars(Cool $x)\nmulti sub chars(Str:D $x)\nmulti sub chars(str $x --> int)\nmethod chars(--> Int:D)</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the number of characters in the string. Please note that on the JVM, you currently get codepoints instead of graphemes.</p><p><pre><code>say 'møp'.chars;    # OUTPUT: «3␤»\nsay 'ã̷̠̬̊'.chars;     # OUTPUT: «1␤»\nsay '\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF'.chars;    # OUTPUT: «1␤»</code></pre></p><p>If the string is native, the number of chars will be also returned as a native int.</p><p></p><p>Graphemes are user visible characters. That is, this is what the user thinks of as a “character”.</p><p>Graphemes can contain more than one codepoint. Typically the number of graphemes and codepoints differs when Prepend or Extend characters are involved (also known as Combining characters), but there are many other cases when this may happen. Another example is \\c[ZWJ] (Zero-width joiner).</p><p>You can check Grapheme_Cluster_Break property of a character in order to see how it is going to behave:</p><p><pre><code>say ‘ã̷̠̬̊’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(Other Extend Extend Extend Extend)␤»\nsay ‘\uD83D\uDC68‍\uD83D\uDC69‍\uD83D\uDC67‍\uD83D\uDC66\uD83C\uDFFF’.uniprops(‘Grapheme_Cluster_Break’); # OUTPUT: «(E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ ZWJ E_Base_GAZ E_Modifier)␤»</code></pre></p><p>You can read more about graphemes in the Unicode Standard, which Raku tightly follows, using a method called NFG, normal form graphemes for efficiently representing them.</p>","sin":"<p>Defined as:</p><p><pre><code>sub sin(Numeric(Cool))\nmethod sin()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument) to Numeric, interprets it as radians, returns its sine.</p><p><pre><code>say sin(0);             # OUTPUT: «0␤»\nsay sin(pi/4);          # OUTPUT: «0.707106781186547␤»\nsay sin(pi/2);          # OUTPUT: «1␤»</code></pre></p><p>Note that Raku is no computer algebra system, so sin(pi) typically does not produce an exact 0, but rather a very small floating-point number.</p>","sqrt":"<p>Defined as:</p><p><pre><code>sub sqrt(Numeric(Cool) $x)\nmethod sqrt()</code></pre></p><p>Coerces the invocant to Numeric (or in the sub form, the argument) and returns the square root, that is, a non-negative number that, when multiplied with itself, produces the original number.</p><p><pre><code>say 4.sqrt;             # OUTPUT: «2␤»\nsay sqrt(2);            # OUTPUT: «1.4142135623731␤»</code></pre></p>","acosec":"<p>Defined as:</p><p><pre><code>sub acosec(Numeric(Cool))\nmethod acosec()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-cosecant in radians.</p><p><pre><code>say 45.acosec;              # OUTPUT: «0.0222240516182672␤»\nsay acosec(45)              # OUTPUT: «0.0222240516182672␤»</code></pre></p>","trim-trailing":"<p>Defined as:</p><p><pre><code>sub trim-trailing(Str(Cool))\nmethod trim-trailing()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the string with trailing whitespace stripped.</p><p><pre><code>my $stripped = '  abc '.trim-trailing;\nsay \"<$stripped>\";          # OUTPUT: «<  abc>␤»</code></pre></p>","fc":"<p>Defined as:</p><p><pre><code>sub fc(Str(Cool))\nmethod fc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns the result a Unicode \"case fold\" operation suitable for doing caseless string comparisons. (In general, the returned string is unlikely to be useful for any purpose other than comparison.)</p><p><pre><code>say \"groß\".fc;       # OUTPUT: «gross␤»</code></pre></p>","conj":"<p>Defined as:</p><p><pre><code>method conj()</code></pre></p><p>Coerces the invocant to Numeric and returns the complex conjugate (that is, the number with the sign of the imaginary part negated).</p><p><pre><code>say (1+2i).conj;        # OUTPUT: «1-2i␤»</code></pre></p>","uniname":"<p>Defined as:</p><p><pre><code>sub uniname(Str(Cool) --> Str)\nmethod uniname(--> Str)</code></pre></p><p>Interprets the invocant or first argument as a Str, and returns the Unicode codepoint name of the first codepoint of the first character. See uninames for a routine that works with multiple codepoints, and uniparse for the opposite direction.</p><p><pre><code># Camelia in Unicode\nsay ‘»ö«’.uniname;\n# OUTPUT: «\"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\"␤»\nsay \"Ḍ̇\".uniname; # Note, doesn't show \"COMBINING DOT ABOVE\"\n# OUTPUT: «\"LATIN CAPITAL LETTER D WITH DOT BELOW\"␤»\n\n# Find the char with the longest Unicode name.\nsay (0..0x1FFFF).sort(*.uniname.chars)[*-1].chr.uniname;\n# OUTPUT: ««ARABIC LIGATURE UIGHUR KIRGHIZ YEH WITH HAMZA ABOVE WITH ALEF MAKSURA INITIAL FORM␤»␤»</code></pre></p>","acotan":"<p>Defined as:</p><p><pre><code>sub acotan(Numeric(Cool))\nmethod acotan()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its arc-cotangent in radians.</p><p><pre><code>say 45.acotan;              # OUTPUT: «0.0222185653267191␤»\nsay acotan(45)              # OUTPUT: «0.0222185653267191␤»</code></pre></p>","atanh":"<p>Defined as:</p><p><pre><code>sub atanh(Numeric(Cool))\nmethod atanh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Inverse tangent hyperbolicus.</p><p><pre><code>say atanh(0.5);             # OUTPUT: «0.549306144334055␤»</code></pre></p>","chr":"<p>Defined as:</p><p><pre><code>sub chr(Int(Cool))\nmethod chr()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Int, interprets it as a Unicode code points, and returns a string made of that code point.</p><p><pre><code>say '65'.chr;       # OUTPUT: «A␤»</code></pre></p><p>The inverse operation is ord.</p><p>Mnemonic: turns an integer into a character.</p>","truncate":"<p>Defined as:</p><p><pre><code>multi sub truncate(Numeric(Cool))\nmulti method truncate()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it towards zero.</p><p><pre><code>say 1.2.truncate;       # OUTPUT: «1␤»\nsay truncate -1.2;      # OUTPUT: «-1␤»</code></pre></p>","index":"<p>Defined as:</p><p><pre><code>multi sub index(Cool $s, Cool $needle, Cool $pos = 0)\nmethod    index(Cool:D: |c)</code></pre></p><p>Coerces the first two arguments (in method form, also counting the invocant) to a Str, and searches for $needle in the string $s starting from $startpos. It returns the offset into the string where $needle was found, and an undefined value if it was not found.</p><p>See the documentation in type Str for examples.</p>","split":"<p>Defined as:</p><p><pre><code>multi sub    split(  Str:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti sub    split(Regex:D $delimiter, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti sub    split(@delimiters, Str(Cool) $input, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(  Str:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(Regex:D $delimiter, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)\nmulti method split(@delimiters, $limit = Inf, :$k, :$v, :$kv, :$p, :$skip-empty)</code></pre></p><p>the comb routine is a much better choice for many tasks that in other languages are handled by the split.</p><p>Coerces the invocant (or in the sub form, the second argument) to Str, and splits it into pieces based on delimiters found in the string.</p><p>If $delimiter is a string, it is searched for literally and not treated as a regex. You can also provide multiple delimiters by specifying them as a list; mixing Cool and Regex objects is OK.</p><p><pre><code>say split(';', \"a;b;c\").perl;               # OUTPUT: «(\"a\", \"b\", \"c\")␤»\nsay split(';', \"a;b;c\", 2).perl;            # OUTPUT: «(\"a\", \"b;c\").Seq␤»\n\nsay split(';', \"a;b;c,d\").perl;             # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\nsay split(/\\;/, \"a;b;c,d\").perl;            # OUTPUT: «(\"a\", \"b\", \"c,d\")␤»\nsay split(/<[;,]>/, \"a;b;c,d\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\", \"d\")␤»\n\nsay split(['a', /b+/, 4], '1a2bb345').perl; # OUTPUT: «(\"1\", \"2\", \"3\", \"5\")␤»</code></pre></p><p>By default, split omits the matches, and returns a list of only those parts of the string that did not match. Specifying one of the :k, :v, :kv, :p adverbs changes that. Think of the matches as a list that is interleaved with the non-matching parts.</p><p>The :v interleaves the values of that list, which will be either Match objects, if a Regex was used as a matcher in the split, or Str objects, if a Cool was used as matcher. If multiple delimiters are specified, Match objects will be generated for all of them, unless all of the delimiters are Cool.</p><p><pre><code>say 'abc'.split(/b/, :v);               # OUTPUT: «(a ｢b｣ c)␤»\nsay 'abc'.split('b', :v);               # OUTPUT: «(a b c)␤»</code></pre></p><p>:k interleaves the keys, that is, the indexes:</p><p><pre><code>say 'abc'.split(/b/, :k);               # OUTPUT: «(a 0 c)␤»</code></pre></p><p>:kv adds both indexes and matches:</p><p><pre><code>say 'abc'.split(/b/, :kv);               # OUTPUT: «(a 0 ｢b｣ c)␤»</code></pre></p><p>and :p adds them as Pairs, using the same types for values as :v does:</p><p><pre><code>say 'abc'.split(/b/, :p);               # OUTPUT: «(a 0 => ｢b｣ c)␤»\nsay 'abc'.split('b', :p);               # OUTPUT: «(a 0 => b c)␤»</code></pre></p><p>You can only use one of the :k, :v, :kv, :p adverbs in a single call to split.</p><p>Note that empty chunks are not removed from the result list. For that behavior, use the :skip-empty named argument:</p><p><pre><code>say (\"f,,b,c,d\".split: /\",\"/             ).perl;  # OUTPUT: «(\"f\", \"\", \"b\", \"c\", \"d\")␤»\nsay (\"f,,b,c,d\".split: /\",\"/, :skip-empty).perl;  # OUTPUT: «(\"f\", \"b\", \"c\", \"d\")␤»</code></pre></p>","cosh":"<p>Defined as:</p><p><pre><code>sub cosh(Numeric(Cool))\nmethod cosh()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and returns its Cosine hyperbolicus.</p><p><pre><code>say cosh(0.5);              # OUTPUT: «1.12762596520638␤»</code></pre></p>","uniprop":"<p>Defined as:</p><p><pre><code>multi sub uniprop(Str:D, |c)\nmulti sub uniprop(Int:D $code)\nmulti sub uniprop(Int:D $code, Stringy:D $propname)\nmulti method uniprop(|c)</code></pre></p><p>Returns the unicode property of the first character. If no property is specified returns the General Category. Returns a Bool for Boolean properties. A uniprops routine can be used to get the property for every character in a string.</p><p><pre><code>say 'a'.uniprop;               # OUTPUT: «Ll␤»\nsay '1'.uniprop;               # OUTPUT: «Nd␤»\nsay 'a'.uniprop('Alphabetic'); # OUTPUT: «True␤»\nsay '1'.uniprop('Alphabetic'); # OUTPUT: «False␤»</code></pre></p>","ceiling":"<p>Defined as:</p><p><pre><code>multi sub ceiling(Numeric(Cool))\nmulti method ceiling</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Numeric, and rounds it upwards to the nearest integer.</p><p><pre><code>say \"1\".ceiling;        # OUTPUT: «1␤»\nsay \"-0.9\".ceiling;     # OUTPUT: «0␤»\nsay \"42.1\".ceiling;     # OUTPUT: «43␤»</code></pre></p>","flip":"<p>Defined as:</p><p><pre><code>sub flip(Cool $s --> Str:D)\nmethod flip()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns a reversed version.</p><p><pre><code>say 421.flip;       # OUTPUT: «124␤»</code></pre></p>","uc":"<p>Defined as:</p><p><pre><code>sub uc(Str(Cool))\nmethod uc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it case-folded to upper case (capital letters).</p><p><pre><code>say \"Abc\".uc;       # OUTPUT: «ABC␤»</code></pre></p>","log10":"<p>Defined as:</p><p><pre><code>multi sub log10(Cool(Numeric))\nmulti method log10()</code></pre></p><p>Coerces the invocant (or in the sub form, the invocant) to Numeric, and returns its Logarithm to base 10, that is, a number that approximately produces the original number when raised to the power of 10. Returns NaN for negative arguments and -Inf for 0.</p><p><pre><code>say log10(1001);            # OUTPUT: «3.00043407747932␤»</code></pre></p>","chrs":"<p>Defined as:</p><p><pre><code>sub chrs(*@codepoints --> Str:D)\nmethod chrs()</code></pre></p><p>Coerces the invocant (or in the sub form, the argument list) to a list of integers, and returns the string created by interpreting each integer as a Unicode codepoint, and joining the characters.</p><p><pre><code>say <67 97 109 101 108 105 97>.chrs;   # OUTPUT: «Camelia␤»</code></pre></p><p>This is the list-input version of chr. The inverse operation is ords.</p>","unimatch":"<p>Defined as:</p><p><pre><code>multi sub unimatch(Str:D $str, |c)\nmulti unimatch(Int:D $code, Stringy:D $pvalname, Stringy:D $propname = $pvalname)</code></pre></p><p>Checks if the given integer codepoint or the first letter of the string given have a unicode property equal to the value you give. If you supply the Unicode property to be checked it will only return True if that property matches the given value.</p><p><pre><code>say unimatch 'A', 'Latin';           # OUTPUT: «True␤»\nsay unimatch 'A', 'Latin', 'Script'; # OUTPUT: «True␤»\nsay unimatch 'A', 'Ll';              # OUTPUT: «True␤»</code></pre></p>","tclc":"<p>Defined as:</p><p><pre><code>sub tclc(Str(Cool))\nmethod tclc()</code></pre></p><p>Coerces the invocant (or in sub form, its argument) to Str, and returns it with the first letter case-folded to title case (or where not available, upper case), and the rest of the string case-folded to lower case.</p><p><pre><code>say 'abC'.tclc;     # OUTPUT: «Abc␤»</code></pre></p>"},"prefix":"<p><pre><code>class Cool is Any { }</code></pre></p><p>Cool, also known as the Convenient OO Loop, is a base class employed by a number of built-in classes whose instances can be meaningfully coerced to a string and a number. For example, an Array can be used in mathematical operations, where its numerical representation is the number of elements it contains. At the same time, it can be concatenated to a string, where its stringy representation is all of its elements joined by a space. Because Array is Cool, the appropriate coercion happens automatically.</p><p>Methods in Cool coerce the invocant to a more specific type, and then call the same method on that type. For example both Int and Str inherit from Cool, and calling method substr on an Int converts the integer to Str first.</p><p><pre><code>123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)</code></pre></p><p>The following built-in types inherit from Cool: Array Bool Complex Cool Duration Map FatRat Hash Instant Int List Match Nil Num Range Seq Stash Str.</p><p>The following table summarizes the methods that Cool provides, and what type they coerce to:</p><table class='sections'><tr><th>method</th><th>coercion type</th></tr>\n<tr><td>abs</tr><td>Numeric</tr></tr>\n<tr><td>conj</tr><td>Numeric</tr></tr>\n<tr><td>sqrt</tr><td>Numeric</tr></tr>\n<tr><td>sign</tr><td>Real</tr></tr>\n<tr><td>rand</tr><td>Numeric</tr></tr>\n<tr><td>sin</tr><td>Numeric</tr></tr>\n<tr><td>asin</tr><td>Numeric</tr></tr>\n<tr><td>cos</tr><td>Numeric</tr></tr>\n<tr><td>acos</tr><td>Numeric</tr></tr>\n<tr><td>tan</tr><td>Numeric</tr></tr>\n<tr><td>tanh</tr><td>Numeric</tr></tr>\n<tr><td>atan</tr><td>Numeric</tr></tr>\n<tr><td>atan2</tr><td>Numeric</tr></tr>\n<tr><td>atanh</tr><td>Numeric</tr></tr>\n<tr><td>sec</tr><td>Numeric</tr></tr>\n<tr><td>asec</tr><td>Numeric</tr></tr>\n<tr><td>cosec</tr><td>Numeric</tr></tr>\n<tr><td>acosec</tr><td>Numeric</tr></tr>\n<tr><td>cotan</tr><td>Numeric</tr></tr>\n<tr><td>cotanh</tr><td>Numeric</tr></tr>\n<tr><td>acotan</tr><td>Numeric</tr></tr>\n<tr><td>sinh</tr><td>Numeric</tr></tr>\n<tr><td>asinh</tr><td>Numeric</tr></tr>\n<tr><td>cosh</tr><td>Numeric</tr></tr>\n<tr><td>acosh</tr><td>Numeric</tr></tr>\n<tr><td>sech</tr><td>Numeric</tr></tr>\n<tr><td>asech</tr><td>Numeric</tr></tr>\n<tr><td>cosech</tr><td>Numeric</tr></tr>\n<tr><td>acosech</tr><td>Numeric</tr></tr>\n<tr><td>acotanh</tr><td>Numeric</tr></tr>\n<tr><td>cis</tr><td>Numeric</tr></tr>\n<tr><td>log</tr><td>Numeric</tr></tr>\n<tr><td>exp</tr><td>Numeric</tr></tr>\n<tr><td>roots</tr><td>Numeric</tr></tr>\n<tr><td>log10</tr><td>Numeric</tr></tr>\n<tr><td>unpolar</tr><td>Numeric</tr></tr>\n<tr><td>round</tr><td>Numeric</tr></tr>\n<tr><td>floor</tr><td>Numeric</tr></tr>\n<tr><td>ceiling</tr><td>Numeric</tr></tr>\n<tr><td>truncate</tr><td>Numeric</tr></tr>\n<tr><td>chr</tr><td>Int</tr></tr>\n<tr><td>ord</tr><td>Str</tr></tr>\n<tr><td>chars</tr><td>Str</tr></tr>\n<tr><td>fmt</tr><td>Str</tr></tr>\n<tr><td>uniname</tr><td>Str</tr></tr>\n<tr><td>uninames</tr><td>Seq</tr></tr>\n<tr><td>unival</tr><td>Str</tr></tr>\n<tr><td>univals</tr><td>Str</tr></tr>\n<tr><td>uniprop</tr><td>Str</tr></tr>\n<tr><td>unimatch</tr><td>Str</tr></tr>\n<tr><td>uc</tr><td>Str</tr></tr>\n<tr><td>lc</tr><td>Str</tr></tr>\n<tr><td>fc</tr><td>Str</tr></tr>\n<tr><td>tc</tr><td>Str</tr></tr>\n<tr><td>tclc</tr><td>Str</tr></tr>\n<tr><td>flip</tr><td>Str</tr></tr>\n<tr><td>trans</tr><td>Str</tr></tr>\n<tr><td>contains</tr><td>Str</tr></tr>\n<tr><td>index</tr><td>Str</tr></tr>\n<tr><td>rindex</tr><td>Str</tr></tr>\n<tr><td>ords</tr><td>Str</tr></tr>\n<tr><td>split</tr><td>Str</tr></tr>\n<tr><td>match</tr><td>Str</tr></tr>\n<tr><td>comb</tr><td>Str</tr></tr>\n<tr><td>subst</tr><td>Str</tr></tr>\n<tr><td>sprintf</tr><td>Str</tr></tr>\n<tr><td>printf</tr><td>Str</tr></tr>\n<tr><td>samecase</tr><td>Str</tr></tr>\n<tr><td>trim</tr><td>Str</tr></tr>\n<tr><td>trim-leading</tr><td>Str</tr></tr>\n<tr><td>trim-trailing</tr><td>Str</tr></tr>\n<tr><td>EVAL</tr><td>Str</tr></tr>\n<tr><td>chomp</tr><td>Str</tr></tr>\n<tr><td>chop</tr><td>Str</tr></tr>\n<tr><td>codes</tr><td>Str</tr></tr>\n</table>","name":"Cool"},"X::Channel::SendOnClosed":{"name":"X::Channel::SendOnClosed","defs":{},"prefix":"<p><pre><code>class X::Channel::SendOnClosed {}</code></pre></p><p>This exception is thrown when a calling send on a Channel that has been closed:</p><p><pre><code>my $s = Channel.new;\n$s.close;\n$s.send(42);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»</code></pre></p>"},"X::TypeCheck::Binding":{"name":"X::TypeCheck::Binding","defs":{},"prefix":"<p><pre><code>class X::TypeCheck::Binding is X::TypeCheck { }</code></pre></p><p>Thrown when the type check of a binding operation fails.</p><p>For example:</p><p><pre><code>my Int $x := \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Binding: Type check failed in binding; expected Int but got Str (\"foo\")␤»</code></pre></p><p>Note that the compiler is free to detect obvious errors at compile time, and complain with a different error at compile time.</p>"},"IO":{"prefix":"<p>The role provides no methods, but exists so that IO() coercers, which coerce to IO::Path, correctly type-check the resultant value. The role is implemented by IO::Path and IO::Special.</p><p>See also the related classes IO::Handle and IO::Path.</p>","defs":{},"name":"IO"},"X::Redeclaration":{"prefix":"<p><pre><code>class X::Redeclaration does X::Comp { }</code></pre></p><p>Thrown when a symbol (variable, routine, type, parameter, ...) is redeclared. Note that redeclarations are generally fine in an inner scope, but if the redeclaration appears in the same scope as the original declaration, it usually indicates an error and is treated as one.</p><p>Examples</p><p><pre><code>my $x; my $x;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nRedeclaration of symbol $x\n</code></pre></p><p>It works with routines too:</p><p><pre><code>sub f() { }\nsub f() { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nRedeclaration of routine f\n</code></pre></p><p>But those are fine</p><p><pre><code>my $x;\nsub f() {\n    my $x;          # not a redeclaration,\n                    # because it's in an inner scope\n    sub f() { };    # same\n}\n</code></pre></p>","defs":{"symbol":"<p>Returns the name of the symbol that was redeclared.</p>","what":"<p>Returns the kind of symbol that was redeclared. Usually symbol, but can also be routine, type etc.</p>"},"name":"X::Redeclaration"},"Pod::Block":{"defs":{"contents":"<p><pre><code>method contents(--> Positional:D)</code></pre></p><p>Returns a list of contents of this block.</p>"},"prefix":"<p><pre><code>class Pod::Block { }</code></pre></p><p>Class for a Pod block, and base class for most other Pod classes.</p><p>A Pod block has contents (more pod blocks or strings) and a config hash.</p><p>Useful subclasses:</p><table class='sections'><tr><th>Class</th><th>Used for</th></tr>\n<tr><td>Pod::Block::Para</tr><td>paragraphs</tr></tr>\n<tr><td>Pod::Block::Named</tr><td>named blocks</tr></tr>\n<tr><td>Pod::Block::Declarator</tr><td>declarator blocks</tr></tr>\n<tr><td>Pod::Block::Code</tr><td>code blocks</tr></tr>\n<tr><td>Pod::Block::Comment</tr><td>comments</tr></tr>\n<tr><td>Pod::Block::Table</tr><td>=begin/end table</tr></tr>\n<tr><td></tr><td>tabular data</tr></tr>\n<tr><td>Pod::Heading</tr><td>=head1 etc. headings</tr></tr>\n<tr><td>Pod::Item</tr><td>list items</tr></tr>\n<tr><td>Pod::Defn</tr><td>definition lists</tr></tr>\n<tr><td>Pod::FormattingCode</tr><td>formatting codes</tr></tr>\n</table>","name":"Pod::Block"},"CompUnit::Repository":{"name":"CompUnit::Repository","defs":{"load":"<p><pre><code>method load(IO::Path:D $file --> CompUnit:D)</code></pre></p><p>Load the $file and return a CompUnit object representing it.</p>","need":"<p>Loads and returns a CompUnit which is mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>","resolve":"<p><pre><code>method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)</code></pre></p><p>Returns a CompUnit mapped to the highest version distribution matching $spec from the first repository in the repository chain that contains any version of a distribution matching $spec.</p>"},"prefix":"<p>The CompUnit::Repository role defines the interface of the implementation of CompUnit::Repositories such as CompUnit::Repository::Installation and CompUnit::Repository::FileSystem.</p>"},"StrDistance":{"name":"StrDistance","prefix":"<p>StrDistance objects are used to represent the return of the string transformation operator.</p><p><pre><code>say (($ = \"fold\") ~~ tr/old/new/).^name;  # OUTPUT: «StrDistance␤»</code></pre></p><p>A StrDistance object will stringify to the resulting string after the transformation, and will numify to the distance between the two strings.</p><p><pre><code>my $str = \"fold\";\nmy $str-dist = ($str ~~ tr/old/new/);\nsay ~$str-dist;  # OUTPUT: «fnew␤»\nsay +$str-dist;  # OUTPUT: «3␤»\n</code></pre></p>","defs":{"Int":"<p>Defined as:</p><p><pre><code>multi method Int(StrDistance:D:)</code></pre></p><p>Returns the distance between the string before and after the transformation.</p>","Bool":"<p>Returns True if before is different from after.</p>","after":"<p>Also a class attribute, returns the string after the transformation:</p><p><pre><code>say $str-dist.after;  # OUTPUT: «fnew␤»\n</code></pre></p>","Numeric":"<p>Returns the distance as a number.</p>","before":"<p>This is actually a class attribute, and called as a method returns the string before the transformation:</p><p><pre><code>say $str-dist.before; # OUTPUT: «fold␤»\n</code></pre></p>"}},"Version":{"name":"Version","defs":{"plus":"<p><pre><code>method plus(Version:D: --> Bool:D)</code></pre></p><p>Returns True if comparisons against this version allow larger versions too.</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = v1.0.1+;\nsay $v1.plus;                                     # OUTPUT: «False␤»\nsay $v2.plus;                                     # OUTPUT: «True␤»</code></pre></p>","Str":"<p><pre><code>method Str(Version:D: --> Str:D)</code></pre></p><p>Returns a string representation of the invocant.</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = Version.new('1.0.1');\nsay $v1.Str;                                      # OUTPUT: «1.0.1␤»\nsay $v2.Str;                                      # OUTPUT: «1.0.1␤»</code></pre></p>","gist":"<p><pre><code>method gist(Version:D: --> Str:D)</code></pre></p><p>Returns a string representation of the invocant, just like Str, prepended with a lower-case v.</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = Version.new('1.0.1');\nsay $v1.gist;                                      # OUTPUT: «v1.0.1␤»\nsay $v2.gist;                                      # OUTPUT: «v1.0.1␤»</code></pre></p>","parts":"<p><pre><code>method parts(Version:D: --> List:D)</code></pre></p><p>Returns the list of parts that make up this Version object</p><p><pre><code>my $v1 = v1.0.1;\nmy $v2 = v1.0.1+;\nsay $v1.parts;                                    # OUTPUT: «(1 0 1)␤»\nsay $v2.parts;                                    # OUTPUT: «(1 0 1)␤»</code></pre></p><p>The + suffix is not considered a part of the Version object, and thus not returned by this method, as shown above in the $v2 variable.</p>","new":"<p><pre><code>method new(Str:D $s)</code></pre></p><p>Creates a Version from a string $s. The string is combed for the numeric, alphabetic, and wildcard components of the version object. Any characters other than alphanumerics and asterisks are assumed to be equivalent to a dot. A dot is also assumed between any adjacent numeric and alphabetic characters.</p>"},"prefix":"<p><pre><code>class Version { }</code></pre></p><p>Version objects identify version of software components (and potentially other entities). Raku uses them internally for versioning modules.</p><p></p><p>A version consists of several parts, which are visually represented by joining them with a dot. A version part is usually an integer, a string like alpha, or a Whatever-star *. The latter is used to indicate that any version part is acceptable in another version that is compared to the current one.</p><p><pre><code>say v1.0.1 ~~ v1.*;     # OUTPUT: «True␤»\nsay v1.0.1 ~~ v1.*.1;   # OUTPUT: «True␤»</code></pre></p><p>The first part of version literals contains v and a number; this might be followed by alphanumeric and Whatever parts and trailed by +. Multiple parts are separate with a dot .. A trailing + indicates that higher versions are OK in comparisons:</p><p><pre><code>say v1.2 ~~ v1.0;                 # OUTPUT: «False␤»\nsay v1.2 ~~ v1.0+;                # OUTPUT: «True␤»\nsay v0.and.anything.else ~~ v0+;  # OUTPUT: «True␤»</code></pre></p><p>In comparisons, order matters, and every part is compared in turn.</p><p><pre><code>say v1.2 cmp v2.1;      # OUTPUT: «Less␤»</code></pre></p><p>The + suffix is always taken into account in comparisons:</p><p><pre><code>say v1.0.1+ <=> v1.0.1; # OUTPUT: «More␤»</code></pre></p><p>And * (Whatever) is too, and considered always Less than whatever digit is in the corresponding part, even if * is trailed by +:</p><p><pre><code>say v1.* <=> v1.0;      # OUTPUT: «Less␤»\nsay v1.* <= v1.0;       # OUTPUT: «True␤»\nsay v1.*+ <= v1.0;      # OUTPUT: «True␤»</code></pre></p><p>Please note that method calls, including pseudo methods like WHAT, require version literals either to be enclosed with parentheses or use some other method to separate them from the dot that denotes a method call, like in these examples:</p><p><pre><code>say (v0.and.some.*.stuff).parts;  # OUTPUT: «(0 and some * stuff)␤»\nsay v0.and.some.*.stuff .parts;   # OUTPUT: «(0 and some * stuff)␤»</code></pre></p>"},"Int":{"prefix":"<p><pre><code>class Int is Cool does Real { }\n</code></pre></p><p>Int objects store integral numbers of arbitrary size. Ints are immutable.</p><p>There are two main syntax forms for Int literals</p><p><pre><code>123;         # Int in decimal notation\n:16<BEEF>;   # Int in radix notations</code></pre></p><p>For your convenience common radix forms come with a prefix shortcut.</p><p><pre><code>say so :2<11111111> == 0b11111111 == :8<377> == 0o377 == 255 == 0d255 == :16<ff> == 0xff;\n# OUTPUT: «True␤»</code></pre></p><p>All forms allow underscores between any two digits which can serve as visual separators, but don't carry any meaning:</p><p><pre><code>5_00000;       # five Lakhs\n500_000;       # five hundred thousand\n0xBEEF_CAFE;   # a strange place\n:2<1010_1010>; # 0d170</code></pre></p><p>Radix notation also supports round and angle brackets which allow you to parse a string for a given base, and putting together digits into a whole number respectively:</p><p><pre><code>:16(\"9F\");         # 159\n:100[99, 2, 3];    # 990203</code></pre></p><p>These notations allow you to use variables, too:</p><p><pre><code>my $two = \"2\";\nmy $ninety-nine = \"99\";\n:16($ninety-nine); # 153\n:100[99, $two, 3]; # 990203</code></pre></p>","defs":{"msb":"<p>Defined as:</p><p><pre><code>multi method msb(Int:D:)\nmulti sub    msb(Int:D)</code></pre></p><p>Short for \"Most Significant Bit\". Returns Nil if the number is 0. Otherwise returns the zero-based index from the right of the most significant (leftmost) 1 in the binary representation of the number.</p><p><pre><code>say 0b00001.msb;        # OUTPUT: «0␤»\nsay 0b00011.msb;        # OUTPUT: «1␤»\nsay 0b00101.msb;        # OUTPUT: «2␤»\nsay 0b01010.msb;        # OUTPUT: «3␤»\nsay 0b10011.msb;        # OUTPUT: «4␤»</code></pre></p>","is-prime":"<p>Defined as:</p><p><pre><code>multi sub    is-prime (Int:D $number --> Bool:D)\nmulti method is-prime (Int:D: --> Bool:D)</code></pre></p><p>Returns True if this Int is known to be a prime, or is likely to be a prime based on a probabilistic Miller-Rabin test.</p><p>Returns False if this Int is known not to be a prime.</p><p><pre><code>say 2.is-prime;         # OUTPUT: «True␤»\nsay is-prime(9);        # OUTPUT: «False␤»</code></pre></p>","lsb":"<p>Defined as:</p><p><pre><code>multi method lsb(Int:D:)\nmulti sub    lsb(Int:D)</code></pre></p><p>Short for \"Least Significant Bit\". Returns Nil if the number is 0. Otherwise returns the zero-based index from the right of the least significant (rightmost) 1 in the binary representation of the number.</p><p><pre><code>say 0b01011.lsb;        # OUTPUT: «0␤»\nsay 0b01010.lsb;        # OUTPUT: «1␤»\nsay 0b10100.lsb;        # OUTPUT: «2␤»\nsay 0b01000.lsb;        # OUTPUT: «3␤»\nsay 0b10000.lsb;        # OUTPUT: «4␤»</code></pre></p>","unival":"<p>Defined as:</p><p><pre><code>multi sub    unival(Int:D  --> Numeric)\nmulti method unival(Int:D: --> Numeric)</code></pre></p><p>Returns the number represented by the Unicode codepoint with the given integer number, or NaN if it does not represent a number.</p><p><pre><code>say ord(\"¾\").unival;    # OUTPUT: «0.75␤»\nsay 190.unival;         # OUTPUT: «0.75␤»\nsay unival(65);         # OUTPUT: «NaN␤»</code></pre></p>","polymod":"<p>Defined as:</p><p><pre><code>method polymod(Int:D: +@mods)</code></pre></p><p>Returns a sequence of mod results corresponding to the divisors in @mods in the same order as they appear there. For the best effect, the divisors should be given from the smallest \"unit\" to the largest (e.g. 60 seconds per minute, 60 minutes per hour) and the results are returned in the same way: from smallest to the largest (5 seconds, 4 minutes). The last non-zero value will be the last remainder.</p><p><pre><code>say 120.polymod(10);    # OUTPUT: «(0 12)␤»\nsay 120.polymod(10,10); # OUTPUT: «(0 2 1)␤»</code></pre></p><p>In the first case, 120 is divided by 10 giving as a remainder 12, which is the last element. In the second, 120 is divided by 10, giving 12, whose remainder once divided by 10 is 2; the result of the integer division of 12 div 10 is the last remainder. The number of remainders will be always one more item than the number of given divisors. If the divisors are given as a lazy list, runs until the remainder is 0 or the list of divisors is exhausted. All divisors must be Ints, unless the method is called on a non-Int number.</p><p><pre><code>my $seconds = 1 * 60*60*24 # days\n            + 3 * 60*60    # hours\n            + 4 * 60       # minutes\n            + 5;           # seconds\n\nsay $seconds.polymod(60, 60);                # OUTPUT: «(5 4 27)␤»\nsay $seconds.polymod(60, 60, 24);            # OUTPUT: «(5 4 3 1)␤»\n\nsay 120.polymod:      1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12 0 0 0)␤»\nsay 120.polymod: lazy 1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12)␤»\nsay 120.polymod:      1, 10, 10² … ∞;        # OUTPUT: «(0 0 12)␤»\n\nsay ⅔.polymod(⅓);                            # OUTPUT: «(0 2)␤»\nsay 5.Rat.polymod(.3, .2);                   # OUTPUT: «(0.2 0 80)␤»\n\nmy @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion\nsay @digits-in-base37.reverse                    # OUTPUT: «[4 32 4 15 36]␤»</code></pre></p><p>To illustrate how the Int, non-lazy version of polymod works, consider this code that implements it:</p><p><pre><code>my $seconds = 2 * 60*60*24 # days\n            + 3 * 60*60    # hours\n            + 4 * 60       # minutes\n            + 5;           # seconds\n\nmy @pieces;\nfor 60, 60, 24 -> $divisor {\n    @pieces.push: $seconds mod $divisor;\n    $seconds div= $divisor\n}\n@pieces.push: $seconds;\n\nsay @pieces; # OUTPUT: «[5 4 3 2]␤»</code></pre></p><p>For a more detailed discussion, see this blog post</p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>","chr":"<p>Defined as:</p><p><pre><code>multi sub    chr(Int:D  --> Str:D)\nmulti method chr(Int:D: --> Str:D)</code></pre></p><p>Returns a one-character string, by interpreting the integer as a Unicode codepoint number and converting it to the corresponding character.</p><p>Example:</p><p><pre><code>65.chr;  # returns \"A\"\n196.chr; # returns \"Ä\"</code></pre></p>","Range":"<p>Returns a Range object that represents the range of values supported.</p>","expmod":"<p>Defined as:</p><p><pre><code>multi sub    expmod(      $x,     $y,     $mod --> Int:D)\nmulti sub    expmod(Int:D $x, Int $y, Int $mod --> Int:D)\nmulti method expmod(Int:D:    Int $y, Int $mod --> Int:D)</code></pre></p><p>Returns the given Int raised to the $y power within modulus $mod, that is gives the result of ($x ** $y) mod $mod. The subroutine form can accept non-Int arguments, which will be coerced to Int.</p><p><pre><code>say expmod(4, 2, 5);    # OUTPUT: «1␤»\nsay 7.expmod(2, 5);     # OUTPUT: «4␤»</code></pre></p><p>$y argument can also be negative, in which case, the result is equivalent to ($x ** $y) mod $mod.</p><p><pre><code>say 7.expmod(-2, 5);     # OUTPUT: «4␤»</code></pre></p>"},"name":"Int"},"X::Parameter::MultipleTypeConstraints":{"name":"X::Parameter::MultipleTypeConstraints","prefix":"<p><pre><code>class X::Parameter::MultipleTypeConstraints does X::Comp { }</code></pre></p><p>Compile time error thrown when a parameter has multiple type constraints. This is not allowed in Raku.0.</p><p>Example:</p><p><pre><code>sub f(Cool Real $x) { }\n</code></pre></p><p>dies with</p><p><pre><code>Parameter $x may only have one prefix type constraint\n</code></pre></p>","defs":{}},"Encoding::Registry":{"defs":{"name":"<p><pre><code>method register(Encoding $enc --> Nil)</code></pre></p><p>Register a new Encoding.</p><p> </p>"},"prefix":"<p><pre><code>class Encoding::Registry {}</code></pre></p><p>Encoding::Registry is initialized with a list of encoding that is available for any Raku application, namely:</p>* <p>utf8</p><br>* <p>utf8-c8</p><br>* <p>utf16</p><br>* <p>utf16le</p><br>* <p>utf16be</p><br>* <p>utf32, utf-32</p><br>* <p>ascii</p><br>* <p>iso-8859-1, iso_8859-1:1987, iso_8859-1, iso-ir-100, latin1, latin-1, csisolatin1, l1, ibm819, cp819</p><br>* <p>windows-1251</p><br>* <p>windows-1252</p><br>* <p>windows-932</p><br>","name":"Encoding::Registry"},"ComplexStr":{"name":"ComplexStr","defs":{"Numeric":"<p>Defined as:</p><p><pre><code>multi method Numeric(ComplexStr:D: --> Complex:D)\nmulti method Numeric(ComplexStr:U: --> Complex:D)</code></pre></p><p>The :D variant returns the numeric portion of the invocant. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value <0+0i>.</p>","new":"<p><pre><code>method new(Complex $i, Str $s)</code></pre></p><p>The constructor requires both the Complex and the Str value, when constructing one directly the values can be whatever is required:</p><p><pre><code>my $f = ComplexStr.new(42+0i, \"forty two (but complicated)\");\nsay +$f; # OUTPUT: «42+0i␤»\nsay ~$f; # OUTPUT: «\"forty two (but complicated)\"␤»</code></pre></p>","ACCEPTS":"<p>Defined as:</p><p><pre><code>multi method ACCEPTS(ComplexStr:D: Any:D $value)</code></pre></p><p>If $value is Numeric (including another allomorph), checks if invocant's Numeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str part ACCEPTS the $value. If value is anything else, checks if both Numeric and Str parts ACCEPTS the $value.</p><p><pre><code>say < 5+0i> ~~ \"5.0\"; # OUTPUT: «False␤»\nsay < 5+0i> ~~  5.0 ; # OUTPUT: «True␤»\nsay < 5+0i> ~~ <5.0>; # OUTPUT: «True␤»</code></pre></p>","Str":"<p>Returns the string value of the ComplexStr.</p>","Complex":"<p><pre><code>method Complex</code></pre></p><p>Returns the Complex value of the ComplexStr.</p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(ComplexStr:D --> Capture:D)</code></pre></p><p>Equivalent to Mu.Capture.</p>","Real":"<p>Defined as:</p><p><pre><code>multi method Real(ComplexStr:D: --> Num:D)\nmulti method Real(ComplexStr:U: --> Num:D)</code></pre></p><p>Coerces the numeric portion of the invocant to Num. If the imaginary part isn't approximately zero, coercion fails with X::Numeric::Real.</p><p>The :D variant returns the result of that coercion. The :U variant issues a warning about using an uninitialized value in numeric context and then returns value 0e0.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(ComplexStr:D: --> Bool:D)</code></pre></p><p>This method may be provided by the parent classes and not implemented in ComplexStr directly.</p><p>Returns False if the invocant is numerically ±0±0i, otherwise returns True. String portion is not considered.</p>"},"prefix":"<p><pre><code>class ComplexStr is Complex is Str {}</code></pre></p><p>The dual value types (often referred to as allomorphs) allow for the representation of a value as both a string and a numeric type. Typically they will be created for you when the context is \"stringy\" but they can be determined to be numbers, such as in some quoting constructs:</p><p><pre><code>my $f = <42+0i>; say $f.^name; # OUTPUT: «ComplexStr␤»</code></pre></p><p>As a subclass of both Complex and Str, a ComplexStr will be accepted where either is expected. However, ComplexStr does not share object identity with Complex- or Str-only variants:</p><p><pre><code>my $complex-str = < 42+0i >;\nmy Complex $complex = $complex-str; # OK!\nmy Str     $str     = $complex-str; # OK!\nsay 42+0i ∈ <42+0i  55  1>; # False; ∈ operator cares about object identity</code></pre></p>"},"X::Syntax::Missing":{"prefix":"<p><pre><code>class X::Syntax::Missing does X::Syntax { }</code></pre></p><p>Syntax error thrown when the previous piece of syntax requires the existence of another piece of syntax, and that second piece is missing.</p><p>For example</p><p><pre><code>for 1, 2, 3;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nMissing block\n</code></pre></p><p>because a for that is not a statement modifier must be followed by a block.</p>","defs":{},"name":"X::Syntax::Missing"},"X::Syntax::Variable::Numeric":{"name":"X::Syntax::Variable::Numeric","defs":{},"prefix":"<p><pre><code>class X::Syntax::Variable::Numeric does X::Syntax { }</code></pre></p><p>Syntax error thrown when trying to declare numeric symbols.</p><p>For example</p><p><pre><code>my @101;\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nCannot declare a numeric variable\n</code></pre></p>"},"IO::Spec::Cygwin":{"name":"IO::Spec::Cygwin","defs":{"abs2rel":"<p>Defined as:</p><p><pre><code>method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)</code></pre></p><p>Returns a string that represents $path, but relative to $base path. Both $path and $base may be relative paths. $base defaults to $*CWD. Uses IO::Spec::Win32's semantics.</p>","canonpath":"<p>Defined as:</p><p><pre><code>method canonpath(Str() $path, :$parent --> Str:D)</code></pre></p><p>Returns a string that is a canonical representation of $path. If :$parent is set to true, will also clean up references to parent directories. NOTE: the routine does not access the filesystem.</p><p><pre><code>IO::Spec::Cygwin.canonpath(｢C:\\foo\\\\..\\bar\\..\\ber｣).say;\n# OUTPUT: «C:/foo/../bar/../ber␤»\n\nIO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\").say;\n# OUTPUT: «foo/../bar/../ber␤»\n\nIO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\", :parent).say;\n# OUTPUT: «ber␤»</code></pre></p>","splitpath":"<p>Defined as:</p><p><pre><code>method splitpath(|c --> List:D)</code></pre></p><p>Same as IO::Spec::Win32.splitpath, except replaces backslashes with slashes in all the values of the final result.</p>","rel2abs":"<p>Defined as:</p><p><pre><code>method rel2abs(|c --> List:D)</code></pre></p><p>Same as IO::Spec::Win32.rel2abs, except replaces backslashes with slashes in the final result.</p>","catdir":"<p>Defined as:</p><p><pre><code>method catdir (*@parts --> Str:D)</code></pre></p><p>Concatenates multiple path fragments and returns the canonical representation of the resultant path as a string. The @parts are Str objects and are allowed to contain path separators.</p><p><pre><code>IO::Spec::Cygwin.catdir(<foo/bar ber perl>).say;\n# OUTPUT: «foo/bar/ber/perl␤»</code></pre></p>","is-absolute":"<p>Defined as:</p><p><pre><code>method is-absolute(Str:D $path --> Bool:D)</code></pre></p><p>Returns True if the $path starts with a slash (\"/\") or backslash (\"\\\"), even if they have combining character on them, optionally preceded by a volume:</p><p><pre><code>say IO::Spec::Cygwin.is-absolute: \"/foo\";        # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\nsay IO::Spec::Cygwin.is-absolute: \"bar\";         # OUTPUT: «False␤»</code></pre></p>","catpath":"<p>Defined as:</p><p><pre><code>method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)</code></pre></p><p>Same as IO::Spec::Win32.catpath, except will also change all backslashes to slashes at the end:</p><p><pre><code>IO::Spec::Cygwin.catpath('C:', '/some/dir', 'foo.txt').say;\n# OUTPUT: «C:/some/dir/foo.txt␤»\n\nIO::Spec::Cygwin.catpath('C:', '/some/dir', '').say;\n# OUTPUT: «C:/some/dir␤»\n\nIO::Spec::Cygwin.catpath('', '/some/dir', 'foo.txt').say;\n# OUTPUT: «/some/dir/foo.txt␤»\n\nIO::Spec::Cygwin.catpath('E:', '', 'foo.txt').say;\n# OUTPUT: «E:foo.txt␤»</code></pre></p>","split":"<p>Defined as:</p><p><pre><code>method split(|c --> List:D)</code></pre></p><p>Same as IO::Spec::Win32.split, except replaces backslashes with slashes in all the values of the final result.</p>","join":"<p>Defined as:</p><p><pre><code>method join(|c)</code></pre></p><p>Same as IO::Spec::Win32.join, except replaces backslashes with slashes in the final result.</p>"},"prefix":"<p><pre><code>class IO::Spec::QNX is IO::Spec { }</code></pre></p><p>This sub-class of IO::Spec will be available from the $*SPEC variable for a perl running on Cygwin .</p><p>NOTE: the IO::Spec::* classes provide low-level path operations. Unless you're creating your own high-level path manipulation routines, you don't need to use IO::Spec::*. Use IO::Path instead.</p><p>NOTE2: no special validation is done by these classes (e.g. check whether path contains a null character). It is the job of higher-level classes, like IO::Path, to do that.</p>"},"Callable":{"name":"Callable","defs":{"CALL-ME":"<p><pre><code>method CALL-ME(Callable:D $self: |arguments)</code></pre></p><p>This method is required for postfix:«( )» and postfix:«.( )». It's what makes an object actually call-able and needs to be overloaded to let a given object act like a routine. If the object needs to be stored in a &-sigiled container, is has to implement Callable.</p><p><pre><code>class A does Callable {\n    submethod CALL-ME(|c){ 'called' }\n}\nmy &a = A;\nsay a(); # OUTPUT: «called␤»</code></pre></p><p>Applying the Callable role is not a requirement to make an object callable; if a class simply wants to add subroutine-like semantics in a regular scalar container, the submethod CALL-ME can be used for that.</p><p><pre><code>class A {\n    has @.values;\n    submethod CALL-ME(Int $x where 0 <= * < @!values.elems) {\n        @!values[$x]\n    }\n}\nmy $a = A.new: values => [4,5,6,7]\nsay $a(2); # OUTPUT: «6␤»</code></pre></p>"},"prefix":"<p><pre><code>role Callable { ... }</code></pre></p><p>Role for objects which support calling them. It's used in Block, Routine, Sub, Method, Submethod and Macro types.</p><p>Callables can be stored in &-sigiled containers, the default type constraint of such a container is Callable.</p><p><pre><code>my &a = {;}; # Empty block needs a semicolon\nmy &b = -> {};\nmy &c = sub () {};\nsub foo() {};\nmy &d = &foo;</code></pre></p>"},"Distribution":{"name":"Distribution","defs":{"meta":"<p><pre><code>method meta(--> Hash:D) { ... }</code></pre></p><p>Returns a Hash with the representation of the metadata. Please note that an actual META6.json file does not need to exist, just a representation in that format.</p>"},"prefix":"<p><pre><code>role Distribution { }</code></pre></p><p>This role is an interface for objects that provide API access mapping META6 data to the files it represents. Objects that fulfill the Distribution role can be read by e.g. CompUnit::Repository::Installation. Generally a Distribution provides read access to a set of modules and metadata. These may be backed by the filesystem (Distribution::Path, Distribution::Hash) but could also read from an e.g. tar file or socket.</p>"},"DateTime":{"defs":{"Str":"<p>Defined as:</p><p><pre><code>method Str(DateTime:D: --> Str:D)</code></pre></p><p>Returns a string representation of the invocant, as done by the formatter. If no formatter was specified, an ISO 8601 timestamp will be returned.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').Str;\n# OUTPUT: «2015-12-24T12:23:00+02:00␤»\n</code></pre></p>","earlier":"<p>Defined as:</p><p><pre><code>method earlier(DateTime:D: *%unit)</code></pre></p><p>Returns a DateTime object based on the current one, but with a time delta towards the past applied. Unless the given unit is second or seconds, the given value will be converted to an Int. See #method later for usage.</p><p><pre><code>my $d = DateTime.new(date => Date.new('2015-02-27'));\nsay $d.earlier(month => 1).earlier(:2days);  # OUTPUT: «2015-01-25T00:00:00Z␤»</code></pre></p><p>If the resultant time has value 60 for seconds, yet no leap second actually exists for that time, seconds will be set to 59:</p><p><pre><code>say DateTime.new('2008-12-31T23:59:60Z').earlier: :1day;\n# OUTPUT: «2008-12-30T23:59:59Z␤»</code></pre></p><p>Negative offsets are allowed, though later is more idiomatic for that.</p>","whole-second":"<p>Defined as:</p><p><pre><code>method whole-second(DateTime:D:)</code></pre></p><p>Returns the second component, rounded down to an Int.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56.789Z').whole-second;      # OUTPUT: «56␤»</code></pre></p>","Instant":"<p>Defined as:</p><p><pre><code>method Instant(DateTime:D: --> Instant:D)</code></pre></p><p>Returns an Instant object based on the invocant.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').Instant; # OUTPUT: «Instant:1450952616␤»</code></pre></p>","utc":"<p>Defined as:</p><p><pre><code>method utc(DateTime:D: --> DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in time zone UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').utc;\n# OUTPUT: «2015-12-24T10:23:00Z␤»</code></pre></p>","later":"<p>Defined as:</p><p><pre><code>method later(DateTime:D: *%unit)</code></pre></p><p>Returns a DateTime object based on the current one, but with a time delta applied. The time delta can be passed as a named argument where the argument name is the unit.</p><p>Unless the given unit is second or seconds, the given value will be converted to an Int.</p><p>Allowed units are second, seconds, minute, minutes, hour, hours, day, days, week, weeks, month, months, year, years. Please note that the plural forms can only be used with the later and earlier methods.</p><p>The :2nd form of colonpairs can be used as a compact and self-documenting way of specifying the delta:</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').later(:2years);\n# OUTPUT: «2017-12-24T12:23:00Z␤»</code></pre></p><p>Since addition of several different time units is not commutative, only one unit may be passed.</p><p><pre><code>my $d = DateTime.new(date => Date.new('2015-02-27'));\nsay $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29T00:00:00Z␤»\nsay $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01T00:00:00Z␤»\nsay $d.later(days => 2).later(:month);   # same, as +True === 1</code></pre></p><p>If the resultant time has value 60 for seconds, yet no leap second actually exists for that time, seconds will be set to 59:</p><p><pre><code>say DateTime.new('2008-12-31T23:59:60Z').later: :1day;\n# OUTPUT: «2009-01-01T23:59:59Z␤»</code></pre></p><p>Negative offsets are allowed, though earlier is more idiomatic for that.</p>","offset-in-minutes":"<p>Defined as:</p><p><pre><code>method offset-in-minutes(DateTime:D: --> Real:D)</code></pre></p><p>Returns the time zone in minutes as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset-in-minutes; # OUTPUT: «120␤»</code></pre></p>","new":"<p>Defined as:</p><p><pre><code>multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&formatter)\nmulti method new(Date :$date!,\n                 Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                 Int :$timezone = 0, :&formatter)\nmulti method new(Int() $year, Int() $month, Int() $day,\n                 Int() $hour, Int $minute, $second,\n                 Int() :$timezone = 0, :&formatter)\nmulti method new(Instant:D $i,  :$timezone=0, :&formatter)\nmulti method new(Int:D $posix,  :$timezone=0, :&formatter)\nmulti method new(Str:D $format, :$timezone=0, :&formatter)\n</code></pre></p><p>Creates a new DateTime object. One option for creating a new DateTime object is from the components (year, month, day, hour, ...) separately. Another is to pass a Date object for the date component, and specify the time component-wise. Yet another is to obtain the time from an Instant, and only supply the time zone and formatter. Or instead of an Instant you can supply an Int as a UNIX timestamp.</p><p>You can also supply a Str formatted in ISO 8601 timestamp notation or as a full RFC 3339 date and time. Strings should be formatted as yyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less restrictive than the ISO 8601 standard, as we allow Unicode digits and mixing of condensed and extended time formats.</p><p>An invalid input string throws an exception of type X::Temporal::InvalidFormat. If you supply a string that includes a time zone and supply the timezone named argument, an exception of type X::DateTime::TimezoneClash is thrown.</p><p><pre><code>my $datetime = DateTime.new(year => 2015,\n                            month => 1,\n                            day => 1,\n                            hour => 1,\n                            minute => 1,\n                            second => 1,\n                            timezone => 1);\n$datetime = DateTime.new(date => Date.new('2015-12-24'),\n                         hour => 1,\n                         minute => 1,\n                         second => 1,\n                         timezone => 1);\n$datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                         1, 1, 1);   # Hour, minute, second with default time zone\n$datetime = DateTime.new(now);                       # Instant.\n# from a Unix timestamp\nsay $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n$datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string</code></pre></p>","posix":"<p>Defined as:</p><p><pre><code>method posix(Bool:D: $ignore-timezone = False --> Int:D)</code></pre></p><p>Returns the date and time as a POSIX/UNIX timestamp (seconds since the Epoch, 1st January 1970 UTC).</p><p>If $ignore-timezone is True, the DateTime object will be treated as if the time zone offset is zero.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').posix;       # OUTPUT: «1450959780␤»\n</code></pre></p>","local":"<p>Defined as:</p><p><pre><code>method local(DateTime:D: --> DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in the local time zone ($*TZ).</p><p><pre><code>my $*TZ = -3600;\nsay DateTime.new('2015-12-24T12:23:00+0200').local; # OUTPUT: «2015-12-24T09:23:00-0100␤»</code></pre></p>","minute":"<p>Defined as:</p><p><pre><code>method minute(DateTime:D: --> Int:D)</code></pre></p><p>Returns the minute component.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').minute;     # OUTPUT: «34␤»</code></pre></p>","offset-in-hours":"<p>Defined as:</p><p><pre><code>method offset-in-hours(DateTime:D: --> Real:D)</code></pre></p><p>Returns the time zone in hours as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset-in-hours;   # OUTPUT: «2␤»\n</code></pre></p>","clone":"<p>Defined as:</p><p><pre><code>method clone(:$year, :$month, :$day, :$hour, :$minute, :$second, :$timezone, :&formatter)</code></pre></p><p>Creates a new DateTime object based on the invocant, but with the given arguments overriding the values from the invocant.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').clone(hour => 0);\n# OUTPUT: «2015-12-24T00:23:00Z␤»</code></pre></p><p>Note that this can lead to invalid dates in some circumstances:</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56Z\").clone(year => 2015);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::OutOfRange: Day out of range. Is: 29, should be in 1..28␤»</code></pre></p>","now":"<p>Defined as:</p><p><pre><code>method now(:$timezone = $*TZ, :&formatter --> DateTime:D)</code></pre></p><p>Creates a new DateTime object from the current system time. A custom formatter and timezone can be provided. The :$timezone is the offset in seconds from GMT and defaults to the value of $*TZ variable.</p><p><pre><code>say DateTime.now; # OUTPUT: «2018-01-08T13:05:32.703292-06:00␤»</code></pre></p><p>Note that one may use the methods shown below chained to the .now to easily express current values, e.g.,</p><p><pre><code>say DateTime.now.year; # OUTPUT: «2018␤»</code></pre></p>","truncated-to":"<p>Defined as:</p><p><pre><code>method truncated-to(DateTime:D: Cool $unit)</code></pre></p><p>Returns a copy of the invocant, with everything smaller than the specified unit truncated to the smallest possible value.</p><p><pre><code>my $d = DateTime.new(\"2012-02-29T12:34:56.946314Z\");\nsay $d.truncated-to('second');      # OUTPUT: «2012-02-29T12:34:56Z␤»\nsay $d.truncated-to('minute');      # OUTPUT: «2012-02-29T12:34:00Z␤»\nsay $d.truncated-to('hour');        # OUTPUT: «2012-02-29T12:00:00Z␤»\nsay $d.truncated-to('day');         # OUTPUT: «2012-02-29T00:00:00Z␤»\nsay $d.truncated-to('month');       # OUTPUT: «2012-02-01T00:00:00Z␤»\nsay $d.truncated-to('year');        # OUTPUT: «2012-01-01T00:00:00Z␤»</code></pre></p><p>DateTimes with fractional seconds can be truncated to whole seconds with .truncated-to('second').</p>","DateTime":"<p>Defined as:</p><p><pre><code>method DateTime(--> DateTime)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56.946314Z\").DateTime;\n# OUTPUT: «2012-02-29T12:34:56.946314Z␤»\nsay DateTime.DateTime;\n# OUTPUT: «(DateTime)␤»</code></pre></p>","second":"<p>Defined as:</p><p><pre><code>method second(DateTime:D:)</code></pre></p><p>Returns the second component, including potentially fractional seconds.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').second;     # OUTPUT: «56␤»\nsay DateTime.new('2012-02-29T12:34:56.789Z').second; # OUTPUT: «56.789␤»\nsay DateTime.new('2012-02-29T12:34:56,789Z').second; # comma also ok</code></pre></p>","in-timezone":"<p>Defined as:</p><p><pre><code>method in-timezone(DateTime:D: Int(Cool) $timezone = 0 --> DateTime:D)</code></pre></p><p>Returns a DateTime object for the same time, but in the specified $timezone, which is the offset in seconds from GMT.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00Z').in-timezone(3600 + 1800); # OUTPUT: «2015-12-24T13:53:00+0130␤»</code></pre></p><p>Per RFC 7164, leap seconds do not respect local time and always occur at the end of the UTC day:</p><p><pre><code>say DateTime.new: '2017-01-01T00:59:60+01:00'\n# OUTPUT: «2017-01-01T00:59:60+01:00␤»</code></pre></p>","offset":"<p>Defined as:</p><p><pre><code>method offset(DateTime:D: --> Int:D)</code></pre></p><p>Returns the time zone in seconds as an offset from UTC. This is an alias for #method timezone.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').offset;            # OUTPUT: «7200␤»</code></pre></p>","Date":"<p>Defined as:</p><p><pre><code>multi method Date(DateTime:U --> Date:U)\nmulti method Date(DateTime:D --> Date:D)</code></pre></p><p>Converts the invocant to Date.</p><p><pre><code>say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\nsay DateTime.Date;                                    # OUTPUT: «(Date)␤»\n</code></pre></p>","timezone":"<p>Defined as:</p><p><pre><code>method timezone(DateTime:D: --> Int:D)</code></pre></p><p>Returns the time zone in seconds as an offset from UTC.</p><p><pre><code>say DateTime.new('2015-12-24T12:23:00+0200').timezone;          # OUTPUT: «7200␤»</code></pre></p>","hh-mm-ss":"<p>Defined as:</p><p><pre><code>method hh-mm-ss(DateTime:D: --> Str:D)</code></pre></p><p>Returns the time represented by the object as a string in 24-hour HH:MM:SS format:</p><p><pre><code>say DateTime.new(\"2052-02-29T22:34:56Z\").hh-mm-ss;\n# OUTPUT: «22:34:56␤»</code></pre></p>","hour":"<p>Defined as:</p><p><pre><code>method hour(DateTime:D: --> Int:D)</code></pre></p><p>Returns the hour component.</p><p><pre><code>say DateTime.new('2012-02-29T12:34:56Z').hour;      # OUTPUT: «12␤»</code></pre></p>"},"prefix":"<p><pre><code>class DateTime does Dateish {}</code></pre></p><p>For handling points in civil time, a DateTime object stores year, month, day, hour, minute (all Int), second (potentially fractional) and a time zone.</p><p>It provides methods for calculating with date and time.</p><p>DateTime methods are immutable; if you are tempted to modify one, create a modified copy instead.</p><p>Time zones are handled as Integers in seconds offset from UTC, not by time zone name.</p><p><pre><code>my $dt = DateTime.new(\n    year    => 2015,\n    month   => 11,\n    day     => 21,\n    hour    => 16,\n    minute  => 1,\n);\n\nsay $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»\nsay $dt.later(days => 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»\nsay $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»\nsay $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»\n\nmy $now = DateTime.now(formatter => { sprintf \"%02d:%02d\", .hour, .minute });\nsay $now;                           # 12:45 (or something like that)\n</code></pre></p>","name":"DateTime"},"Thread":{"name":"Thread","prefix":"<p><pre><code>class Thread {}</code></pre></p><p>A thread is a sequence of instructions that can (potentially) run in parallel to others. Class Thread provides a bit of abstraction over threads provided by the underlying virtual machines (which in turn might or might not be operating system threads).</p><p>Since threads are fairly low-level, most applications should use other primitives, like start, which also runs in parallel and returns a Promise.</p><p><pre><code>my @threads = (^10).map: {\n    Thread.start(\n        name => \"Sleepsorter $_\",\n        sub {\n            my $rand = (^10).pick;\n            sleep $rand;\n            say $rand;\n        },\n    );\n}\n\n.finish for @threads;\n</code></pre></p><p>The current thread is available in the dynamic variable $*THREAD.</p>","defs":{"start":"<p><pre><code>method start(Thread:U: &code, Bool :$app_lifetime = False, Str :$name = '<anon>' --> Thread:D)</code></pre></p><p>Creates, runs and returns a new Thread. Note that it can (and often does) return before the thread's code has finished running.</p>","yield":"<p><pre><code>method yield(Thread:U)</code></pre></p><p>Tells the scheduler to prefer another thread for now.</p><p><pre><code>Thread.yield;</code></pre></p>","app_lifetime":"<p><pre><code>method app_lifetime(Thread:D: --> Bool:D)</code></pre></p><p>Returns False unless the named parameter :app_lifetime is specifically set to True during object creation. If the method returns False it means that the process will only terminate when the thread has finished while True means that the thread will be killed when the main thread of the process terminates.</p><p><pre><code>my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\nmy $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, :app_lifetime);\n\nsay $t1.app_lifetime;                 # OUTPUT: «False␤»\nsay $t2.app_lifetime;                 # OUTPUT: «True␤»</code></pre></p>","join":"<p><pre><code>method join(Thread:D)</code></pre></p><p>Waits for the thread to finish.</p>","finish":"<p><pre><code>method finish(Thread:D)</code></pre></p><p>Waits for the thread to finish. This is called join in other programming systems.</p>","id":"<p><pre><code>method id(Thread:D: --> Int:D)</code></pre></p><p>Returns a numeric, unique thread identifier.</p>","Str":"<p><pre><code>method Str(Thread:D: --> Str:D)</code></pre></p><p>Returns a string which contains the invocants thread id and name.</p><p><pre><code>my $t = Thread.new(code => { for 1..5 -> $v { say $v }}, name => 'calc thread');\nsay $t.Str;                           # OUTPUT: «Thread<3>(calc thread)␤»</code></pre></p>","run":"<p><pre><code>method run(Thread:D:)</code></pre></p><p>Runs the thread, and returns the invocant. It is an error to run a thread that has already been started.</p>","is-initial-thread":"<p><pre><code>method is-initial-thread(--> Bool)</code></pre></p><p>Returns a Bool indicating whether the current thread (if called as a class method) or the Thread object on which it is called, is the initial thread the program started on.</p><p><pre><code>say Thread.is-initial-thread;    # True if this is the initial thread\nsay $*THREAD.is-initial-thread;  # True if $*THREAD is the initial thread</code></pre></p><p>Please note there is no guarantee that this is actually the main thread from the OS's point of view. Also note that if you need this other than from a pure introspection / debugging point of view, that there are probably better ways to achieve what you're trying to achieve.</p>","new":"<p><pre><code>method new(:&code!, Bool :$app_lifetime = False, Str :$name = '<anon>' --> Thread:D)</code></pre></p><p>Creates and returns a new Thread, without starting it yet. &code is the code that will be run in a separate thread.</p><p>$name is a user-specified string that identifies the thread.</p><p>If $app_lifetime is set to True, then the thread is killed when the main thread of the process terminates. If set to False, the process will only terminate when the thread has finished.</p>","name":"<p><pre><code>method name(Thread:D: --> Str:D)</code></pre></p><p>Returns the user defined string, which can optionally be set during object creation in order to identify the Thread, or '<anon>' if no such string was specified.</p><p><pre><code>my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\nmy $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, name => 'my thread');\n\nsay $t1.name;                 # OUTPUT: «<anon>␤»\nsay $t2.name;                 # OUTPUT: «my thread␤»</code></pre></p>","Numeric":"<p><pre><code>method Numeric(Thread:D: --> Int:D)</code></pre></p><p>Returns a numeric, unique thread identifier, i.e. the same as id.</p>"}},"CX::Done":{"prefix":"<p><pre><code>role CX::Done does X::Control { }</code></pre></p><p>A control exception to be used to indicate a supply block is finished by calling done.</p>","defs":{},"name":"CX::Done"},"CX::Succeed":{"name":"CX::Succeed","prefix":"<p><pre><code>role CX::Succeed does X::Control { }</code></pre></p><p>A control exception thrown when succeed is called from a when or default block.</p>","defs":{}},"Metamodel::C3MRO":{"name":"Metamodel::C3MRO","prefix":"<p><pre><code>role Metamodel::C3MRO { }</code></pre></p><p>Metamodel role for the C3 method resolution order (MRO). Note: this method, along with almost the whole metamodel, is part of the Rakudo implementation.</p><p>The method resolution order for a type is a flat list of types including the type itself, and (recursively) all super classes. It determines in which order the types will be visited for determining which method to call with a given name, or for finding the next method in a chain with nextsame, callsame, nextwith or callwith.</p><p><pre><code>class CommonAncestor { };   # implicitly inherits from Any\nclass Child1 is CommonAncestor { }\nclass Child2 is CommonAncestor { }\nclass GrandChild2 is Child2 { }\nclass Weird is Child1 is GrandChild2 { };\n\nsay Weird.^mro; # OUTPUT: «(Weird) (Child1) (GrandChild2) (Child2) (CommonAncestor) (Any) (Mu)␤»\n</code></pre></p><p>C3 is the default resolution order for classes and grammars in Raku. Note that roles generally do not appear in the method resolution order (unless they are punned into a class, from which another type inherits), because methods are copied into classes at role application time.</p>","defs":{"compute_mro":"<p><pre><code>method compute_mro($type)</code></pre></p><p>Computes the method resolution order.</p>","mro":"<p><pre><code>method mro($type)</code></pre></p><p>Returns a list of types in the method resolution order, even those that are marked is hidden.</p><p><pre><code>say Int.^mro;   # OUTPUT: «((Int) (Cool) (Any) (Mu))␤»</code></pre></p>"}},"Blob":{"name":"Blob","prefix":"<p><pre><code>role Blob[::T = uint8] does Positional[T] does Stringy { }</code></pre></p><p>The Blob role is an immutable interface to binary types, and offers a list-like interface to lists of integers, typically unsigned integers.</p>","defs":{"new":"<p>Defined as:</p><p><pre><code>multi method new(Blob:)\nmulti method new(Blob: Blob:D $blob)\nmulti method new(Blob: int @values)\nmulti method new(Blob: @values)\nmulti method new(Blob: *@values)</code></pre></p><p>Creates an empty Blob, or a new Blob from another Blob, or from a list of integers or values (which will have to be coerced into integers):</p><p><pre><code>my $blob = Blob.new([1, 2, 3]);\nsay Blob.new(<1 2 3>); # OUTPUT: «Blob:0x<01 02 03>␤»</code></pre></p>","read-uint8":"<p>Defined as:</p><p><pre><code>method read-uint8(blob8:D: uint $pos, $endian = NativeEndian --> uint)</code></pre></p><p>Returns an unsigned native integer value for the byte at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","read-num32":"<p>Defined as:</p><p><pre><code>method read-num32(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native num value for the four bytes starting at the given position.</p>","read-int64":"<p>Defined as:</p><p><pre><code>method read-int64(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native int value for the eight bytes starting at the given position.</p>","read-int8":"<p>Defined as:</p><p><pre><code>method read-int8(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native int value for the byte at the given position. The $endian parameter has no meaning, but is available for consistency.</p>","read-uint32":"<p>Defined as:</p><p><pre><code>method read-uint32(blob8:D: uint $pos, $endian = NativeEndian --> uint)</code></pre></p><p>Returns a native uint value for the four bytes starting at the given position.</p>","gist":"<p>Defined as:</p><p><pre><code>method gist(Blob:D: --> Str:D)</code></pre></p><p>Returns the string containing the \"gist\" of the Blob, listing up to the first 100 elements, separated by space, appending an ellipsis if the Blob has more than 100 elements.</p><p><pre><code>put Blob.new(1, 2, 3).gist; # OUTPUT: «Blob:0x<01 02 03>␤»\nput Blob.new(1..2000).gist;\n# OUTPUT:\n# Blob:0x<01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15\n# 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C\n# 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43\n# 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A\n# 5B 5C 5D 5E 5F 60 61 62 63 64 ...></code></pre></p>","subbuf":"<p>Defined as:</p><p><pre><code>multi method subbuf(Int $from, Int $len = self.elems --> Blob:D)\nmulti method subbuf(Range $range --> Blob:D)</code></pre></p><p>Extracts a part of the invocant buffer, starting from the index with elements $from, and taking $len elements (or less if the buffer is shorter), and creates a new buffer as the result.</p><p><pre><code>say Blob.new(1..10).subbuf(2, 4);    # OUTPUT: «Blob:0x<03 04 05 06>␤»\nsay Blob.new(1..10).subbuf(*-2);     # OUTPUT: «Blob:0x<09 0a>␤»\nsay Blob.new(1..10).subbuf(*-5,2);   # OUTPUT: «Blob:0x<06 07>␤»</code></pre></p><p>For convenience, also allows a Range to be specified to indicate which part of the invocant buffer you would like:</p><p><pre><code>say Blob.new(1..10).subbuf(2..5);    # OUTPUT: «Blob:0x<03 04 05 06>␤»</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Blob:D:)</code></pre></p><p>Throws X::Buf::AsStr with Str as payload. In order to convert to a Str you need to use .decode.</p>","Stringy":"<p>Defined as:</p><p><pre><code>multi method Stringy(Blob:D:)</code></pre></p><p>Throws X::Buf::AsStr with Stringy as payload.</p>","allocate":"<p>Defined as:</p><p><pre><code>multi method allocate(Blob:U: Int:D $elements)\nmulti method allocate(Blob:U: Int:D $elements, int $value)\nmulti method allocate(Blob:U: Int:D $elements, Int:D \\value)\nmulti method allocate(Blob:U: Int:D $elements, Mu:D $got)\nmulti method allocate(Blob:U: Int:D $elements, int @values)\nmulti method allocate(Blob:U: Int:D $elements, Blob:D $blob)\nmulti method allocate(Blob:U: Int:D $elements, @values)</code></pre></p><p>Returns a newly created Blob object with the given number of elements. Optionally takes a second argument that indicates the pattern with which to fill the Blob: this can be a single (possibly native) integer value, or any Iterable that generates integer values, including another Blob. The pattern will be repeated if not enough values are given to fill the entire Blob.</p><p><pre><code>my Blob $b0 = Blob.allocate(10,0);\n$b0.say; # OUTPUT: «Blob:0x<00 00 00 00 00 00 00 00 00 00>␤»</code></pre></p><p>If the pattern is a general Mu value, it will fail.</p>","read-uint64":"<p>Defined as:</p><p><pre><code>method read-uint64(blob8:D: uint $pos, $endian = NativeEndian --> UInt:D)</code></pre></p><p>Returns an unsigned integer value for the eight bytes starting at the given position.</p>","read-int128":"<p>Defined as:</p><p><pre><code>method read-int128(blob8:D: uint $pos, $endian = NativeEndian --> Int:D)</code></pre></p><p>Returns an integer value for the sixteen bytes starting at the given position.</p>","read-num64":"<p>Defined as:</p><p><pre><code>method read-num64(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native num value for the eight bytes starting at the given position.</p>","reverse":"<p>Defined as:</p><p><pre><code>method reverse(Blob:D: --> Blob:D)</code></pre></p><p>Returns a Blob with all elements in reversed order.</p><p><pre><code>say Blob.new([1, 2, 3]).reverse;    # OUTPUT: «Blob:0x<03 02 01>␤»\nsay blob16.new([2]).reverse;        # OUTPUT: «Blob[uint16]:0x<02>␤»\nsay buf32.new([16, 32]).reverse;    # OUTPUT: «Buf[uint32]:0x<20 10>␤»</code></pre></p>","elems":"<p>Defined as:</p><p><pre><code>multi method elems(Blob:D:)\nmulti method elems(Blob:U: --> 1)</code></pre></p><p>Returns the number of elements of the buffer.</p><p><pre><code>my $blob = Blob.new([1, 2, 3]);\nsay $blob.elems; # OUTPUT: «3␤»</code></pre></p><p>It will also return 1 on the class object.</p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(Blob:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","Bool":"<p>Defined as:</p><p><pre><code>multi method Bool(Blob:D:)</code></pre></p><p>Returns False if and only if the buffer is empty.</p><p><pre><code>my $blob = Blob.new();\nsay $blob.Bool; # OUTPUT: «False␤»\n$blob = Blob.new([1, 2, 3]);\nsay $blob.Bool; # OUTPUT: «True␤»</code></pre></p>","read-ubits":"<p>Defined as:</p><p><pre><code>method read-ubits(blob8:D: uint $pos, uint $bits --> UInt:D)</code></pre></p><p>Returns an unsigned integer value for the bits from the given bit offset and given number of bits. The endianness of the bits is assumed to be BigEndian.</p>","read-int32":"<p>Defined as:</p><p><pre><code>method read-int32(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native int value for the four bytes starting at the given position.</p>","unpack":"<p>This method is considered experimental, in order to use it you will need to do:</p><p><pre><code>use experimental :pack;</code></pre></p><p>Defined as:</p><p><pre><code>multi method unpack(Blob:D: Str:D $template)\nmulti method unpack(Blob:D: @template)\nmulti sub unpack(Blob:D \\blob, Str:D $template)\nmulti sub unpack(Blob:D \\blob, @template)</code></pre></p><p>Extracts features from the blob according to the template string, and returns them as a list.</p><p>The template string consists of zero or more units that begin with an ASCII letter, and are optionally followed by a quantifier. The quantifier can be * (which typically stands for \"use up the rest of the Blob here\"), or a positive integer (without a +).</p><p>Whitespace between template units is ignored.</p><p>Examples of valid templates include \"A4 C n*\" and \"A*\".</p><p>The following letters are recognized:</p><table class='sections'><tr><th>Letter</th><th>Meaning</th></tr>\n<tr><td>A</tr><td>Extract a string, where each element of the Blob maps to a codepoint</tr></tr>\n<tr><td>a</tr><td>Same as A</tr></tr>\n<tr><td>C</tr><td>Extract an element from the blob as an integer</tr></tr>\n<tr><td>H</tr><td>Extracts a hex string</tr></tr>\n<tr><td>L</tr><td>Extracts four elements and returns them as a single unsigned integer</tr></tr>\n<tr><td>n</tr><td>Extracts two elements and combines them in \"network\" (BigEndian) byte order into a single integer</tr></tr>\n<tr><td>N</tr><td>Extracts four elements and combines them in \"network\" (BigEndian) byte order into a single integer</tr></tr>\n<tr><td>S</tr><td>Extracts two elements and returns them as a single unsigned integer</tr></tr>\n<tr><td>v</tr><td>Same as S</tr></tr>\n<tr><td>V</tr><td>Same as L</tr></tr>\n<tr><td>x</tr><td>Drop an element from the blob (that is, ignore it)</tr></tr>\n<tr><td>Z</tr><td>Same as A</tr></tr>\n</table><p>Example:</p><p><pre><code>use experimental :pack;\nsay Blob.new(1..10).unpack(\"C*\");\n# OUTPUT: «(1 2 3 4 5 6 7 8 9 10)␤»</code></pre></p>","read-uint16":"<p>Defined as:</p><p><pre><code>method read-uint16(blob8:D: uint $pos, $endian = NativeEndian --> uint)</code></pre></p><p>Returns a native uint value for the two bytes starting at the given position.</p>","decode":"<p>Defined as:</p><p><pre><code>multi method decode(Blob:D: $encoding = self.encoding // \"utf-8\")</code></pre></p><p><pre><code>multi method decode(Blob:D: $encoding, Str :$replacement!,\n                    Bool:D :$strict = False)\n</code></pre></p><p><pre><code>multi method decode(Blob:D: $encoding, Bool:D :$strict = False)</code></pre></p><p>Applies an encoding to turn the blob into a Str; the encoding will be UTF-8 by default.</p><p><pre><code>my Blob $blob = \"string\".encode('utf-8');\nsay $blob.decode('utf-8'); # OUTPUT: «string␤»</code></pre></p><p>On malformed utf-8 .decode will throw X::AdHoc. To handle sloppy utf-8 use utf8-c8.</p>","read-uint128":"<p>Defined as:</p><p><pre><code>method read-uint128(blob8:D: uint $pos, $endian = NativeEndian --> UInt:D)</code></pre></p><p>Returns an unsigned integer value for the sixteen bytes starting at the given position.</p>","chars":"<p>Defined as:</p><p><pre><code>method chars(Blob:D:)</code></pre></p><p>Throws X::Buf::AsStr with chars as payload.</p>","read-int16":"<p>Defined as:</p><p><pre><code>method read-int16(blob8:D: uint $pos, $endian = NativeEndian --> int)</code></pre></p><p>Returns a native int value for the two bytes starting at the given position.</p>","bytes":"<p>Defined as:</p><p><pre><code>method bytes(Blob:D: --> Int:D)</code></pre></p><p>Returns the number of bytes used by the elements in the buffer.</p><p><pre><code>say Blob.new([1, 2, 3]).bytes;      # OUTPUT: «3␤»\nsay blob16.new([1, 2, 3]).bytes;    # OUTPUT: «6␤»\nsay blob64.new([1, 2, 3]).bytes;    # OUTPUT: «24␤»</code></pre></p>","list":"<p>Defined as:</p><p><pre><code>multi method list(Blob:D:)</code></pre></p><p>Returns the list of codepoints:</p><p><pre><code>say \"zipi\".encode(\"ascii\").list; # OUTPUT: «(122 105 112 105)␤»</code></pre></p>"}},"X::Syntax":{"name":"X::Syntax","defs":{},"prefix":"<p><pre><code>role X::Syntax does X::Comp { }</code></pre></p><p>Common role for syntax errors thrown by the compiler.</p>"},"Channel":{"defs":{"receive":"<p>Defined as:</p><p><pre><code>method receive(Channel:D:)</code></pre></p><p>Receives and removes an item from the channel. It blocks if no item is present, waiting for a send from another thread.</p><p>Throws an exception of type X::Channel::ReceiveOnClosed if the channel has been closed, and the last item has been removed already, or if close is called while receive is waiting for an item to arrive.</p><p>If the channel has been marked as erratic with method fail, and the last item has been removed, throws the argument that was given to fail as an exception.</p><p>See method poll for a non-blocking version that won't throw exceptions.</p><p><pre><code>my $c = Channel.new;\n$c.send(1);\nsay $c.receive; # OUTPUT: «1␤»</code></pre></p>","close":"<p>Defined as:</p><p><pre><code>method close(Channel:D:)</code></pre></p><p>Close the Channel, normally. This makes subsequent send calls die with X::Channel::SendOnClosed. Subsequent calls of .receive may still drain any remaining items that were previously sent, but if the queue is empty, will throw an X::Channel::ReceiveOnClosed exception. Since you can produce a Seq from a Channel by contextualizing to array with @() or by calling the .list method, these methods will not terminate until the channel has been closed. A whenever-block will also terminate properly on a closed channel.</p><p><pre><code>my $c = Channel.new;\n$c.close;\n$c.send(1);\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n</code></pre></p><p>Please note that any exception thrown may prevent .close from being called, this may hang the receiving thread. Use a LEAVE phaser to enforce the .close call in this case.</p>","poll":"<p>Defined as:</p><p><pre><code>method poll(Channel:D:)</code></pre></p><p>Receives and removes an item from the channel. If no item is present, returns Nil instead of waiting.</p><p><pre><code>my $c = Channel.new;\nPromise.in(2).then: { $c.close; }\n^10 .map({ $c.send($_); });\nloop {\n    if $c.poll -> $item { $item.say };\n    if $c.closed  { last };\n    sleep 0.1;\n}</code></pre></p><p>See method receive for a blocking version that properly responds to channel closing and failure.</p>","fail":"<p>Defined as:</p><p><pre><code>method fail(Channel:D: $error)</code></pre></p><p>Closes the Channel (that is, makes subsequent send calls die), and enqueues the error to be thrown as the final element in the channel. Method receive will throw that error as an exception. Does nothing if the channel has already been closed or .fail has already been called on it.</p><p><pre><code>my $c = Channel.new;\n$c.fail(\"Bad error happens!\");\n$c.receive;\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::AdHoc: Bad error happens!␤»</code></pre></p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture(Channel:D --> Capture:D)</code></pre></p><p>Equivalent to calling .List.Capture on the invocant.</p>","Supply":"<p>Defined as:</p><p><pre><code>method Supply(Channel:D:)</code></pre></p><p>This returns an on-demand Supply that emits a value for every value received on the Channel. done will be called on the Supply when the Channel is closed.</p><p><pre><code>my $c = Channel.new;\nmy Supply $s1 = $c.Supply;\nmy Supply $s2 = $c.Supply;\n$s1.tap(-> $v { say \"First $v\" });\n$s2.tap(-> $v { say \"Second $v\" });\n^10 .map({ $c.send($_) });\nsleep 1;</code></pre></p><p>Multiple calls to this method produce multiple instances of Supply, which compete over the values from the Channel.</p>","send":"<p>Defined as:</p><p><pre><code>method send(Channel:D: \\item)</code></pre></p><p>Enqueues an item into the Channel. Throws an exception of type X::Channel::SendOnClosed if the channel has been closed already. This call will not block waiting for a consumer to take the object. There is no set limit on the number of items that may be queued, so care should be taken to prevent runaway queueing.</p><p><pre><code>my $c = Channel.new;\n$c.send(1);\n$c.send([2, 3, 4, 5]);\n$c.close;\nsay $c.list; # OUTPUT: «(1 [2 3 4 5])␤»</code></pre></p>","closed":"<p>Defined as:</p><p><pre><code>method closed(Channel:D: --> Promise:D)</code></pre></p><p>Returns a promise that will be kept once the channel is closed by a call to method close.</p><p><pre><code>my $c = Channel.new;\n$c.closed.then({ say \"It's closed!\" });\n$c.close;\nsleep 1;</code></pre></p>","list":"<p>Defined as:</p><p><pre><code>method list(Channel:D: --> List:D)</code></pre></p><p>Returns a list based on the Seq which will iterate items in the queue and remove each item from it as it iterates. This can only terminate once the close method has been called.</p><p><pre><code>my $c = Channel.new; $c.send(1); $c.send(2);\n$c.close;\nsay $c.list; # OUTPUT: «(1 2)␤»</code></pre></p>"},"prefix":"<p><pre><code>class Channel {}</code></pre></p><p>A Channel is a thread-safe queue that helps you to send a series of objects from one or more producers to one or more consumers. Each object will arrive at only one such consumer, selected by the scheduler. If there is only one consumer and one producer, the order of objects is guaranteed to be preserved. Sending on a Channel is non-blocking.</p><p><pre><code>my $c = Channel.new;\nawait (^10).map: {\n    start {\n        my $r = rand;\n        sleep $r;\n        $c.send($r);\n    }\n}\n$c.close;\nsay $c.list;</code></pre></p><p>Further examples can be found in the concurrency page</p>","name":"Channel"},"Block":{"defs":{},"prefix":"<p><pre><code>class Block is Code { }</code></pre></p><p>A Block is a code object meant for small-scale code reuse. A block is created syntactically by a list of statements enclosed in curly braces.</p><p>Without an explicit signature or placeholder arguments, a block has $_ as a positional argument</p><p><pre><code>my $block = { uc $_; };\nsay $block.^name;           # OUTPUT: «Block␤»\nsay $block('hello');        # OUTPUT: «HELLO␤»</code></pre></p><p>A block can have a Signature between ->  or <->  and the block:</p><p><pre><code>my $add = -> $a, $b = 2 { $a + $b };\nsay $add(40);               # OUTPUT: «42␤»</code></pre></p><p>If the signature is introduced with <-> , then the parameters are marked as rw by default: </p><p><pre><code>my $swap = <-> $a, $b { ($a, $b) = ($b, $a) };\nmy ($a, $b) = (2, 4);\n$swap($a, $b);\nsay $a;                     # OUTPUT: «4␤»</code></pre></p><p>Blocks that aren't of type Routine (which is a subclass of Block) are transparent to return.</p><p><pre><code>sub f() {\n    say <a b c>.map: { return 42 };\n                   #   ^^^^^^   exits &f, not just the block\n}</code></pre></p><p>The last statement is the implicit return value of the block.</p><p><pre><code>say {1}.(); # OUTPUT: «1␤»</code></pre></p><p>Bare blocks are automatically executed in the order they appear:</p><p><pre><code>say 1;                # OUTPUT: «1␤»\n{\n    say 2;            # OUTPUT: «2␤»; executed directly, not a Block object\n}\nsay 3;                # OUTPUT: «3␤»</code></pre></p>","name":"Block"},"X::Anon::Multi":{"prefix":"<p><pre><code>class X::Anon::Multi does X::Comp { }</code></pre></p><p>Compile time error thrown when an anonymous multi is being declared.</p><p>For example</p><p><pre><code>multi method () { }\n</code></pre></p><p>dies with</p><p><pre><code>Cannot put multi on anonymous method\n</code></pre></p>","defs":{"multiness":"<p><pre><code>method multiness(--> Str:D)</code></pre></p><p>Returns a string describing the multiness that the original code used, for example \"multi\" or \"proto\".</p>"},"name":"X::Anon::Multi"},"X::TypeCheck::Assignment":{"name":"X::TypeCheck::Assignment","prefix":"<p><pre><code>class X::TypeCheck::Assignment is X::TypeCheck { }</code></pre></p><p>Error class thrown when the type check of an assignment fails.</p><p>For example, this will die</p><p><pre><code>my Int $x = \"foo\";\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (\"foo\")␤»</code></pre></p><p>though compilers are allowed to detect obvious cases like this example and complain at compile time with a different error.</p>","defs":{}},"X::Signature::NameClash":{"name":"X::Signature::NameClash","defs":{},"prefix":"<p><pre><code>my class X::Signature::NameClash does X::Comp { }</code></pre></p><p>Compile time error thrown when two named parameters have the same name, potentially through aliases.</p><p>For example</p><p><pre><code>sub f(:$a, :a(:@b)) { }\n</code></pre></p><p>dies with</p><p><pre><code>===SORRY!===\nName a used for more than one named parameter\n</code></pre></p>"},"Scheduler":{"name":"Scheduler","prefix":"<p><pre><code>role Scheduler {\n    has &.uncaught_handler is rw\n}</code></pre></p><p>Common role for schedulers. A scheduler is a piece of code that determines which resources to use to run which task, and when.</p><p>Some operations for example on Proc::Async, Promise, Supply allow you to specify a scheduler explicitly; they generally expect those schedulers to follow the interface defined by Scheduler</p>","defs":{"uncaught_handler":"<p><pre><code>method uncaught_handler() is rw</code></pre></p><p>RW-Accessor for the handler that is caught for uncaught exceptions from the code that is being scheduled and run.</p>"}},"IO::Special":{"name":"IO::Special","prefix":"<p><pre><code>class IO::Special does IO { }\n</code></pre></p><p>Used as a $.path attribute in filehandles for special standard input $*IN and output $*OUT and $*ERR. Provides a bridged interface of IO::Handle, mostly file tests and stringification.</p>","defs":{"IO":"<p><pre><code>method IO(IO::Special:D: --> IO::Special)</code></pre></p><p>Returns the invocant.</p><p><pre><code>say $*IN.path.IO.what;  # OUTPUT: «<STDIN>␤»\nsay $*IN.path.what;     # OUTPUT: «<STDIN>␤»</code></pre></p>","d":"<p><pre><code>method d(IO::Special:D: --> False)</code></pre></p><p>The 'directory' file test operator, always returns False.</p>","f":"<p><pre><code>method f(IO::Special:D: --> False)</code></pre></p><p>The 'file' file test operator, always returns False.</p>","s":"<p><pre><code>method s(IO::Special:D: --> 0)</code></pre></p><p>The 'size' file test operator, always returns 0.</p>","x":"<p><pre><code>method x(IO::Special:D: --> False)</code></pre></p><p>The 'execute access' file test operator, always returns False.</p>","changed":"<p><pre><code>method changed(IO::Special:D: --> Instant)</code></pre></p><p>The last changed time for the filehandle. It always returns an Instant type object.</p>","Str":"<p><pre><code>method Str(IO::Special:D:)</code></pre></p><p>This returns '<STDIN>', '<STDOUT>', or '<STDERR>' as appropriate.</p>","WHICH":"<p><pre><code>method WHICH(IO::Special:D: --> Str)</code></pre></p><p>This returns a string that identifies the object. The string is composed by the type of the instance (IO::Special) and the what attribute:</p><p><pre><code>$*IN.path.what;  # OUTPUT: «<STDIN>␤»\n$*IN.path.WHICH; # OUTPUT: «IO::Special<STDIN>␤»</code></pre></p>","accessed":"<p><pre><code>method accessed(IO::Special:D: --> Instant)</code></pre></p><p>The last accessed time for the filehandle. It always returns an Instant type object.</p>","what":"<p><pre><code>say $*IN.path.what;  # OUTPUT: «<STDIN>␤»\nsay $*OUT.path.what; # OUTPUT: «<STDOUT>␤»\nsay $*ERR.path.what; # OUTPUT: «<STDERR>␤»</code></pre></p><p>Returns one of the strings '<STDIN>', '<STDOUT>', or '<STDERR>', specifying the type of the special IO device.</p>","r":"<p><pre><code>method r(IO::Special:D: --> Bool)</code></pre></p><p>The 'read access' file test operator, returns True if and only if this instance represents the standard input handle(<STDIN>).</p>","l":"<p><pre><code>method l(IO::Special:D: --> False)</code></pre></p><p>The 'symbolic links' file test operator, always returns False.</p>","new":"<p><pre><code>method new(:$!what!)\n</code></pre></p><p>Takes a single required attribute what. It is unlikely that you will ever need to construct one of these objects yourself.</p>","modified":"<p><pre><code>method modified(IO::Special:D: --> Instant)</code></pre></p><p>The last modified time for the filehandle. It always returns an Instant type object.</p>","w":"<p><pre><code>method w(IO::Special:D: --> Bool)</code></pre></p><p>The 'write access' file test operator, returns True only if this instance represents either the standard output (<STOUT>) or the standard error (<STDERR>) handle.</p>","e":"<p><pre><code>method e(IO::Special:D: --> True)</code></pre></p><p>The 'exists' file test operator, always returns True.</p>"}},"CX::Take":{"name":"CX::Take","defs":{},"prefix":"<p><pre><code>role CX::Take does X::Control { }</code></pre></p><p>A control exception triggered by take.</p>"},"X::TypeCheck":{"name":"X::TypeCheck","prefix":"<p><pre><code>class X::TypeCheck is Exception { }</code></pre></p><p>Error class thrown when a type check fails.</p>","defs":{"got":"<p><pre><code>method got()</code></pre></p><p>Returns the object that failed to type check</p>","operation":"<p><pre><code>method operation(--> Str:D)</code></pre></p><p>Returns a string description of the operation that failed, for example \"assignment\", \"binding\", \"return\".</p>"}},"X::IO::Cwd":{"prefix":"<p><pre><code>class X::IO::Cwd does X::IO is Exception { }\n</code></pre></p><p>Error class when the runtime fails to determine the current directory.</p><p>A typical error message is</p><p><pre><code>Failed to get the working directory: permission denied\n</code></pre></p>","defs":{},"name":"X::IO::Cwd"},"IO::Socket::INET":{"prefix":"<p><pre><code>class IO::Socket::INET does IO::Socket {}\n</code></pre></p><p>IO::Socket::INET provides TCP sockets, both the server and the client side.</p><p>For UDP support, please see IO::Socket::Async.</p><p>Here is an example of a very simplistic \"echo\" server that listens on localhost, port 3333:</p><p><pre><code>my $listen = IO::Socket::INET.new( :listen,\n                                   :localhost<localhost>,\n                                   :localport(3333) );\nloop {\n    my $conn = $listen.accept;\n    try {\n        while my $buf = $conn.recv(:bin) {\n            $conn.write: $buf;\n        }\n    }\n    $conn.close;\n\n    CATCH {\n          default { .payload.say;      }\n    }\n\n}\n</code></pre></p><p>And a client that connects to it, and prints out what the server answers:</p><p><pre><code>my $conn = IO::Socket::INET.new( :host<localhost>,\n                                 :port(3333) );\n$conn.print: 'Hello, Raku';\nsay $conn.recv;\n$conn.close;\n</code></pre></p><p>Please bear in mind that this is a synchronous connection; an attempt by any of the nodes to write without the other reading will produce an Could not receive data from socket: Connection reset by peer error.</p>","defs":{"get":"<p><pre><code>method get()</code></pre></p><p>Reads a line from the socket and returns it as of type Str. Return Nil on end-of-file (EOF).</p>","lines":"<p><pre><code>method lines()</code></pre></p><p>Returns a lazy list of lines read from the socket.</p>","new":"<p><pre><code>multi method new(\n        :$host,\n        :$port,\n        :$family = PF_INET,\n        :$encoding = 'utf-8',\n        :$nl-in = \"\\r\\n\",\n    --> IO::Socket::INET:D)\nmulti method new(\n        :$localhost,\n        :$localport,\n        :$family = PF_INET,\n        :$listen,\n        :$encoding = 'utf-8',\n        :$nl-in = \"\\r\\n\",\n    --> IO::Socket::INET:D)\n</code></pre></p><p>Creates a new socket.</p><p>If :$listen is True, creates a new socket that listen on :$localhost (which can be an IP address or a domain name) on port :$localport; in other words the :$listen flag determines the server mode of the socket. Otherwise (i.e., :$listen is False), the new socket opens immediately a connection to :$host on port :$port.</p><p>:$family defaults to PF_INET constant for IPv4, and can be set to PF_INET6 constant for IPv6.</p><p>For text operations (such as #method lines and #method get), :$encoding specifies the encoding, and :$nl-in determines the character(s) that separate lines.</p>"},"name":"IO::Socket::INET"},"Slip":{"name":"Slip","prefix":"<p><pre><code>class Slip is List {}</code></pre></p><p>A Slip is a List that automatically flattens into an outer List (or other list-like container or iterable).</p><p>For example it allows you to write a map that produces more than one value into the result without nesting:</p><p><pre><code>say <a b c>.map({ ($_, $_.uc).Slip }).join('|');        # OUTPUT: «a|A|b|B|c|C␤»\n</code></pre></p><p>In contrast, when returning an ordinary List, the resulting list is nested:</p><p><pre><code>say <a b c>.map({ $_, $_.uc }).join('|');               # OUTPUT: «a A|b B|c C␤»\n</code></pre></p><p>To create a Slip, either coerce another list-like type to it by calling the Slip method, or use the slip subroutine:</p><p><pre><code># This says \"1\" and then says \"2\", rather than saying \"(1 2)\"\n.say for gather {\n    take slip(1, 2);\n}</code></pre></p><p>A Slip may also be created by using the prefix:<|> operator. This differs from the slip subroutine in both precedence and treatment of single arguments. In fact, prefix:<|> only takes a single argument, so in that way, it behaves closer to the .Slip method than the slip subroutine.</p><p><pre><code>my $l = (1, 2, 3);\nsay (1, slip 2, 3).perl;  # says (1, 2, 3)      , slips 2, 3 into (1, …)\nsay (0, slip $l).perl;    # says (0, $(1, 2, 3)), $l does not break apart\nsay (0, $l.Slip).perl;    # says (0, 1, 2, 3)   , slips from $l into (0, …)\nsay (|$l).perl;           # says slip(1, 2, 3)  , breaks apart $l\nsay (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\nsay (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\nsay (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\nsay (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n</code></pre></p><p>Loops that do not want to produce a value for an iteration use Slips, rather than empty Lists to do so, as do if statements that do not run their blocks.</p><p>Please note that prefix:<|> will also apply parameters in a slippy manner to a routine call. It does not forward a Slip to the called routine, that includes return and take.</p><p><pre><code>my \\l = gather for 1..10 -> $a, $b { take |($a, $b) }; say l.perl;\n# OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»\nmy \\m= gather for 1..10 -> $a, $b { take ($a, $b).Slip }; say m.perl;\n# OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»</code></pre></p>","defs":{"List":"<p>Defined as:</p><p><pre><code>multi method List(Slip:D: --> List:D)</code></pre></p><p>Turns it into a list.</p>"}},"Stash":{"name":"Stash","prefix":"<p><pre><code>class Stash is Hash { }</code></pre></p><p>A Stash is a hash that is used for symbol tables at the package scoping level in Raku.</p><p>To get a Stash, you can call the .WHO pseudo-method on a package (because it answers the question who lives here?), or if you write the package name as a literal, append two colons:</p><p><pre><code>class Boring {\n    class Nested { };\n    our sub package_sub { }\n    my sub lexical { };\n    method a_method() { }\n}\nsay Boring::.^name;             # OUTPUT: «Stash␤»\nsay Boring.WHO === Boring::;    # OUTPUT: «True␤»</code></pre></p><p>Since it inherits from Hash, you can use all the usual hash functionality:</p><p><pre><code>say Boring::.keys.sort;         # OUTPUT: «(&package_sub Nested)␤»\nsay Boring::<Nested>;           # OUTPUT: «(Nested)␤»\n</code></pre></p><p>As the example above shows only \"our\"-scoped things appear in the Stash (nested classes are \"our\" by default, but can be excluded with \"my\".) Lexicals and methods are not included in a Stash, since they do not live in the package table. Lexicals live in a separate lexical pad, which is only visible from inside the scope. Methods (in the case that the package is also a class) have a separate method table, and are accessible through introspection on the class itself, via .can and .^methods.</p>","defs":{}},"Num":{"defs":{"rand":"<p><pre><code>method rand(Num:D: --> Num)</code></pre></p><p>Returns a pseudo random number between 0 and the invocant.</p>","Capture":"<p>Defined as:</p><p><pre><code>method Capture()</code></pre></p><p>Throws X::Cannot::Capture.</p>"},"prefix":"<p><pre><code>class Num is Cool does Real { }</code></pre></p><p>A Num object stores a floating-point number. It is immutable. On most platforms, it's an IEEE 754 64-bit floating point numbers, aka \"double precision\".</p><p> </p>","name":"Num"},"Code":{"prefix":"<p><pre><code>class Code is Any does Callable {}</code></pre></p><p>Code is the ultimate base class of all code objects in Raku. It exposes functionality that all code objects have. While thunks are directly of type Code, most code objects (such as those resulting from blocks, subroutines or methods) will belong to some subclass of Code.</p>","defs":{"ACCEPTS":"<p><pre><code>multi method ACCEPTS(Code:D: Mu $topic)</code></pre></p><p>Usually calls the code object and passes $topic as an argument. However, when called on a code object that takes no arguments, the code object is invoked with no arguments and $topic is dropped. The result of the call is returned.</p>","of":"<p>Defined as:</p><p><pre><code>method of(Code:D: --> Mu)</code></pre></p><p>Returns the return type constraint of the Code:</p><p><pre><code>say -> () --> Int {}.of; # OUTPUT: «(Int)␤»</code></pre></p>","Str":"<p>Defined as:</p><p><pre><code>multi method Str(Code:D: --> Str:D)</code></pre></p><p>Will output the method name, but also produce a warning. Use .perl or .gist instead.</p><p><pre><code>sub marine() { }\nsay ~&marine;\n# OUTPUT: «Sub object coerced to string (please use .gist or .perl to do that)␤marine␤»\nsay &marine.Str;\n# OUTPUT: «Sub object coerced to string (please use .gist or .perl to do that)␤marine␤»\nsay &marine.perl; # OUTPUT: «sub marine { #`(Sub|94280758332168) ... }␤»</code></pre></p>","signature":"<p>Defined as:</p><p><pre><code>multi method signature(Code:D: --> Signature:D)</code></pre></p><p>Returns the Signature object for this code object, which describes its parameters.</p><p><pre><code>sub a(Int $one, Str $two) {};\nsay &a.signature; # OUTPUT: «(Int $one, Str $two)␤»</code></pre></p>","cando":"<p><pre><code>method cando(Capture $c)</code></pre></p><p>Returns a list of candidates that can be called with the given Capture. Since Code objects do not have any multiple dispatch, this either returns a list with the object, or an empty list.</p><p><pre><code>my $single = \\'a';         # a single argument Capture\nmy $plural = \\('a', 42);   # a two argument Capture\nmy &block = { say $^a };   # a Block object, that is a subclass of Code, taking one argument\nsay &block.cando($single); # OUTPUT: «(-> $a { #`(Block|94212856419136) ... })␤»\nsay &block.cando($plural); # OUTPUT: «()␤»</code></pre></p>","file":"<p>Defined as:</p><p><pre><code>method file(Code:D: --> Str:D)</code></pre></p><p>Returns the name of the file in which the code object was declared.</p><p><pre><code>say &infix:<+>.file;</code></pre></p>","count":"<p>Defined as:</p><p><pre><code>method count(Code:D: --> Real:D)</code></pre></p><p>Returns the maximum number of positional arguments that may be passed when calling the code object. For code objects that can accept any number of positional arguments (that is, they have a slurpy parameter), count will return Inf. Named parameters do not contribute.</p><p><pre><code>sub argless() { }\nsub args($a, $b?) { }\nsub slurpy($a, $b, *@c) { }\nsay &argless.count;             # OUTPUT: «0␤»\nsay &args.count;                # OUTPUT: «2␤»\nsay &slurpy.count;              # OUTPUT: «Inf␤»</code></pre></p>","arity":"<p>Defined as:</p><p><pre><code>method arity(Code:D: --> Int:D)</code></pre></p><p>Returns the minimum number of positional arguments that must be passed in order to call the code object. Any optional or slurpy parameters in the code object's Signature do not contribute, nor do named parameters.</p><p><pre><code>sub argless() { }\nsub args($a, $b?) { }\nsub slurpy($a, $b, *@c) { }\nsay &argless.arity;             # OUTPUT: «0␤»\nsay &args.arity;                # OUTPUT: «1␤»\nsay &slurpy.arity;              # OUTPUT: «2␤»</code></pre></p>","assuming":"<p><pre><code>method assuming(Callable:D $self: |primers)</code></pre></p><p>Returns a Callable that implements the same behavior as the original, but has the values passed to .assuming already bound to the corresponding parameters.</p><p><pre><code>my sub slow($n){ my $i = 0; $i++ while $i < $n; $i };\n\n# takes only one parameter and as such wont forward $n\nsub bench(&c){ c, now - ENTER now };\n\nsay &slow.assuming(10000000).&bench; # OUTPUT: «(10000000 7.5508834)␤»</code></pre></p><p>For a sub with arity greater than one, you can use Whatever * for all of the positional parameters that are not \"assumed\".</p><p><pre><code>sub first-and-last ( $first, $last ) {\n    say \"Name is $first $last\";\n}\n\nmy &surname-smith = &first-and-last.assuming( *, 'Smith' );\n\n&surname-smith.( 'Joe' ); # OUTPUT: «Name is Joe Smith␤»</code></pre></p><p>You can handle any combination of assumed and not assumed positional parameters:</p><p><pre><code>sub longer-names ( $first, $middle, $last, $suffix ) {\n    say \"Name is $first $middle $last $suffix\";\n}\n\nmy &surname-public = &longer-names.assuming( *, *, 'Public', * );\n\n&surname-public.( 'Joe', 'Q.', 'Jr.'); # OUTPUT: «Name is Joe Q. Public Jr.␤»\n</code></pre></p><p>Named parameters can be assumed as well:</p><p><pre><code>sub foo { say \"$^a $^b $:foo $:bar\" }\n&foo.assuming(13, :42foo)(24, :72bar); # OUTPUT: «13 24 42 72␤»</code></pre></p><p>And you can use .assuming on all types of Callables, including Methods and Blocks:</p><p><pre><code># We use a Whatever star for the invocant:\nmy &comber = Str.^lookup('comb').assuming: *, /P \\w+/;\nsay comber 'Perl is awesome! Python is great! And PHP is OK too';\n# OUTPUT: «(Perl Python PHP)␤»\n\nmy &learner = {\n    \"It took me $:months months to learn $^lang\"\n}.assuming: 'Raku';\nsay learner :6months;  # OUTPUT: «It took me 6 months to learn Raku␤»</code></pre></p>"},"name":"Code"},"X::OutOfRange":{"defs":{"range":"<p><pre><code>method range(--> Range:D)</code></pre></p><p>Returns a Range object describing the permissible range for the object returned from .got.</p>","got":"<p><pre><code>method got()</code></pre></p><p>Returns the object that was considered out of range (often an integer)</p>","what":"<p><pre><code>method what(--> Str:D)</code></pre></p><p>Verbal description of the thing that was out of range (e.g. \"array index\", \"month\").</p>"},"prefix":"<p><pre><code>class X::OutOfRange is Exception { }</code></pre></p><p>General error when something (for example an array index) is out of an allowed range.</p><p>For example</p><p><pre><code>say 42[2];\nCATCH { default { put .^name, ': ', .Str } };\n# OUTPUT: «X::OutOfRange: Index out of range. Is: 2, should be in 0..0␤»</code></pre></p><p>since scalars generally act as a one-element list.</p>","name":"X::OutOfRange"},"Test":{"name":"Test","defs":{},"prefix":"<p>This module provides a testing framework, and is used in the official suite that tests the specification. All its functions emit output conforming to the Test Anything Protocol.</p>"}},"ops":{"&infix:<==>>":"<p>This feed operator takes the result from the left and passes it to the next (right) routine as the last parameter.</p><p><pre><code>my @array = (1, 2, 3, 4, 5);\n@array ==> sum() ==> say();   # OUTPUT: «15␤»</code></pre></p><p>This simple example, above, is the equivalent of writing:</p><p><pre><code>my @array = (1, 2, 3, 4, 5);\nsay(sum(@array));             # OUTPUT: «15␤»</code></pre></p><p>Or if using methods:</p><p><pre><code>my @array = (1, 2, 3, 4, 5);\n@array.sum.say;               # OUTPUT: «15␤»</code></pre></p><p>The precedence is very loose so you will need to use parentheses to assign the result or you can even just use another feed operator! In the case of routines/methods that take a single argument or where the first argument is a block, it's often required that you call with parentheses (though this is not required for the very last routine/method).</p><p>This \"traditional\" structure, read bottom-to-top, with the last two lines creating the data structure that is going to be processed</p><p><pre><code>my @fractions = <TWO THREE FOUR FIVE SEVEN> »~» \" \" X~ <FIFTHS SIXTHS EIGHTHS>;\nmy @result = map { .uniparse },                    # (3) Converts to unicode\n    grep { .uniparse },                            # (2) Checks if it parses\n    map( {\"VULGAR FRACTION \" ~ $^þ }, @fractions); # (1) Adds string to input\n\n# @result is [⅖ ⅗ ⅜ ⅘ ⅚ ⅝ ⅞]</code></pre></p><p>Now we use the feed operator (left-to-right) with parentheses, read top-to-bottom</p><p><pre><code>my @result = (\n    <TWO THREE FOUR FIVE SEVEN> »~» \" \" X~ <FIFTHS SIXTHS EIGHTHS> # (1) Input\n    ==> map( {\"VULGAR FRACTION \" ~ $^þ } )                         # (2) Converts to Unicode name\n    ==> grep({ .uniparse })                                        # (3) Filters only real names\n    ==> map( { .uniparse} );                                       # (4) Converts to unicode\n);</code></pre></p><p>For illustration, method chaining equivalent, read top-to-bottom, using the same sequence as above</p><p><pre><code>my @result = ( <TWO THREE FOUR FIVE SEVEN> »~» \" \" X~ <FIFTHS SIXTHS EIGHTHS>)\n    .map( {\"VULGAR FRACTION \" ~ $^þ } )\n    .grep({ .uniparse })\n    .map({ .uniparse });</code></pre></p><p>Although in this particular case the result is the same, the feed operator ==> more clearly shows intent with arrow pointing in the direction of the data flow. To assign without the need of parentheses use another feed operator</p><p><pre><code>my @result;\n<people of earth>\n    ==> map({ .tc })\n    ==> grep /<[PE]>/\n    ==> sort()\n    ==> @result;</code></pre></p><p>It can be useful to capture a partial result, however, unlike the leftward feed operator, it does require parentheses or a semicolon</p><p><pre><code>my @result;\n<people of earth>\n    ==> map({ .tc })\n    ==> my @caps; @caps   # also could wrap in parentheses instead\n    ==> grep /<[PE]>/\n    ==> sort()\n    ==> @result;</code></pre></p><p>The feed operator lets you construct method-chaining-like patterns out of routines and the results of methods on unrelated data. In method-chaining, you are restricted to the methods available on the data or the result of previous method call. With feed operators, that restriction is gone. The resulting code could also be seen to be more readable than a series of method calls broken over multiple lines.</p><p>Note: In the future, this operator will see some change as it gains the ability to run list operations in parallel. It will enforce that the left operand is enclosable as a closure (that can be cloned and run in a subthread).</p>","&infix:<Z>":"<p><pre><code>sub infix:<Z>(**@lists --> Seq:D) is assoc<chain></code></pre></p><p>The Zip operator interleaves the lists passed to Z like a zipper, taking index-corresponding elements from each operand. The returned Seq contains nested lists, each with a value from every operand in the chain. If one of the operands runs out of elements prematurely, the zip operator will stop.</p><p><pre><code>say (1, 2 Z <a b c> Z <+ ->).perl;\n# OUTPUT: «((1, \"a\", \"+\"), (2, \"b\", \"-\")).Seq␤»\nfor <a b c> Z <1 2 3 4> -> [$l, $r] {\n    say \"$l:$r\"\n}\n# OUTPUT: «a:1␤b:2␤c:3␤»\n</code></pre></p><p>The Z operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p><p><pre><code>say 100, 200 Z+ 42, 23;             # OUTPUT: «(142 223)␤»\nsay 1..3 Z~ <a b c> Z~ 'x' xx 3;    # OUTPUT: «(1ax 2bx 3cx)␤»</code></pre></p><p> </p>","&postfix:<++>":"<p><pre><code>multi sub postfix:<++>($x is rw) is assoc<non></code></pre></p><p>Increments its argument by one and returns the original value.</p><p><pre><code>my $x = 3;\nsay $x++;   # OUTPUT: «3␤»\nsay $x;     # OUTPUT: «4␤»</code></pre></p><p>It works by calling the succ method (for successor) on its argument, which gives custom types the freedom to implement their own increment semantics.</p><p>Note that this does not necessarily return its argument; e.g., for undefined values, it returns 0:</p><p><pre><code>my $x;\nsay $x++;   # OUTPUT: «0␤»\nsay $x;     # OUTPUT: «1␤»</code></pre></p><p>Increment on Str will increment the number part of a string and assign the resulting string to the container. A is rw-container is required.</p><p><pre><code>my $filename = \"somefile-001.txt\";\nsay $filename++ for 1..3;\n# OUTPUT: «somefile-001.txt␤somefile-002.txt␤somefile-003.txt␤»</code></pre></p>","&infix:<ff^>":"<p><pre><code>sub infix:<ff^>(Mu $a, Mu $b)</code></pre></p><p>Works like ff, except it does not return True for items matching the stop condition (including items that first matched the start condition).</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ ff^ /C/ for @list;   # OUTPUT: «A␤B␤»</code></pre></p><p>The sed-like version can be found in fff^.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<orelse>":"<p>The orelse operator is similar to infix //, except with looser precedence and $_ aliasing.</p><p>Returns the first defined argument, or else the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as an argument if the right side is a Callable, whose count must be 0 or 1.</p><p>This operator is useful for handling Failures returned by routines since the expected value is usually defined and Failure never is:</p><p><pre><code>sub meows { ++$ < 4 ?? fail 'out of meows!' !! '\uD83D\uDC31' }\n\nsub meows-processor1 { meows() orelse .return } # return handled Failure\nsub meows-processor2 { meows() orelse fail $_ } # return re-armed Failure\nsub meows-processor3 {\n    # Use non-Failure output, or else print a message that stuff's wrong\n    meows() andthen .say orelse ‘something's wrong’.say;\n}\n\nsay \"{.^name}, {.handled}\"  # OUTPUT: «Failure, True␤»\n    given meows-processor1;\nsay \"{.^name}, {.handled}\"  # OUTPUT: «Failure, False␤»\n    given meows-processor2;\nmeows-processor3;           # OUTPUT: «something's wrong␤»\nmeows-processor3;           # OUTPUT: «\uD83D\uDC31␤»</code></pre></p>","&infix:<*>":"<p><pre><code>multi sub infix:<*>(Any, Any --> Numeric:D)</code></pre></p><p>Multiplication operator.</p><p>Coerces both arguments to Numeric and multiplies them. The result is of the wider type. See Numeric for details.</p>","&infix:<max>":"<p>Returns the largest of the arguments, as determined by cmp semantics.</p><p><pre><code>my $foo = -42;\n$foo max= 0   # read as: $foo increases to 0</code></pre></p>","&infix:<(+)>":"<p><pre><code>multi sub infix:<(+)>(**@p)\nmulti sub infix:<⊎>(**@p)</code></pre></p><p>Baggy addition operator.</p><p>Returns the Baggy addition of its arguments. This creates a new Bag from each element of the arguments with the weights of the element added together to get the new weight, if none of the arguments are a Mix or MixHash.</p><p><pre><code>say <a a b c a d> (+) <a a b c c>; # OUTPUT: «Bag(a(5), b(2), c(3), d)␤»\n</code></pre></p><p>If any of the arguments is a Mixy, the result is a new Mix.</p><p><pre><code>say <a b c> (+) (a => 2.5, b => 3.14).Mix; # OUTPUT: «Mix(a(3.5), b(4.14), c)␤»\n</code></pre></p><p>⊎ is equivalent to (+), at codepoint U+228E (MULTISET UNION).</p>","&infix:<unicmp>":"<p>Defined as:</p><p><pre><code>multi sub infix:<unicmp>(Str:D \\a, Str:D \\b --> Order:D)\nmulti sub infix:<unicmp>(Pair:D \\a, Pair:D \\b --> Order:D)\nmulti sub infix:<coll>(Pair:D \\a, Pair:D \\b --> Order:D)</code></pre></p><p>Unlike the cmp operator which sorts according to codepoint, unicmp and coll sort according to how most users would expect, that is, disregarding aspects of the particular character like capitalization.</p><p><pre><code>say 'a' unicmp 'Z'; # Less\nsay 'a' coll 'Z';   # Less\nsay 'a' cmp 'Z';    # More</code></pre></p><p>The main difference between coll and unicmp is that the behavior of the former can be changed by the $*COLLATION dynamic variable.</p><p>NOTE: These are not yet implemented in the JVM.</p>","&prefix:<->":"<p><pre><code>multi sub prefix:<->(Any --> Numeric:D)</code></pre></p><p>Negative numeric context operator.</p><p>Coerces the argument to Numeric by calling the Numeric method on it, and then negates the result.</p>","&infix:<||>":"<p>Returns the first argument that evaluates to True in boolean context, otherwise returns the last argument.</p><p>Note that this short-circuits; i.e., if one of the arguments evaluates to a true value, the remaining arguments are not evaluated.</p><p><pre><code>sub a { 0 }\nsub b { 1 }\nsub c { die \"never called\" };\nsay a() || b() || c();      # OUTPUT: «1␤»</code></pre></p>","&infix:<or>":"<p>Same as infix ||, except with looser precedence.</p><p>Returns the first argument that evaluates to True in boolean context, or otherwise the last argument, it short-circuits. Please note that or is easy to misuse. See traps.</p><p></p>","&prefix:<not>":"<p><pre><code>multi sub prefix:<not>(Mu $x --> Bool:D)</code></pre></p><p>Evaluates its argument in boolean context (and thus collapses Junctions), and negates the result. Please note that not is easy to misuse. See traps.</p>","&infix:<=>>":"<p><pre><code>sub infix:«=>»($key, Mu $value --> Pair:D)</code></pre></p><p>Pair constructor.</p><p>Constructs a Pair object with the left-hand side as the key and the right-hand side as the value.</p><p>Note that the =>  operator is syntactically special-cased, in that it allows unquoted identifier on the left-hand side.</p><p><pre><code>my $p = a => 1;\nsay $p.key;         # OUTPUT: «a␤»\nsay $p.value;       # OUTPUT: «1␤»</code></pre></p><p>A Pair within an argument list with an unquoted identifier on the left is interpreted as a named argument.</p><p>See the Terms language documentation for more ways to create Pair objects.</p>","&infix:<eqv>":"<p><pre><code>sub infix:<eqv>(Any, Any)</code></pre></p><p>Equivalence operator. Returns True if the two arguments are structurally the same, i.e. from the same type and (recursively) contain equivalent values.</p><p><pre><code>say [1, 2, 3] eqv [1, 2, 3];    # OUTPUT: «True␤»\nsay Any eqv Any;                # OUTPUT: «True␤»\nsay 1 eqv 2;                    # OUTPUT: «False␤»\nsay 1 eqv 1.0;                  # OUTPUT: «False␤»</code></pre></p><p>Lazy Iterables cannot be compared, as they're assumed to be infinite. However, the operator will do its best and return False if the two lazy Iterables are of different types or if only one Iterable is lazy.</p><p><pre><code>say (1…∞) eqv (1…∞).List; # Both lazy, but different types;   OUTPUT: «False␤»\nsay (1…∞) eqv (1…3);      # Same types, but only one is lazy; OUTPUT: «False␤»\n(try say (1…∞) eqv (1…∞)) # Both lazy and of the same type. Cannot compare; throws.\n    orelse say $!.^name;  # OUTPUT: «X::Cannot::Lazy␤»</code></pre></p><p>The default eqv operator even works with arbitrary objects. E.g., eqv will consider two instances of the same object as being structurally equivalent:</p><p><pre><code>my class A {\n    has $.a;\n}\nsay A.new(a => 5) eqv A.new(a => 5);  # OUTPUT: «True␤»</code></pre></p><p>Although the above example works as intended, the eqv code might fall back to a slower code path in order to do its job. One way to avoid this is to implement an appropriate infix eqv operator:</p><p><pre><code>my class A {\n    has $.a;\n}\nmulti infix:<eqv>(A $l, A $r) { $l.a eqv $r.a }\nsay A.new(a => 5) eqv A.new(a => 5);            # OUTPUT: «True␤»</code></pre></p><p>Note that eqv does not work recursively on every kind of container type, e.g. Set:</p><p><pre><code>my class A {\n    has $.a;\n}\nsay Set(A.new(a => 5)) eqv Set(A.new(a => 5));  # OUTPUT: «False␤»</code></pre></p><p>Even though the contents of the two sets are eqv, the sets are not. The reason is that eqv delegates the equality check to the Set object which relies on element-wise === comparison. Turning the class A into a value type by giving it a WHICH method produces the expected behavior:</p><p><pre><code>my class A {\n    has $.a;\n    method WHICH {\n        ValueObjAt.new: \"A|$!a.WHICH()\"\n    }\n}\nsay Set(A.new(a => 5)) eqv Set(A.new(a => 5));  # OUTPUT: «True␤»</code></pre></p>","&infix:<gcd>":"<p><pre><code>multi sub infix:<gcd>($a, $b --> Int:D)</code></pre></p><p>Coerces both arguments to Int and returns the greatest common divisor. If one of its arguments is 0, the other is returned (when both arguments are 0, the operator returns 0).</p>","&infix:<≥>":"<p>Numeric greater than or equal to operator.</p><p>Equivalent to >=, at codepoint U+2265 (GREATER-THAN OR EQUAL TO).</p>","&infix:<::=>":"<p>Read-only binding operator, not yet implemented in Rakudo. See infix :=.</p><p></p>","&postcircumfix:<[>":"<p><pre><code>sub postcircumfix:<[ ]>(@container, **@index,\n                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</code></pre></p><p>Universal interface for positional access to zero or more elements of a @container, a.k.a. \"array indexing operator\".</p><p><pre><code>my @alphabet = 'a' .. 'z';\nsay @alphabet[0];                   # OUTPUT: «a␤»\nsay @alphabet[1];                   # OUTPUT: «b␤»\nsay @alphabet[*-1];                 # OUTPUT: «z␤»\nsay @alphabet[100]:exists;          # OUTPUT: «False␤»\nsay @alphabet[15, 4, 17, 11].join;  # OUTPUT: «perl␤»\nsay @alphabet[23 .. *].perl;        # OUTPUT: «(\"x\", \"y\", \"z\")␤»\n\n@alphabet[1, 2] = \"B\", \"C\";\nsay @alphabet[0..3].perl            # OUTPUT: «(\"a\", \"B\", \"C\", \"d\")␤»</code></pre></p><p>See Subscripts, for a more detailed explanation of this operator's behavior and for how to implement support for it in custom types.</p>","&postcircumfix:<«>":"<p>Shortcut for postcircumfix { } that quotes its argument using the same rules as the interpolating quote-words operator of the same name.</p><p><pre><code>my %color = kiwi => \"green\", banana => \"yellow\", cherry => \"red\";\nmy $fruit = \"kiwi\";\nsay %color«cherry \"$fruit\"».perl;   # OUTPUT: «(\"red\", \"green\")␤»</code></pre></p><p>Technically, not a real operator; it's syntactic sugar that's turned into the { } postcircumfix operator at compile-time.</p>","&infix:<but>":"<p><pre><code>multi sub infix:<but>(Mu $obj1, Mu   $role) is assoc<non>\nmulti sub infix:<but>(Mu $obj1, Mu:D $obj2) is assoc<non></code></pre></p><p>Creates a copy of $obj with $role mixed in. Since $obj is not modified, but can be used to created immutable values with mixins.</p><p>Instead of a role, you can provide an instantiated object. In this case, the operator will create a role for you automatically. The role will contain a single method named the same as $obj.^name and that returns $obj:</p><p><pre><code>my $forty-two = 42 but 'forty two';\nsay $forty-two+33;    # OUTPUT: «75␤»\nsay $forty-two.^name; # OUTPUT: «Int+{<anon|1>}␤»\nsay $forty-two.Str;   # OUTPUT: «forty two␤»\n</code></pre></p><p>Calling ^name shows that the variable is an Int with an anonymous object mixed in. However, that object is of type Str, so the variable, through the mixin, is endowed with a method with that name, which is what we use in the last sentence.</p><p>We can also mixin classes, even created on the fly.</p><p><pre><code>my $s = 12 but class Warbles { method hi { 'hello' } }.new;\nsay $s.Warbles.hi;    # OUTPUT: «hello␤»\nsay $s + 42;          # OUTPUT: «54␤»\n</code></pre></p><p>To access the mixed-in class, as above, we use the class name as is shown in the second sentence. If methods of the same name are present already, the last mixed in role takes precedence. A list of methods can be provided in parentheses separated by comma. In this case conflicts will be reported at runtime.</p>","&infix:<->":"<p><pre><code>multi sub infix:<->($a, $b --> Numeric:D)</code></pre></p><p>Subtraction operator.</p><p>Coerces both arguments to Numeric and subtracts the second from the first.</p>","&infix:<(>=)>":"<p><pre><code>multi sub infix:<< (>=) >>($a,$b --> Bool:D)\nmulti sub infix:<⊇>($a,$b --> Bool:D)</code></pre></p><p>Superset of or equal to operator.</p><p>Returns True if $a is a superset of $b, i.e., that all the elements of $b are elements of $a but $a is a larger or equal sized set than $b.</p><p><pre><code>say (1,2,3) (>=) (2,3,1); # OUTPUT: «True␤»\nsay (1,2,3) (>=) (2,3); # OUTPUT: «True␤»\nsay 4 ⊇ (1,2,3); # OUTPUT: «False␤»\n</code></pre></p><p>⊇ is equivalent to (>=), at codepoint U+2287 (SUPERSET OF OR EQUAL TO).</p>","&infix:<(elem)>":"<p><pre><code>multi sub infix:<(elem)>($a,$b --> Bool:D)\nmulti sub infix:<∈>($a,$b --> Bool:D)</code></pre></p><p>Membership operator.</p><p>Returns True if $a is an element of $b.</p><p><pre><code>say 2 (elem) (1, 2, 3); # OUTPUT: «True␤»\nsay 4 ∈ (1, 2, 3); # OUTPUT: «False␤»\n</code></pre></p><p>∈ is equivalent to (elem), at codepoint U+2208 (ELEMENT OF).</p>","&infix:<+>>":"<p><pre><code>multi sub infix:<< +> >>($a, $b --> Int:D)</code></pre></p><p>Integer bit shift to the right.</p>","&prefix:<|>":"<p>Flattens objects of type Capture, Pair, List, Map and Hash into an argument list.</p><p><pre><code>sub slurpee( |args ){\n    say args.perl\n};\nslurpee( <a b c d>, { e => 3 }, 'e' => 'f' => 33 )\n# OUTPUT: «\\((\"a\", \"b\", \"c\", \"d\"), {:e(3)}, :e(:f(33)))␤»</code></pre></p><p>Please see the Signature page, specially the section on Captures for more information on the subject.</p><p>Outside of argument lists, it returns a Slip, which makes it flatten into the outer list. Inside argument list Positionals are turned into positional arguments and Associatives are turned into named arguments.</p>","&prefix:<^>":"<p><pre><code>multi sub prefix:<^>(Any --> Range:D)</code></pre></p><p>upto operator.</p><p>Coerces the argument to Numeric, and generates a range from 0 up to (but excluding) the argument.</p><p><pre><code>say ^5;         # OUTPUT: «0..^5␤»\nfor ^5 { }      # 5 iterations</code></pre></p>","&postfix:<,=>":"<p>Creates an object that concatenates, in a class-dependent way, the contents of the variable on the left hand side and the expression on the right hand side:</p><p><pre><code>my %a = :11a, :22b;\n%a ,= :33x;\nsay %a # OUTPUT: «{a => 11, b => 22, x => 33}␤»</code></pre></p>","&postcircumfix:<<>>":"<p>Decontainerization operator, which extracts the value from a container and makes it independent of the container type.</p><p><pre><code>use JSON::Tiny;\n\nmy $config = from-json('{ \"files\": 3, \"path\": \"/home/perl6/perl6.pod6\" }');\nsay $config.perl;      # OUTPUT: «${:files(3), :path(\"/home/perl6/perl6.pod6\")}»\nmy %config-hash = $config<>;\nsay %config-hash.perl; # OUTPUT: «{:files(3), :path(\"/home/perl6/perl6.pod6\")}»\n</code></pre></p><p>It's a Hash in both cases, and it can be used like that; however, in the first case it was in item context, and in the second case it has been extracted to its proper context.</p>","&infix:<(cont)>":"<p><pre><code>multi sub infix:<(cont)>($a,$b --> Bool:D)\nmulti sub infix:<∋>($a,$b --> Bool:D)</code></pre></p><p>Membership operator.</p><p>Returns True if $a is an element of $b.</p><p><pre><code>say (1,2,3) (cont) 2; # OUTPUT: «True␤»\nsay (1, 2, 3) ∋ 4; # OUTPUT: «False␤»\n</code></pre></p><p>∋ is equivalent to (cont), at codepoint U+220B (CONTAINS AS MEMBER).</p>","&infix:<gt>":"<p><pre><code>multi sub infix:<gt>(Mu,    Mu)\nmulti sub infix:<gt>(Str:D, Str:D)</code></pre></p><p>String greater than operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is larger than the second, as determined by lexicographic comparison.</p><p>Mnemonic: greater than</p>","&infix:<lt>":"<p><pre><code>multi sub infix:<lt>(Mu,    Mu)\nmulti sub infix:<lt>(Str:D, Str:D)</code></pre></p><p>String less than operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is smaller than the second, as determined by lexicographic comparison.</p><p>Mnemonic: less than</p>","&infix:<~<>":"<p>Coerces the left argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise left shift on the bits of the buffer.</p><p>Please note that this has not yet been implemented.</p>","&infix:<<=>>":"<p><pre><code>multi sub infix:«<=>»($a, $b --> Order:D) is assoc<non></code></pre></p><p>Numeric three-way comparator.</p><p>Coerces both arguments to Real and then does a numeric comparison.</p>","&prefix:<+^>":"<p><pre><code>multi sub prefix:<+^>(Any --> Int:D)</code></pre></p><p>Integer bitwise negation operator: Coerces the argument to Int and does a bitwise negation on the result, assuming two's complement.</p>","&infix:<xor>":"<p>Same as infix ^^, except with looser precedence.</p><p>Returns the operand that evaluates to True in boolean context, if and only if the other operand evaluates to False in boolean context. If both operands evaluate to False, returns the last argument. If both operands evaluate to True, returns Nil.</p><p>When chaining, returns the operand that evaluates to True, if and only if there is one such operand. If more than one operand is true, it short-circuits after evaluating the second and returns Nil. If all operands are false, returns the last one.</p>","&infix:<fff>":"<p><pre><code>sub infix:<fff>(Mu $a, Mu $b)</code></pre></p><p>Performs a sed-like flipflop operation, wherein it returns False until the left argument smartmatches against $_, then returns True until the right argument smartmatches against $_.</p><p>Works similarly to ff, except that it only tries one argument per invocation. That is, if $_ smartmatches the left argument, fff will not then try to match that same $_ against the right argument.</p><p><pre><code>for <AB C D B E F> {\n    say $_ if /A/ fff /B/;         # OUTPUT: «AB␤C␤D␤B␤»\n}</code></pre></p><p>The non-sed-like flipflop (which after successfully matching the left argument against $_ will try that same $_ against the right argument and act accordingly). See ff.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<before>":"<p><pre><code>multi sub infix:<before>(Any,       Any)\nmulti sub infix:<before>(Real:D,    Real:D)\nmulti sub infix:<before>(Str:D,     Str:D)\nmulti sub infix:<before>(Version:D, Version:D)</code></pre></p><p>Generic ordering, uses the same semantics as cmp. Returns True if the first argument is smaller than the second.</p>","&infix:<le>":"<p><pre><code>multi sub infix:<le>(Mu,    Mu)\nmulti sub infix:<le>(Str:D, Str:D)</code></pre></p><p>String less than or equal to operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is equal to or smaller than the second, as determined by lexicographic comparison.</p><p>Mnemonic: less or equal</p>","&infix:<&>":"<p><pre><code>multi sub infix:<&>($a, $b --> Junction:D) is assoc<list></code></pre></p><p>All junction operator.</p><p>Creates an all Junction from its arguments. See Junction for more details.</p>","&infix:<:>":"<p>Used as an argument separator just like infix , and marks the argument to its left as the invocant. That turns what would otherwise be a function call into a method call.</p><p><pre><code>substr('abc': 1);       # same as 'abc'.substr(1)</code></pre></p><p>Infix : is only allowed after the first argument of a non-method call. In other positions, it's a syntax error.</p>","&infix:<^>":"<p><pre><code>multi sub infix:<^>($a, $b --> Junction:D) is assoc<list></code></pre></p><p>One junction operator.</p><p>Creates a one Junction from its arguments. See Junction for more details.</p>","&infix:<%%>":"<p><pre><code>multi sub infix:<%%>($a, $b --> Bool:D)</code></pre></p><p>Divisibility operator. Returns True if $a % $b == 0.</p>","&infix:<and>":"<p>Same as infix &&, except with looser precedence.</p><p>Short-circuits so that it returns the first operand that evaluates to False, otherwise returns the last operand. Note that and is easy to misuse, see traps.</p>","&prefix:<?>":"<p><pre><code>multi sub prefix:<?>(Mu --> Bool:D)</code></pre></p><p>Boolean context operator.</p><p>Coerces the argument to Bool by calling the Bool method on it. Note that this collapses Junctions.</p>","&prefix:<++>":"<p><pre><code>multi sub prefix:<++>($x is rw) is assoc<non></code></pre></p><p>This is the . Increments its argument by one and returns the updated value.</p><p><pre><code>my $x = 3;\nsay ++$x;   # OUTPUT: «4␤»\nsay $x;     # OUTPUT: «4␤»</code></pre></p><p>It works by calling the succ method (for successor) on its argument, which gives custom types the freedom to implement their own increment semantics.</p><p></p>","&postfix:<-->":"<p><pre><code>multi sub postfix:<-->($x is rw) is assoc<non></code></pre></p><p>Decrements its argument by one and returns the original value.</p><p><pre><code>my $x = 3;\nsay $x--;   # OUTPUT: «3␤»\nsay $x;     # OUTPUT: «2␤»</code></pre></p><p>It works by calling the pred method (for predecessor) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p><p>Note that this does not necessarily return its argument;e.g., for undefined values, it returns 0:</p><p><pre><code>my $x;\nsay $x--;   # OUTPUT: «0␤»\nsay $x;     # OUTPUT: «-1␤»</code></pre></p><p>Decrement on Str will decrement the number part of a string and assign the resulting string to the container. A is rw-container is required. Crossing 0 is prohibited and throws X::AdHoc.</p><p><pre><code>my $filename = \"somefile-003.txt\";\nsay $filename-- for 1..3;\n# OUTPUT: «somefile-003.txt␤somefile-002.txt␤somefile-001.txt␤»</code></pre></p>","&infix:<⊄>":"<p><pre><code>multi sub infix:<⊄>($a,$b --> Bool:D)</code></pre></p><p>Not a subset of operator.</p><p>Returns True if $a is not a strict subset of $b. Equivalent to !(<).</p><p><pre><code>say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»\nsay (2,3) ⊄ (2,3,1); # OUTPUT: «False␤»\nsay 4 !(<) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊄ is codepoint U+2284 (NOT A SUBSET OF).</p>","&infix:<⊅>":"<p><pre><code>multi sub infix:<⊅>($a,$b --> Bool:D)</code></pre></p><p>Not a superset of operator.</p><p>Returns True if $a is not a strict superset of $b. Equivalent to !(>).</p><p><pre><code>say (1,2,3) ⊅ (2,3,1); # OUTPUT: «True␤»\nsay (1,2,3) ⊅ (2,3); # OUTPUT: «False␤»\nsay 4 !(>) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊅ is codepoint U+2285 (NOT A SUPERSET OF).</p>","&prefix:<+>":"<p><pre><code>multi sub prefix:<+>(Any --> Numeric:D)</code></pre></p><p>Numeric context operator.</p><p>Coerces the argument to Numeric by calling the Numeric method on it.</p>","&infix:<^fff>":"<p><pre><code>sub infix:<^fff>(Mu $a, Mu $b)</code></pre></p><p>Like fff, except it does not return true for matches to the left argument.</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ ^fff /C/ for @list;  # OUTPUT: «B␤C␤»</code></pre></p><p>For the non-sed version, see ^ff.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<^ff^>":"<p><pre><code>sub infix:<^ff^>(Mu $a, Mu $b)</code></pre></p><p>Works like ff, except it does not return True for items matching either the stop or start condition (or both).</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ ^ff^ /C/ for @list;  # OUTPUT: «B␤»</code></pre></p><p>The sed-like version can be found in ^fff^.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<∉>":"<p><pre><code>multi sub infix:<∉>($a,$b --> Bool:D)</code></pre></p><p>Non-membership operator.</p><p>Returns True if $a is not an element of $b. Equivalent to !(elem).</p><p><pre><code>say 4 ∉ (1, 2, 3); # OUTPUT: «True␤»\nsay 2 !(elem) (1, 2, 3); # OUTPUT: «False␤»\n</code></pre></p><p>∉ is codepoint U+2209 (NOT AN ELEMENT OF).</p>","&infix:<//>":"<p>The defined-or operator or infix // returns the first defined operand, or else the last operand. Short-circuits.</p><p><pre><code>say Any // 0 // 42;         # OUTPUT: «0␤»</code></pre></p>","&infix:<div>":"<p><pre><code>multi sub infix:<div>(Int:D, Int:D --> Int:D)</code></pre></p><p>Integer division operator. Rounds down.</p>","&infix:<(<)>":"<p><pre><code>multi sub infix:<< (<) >>($a,$b --> Bool:D)\nmulti sub infix:<⊂>($a,$b --> Bool:D)</code></pre></p><p>Subset of operator.</p><p>Returns True if $a is a strict subset of $b, i.e., that all the elements of $a are elements of $b but $a is a smaller set than $b.</p><p><pre><code>say (1,2,3) (<) (2,3,1); # OUTPUT: «False␤»\nsay (2,3) (<) (2,3,1); # OUTPUT: «True␤»\nsay 4 ⊂ (1,2,3); # OUTPUT: «False␤»\n</code></pre></p><p>⊂ is equivalent to (<), at codepoint U+2282 (SUBSET OF).</p>","&infix:<~&>":"<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise AND on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>","&infix:<≤>":"<p>Numeric less than or equal to operator.</p><p>Equivalent to <=, at codepoint U+2264 (LESS-THAN OR EQUAL TO).</p>","&prefix:<!>":"<p><pre><code>multi sub prefix:<!>(Mu --> Bool:D)</code></pre></p><p>Negated boolean context operator.</p><p>Coerces the argument to Bool by calling the Bool method on it, and returns the negation of the result. Note that this collapses Junctions.</p>","&infix:<xx>":"<p>Defined as:</p><p><pre><code>multi sub infix:<xx>()\nmulti sub infix:<xx>(Mu \\x)\nmulti sub infix:<xx>(&x, Num:D() $n)\nmulti sub infix:<xx>(&x, Whatever)\nmulti sub infix:<xx>(&x, Bool:D $b)\nmulti sub infix:<xx>(&x, Int:D $n)\nmulti sub infix:<xx>(Mu \\x, Num:D() $n)\nmulti sub infix:<xx>(Mu \\x, Whatever)\nmulti sub infix:<xx>(Mu \\x, Bool:D $b)\nmulti sub infix:<xx>(Mu \\x, Int:D $n)</code></pre></p><p>In general, it returns a Sequence of $a repeated and evaluated $b times ($b is coerced to Int). If $b <= 0 , the empty list is returned. It will return an error with no operand, and return the operand itself with a single operand. An exception X::Numeric::CannotConvert will be thrown if $b is -Inf or NaN.</p><p>The left-hand side is evaluated for each repetition, so</p><p><pre><code>say [1, 2] xx 5;\n# OUTPUT: «([1 2] [1 2] [1 2] [1 2] [1 2])␤»</code></pre></p><p>returns five distinct arrays (but with the same content each time), and</p><p><pre><code>rand xx 3</code></pre></p><p>returns three pseudo random numbers that are determined independently.</p><p>The right-hand side can be *, in which case a lazy, infinite list is returned. If it's a Bool, a Seq with a single element is returned if it's True.</p>","&infix:<(<=)>":"<p><pre><code>multi sub infix:<< (<=) >>($a,$b --> Bool:D)\nmulti sub infix:<⊆>($a,$b --> Bool:D)</code></pre></p><p>Subset of or equal to operator.</p><p>Returns True if $a is a subset of $b, i.e., that all the elements of $a are elements of $b but $a is a smaller or equal sized set than $b.</p><p><pre><code>say (1,2,3) (<=) (2,3,1); # OUTPUT: «True␤»\nsay (2,3) (<=) (2,3,1); # OUTPUT: «True␤»\nsay 4 ⊆ (1,2,3); # OUTPUT: «False␤»\n</code></pre></p><p>⊆ is equivalent to (<=), at codepoint U+2286 (SUBSET OF OR EQUAL TO).</p>","&infix:<%>":"<p><pre><code>multi sub infix:<%>($x, $y --> Numeric:D)</code></pre></p><p>Modulo operator. Coerces to Numeric first.</p><p>Generally the following identity holds:</p><p><pre><code>my ($x, $y) = 1,2;\n$x % $y == $x - floor($x / $y) * $y</code></pre></p>","&infix:<(&)>":"<p><pre><code>multi sub infix:<(&)>(**@p)\nmulti sub infix:<∩>(**@p)</code></pre></p><p>Intersection operator.</p><p>Returns the intersection of all of its arguments. This creates a new Set that contains only the elements common to all of the arguments if none of the arguments are a Bag, BagHash, Mix or MixHash.</p><p><pre><code>say <a b c> (&) <b c d>; # OUTPUT: «set(b c)␤»\n<a b c d> ∩ <b c d e> ∩ <c d e f>; # OUTPUT: «set(c d)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy>, the result is a new Bag (or Mix) containing the common elements, each weighted by the largest common weight (which is the minimum of the weights of that element over all arguments).</p><p><pre><code>say <a a b c a> (&) bag(<a a b c c>); # OUTPUT: «Bag(a(2), b, c)␤»\n</code></pre></p><p>∩ is equivalent to (&), at codepoint U+2229 (INTERSECTION).</p>","&infix:<>>":"<p><pre><code>multi sub infix:«>»(Int:D, Int:D)\nmulti sub infix:«>»(Num:D, Num:D)\nmulti sub infix:«>»(Real:D, Real:D)</code></pre></p><p>Numeric greater than operator.</p><p>Coerces both arguments to Real (if necessary); returns True if the first argument is larger than the second.</p>","&infix:<??>":"<p>Also called ternary or conditional operator, $condition ?? $true !! $false evaluates $condition and returns the expression right behind ??, in this case $true if it is True, otherwise evaluates and returns the expression behind !!, $false in this case.</p><p></p>","&infix:<...>":"<p><pre><code>multi sub infix:<...>(**@) is assoc<list>\nmulti sub infix:<...^>(**@) is assoc<list></code></pre></p><p>The sequence operator, which can be written either as ... or as … (with variants ...^ and …^) will produce (possibly lazy) generic sequences on demand.</p><p>The left-hand side will always include the initial elements; it may include a generator too (after the first element or elements). The right-hand side will have an endpoint, which can be Inf or * for \"infinite\" lists (that is, lazy lists whose elements are only produced on demand), an expression which will end the sequence when True, or other elements such as Junctions.</p><p>The sequence operator invokes the generator with as many arguments as necessary. The arguments are taken from the initial elements and the already generated elements. The default generator is *.succ or *.pred, depending on how the end points compare:</p><p><pre><code>say 1 ... 4;        # OUTPUT: «(1 2 3 4)␤»\nsay 4 ... 1;        # OUTPUT: «(4 3 2 1)␤»\nsay 'a' ... 'e';    # OUTPUT: «(a b c d e)␤»\nsay 'e' ... 'a';    # OUTPUT: «(e d c b a)␤»</code></pre></p><p>An endpoint of * (Whatever), Inf or ∞ generates on demand an infinite sequence, with a default generator of *.succ</p><p><pre><code>say (1 ... *)[^5];  # OUTPUT: «(1 2 3 4 5)␤»</code></pre></p><p>Custom generators need to be the last element of the list before the '...' operator. This one takes two arguments, and generates the eight first Fibonacci numbers</p><p><pre><code>say (1, 1, -> $a, $b { $a + $b } ... *)[^8]; # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\n# same but shorter\nsay (1, 1, * + * ... *)[^8];                 # OUTPUT: «(1 1 2 3 5 8 13 21)␤»\n</code></pre></p><p>Of course the generator can also take only one argument.</p><p><pre><code>say 5, { $_ * 2 } ... 40;                # OUTPUT: «5 10 20 40␤»</code></pre></p><p>There must be at least as many initial elements as arguments to the generator.</p><p>Without a generator and with more than one initial element and all initial elements numeric, the sequence operator tries to deduce the generator. It knows about arithmetic and geometric sequences.</p><p><pre><code>say 2, 4, 6 ... 12;     # OUTPUT: «(2 4 6 8 10 12)␤»\nsay 1, 2, 4 ... 32;     # OUTPUT: «(1 2 4 8 16 32)␤»</code></pre></p><p>If the endpoint is not *, it's smartmatched against each generated element and the sequence is terminated when the smartmatch succeeded. For the ... operator, the final element is included, for the ...^ operator it's excluded.</p><p>This allows you to write</p><p><pre><code>say 1, 1, * + * ...^ *>= 100;</code></pre></p><p>to generate all Fibonacci numbers up to but excluding 100.</p><p>The ... operators consider the initial values as \"generated elements\" as well, so they are also checked against the endpoint:</p><p><pre><code>my $end = 4;\nsay 1, 2, 4, 8, 16 ... $end;\n# OUTPUT: «(1 2 4)␤»</code></pre></p>","&infix:<=>":"<p>In this context, it acts as the list assignment operator. Its exact semantics are left to the container type on the left-hand side. See Array and Hash for common cases.</p><p>The distinction between item assignment and list assignment is determined by the parser depending on the syntax of the left-hand side.</p>","&infix:<+&>":"<p><pre><code>multi sub infix:<+&>($a, $b --> Int:D)</code></pre></p><p>Numeric bitwise AND operator. Coerces both arguments to Int and does a bitwise AND operation assuming two's complement.</p>","&infix:<leg>":"<p><pre><code>multi sub infix:<leg>(Any,   Any)\nmulti sub infix:<leg>(Str:D, Str:D)</code></pre></p><p>String three-way comparator. Short for less, equal or greater?.</p><p>Coerces both arguments to Str and then does a lexicographic comparison.</p><p><pre><code>say 'a' leg 'b';       # OUTPUT: «Less␤»\nsay 'a' leg 'a';       # OUTPUT: «Same␤»\nsay 'b' leg 'a';       # OUTPUT: «More␤»</code></pre></p>","&infix:<>=>":"<p><pre><code>multi sub infix:«>=»(Int:D, Int:D)\nmulti sub infix:«>=»(Num:D, Num:D)\nmulti sub infix:«>=»(Real:D, Real:D)</code></pre></p><p>Numeric greater than or equal to operator.</p><p>Coerces both arguments to Real (if necessary); returns True if the first argument is larger than or equal to the second.</p>","&infix:<coll>":"<p>Defined as:</p><p><pre><code>multi sub infix:<coll>(Str:D \\a, Str:D \\b --> Order:D)\nmulti sub infix:<coll>(Cool:D \\a, Cool:D \\b --> Order:D)\nmulti sub infix:<coll>(Pair:D \\a, Pair:D \\b --> Order:D)</code></pre></p><p>coll is a sorting operator that takes pairs of Strs, Cools or Pairs and returns an Order that uses the $*COLLATION order. The default behavior disregards diacritic marks and capitalization, for instance.</p><p><pre><code>say \"b\" cmp \"à\";  # OUTPUT: «Less␤»\nsay \"b\" coll \"à\"; # OUTPUT: «More␤»</code></pre></p><p>In the first case, lexicographic or codepoint order is taken into account. In the second, which uses coll, the diacritic is not considered and sorting happens according to intuitive order.</p><p>NOTE: These are not yet implemented in the JVM.</p>","&infix:<min>":"<p>Returns the smallest of the arguments, as determined by cmp semantics.</p><p><pre><code>my $foo = 42;\n$foo min= 0   # read as: $foo decreases to 0</code></pre></p>","&infix:<fff^>":"<p><pre><code>sub infix:<fff^>(Mu $a, Mu $b)</code></pre></p><p>Like fff, except it does not return true for matches to the right argument.</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ fff^ /C/ for @list;  # OUTPUT: «A␤B␤»</code></pre></p><p>For the non-sed version, see ff^.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<+^>":"<p><pre><code>multi sub infix:<+^>($a, $b --> Int:D)</code></pre></p><p>Integer bitwise XOR operator: Coerces both arguments to Int and does a bitwise XOR (exclusive OR) operation.</p>","&infix:</>":"<p><pre><code>multi sub infix:</>(Any, Any --> Numeric:D)</code></pre></p><p>Division operator.</p><p>Coerces both argument to Numeric and divides the left through the right number. Division of Int values returns Rat, otherwise the \"wider type\" rule described in Numeric holds.</p>","&circumfix:<[>":"<p>The Array constructor returns an itemized Array that does not flatten in list context. Check this:</p><p><pre><code>say .perl for [3,2,[1,0]]; # OUTPUT: «3␤2␤$[1, 0]␤»</code></pre></p><p>This array is itemized, in the sense that every element constitutes an item, as shown by the $ preceding the last element of the array, the (list) item contextualizer.</p>","&infix:<.>":"<p>Calls the following method (whose name must be alphabetic) on the left-side invocant.</p><p>Note that the infix form of the operator has a slightly lower precedence than postfix .meth.</p><p><pre><code>say -5.abs;      # like: -(5.abs)\n# OUTPUT: «-5␤»\nsay -5 . abs;    # like: (-5) . abs\n# OUTPUT: «5␤»\nsay -5 .abs;     # following whitespace is optional\n# OUTPUT: «5␤»</code></pre></p>","&infix:<!=>":"<p><pre><code>sub infix:<!=>(Mu, Mu --> Bool:D)</code></pre></p><p>Numeric inequality operator.</p><p>Coerces both arguments to Numeric (if necessary); returns True if they are distinct.</p><p>Is an alias to !==.</p>","&infix:<:=>":"<p>Binding operator. Whereas $x = $y puts the value in $y into $x, $x := $y makes $x and $y the same thing.</p><p><pre><code>my $a = 42;\nmy $b = $a;\n$b++;\nsay $a;</code></pre></p><p>This will output 42, because $a and $b both contained the number 42, but the containers were different.</p><p><pre><code>my $a = 42;\nmy $b := $a;\n$b++;\nsay $a;</code></pre></p><p>This will output 43, since $b and $a both represented the same object.</p><p>If type constrains on variables or containers are present a type check will be performed at runtime. On failure X::TypeCheck::BindingType will be thrown.</p><p>Please note that := is a compile time operator. As such it can not be referred to at runtime and thus can't be used as an argument to metaoperators.</p>","&infix:<+<>":"<p><pre><code>multi sub infix:<< +< >>($a, $b --> Int:D)</code></pre></p><p>Integer bit shift to the left.</p>","&infix:<^..>":"<p><pre><code>multi sub infix:<^..>($a, $b --> Range:D) is assoc<non></code></pre></p><p>Left-open range operator.</p><p>Constructs a Range from the arguments, excluding the start point.</p>","&infix:<≠>":"<p>Numeric inequality operator.</p><p>Equivalent to !=, at codepoint U+2260 (NOT EQUAL TO).</p>","&postcircumfix:<<>":"<p>Shortcut for postcircumfix { } that quotes its argument using the same rules as the quote-words operator of the same name.</p><p><pre><code>my %color = kiwi => \"green\", banana => \"yellow\", cherry => \"red\";\nsay %color<banana>;               # OUTPUT: «yellow␤»\nsay %color<cherry kiwi>.perl;     # OUTPUT: «(\"red\", \"green\")␤»\nsay %color<strawberry>:exists;    # OUTPUT: «False␤»</code></pre></p><p>Technically, not a real operator; it's syntactic sugar that's turned into the { } postcircumfix operator at compile-time.</p>","&infix:<cmp>":"<p><pre><code>multi sub infix:<cmp>(Any,       Any)\nmulti sub infix:<cmp>(Real:D,    Real:D)\nmulti sub infix:<cmp>(Str:D,     Str:D)\nmulti sub infix:<cmp>(Version:D, Version:D)</code></pre></p><p>Generic, \"smart\" three-way comparator.</p><p>Compares strings with string semantics, numbers with number semantics, Pair objects first by key and then by value etc.</p><p>if $a eqv $b, then $a cmp $b always returns Order::Same.</p><p><pre><code>say (a => 3) cmp (a => 4);   # OUTPUT: «Less␤»\nsay 4        cmp 4.0;        # OUTPUT: «Same␤»\nsay 'b'      cmp 'a';        # OUTPUT: «More␤»</code></pre></p><p>Strings are compared codepoint by codepoint; if leading codepoints are the same, the result of comparing the first differing codepoint is returned or the longer string if their lengths differ.</p><p><pre><code>\"abcd\" cmp \"abcde\"    # OUTPUT: «Less␤»\n\"abcd \" cmp \"abcde\"   # OUTPUT: «Less␤»\n'A' cmp 'Ẳ'           # OUTPUT: «Less␤»</code></pre></p>","&infix:<⊈>":"<p><pre><code>multi sub infix:<⊈>($a,$b --> Bool:D)</code></pre></p><p>Not a subset of nor equal to operator.</p><p>Returns True if $a is not a subset of $b. Equivalent to !(<=).</p><p><pre><code>say (1,2,3) ⊄ (2,3,1); # OUTPUT: «True␤»\nsay (2,3) ⊄ (2,3,1); # OUTPUT: «False␤»\nsay 4 !(<=) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊈ is codepoint U+2288 (NEITHER A SUBSET OF NOR EQUAL TO).</p>","&infix:<<==>":"<p>This leftward feed operator takes the result from the right and passes it to the previous (left) routine as the last parameter. This elucidates the right-to-left dataflow for a series of list manipulating functions.</p><p><pre><code># Traditional structure, read bottom-to-top\nmy @result =\n    sort                   # (4) Sort, result is <Earth People>\n    grep { /<[PE]>/ },     # (3) Look for P or E\n    map { .tc },           # (2) Capitalize the words\n    <people of earth>;     # (1) Start with the input\n\n# Feed (right-to-left) with parentheses, read bottom-to-top\nmy @result = (\n    sort()                 # (4) Sort, result is <Earth People>\n    <== grep({ /<[PE]>/ }) # (3) Look for P or E\n    <== map({ .tc })       # (2) Capitalize the words\n    <== <people of earth>  # (1) Start with the input\n);\n\n# To assign without parentheses, use another feed operator\nmy @result\n    <== sort()              # (4) Sort, result is <Earth People>\n    <== grep({ /<[PE]>/ })  # (3) Look for P or E\n    <== map({ .tc })        # (2) Capitalize the words\n    <== <people of earth>;  # (1) Start with the input\n\n# It can be useful to capture a partial result\nmy @result\n    <== sort()\n    <== grep({ /<[PE]>/ })\n    <== my @caps            # unlike ==>, there's no need for additional statement\n    <== map({ .tc })\n    <== <people of earth>;</code></pre></p><p>Unlike the rightward feed operator, the result is not closely mappable to method-chaining. However, compared to the traditional structure above where each argument is separated by a line, the resulting code is more demonstrative than commas. The leftward feed operator also allows you to \"break into\" the statement and capture an intermediary result which can be extremely useful for debugging or to take that result and create another variation on the final result.</p><p>Note: In the future, this operator will see some change as it gains the ability to run list operations in parallel. It will enforce that the right operand is enclosable as a closure (that can be cloned and run in a subthread).</p>","&infix:<^ff>":"<p><pre><code>sub infix:<^ff>(Mu $a, Mu $b)</code></pre></p><p>Works like ff, except it does not return True for items matching the start condition (including items also matching the stop condition).</p><p>A comparison:</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ ff /C/ for @list;    # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ ^ff /C/ for @list;   # OUTPUT: «B␤C␤»</code></pre></p><p>The sed-like version can be found in ^fff.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&prefix:<~^>":"<p>Coerces the argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then flips each bit in that buffer.</p><p>Please note that this has not yet been implemented.</p>","&infix:<&&>":"<p>Returns the first argument that evaluates to False in boolean context, otherwise returns the last argument.</p><p>Note that this short-circuits, i.e. if one of the arguments evaluates to a false value, the arguments to the right are never evaluated.</p><p><pre><code>sub a { 1 }\nsub b { 0 }\nsub c { die \"never called\" };\nsay a() && b() && c();      # OUTPUT: «0␤»</code></pre></p>","&infix:<~^>":"<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise XOR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>","&infix:<..^>":"<p><pre><code>multi sub infix:<..^>($a, $b --> Range:D) is assoc<non></code></pre></p><p>Right-open range operator.</p><p>Constructs a Range from the arguments, excluding the end point.</p>","&prefix:<-->":"<p><pre><code>multi sub prefix:<-->($x is rw) is assoc<non></code></pre></p><p>Decrements its argument by one and returns the updated value.</p><p><pre><code>my $x = 3;\nsay --$x;   # OUTPUT: «2␤»\nsay $x;     # OUTPUT: «2␤»</code></pre></p><p>It works by calling the pred method (for predecessor) on its argument, which gives custom types the freedom to implement their own decrement semantics.</p>","&infix:<minmax>":"<p>Returns the Range starting from the lowest to the highest of the values, as determined by the cmp semantics. For instance:</p><p><pre><code># numeric comparison\n10 minmax 3;     # 3..10\n\n# string comparison\n'10' minmax '3'; # \"10\"..\"3\"\n'z' minmax 'k';  # \"k\"..\"z\"\n</code></pre></p><p>If the lowest and highest values coincide, the operator returns a Range made by the same value:</p><p><pre><code>1 minmax 1;  # 1..1\n</code></pre></p><p>When applied to Lists, the operator evaluates the lowest and highest values among all available values:</p><p><pre><code>(10,20,30) minmax (0,11,22,33);       # 0..33\n('a','b','z') minmax ('c','d','w');   # \"a\"..\"z\"\n</code></pre></p><p>Similarly, when applied to Hashes, it performs a cmp way comparison:</p><p><pre><code>my %winner = points => 30, misses => 10;\nmy %loser = points => 20, misses => 10;\n%winner cmp %loser;      # More\n%winner minmax %loser;\n# ${:misses(10), :points(20)}..${:misses(10), :points(30)}\n</code></pre></p>","&infix:<===>":"<p><pre><code>sub infix:<===>(Any, Any)</code></pre></p><p>Value identity operator. Returns True if both arguments are the same object, disregarding any containerization.</p><p><pre><code>my class A { };\nmy $a = A.new;\nsay $a === $a;              # OUTPUT: «True␤»\nsay A.new === A.new;        # OUTPUT: «False␤»\nsay A === A;                # OUTPUT: «True␤»</code></pre></p><p>For value types, === behaves like eqv:</p><p><pre><code>say 'a' === 'a';            # OUTPUT: «True␤»\nsay 'a' === 'b';            # OUTPUT: «False␤»\n\nmy $b = 'a';\nsay $b === 'a';             # OUTPUT: «True␤»\n\n# different types\nsay 1 === 1.0;              # OUTPUT: «False␤»</code></pre></p><p>=== uses the WHICH method to obtain the object identity.</p><p>If you want to create a class that should act as a value type, then that class must create an instance method WHICH, that should return a ValueObjAt object that won't change for the lifetime of the object.</p>","&infix:<⊉>":"<p><pre><code>multi sub infix:<⊉>($a,$b --> Bool:D)</code></pre></p><p>Not a superset of nor equal to operator.</p><p>Returns True if $a is not a superset of $b. Equivalent to !(>=).</p><p><pre><code>say (1,2,3) ⊉ (2,3,1); # OUTPUT: «False␤»\nsay (1,2,3) ⊉ (2,3); # OUTPUT: «False␤»\nsay 4 !(>=) (1,2,3); # OUTPUT: «True␤»\n</code></pre></p><p>⊉ is codepoint U+2289 (NEITHER A SUPERSET OF OR EQUAL TO).</p>","&infix:<~>":"<p><pre><code>multi sub infix:<~>(Any,   Any)\nmulti sub infix:<~>(Str:D, Str:D)\nmulti sub infix:<~>(Buf:D, Buf:D)</code></pre></p><p>This is the string concatenation operator, which coerces both arguments to Str and concatenates them. If both arguments are Buf, a combined buffer is returned.</p><p><pre><code>say 'ab' ~ 'c';     # OUTPUT: «abc␤»</code></pre></p>","&prefix:<?^>":"<p><pre><code>multi sub prefix:<?^>(Mu --> Bool:D)</code></pre></p><p>Boolean bitwise negation operator: Coerces the argument to Bool and then does a bit flip, which makes it the same as prefix:<!> .</p>","&infix:<X>":"<p>Defined as:</p><p><pre><code>multi sub infix:<X>(+lol, :&with! --> Seq:D)\nmulti sub infix:<X>(+lol --> Seq:D)</code></pre></p><p>Creates a cross product from all the lists, ordered so that the rightmost elements vary most rapidly, and returns a Seq:</p><p><pre><code>1..3 X <a b c> X 9\n# produces ((1 a 9) (1 b 9) (1 c 9)\n#           (2 a 9) (2 b 9) (2 c 9)\n#           (3 a 9) (3 b 9) (3 c 9))</code></pre></p><p>The X operator also exists as a metaoperator, in which case the inner lists are replaced by the value from applying the operator to the list:</p><p><pre><code>1..3 X~ <a b c> X~ 9\n# produces (1a9 1b9 1c9 2a9 2b9 2c9 3a9 3b9 3c9)</code></pre></p>","&infix:<=~=>":"<p><pre><code>multi sub infix:<=~=>(Any, Any)\nmulti sub infix:<=~=>(Int:D, Int:D)\nmulti sub infix:<=~=>(Num:D, Num:D)\nmulti sub infix:<=~=>(Rational:D, Rational:D)\nmulti sub infix:<=~=>(Real:D, Real:D)\nmulti sub infix:<=~=>(Complex:D, Complex:D)\nmulti sub infix:<=~=>(Numeric:D, Numeric:D)</code></pre></p><p>The approximately-equal operator ≅, whose ASCII variant is =~=, calculates the relative difference between the left-hand and right-hand sides and returns True if the difference is less than $*TOLERANCE (which defaults to 1e-15). However, if either side is zero then it checks that the absolute difference between the sides is less than $*TOLERANCE. Note that this operator is not arithmetically symmetrical (doesn't do ± Δ):</p><p><pre><code>my $x = 1;\nsay ($x + $*TOLERANCE) =~= $x;   # OUTPUT: «False␤»\nsay ($x - $*TOLERANCE) =~= $x;   # OUTPUT: «True␤»</code></pre></p><p>The tolerance is supposed to be modifiable via an adverb:</p><p><pre><code>my ($x, $y) = 42, 42.1;\nsay $x =~= $y :tolerance(.1);\n</code></pre></p><p>However, this is not yet implemented. The same effect can be achieved by assigning to $*TOLERANCE.</p><p><pre><code>{\n    my $*TOLERANCE = .1;\n    say 11 =~= 10;        # OUTPUT: «True␤»\n}</code></pre></p><p>Note that setting $*TOLERANCE = 0 will cause all comparisons to fail.</p><p><pre><code>{\n    my $*TOLERANCE = 0;\n    say 1 =~= 1;          # OUTPUT: «False␤»\n}</code></pre></p>","&infix:<^^>":"<p>Short-circuit exclusive-or. Returns the true argument if there is one (and only one). Returns the last argument if all arguments are false. Returns Nil when more than one argument is true.</p><p>This operator short-circuits in the sense that it does not evaluate any arguments after a 2nd true result.</p><p><pre><code>say 0 ^^ 42;                             # OUTPUT: «42␤»\nsay '' ^^ 0;                             # OUTPUT: «0␤»\nsay 0 ^^ 42 ^^ 1 ^^ die \"never called\";  # OUTPUT: «Nil␤»</code></pre></p><p>Note that the semantics of this operator may not be what you assume: infix ^^ flips to the first true value it finds and then flips to Nil forever after the second, no matter how many more true values there are. (In other words, it has \"find the one true value\" semantics, not \"boolean parity\" semantics.)</p>","&infix:<∌>":"<p><pre><code>multi sub infix:<∌>($a,$b --> Bool:D)</code></pre></p><p>Non-membership operator.</p><p>Returns True if $a is not an element of $b. Equivalent to !(cont).</p><p><pre><code>say (1,2,3) ∌ 4; # OUTPUT: «True␤»\nsay (1,2,3) !(cont) 2; # OUTPUT: «False␤»\n</code></pre></p><p>∉ is codepoint U+220C (DOES NOT CONTAIN AS MEMBER).</p>","&infix:<(-)>":"<p><pre><code>multi sub infix:<(-)>(**@p)\nmulti sub infix:<∖>(**@p)</code></pre></p><p>Set difference operator.</p><p>Returns the set difference of all its arguments. This creates a new Set that contains all the elements the first argument has but the rest of the arguments don't, i.e., of all the elements of the first argument, minus the elements from the other arguments. But only if none of the arguments are a Bag, BagHash, Mix or MixHash.</p><p><pre><code>say <a a b c a d> (-) <a a b c c>; # OUTPUT: «set(d)␤»\nsay <a b c d e> (-) <a b c> (-) <a b d>; # OUTPUT: «set(e)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy>, the result is a new Bag (or Mix) containing all the elements remaining after the first argument with its weight subtracted by the weight of that element in each of the other arguments.</p><p><pre><code>say <a a b c a d> (-) bag(<a b c c>); # OUTPUT: «Bag(a(2), d)␤»\nsay <a a b c a d>  ∖  mix(<a b c c>); # OUTPUT: «Mix(a(2), c(-1), d)␤»\n</code></pre></p><p>∖ is equivalent to (-), at codepoint U+2216 (SET MINUS).</p>","&infix:<after>":"<p><pre><code>multi sub infix:<after>(Any,       Any)\nmulti sub infix:<after>(Real:D,    Real:D)\nmulti sub infix:<after>(Str:D,     Str:D)\nmulti sub infix:<after>(Version:D, Version:D)</code></pre></p><p>Generic ordering, uses the same semantics as cmp. Returns True if the first argument is larger than the second.</p>","&postcircumfix:<(>":"<p>The call operator treats the invocant as a Callable and invokes it, using the expression between the parentheses as arguments.</p><p>Note that an identifier followed by a pair of parentheses is always parsed as a subroutine call.</p><p>If you want your objects to respond to the call operator, implement a method CALL-ME.</p>","&infix:<?|>":"<p><pre><code>multi sub infix:<?|>($a, $b --> Bool:D)</code></pre></p><p>Boolean logical OR operator.</p><p>Coerces both arguments to Bool and does a logical OR (inclusive OR) operation.</p>","&infix:<~~>":"<p>The smartmatch operator aliases the left-hand side to $_, then evaluates the right-hand side and calls .ACCEPTS($_) on it. The semantics are left to the type of the right-hand side operand.</p><p>Here is a partial list of some of the built-in smartmatching functionality. For full details, see ACCEPTS documentation for the type on the right-hand side of the operator.</p><table class='sections'><tr><th>Right-hand side</th><th>Comparison semantics</th></tr>\n<tr><td>Mu:U</tr><td>type check</tr></tr>\n<tr><td>Str</tr><td>string equality</tr></tr>\n<tr><td>Numeric</tr><td>numeric equality</tr></tr>\n<tr><td>Regex</tr><td>regex match</tr></tr>\n<tr><td>Callable</tr><td>boolean result of invocation</tr></tr>\n<tr><td>Set/Bag</tr><td>equal element values</tr></tr>\n<tr><td>Any:D</tr><td>object identity</tr></tr>\n</table>","&infix:<=:=>":"<p><pre><code>multi sub infix:<=:=>(Mu \\a, Mu \\b)</code></pre></p><p>Container identity operator. Returns True if both arguments are bound to the same container. If it returns True, it generally means that modifying one will also modify the other.</p><p><pre><code>my ($a, $b) = (1, 3);\nsay $a =:= $b;      # OUTPUT: «False␤»\n$b = 2;\nsay $a;             # OUTPUT: «1␤»\n$b := $a;\nsay $a =:= $b;      # OUTPUT: «True␤»\n$a = 5;\nsay $b;             # OUTPUT: «5␤»</code></pre></p><p></p>","&infix:<..>":"<p><pre><code>multi sub infix:<..>($a, $b --> Range:D) is assoc<non></code></pre></p><p>Range operator</p><p>Constructs a Range from the arguments.</p>","&infix:<^..^>":"<p><pre><code>multi sub infix:<^..^>($a, $b --> Range:D) is assoc<non></code></pre></p><p>Open range operator</p><p>Constructs a Range from the arguments, excluding both start and end point.</p>","&prefix:<so>":"<p><pre><code>multi sub prefix:<so>(Mu $x --> Bool:D)</code></pre></p><p>Evaluates its argument in boolean context (and thus collapses Junctions), and returns the result.</p>","&infix:<andthen>":"<p>The andthen operator returns Empty upon encountering the first undefined argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as arguments if the right side is a Callable, whose count must be 0 or 1.</p><p>A handy use of this operator is to alias a routine's return value to $_ and to do additional manipulation with it, such as printing or returning it to caller. Since the andthen operator short-circuits, statements on the right-hand side won't get executed, unless left-hand side is defined (tip: Failures are never defined, so you can handle them with this operator).</p><p><pre><code>sub load-data {\n    rand  > .5 or return; # simulated load data failure; return Nil\n    (rand > .3 ?? 'error' !! 'good data') xx 10 # our loaded data\n}\nload-data.first: /good/ andthen say \"$_ is good\";\n# OUTPUT: «(good data is good)␤»\n\nload-data() andthen .return; # return loaded data, if it's defined\ndie \"Failed to load data!!\";</code></pre></p><p>The above example will print good data is good only if the subroutine returned any items that match /good/ and will die unless loading data returned a defined value. The aliasing behavior lets us pipe the values across the operator.</p><p>The andthen operator is a close relative of with statement modifier, and some compilers compile with to andthen, meaning these two lines have equivalent behavior:</p><p><pre><code>.say with 42;\n42 andthen .say;</code></pre></p>","&infix:<(>)>":"<p><pre><code>multi sub infix:<< (>) >>($a,$b --> Bool:D)\nmulti sub infix:<⊃>($a,$b --> Bool:D)</code></pre></p><p>Superset of operator.</p><p>Returns True if $a is a strict superset of $b, i.e., that all the elements of $b are elements of $a but $a is a larger set than $b.</p><p><pre><code>say (1,2,3) (>) (2,3,1); # OUTPUT: «False␤»\nsay (1,2,3) (>) (2,3); # OUTPUT: «True␤»\nsay 4 ⊃ (1,2,3); # OUTPUT: «False␤»\n</code></pre></p><p>⊃ is equivalent to (>), at codepoint U+2283 (SUPERSET OF).</p>","&infix:<.=>":"<p>Calls the right-side method on the value in the left-side container, replacing the resulting value in the left-side container.</p><p>In most cases, this behaves identically to the postfix mutator, but the precedence is lower:</p><p><pre><code>my $a = -5;\nsay ++$a.=abs;\n# OUTPUT: «6␤»\n</code></pre></p><p><pre><code>say ++$a .= abs;\n# OUTPUT: «Cannot modify an immutable Int␤\n#           in block <unit> at <tmp> line 1␤␤»\n</code></pre></p>","&infix:<==>":"<p><pre><code>multi sub infix:<==>(Any, Any)\nmulti sub infix:<==>(Int:D, Int:D)\nmulti sub infix:<==>(Num:D, Num:D)\nmulti sub infix:<==>(Rational:D, Rational:D)\nmulti sub infix:<==>(Real:D, Real:D)\nmulti sub infix:<==>(Complex:D, Complex:D)\nmulti sub infix:<==>(Numeric:D, Numeric:D)</code></pre></p><p>Numeric equality operator.</p><p>Coerces both arguments to Numeric (if necessary); returns True if they are equal.</p>","&infix:<,>":"<p><pre><code>sub infix:<,>(*@a --> List:D) is assoc<list></code></pre></p><p>Constructs a higher-order Cool from its arguments.</p><p><pre><code>my @list = :god('Þor'), ['is',\"mighty\"];\nsay @list;      # OUTPUT: «[god => Þor [is mighty]]␤»\nmy %hash = :god('Þor'), :is(\"mighty\");\nsay %hash.perl; # OUTPUT: «{:god(\"Þor\"), :is(\"mighty\")}␤»\nmy %a = :11a, :22b;\nsay %(%a, :33x);  # OUTPUT: «{a => 11, b => 22, x => 33}␤»</code></pre></p><p>In the first case it returns a List, in the second case, since the arguments are Pairs, it builds a Hash.</p><p>It can also be used for constructing variables from other variables, collating elements of different types, in this case a Hash and a Pair:</p><p><pre><code>my %features = %hash, :wields(\"hammer\");\nsay %features;  # OUTPUT: «{god => Þor, is => mighty, wields => hammer}␤»\n</code></pre></p><p>The comma is also used syntactically as the separator of arguments in calls.</p>","&infix:<**>":"<p><pre><code>multi sub infix:<**>(Any, Any --> Numeric:D) is assoc<right></code></pre></p><p>The exponentiation operator coerces both arguments to Numeric and calculates the left-hand-side raised to the power of the right-hand side.</p><p>If the right-hand side is a non-negative integer and the left-hand side is an arbitrary precision type (Int, FatRat), then the calculation is carried out without loss of precision.</p><p>Unicode superscripts will behave in exactly the same way.</p><p><pre><code>sub squared( Int $num ) { $num² };\nsay squared($_) for ^5; OUTPUT: «0␤1␤4␤9␤16␤»</code></pre></p><p>It also works for sequences of several Unicode superscript numbers:</p><p><pre><code>sub twenty-second-power( Int $num ) { $num²² };\nsay twenty-second-power($_) for ^5; # OUTPUT: «0␤1␤4194304␤31381059609␤17592186044416␤»</code></pre></p>","&infix:<(|)>":"<p><pre><code>multi sub infix:<(|)>(**@p)\nmulti sub infix:<∪>(**@p)</code></pre></p><p>Union operator.</p><p>Returns the union of all of its arguments. This creates a new Set that contains all the elements its arguments contain if none of the arguments are a Bag, BagHash, Mix or MixHash.</p><p><pre><code>say <a b d> ∪ bag(<a a b c>); # OUTPUT: «Bag(a(2), b, c, d)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy>, the result is a new Bag (or Mix) containing all the elements, each weighted by the highest weight that appeared for that element.</p><p><pre><code>say <a b d> ∪ bag(<a a b c>); # OUTPUT: «Bag(a(2), b, c, d)␤»\n</code></pre></p><p>∪ is equivalent to (|), at codepoint U+222A (UNION).</p>","&infix:<+|>":"<p><pre><code>multi sub infix:<+|>($a, $b --> Int:D)</code></pre></p><p>Integer bitwise OR operator: Coerces both arguments to Int and does a bitwise OR (inclusive OR) operation.</p>","&infix:<(.)>":"<p><pre><code>multi sub infix:<(.)>(**@p)\nmulti sub infix:<⊍>(**@p)</code></pre></p><p>Baggy multiplication operator.</p><p>Returns the Baggy multiplication of its arguments, i.e., a Bag that contains each element of the arguments with the weights of the element across the arguments multiplied together to get the new weight. Returns a Mix if any of the arguments is a Mixy.</p><p><pre><code>say <a b c> (.) <a b c d>; # OUTPUT: «Bag(a, b, c)␤»\n                           # Since 1 * 0 == 0, in the case of 'd'\nsay <a a b c a d> ⊍ bag(<a a b c c>); # OUTPUT: «Bag(a(6), b, c(2))␤»\n</code></pre></p><p>⊍ is equivalent to (.), at codepoint U+228D (MULTISET MULTIPLICATION).</p>","&infix:<^fff^>":"<p><pre><code>sub infix:<^fff^>(Mu $a, Mu $b)</code></pre></p><p>Like fff, except it does not return true for matches to either the left or right argument.</p><p><pre><code>my @list = <A B C>;\nsay $_ if /A/ fff /C/ for @list;   # OUTPUT: «A␤B␤C␤»\nsay $_ if /A/ ^fff^ /C/ for @list; # OUTPUT: «B␤»</code></pre></p><p>For the non-sed version, see ^ff^.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<|>":"<p><pre><code>multi sub infix:<|>($a, $b --> Junction:D) is assoc<list></code></pre></p><p> Creates an any Junction from its arguments.</p><p><pre><code>my $three-letters = /<[a b c]>/ | /<[i j k]>/ | /<[x y z]>/;\nsay $three-letters.perl; # OUTPUT: «any(/<[a b c]>/, /<[i j k]>/, /<[x y z]>/)␤»\nsay 'b' ~~ $three-letters; # OUTPUT: «True␤»</code></pre></p><p>This first creates an any Junction of three regular expressions (every one of them matching any of 3 letters), and then uses smartmatching to check whether the letter b matches any of them, resulting in a positive match. See also Junction for more details.</p>","&infix:<(^)>":"<p><pre><code>multi sub infix:<(^)>($a, $b)\nmulti sub infix:<⊖>($a,$b)\n\nmulti sub infix:<(^)>(**@p)\nmulti sub infix:<⊖>(**@p)</code></pre></p><p>Symmetric set difference operator.</p><p>Returns the symmetric set difference of all its arguments. This creates a new Set made up of all the elements that $a has but $b doesn't and all the elements $b has but $a doesn't if none of the arguments are a Bag, BagHash, Mix or MixHash. Equivalent to ($a ∖ $b) ∪ ($b ∖ $a).</p><p><pre><code>say <a b> (^) <b c>; # OUTPUT: «set(a c)␤»\n</code></pre></p><p>If any of the arguments are Baggy or Mixy>, the result is a new Bag (or Mix).</p><p><pre><code>say <a b> ⊖ bag(<b c>); # OUTPUT: «Bag(a, c)␤»\n</code></pre></p><p>⊖ is equivalent to (^), at codepoint U+2296 (CIRCLED MINUS).</p>","&postcircumfix:<{>":"<p><pre><code>sub postcircumfix:<{ }>(%container, **@key,\n                        :$k, :$v, :$kv, :$p, :$exists, :$delete)</code></pre></p><p>Universal interface for associative access to zero or more elements of a %container, a.k.a. \"hash indexing operator\".</p><p><pre><code>my %color = kiwi => \"green\", banana => \"yellow\", cherry => \"red\";\nsay %color{\"banana\"};                 # OUTPUT: «yellow␤»\nsay %color{\"cherry\", \"kiwi\"}.perl;    # OUTPUT: «(\"red\", \"green\")␤»\nsay %color{\"strawberry\"}:exists;      # OUTPUT: «False␤»\n\n%color{\"banana\", \"lime\"} = \"yellowish\", \"green\";\n%color{\"cherry\"}:delete;\nsay %color;             # OUTPUT: «banana => yellowish, kiwi => green, lime => green␤»</code></pre></p><p>See postcircumfix < > and postcircumfix « » for convenient shortcuts, and Subscripts for a more detailed explanation of this operator's behavior and how to implement support for it in custom types.</p>","&prefix:<let>":"<p><pre><code>sub prefix:<let>(Mu $a is rw)</code></pre></p><p>Refers to a variable in an outer scope whose value will be restored if the block exits unsuccessfully, implying that the block returned a defined object.</p><p><pre><code>my $name = \"Jane Doe\";\n\n{\n    let $name = prompt(\"Say your name \");\n    die if !$name;\n    CATCH {\n        default { say \"No name entered\" }\n    }\n    say \"We have $name\";\n}\n\nsay \"We got $name\";\n</code></pre></p><p>This code provides a default name for $name. If the user exits from the prompt or simply does not provide a valid input for $name; let will restore the default value provided at the top. If user input is valid, it will keep that.</p>","&infix:<eq>":"<p><pre><code>multi sub infix:<eq>(Any,   Any)\nmulti sub infix:<eq>(Str:D, Str:D)</code></pre></p><p>String equality operator.</p><p>Coerces both arguments to Str (if necessary); returns True if both are equal.</p><p>Mnemonic: equal</p>","&infix:<ne>":"<p><pre><code>multi sub infix:<ne>(Mu,    Mu)\nmulti sub infix:<ne>(Str:D, Str:D)</code></pre></p><p>String inequality operator.</p><p>Coerces both arguments to Str (if necessary); returns False if both are equal.</p><p>Mnemonic: not equal</p>","&infix:<ge>":"<p><pre><code>multi sub infix:<ge>(Mu,    Mu)\nmulti sub infix:<ge>(Str:D, Str:D)</code></pre></p><p>String greater than or equal to operator.</p><p>Coerces both arguments to Str (if necessary); returns True if the first is equal to or larger than the second, as determined by lexicographic comparison.</p><p>Mnemonic: greater or equal</p>","&infix:<lcm>":"<p><pre><code>multi sub infix:<lcm>($a, $b --> Int:D)</code></pre></p><p>Coerces both arguments to Int and returns the least common multiple; that is, the smallest integer that is evenly divisible by both arguments.</p>","&infix:<~>>":"<p>Coerces the left argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise right shift on the bits of the buffer.</p><p>Please note that this has not yet been implemented.</p>","&prefix:<~>":"<p><pre><code>multi sub prefix:<~>(Any --> Str:D)</code></pre></p><p>String context operator.</p><p>Coerces the argument to Str by calling the Str method on it.</p>","&infix:<does>":"<p><pre><code>sub infix:<does>(Mu $obj, Mu $role) is assoc<non></code></pre></p><p>Mixes $role into $obj at runtime. Requires $obj to be mutable.</p><p>Similar to but operator, the $role can instead be an instantiated object, in which case, the operator will create a role for you automatically. The role will contain a single method named the same as $obj.^name and that returns $obj:</p><p><pre><code>my $o = class { method Str { \"original\" } }.new;\nput $o;            # OUTPUT: «original␤»\n$o does \"modded\";\nput $o;            # OUTPUT: «modded␤»</code></pre></p><p>If methods of the same name are present already, the last mixed in role takes precedence.</p>","&infix:<?^>":"<p><pre><code>multi sub infix:<?^>(Mu $x = Bool::False)\nmulti sub infix:<?^>(Mu \\a, Mu \\b)</code></pre></p><p>Boolean bitwise XOR operator: Coerces the argument(s) to Bool and performs logical XOR on them: it will return True if and only if just one of the argument is true. It returns identity on a single argument.</p>","&infix:<∘>":"<p><pre><code>multi sub infix:<∘>()\nmulti sub infix:<∘>(&f)\nmulti sub infix:<∘>(&f, &g --> Block:D)</code></pre></p><p>The function composition operator infix:<∘> or infix:<o> combines two functions, so that the left function is called with the return value of the right function. If the .count of the left function is greater than 1, the return value of the right function will be slipped into the left function.</p><p>Both .count and .arity of the right-hand side will be maintained.</p><p><pre><code>sub f($p){ say 'f'; $p / 2 }\nsub g($p){ say 'g'; $p * 2 }\n\nmy &composed = &f ∘ &g;\nsay composed 2; # OUTPUT: «g␤f␤2␤»\n# equivalent to:\nsay 2.&g.&f;\n# or to:\nsay f g 2;</code></pre></p><p><pre><code>sub f($a, $b, $c) { [~] $c, $b, $a }\nsub g($str){ $str.comb }\nmy &composed = &f ∘ &g;\nsay composed 'abc'; # OUTPUT: «cba␤»\n# equivalent to:\nsay f |g 'abc';\n</code></pre></p><p>The single-arg candidate returns the given argument as is. The zero-arg candidate returns an identity routine that simply returns its argument.</p><p><pre><code>my &composed = [∘] &uc;\nsay composed 'foo'; # OUTPUT: «FOO␤»\n\nmy &composed = [∘];\nsay composed 'foo'; # OUTPUT: «foo␤»</code></pre></p>","&infix:<~|>":"<p>Coerces each argument to a non-variable-encoding string buffer type (e.g. buf8, buf16, buf32) and then performs a numeric bitwise OR on corresponding integers of the two buffers, padding the shorter buffer with zeroes.</p>","&infix:<mod>":"<p><pre><code>multi sub infix:<mod>(Int:D $a, Int:D $b --> Int:D)</code></pre></p><p>Integer modulo operator. Returns the remainder of an integer modulo operation.</p>","&infix:<<=>":"<p><pre><code>multi sub infix:«<=»(Int:D, Int:D)\nmulti sub infix:«<=»(Num:D, Num:D)\nmulti sub infix:«<=»(Real:D, Real:D)</code></pre></p><p>Numeric less than or equal to operator.</p><p>Coerces both arguments to Real (if necessary); returns True if the first argument is smaller than or equal to the second.</p>","&infix:<notandthen>":"<p>The notandthen operator returns Empty upon encountering the first defined argument, otherwise the last argument. Last argument is returned as-is, without being checked for definedness at all. Short-circuits. The result of the left side is bound to $_ for the right side, or passed as arguments if the right side is a Callable, whose count must be 0 or 1.</p><p>At first glance, notandthen might appear to be the same thing as the orelse operator. The difference is subtle: notandthen returns Empty when it encounters a defined item (that isn't the last item), whereas orelse returns that item. In other words, notandthen is a means to act when items aren't defined, whereas orelse is a means to obtain the first defined item:</p><p><pre><code>sub all-sensors-down     { [notandthen] |@_, True             }\nsub first-working-sensor { [orelse]     |@_, 'default sensor' }\n\nall-sensors-down Nil, Nil, Nil\n  and say 'OMG! All sensors are down!'; # OUTPUT:«OMG! All sensors are down!␤»\nsay first-working-sensor Nil, Nil, Nil; # OUTPUT:«default sensor␤»\n\nall-sensors-down Nil, 42, Nil\n  and say 'OMG! All sensors are down!'; # No output\nsay first-working-sensor Nil, 42, Nil;  # OUTPUT:«42␤»\n</code></pre></p><p>The notandthen operator is a close relative of without statement modifier, and some compilers compile without to notandthen, meaning these two lines have equivalent behavior:</p><p><pre><code>sub good-things { fail }\n\n'boo'.say without good-things;\ngood-things() notandthen 'boo'.say;\n</code></pre></p>","&infix:<x>":"<p><pre><code>sub infix:<x>($a, $b --> Str:D)</code></pre></p><p>String repetition operator.</p><p>Repeats the string $a $b times, if necessary coercing $a to Str and $b Int. Returns an empty string if $b <= 0 . An exception X::Numeric::CannotConvert will be thrown if $b is -Inf or NaN.</p><p><pre><code>say 'ab' x 3;           # OUTPUT: «ababab␤»\nsay 42 x 3;             # OUTPUT: «424242␤»\n\nmy $a = 'a'.IO;\nmy $b = 3.5;\nsay $a x $b;            # OUTPUT: «aaa␤»</code></pre></p><p>List repetition operator</p>","&infix:<ff>":"<p><pre><code>sub infix:<ff>(Mu $a, Mu $b)</code></pre></p><p>Also called the flipflop operator, compares both arguments to $_ (that is, $_ ~~ $a and $_ ~~ $b). Evaluates to False until the left-hand smartmatch is True, at which point it evaluates to True until the right-hand smartmatch is True.</p><p>In effect, the left-hand argument is the \"start\" condition and the right-hand is the \"stop\" condition. This construct is typically used to pick up only a certain section of lines. For example:</p><p><pre><code>my $excerpt = q:to/END/;\nHere's some unimportant text.\n=begin code\n    This code block is what we're after.\n    We'll use 'ff' to get it.\n=end code\nMore unimportant text.\nEND\n\nmy @codelines = gather for $excerpt.lines {\n    take $_ if \"=begin code\" ff \"=end code\"\n}\n# this will print four lines, starting with \"=begin code\" and ending with\n# \"=end code\"\nsay @codelines.join(\"\\n\");\n</code></pre></p><p>After matching the start condition, the operator will then match the same $_ to the stop condition and act accordingly if successful. In this example, only the first element is printed:</p><p><pre><code>for <AB C D B E F> {\n    say $_ if /A/ ff /B/;  # OUTPUT: «AB␤»\n}</code></pre></p><p>If you only want to test against a start condition and have no stop condition, * can be used as such.</p><p><pre><code>for <A B C D E> {\n    say $_ if /C/ ff *;    # OUTPUT: «C␤D␤E␤»\n}</code></pre></p><p>For the sed-like version, which does not try $_ on the stop condition after succeeding on the start condition, see fff.</p><p>This operator cannot be overloaded, as it's handled specially by the compiler.</p>","&infix:<+>":"<p><pre><code>multi sub infix:<+>($a, $b --> Numeric:D)</code></pre></p><p>Addition operator.</p><p>Coerces both arguments to Numeric and adds them.</p>","&prefix:<temp>":"<p><pre><code>sub prefix:<temp>(Mu $a is rw)</code></pre></p><p>\"temporizes\" the variable passed as the argument. The variable begins with the same value as it had in the outer scope, but can be assigned new values in this scope. Upon exiting the scope, the variable will be restored to its original value.</p><p><pre><code>my $a = \"three\";\nsay $a; # OUTPUT: «three␤»\n{\n    temp $a;\n    say $a; # OUTPUT: «three␤»\n    $a = \"four\";\n    say $a; # OUTPUT: «four␤»\n}\nsay $a; # OUTPUT: «three␤»</code></pre></p><p>You can also assign immediately as part of the call to temp:</p><p><pre><code>temp $a = \"five\";\n</code></pre></p><p>Be warned the temp effects get removed once the block is left. If you were to access the value from, say, within a Promise after the temp was undone, you'd get the original value, not the temp one:</p><p><pre><code>my $v = \"original\";\n{\n    temp $v = \"new one\";\n    start {\n        say \"[PROMISE] Value before block is left: `$v`\";\n        sleep 1;\n        say \"[PROMISE] Block was left while we slept; value is now `$v`\";\n    }\n    sleep ½;\n    say \"About to leave the block; value is `$v`\";\n}\nsay \"Left the block; value is now `$v`\";\nsleep 2;\n\n# OUTPUT:\n# [PROMISE] Value before block is left: `new one`\n# About to leave the block; value is `new one`\n# Left the block; value is now `original`\n# [PROMISE] Block was left while we slept; value is now `original`\n</code></pre></p>","&infix:<<>":"<p><pre><code>multi sub infix:«<»(Int:D, Int:D)\nmulti sub infix:«<»(Num:D, Num:D)\nmulti sub infix:«<»(Real:D, Real:D)</code></pre></p><p>Numeric less than operator.</p><p>Coerces both arguments to Real (if necessary); returns True if the first argument is smaller than the second.</p>"}}