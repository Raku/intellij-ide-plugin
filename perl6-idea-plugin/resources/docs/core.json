{
  "types": [
    {
      "desc": "TITLE\nclass Int\n\nSUBTITLE\nInteger (arbitrary-precision)\n\n    class Int is Cool does Real { }\n\n\nInt objects store integral numbers of arbitrary size. Ints are immutable.\n\nThere are two main syntax forms for Int literals\n\n    123;         # Int in decimal notation\n    :16<BEEF>;   # Int in radix notations\n\nFor your convenience common radix forms come with a prefix shortcut.\n\n    say so :2<11111111> == 0b11111111 == :8<377> == 0o377 == 255 == 0d255 == :16<ff> == 0xff;\n    # OUTPUT: «True␤»\n\nAll forms allow underscores between any two digits which can serve as\nvisual separators, but don't carry any meaning:\n\n    5_00000;       # five Lakhs\n    500_000;       # five hundred thousand\n    0xBEEF_CAFE;   # a strange place\n    :2<1010_1010>; # 0d170\n\nRadix notation also supports round and angle brackets which allow you to\nparse a string for a given base, and putting together digits into a whole\nnumber respectively:\n\n    :16(\"9F\");         # 159\n    :100[99, 2, 3];    # 990203\n\nThese notations allow you to use variables, too:\n\n    my $two = \"2\";\n    my $ninety-nine = \"99\";\n    :16($ninety-nine); # 153\n    :100[99, $two, 3]; # 990203\n\n",
      "name": "Int"
    },
    {
      "name": "Perl",
      "desc": "TITLE\nclass Perl\n\nSUBTITLE\nPerl related information\n\n    class Perl does Systemic { }\n\nBuilt-in class for providing perl related information. Usually accessed\nthrough the $*PERL dynamic variable.\n\n"
    },
    {
      "name": "Iterable",
      "desc": "TITLE\nrole Iterable\n\nSUBTITLE\nInterface for container objects that can be iterated over\n\n    role Iterable { }\n\nIterable serves as an API for objects that can be iterated with for and\nrelated iteration constructs, like assignment to a Positional variable.\n\nIterable objects nested in other Iterable objects (but not within scalar\ncontainers) flatten in certain contexts, for example when passed to a\nslurpy parameter (*@a), or on explicit calls to flat.\n\nIts most important aspect is a method stub for iterator.\n\n    class DNA does Iterable {\n        has $.chain;\n        method new ($chain where { $chain ~~ /^^ <[ACGT]>+ $$ / } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator(DNA:D:) {\n            $!chain.comb.rotor(3).iterator;\n        }\n    }\n\n    my $a := DNA.new('GAATCC');\n    .say for $a; # OUTPUT: «(G A A)␤(T C C)␤»\n\n\nThis example mixes in the Iterable role to offer a new way of iterating\nover what is essentially a string (constrained by where to just the four\nDNA letters). In the last statement, for actually hooks to the iterator\nrole printing the letters in groups of 3.\n\n"
    },
    {
      "desc": "TITLE\nclass Slip\n\nSUBTITLE\nA kind of List that automatically flattens into an outer container\n\n    class Slip is List {}\n\nA Slip is a List that automatically flattens into an outer List (or other\nlist-like container or iterable).\n\nFor example it allows you to write a map that produces more than one value\ninto the result without nesting:\n\n    say <a b c>.map({ ($_, $_.uc).Slip }).join('|');        # OUTPUT: «a|A|b|B|c|C␤»\n\n\nIn contrast, when returning an ordinary List, the resulting list is\nnested:\n\n    say <a b c>.map({ $_, $_.uc }).join('|');               # OUTPUT: «a A|b B|c C␤»\n\n\nTo create a Slip, either coerce another list-like type to it by calling the\nSlip method, or use the slip subroutine:\n\n    # This says \"1\" and then says \"2\", rather than saying \"(1 2)\"\n    .say for gather {\n        take slip(1, 2);\n    }\n\nA Slip may also be created by using the prefix:<|> operator. This differs\nfrom the slip subroutine in both precedence and treatment of single\narguments. In fact, prefix:<|> only takes a single argument, so in that\nway, it behaves closer to the .Slip method than the slip subroutine.\n\n    my $l = (1, 2, 3);\n    say (1, slip 2, 3).perl;  # says (1, 2, 3)      , slips 2, 3 into (1, …)\n    say (0, slip $l).perl;    # says (0, $(1, 2, 3)), $l does not break apart\n    say (0, $l.Slip).perl;    # says (0, 1, 2, 3)   , slips from $l into (0, …)\n    say (|$l).perl;           # says slip(1, 2, 3)  , breaks apart $l\n    say (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n    say (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n\n\nLoops that do not want to produce a value for an iteration use Slips,\nrather than empty Lists to do so, as do if statements that do not run their\nblocks.\n\nPlease note that prefix:<|> will also apply parameters in a slippy manner\nto a routine call. It does not forward a Slip to the called routine, that\nincludes return and take.\n\n    my \\l = gather for 1..10 -> $a, $b { take |($a, $b) }; say l.perl;\n    # OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»\n    my \\m= gather for 1..10 -> $a, $b { take ($a, $b).Slip }; say m.perl;\n    # OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»\n\n",
      "name": "Slip"
    },
    {
      "name": "NFKD",
      "desc": "TITLE\nclass NFKD\n\nSUBTITLE\nCodepoint string in Normal Form KD (compatibility decomposed)\n\n    class NFKD is Uni {}\n\nA Codepoint string in Unicode Normalization Form KD. It is created by\nCompatibility Decomposition. For more information on what this means, see\nUnicode TR15."
    },
    {
      "desc": "TITLE\nmodule Test\n\nSUBTITLE\nWriting and running tests\n\nThis module provides a testing framework, and is used in the official suite\nthat tests the specification. All its functions emit output conforming to\nthe Test Anything Protocol.\n\n",
      "name": "Test"
    },
    {
      "name": "Buf",
      "desc": "TITLE\nrole Buf\n\nSUBTITLE\nMutable buffer for binary data\n\n    role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T){ ... }\n\nA Buf does the role of a mutable sequence of (usually unsigned) integers.\n\n    my $b = Buf.new(1, 2, 3);\n    $b[1] = 42;\n\nHowever, it's a parameterized type, and you can instantiate with several\ninteger types:\n\n    my $b = Buf[int32].new( 3, -3, 0xff32, -44)\n    # OUTPUT: «Buf[int32]:0x<03 -3 FF32 -2C>»\n\n\nBy default, Buf uses 8-bit unsigned integers, that is, it is equivalent to\nBuf[uint8]. Some other types of Bufs which are used often get their own\nclass name.\n\n  buf8   Buf[uint8]\n  buf16  Buf[uint16]\n  buf32  Buf[uint32]\n  buf64  Buf[uint64]\n\n\nYou can use these in pretty much the same way you would with Buf:\n\n    my $buf = buf8.new(3,6, 254);\n    say $buf; # OUTPUT: «Buf[uint8]:0x<03 06 fe>␤»\n\nPlus there are some object methods, like encode that might return a buf8 in\nsome cases where it is the best representation for a particular encoding.\n\n"
    },
    {
      "desc": "TITLE\nclass DateTime\n\nSUBTITLE\nCalendar date with time\n\n    class DateTime does Dateish {}\n\nFor handling points in civil time, a DateTime object stores year, month,\nday, hour, minute (all Int), second (potentially fractional) and a time\nzone.\n\nIt provides methods for calculating with date and time.\n\nDateTime methods are immutable; if you are tempted to modify one, create a\nmodified copy instead.\n\nTime zones are handled as Integers in seconds offset from UTC, not by time\nzone name.\n\n    my $dt = DateTime.new(\n        year    => 2015,\n        month   => 11,\n        day     => 21,\n        hour    => 16,\n        minute  => 1,\n    );\n\n    say $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»\n    say $dt.later(days => 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»\n    say $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»\n    say $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»\n\n    my $now = DateTime.now(formatter => { sprintf \"%02d:%02d\", .hour, .minute });\n    say $now;                           # 12:45 (or something like that)\n\n\n",
      "name": "DateTime"
    },
    {
      "desc": "TITLE\nclass Num\n\nSUBTITLE\nFloating-point number\n\n    class Num is Cool does Real { }\n\nA Num object stores a floating-point number. It is immutable. On most\nplatforms, it's an IEEE 754 64-bit floating point numbers, aka \"double\nprecision\".\n\n \n\n  Inf\n\nThe value Inf is an instance of Num and represents value that's too large\nto represent in 64-bit double-precision floating point number (roughly,\nabove 1.7976931348623158e308 for positive Inf and below\n-1.7976931348623157e308 for negative Inf) as well as returned from certain\noperations as defined by the IEEE 754-2008 standard.\n\n    say 2e300 ** 2e300; # OUTPUT: «Inf␤»\n    say (-1/0).Num;     # OUTPUT: «-Inf␤»\n\nThe ∞ U+221E Unicode character can be used instead of the word Inf and can\nbe handy when Inf would otherwise require an unspace, such as when writing\nComplex numbers:\n\n    say Inf+Inf\\i; # Backslash (unspace) before `i` required\n    say ∞+∞i;      # No backslash is needed\n\nNote that there are just two infinities (positive and negative), so even if\nan operation that would instinctively give a \"larger\" infinity is\nperformed, the result in still an infinity of the original magnitude. The\ninfinities can be compared, operated and used as an argument as if they\nwere simply a number that's too big to represent or to signify \"without\nbounds\" or limits:\n\n    say ∞²;                       # OUTPUT: «Inf␤»\n    say 42 + Inf === ∞;           # OUTPUT: «True␤»\n    say atan ∞;                   # OUTPUT: «1.5707963267949␤»\n    say -∞ < 42 < ∞;              # OUTPUT: «True␤»\n    my  $l := 1, 2, 4, 8 ... Inf; # Infinite sequence (no limits)\n\nIn some cases, it's used as an implicit value to represent \"all of them\"\n\n    say \"House of M\".comb(3,Inf).join(\"←X→\");\n    # OUTPUT: «Hou←X→se ←X→of ←X→M␤»\n\nIn the example above, Inf can be eliminated, since it's the default value\nfor the second argument of .comb, used to indicate how many parts should be\nreturned.\n\nDivision of an infinity by another infinity results in a NaN:\n\n    say ∞/∞;             # OUTPUT: «NaN␤»\n\n  NaN\n\nThe value NaN is an instance of Num and represents a floating point\nnot-a-number value, which is returned from some routines where a concrete\nnumber as the answer is not defined, but a Numeric value is still\nacceptable. NaN is defined and boolifies to True, but is not numerically\nequal to any value (including itself).\n\n    say cos ∞;     # OUTPUT: «NaN␤»\n    say (0/0).Num; # OUTPUT: «NaN␤»\n\nTo test for NaN, use isNaN method or === operator:\n\n    say (0/0).isNaN;       # OUTPUT: «True␤»\n    say (0/0).Num === NaN; # OUTPUT: «True␤»\n\n  method rand\n\n    method rand(Num:D: --> Num)\n\nReturns a pseudo random number between 0 and the invocant.\n\n  sub srand\n\n    sub srand(Int $seed --> Int:D)\n\nSeeds the pseudo random number generator used by Num.rand with the provided\nvalue. Note that srand is called with a platform dependent value when a\nPerl 6 program is started.\n\n  method Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.\n\n  Int\n\n    method Int(Num:D:)\n\nConverts the number to an Int. Fails with X::Numeric::CannotConvert if the\ninvocant is a NaN or Inf/-Inf. No rounding is performed.\n\n  Rat\n\n    method Rat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a Rat with $epsilon precision. If the invocant is a\nInf, -Inf, or a NaN, converts them to a Rat with 0 denominator and 1, -1,\nor 0 numerator, respectively.\n\n  FatRat\n\n    method FatRat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a FatRat with the precision $epsilon. If invocant is\na Inf, -Inf, or a NaN, converts them to a FatRat with 0 denominator and 1,\n-1, or 0 numerator, respectively.",
      "name": "Num"
    },
    {
      "desc": "TITLE\nclass Method\n\nSUBTITLE\nMember function\n\n    class Method is Routine { }\n\nA type for methods that behave the same way then Routine with some\nexceptions listed in the following. For details of a method's parameter\nlist see Signature.\n\nTo create a method outside a class definition, use the declarators my and\nmethod. If an identifier is provided the methods name will be injected into\nthe scope specified by the declarator.\n\n    my $m = method ($invocant: $param) {\n        say \"$invocant: '$param'\";\n    }\n    \"greeting\".$m(\"hello\");  # OUTPUT: «greeting: 'hello'␤»\n\n    <a b c>.&(my method (List:D:) { say self.perl; self }).say;\n    # OUTPUT: «(\"a\", \"b\", \"c\")␤(a b c)␤»\n\nThe invocant of a method defaults to self. A type constraint including a\ntype-smiley can be used and is honored both for methods defined in a class\nand for free floating methods. Call the latter with .& on an object.\n\n    my method m(Int:D: $b){\n        say self.^name\n    }\n    my $i = 1;\n    $i.&m(<a>);\n    # OUTPUT: «Int␤»\n\n ",
      "name": "Method"
    },
    {
      "name": "Sub",
      "desc": "TITLE\nclass Sub\n\nSUBTITLE\nSubroutine\n\n    class Sub is Routine { }\n\nA type for subroutines and operators. Subs are created with the sub\ndeclarator keyword followed by an optional identifier. This short tutorial\nexplains how operators are declared. For details of a sub's parameter list,\nsee Signature.\n\nNote that subs that go by the same name as coercers will not take\nprecedence over them. Use the &-sigil to call them.\n\n    sub Int(Str $s){'what?'};\n    say [Int, Int('42'),&Int('42')];\n    # OUTPUT: «[(Int) 42 what?]␤»\n\n Subs can be nested and scoped with my and our, whereby my is the default.\nA sub declared with my cannot be reached from any outer scope. An our\nscoped sub will not redefine a sub of the same name in the outer scope. Any\nsub can be accessed via a closure from any outer scope. For instance, in\nthis example\n\n    sub can-be-seener( $whatever ) {\n      my sub can-be-seen ( $objection ) {\n        return $whatever but $objection;\n      }\n      return &can-be-seen\n    }\n\n    my $objectioner = can-be-seener( \"Really?\");\n    say $objectioner(42).Int; # OUTPUT: «42␤»\n\n$objectioner will contain the can-be-seen subroutine, even if it has been\ndeclared in another scope; calling it with 42 will return \"Really?\" with\nthe number 42 mixed in, as shown in the last sentence.\n\nOperators\n\nOperators are also Subs. Their definition includes the category they belong\nto and their code, precedence and associativity. The syntax used in their\ndefinition is an example of extended identifiers.\n\nTraits \n\nA Trait is a sub that is applied at compile time to various objects like\nclasses, routines or containers. It is declared with the trait_mod\ndeclarator followed by a colon and a string literal containing the name of\nthe trait. A single positional parameter defines the type of the object\nthat the trait is applied to. A single named argument defines the secondary\nname and may carry arguments when the trait is called. Traits are a special\ngrammar category and are allowed to be placed after most language object\nnames or parameter lists.\n\n    say 'start';\n    multi sub trait_mod:<is>(Sub $s, :$foo){\n        say \"⟨is foo⟩ has been called with ⟨$foo⟩ on {$s.WHICH}\";\n    }\n    sub bar() is foo<oi‽> {\n        say 'bar has been called'\n    }\n    bar();\n    # OUTPUT: «⟨is foo⟩ has been called with ⟨oi‽⟩ on Sub|47563000␤start␤bar has been called␤»\n\nUse destructuring to call traits with complex arguments.\n\n    multi trait_mod:<is>(Variable $a, :@foo [$firstpos, *@restpos, :$named, *%restnameds]) {\n        say [$firstpos, @restpos, $named, %restnameds]\n    }\n    my $x is foo[1,2,3,:named<a>, :2b, :3c] = 1\n    # OUTPUT: «[1 [2 3] a {b => 2, c => 3}]␤»\n\nDespite its funky syntax, a trait is just a normal Sub. We can apply traits\nto it (or even themselves) and we can apply traits to objects at runtime.\n\n    multi sub trait_mod:<is> (Sub $s, :$foo) is foo {\n        say 'is foo called'\n    }\n    sub bar {}\n    &trait_mod:<is>(&bar, :foo);\n    # OUTPUT: «is foo called␤is foo called␤»"
    },
    {
      "desc": "TITLE\nclass NFD\n\nSUBTITLE\nCodepoint string in Normal Form D (decomposed)\n\n    class NFD is Uni {}\n\nA Codepoint string in the \"D\" Unicode Normalization Form",
      "name": "NFD"
    },
    {
      "desc": "TITLE\nrole Iterator\n\nSUBTITLE\nGeneric API for producing a sequence of values\n\n    constant IterationEnd\n    role Iterator { }\n\n\nA Iterator is an object that can generate or provide elements of a\nsequence. Users usually don't have to care about iterators, their usage is\nhidden behind iteration APIs such as for @list { }, map, grep, head, tail,\nskip and list indexing with .[$idx].\n\nThe main API is the pull-one method, which either returns the next value,\nor the sentinel value IterationEnd if no more elements are available. Each\nclass implementing Iterator must provide a pull-one method. All other\nnon-optional Iterator API methods are implemented in terms of pull-one, but\ncan also be overridden by consuming classes for performance or other\nreasons. There are also optional Iterator API methods that will only be\ncalled if they are implemented by the consuming class: these are not\nimplemented by the Iterator role.\n\nIterationEnd\n\nIterators only allow one iteration over the entire sequence. It's forbidden\nto make attempts to fetch more data, once IterationEnd has been generated,\nand behavior for doing so is undefined. For example, the following Seq will\nnot cause the die to be called under normal use, because pull-one will\nnever be called after it returns IterationEnd:\n\n    class SkippingArray is Array {\n        # skip all undefined values while iterating\n        method iterator {\n            class :: does Iterator {\n                has $.index is rw = 0;\n                has $.array is required;\n                method pull-one {\n                    $.index++ while !$.array.AT-POS($.index).defined && $.array.elems > $.index;\n                    $.array.elems > $.index ?? $.array.AT-POS($.index++) !! IterationEnd\n                }\n            }.new(array => self)\n        }\n    }\n\n    my @a := SkippingArray.new;\n\n    @a.append: 1, Any, 3, Int, 5, Mu, 7;\n\n    for @a -> $a, $b {\n        say [$a, $b];\n    }\n\n    # OUTPUT: «[1 3]␤[5 7]␤»\n\n\nThe only valid use of the sentinel value IterationEnd in a program is\nidentity comparison (using =:=) with the result of a method in the iterator\nAPI. Any other behavior is undefined and implementation dependent.\n\nPlease bear in mind that IterationEnd is a constant, so if you are going to\ncompare it against the value of a variable, this variable will have to be\nbound, not assigned. Comparing directly to the output of pull-one will\nwork.\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    say $it.pull-one =:= IterationEnd; # OUTPUT: «True␤»\n\n\nHowever, if we use a variable we and we assign it, the result will be\nincorrect:\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    my $is-it-the-end = $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «False␤»\n\n\nSo we'll have to bind the variable to make it work:\n\n    my $is-it-the-end := $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «True␤»\n\n\n",
      "name": "Iterator"
    },
    {
      "desc": "TITLE\nclass Instant\n\nSUBTITLE\nSpecific moment in time\n\n    class Instant is Cool does Real { }\n\nAn Instant is a particular moment in time measured in atomic seconds, with\nfractions. It is not tied to or aware of any epoch.\n\nAn Instant can be used to create a DateTime object set to that Instant. The\npseudo-constant now returns the current time as an Instant.\n\nBasic math is defined for Instants (as well as Durations). Adding an\nInstant to a Duration returns another Instant. Subtracting two Instants\nwill yield a Duration. Adding two Instants is explicitly disallowed. All\nother operations with Instants are undefined.\n\nFuture Leap Seconds\n\nThe methods that involve knowledge of leap seconds always assume that there\nwill be no further leaps after the last leap second that the implementation\nknows about, which may not be the last leap second that has actually been\nscheduled. This means you can get different results, depending on the\ncompiler version you're using. For example, the December 31, 2016 leap\nsecond was announced in July and shipped with Rakudo 2016.07, so 2016.06\nand earlier releases won't know about it:\n\n    $ perl6-2016.06 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726631\n\n    $ perl6-2016.07 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\nSince a Rakudo compiler always returns 0 for future leap seconds it doesn't\nknow about, you can patch your old code when new leap seconds are\nannounced, so it will give correct results, regardless of what version of\nthe compiler it runs on:\n\n    $ perl6-2016.06 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n    $ perl6-2016.07 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\n",
      "name": "Instant"
    },
    {
      "name": "Mixy",
      "desc": "TITLE\nrole Mixy\n\nSUBTITLE\nCollection of distinct objects with Real weights\n\n    role Mixy does Baggy { }\n\nA role for collections of weighted values. See Mix and MixHash. Mixy\nobjects differ from Baggy objects in that the weights of Mixy are Reals\nrather than Ints.\n\n"
    },
    {
      "name": "CurrentThreadScheduler",
      "desc": "TITLE\nclass CurrentThreadScheduler\n\nSUBTITLE\nScheduler that synchronously executes code on the current thread\n\n    class CurrentThreadScheduler does Scheduler {}\n\n\nCurrentThreadScheduler executes tasks on the current threads. This means\nthat method cue blocks until the code has finished executing."
    },
    {
      "desc": "TITLE\nclass Signature\n\nSUBTITLE\nParameter list pattern\n\n    class Signature { }\n\nA signature is a static description of the parameter list of a code object.\nThat is, it describes what and how many arguments you need to pass to the\ncode or function in order to call it.\n\nPassing arguments to a signature binds the arguments, contained in a\nCapture, to the signature.\n\n \n\nSignature literals\n\nSignatures appear inside parentheses after subroutine and method names, on\nblocks after a ->  or <->  arrow, as the input to variable declarators like\nmy, or as a separate term starting with a colon.\n\n    sub f($x) { }\n    #    ^^^^ Signature of sub f\n    my method x() { }\n    #          ^^ Signature of a method\n    my $s = sub (*@a) { }\n    #           ^^^^^ Signature of an anonymous function\n\n    for <a b c> -> $x { }\n    #              ^^   Signature of a Block\n\n    my ($a, @b) = 5, (6, 7, 8);\n    #  ^^^^^^^^ Signature of a variable declarator\n\n    my $sig = :($a, $b);\n    #          ^^^^^^^^ Standalone Signature object\n\nSignature literals can be used to define the signature of a callback or a\nclosure.\n\n    sub f(&c:(Int)) { }\n    sub will-work(Int) { }\n    sub won't-work(Str) { }\n    f(&will-work);\n\n    f(&won't-work);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding::Parameter: Constraint type check failed in binding to parameter '&c'␤»\n\n    f(-> Int { 'this works too' } );\n\nSmartmatching signatures against a List is supported.\n\n    my $sig = :(Int $i, Str $s);\n    say (10, 'answer') ~~ $sig;\n    # OUTPUT: «True␤»\n    my $sub = sub ( Str $s, Int $i ) { return $s xx $i };\n    say $sub.signature ~~ :( Str, Int );\n    # OUTPUT: «True␤»\n    given $sig {\n        when :(Str, Int) { say 'mismatch' }\n        when :($, $)     { say 'match' }\n        default          { say 'no match' }\n    }\n    # OUTPUT: «match␤»\n\nIt matches the second when clause since :($, $) represents a Signature with\ntwo scalar, anonymous, arguments, which is a more general version of $sig.\n\nWhen smartmatching against a Hash, the signature is assumed to consist of\nthe keys of the Hash.\n\n    my %h = left => 1, right => 2;\n    say %h ~~ :(:$left, :$right);\n    # OUTPUT: «True␤»\n\n  Parameter separators\n\nA signature consists of zero or more parameters, separated by commas.\n\n    my $sig = :($a, @b, %c);\n    sub add($a, $b) { $a + $b };\n\nAs an exception the first parameter may be followed by a colon instead of a\ncomma to mark the invocant of a method. The invocant is the object that was\nused to call the method, which is usually bound to self. By specifying it\nin the signature, you can change the variable name it is bound to.\n\n    method ($a: @b, %c) {};       # first argument is the invocant\n\n    class Foo {\n        method whoami($me:) {\n            \"Well I'm class $me.^name(), of course!\"\n        }\n    }\n    say Foo.whoami; # OUTPUT: «Well I'm class Foo, of course!␤»\n\n \n\n  Type constraints\n\nParameters can optionally have a type constraint (the default is Any).\nThese can be used to restrict the allowed input to a function.\n\n    my $sig = :(Int $a, Str $b);\n\n\nType constraints can have any compile-time defined value\n\n    subset Positive-integer of Int where * > 0;\n    sub divisors(Positive-integer $n) { $_ if $n %% $_ for 1..$n };\n    divisors 2.5;\n    # ERROR «Type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Rat (2.5) $n)»\n    divisors -3;\n    # ERROR: «Constraint type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Int (-3)»\n\n\nPlease note that in the code above type constraints are enforced at two\ndifferent levels: the first level checks if it belongs to the type in which\nthe subset is based, in this case Int. If it fails, a Type check error is\nproduced. Once that filter is cleared, the constraint that defined the\nsubset is checked, producing a Constraint type check error if it fails.\n\n Anonymous arguments are fine too, if you don't actually need to refer to a\nparameter by name, for instance to distinguish between different signatures\nin a multi or to check the signature of a Callable.\n\n    my $sig = :($, @, %a);          # two anonymous and a \"normal\" parameter\n    $sig = :(Int, Positional);      # just a type is also fine (two parameters)\n    sub baz(Str) { \"Got passed a Str\" }\n\nType constraints may also be type captures.\n\n In addition to those nominal types, additional constraints can be placed\non parameters in the form of code blocks which must return a true value to\npass the type check\n\n    sub f(Real $x where { $x > 0 }, Real $y where { $y >= $x }) { }\n\nThe code in where clauses has some limitations: anything that produces\nside-effects (e.g., printing output, pulling from an iterator, or\nincreasing a state variable) is not supported and may produce surprising\nresults if used. Also, the code of the where clause may run more than once\nfor a single typecheck in some implementations.\n\nThe where clause doesn't need to be a code block, anything on the right of\nthe where-clause will be used to smartmatch the argument against it. So you\ncan also write:\n\n    multi factorial(Int $ where 0) { 1 }\n    multi factorial(Int $x)        { $x * factorial($x - 1) }\n\nThe first of those can be shortened to\n\n    multi factorial(0) { 1 }\n\ni.e., you can use a literal directly as a type and value constraint on an\nanonymous parameter.\n\nTip: pay attention to not accidentally leave off a block when you, say,\nhave several conditions:\n\n    -> $y where   .so && .name    {}( sub one   {} ); # WRONG!!\n    -> $y where { .so && .name }  {}( sub two   {} ); # OK!\n    -> $y where   .so &  .name.so {}( sub three {} ); # Also good\n\nThe first version is wrong and will issue a warning about a sub object\ncoerced to string. The reason is the expression is equivalent to ($y ~~\n($y.so && $y.name)); that is \"call .so, and if that is True, call .name; if\nthat is also True use its value for smartmatching…\". It's the result of\n(.so && .name) it will be smartmatched against, but we want to check that\nboth .so and .name are truthy values. That is why an explicit Block or a\nJunction is the right version.\n\nAll previous arguments that are not part of a sub-signature in a Signature\nare accessible in a where-clause that follows an argument. Therefore, the\nwhere-clause of the last argument has access to all arguments of a\nsignature that are not part of a sub-signature. For a sub-signature place\nthe where-clause inside the sub-signature.\n\n    sub foo($a, $b where * == $a ** 2) { say \"$b is a square of $a\" }\n    foo 2, 4; # OUTPUT: «4 is a square of 2␤»»\n    # foo 2, 3;\n    # OUTPUT: «Constraint type check failed in binding to parameter '$b'…»\n\n    Constraining optional arguments\n\nOptional arguments can have constraints, too. Any where clause on any\nparameter will be executed, even if it's optional and not provided by the\ncaller. In that case you may have to guard against undefined values within\nthe where clause.\n\n    sub f(Int $a, UInt $i? where { !$i.defined or $i > 5 }) { ... }\n\n    Constraining slurpy arguments\n\nSlurpy arguments can not have type constraints. A where-clause in\nconjunction with a Junction can be used to that effect.\n\n    sub f(*@a where {$_.all ~~ Int}) { say @a };\n    f(42);\n    f(<a>);\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «[42]␤Constraint type check failed in binding to parameter '@a' ...»\n\n\n    Constraining named arguments\n\nConstraints against Named arguments apply to the value part of the\ncolon-pair.\n\n    sub f(Int :$i){};\n    f :i<forty-two>;\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «X::TypeCheck::Binding::Parameter ==> Type check failed in\n    # binding to parameter '$i'; expected Int but got Str (\"forty-two\")␤»\n\n  \n\n    Constraining argument definiteness\n\nNormally, a type constraint only checks whether the value of the parameter\nis of the correct type. Crucially, both object instances and type objects\nwill satisfy such a constraint as illustrated below:\n\n    say  42.^name;    # OUTPUT: «Int␤»\n    say  42 ~~ Int;   # OUTPUT: «True␤»\n    say Int ~~ Int;   # OUTPUT: «True␤»\n\nNote how both 42 and Int satisfy the match.\n\nSometimes we need to distinguish between these object instances (42) and\ntype objects (Int). Consider the following code:\n\n    sub limit-lines(Str $s, Int $limit) {\n        my @lines = $s.lines;\n        @lines[0 .. min @lines.elems, $limit].join(\"\\n\")\n    }\n    say (limit-lines \"a \\n b \\n c \\n d \\n\", 3).perl; # \"a \\n b \\n c \\n d \"\n    say limit-lines Str, 3;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller lines(Str: );\n    # none of these signatures match:\n    #     (Str:D $: :$count!, *%_)\n    #     (Str:D $: $limit, *%_)\n    #     (Str:D $: *%_)»\n    say limit-lines \"a \\n b\", Int; # Always returns the max number of lines\n\nHere we really only want to deal with string instances, not type objects.\nTo do this, we can use the :D type constraint. This constraint checks that\nthe value passed is an object instance, in a similar fashion to calling its\nDEFINITE (meta)method.\n\nTo warm up, let's apply :D to the right-hand side of our humble Int\nexample:\n\n    say  42 ~~ Int:D;  # OUTPUT: «True␤»\n    say Int ~~ Int:D;  # OUTPUT: «False␤»\n\nNote how only 42 matches Int:D in the above.\n\nReturning to limit-lines, we can now amend its signature to catch the error\nearly:\n\n    sub limit-lines(Str:D $s, Int $limit) { };\n    say limit-lines Str, 3;\n    CATCH { default { put .^name ~ '--' ~ .Str } };\n    # OUTPUT: «Parameter '$s' of routine 'limit-lines' must be an object instance of type 'Str',\n    #          not a type object of type 'Str'.  Did you forget a '.new'?»\n\nThis is much better than the way the program failed before, since here the\nreason for failure is clearer.\n\nIt's also possible that type objects are the only ones that make sense for\na routine to accept. This can be done with the :U type constraint, which\nchecks whether the value passed is a type object rather than an object\ninstance. Here's our Int example again, this time with :U applied:\n\n    say  42 ~~ Int:U;  # OUTPUT: «False␤»\n    say Int ~~ Int:U;  # OUTPUT: «True␤»\n\nNow 42 fails to match Int:U while Int succeeds.\n\nHere's a more practical example:\n\n    sub can-turn-into(Str $string, Any:U $type) {\n       return so $string.$type;\n    }\n    say can-turn-into(\"3\", Int);        # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Int);      # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Num);      # OUTPUT: «True␤»\n    say can-turn-into(\"a string\", Num); # OUTPUT: «False␤»\n\nCalling can-turn-into with an object instance as its second parameter will\nyield a constraint violation as intended:\n\n    say can-turn-into(\"a string\", 123);\n    # OUTPUT: «Parameter '$type' of routine 'can-turn-into' must be a type object\n    # of type 'Any', not an object instance of type 'Int'...»\n\n\nFor explicitly indicating the normal behavior, that is, not constraining\nwhether the argument will be an instance or a type object, :_ can be used,\nbut this is unnecessary. :(Num:_ $) is the same as :(Num $).\n\nTo recap, here is a quick illustration of these type constraints, also\nknown collectively as type smileys:\n\n    # Checking a type object\n    say Int ~~ Any:D;    # OUTPUT: «False␤»\n    say Int ~~ Any:U;    # OUTPUT: «True␤»\n    say Int ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an object instance\n    say 42 ~~ Any:D;     # OUTPUT: «True␤»\n    say 42 ~~ Any:U;     # OUTPUT: «False␤»\n    say 42 ~~ Any:_;     # OUTPUT: «True␤»\n\n    # Checking a user-supplied class\n    class Foo {};\n    say Foo ~~ Any:D;    # OUTPUT: «False␤»\n    say Foo ~~ Any:U;    # OUTPUT: «True␤»\n    say Foo ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an instance of a class\n    my $f = Foo.new;\n    say $f  ~~ Any:D;    # OUTPUT: «True␤»\n    say $f  ~~ Any:U;    # OUTPUT: «False␤»\n    say $f  ~~ Any:_;    # OUTPUT: «True␤»\n\nThe Classes and Objects document further elaborates on the concepts of\ninstances and type objects and discovering them with the .DEFINITE method.\n\nKeep in mind all parameters have values; even optional ones have default\nvalues that are the type object of the constrained type for explicit type\nconstraints. If no explicit type constraint exists, the default value is an\nAny type object for methods, submethods, and subroutines, and a Mu type\nobject for blocks. This means that if you use the :D type smiley, you'd\nneed to provide a default value or make the parameter required. Otherwise,\nthe default value would be a type object, which would fail the definiteness\nconstraint.\n\n    sub divide (Int:D :$a = 2, Int:D :$b!) { say $a/$b }\n    divide :1a, :2b; # OUTPUT: «0.5␤»\n\nThe default value will kick in when that particular parameter, either\npositional or named, gets no value at all.\n\n    sub f($a = 42){\n      my $b is default('answer');\n      say $a;\n      $b = $a;\n      say $b\n    };\n    f;     # OUTPUT: «42␤42␤»\n    f Nil; # OUTPUT: «Nil␤answer␤»\n\n$a has 42 as its default value. With no value, $a will be assigned the\ndefault value declared in the Signature. However, in the second case, it\ndoes receive a value, which happens to be Nil. Assigning Nil to any\nvariable resets it to its default value, which has been declared as\n'answer' by use of the default trait. That explains what happens the second\ntime we call f. Routine parameters and variables deal differently with\ndefault value, which is in part clarified by the different way default\nvalues are declared in each case (using = for parameters, using the default\ntrait for variables).\n\nNote: in 6.c language, the default value of :U/:D constrained variables was\na type object with such a constraint, which is not initializable, thus you\ncannot use the .= operator, for example.\n\n    use v6.c;\n    my Int:D $x .= new: 42;\n    # OUTPUT: You cannot create an instance of this type (Int:D)\n    # in block <unit> at -e line 1\n\n\nIn the 6.d language, the default default is the type object without the\nsmiley constraint:\n\n    use v6.d;\n    my Int:D $x .= new: 42; # OUTPUT: «42␤»\n\n\nA closing remark on terminology: this section is about the use of the type\nsmileys :D and :U to constrain the definiteness of arguments. Occasionally\ndefinedness is used as a synonym for definiteness; this may be confusing,\nsince the terms have subtly different meanings.\n\nAs explained above, definiteness is concerned with the distinction between\ntype objects and object instances. A type object is always indefinite,\nwhile an object instance is always definite. Whether an object is a type\nobject/indefinite or an object instance/definite can be verified using the\nDEFINITE (meta)method.\n\nDefiniteness should be distinguished from definedness, which is concerned\nwith the difference between defined and undefined objects. Whether an\nobject is defined or undefined can be verified using the defined-method,\nwhich is implemented in class Mu. By default a type object is considered\nundefined, while an object instance is considered defined; that is:\n.defined returns False on a type object, and True otherwise. But this\ndefault behavior may be overridden by subclasses. An example of a subclass\nthat overrides the default .defined behavior is Failure, so that even an\ninstantiated Failure acts as an undefined value:\n\n    my $a = Failure;                # Initialize with type object\n    my $b = Failure.new(\"foo\");     # Initialize with object instance\n    say $a.DEFINITE;                # Output: «False␤» : indefinite type object\n    say $b.DEFINITE;                # Output: «True␤»  : definite object instance\n    say $a.defined;                 # Output: «False␤» : default response\n    say $b.defined;                 # Output: «False␤» : .defined override\n\n    Constraining signatures of Callables\n\nThe signature of a Callable parameter can be constrained by specifying a\nSignature literal right after the parameter (no whitespace allowed):\n\n    sub f(&c:(Int, Str))  { say c(10, 'ten') };\n    sub g(Int $i, Str $s) { $s ~ $i };\n    f(&g);\n    # OUTPUT: «ten10␤»\n\nThis shorthand syntax is available only for parameters with the & sigil.\nFor others, you need to use the long version:\n\n    sub f($c where .signature ~~ :(Int, Str))  { say $c(10, 'ten') }\n    sub g(Num $i, Str $s) { $s ~ $i }\n    sub h(Int $i, Str $s) { $s ~ $i }\n    # f(&g); # Constraint type check failed\n    f(&h);   # OUTPUT: «ten10␤»\n\n    Constraining return types\n\nThere are multiple ways to constrain return types on a Routine. All\nversions below are currently valid and will force a type check on\nsuccessful execution of a routine.\n\nNil and Failure are always allowed as return types, regardless of any type\nconstraint. This allows Failure to be returned and passed on down the call\nchain.\n\n    sub foo(--> Int) { Nil };\n    say foo.perl; # OUTPUT: «Nil␤»\n\nType captures are not supported.\n\n \n\n    Return type arrow: -->\n\nThis form of indicating return types (or constants) in the signature is\npreferred, since it can handle constant values while the others can't. For\nconsistency, it is the only form accepted on this site.\n\nThe return type arrow has to be placed at the end of the parameter list,\nwith or without a , before it.\n\n    sub greeting1(Str $name  --> Str) { say \"Hello, $name\" } # Valid\n    sub greeting2(Str $name, --> Str) { say \"Hello, $name\" } # Valid\n\n    sub favorite-number1(--> 42) {        } # OUTPUT: 42\n    sub favorite-number2(--> 42) { return } # OUTPUT: 42\n\n\nIf the type constraint is a constant expression, it is used as the return\nvalue of the routine. Any return statement in that routine has to be\nargumentless.\n\n    sub foo(Str $word --> 123) { say $word; return; }\n    my $value = foo(\"hello\"); # OUTPUT: hello\n    say $value;               # OUTPUT: 123\n\n\n    # The code below will not compile\n    sub foo(Str $word --> 123) { say $word; return $word; }\n    my $value = foo(\"hello\");\n    say $value;\n\n\n    returns\n\nThe keyword returns following a signature declaration has the same function\nas --> with the caveat that this form does not work with constant values.\nYou cannot use it in a block either. That is why the pointy arrow form is\nalways preferred.\n\n    sub greeting(Str $name) returns Str { say \"Hello, $name\" } # Valid\n\n\n    sub favorite-number returns 42 {        } # This will fail.\n\n\n    of\n\nof is just the real name of the returns keyword.\n\n    sub foo() of Int { 42 }; # Valid\n\n\n    sub foo() of 42 {  };    # This will fail.\n\n\n    prefix(C-like) form\n\nThis is similar to placing type constraints on variables like my Type $var\n= 20;, except the $var is a definition for a routine.\n\n    my Int sub bar { 1 };     # Valid\n\n\n    my 42 sub bad-answer {};  # This will fail.\n\n\n    Coercion type\n\nTo accept one type but coerce it automatically to another, use the accepted\ntype as an argument to the target type. If the accepted type is Any it can\nbe omitted.\n\n    sub f(Int(Str) $want-int, Str() $want-str) {\n        say $want-int.^name ~ ' ' ~ $want-str.^name\n    }\n    f '10', 10;\n    # OUTPUT: «Int Str␤»\n\n    use MONKEY;\n    augment class Str { method Date() { Date.new(self) } };\n    sub foo(Date(Str) $d) { say $d.^name; say $d };\n    foo \"2016-12-01\";\n    # OUTPUT: «Date␤2016-12-01␤»\n\nThe coercion is performed by calling the method with the name of the type\nto coerce to, if it exists (e.g. Foo(Bar) coercer, would call method Foo).\nThe method is assumed to return the correct type—no additional checks on\nthe result are currently performed.\n\nCoercion can also be performed on return types:\n\n    sub square-str (Int $x --> Str(Int)) {\n        $x²\n    }\n\n    for 2,4, *²  … 256 -> $a {\n        say $a, \"² is \", square-str( $a ).chars, \" figures long\";\n    }\n\n    # OUTPUT: «2² is 1 figures long␤\n    #          4² is 2 figures long␤\n    #          16² is 3 figures long␤\n    #          256² is 5 figures long␤»\n\n\nIn this example, coercing the return type to String allows us to directly\napply string methods, such as the number of characters.\n\n  \n\n  Slurpy (A.K.A. variadic) parameters\n\nA function is variadic if it can take a varying number of arguments; that\nis, its arity is not fixed. Therefore, optional, named, and slurpy\nparameters are variadic. An array or hash parameter can be marked as slurpy\nby leading single (*) or double asterisk (**) or a leading plus (+). A\nslurpy parameter can bind to an arbitrary number of arguments (zero or\nmore), and it will result in a type that is compatible with the sigil.\n\nThese are called \"slurpy\" because they slurp up any remaining arguments to\na function, like someone slurping up noodles.\n\n    $ = :($a, @b);  # exactly two arguments, where the second one must be Positional\n    $ = :($a, *@b); # at least one argument, @b slurps up any beyond that\n    $ = :(*%h);     # no positional arguments, but any number of named arguments\n\n    sub one-arg (@)  { }\n    sub slurpy  (*@) { }\n    one-arg (5, 6, 7); # ok, same as one-arg((5, 6, 7))\n    slurpy  (5, 6, 7); # ok\n    slurpy   5, 6, 7 ; # ok\n    # one-arg(5, 6, 7) ; # X::TypeCheck::Argument\n    # one-arg  5, 6, 7 ; # X::TypeCheck::Argument\n\n    sub named-names (*%named-args) { %named-args.keys };\n    say named-names :foo(42) :bar<baz>; # OUTPUT: «foo bar␤»\n\n\nPositional and named slurpies can be combined; named arguments (i.e.,\nPairs) are collected in the specified hash, positional arguments in the\narray:\n\n    sub combined-slurpy (*@a, *%h) { { array => @a, hash => %h } }\n    # or: sub combined-slurpy (*%h, *@a) { ... }\n\n    say combined-slurpy(one => 1, two => 2);\n    # OUTPUT: «{array => [], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4);\n    # OUTPUT: «{array => [3 4], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5);\n    # OUTPUT: «{array => [3 4], hash => {five => 5, one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5, 6);\n    # OUTPUT: «{array => [3 4 6], hash => {five => 5, one => 1, two => 2}}␤»\n\n\nNote that positional parameters aren't allowed after slurpy parameters:\n\n    :(*@args, $last);\n    # ===SORRY!=== Error while compiling:\n    # Cannot put required parameter $last after variadic parameters\n\n\nNormally a slurpy parameter will create an Array (or compatible type),\ncreate a new Scalar container for each argument, and assign the value from\neach argument to those Scalars. If the original argument also had an\nintermediary Scalar it is bypassed during this process, and is not\navailable inside the called function.\n\nSigiled parameters will always impose a context on the collected arguments.\nSigilless parameters can also be used slurpily, preceded by a + sign, to\nwork with whatever initial type they started with:\n\n    sub zipi( +zape ) {\n        zape.^name => zape\n    };\n    say zipi( \"Hey \"); # OUTPUT: «List => (Hey )␤»\n    say zipi( 1...* ); # OUTPUT: «Seq => (...)␤»\n\n\nSlurpy parameters have special behaviors when combined with some traits and\nmodifiers, as described in the section on slurpy array parameters.\n\n  Types of slurpy array parameters\n\nThere are three variations to slurpy array parameters.\n\n  * The single asterisk form flattens passed arguments.\n\n  * The double asterisk form does not flatten arguments.\n\n  * The plus form flattens according to the single argument rule.\n\nEach will be described in detail in the next few sections. As the\ndifference between each is a bit nuanced, examples are provided for each to\ndemonstrate how each slurpy convention varies from the others.\n\n    Flattened slurpy\n\nSlurpy parameters declared with one asterisk will flatten arguments by\ndissolving one or more layers of bare Iterables.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub a(*@a)  { @a.perl.say };\n    a(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]»\n    a(1, $list, [2, 3]);       # OUTPUT: «[1, \"d\", \"e\", \"f\", 2, 3]»\n    a([1, 2]);                 # OUTPUT: «[1, 2]»\n    a(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, 1, 2, 3, 4, 5]»\n    a(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]»\n\n\nA single asterisk slurpy flattens all given iterables, effectively hoisting\nany object created with commas up to the top level.\n\n    Unflattened slurpy\n\nSlurpy parameters declared with two stars do not flatten any Iterable\narguments within the list, but keep the arguments more or less as-is:\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub b(**@b) { @b.perl.say };\n    b(@array);                 # OUTPUT: «[[\"a\", \"b\", \"c\"],]␤»\n    b(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    b([1, 2]);                 # OUTPUT: «[[1, 2],]␤»\n    b(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    b(($_ for 1, 2, 3));       # OUTPUT: «[(1, 2, 3),]␤»\n\n\nThe double asterisk slurpy hides the nested comma objects and leaves them\nas-is in the slurpy array.\n\n    Single argument rule slurpy\n\nA slurpy parameter created using a plus engages the \"single argument rule\",\nwhich decides how to handle the slurpy argument based upon context.\nBasically, if only a single argument is passed and that argument is\nIterable, that argument is used to fill the slurpy parameter array. In any\nother case, +@ works like **@.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub c(+@b) { @b.perl.say };\n    c(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]␤»\n    c(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    c([1, 2]);                 # OUTPUT: «[1, 2]␤»\n    c(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    c(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]␤»\n\n\nFor additional discussion and examples, see Slurpy Conventions for\nFunctions.\n\n  Type captures\n\nType captures allow deferring the specification of a type constraint to the\ntime the function is called. They allow referring to a type both in the\nsignature and the function body.\n\n    sub f(::T $p1, T $p2, ::C){\n        # $p1 and $p2 are of the same type T, that we don't know yet\n        # C will hold a type we derive from a type object or value\n        my C $division = $p1 / $p2;\n        return sub (T $p1) {\n            $division * $p1;\n        }\n    }\n\n    # The first parameter is Int and so must be the 2nd.\n    # We derive the 3rd type from calling the operator that is used in &f.\n    my &s = f(10, 2, Int.new / Int.new);\n    say s(2); # 10 / 2 * 2 == 10\n\n \n\n  Positional vs. named arguments\n\nAn argument can be positional or named. By default, arguments are\npositional, except slurpy hash and arguments marked with a leading colon :.\nThe latter is called a colon-pair. Check the following signatures and what\nthey denote:\n\n    $ = :($a);               # a positional argument\n    $ = :(:$a);              # a named argument of name 'a'\n    $ = :(*@a);              # a slurpy positional argument\n    $ = :(*%h);              # a slurpy named argument\n\nOn the caller side, positional arguments are passed in the same order as\nthe arguments are declared.\n\n    sub pos($x, $y) { \"x=$x y=$y\" }\n    pos(4, 5);                          # OUTPUT: «x=4 y=5»\n\nIn the case of named arguments and parameters, only the name is used for\nmapping arguments to parameters. If a fat arrow is used to construct a Pair\nonly those with valid identifiers as keys are recognized as named\narguments.\n\n    sub named(:$x, :$y) { \"x=$x y=$y\" }\n    named( y => 5, x => 4);             # OUTPUT: «x=4 y=5»\n\n\nYou can invoke the routine using a variable with the same name as the named\nargument; in that case : will be used for the invocation so that the name\nof the variable is understood as the key of the argument.\n\n    sub named-shortcut( :$shortcut ) {\n        say \"Looks like $shortcut\"\n    }\n    named-shortcut( shortcut => \"to here\"); # OUTPUT: «Looks like to here␤»\n    my $shortcut = \"Þor is mighty\";\n    named-shortcut( :$shortcut );           # OUTPUT: «Looks like Þor is mighty␤»\n\nIt is possible to have a different name for a named argument than the\nvariable name:\n\n    sub named(:official($private)) { \"Official business!\" if $private }\n    named :official;\n\n  Argument aliases\n\nThe colon-pair syntax can be used to provide aliases for arguments:\n\n    sub alias-named(:color(:$colour), :type(:class($kind))) {\n        say $colour ~ \" \" ~ $kind\n    }\n    alias-named(color => \"red\", type => \"A\");    # both names can be used\n    alias-named(colour => \"green\", type => \"B\"); # more than two names are ok\n    alias-named(color => \"white\", class => \"C\"); # every alias is independent\n\nThe presence of the colon : will decide whether we are creating a new named\nargument or not. :$colour will not only be the name of the aliased\nvariable, but also a new named argument (used in the second invocation).\nHowever, $kind will just be the name of the aliased variable, that does not\ncreate a new named argument. More uses of aliases can be found in sub\nMAIN.\n\nA function with named arguments can be called dynamically, dereferencing a\nPair with | to turn it into a named argument.\n\n    multi f(:$named) { note &?ROUTINE.signature };\n    multi f(:$also-named) { note &?ROUTINE.signature };\n    for 'named', 'also-named' -> $n {\n        f(|($n => rand))                # OUTPUT: «(:$named)␤(:$also-named)␤»\n    }\n\n    my $pair = :named(1);\n    f |$pair;                           # OUTPUT: «(:$named)␤»\n\nThe same can be used to convert a Hash into named arguments.\n\n    sub f(:$also-named) { note &?ROUTINE.signature };\n    my %pairs = also-named => 4;\n    f |%pairs;                              # OUTPUT: «(:$also-named)␤»\n\nA Hash that contains a list may prove problematic when slipped into named\narguments. To avoid the extra layer of containers coerce to Map before\nslipping.\n\n    class C { has $.x; has $.y; has @.z };\n    my %h = <x y z> Z=> (5, 20, [1,2]);\n    say C.new(|%h.Map);\n    # OUTPUT: «C.new(x => 5, y => 20, z => [1, 2])␤»\n\nYou can create as many aliases to a named argument as you want:\n\n    sub alias-named(:color(:$colour),\n                    :variety(:style(:sort(:type(:class($kind)))))) {\n        return $colour ~ \" \" ~ $kind\n    }\n    say alias-named(color => \"red\", style => \"A\");\n    say alias-named(colour => \"green\", variety => \"B\");\n    say alias-named(color => \"white\", class => \"C\");\n\n\n  Optional and mandatory arguments\n\nPositional parameters are mandatory by default, and can be made optional\nwith a default value or a trailing question mark:\n\n    $ = :(Str $id);         # required parameter\n    $ = :($base = 10);      # optional parameter, default value 10\n    $ = :(Int $x?);         # optional parameter, default is the Int type object\n\n Named parameters are optional by default, and can be made mandatory with a\ntrailing exclamation mark:\n\n    $ = :(:%config);        # optional parameter\n    $ = :(:$debug = False); # optional parameter, defaults to False\n    $ = :(:$name!);         # mandatory 'name' named parameter\n\nDefault values can depend on previous parameters, and are (at least\nnotionally) computed anew for each call\n\n    $ = :($goal, $accuracy = $goal / 100);\n    $ = :(:$excludes = ['.', '..']);        # a new Array for every call\n\n  Dynamic variables\n\nDynamic variables are allowed in signatures although they don't provide\nspecial behavior because argument binding does connect two scopes anyway.\n\n  Destructuring arguments\n\nNon-scalar parameters can be followed or substituted by a sub-signature in\nparentheses, which will destructure the argument given. The destructuring\nof a list is just its elements:\n\n    sub first(@array ($first, *@rest)) { $first }\n\nor\n\n    sub first([$f, *@]) { $f }\n\nWhile the destructuring of a hash is its pairs:\n\n    sub all-dimensions(% (:length(:$x), :width(:$y), :depth(:$z))) {\n        $x andthen $y andthen $z andthen True\n    }\n\nPointy loops can also destructure hashes, allowing assignment to\nvariables:\n\n    my %hhgttu = (:40life, :41universe, :42everything);\n    for %hhgttu -> (:$key, :$value) {\n      say \"$key → $value\";\n    }\n    # OUTPUT: «universe → 41␤life → 40␤everything → 42␤»\n\nIn general, an object is destructured based on its attributes. A common\nidiom is to unpack a Pair's key and value in a for loop:\n\n    for <Peter Paul Merry>.pairs -> (:key($index), :value($guest)) { }\n\nHowever, this unpacking of objects as their attributes is only the default\nbehavior. To make an object get destructured differently, change its\nCapture method.\n\n  Sub-signatures\n\nTo match against a compound parameter use a sub-signature following the\nargument name in parentheses.\n\n    sub foo(|c(Int, Str)){\n       put \"called with {c.perl}\"\n    };\n    foo(42, \"answer\");\n    # OUTPUT: «called with \\(42, \"answer\")␤»\n\n  Long names\n\nTo exclude certain parameters from being considered in multiple dispatch,\nseparate them with a double semicolon.\n\n    multi sub f(Int $i, Str $s;; :$b) { say \"$i, $s, {$b.perl}\" };\n    f(10, 'answer');\n    # OUTPUT: «10, answer, Any␤»\n\n  Capture parameters\n\nPrefixing a parameter with a vertical bar | makes the parameter a Capture,\nusing up all the remaining positional and named arguments.\n\nThis is often used in proto definitions (like proto foo (|) {*}) to\nindicate that the routine's multi definitions can have any type\nconstraints. See proto for an example.\n\nIf bound to a variable arguments can be forwarded as a whole using the slip\noperator |.\n\n    sub a(Int $i, Str $s) { say $i.^name ~ ' ' ~ $s.^name }\n    sub b(|c) { say c.^name; a(|c) }\n    b(42, \"answer\");\n    # OUTPUT: «Capture␤Int Str␤»\n\n  Parameter traits and modifiers\n\nBy default, parameters are bound to their argument and marked as read-only.\nOne can change that with traits on the parameter.\n\n The is copy trait causes the argument to be copied, and allows it to be\nmodified inside the routine\n\n    sub count-up($x is copy) {\n        $x = ∞ if $x ~~ Whatever;\n        .say for 1..$x;\n    }\n\n The is rw trait, which stands for is read-write, makes the parameter bind\nto a variable (or other writable container). Assigning to the parameter\nchanges the value of the variable at the caller side.\n\n    sub swap($x is rw, $y is rw) {\n        ($x, $y) = ($y, $x);\n    }\n\nOn slurpy parameters, is rw is reserved for future use by language\ndesigners.\n\n The is raw trait is automatically applied to parameters declared with a\nbackslash as a \"sigil\", and may also be used to make normally sigiled\nparameters behave like these do. In the special case of slurpies, which\nnormally produce an Array full of Scalars as described above, is raw will\ninstead cause the parameter to produce a List. Each element of that list\nwill be bound directly as raw parameter.\n\n To explicitly ask for a read-only parameter use the is readonly trait.\nPlease note that this applies only to the container. The object inside can\nvery well have mutator methods and Perl 6 will not enforce immutability on\nthe attributes of the object.\n\nTraits can be followed by the where clause:\n\n    sub ip-expand-ipv6($ip is copy where m:i/^<[a..f\\d\\:]>**3..39$/) { }\n\n",
      "name": "Signature"
    },
    {
      "desc": "TITLE\nrole Numeric\n\nSUBTITLE\nNumber or object that can act as a number\n\n    role Numeric { ... }\n\nCommon role for numbers and types that can act as numbers.\n\nBinary numeric operations return an object of the \"wider\" type:\n\n    Int         narrowest\n    Rat\n    FatRat\n    Num\n    Complex     widest\n\n\nSo for example the product of a Rat and an Int is a Rat.\n\nUnary operations that in pure math usually return an irrational number\ngenerally return Num in Perl 6.\n\n",
      "name": "Numeric"
    },
    {
      "desc": "TITLE\nrole IO\n\nSUBTITLE\nInput/output related routines\n\nThe role provides no methods, but exists so that IO() coercers, which\ncoerce to IO::Path, correctly type-check the resultant value. The role is\nimplemented by IO::Path and IO::Special.\n\nSee also the related classes IO::Handle and IO::Path.",
      "name": "IO"
    },
    {
      "name": "Nil",
      "desc": "TITLE\nclass Nil\n\nSUBTITLE\nAbsence of a value or a benign failure\n\n    class Nil is Cool { }\n\nThe value Nil may be used to fill a spot where a value would normally go,\nand in so doing, explicitly indicate that no value is present. It may also\nbe used as a cheaper and less explosive alternative to a Failure. (In fact,\nclass Failure is derived from Nil, so smartmatching Nil will also match\nFailure.)\n\nThe class Nil is the same exact thing as its only possible value, Nil.\n\n    say Nil === Nil.new;        # OUTPUT: «True␤»\n\nAlong with Failure, Nil and its sub classes may always be returned from a\nroutine even when the routine specifies a particular return type. It may\nalso be returned regardless of the definedness of the return type, however,\nNil is considered undefined for all other purposes.\n\n    sub a( --> Int:D ) { return Nil }\n    a().say;                    # OUTPUT: «Nil␤»\n\nNil is what is returned from empty routines or closure, or routines that\nuse a bare return statement.\n\n    sub a { }; a().say;         # OUTPUT: «Nil␤»\n    sub b { return }; b().say;  # OUTPUT: «Nil␤»\n    say (if 1 { });             # OUTPUT: «Nil␤»\n    { ; }().say;                # OUTPUT: «Nil␤»\n    say EVAL \"\";                # OUTPUT: «Nil␤»\n\nIn a list, Nil takes the space of one value. Iterating a Nil behaves like\niteration of any non-iterable value, producing a sequence of one Nil. (When\nyou need the other meaning, the special value Empty is available to take no\nspaces when inserted into list, and to return no values when iterated.)\n\n    (1, Nil, 3).elems.say;      # OUTPUT: «3␤»\n    (for Nil { $_ }).perl.say;  # OUTPUT: «(Nil,)␤»\n\nAny method call on Nil of a method that does not exist, and consequently,\nany subscripting operation, will succeed and return Nil.\n\n    say Nil.ITotallyJustMadeThisUp;  # OUTPUT: «Nil␤»\n    say (Nil)[100];                  # OUTPUT: «Nil␤»\n    say (Nil){100};                  # OUTPUT: «Nil␤»\n\n When assigned to a container, the Nil value (but not any subclass of Nil)\nwill attempt to revert the container to its default value; if no such\ndefault is declared, Perl 6 assumes Any.\n\nSince a hash assignment expects two elements, use Empty not Nil, e.g.\n\n    my %h = 'a'..'b' Z=> 1..*;\n    # stuff happens\n    %h = Empty; # %h = Nil will generate an error\n\nHowever, if the container type is constrained with :D, assigning Nil to it\nwill immediately throw an exception. (In contrast, an instantiated Failure\nmatches :D because it's a definite value, but will fail to match the actual\nnominal type unless it happens to be a parent class of Failure.) Native\ntypes can not have default values nor hold a type object. Assigning Nil to\na native type container will fail with a runtime error.\n\n    my Int $x = 42;\n    $x = Nil;\n    $x.say;                     # OUTPUT: «(Int)␤»\n\n    sub f( --> Int:D ){ Nil };  # this definedness constraint is ignored\n    my Int:D $i = f;            # this definedness constraint is not ignored, so throws\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)»\n\n    sub g( --> Int:D ){ fail \"oops\" }; # this definedness constraint is ignored\n    my Any:D $h = g;                   # failure object matches Any:D, so is assigned\n\nbut\n\n    my Int:D $j = g;\n    # It will throw both exceptions:\n    # Earlier failure:\n    #  oops\n    #   in sub g at <unknown file> line 1\n    #   in block <unit> at <unknown file> line 1\n    #\n    # Final error:\n    #  Type check failed in assignment to $j; expected Int:D but got Failure (Failure.new(exception...)\n    #   in block <unit> at <unknown file> line 1\n\n\nBecause an untyped variable is type Any, assigning a Nil to one will result\nin an (Any) type object.\n\n    my $x = Nil;\n    $x.say;          # OUTPUT: «(Any)␤»\n    my Int $y = $x;  # will throw an exception\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)␤»\n\nIf you are looking for a variable which transforms objects into type\nobjects when said variable appears on the right-hand side, you can type the\ncontainer as Nil.\n\n    my Nil $x;\n    my Str $s = $x;\n    $s.say;          # OUTPUT: «(Str)␤»\n\nThere is an important exception to this transforms-into-type-object rule:\nassigning Nil to a variable which has a default will restore that default.\n\n    my Int $x is default(42) = -1;\n    my $y = 1;\n    for $x, $y -> $val is rw { $val = Nil unless $val > 0 }\n    $x.say;          # OUTPUT: «42␤»\n\n"
    },
    {
      "name": "Duration",
      "desc": "TITLE\nclass Duration\n\nSUBTITLE\nLength of time\n\n    class Duration is Cool does Real { }\n\nA Duration represents a length of time in atomic seconds, with fractions.\nLike an Instant, it is epoch-agnostic.\n\nDurations can be subtracted from or added to Instants to yield another, new\nInstant. Subtracting one Instant from another yields a Duration. A Duration\ncan also result from mathematical operations between two Durations when it\nmakes sense (namely, the addition, subtraction, or modulus of two\nDurations). It can also be added, subtracted or divided modulo Real\nnumbers.\n\nThe type of object returned for other numeric operations is currently\nunspecified."
    },
    {
      "desc": "TITLE\nrole Enumeration\n\nSUBTITLE\nWorking with the role behind the enum type\n\n    role Enumeration { }\n\nThis is the role implemented by the enum-pairs in the enum type. In\ngeneral, it is used to create constant sets, the elements of which become\nalso constant symbols in the current namespace and to establish a\nrelationship between the symbols belonging to the same set. In general, you\nwill find Enumeration in enum types:\n\n    enum norse-gods <Þor Oðin Loki>;\n    my $one-of-them = norse-gods.pick;\n    say $one-of-them ~~ Enumeration; # OUTPUT: «True␤»\n\nbut nothing prevents you from using it in your own programs if you want to\nrestrict somehow the relationship between the key and the value:\n\n    class DNA does Enumeration {\n        my %pairings = %( A => \"T\",\n                          T => \"A\",\n                          C => \"G\",\n                          G => \"C\" );\n\n        method new( $base-pair where \"A\" | \"C\" | \"G\" | \"T\" )  {\n            self.bless( key => $base-pair,\n                        value => %pairings{$base-pair});\n        }\n\n        multi method gist(::?CLASS:D:) {\n            return \"$!key → $!value\";\n        }\n\n    }\n\n    enum Chain ();\n    constant length = 16;\n    for <A C G T>.roll( length ) -> $letter {\n        my DNA $base = DNA.new( $letter );\n        Chain.HOW.add_enum_value( Chain, $base );\n    }\n\n    for ^length {\n        my $base = Chain.pick;\n        say \"{$base.key} and {$base.value}\";\n    }\n\n\nIn this code, DNA consumes the Enumeration role, which is from this point\nof view a pair of key and value; we can use the generated DNA objects to\ncompose an enum type from which elements can be picked one by one, with the\noutput shown below.\n\n    T and A\n    C and G\n    T and A\n    # and so on...\n\n\n",
      "name": "Enumeration"
    },
    {
      "name": "Label",
      "desc": "TITLE\nclass Label\n\nSUBTITLE\nTagged location in the source code\n\n    class Label {}\n\nLabels are used in Perl 6 to tag loops so that you can specify the one you\nwant to jump to with statements such as last. You can use it to jump out of\nloops and get to outer ones, instead of just exiting the current loop or\ngoing to the statement before.\n\n    USERS:          # the label\n    for @users -> $u {\n        for $u.pets -> $pet {\n            # usage of a label\n            next USERS if $pet.barks;\n        }\n        say \"None of {$u}'s pets barks\";\n    }\n    say USERS.^name;        # OUTPUT: «Label␤»\n\n\nThose label are objects of type Label, as shown in the last statement.\nLabels can be used in any loop construct, as long as they appear right\nbefore the loop statement.\n\n    my $x = 0;\n    my $y = 0;\n    my $t = '';\n    A: while $x++ < 2 {\n        $t ~= \"A$x\";\n        B: while $y++ < 2 {\n            $t ~= \"B$y\";\n            redo A if $y++ == 1;\n            last A\n        }\n    }\n    say $t; # OUTPUT: «A1B1A1A2»\n\n\nPutting them on the line before the loop or the same line is optional.\nLabels must follow the syntax of ordinary identifiers, although\ntraditionally we will use the latin alphabet in uppercase so that they\nstand out in the source. You can use, however, other alphabets like here:\n\n    駱駝道: while True {\n      say 駱駝道.name;\n      last 駱駝道;\n    }\n\n"
    },
    {
      "name": "VM",
      "desc": "TITLE\nclass VM\n\nSUBTITLE\nPerl 6 Virtual Machine related information\n\n    class VM does Systemic { }\n\nBuilt-in class for providing information about the virtual machine in which\nPerl 6 is running. Usually accessed through the $*VM dynamic variable.\n\n"
    },
    {
      "desc": "TITLE\nclass ThreadPoolScheduler\n\nSUBTITLE\nScheduler that distributes work among a pool of threads\n\n    class ThreadPoolScheduler does Scheduler {}\n\n\nThe ThreadPoolScheduler has a range of number of threads that it maintains,\nand it distributes work among those threads. When the upper limit of\nthreads isn't reached yet, and there is work pending, it spawns new threads\nto handle the work.\n\n",
      "name": "ThreadPoolScheduler"
    },
    {
      "desc": "TITLE\nclass Any\n\nSUBTITLE\nThing/object\n\n    class Any is Mu {}\n\nWhile Mu is the root of the Perl 6 class hierarchy, Any is the class that\nserves as a default base class for new classes, and as the base class for\nmost built-in classes.\n\nSince Perl 6 intentionally confuses items and single-element lists, most\nmethods in Any are also present on class List, and coerce to List or a\nlist-like type.\n\n",
      "name": "Any"
    },
    {
      "desc": "TITLE\nclass Macro\n\nSUBTITLE\nCompile-time routine\n\n    class Macro is Routine { }\n\nA macro is a Routine whose invocation typically happens during parsing. By\nreturning an AST, a macro can inject code into the calling location.",
      "name": "Macro"
    },
    {
      "name": "Stash",
      "desc": "TITLE\nclass Stash\n\nSUBTITLE\nTable for \"our\"-scoped symbols\n\n    class Stash is Hash { }\n\nA Stash is a hash that is used for symbol tables at the package scoping\nlevel in Perl 6.\n\nTo get a Stash, you can call the .WHO pseudo-method on a package (because\nit answers the question who lives here?), or if you write the package name\nas a literal, append two colons:\n\n    class Boring {\n        class Nested { };\n        our sub package_sub { }\n        my sub lexical { };\n        method a_method() { }\n    }\n    say Boring::.^name;             # OUTPUT: «Stash␤»\n    say Boring.WHO === Boring::;    # OUTPUT: «True␤»\n\nSince it inherits from Hash, you can use all the usual hash functionality:\n\n    say Boring::.keys.sort;         # OUTPUT: «(&package_sub Nested)␤»\n    say Boring::<Nested>;           # OUTPUT: «(Nested)␤»\n\n\nAs the example above shows only \"our\"-scoped things appear in the Stash\n(nested classes are \"our\" by default, but can be excluded with \"my\".)\nLexicals and methods are not included in a Stash, since they do not live in\nthe package table. Lexicals live in a separate lexical pad, which is only\nvisible from inside the scope. "
    },
    {
      "desc": "TITLE\nclass Kernel\n\nSUBTITLE\nKernel related information\n\n    class Kernel does Systemic { }\n\nBuilt-in class for providing kernel related information. Usually accessed\nthrough the $*KERNEL dynamic variable.\n\n",
      "name": "Kernel"
    },
    {
      "name": "Promise",
      "desc": "TITLE\nclass Promise\n\nSUBTITLE\nStatus/result of an asynchronous computation\n\n    my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));\n    class Promise {}\n\nA Promise is used to handle the result of a computation that might not have\nfinished. It allows the user to execute code once the computation is done\n(with the then method), execution after a time delay (with in), combining\npromises, and waiting for results.\n\n    my $p = Promise.start({ sleep 2; 42});\n    $p.then({ say .result });   # will print 42 once the block finished\n    say $p.status;              # OUTPUT: «Planned␤»\n    $p.result;                  # waits for the computation to finish\n    say $p.status;              # OUTPUT: «Kept␤»\n\nThere are two typical scenarios for using promises. The first is to use a\nfactory method (start, in, at, anyof, allof, kept, broken) on the type\nobject; those will make sure that the promise is automatically kept or\nbroken for you, and you can't call break or keep on these promises\nyourself.\n\nThe second is to create your promises yourself with Promise.new. If you\nwant to ensure that only your code can keep or break the promise, you can\nuse the vow method to get a unique handle, and call keep or break on it:\n\n    sub async-get-with-promise($user-agent, $url) {\n        my $p = Promise.new;\n        my $v = $p.vow;\n\n        # do an asynchronous call on a fictive user agent,\n        # and return the promise:\n        $user-agent.async-get($url,\n                on-error => -> $error {\n                    $v.break($error);\n                },\n                on-success => -> $response {\n                    $v.keep($response);\n                }\n        );\n        return $p;\n    }\n\n\nFurther examples can be found in the concurrency page.\n\n"
    },
    {
      "name": "Mix",
      "desc": "TITLE\nclass Mix\n\nSUBTITLE\nImmutable collection of distinct objects with Real weights\n\n    class Mix does Mixy { }\n\nA Mix is an immutable collection of distinct elements in no particular\norder that each have a real-number weight assigned to them. (For mutable\nmixes, see MixHash instead.)\n\nMixes are often used for performing weighted random selections - see\n.roll.\n\nObjects/values of any type are allowed as mix elements. Within a Mix, items\nthat would compare positively with the === operator are considered the same\nelement, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixes can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the corresponding numeric weight for keys that are elements\nof the mix, and 0 for keys that aren't:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\nCreating Mix objects\n\nMixes can be composed using the mix subroutine (or Mix.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the mix - with a weight of 1 for each time the parameter\noccurred:\n\n    my $n = mix \"a\", \"a\", \"b\" => 0, 3.14, π, π; # The Pair is a single element\n    say $n.keys.map: *.^name; # OUTPUT: «(Rat Pair Num Str)␤»\n    say $n.pairs;\n    # OUTPUT: «(3.14 => 1 (b => 0) => 1 3.141592653589793 => 2 a => 2)␤»\n\nAlternatively, the .Mix coercer (or its functional form, Mix()) can be\ncalled on an existing object to coerce it to a Mix. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a mix with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the mix, and the (cumulative) values become the associated numeric\nweights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).Mix;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nElements with a 0 value, as b above, are simply eliminated from the Mix.\n\nAlternatively, since Mixes are Associative, we can use the % sigil to\ndeclare them; in that case, we can employ is to declare their type:\n\n    my %n is Mix = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14);\n    say %n.^name; # OUTPUT: «Mix␤»\n    say %n;       # OUTPUT: «Mix(a(2), c(3.14))␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a Mix. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = Mix[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %m is Mix[Str] = <a b b c c c>;\n    say %m<b>;  # 2\n    say %m<d>;  # 0\n\n    # only allow whole numbers\n    my %m is Mix[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nMixes can use all kind of set operators returning either Bool or other\nMixes:\n\n    my $this-mix = (sugar => ⅓, spice => ¼, all-things-nice => ¾);\n    my $that-mix = ( sugar => 1, spice => 2);\n\n    say $that-mix (<) $this-mix;     # OUTPUT: «True␤»\n    say $that-mix (^) $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix (+) $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nWith their equivalent Unicode operators:\n\n    say $that-mix ⊂ $this-mix;     # OUTPUT: «True␤»\n    say $that-mix ⊖ $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix ⊎ $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\n  sub mix\n\n    sub mix(*@args --> Mix)\n\nCreates a new Mix from @args.\n\n"
    },
    {
      "name": "Version",
      "desc": "TITLE\nclass Version\n\nSUBTITLE\nModule version descriptor\n\n    class Version { }\n\nVersion objects identify version of software components (and potentially\nother entities). Perl 6 uses them internally for versioning modules.\n\nA version consists of several parts, which are visually represented by\njoining them with a dot. A version part is usually an integer, a string\nlike alpha, or a Whatever-star *. The latter is used to indicate that any\nversion part is acceptable in another version that is compared to the\ncurrent one.\n\n    say v1.0.1 ~~ v1.*;     # OUTPUT: «True␤»\n    say v1.0.1 ~~ v1.*.1;   # OUTPUT: «True␤»\n\nThe first part of version literals contains v and a number; this might be\nfollowed by alphanumeric and Whatever parts and trailed by +. Multiple\nparts are separate with a dot .. A trailing + indicates that higher\nversions are OK in comparisons:\n\n    say v1.2 ~~ v1.0;                 # OUTPUT: «False␤»\n    say v1.2 ~~ v1.0+;                # OUTPUT: «True␤»\n    say v0.and.anything.else ~~ v0+;  # OUTPUT: «True␤»\n\nIn comparisons, order matters, and every part is compared in turn.\n\n    say v1.2 cmp v2.1;      # OUTPUT: «Less␤»\n\nThe + suffix is always taken into account in comparisons:\n\n    say v1.0.1+ <=> v1.0.1; # OUTPUT: «More␤»\n\nAnd * (Whatever) is too, and considered always Less than whatever digit is\nin the corresponding part, even if * is trailed by +:\n\n    say v1.* <=> v1.0;      # OUTPUT: «Less␤»\n    say v1.* <= v1.0;       # OUTPUT: «True␤»\n    say v1.*+ <= v1.0;      # OUTPUT: «True␤»\n\nPlease note that method calls, including pseudo methods like WHAT, require\nversion literals either to be enclosed with parentheses or use some other\nmethod to separate them from the dot that denotes a method call, like in\nthese examples:\n\n    say (v0.and.some.*.stuff).parts;  # OUTPUT: «(0 and some * stuff)␤»\n    say v0.and.some.*.stuff .parts;   # OUTPUT: «(0 and some * stuff)␤»\n\n"
    },
    {
      "desc": "TITLE\nclass Sequence\n\nSUBTITLE\nOperations for higher-level sequences\n\n    class Sequence does PositionalBindFailover { }\n\nA Sequence implements a series of methods for converting hight-level Seqs\ninto different types of objects, from positional to other.\n\n",
      "name": "Sequence"
    },
    {
      "desc": "TITLE\nclass Rat\n\nSUBTITLE\nRational number (limited-precision)\n\n    class Rat is Cool does Rational[Int, uint64] { }\n\nRat objects store rational numbers as a pair of a numerator and\ndenominator. Number literals with a dot but without exponent produce Rats.\n\n    say 3.1;          # OUTPUT: «3.1␤»      (same as: Rat.new(31, 10))\n    say 3.1.^name;    # OUTPUT: «Rat␤»\n    say 3.1.nude;     # OUTPUT: «(31 10)␤»\n\n    say <1/2>;        # OUTPUT: «0.5␤»      (same as: Rat.new(1, 2))\n    say <1/2>.^name;  # OUTPUT: «Rat␤»\n    say <1/2>.nude;   # OUTPUT: «(1 2)␤»\n\nThus arithmetic with short dotted-decimal numbers does not suffer from\nfloating point errors.\n\nTo prevent the numerator and denominator from becoming pathologically\nlarge, the denominator is limited to 64 bit storage. On overflow of the\ndenominator a Num (floating-point number) is returned instead.\n\nFor example this function crudely approximates a square root, and overflows\nthe denominator quickly:\n\n    sub approx-sqrt($n, $iterations) {\n        my $x = $n;\n        $x = ($x + $n / $x) / 2 for ^$iterations;\n        return $x;\n    }\n    say approx-sqrt(2, 5).^name;     # OUTPUT: «Rat␤»\n    say approx-sqrt(2, 10).^name;    # OUTPUT: «Num␤»\n\nIf you want arbitrary precision arithmetic with rational numbers, use the\nFatRat type instead.\n\nRat objects are immutable.\n\n",
      "name": "Rat"
    },
    {
      "name": "Scheduler",
      "desc": "TITLE\nrole Scheduler\n\nSUBTITLE\nScheme for automatically assigning tasks to threads\n\n    role Scheduler {\n        has &.uncaught_handler is rw\n    }\n\nCommon role for schedulers. A scheduler is a piece of code that determines\nwhich resources to use to run which task, and when.\n\nSome operations for example on Proc::Async, Promise, Supply allow you to\nspecify a scheduler explicitly; they generally expect those schedulers to\nfollow the interface defined by Scheduler\n\n"
    },
    {
      "name": "Submethod",
      "desc": "TITLE\nclass Submethod\n\nSUBTITLE\nMember function that is not inherited by subclasses\n\n    class Submethod is Routine {}\n\nA Submethod is a method that is not inherited by child classes. They are\ntypically used for per-class initialization and tear-down tasks which are\ncalled explicitly per class in an inheritance tree, usually for enforcing a\nparticular order. For example object construction with the BUILD submethod\nhappens from the least-derived to most-derived, so that the most-derived\n(child) classes can depend on the parent already being initialized.\n\nSubmethods are of type Submethod, and are declared with the submethod\ndeclarator:\n\n    class Area {\n        has $.size;\n        submethod BUILD(:$x, :$y, :$z) {\n            $!size = $x * $y * $z;\n        }\n    }\n\n"
    },
    {
      "name": "RaceSeq",
      "desc": "TITLE\nclass RaceSeq\n\nSUBTITLE\nPerforms batches of work in parallel without respecting original order.\n\n    class RaceSeq does Iterable does Sequence { }\n\nAn RaceSeq is the intermediate object used when the operator race is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n"
    },
    {
      "desc": "TITLE\nclass RatStr\n\nSUBTITLE\nDual value rational number and string\n\n    class RatStr is Rat is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1>; say $f.^name; # OUTPUT: «RatStr␤»\n\nAs a subclass of both Rat and Str, a RatStr will be accepted where either\nis expected. However, RatStr does not share object identity with Rat- or\nStr-only variants:\n\n    my $rat-str = <42.1>;\n    my Rat $rat = $rat-str; # OK!\n    my Str $str = $rat-str; # OK!\n    say 42.1 ∈ <42.1  55  1>; # False; ∈ operator cares about object identity\n\n",
      "name": "RatStr"
    },
    {
      "desc": "TITLE\nclass Range\n\nSUBTITLE\nInterval of ordered values\n\n    class Range is Cool does Iterable does Positional {}\n\nRanges serve two main purposes: to generate lists of consecutive numbers or\nstrings, and to act as a matcher to check if a number or string is within a\ncertain range.\n\nRanges are constructed using one of the four possible range operators,\nwhich consist of two dots, and optionally a caret which indicates that the\nendpoint marked with it is excluded from the range.\n\n    1 .. 5;  # 1 <= $x <= 5\n    1^.. 5;  # 1 <  $x <= 5\n    1 ..^5;  # 1 <= $x <  5\n    1^..^5;  # 1 <  $x <  5\n\nThe caret is also a prefix operator for constructing numeric ranges\nstarting from zero:\n\n    my $x = 10;\n    say ^$x;     # same as 0 ..^ $x.Numeric\n\nIterating a range (or calling the list method) uses the same semantics as\nthe ++ prefix and postfix operators, i.e., it calls the succ method on the\nstart point, and then the generated elements.\n\nRanges always go from small to larger elements; if the start point is\nbigger than the end point, the range is considered empty.\n\n    for 1..5 { .say };       # OUTPUT: «1␤2␤3␤4␤5␤»\n    ('a' ^..^ 'f').list;     # RESULT: «'b', 'c', 'd', 'e'»\n    5 ~~ ^5;                 # RESULT: «False»\n    4.5 ~~ 0..^5;            # RESULT: «True»\n    (1.1..5).list;           # RESULT: «(1.1, 2.1, 3.1, 4.1)»\n\nUse the ... sequence operator to produce lists of elements that go from\nlarger to smaller values, or to use offsets other than increment-by-1 and\nother complex cases.\n\nUse ∞ or * (Whatever) to indicate an end point to be open-ended.\n\n    for 1..* { .say };       # start from 1, continue until stopped\n    for 1..∞ { .say };       # the same\n\n\nBeware that a WhateverCode end point, instead of a plain Whatever, will go\nthrough the range operator and create another WhateverCode which returns a\nRange:\n\n    # A Whatever produces the 1..Inf range\n    say (1..*).^name;        # OUTPUT: «Range␤»\n    say (1..*);              # OUTPUT: «1..Inf␤»\n    # Upper end point is now a WhateverCode\n    say (1..*+20).^name;     # OUTPUT: «{ ... }␤»\n    say (1..*+20).WHAT;      # OUTPUT: «(WhateverCode)␤»\n    say (1..*+20).(22);      # OUTPUT: «1..42␤»\n\n\nRanges implement Positional interface, so its elements can be accessed\nusing an index. In a case when the index given is bigger than the Range\nobject's size, Nil object will be returned. The access works for lazy Range\nobjects as well.\n\n    say (1..5)[1];  # OUTPUT: «2␤»\n    say (1..5)[10]; # OUTPUT: «Nil␤»\n    say (1..*)[10]; # OUTPUT: «11␤»\n\n\n  Ranges in subscripts\n\nA Range can be used in a subscript to get a range of values. Please note\nthat assigning a Range to a scalar container turns the Range into an item.\nUse binding, @-sigiled containers or a slip to get what you mean.\n\n    my @numbers =  <4 8 15 16 23 42>;\n    my $range := 0..2;\n    .say for @numbers[$range]; # OUTPUT: «4␤8␤15␤»\n    my @range = 0..2;\n    .say for @numbers[@range]; # OUTPUT: «4␤8␤15␤»\n\n  Shifting and scaling intervals\n\nIt is possible to shift or scale the interval of a range:\n\n    say (1..10) + 1;       # OUTPUT: «2..11␤»\n    say (1..10) - 1;       # OUTPUT: «0..9␤»\n    say (1..10) * 2;       # OUTPUT: «2..20␤»\n    say (1..10) / 2;       # OUTPUT: «0.5..5.0␤»\n\n  Matching against Ranges\n\nYou can use smartmatch to match against Ranges.\n\n    say 3 ~~ 1..12;          # OUTPUT: «True␤»\n    say 2..3 ~~ 1..12;       # OUTPUT: «True␤»\n\n In Rakudo only, you can use the in-range method for matching against a\nrange, which in fact is equivalent to smartmatch except it will throw an\nexception when out of range, instead of returning False:\n\n    say ('א'..'ת').in-range('ע');  # OUTPUT: «True␤»\n\nHowever, if it is not included in the range:\n\n    say ('א'..'ת').in-range('p', \"Letter 'p'\");\n    # OUTPUT: «(exit code 1) Letter 'p' out of range. Is: \"p\", should be in \"א\"..\"ת\"␤\n\n\nThe second parameter to in-range is the optional message that will be\nprinted with the exception. It will print Value by default.\n\n",
      "name": "Range"
    },
    {
      "name": "Tap",
      "desc": "TITLE\nclass Tap\n\nSUBTITLE\nSubscription to a Supply\n\n    class Tap {}\n\nA Tap is a subscription to a Supply.\n\n    my $s = Supplier.new;\n    my $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n        -> $v { say \"the value is $v\" },\n        done    => { say \"Supply is done\" },\n        quit    => -> $ex { say \"Supply finished with error $ex\" },\n    );\n\n    # later\n    $tap.close;\n\n"
    },
    {
      "name": "PositionalBindFailover",
      "desc": "TITLE\nrole PositionalBindFailover\n\nSUBTITLE\nFailover for binding to a Positional\n\n    role PositionalBindFailover { ... }\n\nThis role provides an interface by which an object can be coerced into a\nPositional when binding to Positional parameters.\n\nFor example, Seq type is not Positional, but you can still write the\nfollowing, because it does PositionalBindFailover role:\n\n    sub fifths(@a) {        # @a is constraint to Positional\n        @a[4];\n    }\n    my $seq := gather {     # a Seq, which is not Positional\n        take $_ for 1..*;\n    }\n    say fifths($seq);       # OUTPUT: «5␤»\n\nThe invocation of fifths in the example above would ordinarily give a type\nerror, because $seq is of type Seq, which doesn't do the Positional\ninterface that the @-sigil implies.\n\nBut the signature binder recognizes that Seq does the\nPositionalBindFailover role, and calls its cache method to coerce it to a\nList, which does the Positional role.\n\nThe same happens with custom classes that do the role; they simply need to\nprovide an iterator method that produces an Iterator:\n\n    class Foo does PositionalBindFailover {\n        method iterator {\n            class :: does Iterator {\n                method pull-one {\n                    return 42 unless $++;\n                    IterationEnd\n                }\n            }.new\n        }\n    }\n\n    sub first-five (@a) { @a[^5].say }\n    first-five Foo.new; # OUTPUT: # OUTPUT: «(42 Nil Nil Nil Nil)␤»\n\n"
    },
    {
      "desc": "TITLE\nclass SetHash\n\nSUBTITLE\nMutable collection of distinct objects\n\n    class SetHash does Setty { }\n\nA SetHash is a mutable set, meaning a collection of distinct elements in no\nparticular order. (For immutable sets, see Set instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSetHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the value True for keys that are elements of the\nset, and False for keys that aren't. Assigning a value that boolifies to\nTrue or False, respectively, can be used to add or remove a set element:\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits<apple>;     # OUTPUT: «True␤»\n    say $fruits<kiwi>;      # OUTPUT: «False␤»\n\n    $fruits<apple kiwi> = False, True;\n    say $fruits.keys.sort;  # OUTPUT: «kiwi orange peach␤»\n\n\nHere is a convenient shorthand idiom for adding and removing SetHash\nelements:\n\n    my SetHash $fruits .= new;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<cherry>++;\n    say $fruits<cherry>;      # OUTPUT: «True␤»\n    $fruits<apple banana kiwi>»++; # Add multiple elements\n\n    $fruits<cherry>--;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<banana kiwi>»--; # Remove multiple elements\n\n\n\nCreating SetHash objects\n\nSetHashes can be composed using SetHash.new. Any positional parameters,\nregardless of their type, become elements of the set:\n\n    my $n = SetHash.new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .SetHash coercer (or its functional form, SetHash()) can\nbe called on an existing object to coerce it to a SetHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a set with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the set - and keys mapped to values which boolify to\nFalse are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).SetHash;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nIt is also possible to initialize a single key with the use of {}:\n\n    my $sh = SetHash.new;\n    $sh{ 'key1' } = True;\n    $sh{ 'key2' } = 'Hello World!';\n    $sh{ 'key3' } = 0;  # does not store the key since 0.Bool is False\n    say $sh;            # OUTPUT: «SetHash(key1 key2)␤»\n    say $sh.keys.perl;  # OUTPUT: «(\"key1\", \"key2\").Seq␤»\n\nor, in order to initialize more than one key at the same time, use a list\nassignment:\n\n    my $sh = SetHash.new;\n    $sh{ 'a', 'b', 'c' } = True, False, True;\n    say $sh.keys.perl;  # OUTPUT: «(\"a\", \"c\").Seq␤»\n\nYou can also create SetHash masquerading as a hash by using the is trait:\n\n    my %sh is SetHash = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a SetHash. This can either be done when\ncalling .new:\n\n    # only allow Pairs\n    my $n = SetHash[Pair].new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %sh is SetHash[Str] = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\n    # only allow whole numbers\n    my %sh is SetHash[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nPerl 6 provides common set operators, which can take SetHashes (or any\nother collections) as input, although result sets are returned as immutable\nSets. For example:\n\n    my ($a, $b) = SetHash.new(1, 2, 3), SetHash.new(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a (|) $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a ∪ $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSee Also\n\nSets, Bags, and Mixes",
      "name": "SetHash"
    },
    {
      "name": "HyperSeq",
      "desc": "TITLE\nclass HyperSeq\n\nSUBTITLE\nAn object for performing batches of work in parallel with ordered output\n\n    class HyperSeq does Iterable does Sequence { }\n\nAn HyperSeq is the intermediate object used when the operator hyper is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n"
    },
    {
      "desc": "TITLE\nclass Distro\n\nSUBTITLE\nDistribution related information\n\n    class Distro does Systemic { }\n\nBuilt-in class for providing distribution related information. Usually\naccessed through the $*DISTRO dynamic variable.\n\n",
      "name": "Distro"
    },
    {
      "name": "NumStr",
      "desc": "TITLE\nclass NumStr\n\nSUBTITLE\nDual value floating-point number and string\n\n    class NumStr is Num is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1e0>; say $f.^name; # OUTPUT: «NumStr␤»\n\nAs a subclass of both Num and Str, a NumStr will be accepted where either\nis expected. However, NumStr does not share object identity with Num- or\nStr-only variants:\n\n    my $num-str = <42e10>;\n    my Num $num = $num-str; # OK!\n    my Str $str = $num-str; # OK!\n    say 42e10 ∈ <42e10  55  1>; # False; ∈ operator cares about object identity\n\n"
    },
    {
      "name": "Rational",
      "desc": "TITLE\nrole Rational\n\nSUBTITLE\nNumber stored as numerator and denominator\n\n    role Rational[::NuT, ::DeT] does Real { ... }\n\nRational is the common role for numbers that are stored as pairs of\nnumerator and denominator. It is parameterized by the types of the\nnumerator (NuT) and denominator (DeT). By default, these are Int, but other\ntypes of Rational are possible by using a different parameterization. In\naddition, Rational objects are immutable throughout their life.\n\n    class Positive does Rational[UInt] {};\n    my Positive $one-third = Positive.new(1,3);\n    say $one-third;                         # OUTPUT: «0.333333␤»\n    my Positive $fail =Positive.new(-2,3);  # OUTPUT: «Type check failed in binding to parameter 'nu'; expected UInt but got Int (-2)␤»\n\nPlease note that, since DeT is by default equal to NuT, in this case both\nare instantiated to UInt. Built into Perl 6 are Rat and FatRat, which both\ndo the Rational role.\n\n"
    },
    {
      "desc": "TITLE\nclass Proc\n\nSUBTITLE\nRunning process (filehandle-based interface)\n\n    class Proc {}\n\nProc is a representation of an invocation of an external process. It\nprovides access to the input, output and error stream as well as the exit\ncode. It is typically created through the run subroutine:\n\n    my $proc = run 'echo', 'Hallo world', :out;\n    my $captured-output = $proc.out.slurp: :close;\n    say \"Output was $captured-output.perl()\";# OUTPUT: «Output was \"Hallo world\\n\"␤»\n\n\nPiping several commands is easy too. To achieve the equivalent of the pipe\necho \"Hello, world\" | cat -n in Perl 6, and capture the output from the\nsecond command, you can do\n\n    my $p1 = run 'echo', 'Hello, world', :out;\n    my $p2 = run 'cat', '-n', :in($p1.out), :out;\n    say $p2.out.get;\n\n\nYou can also feed the :in (standard input) pipe directly from your program,\nby setting it to True, which will make the pipe available via .in method on\nthe Proc:\n\n    my $p = run \"cat\", \"-n\", :in, :out;\n    $p.in.say: \"Hello,\\nworld!\";\n    $p.in.close;\n    say $p.out.slurp: :close;\n    # OUTPUT: «1  Hello,␤\n    #          2  world!␤»\n\n\nIn order to capture the standard error, :err can be supplied:\n\n    my $p = run \"ls\", \"-l\", \".\", \"qqrq\", :out, :err;\n    my $captured-output = $p.out.slurp: :close;\n    my $captured-error  = $p.err.slurp: :close;\n    my $exit-code       = $p.exitcode;\n\n\nIn sink context, a Proc will call its sink method, throwing an exception if\nthe process has exited with an exit code different from zero:\n\n    shell 'exit 1'\n    # OUTPUT: «(exit code 1) The spawned command 'exit 1' exited unsuccessfully (exit code: 1)␤»\n\n\nNote: Versions of Rakudo older than 2017.04 do not have .slurp available on\nIO::Pipe objects; use .slurp-rest instead.\n\nUse Proc::Async for non-blocking operations.\n\n",
      "name": "Proc"
    },
    {
      "name": "Uni",
      "desc": "TITLE\nclass Uni\n\nSUBTITLE\nA string of Unicode codepoints\n\n    class Uni does Positional[uint32] does Stringy { }\n\nUnlike Str, which is made of Grapheme clusters, Uni is string strictly made\nof Unicode codepoints. That is, base characters and combining characters\nare separate elements of a Uni instance.\n\nUni presents itself with a list-like interface of integer Codepoints.\n\nTypical usage of Uni is through one of its subclasses, NFC, NFD, NFKD and\nNFKC, which represent strings in one of the Unicode Normalization Forms of\nthe same name.\n\n"
    },
    {
      "desc": "TITLE\nclass Lock\n\nSUBTITLE\nA low-level, re-entrant, mutual exclusion lock\n\n    class Lock {}\n\nA Lock is a low-level concurrency control construct. It provides mutual\nexclusion, meaning that only one thread may hold the lock at a time. Once\nthe lock is unlocked, another thread may then lock it.\n\nA Lock is typically used to protect access to one or more pieces of state.\nFor example, in this program:\n\n    my $x = 0;\n    my $l = Lock.new;\n    await (^10).map: {\n        start {\n            $l.protect({ $x++ });\n        }\n    }\n    say $x;         # OUTPUT: «10␤»\n\nThe Lock is used to protect operations on $x. An increment is not an atomic\noperation; without the lock, it would be possible for two threads to both\nread the number 5 and then both store back the number 6, thus losing an\nupdate. With the use of the Lock, only one thread may be running the\nincrement at a time.\n\nA Lock is re-entrant, meaning that a thread that holds the lock can lock it\nagain without blocking. That thread must unlock the same number of times\nbefore the lock can be obtained by another thread (it works by keeping a\nrecursion count).\n\nIt's important to understand that there is no direct connection between a\nLock and any particular piece of data; it is up to the programmer to ensure\nthat the Lock is held during all operations that involve the data in\nquestion. The OO::Monitors module, while not a complete solution to this\nproblem, does provide a way to avoid dealing with the lock explicitly and\nencourage a more structured approach.\n\nThe Lock class is backed by operating-system provided constructs, and so a\nthread that is waiting to acquire a lock is, from the point of view of the\noperating system, blocked.\n\nCode using high-level Perl 6 concurrency constructs should avoid using\nLock. Waiting to acquire a Lock blocks a real Thread, meaning that the\nthread pool (used by numerous higher-level Perl 6 concurrency mechanisms)\ncannot use that thread in the meantime for anything else.\n\nAny await performed while a Lock is held will behave in a blocking manner;\nthe standard non-blocking behavior of await relies on the code following\nthe `await` resuming on a different Thread from the pool, which is\nincompatible with the requirement that a Lock be unlocked by the same\nthread that locked it. See Lock::Async for an alternative mechanism that\ndoes not have this shortcoming.\n\nBy their nature, Locks are not composable, and it is possible to end up\nwith hangs should circular dependencies on locks occur. Prefer to structure\nconcurrent programs such that they communicate results rather than modify\nshared data structures, using mechanisms like Promise, Channel and Supply.\n\n",
      "name": "Lock"
    },
    {
      "name": "Backtrace",
      "desc": "TITLE\nclass Backtrace\n\nSUBTITLE\nSnapshot of the dynamic call stack\n\n    class Backtrace {}\n\nA backtrace contains the dynamic call stack, usually leading up to a point\nwhere an exception was thrown, and is a List of Backtrace::Frame objects.\nIts default stringification excludes backtrace frames that are deemed\nunnecessary or confusing; for example routines like &die are hidden by\ndefault. Being a list, you can also access individual elements.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try {\n        zipi;\n    }\n    if ($!) {\n        say $!.backtrace[*-1].perl;\n    }\n\n\nThis will print the last frame in the list, pointing at the line where it's\nhappened.\n\n"
    },
    {
      "desc": "TITLE\nclass ComplexStr\n\nSUBTITLE\nDual value complex number and string\n\n    class ComplexStr is Complex is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42+0i>; say $f.^name; # OUTPUT: «ComplexStr␤»\n\nAs a subclass of both Complex and Str, a ComplexStr will be accepted where\neither is expected. However, ComplexStr does not share object identity with\nComplex- or Str-only variants:\n\n    my $complex-str = < 42+0i >;\n    my Complex $complex = $complex-str; # OK!\n    my Str     $str     = $complex-str; # OK!\n    say 42+0i ∈ <42+0i  55  1>; # False; ∈ operator cares about object identity\n\n",
      "name": "ComplexStr"
    },
    {
      "name": "Supplier",
      "desc": "TITLE\nclass Supplier\n\nSUBTITLE\nLive Supply factory\n\n    class Supplier { }\n\nThis is a factory for live Supply objects, which provides the mechanism for\nemitting new values onto the supplies:\n\n    my $supplier = Supplier.new;\n    my $supply_1 = $supplier.Supply;\n    $supply_1.tap(-> $v { say \"One $v\" });\n    my $supply_2 = $supplier.Supply;\n    $supply_2.tap(-> $v { say \"Two $v\" });\n    $supplier.emit(42);\n\nWill output:\n\n    One 42\n    Two 42\n\n\non demand supplies are created by the factory methods of the Supply class\nor by the supply keyword. A mixture of a live and on-demand Supply can be\ncreated with a Supplier::Preserving.\n\n"
    },
    {
      "desc": "TITLE\nclass List\n\nSUBTITLE\nSequence of values\n\n    my class List does Iterable does Positional { }\n\n\nList stores items sequentially and potentially lazily.\n\nIndexes into lists and arrays start at 0 by default.\n\nYou can assign to list elements if they are containers. Use Arrays to have\nevery value of the list stored in a container.\n\nList implements Positional and as such provides support for subscripts.\n\nItems, flattening and sigils\n\nIn Perl 6, assigning a List to a scalar variable does not lose information.\nThe difference is that iteration generally treats a list (or any other\nlist-like object, like a Seq or an Array) inside a scalar as a single\nelement.\n\n    my $s = (1, 2, 3);\n    for $s { }      # one iteration\n    for $s.list { } # three iterations\n\n    my $t = [1, 2, 3];\n    for $t { }      # one iteration\n    for $t.list { } # three iterations\n\n    my @a = 1, 2, 3;\n    for @a { }      # three iterations\n    for @a.item { } # one iteration\n\nThis operation is called itemization or putting in an item context. .item\ndoes the job for objects, as well as $( ... ) and, on array variables,\n$@a.\n\nLists generally don't interpolate (flatten) into other lists, except when\nthey are in list context and the single argument to an operation such as\nappend:\n\n    my $a = (1, 2, 3);\n    my $nested = ($a, $a);  # two elements\n\n    my $flat = $nested.map({ .Slip });  # six elements, with explicit Slip\n\n    my @b = <a b>;\n    @b.append: $a.list;     # The array variable @b has 5 elements, because\n                            # the list $a is the sole argument to append\n\n    say @b.elems;           # OUTPUT: «5␤»\n\n    my @c = <a b>;\n    @c.append: $a.list, 7;  # The array variable @c has 4 elements, because\n                            # the list $a wasn't the only argument and thus\n                            # wasn't flatten by the append operation\n\n    say @c.elems;           # OUTPUT: «4␤»\n\n    my @d = <a b>;\n    @d.append: $a;          # The array variable @d has 3 elements, because\n                            # $a is in  and as far as append is\n                            # concerned a single element\n\n    say @d.elems;           # OUTPUT: «3␤»\n\nThe same flattening behavior applies all objects that do the Iterable role,\nnotable hashes:\n\n    my %h = a => 1, b => 2;\n    my @b = %h;   say @b.elems;     # OUTPUT: «2␤»\n    my @c = %h, ; say @c.elems;     # OUTPUT: «1␤»\n    my @d = $%h;  say @d.elems;     # OUTPUT: «1␤»\n\nSlurpy parameters (*@a) flatten non-itemized sublists:\n\n    sub fe(*@flat) { @flat.elems }\n    say fe(<a b>, <d e>);           # OUTPUT: «4␤»\n    say fe(<a b>, <d e>.item);      # OUTPUT: «3␤»\n\n The empty list is created with (). Smartmatching against the empty list\nwill check for the absence of elements.\n\n    my @a;\n    for @a, @a.list, @a.Seq -> \\listoid {\n        say listoid ~~ ()\n    }\n    # OUTPUT: «True␤True␤True␤»\n\nCoercion to Bool also indicates if the List got any elements.\n\n    my @a;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[0 False False]␤»\n    @a.push: 42;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[1 True True]␤»\n    say 'empty' unless @a;        # no output\n\n",
      "name": "List"
    },
    {
      "name": "Blob",
      "desc": "TITLE\nrole Blob\n\nSUBTITLE\nImmutable buffer for binary data ('Binary Large OBject')\n\n    role Blob[::T = uint8] does Positional[T] does Stringy { }\n\nThe Blob role is an immutable interface to binary types, and offers a\nlist-like interface to lists of integers, typically unsigned integers.\n\n"
    },
    {
      "desc": "TITLE\nIndependent routines\n\nSUBTITLE\nRoutines not defined within any class or role.\n\nThese routines are defined in different files along with one or several\nother classes, but are not actually attached to any particular class or\nrole.\n\n  routine EVAL\n\nDefined as:\n\n    proto sub EVAL($code where Blob|Cool|Callable, Str() :$lang = 'perl6',\n                    PseudoStash :$context, *%n)\n\n\n    multi sub EVAL($code, Str :$lang where { ($lang // '') eq 'Perl5' },\n                    PseudoStash :$context)\n\n\nThis routine coerces Cool $code to Str. If $code is a Blob, it'll be\nprocessed using the same encoding as the $lang compiler would: for perl6\n$lang, uses utf-8; for Perl5, processes using the same rules as perl.\n\nThis works as-is with a literal string parameter. More complex input, such\nas a variable or string with embedded code, is illegal by default. This can\nbe overridden in any of several ways:\n\n    use MONKEY-SEE-NO-EVAL; # Or...\n    use MONKEY;             # shortcut that turns on all MONKEY pragmas\n    use Test;\n\n    # any of the above allows:\n    EVAL \"say { 5 + 5 }\";   # OUTPUT: «10␤»\n\nIn case the MONKEY-SEE-NO-EVAL pragma is not activated, the compiler will\ncomplain with a EVAL is a very dangerous function!!! exception. And it is\nessentially right, since that will run arbitrary code with the same\npermissions as the program. You should take care of cleaning the code that\nis going to pass through EVAL if you activate the MONKEY-SEE-NO-EVAL\npragma.\n\nPlease note that you can interpolate to create routine names using\nquotation, as can be seen in this example or other ways to interpolate to\ncreate identifier names. This only works, however, for already declared\nfunctions and other objects and is thus safer to use.\n\nSymbols in the current lexical scope are visible to code in an EVAL.\n\n    my $answer = 42;\n    EVAL 'say $answer;';    # OUTPUT: «42␤»\n\nHowever, since the set of symbols in a lexical scope is immutable after\ncompile time, an EVAL can never introduce symbols into the surrounding\nscope.\n\n    EVAL 'my $lives = 9'; say $lives;   # error, $lives not declared\n\n\nFurthermore, the EVAL is evaluated in the current package:\n\n    module M {\n        EVAL 'our $answer = 42'\n    }\n    say $M::answer;         # OUTPUT: «42␤»\n\nAnd also in the current language, meaning any added syntax is available:\n\n    sub infix:<mean>(*@a) is assoc<list> {\n        @a.sum / @a.elems\n    }\n    EVAL 'say 2 mean 6 mean 4';     # OUTPUT: «4␤»\n\nAn EVAL statement evaluates to the result of the last statement:\n\n    sub infix:<mean>(*@a) is assoc<list> {\n        @a.sum / @a.elems\n    }\n    say EVAL 'say 1; 2 mean 6 mean 4';         # OUTPUT: «1␤4␤»\n\n\nEVAL is also a gateway for executing code in other languages:\n\n    EVAL \"use v5.20; say 'Hello from perl5!'\", :lang<Perl5>;\n\n\nYou need to have Inline::Perl5 for this to work correctly.\n\n  sub EVALFILE\n\nDefined as:\n\n    sub EVALFILE($filename where Blob|Cool, :$lang = 'perl6')\n\nSlurps the specified file and evaluates it. Behaves the same way as EVAL\nwith regard to Blob decoding, scoping, and the $lang parameter. Evaluates\nto the value produced by the final statement in the file.\n\n    EVALFILE \"foo.p6\";\n\n\n  sub mkdir\n\nDefined as:\n\n    sub    mkdir(IO() $path, Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory; see mode for explanation and valid values for\n$mode. Returns the IO::Path object pointing to the newly created directory\non success; fails with X::IO::Mkdir if directory cannot be created.\n\nAlso creates parent directories, as needed (similar to *nix utility mkdir\nwith -p option); that is, mkdir \"foo/bar/ber/meow\" will create foo,\nfoo/bar, and foo/bar/ber directories if they do not exist, as well as\nfoo/bar/ber/meow.\n\n  sub chdir\n\nDefined as:\n\n    sub chdir(IO() $path, :$d = True, :$r, :$w, :$x --> IO::Path:D)\n\nChanges value of $*CWD variable to the provided $path, optionally ensuring\nthe new path passes several file tests. NOTE: that this routine does NOT\nalter the process's current directory (see &*chdir).\n\nReturns IO::Path representing new $*CWD on success. On failure, returns\nFailure and leaves $*CWD untouched. The $path can be any object with an IO\nmethod that returns an IO::Path object. The available file tests are:\n\n  * :d — check .d returns True\n\n  * :r — check .r returns True\n\n  * :w — check .w returns True\n\n  * :x — check .x returns True\n\nBy default, only :d test is performed.\n\n    chdir         '/tmp'; # change $*CWD to '/tmp' and check its .d is True\n    chdir :r, :w, '/tmp'; # … check its .r and .w are True\n    chdir '/not-there';   # returns Failure\n\n\nNote that the following construct is a mistake:\n\n    # WRONG! DO NOT DO THIS!\n    my $*CWD = chdir '/tmp/';\n\n\nUse indir instead.\n\n  sub &*chdir\n\nDefined as:\n\n    PROCESS::<&chdir> = sub (IO() $path --> IO::Path:D) { }\n\n\nChanges value of $*CWD variable to the provided $path and sets the\nprocess's current directory to the value of $path.absolute. NOTE: that in\nmost cases, you want to use chdir routine instead.\n\nReturns an IO::Path representing the new $*CWD on success. On failure,\nreturns Failure and leaves $*CWD untouched. The $path can be any object\nwith an IO method that returns an IO::Path object.\n\nNote that unlike regular chdir, there are no arguments to specify which\nfile tests to perform.\n\n    &*chdir('/tmp');  # change $*CWD and process's current directory to '/tmp'\n    &*chdir('/not-there'); # returns Failure\n\n\nNote that the following construct is a mistake:\n\n    # WRONG! DO NOT DO THIS!\n    my $*CWD = &*chdir('/tmp');\n\n\nUse the following, instead; or see indir if you do not need to change\nprocess's current directory:\n\n    temp $*CWD;\n    &*chdir('/tmp');\n\n\n  sub chmod\n\nDefined as:\n\n    sub chmod(Int() $mode, *@filenames --> List)\n\nCoerces all @filenames to IO::Path and calls IO::Path.chmod with $mode on\nthem. Returns a List containing a subset of @filenames for which chmod was\nsuccessfully executed.\n\n    chmod 0o755, <myfile1  myfile2>; # make two files executable by the owner\n\n  sub indir\n\nDefined as:\n\n    sub indir(IO() $path, &code, :$d = True, :$r, :$w, :$x --> Mu)\n\nTakes Callable &code and executes it after locally (to &code) changing\n$*CWD variable to an IO::Path object based on $path, optionally ensuring\nthe new path passes several file tests. If $path is relative, it will be\nturned into an absolute path, even if an IO::Path object was given. NOTE:\nthat this routine does NOT alter the process's current directory (see\n&*chdir). The $*CWD outside of the &code is not affected, even if &code\nexplicitly assigns a new value to $*CWD.\n\nReturns the return value of &code on success. On failure to successfully\nchange $*CWD, returns Failure. WARNING: keep in mind that lazily evaluated\nthings might end up NOT having the $*CWD set by indir in their dynamic\nscope by the time they're actually evaluated. Either ensure the generators\nhave their $*CWD set or eagerly evaluate them before returning the results\nfrom indir:\n\n    say indir(\"/tmp\", {\n        gather { take \".\".IO }\n    })».CWD; # OUTPUT: «(/home/camelia)␤»\n\n    say indir(\"/tmp\", {\n        eager gather { take \".\".IO }\n    })».CWD; # OUTPUT: «(/tmp)␤»\n\n    say indir(\"/tmp\", {\n        my $cwd = $*CWD;\n        gather { temp $*CWD = $cwd; take \".\".IO }\n    })».CWD; # OUTPUT: «(/tmp)␤»\n\nThe routine's $path argument can be any object with an IO method that\nreturns an IO::Path object. The available file tests are:\n\n  * :d — check .d returns True\n\n  * :r — check .r returns True\n\n  * :w — check .w returns True\n\n  * :x — check .x returns True\n\nBy default, only :d test is performed.\n\n    say $*CWD;                   # OUTPUT: «\"/home/camelia\".IO␤»\n    indir '/tmp', { say $*CWD }; # OUTPUT: «\"/tmp\".IO␤»\n    say $*CWD;                   # OUTPUT: «\"/home/camelia\".IO␤»\n\n    indir '/not-there', {;};     # returns Failure; path does not exist\n\n  sub print\n\nDefined as:\n\n    multi sub print(**@args --> True)\n    multi sub print(Junction:D --> True)\n\nPrints the given text on standard output (the $*OUT filehandle), coercing\nnon-Str objects to Str by calling .Str method. Junction arguments\nautothread and the order of printed strings is not guaranteed.\n\n    print \"Hi there!\\n\";   # OUTPUT: «Hi there!␤»\n    print \"Hi there!\";     # OUTPUT: «Hi there!»\n    print [1, 2, 3];       # OUTPUT: «1 2 3»\n\nTo print text and include the trailing newline, use put.\n\n  sub put\n\nDefined as:\n\n    multi sub put(**@args --> True)\n    multi sub put(Junction:D --> True)\n\nSame as print, except it uses print-nl (which prints a newline, by default)\nat the end. Junction arguments autothread and the order of printed strings\nis not guaranteed.\n\n    put \"Hi there!\\n\";   # OUTPUT: «Hi there!␤␤»\n    put \"Hi there!\";     # OUTPUT: «Hi there!␤»\n    put [1, 2, 3];       # OUTPUT: «1 2 3␤»\n\n  sub say\n\nDefined as:\n\n    multi sub say(**@args --> True)\n\nPrints the \"gist\" of given objects. Same as put, except uses .gist method\nto obtain string representation of the object.\n\nNOTE: the .gist method of some objects, such as Lists, returns only partial\ninformation about the object (hence the \"gist\"). If you mean to print\ntextual information, you most likely want to use put instead.\n\n    say Range;        # OUTPUT: «(Range)␤»\n    say class Foo {}; # OUTPUT: «(Foo)␤»\n    say 'I ♥ Perl6';  # OUTPUT: «I ♥ Perl6␤»\n    say 1..Inf;       # OUTPUT: «1..Inf␤»\n\n  routine note\n\nDefined as:\n\n    method note(Mu: -->Bool:D)\n    multi sub note(            --> Bool:D)\n    multi sub note(Str:D $note --> Bool:D)\n    multi sub note(**@args     --> Bool:D)\n\nLike say, except prints output to $*ERR handle (STDERR). If no arguments\nare given to subroutine forms, will use string \"Noted\".\n\n    note;       # STDERR OUTPUT: «Noted␤»\n    note 'foo'; # STDERR OUTPUT: «foo␤»\n    note 1..*;  # STDERR OUTPUT: «1..Inf␤»\n\n\n  sub prompt\n\n    multi sub prompt()\n    multi sub prompt($msg)\n\nPrints $msg to $*OUT handle if $msg was provided, then gets a line of input\nfrom $*IN handle. By default, this is equivalent to printing $msg to\nSTDOUT, reading a line from STDIN, removing the trailing new line, and\nreturning the resultant string. As of Rakudo 2018.08, prompt will create\nallomorphs for numeric values, equivalent to calling val prompt.\n\n    my $name = prompt \"What's your name? \";\n    say \"Hi, $name! Nice to meet you!\";\n    my $age = prompt(\"Say your age (number)\");\n    my Int $years = $age;\n    my Str $age-badge = $age;\n\n\nIn the code above, $age will be duck-typed to the allomorph IntStr if it's\nentered correctly as a number.\n\n  sub open\n\n    multi sub open(IO() $path, |args --> IO::Handle:D)\n\nCreates a handle with the given $path, and calls IO::Handle.open, passing\nany of the remaining arguments to it. Note that IO::Path type provides\nnumerous methods for reading and writing from files, so in many common\ncases you do not need to open files or deal with IO::Handle type directly.\n\n    my $fh = open :w, '/tmp/some-file.txt';\n    $fh.say: 'I ♥ writing Perl code';\n    $fh.close;\n\n    $fh = open '/tmp/some-file.txt';\n    print $fh.readchars: 4;\n    $fh.seek: 7, SeekFromCurrent;\n    say $fh.readchars: 4;\n    $fh.close;\n\n    # OUTPUT: «I ♥ Perl␤»\n\n\n  sub slurp\n\nDefined as:\n\n    multi sub slurp(IO::Handle:D $fh = $*ARGFILES, |c)\n    multi sub slurp(IO() $path, |c)\n\nSlurps the contents of the entire file into a Str (or Buf if :bin). Accepts\n:bin and :enc optional named parameters, with the same meaning as open();\npossible encodings are the same as in all the other IO methods and are\nlisted in encoding routine. The routine will fail if the file does not\nexist, or is a directory. Without any arguments, sub slurp operates on\n$*ARGFILES, which defaults to $*IN in the absence of any filenames.\n\n    # read entire file as (Unicode) Str\n    my $text_contents   = slurp \"path/to/file\";\n\n    # read entire file as Latin1 Str\n    my $text_contents   = slurp \"path/to/file\", enc => \"latin1\";\n\n    # read entire file as Buf\n    my $binary_contents = slurp \"path/to/file\", :bin;\n\n\n  sub spurt\n\nDefined as:\n\n    multi spurt(IO() $path, |c)\n\nThe $path can be any object with an IO method that returns an IO::Path\nobject. Calls IO::Path.spurt on the $path, forwarding any of the remaining\narguments.\n\n    Options\n\n  * :enc\n\nThe encoding with which the contents will be written.\n\n  * :append\n\nBoolean indicating whether to append to a (potentially) existing file. If\nthe file did not exist yet, it will be created. Defaults to False.\n\n  * :createonly\n\nBoolean indicating whether to fail if the file already exists. Defaults to\nFalse.\n\n    Examples\n\n    # write directly to a file\n    spurt 'path/to/file', 'default text, directly written';\n\n    # write directly with a non-Unicode encoding\n    spurt 'path/to/latin1_file', 'latin1 text: äöüß', :enc<latin1>;\n\n    spurt 'file-that-already-exists', 'some text';           # overwrite file's contents:\n    spurt 'file-that-already-exists', ' new text', :append;  # append to file's contents:\n    say slurp 'file-that-already-exists';                    # OUTPUT: «some text new text␤»\n\n    # fail when writing to a pre-existing file\n    spurt 'file-that-already-exists', 'new text', :createonly;\n    # OUTPUT: «Failed to open file /home/camelia/file-that-already-exists: file already exists …»\n\n\n  sub run\n\nDefined as:\n\n    sub run(\n        *@args ($, *@),\n        :$in = '-',\n        :$out = '-',\n        :$err = '-',\n        Bool :$bin = False,\n        Bool :$chomp = True,\n        Bool :$merge = False,\n        Str:D :$enc = 'UTF-8',\n        Str:D :$nl = \"\\n\",\n        :$cwd = $*CWD,\n        Hash() :$env = %*ENV\n    --> Proc:D)\n\n\nRuns an external command without involving a shell and returns a Proc\nobject. By default, the external command will print to standard output and\nerror, and read from standard input.\n\n    run 'touch', '>foo.txt'; # Create a file named >foo.txt\n\n    run <<rm >foo.txt>>; # Another way to use run, using word quoting for the\n                         # arguments\n\nIf you want to pass some variables you can still use < >, but try to avoid\nusing « » as it will do word splitting if you forget to quote variables:\n\n    my $file = ‘--my arbitrary filename’;\n    run ‘touch’, ‘--’, $file;  # RIGHT\n    run <touch -->, $file;     # RIGHT\n\n    run «touch -- \"$file\"»;    # RIGHT but WRONG if you forget quotes\n    run «touch -- $file»;      # WRONG; touches ‘--my’, ‘arbitrary’ and ‘filename’\n    run ‘touch’, $file;        # WRONG; error from `touch`\n    run «touch \"$file\"»;       # WRONG; error from `touch`\n\n\nNote that -- is required for many programs to disambiguate between\ncommand-line arguments and filenames that begin with hyphens.\n\nA sunk Proc object for a process that exited unsuccessfully will throw. If\nyou wish to ignore such failures, simply use run in non-sink context:\n\n    run 'false';     # SUNK! Will throw\n    run('false').so; # OK. Evaluates Proc in Bool context; no sinking\n\nIf you want to capture standard output or error instead of having it\nprinted directly you can use the :out or :err arguments, which will make\nthem available using their respective methods: Proc.out and Proc.err.\n\n    my $proc = run 'echo', 'Perl 6 is Great!', :out, :err;\n    $proc.out.slurp(:close).say; # OUTPUT: «Perl 6 is Great!␤»\n    $proc.err.slurp(:close).say; # OUTPUT: «␤»\n\nYou can use these arguments to redirect them to a filehandle, thus creating\na kind of pipe:\n\n    my $ls-alt-handle = open :w, '/tmp/cur-dir-ls-alt.txt';\n    my $proc = run \"ls\", \"-alt\", :out($ls-alt-handle);\n    # (The file will contain the output of the ls -alt command)\n\nThese argument are quite flexible and admit, for instance, handles to\nredirect them. See Proc and Proc::Async for more details.\n\nSee also new for more examples.\n\n  sub shell\n\n    multi sub shell($cmd, :$in = '-', :$out = '-', :$err = '-',\n                    Bool :$bin, Bool :$chomp = True, Bool :$merge,\n                    Str :$enc, Str:D :$nl = \"\\n\", :$cwd = $*CWD, :$env)\n\n\nRuns a command through the system shell, which defaults to %*ENV<ComSpec>\n/c in Windows, /bin/sh -c otherwise. All shell metacharacters are\ninterpreted by the shell, including pipes, redirects, environment variable\nsubstitutions and so on. Shell escapes are a severe security concern and\ncan cause confusion with unusual file names. Use run if you want to be\nsafe.\n\nThe return value is of type Proc.\n\n    shell 'ls -lR | gzip -9 > ls-lR.gz';\n\nSee Proc for more details, for example on how to capture output.\n\n  routine unpolar\n\nDefined as:\n\n    method unpolar(Real $angle)\n    multi sub unpolar(Real $mag, Real $angle)\n\nReturns a Complex with the coordinates corresponding to the angle in\nradians and magnitude corresponding to the object value or $mag in the case\nit's being used as a sub\n\n    say 1.unpolar(⅓*pi);\n    # OUTPUT: «0.5000000000000001+0.8660254037844386i␤»\n\n  routine printf\n\nDefined as:\n\n    method printf (*@args)\n    multi sub printf(Cool:D $format, *@args)\n\nAs a method, takes the object as a format using the same language as\nStr.sprintf; as a sub, its first argument will be the format string, and\nthe rest of the arguments will be substituted in the format following the\nformat conventions.\n\n    \"%s is %s\".printf(\"þor\", \"mighty\");    # OUTPUT: «þor is mighty»\n    printf( \"%s is %s\", \"þor\", \"mighty\");  # OUTPUT: «þor is mighty»\n\n  routine sprintf\n\nDefined as:\n\n    method sprintf(*@args)\n    multi sub sprintf(Cool:D $format, *@args)\n\nFormats and outputs a string, following the same language as Str.sprintf,\nusing as such format either the object (if called in method form) or the\nfirst argument (if called as a routine)\n\n    sprintf( \"%s the %d%s\", \"þor\", 1, \"st\").put; #OUTPUT: «þor the 1st␤»\n    sprintf( \"%s is %s\", \"þor\", \"mighty\").put;   # OUTPUT: «þor is mighty␤»\n    \"%s's weight is %.2f %s\".sprintf( \"Mjölnir\", 3.3392, \"kg\").put;\n    # OUTPUT: «Mjölnir's weight is 3.34 kg␤»\n\nThis function is mostly identical to the C library's sprintf and printf\nfunctions. The only difference between the two functions is that sprintf\nreturns a string while the printf function writes to a filehandle. sprintf\nreturns a Str, not a literal.\n\nThe $format is scanned for % characters. Any % introduces a format token.\nDirectives guide the use (if any) of the arguments. When a directive other\nthan % is used, it indicates how the next argument passed is to be\nformatted into the string to be created.\n\nThe information below is for a fully functioning sprintf implementation\nwhich hasn't been achieved yet. Formats or features not yet implemented are\nmarked NYI.\n\nThe directives are:\n\n  %  a literal percent sign\n  c  a character with the given codepoint\n  s  a string\n  d  a signed integer, in decimal\n  u  an unsigned integer, in decimal\n  o  an unsigned integer, in octal\n  x  an unsigned integer, in hexadecimal\n  e  a floating-point number, in scientific notation\n  f  a floating-point number, in fixed decimal notation\n  g  a floating-point number, in %e or %f notation\n  X  like x, but using uppercase letters\n  E  like e, but using an uppercase \"E\"\n  G  like g, but with an uppercase \"E\" (if applicable)\n  b  an unsigned integer, in binary\n\n\nCompatibility:\n\n  i  a synonym for %d\n  D  a synonym for %ld\n  U  a synonym for %lu\n  O  a synonym for %lo\n  F  a synonym for %f\n\n\nModifiers change the meaning of format directives, but are largely no-ops\n(the semantics are still being determined).\n\n       h   interpret integer as native \"short\" (typically int16)\n  NYI  l   interpret integer as native \"long\" (typically int32 or int64)\n  NYI  ll  interpret integer as native \"long long\" (typically int64)\n  NYI  L   interpret integer as native \"long long\" (typically uint64)\n  NYI  q   interpret integer as native \"quads\" (typically int64 or larger)\n\n\nBetween the % and the format letter, you may specify several additional\nattributes controlling the interpretation of the format. In order, these\nare:\n\n    Format parameter index\n\nAn explicit format parameter index, such as 2$. By default, sprintf will\nformat the next unused argument in the list, but this allows you to take\nthe arguments out of order:\n\n    sprintf '%2$d %1$d', 12, 34;      # OUTPUT: «34 12␤»\n    sprintf '%3$d %d %1$d', 1, 2, 3;  # OUTPUT: «3 1 1␤»\n\n    Flags\n\nOne or more of:\n\n  space  prefix non-negative number with a space\n  +      prefix non-negative number with a plus sign\n  -      left-justify within the field\n  0      use leading zeros, not spaces, for required padding\n  #      ensure the leading \"0\" for any octal, prefix non-zero hexadecimal with \"0x\" or \"0X\", prefix non-zero binary with \"0b\" or \"0B\"\n\n\nFor example:\n\n    sprintf '<% d>',  12;   # RESULT: «< 12>␤»\n    sprintf '<% d>',   0;   # RESULT: «< 0>\"»\n    sprintf '<% d>', -12;   # RESULT: «<-12>␤»\n    sprintf '<%+d>',  12;   # RESULT: «<+12>␤»\n    sprintf '<%+d>',   0;   # RESULT: «<+0>\"»\n    sprintf '<%+d>', -12;   # RESULT: «<-12>␤»\n    sprintf '<%6s>',  12;   # RESULT: «<    12>␤»\n    sprintf '<%-6s>', 12;   # RESULT: «<12    >␤»\n    sprintf '<%06s>', 12;   # RESULT: «<000012>␤»\n    sprintf '<%#o>',  12;   # RESULT: «<014>␤»\n    sprintf '<%#x>',  12;   # RESULT: «<0xc>␤»\n    sprintf '<%#X>',  12;   # RESULT: «<0XC>␤»\n    sprintf '<%#b>',  12;   # RESULT: «<0b1100>␤»\n    sprintf '<%#B>',  12;   # RESULT: «<0B1100>␤»\n\nWhen a space and a plus sign are given as the flags at once, the space is\nignored:\n\n    sprintf '<%+ d>', 12;   # RESULT: «<+12>␤»\n    sprintf '<% +d>', 12;   # RESULT: «<+12>␤»\n\nWhen the # flag and a precision are given in the %o conversion, the\nnecessary number of 0s is added at the beginning. If the value of the\nnumber is 0 and the precision is 0, it will output nothing; precision 0 or\nsmaller than the actual number of elements will return the number with 0 to\nthe left:\n\n    say sprintf '<%#.5o>', 0o12;     # OUTPUT: «<00012>␤»\n    say sprintf '<%#.5o>', 0o12345;  # OUTPUT: «<012345>␤»\n    say sprintf '<%#.0o>', 0;        # OUTPUT: «<>␤» zero precision and value 0 results in no output!\n    say sprintf '<%#.0o>', 0o1       # OUTPUT: «<01>␤»\n\n    Vector flag\n\nThis flag tells Perl 6 to interpret the supplied string as a vector of\nintegers, one for each character in the string. Perl 6 applies the format\nto each integer in turn, then joins the resulting strings with a separator\n(a dot, '.', by default). This can be useful for displaying ordinal values\nof characters in arbitrary strings:\n\n    NYI sprintf \"%vd\", \"AB\\x[100]\";           # \"65.66.256\"\n\n\nYou can also explicitly specify the argument number to use for the join\nstring using something like *2$v; for example:\n\n    NYI sprintf '%*4$vX %*4$vX %*4$vX',       # 3 IPv6 addresses\n            @addr[1..3], \":\";\n\n\n    (Minimum) Width\n\nArguments are usually formatted to be only as wide as required to display\nthe given value. You can override the width by putting a number here, or\nget the width from the next argument (with * ) or from a specified argument\n(e.g., with *2$):\n\n     sprintf \"<%s>\", \"a\";           # RESULT: «<a>␤»\n     sprintf \"<%6s>\", \"a\";          # RESULT: «<     a>␤»\n     sprintf \"<%*s>\", 6, \"a\";       # RESULT: «<     a>␤»\n     NYI sprintf '<%*2$s>', \"a\", 6; # \"<     a>\"\n     sprintf \"<%2s>\", \"long\";       # RESULT: «<long>␤» (does not truncate)\n\n\nIf a field width obtained through * is negative, it has the same effect as\nthe - flag: left-justification.\n\n    Precision, or maximum width\n\nYou can specify a precision (for numeric conversions) or a maximum width\n(for string conversions) by specifying a . followed by a number. For\nfloating-point formats, except g and G, this specifies how many places\nright of the decimal point to show (the default being 6). For example:\n\n    # these examples are subject to system-specific variation\n    sprintf '<%f>', 1;    # RESULT: «\"<1.000000>\"␤»\n    sprintf '<%.1f>', 1;  # RESULT: «\"<1.0>\"␤»\n    sprintf '<%.0f>', 1;  # RESULT: «\"<1>\"␤»\n    sprintf '<%e>', 10;   # RESULT: «\"<1.000000e+01>\"␤»\n    sprintf '<%.1e>', 10; # RESULT: «\"<1.0e+01>\"␤»\n\nFor \"g\" and \"G\", this specifies the maximum number of digits to show,\nincluding those prior to the decimal point and those after it; for\nexample:\n\n    # These examples are subject to system-specific variation.\n    sprintf '<%g>', 1;        # RESULT: «<1>␤»\n    sprintf '<%.10g>', 1;     # RESULT: «<1>␤»\n    sprintf '<%g>', 100;      # RESULT: «<100>␤»\n    sprintf '<%.1g>', 100;    # RESULT: «<1e+02>␤»\n    sprintf '<%.2g>', 100.01; # RESULT: «<1e+02>␤»\n    sprintf '<%.5g>', 100.01; # RESULT: «<100.01>␤»\n    sprintf '<%.4g>', 100.01; # RESULT: «<100>␤»\n\nFor integer conversions, specifying a precision implies that the output of\nthe number itself should be zero-padded to this width, where the 0 flag is\nignored:\n\n(Note that this feature currently works for unsigned integer conversions,\nbut not for signed integer.)\n\n    sprintf '<%.6d>', 1;      # <000001>\n    NYI sprintf '<%+.6d>', 1;     # <+000001>\n    NYI sprintf '<%-10.6d>', 1;   # <000001    >\n    sprintf '<%10.6d>', 1;    # <    000001>\n    NYI sprintf '<%010.6d>', 1;   #     000001>\n    NYI sprintf '<%+10.6d>', 1;   # <   +000001>\n    sprintf '<%.6x>', 1;         # RESULT: «<000001>␤»\n    sprintf '<%#.6x>', 1;        # RESULT: «<0x000001>␤»\n    sprintf '<%-10.6x>', 1;      # RESULT: «<000001    >␤»\n    sprintf '<%10.6x>', 1;       # RESULT: «<    000001>␤»\n    sprintf '<%010.6x>', 1;      # RESULT: «<    000001>␤»\n    sprintf '<%#10.6x>', 1;      # RESULT: «<  0x000001>␤»\n\n\nFor string conversions, specifying a precision truncates the string to fit\nthe specified width:\n\n    sprintf '<%.5s>', \"truncated\";   # RESULT: «<trunc>␤»\n    sprintf '<%10.5s>', \"truncated\"; # RESULT: «<     trunc>␤»\n\nYou can also get the precision from the next argument using .*, or from a\nspecified argument (e.g., with .*2$):\n\n    sprintf '<%.6x>', 1;       # RESULT: «<000001>␤»\n    sprintf '<%.*x>', 6, 1;    # RESULT: «<000001>␤»\n    NYI sprintf '<%.*2$x>', 1, 6;  # \"<000001>\"\n    NYI sprintf '<%6.*2$x>', 1, 4; # \"<  0001>\"\n\n\nIf a precision obtained through * is negative, it counts as having no\nprecision at all:\n\n    sprintf '<%.*s>',  7, \"string\";   # RESULT: «<string>␤»\n    sprintf '<%.*s>',  3, \"string\";   # RESULT: «<str>␤»\n    sprintf '<%.*s>',  0, \"string\";   # RESULT: «<>␤»\n    sprintf '<%.*s>', -1, \"string\";   # RESULT: «<string>␤»\n    sprintf '<%.*d>',  1, 0;          # RESULT: «<0>␤»\n    sprintf '<%.*d>',  0, 0;          # RESULT: «<>␤»\n    sprintf '<%.*d>', -1, 0;          # RESULT: «<0>␤»\n\n    Size\n\nFor numeric conversions, you can specify the size to interpret the number\nas using l, h, V, q, L, or ll. For integer conversions (d u o x X b i D U\nO), numbers are usually assumed to be whatever the default integer size is\non your platform (usually 32 or 64 bits), but you can override this to use\ninstead one of the standard C types, as supported by the compiler used to\nbuild Perl 6:\n\n(Note: None of the following have been implemented.)\n\n  hh           interpret integer as C type \"char\" or \"unsigned char\"\n  h            interpret integer as C type \"short\" or \"unsigned short\"\n  j            interpret integer as C type \"intmax_t\", only with a C99 compiler (unportable)\n  l            interpret integer as C type \"long\" or \"unsigned long\"\n  q, L, or ll  interpret integer as C type \"long long\", \"unsigned long long\", or \"quad\" (typically 64-bit integers)\n  t            interpret integer as C type \"ptrdiff_t\"\n  z            interpret integer as C type \"size_t\"\n\n\n    Order of arguments\n\nNormally, sprintf takes the next unused argument as the value to format for\neach format specification. If the format specification uses * to require\nadditional arguments, these are consumed from the argument list in the\norder they appear in the format specification before the value to format.\nWhere an argument is specified by an explicit index, this does not affect\nthe normal order for the arguments, even when the explicitly specified\nindex would have been the next argument.\n\nSo:\n\n    my $a = 5; my $b = 2; my $c = 'net';\n    sprintf \"<%*.*s>\", $a, $b, $c; # RESULT: «<   ne>␤»\n\nuses $a for the width, $b for the precision, and $c as the value to format;\nwhile:\n\n    NYI sprintf '<%*1$.*s>', $a, $b;\n\n\nwould use $a for the width and precision and $b as the value to format.\n\nHere are some more examples; be aware that when using an explicit index,\nthe $ may need escaping:\n\n    sprintf \"%2\\$d %d\\n\",      12, 34;     # RESULT: «34 12␤␤»\n    sprintf \"%2\\$d %d %d\\n\",   12, 34;     # RESULT: «34 12 34␤␤»\n    sprintf \"%3\\$d %d %d\\n\",   12, 34, 56; # RESULT: «56 12 34␤␤»\n    NYI sprintf \"%2\\$*3\\$d %d\\n\",  12, 34,  3; # \" 34 12\\n\"\n    NYI sprintf \"%*1\\$.*f\\n\",       4,  5, 10; # \"5.0000\\n\"\n\n\nOther examples:\n\n    NYI sprintf \"%ld a big number\", 4294967295;\n    NYI sprintf \"%%lld a bigger number\", 4294967296;\n    sprintf('%c', 97);                  # RESULT: «a␤»\n    sprintf(\"%.2f\", 1.969);             # RESULT: «1.97␤»\n    sprintf(\"%+.3f\", 3.141592);         # RESULT: «+3.142␤»\n    sprintf('%2$d %1$d', 12, 34);       # RESULT: «34 12␤»\n    sprintf(\"%x\", 255);                 # RESULT: «ff␤»\n\n\nSpecial case: sprintf(\"<b>%s</b>\\n\", \"Perl 6\") will not work, but one of\nthe following will:\n\n    sprintf Q:b \"<b>%s</b>\\n\",  \"Perl 6\"; # RESULT: «<b>Perl 6</b>␤␤»\n    sprintf     \"<b>\\%s</b>\\n\", \"Perl 6\"; # RESULT: «<b>Perl 6</b>␤␤»\n    sprintf     \"<b>%s\\</b>\\n\", \"Perl 6\"; # RESULT: «<b>Perl 6</b>␤␤»\n\n\n  sub flat\n\nDefined as:\n\n    multi flat(**@list)\n    multi flat(Iterable \\a)\n\nConstructs a list which contains any arguments provided, and returns the\nresult of calling the .flat method (inherited from Any) on that list or\nIterable:\n\n    say flat 1, (2, (3, 4), $(5, 6)); # OUTPUT: «(1 2 3 4 (5 6))␤»\n\n  routine unique\n\nDefined as:\n\n    multi sub unique(+values, |c)\n\nReturns a sequence of unique values from the invocant/argument list, such\nthat only the first occurrence of each duplicated value remains in the\nresult list. unique uses the semantics of the === operator to decide\nwhether two objects are the same, unless the optional :with parameter is\nspecified with another comparator. The order of the original list is\npreserved even as duplicates are removed.\n\nExamples:\n\n    say <a a b b b c c>.unique;   # OUTPUT: «(a b c)␤»\n    say <a b b c c b a>.unique;   # OUTPUT: «(a b c)␤»\n\n(Use squish instead if you know the input is sorted such that identical\nobjects are adjacent.)\n\nThe optional :as parameter allows you to normalize/canonicalize the\nelements before unique-ing. The values are transformed for the purposes of\ncomparison, but it's still the original values that make it to the result\nlist; however, only the first occurrence will show up in that list:\n\nExample:\n\n    say <a A B b c b C>.unique(:as(&lc))      # OUTPUT: «(a B c)␤»\n\nOne can also specify the comparator with the optional :with parameter. For\ninstance if one wants a list of unique hashes, one could use the eqv\ncomparator.\n\nExample:\n\n    my @list = %(a => 42), %(b => 13), %(a => 42);\n    say @list.unique(:with(&[eqv]))           # OUTPUT: «({a => 42} {b => 13})␤»\n\nNote: since :with Callable has to be tried with all the items in the list,\nthis makes unique follow a path with much higher algorithmic complexity.\nYou should try to use the :as argument instead, whenever possible.\n\n  routine repeated\n\nDefined as:\n\n    multi sub    repeated(+values, |c)\n\nThis returns a sequence of repeated values from the invocant/argument list.\nIt takes the same parameters as unique, but instead of passing through any\nelements when they're first seen, they're only passed through as soon as\nthey're seen for the second time (or more).\n\nExamples:\n\n    say <a a b b b c c>.repeated;                   # OUTPUT: «(a b b c)␤»\n    say <a b b c c b a>.repeated;                   # OUTPUT: «(b c b a)␤»\n    say <a A B b c b C>.repeated(:as(&lc));         # OUTPUT: «(A b b C)␤»\n\n    my @list = %(a => 42), %(b => 13), %(a => 42);\n    say @list.repeated(:with(&[eqv]))               # OUTPUT: «({a => 42})␤»\n\nAs in the case of unique the associative argument :as takes a Callable that\nnormalizes the element before comparison, and :with takes a the equality\ncomparison function that is going to be used.\n\n  routine squish\n\nDefined as:\n\n    sub          squish( +values, |c)\n\nReturns a sequence of values from the invocant/argument list where runs of\none or more values are replaced with only the first instance. Like unique,\nsquish uses the semantics of the === operator to decide whether two objects\nare the same. Unlike unique, this function only removes adjacent\nduplicates; identical values further apart are still kept. The order of the\noriginal list is preserved even as duplicates are removed.\n\nExamples:\n\n    say <a a b b b c c>.squish; # OUTPUT: «(a b c)␤»\n    say <a b b c c b a>.squish; # OUTPUT: «(a b c b a)␤»\n\nThe optional :as parameter, just like with unique, allows values to be\ntemporarily transformed before comparison.\n\nThe optional :with parameter is used to set an appropriate comparison\noperator:\n\n    say [42, \"42\"].squish;                      # OUTPUT: «(42 42)␤»\n    # Note that the second item in the result is still Str\n    say [42, \"42\"].squish(with => &infix:<eq>); # OUTPUT: «(42)␤»\n    # The resulting item is Int\n\n  sub emit\n\nDefined as\n\n    sub emit(\\value --> Nil)\n\nIf used outside any supply or react block, throws an exception emit without\nsupply or react. Within a Supply block, it will add a message to the\nstream.\n\n    my $supply = supply {\n      for 1 .. 10 {\n          emit($_);\n      }\n    }\n    $supply.tap( -> $v { say \"First : $v\" });\n\n\nSee also the page for emit methods.\n\n  sub undefine\n\nDefined as:\n\n    multi sub undefine(Mu    \\x)\n    multi sub undefine(Array \\x)\n    multi sub undefine(Hash  \\x)\n\nDEPRECATED in 6.d language version and will be removed in 6.e. For Array\nand Hash, it will become equivalent to assigning Empty; for everything\nelse, equivalent to assigning Nil or Empty in the case of arrays or hashes,\nwhose use is advised.\n\nControl routines\n\nRoutines that change the flow of the program, maybe returning a value.\n\n  sub exit\n\nDefined as:\n\n    multi sub exit()\n    multi sub exit(Int(Any) $status)\n\nExits the current process with return code $status or zero if no value has\nbeen specified. The exit value ($status), when different from zero, has to\nbe opportunely evaluated from the process that catches it (e.g., a shell);\nit is the only way to return an exit code different from zero from a Main.\n\nexit prevents the LEAVE phaser to be executed, but it will run the code in\nthe &*EXIT variable.\n\nexit should be used as last resort only to signal the parent process about\nan exit code different from zero, and not to terminate exceptionally a\nmethod or a sub: use exceptions instead.\n\n  sub done\n\nDefined as\n\n    sub done(--> Nil)\n\nIf used outside any supply or react block, throws an exception done without\nsupply or react. Within a Supply block, it will indicate the supply will no\nlonger emit anything. See also documentation on method done.\n\n    my $supply = supply {\n        for 1 .. 3 {\n            emit($_);\n        }\n        done;\n    }\n    $supply.tap( -> $v { say \"Second : $v\" }, done => { say \"No more\" });\n    # OUTPUT: OUTPUT: «Second : 1␤Second : 2␤Second : 3␤No More␤»\n\n\nThe block passed to the done named argument will be run when done is called\nwithin the supply block.",
      "name": "Independent routines"
    },
    {
      "desc": "TITLE\nrole Distribution\n\nSUBTITLE\nDistribution\n\n    role Distribution { }\n\nInterface for objects that provide API access mapping META6 data to the\nfiles its represents. Objects that fulfill the Distribution role can be\nread by e.g. CompUnit::Repository::Installation. Generally a Distribution\nprovides read access to a set of modules and metadata. These may be backed\nby the filesystem (Distribution::Path, Distribution::Hash) but could also\nread from an e.g. tar file or socket.\n\nRequired ",
      "name": "Distribution"
    },
    {
      "name": "UInt",
      "desc": "TITLE\nSubset UInt\n\nSUBTITLE\nUnsigned integer (arbitrary-precision)\n\nThe UInt is defined as a subset of Int:\n\n    my subset UInt of Int where {not .defined or $_ >= 0};\n\n\nConsequently, it cannot be instantiated or subclassed; however, that\nshouldn't affect most normal uses.\n\nSome examples of its behavior and uses:\n\n    say UInt ~~ Int; # OUTPUT: «True␤»\n    my UInt $u = 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff; # 64-bit unsigned value\n    say $u.base(16); # OUTPUT: «FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF␤» (32 digits)\n    ++$u;\n    say $u.base(16); # OUTPUT: «100000000000000000000000000000000␤» (33 digits!)\n    my Int $i = $u;\n    say $i.base(16); # same as above\n    say $u.^name;    # OUTPUT: «Int␤» - UInt is a subset, so the type is still Int.\n    say $i.^name;    # OUTPUT: «Int␤»\n    # Difference in assignment\n    my UInt $a = 5;  # nothing wrong\n    my UInt $b = -5; # Exception about failed type check\n    my UInt $c = 0;\n    --$c;            # Exception again\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $b; expected UInt but got Int (-5)␤»\n\n    # Non-assignment operations are fine\n    my UInt $d = 0;\n    say $d - 3;      # OUTPUT: «-3␤»"
    },
    {
      "desc": "TITLE\nclass ValueObjAt\n\nSUBTITLE\nUnique identification for value types\n\n    class ValueObjAt is ObjAt { }\n\nA subclass of ObjAt that should be used to indicate that a class produces\nobjects that are value types (in other words: are immutable after they have\nbeen initialized.\n\n    my %h = a => 42;        # mutable Hash\n    say %h.WHICH;           # OUTPUT: «ObjAt.new(\"Hash|1402...888\")␤»\n\n    my %m is Map = a => 42; # immutable Map\n    say %m.WHICH;           # OUTPUT: «ValueObjAt.new(\"Map|AAF...09F61F\")␤»\n\nIf you create a class that should be considered a value type, you should\nadd a WHICH method to that class that returns a ValueObjAt object, for\ninstance:\n\n    class YourClass {\n        has $.foo;  # note these are not mutable\n        has $.bar;\n\n        method WHICH() {\n            ValueObjAt.new(\"YourClass|$!foo|$!bar\");\n        }\n    }\n\nNote that it is customary to always start the identifying string with the\nname of the object, followed by a \"|\". This to prevent confusion with other\nclasses that may generate similar string values: the name of the class\nshould then be enough of a differentiator to prevent collisions.",
      "name": "ValueObjAt"
    },
    {
      "desc": "TITLE\nclass Code\n\nSUBTITLE\nCode object\n\n    class Code is Any does Callable {}\n\nCode is the ultimate base class of all code objects in Perl 6. It exposes\nfunctionality that all code objects have. While thunks are directly of type\nCode, most code objects (such as those resulting from blocks, subroutines\nor methods) will belong to some subclass of Code.\n\n",
      "name": "Code"
    },
    {
      "name": "Match",
      "desc": "TITLE\nclass Match\n\nSUBTITLE\nResult of a successful regex match\n\n    class Match is Capture is Cool does NQPMatchRole {}\n\nMatch objects are the result of a successful regex match, this does include\nany zero-width match. They store a reference to the original string\n(.orig), positional and named captures, the positions of the start and end\nof the match in the original string, and a payload referred to as AST\n(abstract syntax tree), which can be used to build data structures from\ncomplex regexes and grammars.\n\nThe last match is also stored in the $¢ Match object, which is lexically\nscoped to the regex, that is, only available from within the regular\nexpression, as shown here:\n\n    my $c;\n    'abc' ~~ /.$${ $c = $¢ }/;\n    say $c; # OUTPUT: «｢c｣␤»\n\nIn this case, we are running the code among curly braces when the match\noccurs, in this case the last letter in the string (actually, the last,\nindicated by the double $, character); $c gets the value of the cursor $¢,\nwhich contains the Match; when used with say, the Match is stringified by\ncalling .Str on it. This $¢ offers a way of capturing the Match inside a\nregular expression; outside, you need to use $/\n\n    my $c; 'camelia' ~~ /<[ l m ]> {$c = $¢}/;\n    say $c; # OUTPUT: «｢m｣␤»\n    say $/; # OUTPUT: «｢m｣␤»\n\nNote: This feature works only from Perl 6 version 2018.02. It would have\nreturned Nil with any previous version. Alternatively and prior to that\nversion, you could use $/ which, inside the regex, has the same value:\n\n    '123' ~~ / (\\d) { say $0; say $/; } \\d+ /; # OUTPUT: «｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n\nThe main difference between $/ and $¢ is scope: the latter only has a value\ninside the regex:\n\n    '123' ~~ / (\\d) { say $/; say $¢; } \\d+ /; # OUTPUT: «｢1｣␤ 0 => ｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n    say \"¢ → \", $¢, \"/ is $/\"; ; # OUTPUT: «¢ → Nil/ is 123␤»\n\n\nSubmatches are also Match objects (or lists of Match objects, if the\ncorresponding regex was quantified), so each match object can be seen as\nthe root of a tree of match objects.\n\nA Match object can also hold the result of a match in progress (while the\ngrammar engine is running), in which case the pos method returns the\ncurrent position. This view on Match objects is only visible if you call\ncode from within a regex.\n\nNote (deprecated): There is a synonym for this class, Cursor, defined as:\n\n    my constant Cursor = Match\n\nInitially, it was used to keep track of initial position in regex matches.\nIn current versions, it's an alias for Match.\n\n"
    },
    {
      "name": "IntStr",
      "desc": "TITLE\nclass IntStr\n\nSUBTITLE\nDual value integer and string\n\n    class IntStr is Int is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42>; say $f.^name; # OUTPUT: «IntStr␤»\n\nAs a subclass of both Int and Str, an IntStr will be accepted where either\nis expected. However, IntStr does not share object identity with Int- or\nStr-only variants:\n\n    my $int-str = <42>;\n    my Int $int = $int-str; # OK!\n    my Str $str = $int-str; # OK!\n    say 42 ∈ <42  55  1>;   # False; ∈ operator cares about object identity\n\n"
    },
    {
      "desc": "TITLE\nclass Failure\n\nSUBTITLE\nDelayed exception\n\n    class Failure is Nil { }\n\nA Failure is a soft or unthrown Exception, usually generated by calling\n&fail. It acts as a wrapper around an Exception object.\n\nSink (void) context causes a Failure to throw, i.e. turn into a normal\nexception. The use fatal pragma causes this to happen in all contexts\nwithin the pragma's scope. Inside try blocks, use fatal is automatically\nset, and you can disable it with no fatal.\n\nThat means that Failures are generally only useful in cases of code that\nnormally would produce an rvalue; Failures are more or less equivalent to\nExceptions in code that will frequently be called in sink context (i.e.,\nfor its side-effects, such as with say).\n\nSimilarly, you should generally use &fail only inside code that is normally\nexpected to return something.\n\nChecking a Failure for truth (with the Bool method) or definedness (with\nthe defined method) marks the failure as handled, and causes it not to\nthrow in sink context anymore.\n\nYou can call the handled method to check if a failure has been handled.\n\nCalling methods on unhandled failures propagates the failure. The\nspecification says the result is another Failure, in Rakudo it causes the\nfailure to throw.\n\nBecause a Failure is Nil, which is undefined, a common idiom for safely\nexecuting code that may fail uses a with/else statement:\n\n    sub may_fail( --> Numeric:D ) {\n      my $value = (^10).pick || fail \"Zero is unacceptable\";\n      fail \"Odd is also not okay\" if $value % 2;\n      return $value;\n    }\n\n    with may_fail() -> $value { # defined, so didn't fail\n      say \"I know $value isn't zero or odd.\"\n    } else { # undefined, so failed, and the Failure is the topic\n      say \"Uh-oh: {.exception.message}.\"\n    }\n\n\n",
      "name": "Failure"
    },
    {
      "name": "Systemic",
      "desc": "TITLE\nrole Systemic\n\nSUBTITLE\nInformation related to the build system\n\nBuilt-in class for providing built system related information. Usually\naccessed through dynamic variables mixing this role such as the $*KERNEL,\n$*VM, or $*PERL.\n\n"
    },
    {
      "desc": "TITLE\nclass Str\n\nSUBTITLE\nString of characters\n\n    class Str is Cool does Stringy { }\n\nBuilt-in class for strings. Objects of type Str are immutable, but read the\nFAQ to understand precisely what this means.\n\n",
      "name": "Str"
    },
    {
      "desc": "TITLE\nclass Whatever\n\nSUBTITLE\nPlaceholder for the value of an unspecified argument\n\n    class Whatever { }\n\nWhatever is a class whose objects don't have any explicit meaning; it gets\nits semantics from other routines that accept Whatever-objects as markers\nto do something special. Using the * literal as an operand creates a\nWhatever object.\n\nMuch of *'s charm comes from Whatever-currying. When * is used in term\nposition, that is, as an operand, in combination with most operators, the\ncompiler will transform the expression into a closure of type WhateverCode,\nwhich is actually a Block that can be used wherever Callables are\naccepted.\n\n    my $c = * + 2;          # same as   -> $x { $x + 2 };\n    say $c(4);              # OUTPUT: «6␤»\n\nMultiple * in one expression generate closures with as many arguments:\n\n    my $c = * + *;          # same as   -> $x, $y { $x + $y }\n\nUsing * in complex expressions will also generate closures:\n\n    my $c = 4 * * + 5;      # same as   -> $x { 4 * $x + 5 }\n\nCalling a method on * also creates a closure:\n\n    <a b c>.map: *.uc;      # same as    <a b c>.map: -> $char { $char.uc }\n\n\nAs mentioned before, not all operators and syntactic constructs curry * (or\nWhatever-stars) to WhateverCode. In the following cases, * will remain a\nWhatever object.\n\n  Exception        Example  What it does\n  comma            1, *, 2  generates a List with a * element\n  range operators  1 .. *   Range.new(:from(1), :to(*));\n  series operator  1 ... *  infinite list\n  assignment       $x = *   assign * to $x\n  binding          $x := *  bind * to $x\n  list repetition  1 xx *   generates an infinite list\n\n\nThe range operators are handled specially. They do not curry with\nWhatever-stars, but they do curry with WhateverCode\n\n    say (1..*).^name;       # OUTPUT: «Range␤»\n    say ((1..*-1)).^name;   # OUTPUT: «WhateverCode␤»\n\nThis allows all these constructs to work:\n\n    .say for 1..*;          # infinite loop\n\n\nand\n\n    my @a = 1..4;\n    say @a[0..*];           # OUTPUT: «(1 2 3 4)␤»\n    say @a[0..*-2];         # OUTPUT: «(1 2 3)␤»\n\nBecause Whatever-currying is a purely syntactic compiler transform, you\nwill get no runtime currying of stored Whatever-stars into WhateverCodes.\n\n    my $x = *;\n    $x + 2;   # Not a closure, dies because it can't coerce $x to Numeric\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller Numeric(Whatever: );\n    # none of these signatures match:␤\n    # (Mu:U \\v: *%_)»\n\n\nThe use cases for stored Whatever-stars involve those curry-exception cases\nmentioned above. For example, if you want an infinite series by default.\n\n    my $max    = potential-upper-limit() // *;\n    my $series = known-lower-limit() ... $max;\n\n\nA stored * will also result in the generation of a WhateverCode in the\nspecific case of smartmatch. Note that this is not actually the stored *\nwhich is being curried, but rather the * on the left-hand side.\n\n    my $constraint           = find-constraint() // *;\n    my $maybe-always-matcher = * ~~ $constraint;\n\n\nIf this hypothetical find-constraint were to have found no constraint,\n$maybe-always-matcher would evaluate to True for anything.\n\n    $maybe-always-matcher(555);      # True\n    $maybe-always-matcher(Any);      # True\n\n\nHyperWhatever's functionality is similar to Whatever, except it refers to\nmultiple values, instead of a single one.\n\n",
      "name": "Whatever"
    },
    {
      "desc": "TITLE\nclass Complex\n\nSUBTITLE\nComplex number\n\n    class Complex is Cool does Numeric {}\n\nRepresents a number in the complex plane.\n\nComplex objects are immutable.\n\nOperators\n\n  postfix i\n\nAdding a trailing i to a number literal makes it a Complex, for example:\n\n    say 2i;     # same as Complex.new(0, 2);\n    say 1-2e3i; # same as Complex.new(1, -2e3);\n\n",
      "name": "Complex"
    },
    {
      "name": "Stringy",
      "desc": "TITLE\nrole Stringy\n\nSUBTITLE\nString or object that can act as a string\n\n    role Stringy { ... }\n\nCommon role for string types (such as Str)."
    },
    {
      "name": "Positional",
      "desc": "TITLE\nrole Positional\n\nSUBTITLE\nObject that supports looking up values by index\n\n    role Positional { ... }\n\nRole for objects which support indexing them using postcircumfix:«[ ]»\n(usually list-like objects). Example types with Positional role include\nList, Array, Range, and Buf.\n\n"
    },
    {
      "desc": "TITLE\nclass NFKC\n\nSUBTITLE\nCodepoint string in Normal Form KC (compatibility composed)\n\n    class NFKC is Uni {}\n\nA Codepoint string in Unicode Normalization Form KC. It is created by\nCompatibility Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15.",
      "name": "NFKC"
    },
    {
      "name": "PredictiveIterator",
      "desc": "TITLE\nrole PredictiveIterator\n\nSUBTITLE\nIterators that can predict number of values\n\nA PredictiveIterator is a special kind of Iterator that can know how many\nvalues it will (still) generate without actually needing to generate those\nvalues.\n\nThe main addition to the API of the Iterator role, is the count-only\nmethod, which should return the number of values the Iterator is still able\nto generate.\n\nThe other addition is the bool-only method, that should return a Bool\nindicating whether the Iterator is still capable of producing values (aka,\nis not exhausted yet). By default, this is the Booleanification of the\nresult of the call to the count-only method.\n\n"
    },
    {
      "desc": "TITLE\nrole Callable\n\nSUBTITLE\nInvocable code object\n\n    role Callable { ... }\n\nRole for objects which support calling them. It's used in Block, Routine,\nSub, Method, Submethod and Macro types.\n\nCallables can be stored in &-sigiled containers, the default type\nconstraint of such a container is Callable.\n\n    my &a = {;}; # Empty block needs a semicolon\n    my &b = -> {};\n    my &c = sub () {};\n    sub foo() {};\n    my &d = &foo;\n\n",
      "name": "Callable"
    },
    {
      "desc": "TITLE\nclass Grammar\n\nSUBTITLE\nFormal grammar made up of named regexes\n\n    class Grammar is Match {}\n\nEvery type declared with grammar and not explicitly stating its superclass,\nbecomes a subclass of Grammar.\n\n    grammar Identifier {\n        token TOP       { <initial> <rest>* }\n        token initial   { <+myletter +[_]> }\n        token rest      { <+myletter +mynumber +[_]> }\n        token myletter  { <[A..Za..z]> }\n        token mynumber  { <[0..9]> }\n    }\n\n    say Identifier.isa(Grammar);                # OUTPUT: «True␤»\n    my $match = Identifier.parse('W4anD0eR96');\n    say ~$match;                                # OUTPUT: «W4anD0eR96␤»\n\nMore documentation on grammars is available.\n\n",
      "name": "Grammar"
    },
    {
      "desc": "TITLE\nclass Variable\n\nSUBTITLE\nObject representation of a variable for use in traits\n\n    class Variable {}\n\nVariables have a wealth of compile-time information, but at runtime,\naccesses to a variable usually act on the value stored inside it, not the\nvariable itself. The runtime class of a variable is Scalar.\n\nClass Variable holds the compile-time information that traits can use to\nintrospect and manipulate variables.\n\nTraits\n\n  trait is default\n\nSets the default value with which a variable is initialized, and to which\nit is reset when Nil is assigned to it. Trait arguments are evaluated at\ncompile time. Closures won't do what you expect: they are stored as is and\nneed to be called by hand.\n\n    my Int $x is default(42);\n    say $x;     # OUTPUT: «42␤»\n    $x = 5;\n    say $x;     # OUTPUT: «5␤»\n    # explicit reset:\n    $x = Nil;\n    say $x;     # OUTPUT: «42␤»\n\nThe trait is default can be used also with subscripting things like arrays\nand hashes:\n\n    my @array is default( 'N/A' );\n    @array[22].say;  # OUTPUT: N/A\n    @array = Nil;\n    @array.say;      # OUTPUT: [N/A]\n    @array[4].say;   # OUTPUT: N/A\n\n    my %hash is default( 'no-value-here' );\n    %hash<non-existent-key>.say; # OUTPUT: no-value-here\n    %hash<foo> = 'bar';\n    %hash<>.say;                 # OUTPUT: {foo => bar}\n    %hash<wrong-key>.say;        # OUTPUT: no-value-here\n\n\n  trait is dynamic\n\n    multi sub trait_mod:<is>(Variable:D, :$dynamic)\n\nMarks a variable as dynamic, that is, accessible from inner dynamic scopes\nwithout being in an inner lexical scope.\n\n    sub introspect() {\n        say $CALLER::x;\n    }\n    my $x is dynamic = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Caller::NotDynamic\n    }\n\n\nThe is dynamic trait is a rather cumbersome way of creating and accessing\ndynamic variables. A much easier way is to use the * twigil:\n\n    sub introspect() {\n        say $*x;\n    }\n    my $*x = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Dynamic::NotFound\n    }\n\n\n  trait of\n\n    multi sub trait_mod:<of>(Mu:U $target, Mu:U $type)\n\nSets the type constraint of a container bound to a variable.\n\n    my $i of Int = 42;\n    $i = \"forty plus two\";\n    CATCH { default { say .^name, ' ', .Str } }\n    # OUTPUT: «X::TypeCheck::Assignment Type check failed in assignment to $i; expected Int but got Str (\"forty plus two\")␤»\n\nYou can use any value defined in compile time as a type constraint,\nincluding constants:\n\n    constant \\T = Int;\n    my $i of T = 42;\n\nwhich would be equivalent to the previous definition.\n\n",
      "name": "Variable"
    },
    {
      "desc": "TITLE\nclass Date\n\nSUBTITLE\nCalendar date\n\n    class Date { }\n\nA Date is an immutable object identifying a day in the Gregorian calendar.\n\nDate objects support addition and subtraction of integers, where an integer\nis interpreted as the number of days. You can compare Date objects with the\nnumeric comparison operators ==, <, <=, >, >=, != . Their stringification\nin YYYY-MM-DD format means that comparing them with the string operators\neq, lt, le etc. also gives the right result.\n\nDate.today creates an object the current day according to the system\nclock.\n\n    my $d = Date.new(2015, 12, 24); # Christmas Eve!\n    say $d;                         # OUTPUT: «2015-12-24␤»\n    say $d.year;                    # OUTPUT: «2015␤»\n    say $d.month;                   # OUTPUT: «12␤»\n    say $d.day;                     # OUTPUT: «24␤»\n    say $d.day-of-week;             # OUTPUT: «4␤» (Thursday)\n    say $d.later(days => 20);       # OUTPUT: «2016-01-13␤»\n    my $n = Date.new('2015-12-31'); # New Year's Eve\n    say $n - $d;                    # OUTPUT: «7␤», 7 days between New Years/Christmas Eve\n    say $n + 1;                     # OUTPUT: «2016-01-01␤»\n\nNote since version 6.d, .perl can be called on Date.\n\n",
      "name": "Date"
    },
    {
      "desc": "TITLE\nrole Associative\n\nSUBTITLE\nObject that supports looking up values by key\n\n    role Associative[::TValue = Mu, ::TKey = Str(Any)] { }\n\nA common role for types that support name-based lookup through\npostcircumfix:<{ }>, for example Hash and Map. It is used for type checks\nin operators that expect to find specific methods to call. See Subscripts\nfor details.\n\nThe % sigil restricts variables to objects that do Associative, so you will\nhave to mix in that role if you want to use it for your classes.\n\n    class Whatever {};\n    my %whatever := Whatever.new;\n    # OUTPUT: «Type check failed in binding; expected Associative but got Whatever\n\n\nPlease note that we are using binding := here, since by default %\nassignments expect a Hash in the right-hand side. However, with the\nAssociative role:\n\n    class Whatever is Associative {};\n    my %whatever := Whatever.new;\n\nwill be syntactically correct.\n\n",
      "name": "Associative"
    },
    {
      "desc": "TITLE\nclass Supply\n\nSUBTITLE\nAsynchronous data stream with multiple subscribers\n\n    class Supply {}\n\nA supply is a thread-safe, asynchronous data stream like a Channel, but it\ncan have multiple subscribers (taps) that all get the same values flowing\nthrough the supply.\n\nIt is a thread-safe implementation of the Observer Pattern, and central to\nsupporting reactive programming in Perl 6.\n\nThere are two types of Supplies: live and on demand. When tapping into a\nlive supply, the tap will only see values that are flowing through the\nsupply after the tap has been created. Such supplies are normally infinite\nin nature, such as mouse movements. Closing such a tap does not stop mouse\nevents from occurring, it just means that the values will go by unseen. All\ntappers see the same flow of values.\n\nA tap on an on demand supply will initiate the production of values, and\ntapping the supply again may result in a new set of values. For example,\nSupply.interval produces a fresh timer with the appropriate interval each\ntime it is tapped. If the tap is closed, the timer simply stops emitting\nvalues to that tap.\n\nA live Supply is obtained from the Supplier factory method Supply. New\nvalues are emitted by calling emit on the Supplier object.\n\n    my $supplier = Supplier.new;\n    my $supply = $supplier.Supply;\n    $supply.tap(-> $v { say \"$v\" });\n    $supplier.emit(42); # Will cause the tap to output \"42\"\n\nThe live method returns True on live supplies. Factory methods such as\ninterval, from-list will return on demand supplies.\n\nA live Supply that keeps values until tapped the first time can be created\nwith Supplier::Preserving.\n\nFurther examples can be found in the concurrency page.\n\n",
      "name": "Supply"
    },
    {
      "desc": "TITLE\nclass Set\n\nSUBTITLE\nImmutable collection of distinct objects\n\n    class Set does Setty { }\n\nA Set is an immutable set, meaning a collection of distinct elements in no\nparticular order. (For mutable sets, see SetHash instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = set <peach apple orange apple apple>;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSets can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the value True for keys that are elements of the set, and\nFalse for keys that aren't:\n\n    my $fruits = set <peach apple orange apple apple>;\n    say $fruits<apple>;  # OUTPUT: «True␤»\n    say $fruits<kiwi>;   # OUTPUT: «False␤»\n\nCreating Set objects\n\nSets can be composed using the set subroutine (or Set.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the set:\n\n    my $n = set \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .Set coercer (or its functional form, Set()) can be\ncalled on an existing object to coerce it to a Set. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a set with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the set - and keys mapped to values which boolify to False are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).Set;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nFurthermore, you can get a Set by using set operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Set on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (^) 4;  # OUTPUT: «set(1, 2, 3, 5)␤»\n\nOf course, you can also create a Set with the .new method.\n\n    my $fruits = Set.new( <peach apple orange apple apple> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Set, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Set\n    my $fruits = Set[Str].new( <peach apple orange apple apple> );\n\n    # only allow whole numbers (Int) in the Set\n    my $fruits = Set[Int].new( <peach apple orange apple apple> );\n    # Type check failed in binding; expected Int but got Str (\"peach\")\n\nFinally, you can create Set masquerading as a hash by using the is trait:\n\n    my %s is Set = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %s is Set[Str] = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\n    # limit to whole numbers\n    my %s is Set[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nPerl 6 provides common set operators, which can take Sets (or any other\ncollections) as input, and return result sets as new Set objects. For\nexample:\n\n    my ($a, $b) = set(1, 2, 3), set(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSubroutines\n\n  sub set\n\n    sub set(*@args --> Set)\n\nCreates a Set from the given @args\n\nSee Also\n\nSets, Bags, and Mixes",
      "name": "Set"
    },
    {
      "name": "Endian",
      "desc": "TITLE\nenum Endian\n\nSUBTITLE\nIndicate endianness (6.d, 2018.12 and later)\n\n    enum Endian <NativeEndian LittleEndian BigEndian>;\n\n    An enum for indicating endianness, specifically with methods on blob8\nand buf8. Consists of NativeEndian, LittleEndian and BigEndian.\n\n"
    },
    {
      "name": "Junction",
      "desc": "TITLE\nclass Junction\n\nSUBTITLE\nLogical superposition of values\n\n    class Junction is Mu { }\n\nA junction is an unordered composite value of zero or more values.\nJunctions autothread over many operations, which means that the operation\nis carried out for each junction element (also known as eigenstate), and\nthe result is junction of the return values of all those operators.\n\nJunctions collapse into a single value in boolean context, so when used in\na conditional, a negation or an explicit coercion to Bool through the so or\n? prefix operators. The semantics of this collapse depend on the junction\ntype, which can be all, any, one or none.\n\n  type  constructor  operator  True if ...\n  all   all          &         no value evaluates to False\n  any   any          |         at least one value evaluates to True\n  one   one          ^         exactly one value evaluates to True\n  none  none                   no value evaluates to True\n\n\nAs the table shows, in order to create junctions, you use the string that\nrepresents the type followed by any object, or else call .all, .none or\n.one on the object.\n\n    say so 3 == (1..30).one;         # OUTPUT: «True␤»\n    say so (\"a\" ^ \"b\" ^ \"c\") eq \"a\"; # OUTPUT: «True␤»\n\nJunctions are very special objects. They fall outside the Any hierarchy,\nbeing only, as any other object, subclasses of Mu. That enables a feature\nfor most methods: autothreading. Autothreading happens when a junction is\nbound to a parameter of a code object that doesn't accept values of type\nJunction. Instead of producing an error, the signature binding is repeated\nfor each value of the junction.\n\nExample:\n\n    my $j = 1|2;\n    if 3 == $j + 1 {\n        say 'yes';\n    }\n\nFirst autothreads over the infix:<+>  operator, producing the Junction 2|3.\nThe next autothreading step is over infix:<==> , which produces False|True.\nThe if conditional evaluates the junction in boolean context, which\ncollapses it to True. So the code prints yes\\n.\n\nThe type of a Junction does not affect the number of items in the resultant\nJunction after autothreading. For example, using a one Junction during Hash\nkey lookup, still results in a Junction with several items. It is only in\nboolean context would the type of the Junction come into play:\n\n    my %h = :42foo, :70bar;\n    say    %h{one <foo meow>}:exists; # OUTPUT: «one(True, False)␤»\n    say so %h{one <foo meow>}:exists; # OUTPUT: «True␤»\n    say    %h{one <foo  bar>}:exists; # OUTPUT: «one(True, True)␤»\n    say so %h{one <foo  bar>}:exists; # OUTPUT: «False␤»\n\nNote that the compiler is allowed, but not required, to parallelize\nautothreading (and Junction behavior in general), so it is usually an error\nto autothread junctions over code with side effects.\n\nAutothreading implies that the function that's autothreaded will also\nreturn a Junction of the values that it would usually return.\n\n    (1..3).head( 2|3 ).say; # OUTPUT: «any((1 2), (1 2 3))␤»\n\nSince .head returns a list, the autothreaded version returns a Junction of\nlists.\n\n    (1..3).contains( 2&3 ).say; # OUTPUT: «all(True, True)␤»\n\nLikewise, .contains returns a Boolean; thus, the autothreaded version\nreturns a Junction of Booleans. In general, all methods and routines that\ntake an argument of type T and return type TT, will also accept junctions\nof T, returning junctions of TT.\n\nImplementations are allowed to short-circuit Junctions. For example one or\nmore routine calls (a(), b(), or c()) in the code below might not get\nexecuted at all, if the result of the conditional has been fully determined\nfrom routine calls already performed (only one truthy return value is\nenough to know the entire Junction is true):\n\n    if a() | b() | c() {\n        say \"At least one of the routines was called and returned a truthy value\"\n    }\n\n\nJunctions are meant to be used as matchers in boolean context;\nintrospection of junctions is not supported. If you feel the urge to\nintrospect a junction, use a Set or a related type instead.\n\nUsage examples:\n\n    my @list = <1 2 \"Great\">;\n    @list.append(True).append(False);\n    my @bool_or_int = grep Bool|Int, @list;\n\n    sub is_prime(Int $x) returns Bool {\n        # 'so' is for boolean context\n        so $x %% none(2..$x.sqrt);\n    }\n    my @primes_ending_in_1 = grep &is_prime & / 1$ /, 2..100;\n    say @primes_ending_in_1;        # OUTPUT: «[11 31 41 61 71]␤»\n\n    my @exclude = <~ .git>;\n    for dir(\".\") { say .Str if .Str.ends-with(none @exclude) }\n\nSpecial care should be taken when using all with arguments that may produce\nan empty list:\n\n    my @a = ();\n    say so all(@a) # True, because there are 0 False's\n\nTo express \"all, but at least one\", you can use @a && all(@a)\n\n    my @a = ();\n    say so @a && all(@a);   # OUTPUT: «False␤»\n\nNegated operators are special-cased when it comes to autothreading. $a !op\n$b is rewritten internally as !($a op $b). The outer negation collapses any\njunctions, so the return value always a plain Bool.\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word !eq any @negations {\n        say '\"yes\" is not a negation';\n    }\n\nNote that without this special-casing, an expression like $word ne any\n@words would always evaluate to True for non-trivial lists on one side.\n\nFor this purpose, infix:<ne>  counts as a negation of infix:<eq> .\n\nIn general it is more readable to use a positive comparison operator and a\nnegated junction:\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word eq none @negations {\n        say '\"yes\" is not a negation';\n    }\n\nFailures and exceptions\n\nFailures are just values like any other, as far as Junctions are\nconcerned:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    my @list = gather for $j -> $e {\n        take $e if $e.defined;\n    }\n    @list.say; # OUTPUT: «[42 2.1]␤»\n\nAbove, we've used prefix + operator on a Junction to coerce the strings\ninside of it to Numeric. Since the operator returns a Failure when a Str\nthat doesn't contain a number gets coerced to Numeric, one of the elements\nin the Junction is a Failure. Failures do not turn into exceptions until\nthey are used or sunk, but we can check for definedness to avoid that. That\nis what we do in the loop that runs over the elements of the junction,\nadding them to a list only if they are defined.\n\nThe exception will be thrown, if you try to use the Failure as a value—just\nlike as if this Failure were on its own and not part of the Junction:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    try say $j == 42;\n    $! and say \"Got exception: $!.^name()\";\n    # OUTPUT: «Got exception: X::Str::Numeric␤»\n\n\nNote that if an exception gets thrown when any of the values in a Junction\nget computed, it will be thrown just as if the problematic value were\ncomputed on its own and not with a Junction; you can't just compute the\nvalues that work while ignoring exceptions:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    say try calc $j; # OUTPUT: «Nil␤»\n\nOnly one value above causes an exception, but the result of the try block\nis still a Nil. A possible way around it is to cheat and evaluate the\nvalues of the Junction individually and then re-create the Junction from\nthe result:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    $j = any (gather $j».take).grep: {Nil !=== try calc $_};\n    say so $j == 42; # OUTPUT: «True␤»\n\nSmartmatching\n\nNote that using Junctions on the right-hand side of ~~ works slightly\ndifferently than using Junctions with other operators.\n\nConsider this example:\n\n    say 25 == (25 | 42);    # OUTPUT: «any(True, False)␤» – Junction\n    say 25 ~~ (25 | 42);    # OUTPUT: «True␤»             – Bool\n\nThe reason is that == (and most other operators) are subject to\nauto-threading, and therefore you will get a Junction as a result. On the\nother hand, ~~ will call .ACCEPTS on the right-hand-side (in this case on a\nJunction) and the result will be a Bool.\n\n"
    },
    {
      "desc": "TITLE\nclass Bag\n\nSUBTITLE\nImmutable collection of distinct objects with integer weights\n\n    class Bag does Baggy { }\n\nA Bag is an immutable bag/multiset implementing Associative, meaning a\ncollection of distinct elements in no particular order that each have an\ninteger weight assigned to them signifying how many copies of that element\nare considered \"in the bag\". (For mutable bags, see BagHash instead.)\n\nBags are often used for performing weighted random selections - see .pick\nand .roll.\n\nObjects/values of any type are allowed as bag elements. Within a Bag, items\nthat would compare positively with the === operator are considered the same\nelement, with the number of how many there are as its weight. But of course\nyou can also easily get back the expanded list of items (without the\norder):\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBags can be treated as object hashes using the { } postcircumfix operator,\nor the < >  operator for literal string keys, which returns the\ncorresponding integer weight for keys that are elements of the bag, and 0\nfor keys that aren't:\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n    say $breakfast<bacon>;    # OUTPUT: «1␤»\n    say $breakfast<spam>;     # OUTPUT: «4␤»\n    say $breakfast<sausage>;  # OUTPUT: «0␤»\n\nCreating Bag objects\n\nBags can be composed using the bag subroutine (or Bag.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the bag:\n\n    my $n = bag \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:c(2), :b(1), :a(0)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n    say $n.values.perl;      # OUTPUT: «(2, 1, 1).Seq␤»\n\nAlternatively, the .Bag coercer (or its functional form, Bag()) can be\ncalled on an existing object to coerce it to a Bag. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a bag with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the bag, and the (cumulative) values become the associated integer\nweights:\n\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).Bag;\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nFurthermore, you can get a Bag by using bag operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Bag on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (+) 4;  # OUTPUT: «bag(1, 2, 3, 4(2), 5)␤»\n\nOf course, you can also create a Bag with the .new method.\n\n    my $breakfast = Bag.new( <spam eggs spam spam bacon spam> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Bag, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Bag\n    my $breakfast = Bag[Str].new( <spam eggs spam spam bacon spam> );\n\n    # only allow whole numbers (Int) in the Bag\n    my $breakfast = Bag[Int].new( <spam eggs spam spam bacon spam> );\n    # Type check failed in binding; expected Int but got Str (\"spam\")\n\nFinally, you can create Bag masquerading as a hash by using the is trait:\n\n    my %b is Bag = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %b is Bag[Str] = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\n    # limit to whole numbers\n    my %b is Bag[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nPerl 6 provides common set and bag operators, which can take Bags (or any\nother collections) as input, and return result as Bool, Set or Bag values.\nFor example:\n\n    my ($a, $b) = bag(2, 2, 4), bag(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nSubroutines\n\n  sub bag\n\n    sub bag(*@args --> Bag)\n\nCreates a new Bag from @args.\n\nNote on reverse and ordering\n\nThis method is inherited from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nSee also\n\nSets, Bags, and Mixes",
      "name": "Bag"
    },
    {
      "name": "StrDistance",
      "desc": "TITLE\nclass StrDistance\n\nSUBTITLE\nContains the result of a string transformation.\n\nStrDistance objects are used to represent the return of the string\ntransformation operator.\n\n    say (($ = \"fold\") ~~ tr/old/new/).^name;  # OUTPUT: «StrDistance␤»\n\nA StrDistance object will stringify to the resulting string after the\ntransformation, and will numify to the distance between the two strings.\n\n    my $str = \"fold\";\n    my $str-dist = ($str ~~ tr/old/new/);\n    say ~$str-dist;  # OUTPUT: «fnew␤»\n    say +$str-dist;  # OUTPUT: «3␤»\n\n\n"
    },
    {
      "name": "Encoding",
      "desc": "TITLE\nrole Encoding\n\nSUBTITLE\nSupport for character encodings.\n\n    role Encoding { ... }\n\nThe Encoding role is implemented by classes that provide a character\nencoding, such as ASCII or UTF-8. Besides being used by the built-in\ncharacter encodings, it may also be implemented by users to provide new\nencodings. Instances of objects doing this role are typically obtained\nusing Encoding::Registry. For a list of supported encodings, see\nIO::Handle.\n\nAll methods provided by this role are stubs; they should be implemented by\nconsumers of the role.\n\n"
    },
    {
      "desc": "TITLE\nclass Cancellation\n\nSUBTITLE\nRemoval of a task from a Scheduler before normal completion\n\n    my class Cancellation {}\n\nA low level part of the Perl 6 concurrency system. Some Scheduler objects\nreturn a Cancellation with the .cue method which can be used to cancel the\nscheduled execution before normal completion. Cancellation.cancelled is a\nboolean that is true after #cancel is called.\n\n",
      "name": "Cancellation"
    },
    {
      "name": "Attribute",
      "desc": "TITLE\nclass Attribute\n\nSUBTITLE\nMember variable\n\n    class Attribute { }\n\nIn Perl 6 lingo, an attribute refers to a per-instance/object storage slot.\nAn Attribute is used to talk about classes' and roles' attributes at the\nmetalevel.\n\nNormal usage of attributes does not require the user to use this class\nexplicitly.\n\nTraits\n\n  Trait is default\n\nAn attribute that is assigned Nil will revert to its default value set with\nthe trait is default. In the case of arrays or associatives, the argument\nof is default will set the default item value or hash value.\n\n    class C {\n        has $.a is default(42) is rw = 666\n    }\n    my $c = C.new;\n    say $c;\n    $c.a = Nil;\n    say $c;\n    # OUTPUT: «C.new(a => 666)␤C.new(a => 42)␤»\n\n  Trait is required\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute $attr, :$required!)\n\nThe trait is required will mark the attribute as to be filled with a value\nwhen the object is instantiated. Failing to do so will result in a runtime\nerror.\n\n    class C {\n        has $.a is required\n    }\n    my $c = C.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required, but you did not provide a value for it.␤»\n\nAvailable as of 6.d language version (early implementation exists in Rakudo\ncompiler 2018.08+): You can specify a reason why the attribute is\nrequired:\n\n    class D {\n        has $.a is required(\"it is a good idea\");\n    }\n    my $d = D.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required because it is a good idea,␤but you did not provide a value for it.␤»\n\n\nis required doesn't just affect the default constructor, it checks for the\nattribute at a lower level, so it will work for custom constructors written\nusing bless.\n\n  trait is DEPRECATED\n\n    multi sub trait_mod:<is>(Attribute:D $r, :$DEPRECATED!)\n\nMarks an attribute as deprecated, optionally with a message what to use\ninstead.\n\n    class C {\n        has $.foo is DEPRECATED(\"'bar'\");\n    }\n    my $c = C.new( foo => 42 );  # doesn't trigger with initialization (yet)\n    say $c.foo;                  # does trigger on usage\n\nAfter the program is finished, this will show something like this on\nSTDERR:\n\n    # Saw 1 occurrence of deprecated code.\n    # =====================================\n    # Method foo (from C) seen at:\n    # script.p6, line 5\n    # Please use 'bar' instead.\n\n  trait is rw\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute:D $attr, :$rw!)\n\nMarks an attribute as read/write as opposed to the default readonly. The\ndefault accessor for the attribute will return a writable value.\n\n    class Boo {\n       has $.bar is rw;\n       has $.baz;\n    };\n\n    my $boo = Boo.new;\n    $boo.bar = 42; # works\n    $boo.baz = 42;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\n"
    },
    {
      "desc": "TITLE\nclass HyperWhatever\n\nSUBTITLE\nPlaceholder for multiple unspecified values/arguments\n\n    class HyperWhatever { }\n\nHyperWhatever is very similar in functionality to Whatever. The difference\nlies in HyperWhatever standing in for multiple values, rather than a single\none.\n\nStandalone term\n\nJust like with Whatever, if a HyperWhatever is used as a term on its own,\nno currying is done and the HyperWhatever object will be used as-is:\n\n    sub foo ($arg) { say $arg.^name }\n    foo **; # OUTPUT: «HyperWhatever␤»\n\nYou can choose to interpret such a value as standing for multiple values in\nyour own routines. In core, a HyperWhatever can be used with this meaning\nwhen smartmatching with Lists:\n\n    say (1, 8)                ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 4, 5, 6, 7, 8) ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 8, 9)          ~~ (1, **, 8); # OUTPUT: «False␤»\n\nWherever a HyperWhatever appears in the list on the right-hand side means\nany number of elements can fill that space in the list being smartmatched.\n\nCurrying\n\nWhen it comes to currying, the HyperWhatever follows the same rules as\nWhatever. The only difference is HyperWhatever produces a Callable with a\n*@ slurpy as a signature:\n\n    say (**²)(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nA HyperWhatever closure can be imagined as a Whatever closure with another\nsub wrapped around it that simply maps each element in the arguments over:\n\n    my &hyper-whatever = sub (*@args) { map *², @args }\n    say hyper-whatever(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nWhen currying, mixing HyperWhatever with Whatever is not permitted.",
      "name": "HyperWhatever"
    },
    {
      "name": "QuantHash",
      "desc": "TITLE\nrole QuantHash\n\nSUBTITLE\nObject hashes with limitation on type of value\n\n    role QuantHash does Associative { }\n\nThe QuantHash role provides the basic functionality shared by the Setty,\nBaggy and Mixy roles. These provide object hashes of which the values are\nlimited in some way.\n\nQuantHashes are what set operators use internally.\n\n"
    },
    {
      "name": "Baggy",
      "desc": "TITLE\nrole Baggy\n\nSUBTITLE\nCollection of distinct weighted objects\n\n    role Baggy does QuantHash { }\n\nA role for collections of weighted objects. See Bag, BagHash, and Mixy.\n\n"
    },
    {
      "name": "Regex",
      "desc": "TITLE\nclass Regex\n\nSUBTITLE\nString pattern\n\n    class Regex is Method { }\n\nA regex is a kind of pattern that describes a set of strings. The process\nof finding out whether a given string is in the set is called matching. The\nresult of such a matching is a Match object, which evaluates to True in\nboolean context if the string is in the set.\n\nA regex is typically constructed by a regex literal\n\n    rx/ ^ab /;      # describes all strings starting with 'ab'\n    / ^ ab /;       # same\n    rx/ \\d ** 2/;   # describes all strings containing at least two digits\n\n A named regex can be defined with the regex declarator followed by its\ndefinition in curly braces. Since any regex does Callable introspection\nrequires referencing via &-sigil.\n\n    my regex R { \\N };\n    say &R.^name; # OUTPUT: «Regex␤»\n\nTo match a string against a regex, you can use the smartmatch operator:\n\n    my $match = 'abc' ~~ rx/ ^ab /;\n    say $match.Bool;                # OUTPUT: «True␤»\n    say $match.orig;                # OUTPUT: «abc␤»\n    say $match.Str;                 # OUTPUT: «ab␤»\n    say $match.from;                # OUTPUT: «0␤»\n    say $match.to;                  # OUTPUT: «2␤»\n\nOr you can evaluate the regex in boolean context, in which case it matches\nagainst the $_ variable\n\n    $_ = 'abc';\n    if / ^ab / {\n        say '\"abc\" begins with \"ab\"';\n    }\n    else {\n        say 'This is a weird alternative Universe';\n    }\n\n"
    },
    {
      "desc": "TITLE\nclass CompUnit\n\nSUBTITLE\nCompUnit\n\n    class CompUnit {}\n\nThe CompUnit represents the metainformation about a compilation unit. This\nusually relates to source code that resides in a file on a filesystem,\nrather than code that is executed using an EVAL statement.\n\n",
      "name": "CompUnit"
    },
    {
      "name": "ObjAt",
      "desc": "TITLE\nclass ObjAt\n\nSUBTITLE\nUnique identification for an object\n\n    class ObjAt is Any {}\n\nObjects of type ObjAt are the return value of .WHICH calls on other\nobjects, and identify an object uniquely.\n\nIf two objects compare equally via ===, their .WHICH methods return the\nsame ObjAt object.\n\nSee also ValueObjAt for value types.\n\n"
    },
    {
      "name": "utf8",
      "desc": "TITLE\nclass utf8\n\nSUBTITLE\nMutable uint8 buffer for utf8 binary data\n\n    class utf8 does Blob[uint8] is repr('VMArray') {}\n\nA utf8 is a subtype of Blob which is specifically uint8 data for holding\nUTF-8 encoded text.\n\n    my utf8 $b = \"hello\".encode;\n    say $b[1].fmt(\"0x%X\"); # OUTPUT: «0x65␤»"
    },
    {
      "name": "BagHash",
      "desc": "TITLE\nclass BagHash\n\nSUBTITLE\nMutable collection of distinct objects with integer weights\n\n    class BagHash does Baggy { }\n\nA BagHash is a mutable bag/multiset, meaning a collection of distinct\nelements in no particular order that each have an integer weight assigned\nto them signifying how many copies of that element are considered \"in the\nbag\". (For immutable bags, see Bag instead.)\n\nObjects/values of any type are allowed as bag elements. Within a BagHash,\nitems that would compare positively with the === operator are considered\nthe same element, with the number of how many there were as its weight. But\nof course you can also easily get back the expanded list of items (without\nthe order):\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBagHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding integer weight for keys that are\nelements of the bag, and 0 for keys that aren't. It can also be used to\nmodify weights; setting a weight to 0 automatically removes that element\nfrom the bag, and setting a weight to a positive number adds that element\nif it didn't already exist:\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n    say $breakfast<bacon>;     # OUTPUT: «1␤»\n    say $breakfast<spam>;      # OUTPUT: «4␤»\n    say $breakfast<sausage>;   # OUTPUT: «0␤»\n\n    $breakfast<sausage> = 2;\n    $breakfast<bacon>--;\n    say $breakfast.kxxv.sort;  # OUTPUT: «eggs sausage sausage spam spam spam spam␤»\n\n\nCreating BagHash objects\n\nBagHashes can be composed using BagHash.new. Any positional parameters,\nregardless of their type, become elements of the bag:\n\n    my $n = BagHash.new: \"a\", \"b\", \"c\", \"c\";\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"a\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 1, 2).Seq␤»\n\nBesides, BagHash.new-from-pairs can create a BagHash with items and their\noccurrences.\n\n    my $n = BagHash.new-from-pairs: \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nAlternatively, the .BagHash coercer (or its functional form, BagHash()) can\nbe called on an existing object to coerce it to a BagHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a bag with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the bag, and the (cumulative) values become the\nassociated integer weights:\n\n    my $m = (\"a\", \"b\", \"c\", \"c\").BagHash;\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).BagHash;\n    say $m.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n\nYou can also create BagHash masquerading as a hash by using the is trait:\n\n    my %bh is BagHash = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a BagHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = BagHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %bh is BagHash[Str] = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\n    # only allow whole numbers\n    my %bh is BagHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nPerl 6 provides common set and bag operators, which can take BagHashes (or\nany other collections) as input, and return result as Bool, Set or Bag\nvalues. For example:\n\n    my ($a, $b) = BagHash.new(2, 2, 4), BagHash.new(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nBagHash inherits reverse from Any, however, Bags do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a BagHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = BagHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «BagHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\nSee Also\n\nSets, Bags, and Mixes"
    },
    {
      "desc": "TITLE\nclass Semaphore\n\nSUBTITLE\nControl access to shared resources by multiple threads\n\n    class Semaphore { }\n\nProtect your shared code, data or device access using semaphores. An\nexample is a printer manager managing a pool of printers without the need\nof storing print jobs when all printers are occupied. The next job is just\nblocked until a printer becomes available.\n\n    class print-manager {\n      has Array $!printers;\n      has Semaphore $!print-control;\n\n      method BUILD( Int:D :$nbr-printers ) {\n        for ^$nbr-printers -> $pc {\n          $!printers[$pc] = { :name{\"printer-$pc\"} };\n        }\n\n        $!print-control .= new($nbr-printers);\n      }\n\n      method find-available-printer-and-print-it($job) { say \"Is printed!\"; }\n\n      method print( $print-job ) {\n        $!print-control.acquire;\n\n        self.find-available-printer-and-print-it($print-job);\n\n        $!print-control.release;\n      }\n    }\n\nAnother example is a protection around code updating sensitive data. In\nsuch a case the semaphore is typically initialized to 1.\n\nIt is important to have a release on every exit of your program! While this\nis obvious, it is easy to fall in traps such as throwing an exception\ncaused by some event. When the program dies there is no problem. When the\nexception is caught your program might eventually come back to the acquire\nmethod and will hang indefinitely.\n\n",
      "name": "Semaphore"
    },
    {
      "desc": "TITLE\nclass atomicint\n\nSUBTITLE\nInteger (native storage at the platform's atomic operation size)\n\n    class atomicint is Int is repr('P6int') { }\n\nAn atomicint is a native integer sized such that CPU-provided atomic\noperations can be performed upon it. On a 32-bit CPU it will typically be\n32 bits in size, and on an a 64-bit CPU it will typically be 64 bits in\nsize. It exists to allow writing portable code that uses atomic\noperations.\n\nNote: Rakudo releases before 2017.08 had no support for atomicints.\n\n    # Would typically only work on a 64-bit machine and VM build.\n    my int64 $active = 0;\n    $active⚛++;\n\n    # Would typically only work on a 32-bit machine and VM build.\n    my int32 $active = 0;\n    $active⚛++;\n\n    # Will work portably, though can only portably assume range of 32 bits.\n    my atomicint $active = 0;\n    $active⚛++;\n\nThe use of the atomicint type does not automatically provide atomicity; it\nmust be used in conjunction with the atomic operations.\n\n    # Correct (will always output 80000)\n    my atomicint $total = 0;\n    await start { for ^20000 { $total⚛++ } } xx 4;\n    say $total;\n\n    # *** WRONG *** due to lack of use of the atomicint type.\n    # Either works correctly or dies, depending on platform.\n    my int $total = 0;\n    await start { for ^20000 { $total⚛++ } } xx 4;\n    say $total;\n\n    # *** WRONG *** due to lack of use of the atomic increment operator.\n    my atomicint $total = 0;\n    await start { for ^20000 { $total++ } } xx 4;\n    say $total;\n\nRoutines\n\n  sub atomic-assign\n\nDefined as:\n\n    multi sub atomic-assign(atomicint $ is rw, int $value)\n    multi sub atomic-assign(atomicint $ is rw, Int() $value)\n\nPerforms an atomic assignment to a native integer, which may be in a\nlexical, attribute, or native array element. If $value cannot unbox to a\n64-bit native integer due to being too large, an exception will be thrown.\nIf the size of atomicint is only 32 bits, then an out of range $value will\nbe silently truncated. The atomic-assign routine ensures that any required\nbarriers are performed such that the changed value will be \"published\" to\nother threads.\n\n  sub atomic-fetch\n\nDefined as:\n\n    multi sub atomic-fetch(atomicint $ is rw)\n\nPerforms an atomic read of a native integer, which may live in a lexical,\nattribute, or native array element. Using this routine instead of simply\nusing the variable ensures that the latest update to the variable from\nother threads will be seen, both by doing any required hardware barriers\nand also preventing the compiler from lifting reads. For example:\n\n    my atomicint $i = 0;\n    start { atomic-assign($i, 1) }\n    while atomic-fetch($i) == 0 { }\n\nIs certain to terminate, while in:\n\n    my atomicint $i = 0;\n    start { atomic-assign($i, 1) }\n    while $i == 0 { }\n\nIt would be legal for a compiler to observe that $i is not updated in the\nloop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  sub atomic-fetch-inc\n\nDefined as:\n\n    multi sub atomic-fetch-inc(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore incrementing it. Overflow will wrap around silently.\n\n  sub atomic-fetch-dec\n\nDefined as:\n\n    multi sub atomic-fetch-dec(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore decrementing it. Overflow will wrap around silently.\n\n  sub atomic-fetch-add\n\nDefined as:\n\n    multi sub atomic-fetch-add(atomicint $ is rw, int $value)\n    multi sub atomic-fetch-add(atomicint $ is rw, Int() $value)\n\nPerforms an atomic addition on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore the addition was performed. Overflow will wrap around silently. If\n$value is too big to unbox to a 64-bit integer, an exception will be\nthrown. If $value otherwise overflows atomicint then it will be silently\ntruncated before the addition is performed.\n\n  sub atomic-fetch-sub\n\nDefined as:\n\n    multi sub atomic-fetch-sub(atomicint $ is rw, int $value)\n    multi sub atomic-fetch-sub(atomicint $ is rw, Int() $value)\n\nPerforms an atomic subtraction on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore the subtraction was performed. Underflow will wrap around silently.\nIf $value is too big to unbox to a 64-bit integer, an exception will be\nthrown. If $value otherwise overflows atomicint then it will be silently\ntruncated before the subtraction is performed.\n\n  sub atomic-inc-fetch\n\n    multi sub atomic-inc-fetch(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the increment. Overflow will wrap around silently.\n\n  sub atomic-dec-fetch\n\n    multi sub atomic-dec-fetch(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the decrement. Overflow will wrap around silently.\n\n  sub cas\n\nDefined as:\n\n    multi sub cas(atomicint $target is rw, int $expected, int $value)\n    multi sub cas(atomicint $target is rw, Int() $expected, Int() $value)\n    multi sub cas(atomicint $target is rw, &operation)\n\nPerforms an atomic compare and swap of the native integer value in location\n$target. The first two forms have semantics like:\n\n    my int $seen = $target;\n    if $seen == $expected {\n        $target = $value;\n    }\n    return $seen;\n\n\nExcept it is performed as a single hardware-supported atomic instruction,\nas if all memory access to $target were blocked while it took place.\nTherefore it is safe to attempt the operation from multiple threads without\nany other synchronization. For example:\n\n    my atomicint $master = 0;\n    await start {\n        if cas($master, 0, 1) == 0 {\n            say \"Master!\"\n        }\n    } xx 4\n\nWill reliably only ever print Master! one time, as only one of the threads\nwill be successful in changing the 0 into a 1.\n\nBoth $expected and $value will be coerced to Int and unboxed if needed. An\nexception will be thrown if the value cannot be represented as a 64-bit\ninteger. If the size of atomicint is only 32 bits then the values will be\nsilently truncated to this size.\n\nThe third form, taking a code object, will first do an atomic fetch of the\ncurrent value and invoke the code object with it. It will then try to do an\natomic compare and swap of the target, using the value passed to the code\nobject as $expected and the result of the code object as $value. If this\nfails, it will read the latest value, and retry, until a CAS operation\nsucceeds. Therefore, an atomic multiply of an atomicint $i by 2 could be\nimplemented as:\n\n    cas $i, -> int $current { $current * 2 }\n\n\nIf another thread changed the value while $current * 2 was being calculated\nthen the block would be called again with the latest value for a further\nattempt, and this would be repeated until success.\n\nOperators\n\n  infix ⚛=\n\n    multi sub infix:<⚛=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic assignment to a native integer, which may be in a\nlexical, attribute, or native array element. If $value cannot unbox to a\n64-bit native integer due to being too large, an exception will be thrown.\nIf the size of atomicint is only 32 bits, then an out of range $value will\nbe silently truncated. The ⚛= operator ensures that any required barriers\nare performed such that the changed value will be \"published\" to other\nthreads.\n\n  prefix ⚛\n\n    multi sub prefix:<⚛>(atomicint $ is rw)\n\nPerforms an atomic read of a native integer, which may live in a lexical,\nattribute, or native array element. Using this operator instead of simply\nusing the variable ensures that the latest update to the variable from\nother threads will be seen, both by doing any required hardware barriers\nand also preventing the compiler from lifting reads. For example:\n\n    my atomicint $i = 0;\n    start { $i ⚛= 1 }\n    while ⚛$i == 0 { }\n\nIs certain to terminate, while in:\n\n    my atomicint $i = 0;\n    start { $i ⚛= 1 }\n    while $i == 0 { }\n\nIt would be legal for a compiler to observe that $i is not updated in the\nloop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  prefix ++⚛\n\n    multi sub prefix:<++⚛>(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the increment. Overflow will wrap around silently.\n\n  postfix ⚛++\n\n    multi sub postfix:<⚛++>(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore incrementing it. Overflow will wrap around silently.\n\n  prefix --⚛\n\n    multi sub prefix:<--⚛>(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the decrement. Overflow will wrap around silently.\n\n  postfix ⚛--\n\n    multi sub postfix:<⚛-->(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore decrementing it. Overflow will wrap around silently.\n\n  infix ⚛+=\n\nDefined as:\n\n    multi sub infix:<⚛+=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛+=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic addition on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Evaluates to the result of the\naddition. Overflow will wrap around silently. If $value is too big to unbox\nto a 64-bit integer, an exception will be thrown. If $value otherwise\noverflows atomicint then it will be silently truncated before the addition\nis performed.\n\n  infix ⚛-=\n\nDefined as:\n\n    multi sub infix:<⚛-=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛-=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic subtraction on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Evaluates to the result of the\nsubtraction. Underflow will wrap around silently. If $value is too big to\nunbox to a 64-bit integer, an exception will be thrown. If $value otherwise\noverflows atomicint then it will be silently truncated before the\nsubtraction is performed.\n\n  infix ⚛−=\n\nSynonym for ⚛-= using U+2212 minus.",
      "name": "atomicint"
    },
    {
      "name": "Bool",
      "desc": "TITLE\nenum Bool\n\nSUBTITLE\nLogical boolean\n\n    enum Bool <False True>\n\n   An enum for boolean true/false decisions.\n\n"
    },
    {
      "name": "Proxy",
      "desc": "TITLE\nclass Proxy\n\nSUBTITLE\nItem container with custom storage and retrieval\n\n    class Proxy {}\n\nA Proxy is an object that allows you to set a hook that executes whenever a\nvalue is retrieved from a container (FETCH) or when it is set (STORE).\nPlease note that Proxy can introduce mutability at places where it would\nbreak behavior, e.g. in Hash keys.\n\nTo create a container that returns twice what was stored in it, you do\nsomething like this:\n\n    sub double() is rw {\n        my $storage = 0;\n        Proxy.new(\n            FETCH => method ()     { $storage * 2    },\n            STORE => method ($new) { $storage = $new },\n        )\n     }\n     my $doubled := double();\n     $doubled = 4;\n     say $doubled;       # OUTPUT: «8␤»\n\n"
    },
    {
      "name": "Real",
      "desc": "TITLE\nrole Real\n\nSUBTITLE\nNon-complex number\n\n    role Real does Numeric { ... }\n\nCommon role for non-Complex numbers.\n\n"
    },
    {
      "name": "AST",
      "desc": "TITLE\nclass AST\n\nSUBTITLE\nAbstract representation of a piece of source code\n\n    class AST { }\n\nAn AST or Abstract Syntax Tree is a partially processed representation of a\nprogram. ASTs are return values of the quasi quoting construct, and are\ntypically used within macros to generate code that is inserted in the\ncalling location of the macro.\n\nThere is no API defined for ASTs yet. Hopefully that will emerge as part of\nthe work on macros."
    },
    {
      "name": "Seq",
      "desc": "TITLE\nclass Seq\n\nSUBTITLE\nAn iterable, lazy sequence of values\n\n    class Seq is Cool does Iterable does PositionalBindFailover { }\n\nA Seq represents anything that can lazily produce a sequence of values. A\nSeq is born in a state where iterating it will consume the values. However,\ncalling .cache on a Seq will return a List that is still lazy, but stores\nthe generated values for later access. However, assigning a Seq to an array\nconsumes the Seq; alternatively, you can use the lazy statement prefix to\navoid it from being iterated during the assignment:\n\n    # The Seq created by gather ... take is consumed on the spot here.\n    my @a = gather do { say 'consuming...'; take 'one' };  # OUTPUT: «consuming...␤»\n\n    # The Seq here is only consumed as we iterate over @a later.\n    my @a = lazy gather do { say 'consuming...'; take 'one' };  # outputs nothing.\n    .say for @a;  # OUTPUT: «consuming...␤one␤»\n\n\nA typical use case is method lines in IO::Handle, which could use a lot of\nmemory if it stored all the lines read from the file. So\n\n    for open('README.md').lines -> $line {\n        say $line;\n    }\n\n\nwon't keep all lines from the file in memory.\n\nThis implies that you cannot iterate the same Seq object twice (otherwise\nit couldn't throw away old values), so this dies:\n\n    my @a = 1, 2, 3;\n    my @b = <a b c>;\n    my \\c = @a Z=> @b;\n    .say for c;\n    .say for c; # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Seq::Consumed: This Seq has already been iterated, and its values consumed\n    # (you might solve this by adding .cache on usages of the Seq, or\n    # by assigning the Seq into an array)»\n\nA high-level construct to generate a Seq is gather/take, as well as many\nbuilt-in methods like map and grep, low-level constructors to create a Seq\nfrom an iterator or from looping constructs are available too.\n\nCaution: No program should ever assume a Seq may only be iterated once even\nif not cached by the program. Caching is a volatile state exposed to the\ndeveloper as an optimization. The Seq may become cached by many operations,\nincluding calling perl on the Seq (if called prior to a non-cached\niteration). From version 6.d, you .perl can be called on consumed <Seq>. If\na program assumes a Seq can only iterate once, but then is later changed to\ncall one of these operations during the loop, that assumption will fail.\n\n"
    },
    {
      "desc": "TITLE\nclass Array\n\nSUBTITLE\nSequence of itemized values\n\n    class Array is List {}\n\nAn Array is a List which forces all its elements to be scalar containers,\nwhich means you can assign to array elements.\n\nArray implements Positional and as such provides support for subscripts.\n\nNote from version 6.d, .perl can be called on multi-dimensional arrays.\n\n",
      "name": "Array"
    },
    {
      "name": "Map",
      "desc": "TITLE\nclass Map\n\nSUBTITLE\nImmutable mapping from strings to values\n\n    class Map does Associative does Iterable { }\n\nA Map is an immutable mapping from string keys to values of arbitrary\ntypes. It serves as a base class for Hash, which is mutable.\n\nIn list context a Map behaves as a list of Pair objects.\n\nNote that the order in which keys, values and pairs are retrieved is\ngenerally arbitrary, but the keys, values and pairs methods return them\nalways in the same order when called on the same object.\n\n    my %e := Map.new('a', 1, 'b', 2);\n    say %e.keys;    # can print \"a b\\n\" or \"b a\\n\";\n    say %e.values;  # prints \"1 2\\n\" if the previous line\n                    # printed \"a b\\n\", \"b a\\n\" otherwise\n\nTo retrieve a value from the Map by key, use the { } postcircumfix\noperator:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    say $map{'a'};      # OUTPUT: «1␤»\n    say $map{ 'a', 'b' }; # OUTPUT: «(1 2)␤»\n\nTo check whether a given key is stored in a Map, modify the access with the\n:exists adverb:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    my $key = 'a';\n    if $map{$key}:exists {\n        say \"$map{} has key $key\";\n    }\n\nBeing an immutable instance, it is not possible to add keys after a Map has\nbeen initialized:\n\n    my $m = Map.new( 'a', 1, 'b', 2 );\n    $m{ 'c' } = 'foo'; # WRONG!\n                       # Cannot modify an immutable Str\n\n"
    },
    {
      "name": "Compiler",
      "desc": "TITLE\nclass Compiler\n\nSUBTITLE\nInformation related to the compiler that is being used\n\n    class Compiler does Systemic {}\n\nBuilt-in class for providing compiler related information. Usually accessed\nthrough the compiler attribute of the $*PERL dynamic variable.\n\n    say $*PERL.compiler; # OUTPUT: «rakudo (2019.03.1.385.ga.643.b.8.be.1)␤»\n\n"
    },
    {
      "name": "Cool",
      "desc": "TITLE\nclass Cool\n\nSUBTITLE\nObject that can be treated as both a string and number\n\n    class Cool is Any { }\n\nCool, also known as the Convenient OO Loop, is a base class employed by a\nnumber of built-in classes whose instances can be meaningfully coerced to a\nstring and a number. For example, an Array can be used in mathematical\noperations, where its numerical representation is the number of elements it\ncontains. At the same time, it can be concatenated to a string, where its\nstringy representation is all of its elements joined by a space. Because\nArray is Cool, the appropriate coercion happens automatically.\n\n"
    },
    {
      "desc": "TITLE\nclass Mu\n\nSUBTITLE\nThe root of the Perl 6 type hierarchy.\n\n    class Mu { }\n\nThe root of the Perl 6 type hierarchy. For the origin of the name, see\nhttps://en.wikipedia.org/wiki/Mu_%28negative%29. One can also say that\nthere are many undefined values in Perl 6, and Mu is the most undefined\nvalue.\n\nNote that most classes do not derive from Mu directly, but rather from\nAny.\n\n",
      "name": "Mu"
    },
    {
      "name": "Routine",
      "desc": "TITLE\nclass Routine\n\nSUBTITLE\nCode object with its own lexical scope and return handling\n\n    class Routine is Block { }\n\nA Routine is a code object meant for larger unities of code than Block.\nRoutine is the common superclass for Sub (and therefore operators) and\nMethod, the two primary code objects for code reuse.\n\nRoutines serve as a scope limiter for return (i.e. a return returns from\nthe innermost outer Routine).\n\nThe routine level is also the one at which multiness (multi subs and multi\nmethods) are handled. Subroutines can also be declared anon. See the\ndocumentation on the anon declarator for more information.\n\n"
    },
    {
      "name": "Exception",
      "desc": "TITLE\nclass Exception\n\nSUBTITLE\nAnomalous event capable of interrupting normal control-flow\n\n    class Exception {}\n\nAll exceptions that are placed into the $! variable (or into $_ in CATCH\nblocks) inherit from Exception. When you call die or fail with a\nnon-Exception argument, it is wrapped into an X::AdHoc object, which also\ninherits from Exception.\n\nUser-defined exception classes should inherit from Exception too, and\ndefine at least a method message.\n\n    class X::YourApp::SomeError is Exception {\n        method message() {\n            \"A YourApp-Specific error occurred: out of coffee!\";\n        }\n    }\n\n"
    },
    {
      "name": "PseudoStash",
      "desc": "TITLE\nclass PseudoStash\n\nSUBTITLE\nStash type for pseudo-packages\n\n    class PseudoStash is Map { }\n\nPseudoStash is the stash type (hanging off .WHO) that backs various\npseudo-packages. So, when you do MY:: or CALLER::, that gives back a\nPseudoStash. In most cases, Package:: gives back a Stash. Neither of these\nare objects the user is expected to create by themselves, but in case you\nhave one, you can just use it like a hash.\n\n    my $a = 42;\n    my $b = q/$a/;\n    say MY::{$b};\n    #OUTPUT: «42␤»\n\n\nThis shows how you can use a PseudoStash to look up variables, by name, at\nruntime."
    },
    {
      "desc": "TITLE\nenum Order\n\nSUBTITLE\nHuman readable form for comparison operators. \n\n    enum Order (:Less(-1), :Same(0), :More(1));\n\nOperators\n\n  infix cmp\n\n    multi sub infix:<cmp>(\\a, \\b --> Order:D)\n\ncmp will first try to compare operands as strings (via coercion to\nStringy), and, failing that, will try to compare numerically via the <=>\noperator or any other type-appropriate comparison operator. See also the\ndocumentation for the cmp operator.\n\n  infix <=>\n\n    multi sub infix:«<=>»(Int:D \\a, Int:D \\b --> Order:D)\n\nSpecialized form for Int.",
      "name": "Order"
    },
    {
      "desc": "TITLE\nclass Telemetry\n\nSUBTITLE\nCollect performance state for analysis\n\n    class Telemetry { }\n\nNote:  This class is a Rakudo-specific feature and not standard Perl 6.\n\nOn creation, a Telemetry object contains a snapshot of various aspects of\nthe current state of the virtual machine. This is in itself useful, but\ngenerally one needs two snapshots for the difference (which is a\nTelemetry::Period object).\n\nThe Telemetry object is really a collection of snapshots taken by different\n\"instruments\". By default, the Telemetry::Instrument::Usage and\nTelemetry::Instrument::ThreadPool instruments are activated.\n\nThe Telemetry (and Telemetry::Period) object also Associative. This means\nthat you can treat a Telemetry object as a read-only Hash, with all of the\ndata values of the instruments as keys.\n\nYou can determine which instruments Telemetry should use by setting the\n$*SAMPLER dynamic variable, which is a Telemetry::Sampler object.\n\nCurrently, the following instruments are supported by the Rakudo core:\n\n  * Telemetry::Instrument::Usage\n\nProvides (in alphabetical order): cpu, cpu-sys, cpu-user, cpus, id-rss,\ninb, invcsw, is-rss, ix-rss, majf, max-rss, minf, mrcv, msnd, nsig, nswp,\nvolcsw, outb, util% and wallclock. For complete documentation of the\nmeaning of these data values, see Telemetry::Instrument::Usage.\n\n  * Telemetry::Instrument::Thread\n\nProvides (in alphabetical order): tad, tcd, thid, tjd, tsd and tys. For\ncomplete documentation of the meaning of these data values, see\nTelemetry::Instrument::Thread.\n\n  * Telemetry::Instrument::ThreadPool\n\nProvides (in alphabetical order): atc, atq, aw, gtc, gtq, gw, s, ttc, ttq\nand tw. For complete documentation of the meaning of these data values, see\nTelemetry::Instrument::ThreadPool.\n\n  * Telemetry::Instrument::AdHoc\n\nDoes not provide any data by itself: one must indicate which variables are\nto be monitored, which will then become available as methods with the same\nname on the instrument. For complete documentation, see\nTelemetry::Instrument::AdHoc.\n\n  routine T\n\n    sub T()\n\nShortcut for Telemetry.new. It is exported by default. Since the Telemetry\nclass also provides an Associative interface, one can easily interpolate\nmultiple values in a single statement:\n\n    use Telemetry;\n    say \"Used {T<max-rss cpu>} (KiB CPU) so far\";\n\n\n  routine snap\n\n    multi sub snap(--> Nil)\n    multi sub snap(@s --> Nil)\n\nThe snap subroutine is shorthand for creating a new Telemetry object and\npushing it to an array for later processing. It is exported by default.\n\n    use Telemetry;\n    my @t;\n    for ^5 {\n        snap(@t);\n        # do some stuff\n        LAST snap(@t);\n    }\n\n\nIf no array is specified, it will use an internal array for convenience.\n\n  routine snapper\n\n    sub snapper($sleep = 0.1, :$stop, :$reset --> Nil)\n\nThe snapper routine starts a separate thread that will call snap repeatedly\nuntil the end of program. It is exported by default.\n\nBy default, it will call snap every 0.1 second. The only positional\nparameter is taken to be the delay between snaps.\n\nPlease see the snapper module for externally starting a snapper without\nhaving to change the code. Simply adding -Msnapper as a command line\nparameter, will then start a snapper for you.\n\n  routine periods\n\n    multi sub periods( --> Seq)\n    multi sub periods(@s --> Seq)\n\nThe periods subroutine processes an array of Telemetry objects and\ngenerates a Seq of Telemetry::Period objects out of that. It is exported by\ndefault.\n\n    .<cpu wallclock>.say for periods(@t);\n\n    # OUTPUT:\n    # ====================\n    # (164 / 160)\n    # (23 / 21)\n    # (17 / 17)\n    # (15 / 16)\n    # (29 / 28)\n\n\nIf no array is specified, it will use the internal array of snap without\nparameters and will reset that array upon completion (so that new snaps can\nbe added again).\n\n    use Telemetry;\n    for ^5 {\n        snap;\n        LAST snap;\n    }\n    say .<cpu wallclock>.join(\" / \") for periods;\n\n    # OUTPUT:\n    # ====================\n    # 172 / 168\n    # 24 / 21\n    # 17 / 18\n    # 17 / 16\n    # 27 / 27\n\n\nIf only one snap was done, another snap will be done to create at least one\nTelemetry::Period object.\n\n  routine report\n\n    multi sub report(:@columns, :$legend, :$header-repeat, :$csv, :@format)\n\nThe report subroutine generates a report about an array of Telemetry\nobjects. It is exported by default. These can have been created by\nregularly calling snap, or by having a snapper running. If no positional\nparameter is used, it will assume the internal array to which the\nparameterless snap pushes.\n\nBelow are the additional named parameters of report.\n\n  * :columns\n\nSpecify the names of the columns to be included in the report. Names can be\nspecified with the column name (e.g. gw). If not specified, defaults to\nwhat is specified in the RAKUDO_REPORT_COLUMNS environment variable. If\nthat is not set either, defaults to:\n\n    wallclock util% max-rss gw gtc tw ttc aw atc\n\n\n  * :header-repeat\n\nSpecifies after how many lines the header should be repeated in the report.\nIf not specified, defaults to what is specified in the\nRAKUDO_REPORT_HEADER_REPEAT environment variable. If that is not set\neither, defaults to 32.\n\n  * :legend\n\nSpecifies whether a legend should be added to the report. If not specified,\ndefaults to what is specified in the RAKUDO_REPORT_LEGEND environment\nvariable. If that is not set either, defaults to True.\n\nIf there are snaps available in the internal array at the end of the\nprogram, then report will be automatically generated and printed on\nSTDERR.\n\n  module snapper\n\nStart a thread taking repeated system state snapshots.\n\nThis module contains no subroutines or methods or anything. It is intended\nas a shortcut for starting the snapper subroutine of the Telemetry module,\nallowing taking snapshots of the execution of a program without needing to\nchange the program. Simple loading the module with -Msnapper will do all\nthat is needed to start the snapper, and have a report printed on STDERR\nupon completion of the program.\n\nThe RAKUDO_SNAPPER environment variable can be set to indicate the time\nbetween snapshots. If not specified, it will default to 0.1 seconds.",
      "name": "Telemetry"
    },
    {
      "desc": "TITLE\nclass Hash\n\nSUBTITLE\nMapping from strings to itemized values\n\n    class Hash is Map { }\n\nA Hash is a mutable Map; it implements Associative through its inheritance\nof Map and as such provides support for looking up values using keys,\nproviding support for associative subscripting.\n\nAlthough the order of the hashes is guaranteed to be random in every single\ncall, still successive calls to .keys and .values are guaranteed to return\nthem in the same order:\n\n    my %orig = :1a, :2b; my %new = :5b, :6c;\n    %orig{ %new.keys } = %new.values;\n    say %orig.perl; # OUTPUT: «{:a(1), :b(5), :c(6)}␤»\n\nIn this case, b will always be associated to 5 and c to 6; even if two\nsuccessive calls to keys will return them in different order. Successive\ncalls to any of them separately and repeatedly will always return the same\norder in any program invocation.\n\nPlease see the section on hash literals for different ways to declare a\nhash. Additionally, they can be declared using curly braces as long as\nthese rules are followed:\n\n  * Empty curly braces will always declare an empty hash.\n\n  * A reference to $_ (even implicit) will instead declare a block.\n\n  * A Pair or variable with % as the first element will declare a hash.\n\n    given 3 { say WHAT {3 => 4, :b}  };     # OUTPUT: «(Hash)␤»\n    given 3 { say WHAT {3 => 4, :b($_)} };  # OUTPUT: «(Block)␤»\n    given 3 { say WHAT {3 => 4, :b(.Num)} };# OUTPUT: «(Block)␤»\n    say { 'a',:b(3), 'c' }.^name;           # OUTPUT: «Block␤»\n\n\nThe next-to-last two cases are examples of the generation of Blocks in the\npresence of the topic variable $_. The last case does not meet the third\ncriterium for generating a hash, and thus generates a Block.\n\nA % in front of parentheses or square brackets will generate a Hash as long\nas the elements can be paired.\n\n    say %( 'a', 3, :b(3), 'c', 3 ).^name; # OUTPUT: «Hash␤»\n\nElements in this hash can be paired both sides of the Pair :b(3).\n\n    say %(«a b c 1 2 3»).^name;           # OUTPUT: «Hash␤»\n\nAn empty hash can be initialized either with empty curly braces or, since\n6.d, %().\n\n    say %().^name; # OUTPUT: «Hash␤»\n    say {}.^name;  # OUTPUT: «Hash␤»\n\n",
      "name": "Hash"
    },
    {
      "desc": "TITLE\nclass Parameter\n\nSUBTITLE\nElement of a Signature\n\n    class Parameter { }\n\nRepresents a parameter, for purpose of introspection.\n\nThe usual way to obtain a Parameter object is to create a signature, and\ncall .params on it to obtain a list of the Parameters.\n\n    my $sig   = :(Str $x);\n    my $param = $sig.params[0];\n    say $param.type;              # OUTPUT: «Str()␤»\n\nSee Signature for more information, and also for an explanation on what\nmost of the concepts related to parameters mean.\n\n",
      "name": "Parameter"
    },
    {
      "desc": "TITLE\nclass ForeignCode\n\nSUBTITLE\nRakudo-specific class that wraps around code in other languages (generally\nNQP)\n\n    class ForeignCode does Callable {}\n\nThis is a Rakudo specific class, and as such it is advisable not to use it\nin your own code, since its interface might change or even disappear in the\nfuture. This is provided here only as a reference\n\nForeignCode is a Perl 6 wrapper around code that is not written originally\nin that language; its intention is to use these blocks of code in Callable\ncontexts easily. For instance, subs have some anonymous functions that are\nactually ForeignCode.\n\n    sub does-nothing(){};\n    say $_.name ~ ' → ' ~ $_.^name for &does-nothing.^methods;\n    # OUTPUT: «<anon> → ForeignCode␤<anon> → ForeignCode␤soft → Method␤…»\n\n\nThis script will map method names to their class, and it shows that\nroutines, in particular, have several methods that are actually ForeignCode\ninstead of ",
      "name": "ForeignCode"
    },
    {
      "desc": "TITLE\nrole Setty\n\nSUBTITLE\nCollection of distinct objects\n\n    role Setty does QuantHash { }\n\nA role for collections which make sure that each element can only appear\nonce. See Set and SetHash.\n\n",
      "name": "Setty"
    },
    {
      "desc": "TITLE\nclass CallFrame\n\nSUBTITLE\nCaptures the current frame state\n\n    class CallFrame {}\n\nA CallFrame will be usually captured from the current state of a program\nusing the callframe subroutine.\n\n    my $frame = callframe;\n    say \"The above line of code ran at {$frame.file}:{$frame.line}.\";\n\nWith no arguments the callframe will give you frame information for the\nline calling callframe. The file and line annotations will be identical to\nthose in $?FILE and $?LINE.\n\nYou may, however, pass a number to callframe to specify a different frame\nlevel. A positive number will move upward through the levels of frame. A\nnegative number will move downward into the callframe method and class\nitself at the point at which they are running to construct this information\nfor you.\n\nThe frames themselves do not necessarily match only method or subroutine\ncalls. Perl constructs a frames for blocks and such as well, so if you need\na callframe for a particular method call, do not assume it is a fixed\nnumber of levels up.\n\nEach frame stores annotations, including the file and line annotations,\nwhich have convenience methods for accessing them directly. You can also\nretrieve a reference to the code block of the currently executing frame\nusing the code method. The frame also captures all lexical variables stored\nwith the frame, which are available by calling my on the frame object.\n\nHere's a short example that will find the calling routine and print the\npackage of the caller using the callframe interface.\n\n    sub calling-frame() {\n        for 1..* -> $level {\n            given callframe($level) -> $frame {\n                when $frame ~~ CallFrame {\n                        next unless $frame.code ~~ Routine;\n                        say $frame.code.package;\n                        last;\n                }\n                default {\n                        say \"no calling routine or method found\";\n                        last;\n                }\n            }\n        }\n    }\n\n    calling-frame;\n\nIf you just need to trace caller information, Backtrace may provide a\nbetter means of getting it. CallFrame contains more information about a\nspecific frame, but provides a tedious interface for enumerating a call\nstack.\n\n",
      "name": "CallFrame"
    },
    {
      "name": "WhateverCode",
      "desc": "TITLE\nclass WhateverCode\n\nSUBTITLE\nCode object constructed by Whatever-currying\n\n    class WhateverCode is Code { }\n\nWhateverCode objects are the result of Whatever-currying. See the Whatever\ndocumentation for details.\n\nWhen you wish to control how a method or function interprets any Whatever\nstar, you may use multi dispatch with Whatever and WhateverCode parameters\nto do so, as in the following example:\n\n    class Cycle {\n          has $.pos;\n          has @.vals;\n    }\n\n    multi sub get-val(Cycle $c, Int $idx) {\n          $c.vals[$idx % $c.vals.elems]\n    }\n\n    # Define what to do with a stand-alone * as the second argument\n    multi sub get-val(Cycle $c, Whatever $idx) {\n        get-val($c, $c.pos);\n    }\n\n    # Define what to do with a * WhateverCode in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx) {\n        get-val($c, $idx($c.pos));\n    }\n\n    my Cycle $c .= new(:pos(2), :vals(0..^10));\n\n    say get-val($c, 3);   # OUTPUT: «3␤»\n    say get-val($c, *);   # OUTPUT: «2␤»\n    say get-val($c, *-1); # OUTPUT: «1␤»\n\nThe WhateverCode does the Callable role, so it should be possible to\nintrospect the type of Callable it contains; for instance, continuing the\nprevious example, we can add a multi that handles a WhateverCode with two\narguments via checking the signature:\n\n    # Define what to do with two * in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {\n        get-val($c, $idx($c.pos, $c.vals.elems));\n    }\n\n    say get-val($c, * + * div 2); # 2 + 10/2 = 7\n\n\nNote, though, that subexpressions may impose their own Whatever star\nrules:\n\n    my @a = (0, 1, 2);\n    say get-val($c, @a[*-1]) # 2, because the star belongs to the Array class\n\n\nThis can make the ownership of Whatever stars become confusing rather\nquickly, so be careful not to overdo it.\n\nYou may instead type-constrain using Callable type in order to accept any\nCallable, including WhateverCode:\n\n    sub run-with-rand (Callable $code) { $code(rand) };\n    run-with-rand *.say;           # OUTPUT: «0.773672071688484␤»\n    run-with-rand {.say};          # OUTPUT: «0.38673179353983␤»\n    run-with-rand sub { $^v.say }; # OUTPUT: «0.0589543603685792␤»\n\nType-constraining with &-sigiled parameter works equally well and is\nshorter to type:\n\n    sub run-with-rand (&code) { code time };"
    },
    {
      "name": "Collation",
      "desc": "TITLE\nclass Collation\n\nSUBTITLE\nEncapsulates how strings are sorted\n\n    class Collation { }\n\n\nCollation is the class that allows proper sorting, taking into account all\nUnicode characteristics. It's the class the object $*COLLATION is\ninstantiated to, and thus includes collation levels, that is, what kind of\nfeatures should be looked up when comparing two strings and in which\norder.\n\n"
    },
    {
      "desc": "TITLE\nclass Channel\n\nSUBTITLE\nThread-safe queue for sending values from producers to consumers\n\n    class Channel {}\n\nA Channel is a thread-safe queue that helps you to send a series of objects\nfrom one or more producers to one or more consumers. Each object will\narrive at only one such consumer, selected by the scheduler. If there is\nonly one consumer and one producer, the order of objects is guaranteed to\nbe preserved. Sending on a Channel is non-blocking.\n\n    my $c = Channel.new;\n    await (^10).map: {\n        start {\n            my $r = rand;\n            sleep $r;\n            $c.send($r);\n        }\n    }\n    $c.close;\n    say $c.list;\n\nFurther examples can be found in the concurrency page\n\n",
      "name": "Channel"
    },
    {
      "name": "Block",
      "desc": "TITLE\nclass Block\n\nSUBTITLE\nCode object with its own lexical scope\n\n    class Block is Code { }\n\nA Block is a code object meant for small-scale code reuse. A block is\ncreated syntactically by a list of statements enclosed in curly braces.\n\nWithout an explicit signature or placeholder arguments, a block has $_ as a\npositional argument\n\n    my $block = { uc $_; };\n    say $block.^name;           # OUTPUT: «Block␤»\n    say $block('hello');        # OUTPUT: «HELLO␤»\n\nA block can have a Signature between ->  or <->  and the block:\n\n    my $add = -> $a, $b = 2 { $a + $b };\n    say $add(40);               # OUTPUT: «42␤»\n\nIf the signature is introduced with <-> , then the parameters are marked as\nrw by default: \n\n    my $swap = <-> $a, $b { ($a, $b) = ($b, $a) };\n    my ($a, $b) = (2, 4);\n    $swap($a, $b);\n    say $a;                     # OUTPUT: «4␤»\n\nBlocks that aren't of type Routine (which is a subclass of Block) are\ntransparent to return.\n\n    sub f() {\n        say <a b c>.map: { return 42 };\n                       #   ^^^^^^   exits &f, not just the block\n    }\n\nThe last statement is the implicit return value of the block.\n\n    say {1}.(); # OUTPUT: «1␤»\n\nBare blocks are automatically executed in the order they appear:\n\n    say 1;                # OUTPUT: «1␤»\n    {\n        say 2;            # OUTPUT: «2␤»; executed directly, not a Block object\n    }\n    say 3;                # OUTPUT: «3␤»"
    },
    {
      "name": "NFC",
      "desc": "TITLE\nclass NFC\n\nSUBTITLE\nCodepoint string in Normal Form C (composed)\n\n    class NFC is Uni {}\n\nA Codepoint string in Unicode Normalization Form C. It is created by\nCanonical Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15."
    },
    {
      "desc": "TITLE\nclass MixHash\n\nSUBTITLE\nMutable collection of distinct objects with Real weights\n\n    class MixHash does Mixy { }\n\nA MixHash is a mutable mix, meaning a collection of distinct elements in no\nparticular order that each have a real-number weight assigned to them. (For\nimmutable mixes, see Mix instead.)\n\nObjects/values of any type are allowed as mix elements. Within a MixHash,\nitems that would compare positively with the === operator are considered\nthe same element, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding numeric weight for keys that are\nelements of the mix, and 0 for keys that aren't. It can also be used to\nmodify weights; Setting a weight to 0 automatically removes that element\nfrom the mix, and setting a weight to a non-zero number adds that element\nif it didn't already exist:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\n    $recipe<butter> = 0;\n    $recipe<chocolate> = 0.30;\n    say $recipe.pairs;       # OUTPUT: «\"sugar\" => 0.12 \"flour\" => 0.275 \"chocolate\" => 0.3␤»\n\n\nCreating MixHash objects\n\nMixHashes can be composed using MixHash.new. Any positional parameters,\nregardless of their type, become elements of the mix - with a weight of 1\nfor each time the parameter occurred:\n\n    my $n = MixHash.new: \"a\", \"a\", \"b\" => 0, \"c\" => 3.14;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Pair) (Pair))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 (c => 3.14) => 1 (b => 0) => 1)␤»\n\nAlternatively, the .MixHash coercer (or its functional form, MixHash()) can\nbe called on an existing object to coerce it to a MixHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a mix with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the mix, and the (cumulative) values become the\nassociated numeric weights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).MixHash;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a MixHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = MixHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %mh is MixHash[Str] = <a b b c c c>;\n    say %mh<b>;  # 2\n    say %mh<d>;  # 0\n\n    # only allow whole numbers\n    my %mh is MixHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\n    my ($a, $b) = MixHash(2 => 2, 4), MixHash(2 => 1.5, 3 => 2, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a (+) $b;   # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a ⊎ $b;  # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nMixHash inherits reverse from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a MixHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = MixHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «MixHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\n",
      "name": "MixHash"
    },
    {
      "desc": "TITLE\nclass Capture\n\nSUBTITLE\nArgument list suitable for passing to a Signature\n\n \n\n    class Capture { }\n\n\nA Capture is a container for passing arguments to a code object. Captures\nare the flip-side of Signatures – Captures are the caller defined\narguments, while Signatures are the callee defined parameters.\n\nWhen you call print $a, $b, the $a, $b part is a Capture.\n\nCaptures contain a list-like part for positional arguments and a hash-like\npart for named arguments, thus behaving as Positional and Associative,\nalthough it does not actually mixes in those roles. For the named\narguments, Captures use a slightly different syntax than a normal List.\nThere are two easy ways to make a named argument: 1) use an unquoted key\nnaming a parameter, followed by =>, followed by the argument and 2) use a\ncolon-pair literal named after the parameter:\n\n    say unique 1, -2, 2, 3, as => { abs $_ };   # OUTPUT: «(1 -2 3)␤»\n    # ... is the same thing as:\n    say unique 1, -2, 2, 3, :as({ abs $_ });    # OUTPUT: «(1 -2 3)␤»\n    # Be careful not to quote the name of a named parameter:\n    say unique 1, -2, 2, 3, 'as' => { abs $_ };\n    # OUTPUT: «(1 -2 2 3 as => -> ;; $_? is raw { #`(Block|78857320) ... })␤»\n\nA stand-alone Capture can also be made, stored, and used later. A literal\nCapture can be created by prefixing a term with a backslash \\. Commonly,\nthis term will be a List of terms, from which any Pair literal will be\nplaced in the named part, and all other terms will be placed in the\npositional part.\n\n    my $c = \\(42);          # Capture with one positional part\n    $c = \\(1, 2, a => 'b'); # Capture with two positional and one named parts\n\nTo use such a Capture, you may use '|' before it in a function call, and it\nwill be as if the values in the Capture were passed directly to the\nfunction as arguments – named arguments will be passed as named arguments\nand positional arguments will be passed as positional arguments. You may\nre-use the Capture as many times as you want, even with different\nfunctions.\n\n    my $c = \\(4, 2, 3);\n    reverse(|$c).say; # OUTPUT: «3 2 4␤»\n    sort(5,|$c).say;  # OUTPUT: «2 3 4 5␤»\n\nInside a Signature, a Capture may be created by prefixing a sigilless\nparameter with a vertical bar |. This packs the remainder of the argument\nlist into that parameter.\n\n    f(1, 2, 3, a => 4, b => 5);\n    sub f($a, |c) {\n        # c  is  \\(2, 3, a => 4, b => 5)\n    }\n\nNote that Captures are still Lists in that they may contain containers, not\njust values:\n\n    my $b = 1;\n    my $c = \\(4, 2, $b, 3);\n    sort(|$c).say;        # OUTPUT: «1 2 3 4␤»\n    $b = 6;\n    sort(|$c).say;        # OUTPUT: «2 3 4 6␤»\n\n",
      "name": "Capture"
    },
    {
      "name": "Pair",
      "desc": "TITLE\nclass Pair\n\nSUBTITLE\nKey/value pair\n\n    class Pair does Associative {}\n\nConsists of two parts, a key and a value. Pairs can be seen as the atomic\nunits in Hashes, and they are also used in conjunction with named arguments\nand parameters.\n\n     There are many syntaxes for creating Pairs:\n\n    Pair.new('key', 'value'); # The canonical way\n    'key' => 'value';         # this...\n    :key<value>;              # ...means the same as this\n    :key<value1 value2>;      # But this is  key => <value1 value2>\n    :foo(127);                # short for  foo => 127\n    :127foo;                  # the same   foo => 127\n\nNote that last form supports Non-ASCII numerics as well:\n\n    # use MATHEMATICAL DOUBLE-STRUCK DIGIT THREE\n    say (:\uD835\uDFDBmath-three);         # OUTPUT: «math-three => 3␤»\n\nYou can also use an identifier-like literal as key; this will not need the\nquotes as long as it follows the syntax of ordinary identifiers:\n\n    (foo => 127)              # the same   foo => 127\n\nVariants of this are\n\n    :key;                     # same as   key => True\n    :!key;                    # same as   key => False\n\nAnd this other variant, to be used in routine invocation\n\n    sub colon-pair( :$key-value ) {\n        say $key-value;\n    }\n    my $key-value = 'value';\n    colon-pair( :$key-value );               # OUTPUT: «value␤»\n    colon-pair( key-value => $key-value );   # OUTPUT: «value␤»\n\n\n Colon pairs can be chained without a comma to create a List of Pairs.\nDepending on context you may have to be explicit when assigning colon\nlists.\n\n    sub s(*%h){ say %h.perl };\n    s :a1:b2;\n    # OUTPUT: «{:a1, :b2}␤»\n\n    my $manna = :a1:b2:c3;\n    say $manna.^name;\n    # OUTPUT: «Pair␤»\n\n    $manna = (:a1:b2:c3);\n    say $manna.^name;\n    # OUTPUT: «List␤»\n\nAny variable can be turned into a Pair of its name and its value.\n\n    my $bar = 10;\n    my $p   = :$bar;\n    say $p; # OUTPUT: «bar => 10␤»\n\nIt is worth noting that when assigning a Scalar as value of a Pair the\nvalue holds the container of the value itself. This means that it is\npossible to change the value from outside of the Pair itself:\n\n    my $v = 'value A';\n    my $pair = a => $v;\n    $pair.say;  # OUTPUT: «a => value A␤»\n\n    $v = 'value B';\n    $pair.say;  # OUTPUT: «a => value B␤»\n\n\nPlease also note that this behavior is totally unrelated to the way used to\nbuild the Pair itself (i.e., explicit usage of new, use of colon, fat\narrow), as well as if the Pair is bound to a variable.\n\nIt is possible to change the above behavior forcing the Pair to remove the\nscalar container and to hold the effective value itself via the method\nfreeze:\n\n    my $v = 'value B';\n    my $pair = a => $v;\n    $pair.freeze;\n    $v = 'value C';\n    $pair.say; # OUTPUT: «a => value B␤»\n\n\nAs Pair implements Associative role, its value can be accessed using\nAssociative subscription operator, however, due to Pair's singular nature,\nthe pair's value will be only returned for the pair's key. Nil object will\nbe returned for any other key. Subscript adverbs such as :exists can be\nused on Pair.\n\n    my $pair = a => 5;\n    say $pair<a>;           # OUTPUT: «5␤»\n    say $pair<a>:exists;    # OUTPUT: «True␤»\n    say $pair<no-such-key>; # OUTPUT: «Nil␤»\n\n\n"
    },
    {
      "name": "Dateish",
      "desc": "TITLE\nrole Dateish\n\nSUBTITLE\nObject that can be treated as a date\n\n    role Dateish { ... }\n\nBoth Date and DateTime support accessing a year, month and day-of-month, as\nwell as related functionality such as calculating the day of the week.\n\n"
    },
    {
      "name": "FatRat",
      "desc": "TITLE\nclass FatRat\n\nSUBTITLE\nRational number (arbitrary-precision)\n\n    class FatRat is Cool does Rational[Int, Int] {}\n\nA FatRat is a rational number stored with arbitrary size numerator and\ndenominator. Arithmetic operations involving a FatRat and optionally Int or\nRat objects return a FatRat, avoiding loss of precision.\n\nSince, unlike Rat, FatRat arithmetics do not fall back Num at some point,\nthere is a risk that repeated arithmetic operations generate pathologically\nlarge numerators and denominators.\n\nThere are two common ways to generate FatRat objects: through the\nFatRat.new(Int, Int) constructor, which generates them from numerator and\ndenominator, or by calling the .FatRat method on an Int or Rat object.\n\n"
    },
    {
      "name": "Scalar",
      "desc": "TITLE\nclass Scalar\n\nSUBTITLE\nA mostly transparent container used for indirections\n\n    class Scalar {}\n\nA Scalar is an internal indirection which is for most purposes invisible\nduring ordinary use of Perl 6. It is the default container type associated\nwith the $ sigil. A literal Scalar may be placed around a literal value by\nenclosing the value in $(…). This notation will appear in the output of a\n.perl method in certain places where it is important to note the presence\nof Scalars.\n\nWhen a value is assigned to a $-sigiled variable, the variable will\nactually bind to a Scalar, which in turn will bind to the value. When a\nScalar is assigned to a $-sigiled variable, the value bound to by that\nScalar will be bound to the Scalar which that variable was bound to (a new\none will be created if necessary.)\n\nIn addition, Scalars delegate all method calls to the value which they\ncontain. As such, Scalars are for the most part invisible. There is,\nhowever, one important place where Scalars have a visible impact: a Scalar\nwill shield its content from flattening by most Perl 6 core list\noperations.\n\nA $-sigiled variable may be bound directly to a value with no intermediate\nScalar using the binding operator :=. You can tell if this has been done by\nexamining the output of the introspective pseudo-method .VAR:\n\n    my $a = 1;\n    $a.^name.say;     # OUTPUT: «Int␤»\n    $a.VAR.^name.say; # OUTPUT: «Scalar␤»\n    my $b := 1;\n    $b.^name.say;     # OUTPUT: «Int␤»\n    $b.VAR.^name.say; # OUTPUT: «Int␤»\n\nThis same thing happens when values are assigned to an element of an Array,\nhowever, Lists directly contain their values:\n\n    my @a = 1, 2, 3;\n    @a[0].^name.say;            # OUTPUT: «Int␤»\n    @a[0].VAR.^name.say;        # OUTPUT: «Scalar␤»\n    [1, 2, 3][0].^name.say;     # OUTPUT: «Int␤»\n    [1, 2, 3][0].VAR.^name.say; # OUTPUT: «Scalar␤»\n    (1, 2, 3)[0].^name.say;     # OUTPUT: «Int␤»\n    (1, 2, 3)[0].VAR.^name.say; # OUTPUT: «Int␤»\n\nArray elements may be bound directly to values using := as well; however,\nthis is discouraged as it may lead to confusion. Doing so will break exact\nround-tripping of .perl output – since Arrays are assumed to place Scalars\naround each element, Scalars are not denoted with $ in the output of\nArray.perl.\n\n    [1, $(2, 3)].perl.say;     # OUTPUT: «[1, (2, 3)]␤»\n    (1, $(2, 3)).perl.say;     # OUTPUT: «(1, $(2, 3))␤»\n\nBinding a Scalar to a $-sigiled variable replaces the existing Scalar in\nthat variable, if any, with the given Scalar. That means more than one\nvariable may refer to the same Scalar. Because the Scalar may be mutated,\nthis makes it possible to alter the value of both variables by altering\nonly one of them:\n\n    my $a = 1;\n    my $b := $a;\n    $b = 2;\n    $a.say;       # OUTPUT: «2␤»\n\n SSA-style constants bind directly to their value with no intervening\nScalar, even when assignment (=) is used. They may be forced to use a\nScalar by assigning a $-sigiled variable to them, at which point, they\nbehave entirely like $-sigiled variables.\n\n    my \\c = 1;\n    c.^name.say;             # OUTPUT: «Int␤»\n    c.VAR.^name.say;         # OUTPUT: «Int␤»\n    my $a = 1;\n    my \\d = $a;              # just \"my \\d = $ = 1\" works, too\n    d.^name.say;             # OUTPUT: «Int␤»\n    d.VAR.^name.say;         # OUTPUT: «Scalar␤»\n    d = 2;                   # ok\n    c = 2;                   # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»\n\nAtomic operations on Scalar\n\nA Scalar can have its value changed using a hardware-supported atomic\ncompare and swap operation. This is useful when implementing lock free data\nstructures and algorithms. It may also be fetched and assigned to in an\n\"atomic\" fashion, which ensures appropriate memory barriering and prevents\nunwanted optimizations of memory accesses.\n\nA Scalar that will be used with an atomic operation should always be\nexplicitly initialized with a value before any atomic operations are\nperformed upon it. This is to avoid races with lazy allocation and\nauto-vivification. For example:\n\n    cas(@a[5], $expected, $value)\n\n\nWill work in principle since an Array consists of Scalar containers.\nHowever, the container is only bound into the array upon initial\nassignment. Therefore, there would be a race to do that binding. The Scalar\natomic operations will never check for or do any such auto-vivification, so\nas to make such bugs much more evident (rather than only observed under\nstress).\n\nIntrospection\n\n  method of\n\n    method of(Scalar:D: --> Mu)\n\nReturns the type constraint of the container.\n\nExample:\n\n    my Cool $x = 42;\n    say $x.VAR.of;                  # OUTPUT: «(Cool)»\n\n  method default\n\n    method default(Scalar:D: --> Str)\n\nReturns the default value associated with the container.\n\nExample:\n\n    my $x is default(666) = 42;\n    say $x.VAR.default;             # OUTPUT: «666»\n\n  method name\n\n    method name(Scalar:D: --> Str)\n\nReturns the name associated with the container.\n\nExample:\n\n    my $x = 42;\n    say $x.VAR.name;                # OUTPUT: «$x»\n\n  method dynamic\n\n    method dynamic(Scalar:D: --> Bool)\n\nReturns whether the variable is visible in dynamic variable lookups.\n\nExample:\n\n    my $*FOO = 42;\n    say $*FOO.VAR.dynamic;          # OUTPUT: «True»\n\nRoutines\n\n  sub atomic-assign\n\nDefined as:\n\n    multi sub atomic-assign($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The\natomic-assign routine ensures that any required barriers are performed such\nthat the changed value will be \"published\" to other threads.\n\n  sub atomic-fetch\n\n    multi sub atomic-fetch($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this routine instead of simply using the variable ensures\nthat the latest update to the variable from other threads will be seen,\nboth by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until atomic-fetch($started) { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  sub cas\n\nDefined as:\n\n    multi sub cas($target is rw, $expected, $value)\n    multi sub cas($target is rw, &operation)\n\nPerforms an atomic compare and swap of the value in the Scalar $target. The\nfirst form has semantics like:\n\n    my $seen = $target;\n    if $seen<> =:= $expected<> {\n        $target = $value;\n    }\n    return $seen;\n\n\nExcept it is performed as a single hardware-supported atomic instruction,\nas if all memory access to $target were blocked while it took place.\nTherefore it is safe to attempt the operation from multiple threads without\nany other synchronization. Since it is a reference comparison, this\noperation is usually not sensible on value types.\n\nFor example:\n\n    constant NOT_STARTED = Any.new;\n    constant STARTED = Any.new;\n    my $master = NOT_STARTED;\n    await start {\n        if cas($master, NOT_STARTED, STARTED) === NOT_STARTED {\n            say \"Master!\"\n        }\n    } xx 4\n\nWill reliably only ever print Master! one time, as only one of the threads\nwill be successful in changing the Scalar from NOT_STARTED to STARTED.\n\nThe second form, taking a code object, will first do an atomic fetch of the\ncurrent value and invoke the code object with it. It will then try to do an\natomic compare and swap of the target, using the value passed to the code\nobject as $expected and the result of the code object as $value. If this\nfails, it will read the latest value, and retry, until a CAS operation\nsucceeds.\n\nTherefore, an item could be added to the head of a linked list in a lock\nfree manner as follows:\n\n    class Node {\n        has $.value;\n        has Node $.next;\n    }\n    my Node $head = Node;\n    await start {\n        for ^1000 -> $value {\n            cas $head, -> $next { Node.new(:$value, :$next) }\n        }\n    } xx 4;\n\nThis will reliably build up a linked list of 4000 items, with 4 nodes with\neach value ranging from 0 up to 999.\n\nOperators\n\n  infix ⚛=\n\n    multi sub infix:<⚛=>($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The ⚛=\noperator ensures that any required barriers are performed such that the\nchanged value will be \"published\" to other threads.\n\n  prefix ⚛\n\n    multi sub prefix:<⚛>($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this operator instead of simply using the variable\nensures that the latest update to the variable from other threads will be\nseen, both by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until ⚛$started { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate."
    },
    {
      "desc": "TITLE\nclass Thread\n\nSUBTITLE\nConcurrent execution of code (low-level)\n\n    class Thread {}\n\nA thread is a sequence of instructions that can (potentially) run in\nparallel to others. Class Thread provides a bit of abstraction over threads\nprovided by the underlying virtual machines (which in turn might or might\nnot be operating system threads).\n\nSince threads are fairly low-level, most applications should use other\nprimitives, like start, which also runs in parallel and returns a Promise.\n\n    my @threads = (^10).map: {\n        Thread.start(\n            name => \"Sleepsorter $_\",\n            sub {\n                my $rand = (^10).pick;\n                sleep $rand;\n                say $rand;\n            },\n        );\n    }\n\n    .finish for @threads;\n\n\nThe current thread is available in the dynamic variable $*THREAD.\n\n",
      "name": "Thread"
    },
    {
      "name": "Pod::FormattingCode",
      "desc": "TITLE\nclass Pod::FormattingCode\n\nSUBTITLE\nPod formatting code\n\n    class Pod::FormattingCode is Pod::Block { }\n\nClass for formatting codes in a Pod document.\n\n"
    },
    {
      "desc": "TITLE\nclass Pod::Defn\n\nSUBTITLE\nPod definition list\n\n    class Pod::Defn is Pod::Block { }\n\nClass for definition lists in a Pod document.\n\n",
      "name": "Pod::Defn"
    },
    {
      "desc": "TITLE\nclass Pod::Item\n\nSUBTITLE\nItem in a Pod enumeration list\n\n    class Pod::Item is Pod::Block { }\n\nClass for items in Pod enumeration lists.\n\n",
      "name": "Pod::Item"
    },
    {
      "desc": "TITLE\nclass Pod::Heading\n\nSUBTITLE\nHeading in a Pod document\n\n    class Pod::Heading is Pod::Block { }\n\nClass for headings in a Pod document.\n\n",
      "name": "Pod::Heading"
    },
    {
      "desc": "TITLE\nclass Pod::Block\n\nSUBTITLE\nBlock in a Pod document\n\n    class Pod::Block { }\n\nClass for a Pod block, and base class for most other Pod classes.\n\nA Pod block has contents (more pod blocks or strings) and a config hash.\n\nUseful subclasses:\n\n  Class                   Used for\n  Pod::Block::Para        paragraphs\n  Pod::Block::Named       named blocks\n  Pod::Block::Declarator  declarator blocks\n  Pod::Block::Code        code blocks\n  Pod::Block::Comment     comments\n  Pod::Block::Table       =begin/end table\n                          tabular data\n  Pod::Heading            =head1 etc. headings\n  Pod::Item               list items\n  Pod::Defn               definition lists\n  Pod::FormattingCode     formatting codes\n\n\n",
      "name": "Pod::Block"
    },
    {
      "desc": "TITLE\nclass Lock::Async\n\nSUBTITLE\nA non-blocking, non-re-entrant, mutual exclusion lock\n\n    class Lock::Async {}\n\nA Lock::Async instance provides a mutual exclusion mechanism: when the lock\nis held, any other code wishing to lock must wait until the holder calls\nunlock.\n\nUnlike Lock, which provides a traditional OS-backed mutual exclusion\nmechanism, Lock::Async works with the high-level concurrency features of\nPerl 6. The lock method returns a Promise, which will be kept when the lock\nis available. This Promise can be used with non-blocking await. This means\nthat a thread from the thread pool need not be consumed while waiting for\nthe Lock::Async to be available, and the code trying to obtain the lock\nwill be resumed once it is available.\n\nThe result is that it's quite possible to have many thousands of\noutstanding Lock::Async lock requests, but just a small number of threads\nin the pool. Attempting that with a traditional Lock would not go so well!\n\nThere is no requirement that a Lock::Async is locked and unlocked by the\nsame physical thread, meaning it is possible to do a non-blocking await\nwhile holding the lock. The flip side of this is Lock::Async is not\nre-entrant.\n\nWhile Lock::Async works in terms of higher-level Perl 6 concurrency\nmechanisms, it should be considered a building block. Indeed, it lies at\nthe heart of the Supply concurrency model. Prefer to structure programs so\nthat they communicate results rather than mutate shared data structures,\nusing mechanisms like Promise, Channel and Supply.\n\n",
      "name": "Lock::Async"
    },
    {
      "desc": "TITLE\nclass Proc::Async\n\nSUBTITLE\nRunning process (asynchronous interface)\n\n    class Proc::Async {}\n\n\nProc::Async allows you to run external commands asynchronously, capturing\nstandard output and error handles, and optionally write to its standard\ninput.\n\n    my $file = ‘foo’.IO;\n    spurt $file, “and\\nCamelia\\n♡\\nme\\n”;\n\n    my $proc = Proc::Async.new: :w, ‘tac’, ‘--’, $file, ‘-’;\n    # my $proc = Proc::Async.new: :w, ‘sleep’, 15; # uncomment to try timeouts\n\n    react {\n        whenever $proc.stdout.lines { # split input on \\r\\n, \\n, and \\r\n            say ‘line: ’, $_\n        }\n        whenever $proc.stderr { # chunks\n            say ‘stderr: ’, $_\n        }\n        whenever $proc.ready {\n            say ‘PID: ’, $_ # Only in Rakudo 2018.04 and newer, otherwise Nil\n        }\n        whenever $proc.start {\n            say ‘Proc finished: exitcode=’, .exitcode, ‘ signal=’, .signal;\n            done # gracefully jump from the react block\n        }\n        whenever $proc.print: “I\\n♥\\nCamelia\\n” {\n            $proc.close-stdin\n        }\n        whenever signal(SIGTERM).merge: signal(SIGINT) {\n            once {\n                say ‘Signal received, asking the process to stop’;\n                $proc.kill; # sends SIGHUP, change appropriately\n                whenever signal($_).zip: Promise.in(2).Supply {\n                    say ‘Kill it!’;\n                    $proc.kill: SIGKILL\n                }\n            }\n        }\n        whenever Promise.in(5) {\n            say ‘Timeout. Asking the process to stop’;\n            $proc.kill; # sends SIGHUP, change appropriately\n            whenever Promise.in(2) {\n                say ‘Timeout. Forcing the process to stop’;\n                $proc.kill: SIGKILL\n            }\n        }\n    }\n\n    say ‘Program finished’;\n\n\nExample above produces the following output:\n\n    line: me\n    line: ♡\n    line: Camelia\n    line: and\n    line: Camelia\n    line: ♥\n    line: I\n    Proc finished. Exit code: 0\n    Program finished\n\n\nAlternatively, you can use Proc::Async without using a react block:\n\n    # command with arguments\n    my $proc = Proc::Async.new('echo', 'foo', 'bar');\n\n    # subscribe to new output from out and err handles:\n    $proc.stdout.tap(-> $v { print \"Output: $v\" }, quit => { say 'caught exception ' ~ .^name });\n    $proc.stderr.tap(-> $v { print \"Error:  $v\" });\n\n    say \"Starting...\";\n    my $promise = $proc.start;\n\n    # wait for the external program to terminate\n    await $promise;\n    say \"Done.\";\n\nThis produces the following output:\n\n    Starting...\n    Output: foo bar\n    Done.\n\n\nAn example that opens an external program for writing:\n\n    my $prog = Proc::Async.new(:w, 'hexdump', '-C');\n    my $promise = $prog.start;\n    await $prog.write(Buf.new(12, 42));\n    $prog.close-stdin;\n    await $promise;\n\nAn example of piping several commands like echo \"Hello, world\" | cat -n:\n\n    my $proc-echo = Proc::Async.new: 'echo', 'Hello, world';\n    my $proc-cat = Proc::Async.new: 'cat', '-n';\n    $proc-cat.bind-stdin: $proc-echo.stdout;\n    await $proc-echo.start, $proc-cat.start;\n\n",
      "name": "Proc::Async"
    },
    {
      "name": "Routine::WrapHandle",
      "desc": "TITLE\nclass Routine::WrapHandle\n\nSUBTITLE\nHolds all information needed to unwrap a wrapped routine.\n\nclass WrapHandle { ... }\n\nWrapHandle is a Rakudo private class created and returned by wrap. Its only\nuse is to unwrap wrapped routines. Either call unwrap on a routine object\nor call the method restore on a Routine::WrapHandle object.\n\n    sub f() { say 'f was called' }\n    my $wrap-handle = &f.wrap({ say 'before'; callsame; say 'after' });\n    f;                    # OUTPUT: «before␤f was called␤after␤»\n    $wrap-handle.restore;\n    f;                    # OUTPUT: «f was called␤»\n\nAs such private class, it may suffer any kind of changes without prior\nnotice. It is only mentioned here since it is visible by the user who\nchecks the return type of the Routine.wrap method.\n\n"
    },
    {
      "desc": "TITLE\nrole CompUnit::Repository\n\nSUBTITLE\nCompUnit::Repository\n\nThe CompUnit::Repository role defines the interface of the implementation\nof CompUnit::Repositories such as CompUnit::Repository::Installation and\nCompUnit::Repository::FileSystem.\n\n",
      "name": "CompUnit::Repository"
    },
    {
      "desc": "TITLE\nclass Encoding::Registry\n\nSUBTITLE\nManagement of available encodings\n\n    class Encoding::Registry {}\n\nEncoding::Registry is initialized with a list of encoding that is available\nfor any Perl 6 application, namely:\n\n  * utf8\n\n  * utf8-c8\n\n  * utf16\n\n  * utf16le\n\n  * utf16be\n\n  * utf32, utf-32\n\n  * ascii\n\n  * iso-8859-1, iso_8859-1:1987, iso_8859-1, iso-ir-100, latin1, latin-1,\n  csisolatin1, l1, ibm819, cp819\n\n  * windows-1251\n\n  * windows-1252\n\n  * windows-932\n\n",
      "name": "Encoding::Registry"
    },
    {
      "name": "IO::Handle",
      "desc": "TITLE\nclass IO::Handle\n\nSUBTITLE\nOpened file or stream\n\n    class IO::Handle { }\n\nInstances of IO::Handle encapsulate an handle to manipulate input/output\nresources. Usually there is no need to create directly an IO::Handle\ninstance, since it will be done by other roles and methods. For instance,\nan IO::Path object provides an open method that returns an IO::Handle:\n\n    my $fh = '/tmp/log.txt'.IO.open;\n    say $fh.^name; # OUTPUT: IO::Handle\n\nThe first line is pretty much equivalent to the following piece of code:\n\n    my $fh = IO::Handle.new( :path( '/tmp/log.txt'.IO.path ) ).open;\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Pipe\n\nSUBTITLE\nBuffered inter-process string or binary stream\n\n    class IO::Pipe is IO::Handle {}\n\nAn IO::Pipe object closely corresponds to a UNIX pipe. It has one end where\nit consumes string or binary data, and another where it reproduces the same\ndata. It is buffered, so that a write without a read doesn't immediately\nblock.\n\nPipes can be easily constructed with sub run and Proc::Async.new.\n\n",
      "name": "IO::Pipe"
    },
    {
      "desc": "TITLE\nclass IO::Notification\n\nSUBTITLE\nAsynchronous notification for file and directory changes    \n\n    enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));\n\n\n    class IO::Notification  {\n        class Change {\n            has $.path;\n            has $.event;\n        }\n        ...\n    }\n\n\nIO::Notification.watch-path($path) produces a Supply of\nIO::Notification::Change events for a file or directory.\n\nHere is a small example that prints the first ten FileChanged-notifications\nfor the current working directory:\n\n    my $finish = Promise.new;\n    my $count = 0;\n    IO::Notification.watch-path($*CWD).act( -> $change {\n        $count++ if $change.event ~~ FileChanged;\n        say \"($count) $change.path(): $change.event()\";\n        $finish.keep if $count >= 10;\n    });\n    await $finish;\n\n\nThe type of the change is very much dependent both on the platform and on\nspecific system calls that were used initiate the change. At this point in\ntime you should not rely on the type of change in general, and test your\nparticular situation.\n\n",
      "name": "IO::Notification"
    },
    {
      "name": "IO::Socket",
      "desc": "TITLE\nrole IO::Socket\n\nSUBTITLE\nNetwork socket\n\n    role IO::Socket { ... }\n\nIO::Socket contains read and write methods for sockets. It is usually used\nthrough IO::Socket::INET.\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Special\n\nSUBTITLE\nPath to special I/O device\n\n    class IO::Special does IO { }\n\n\nUsed as a $.path attribute in filehandles for special standard input $*IN\nand output $*OUT and $*ERR. Provides a bridged interface of IO::Handle,\nmostly file tests and stringification.\n\n",
      "name": "IO::Special"
    },
    {
      "name": "IO::CatHandle",
      "desc": "TITLE\nclass IO::CatHandle\n\nSUBTITLE\nUse multiple IO handles as if they were one\n\n    class IO::CatHandle is IO::Handle { }\n\nThis class has been available in Rakudo since version 2017.06.\n\nThe IO::CatHandle|/type/IO::CatHandle class provides a means to create an\nIO::Handle that seamlessly gathers input from multiple IO::Handle and\nIO::Pipe sources.\n\nAll of the IO::Handle's methods are implemented, and while attempt to use\nwrite methods will (currently) throw and exception, an IO::CatHandle is\nusable anywhere a read-only IO::Handle can be used.\n\n"
    },
    {
      "name": "IO::ArgFiles",
      "desc": "TITLE\nclass IO::ArgFiles\n\nSUBTITLE\nIterate over contents of files specified on command line\n\n    class IO::ArgFiles is IO::CatHandle { }\n\nThis class exists for backwards compatibility reasons and provides no\nadditional methods to IO::CatHandle, so it can be used in the same way as\nit, for instance, in this way:\n\n    my $argfiles = IO::ArgFiles.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nIf invoked with perl6 io-argfiles.p6 *.p6 it will print the contents of all\nthe files with that extension in the directory. However, that is totally\nequivalent to:\n\n    my $argfiles = IO::CatHandle.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nVariables\n\n  $*ARGFILES\n\nThis class is the magic behind the $*ARGFILES variable, which provides a\nway to iterate over files passed in to the program on the command line\n(i.e. elements of @*ARGS). Thus the examples above can be simplified like\nso:\n\n    .say for $*ARGFILES.lines;\n\n    # or\n    while ! $*ARGFILES.eof {\n        say $*ARGFILES.get;\n    }\n\n    # or\n    say $*ARGFILES.slurp;\n\nSave one of the variations above in a file, say argfiles.p6. Then create\nanother file (named, say sonnet18.txt with the contents:\n\n    Shall I compare thee to a summer's day?\n\n\nRunning the command\n\n    $ perl6 argfiles.p6 sonnet18.txt\n\n\nwill then give the output\n\n    Shall I compare thee to a summer's day?\n\n\nAs of 6.d language, $*ARGFILES inside sub MAIN is always set to $*IN, even\nwhen @*ARGS is not empty. That means that\n\n    sub MAIN () {\n        .say for $*ARGFILES.lines;\n    }\n\n\nwhich can be used as cat *.p6 | perl6 argfiles-main.p6, for instance, is\ntotally equivalent to:\n\n    sub MAIN () {\n        .say for $*IN.lines;\n    }\n\n\nand, in fact, can't be used to process the arguments in the command line,\nsince, in this case, it would result in an usage error.\n\nBear in mind that the object $*ARGFILES is going to contain a handle for\nevery argument in a command line, even if that argument is not a valid\nfile. You can retrieve them via the .handles method.\n\n    for $*ARGFILES.handles -> $fh {\n        say $fh;\n    }\n\n\nThat code will fail if any of the arguments is not the valid name of a\nfile. You will have to deal with that case at another level, checking that\n@*ARGS contains valid file names, for instance."
    },
    {
      "name": "IO::Path",
      "desc": "TITLE\nclass IO::Path\n\nSUBTITLE\nFile or directory path\n\n    class IO::Path is Cool does IO { }\n\n\nIO::Path is the workhorse of IO operations.\n\nConceptually, an IO::Path object consists of a volume, a directory, and a\nbasename. It supports both purely textual operations, and operations that\naccess the filesystem, e.g. to resolve a path, or to read all content of a\nfile.\n\nAt creation, each IO::Path object is given information about the current\nworking directory the path might be relative to using the $.CWD attribute\n(defaults to $*CWD), as well as what operating system semantics should be\nused for path manipulation using the special IO::Spec type given in the\n$.SPEC attribute.\n\nThe $.SPEC defaults to the value of $*SPEC, which uses the object suitable\nfor the operating system the code is currently running on. This is the\ndefault most code will be comfortable with.\n\nIn certain situations, e.g. testing, you may wish to force $*SPEC to use\none of the specific SPEC modules: IO::Spec::Unix, IO::Spec::Win32,\nIO::Spec::Cygwin, and IO::Spec::QNX, or to create IO::Path objects via\nshortcut subclasses IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin, and\nIO::Path::QNX that pre-set the $.SPEC attribute for you.\n\nThe rest of this document silently assumes Unix semantics in its examples,\nunless stated otherwise.\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Spec\n\nSUBTITLE\nPlatform specific operations on file and directory paths\n\n    class IO::Spec { }\n\nObjects of this class are not used directly but as a sub-class specific to\nthe platform perl is running on via the $*SPEC variable which will contain\nan object of the appropriate type.\n\nThe sub-classes are documented separately, with the platform-specific\ndifferences documented in IO::Spec::Cygwin, IO::Spec::QNX, IO::Spec::Unix\nand IO::Spec::Win32.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n",
      "name": "IO::Spec"
    },
    {
      "name": "Supplier::Preserving",
      "desc": "TITLE\nclass Supplier::Preserving\n\nSUBTITLE\nCached live Supply factory\n\n    class Supplier::Preserving is Supplier { }\n\nThis is a factory for live Supply-type objects, and it provides the\nmechanism for emitting new values onto the supplies, whereby values are\nkept when no consumer has tapped into the Supply. Any tapping will consume\nthe already stored and future values.\n\nStarting a preserving Supply and consuming its values after it is done:\n\n    my $p = Supplier::Preserving.new;\n    start for ^3 {\n        $p.emit($_);\n        LAST {\n            say „done after { now - BEGIN now}s“;\n            $p.done;\n        }\n    }\n    sleep 2;\n    react {\n        whenever $p.Supply { $_.say; }\n        whenever Promise.in(2) { done }\n    }\n    say „also done after { now - BEGIN now }s“\n\nWill output:\n\n    done after 0.0638467s\n    0\n    1\n    2\n    also done after 4.0534119s\n\n\n"
    },
    {
      "name": "CX::Warn",
      "desc": "TITLE\nrole CX::Warn\n\nSUBTITLE\nControl exception warning\n\n    role CX::Warn does X::Control { }\n\nA control exception triggered when warn is called to warn about any\nincidence.\n\n"
    },
    {
      "name": "CX::Take",
      "desc": "TITLE\nrole CX::Take\n\nSUBTITLE\nTake control exception\n\n    role CX::Take does X::Control { }\n\nA control exception triggered by take.\n\n"
    },
    {
      "name": "CX::Return",
      "desc": "TITLE\nrole CX::Return\n\nSUBTITLE\nReturn control exception\n\n    role CX::Next does X::Control { }\n\nA control exception to be used when return is called from within a sub.\n\n"
    },
    {
      "name": "CX::Emit",
      "desc": "TITLE\nrole CX::Emit\n\nSUBTITLE\nEmit control exception\n\n    role CX::Emit does X::Control { }\n\nA control exception to be used when emit is used inside a Supply block.\n\n"
    },
    {
      "desc": "TITLE\nrole CX::Last\n\nSUBTITLE\nLast control exception\n\n    role CX::Last does X::Control { }\n\nA control exception that is thrown when last is called.\n\n",
      "name": "CX::Last"
    },
    {
      "name": "CX::Done",
      "desc": "TITLE\nrole CX::Done\n\nSUBTITLE\nDone control exception\n\n    role CX::Done does X::Control { }\n\nA control exception to be used to indicate a supply block is finished by\ncalling done.\n\n"
    },
    {
      "name": "CX::Proceed",
      "desc": "TITLE\nrole CX::Proceed\n\nSUBTITLE\nProceed control exception\n\n    role CX::Proceed does X::Control { }\n\nA control exception to be used when proceed is used within when or default\nblocks.\n\n"
    },
    {
      "desc": "TITLE\nrole CX::Succeed\n\nSUBTITLE\nSucceed control exception\n\n    role CX::Succeed does X::Control { }\n\nA control exception thrown when succeed is called from a when or default\nblock.\n\n",
      "name": "CX::Succeed"
    },
    {
      "desc": "TITLE\nrole CX::Redo\n\nSUBTITLE\nRedo control exception\n\n    role CX::Redo does X::Control { }\n\nA control exception thrown when redo is called.\n\n",
      "name": "CX::Redo"
    },
    {
      "name": "CX::Next",
      "desc": "TITLE\nrole CX::Next\n\nSUBTITLE\nNext control exception\n\n    role CX::Next does X::Control { }\n\nA control exception that is triggered when next is called.\n\n    for ^10 {\n        CONTROL {\n          when CX::Next { say \"We're next\" };\n        }\n        next if $_ %% 2;\n        say \"We're in $_\";\n    }\n\n\nThis will print:\n\n    We're next\n    We're in 1\n    We're next\n    We're in 3\n    We're next\n    We're in 5\n    We're next\n    We're in 7\n    We're next\n    We're in 9\n\n\n"
    },
    {
      "desc": "TITLE\nclass Metamodel::PackageHOW\n\nSUBTITLE\nMetaobject representing a Perl 6 package.\n\n    class Metamodel::PackageHOW\n      does Metamodel::Naming\n      does Metamodel::Documenting\n      does Metamodel::Stashing\n      does Metamodel::TypePretense\n      does Metamodel::MethodDelegation { }\n\nMetamodel::ClassHOW is the metaclass behind the package keyword.\n\n    package P {};\n    say P.HOW; # OUTPUT: «Perl6::Metamodel::PackageHOW.new␤»\n\nWarning: This class is part of the Rakudo implementation, not a part of the\nlanguage itself.\n\n",
      "name": "Metamodel::PackageHOW"
    },
    {
      "desc": "TITLE\nrole Metamodel::CurriedRoleHOW\n\nSUBTITLE\nSupport for parameterized roles that have not been instantiated\n\n    class Metamodel::CurriedRoleHOW\n        does Metamodel::Naming\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning {}\n\nSometimes, we see references to roles that provide parameters but do not\nfully resolve them. For example, in:\n\n    class C does R[Type] { }\n\n\nWe need to represent R[T], but we cannot yet fully specialize the role\nbecause we don't have the first parameter at hand. We may also run into the\nissue where we have things like:\n\n    sub foo(R[T] $x) { ... }\n    if $x ~~ R[T] { ... }\n\n\nWhere we clearly want to talk about a partial parameterization of a role\nand actually want to do so in a way distinct from a particular\ninstantiation of it. This metaobject represents those \"partial types\" as\nboth a way to curry on your way to a full specialization, but also as a way\nto do type-checking or punning.\n\nThis class will show up in parameterized roles. For instance:\n\n    role Zipi[::T] {\n        method zape { \"Uses \" ~ T.^name };\n    }\n    role Zipi[::T, ::Y] {\n        method zape { \"Uses \" ~ T.^name ~ \" and \" ~ Y.^name };\n    }\n    for Zipi[Int], Zipi[Int,Str] -> $role {\n        say $role.HOW;\n        say $role.new().zape;\n    }\n    # OUTPUT:\n    # Perl6::Metamodel::CurriedRoleHOW.new\n    # Uses Int\n    # Perl6::Metamodel::CurriedRoleHOW.new\n    # Uses Int and Str\n\n\nSince there are several variants of Zipi, providing a parameter curries it,\nbut it's still up to the compiler to find out the actual realization taking\ninto account the ParametricRoleGroup, so these (partially instantiated)\nroles show up as Metamodel::CurriedRoleHOW as shown in the example; even if\nthere's a single parameter an instantiated role will also be of the same\ntype:\n\n    role Zape[::T] {};\n    say Zape[Int].HOW; #: «Perl6::Metamodel::CurriedRoleHOW.new␤»\n\nNote: As most of the Metamodel classes, this class is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate.",
      "name": "Metamodel::CurriedRoleHOW"
    },
    {
      "desc": "TITLE\nrole Metamodel::C3MRO\n\nSUBTITLE\nMetaobject that supports the C3 method resolution order\n\n    role Metamodel::C3MRO { }\n\nMetamodel role for the C3 method resolution order (MRO). Note: this method,\nalong with almost the whole metamodel, is part of the Rakudo\nimplementation.\n\nThe method resolution order for a type is a flat list of types including\nthe type itself, and (recursively) all super classes. It determines in\nwhich order the types will be visited for determining which method to call\nwith a given name, or for finding the next method in a chain with nextsame,\ncallsame, nextwith or callwith.\n\n    class CommonAncestor { };   # implicitly inherits from Any\n    class Child1 is CommonAncestor { }\n    class Child2 is CommonAncestor { }\n    class GrandChild2 is Child2 { }\n    class Weird is Child1 is GrandChild2 { };\n\n    say Weird.^mro; # OUTPUT: «(Weird) (Child1) (GrandChild2) (Child2) (CommonAncestor) (Any) (Mu)␤»\n\n\nC3 is the default resolution order for classes and grammars in Perl 6. Note\nthat roles generally do not appear in the method resolution order (unless\nthey are punned into a class, from which another type inherits), because\nmethods are copied into classes at role application time.\n\n",
      "name": "Metamodel::C3MRO"
    },
    {
      "name": "Metamodel::AttributeContainer",
      "desc": "TITLE\nrole Metamodel::AttributeContainer\n\nSUBTITLE\nMetaobject that can hold attributes\n\n    role Metamodel::AttributeContainer {}\n\nClasses, roles and grammars can have attributes. Storage and introspection\nof attributes is implemented by this role.\n\n"
    },
    {
      "desc": "TITLE\nrole Metamodel::Versioning\n\nSUBTITLE\nMetaobjects that support versioning\n\n    role Metamodel::Versioning { ... }\n\nMetamodel role for (optionally) versioning metaobjects.\n\nWhen you declare a type, you can pass it a version, author, and/or API and\nget them, like so:\n\n    class Versioned:ver<0.0.1>:auth<github:Kaiepi>:api<1> { }\n\n    say Versioned.^ver;  # OUTPUT: «v0.0.1␤»\n    say Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\n    say Versioned.^api;  # OUTPUT: «1␤»\n\n\nThis is roughly equivalent to the following, which also sets them\nexplicitly:\n\n    BEGIN {\n        class Versioned { }\n        Versioned.^set_ver:  v0.0.1;\n        Versioned.^set_auth: 'github:Kaiepi';\n        Versioned.^set_api:  <1>;\n    }\n\n    say Versioned.^ver;  # OUTPUT: «v0.0.1␤»\n    say Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\n    say Versioned.^api;  # OUTPUT: «1␤»\n\n\n",
      "name": "Metamodel::Versioning"
    },
    {
      "desc": "TITLE\nrole Metamodel::Trusting\n\nSUBTITLE\nMetaobject that supports trust relations between types\n\n    role Metamodel::Trusting is SuperClass { ... }\n\n\nNormally, code in a class or role can only access its own private methods.\nIf another type declares that it trusts that first class, then access to\nprivate methods of that second type is possible. Metamodel::Trusting\nimplements that aspect of the Perl 6 object system.\n\n    class A {\n        my class B {\n            trusts A;   # that's where Metamodel::Trusting comes in\n            method !private_method() {\n                say \"Private method in B\";\n            }\n        }\n        method build-and-poke {\n            # call a private method from B\n            # disallowed if A doesn't trust B\n            B.new()!B::private_method();\n        }\n    };\n\n    A.build-and-poke;   # Private method in A\n\n",
      "name": "Metamodel::Trusting"
    },
    {
      "name": "Metamodel::RolePunning",
      "desc": "TITLE\nrole Metamodel::RolePunning\n\nSUBTITLE\nMetaobject that supports punning of roles.\n\n    role Perl6::Metamodel::RolePunning {}\n\nImplements the ability to create objects from Roles without the\nintermediate need to use a class. Not intended to be used directly (will in\nfact error if it's used), but via punning of roles, as below. This is also\nRakudo specific and not part of the spec.\n\n    role A {\n        method b {\n          return \"punned\"\n        }\n    };\n    my $a = A.new;\n    say $a.b; # OUTPUT: «punned␤»\n"
    },
    {
      "name": "Metamodel::ClassHOW",
      "desc": "TITLE\nclass Metamodel::ClassHOW\n\nSUBTITLE\nMetaobject representing a Perl 6 class.\n\n    class Metamodel::ClassHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Versioning\n        does Metamodel::Stashing\n        does Metamodel::AttributeContainer\n        does Metamodel::MethodContainer\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::DefaultParent\n        does Metamodel::C3MRO\n        does Metamodel::MROBasedMethodDispatch\n        does Metamodel::MROBasedTypeChecking\n        does Metamodel::Trusting\n        does Metamodel::BUILDPLAN\n        does Metamodel::Mixins\n        does Metamodel::ArrayType\n        does Metamodel::BoolificationProtocol\n        does Metamodel::REPRComposeProtocol\n        does Metamodel::InvocationProtocol\n        does Metamodel::Finalization\n            { }\n\nMetamodel::ClassHOW is the metaclass behind the class keyword.\n\n    say so Int.HOW ~~ Metamodel::ClassHOW;    # OUTPUT: «True␤»\n    say Int.^methods(:all).pick.name;         # OUTPUT: «random Int method name␤»\n\nWarning: This class is part of the Rakudo implementation, not a part of the\nlanguage itself.\n\n"
    },
    {
      "name": "Metamodel::RoleContainer",
      "desc": "TITLE\nrole Metamodel::RoleContainer\n\nSUBTITLE\nMetaobject that supports holding/containing roles\n\n    role Metamodel::RoleContainer {}\n\nImplements the ability to hold roles to be held for composition.\n\n    class A does SomeRole {}\n\n\nroughly corresponds to\n\n    class A {\n        BEGIN A.^add_role(SomeRole);\n    }\n\n\n"
    },
    {
      "desc": "TITLE\nclass Metamodel::EnumHOW\n\nSUBTITLE\nMetaobject representing a Perl 6 enum.\n\n    class Metamodel::EnumHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Stashing\n        does Metamodel::AttributeContainer\n        does Metamodel::MethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::RoleContainer\n        does Metamodel::BaseType\n        does Metamodel::MROBasedMethodDispatch\n        does Metamodel::MROBasedTypeChecking\n        does Metamodel::BUILDPLAN\n        does Metamodel::BoolificationProtocol\n        does Metamodel::REPRComposeProtocol\n        does Metamodel::InvocationProtocol\n        does Metamodel::Mixins\n            { }\n\nMetamodel::EnumHOW is the metaclass behind the enum keyword.\n\n    enum Numbers <1 2>;\n    say Numbers.HOW ~~ Metamodel::EnumHOW; # OUTPUT: «True␤»\n\nThe following enum declaration:\n\n    our Int enum Error <Warning Failure Exception Sorrow Panic>;\n\nIs roughly equivalent to this code using Metamodel::EnumHOW's methods:\n\n    BEGIN {\n        my constant Error = Metamodel::EnumHOW.new_type: :name<Error>, :base_type(Int);\n        Error.^add_role: Enumeration;\n        Error.^add_role: NumericEnumeration;\n        Error.^compose;\n        for <Warning Failure Exception Sorrow Panic>.kv -> Int $v, Str $k {\n            # Note: Enumeration.pred and .succ will not work when adding enum\n            # values as pairs. They should be instances of the enum itself, but\n            # this isn't possible to do without nqp.\n            Error.^add_enum_value: $k => $v;\n            OUR::{$k} := Error.^enum_from_value: $v;\n        }\n        Error.^compose_values;\n        OUR::<Error> := Error;\n    }\n\nWarning: This class is part of the Rakudo implementation, and is not a part\nof the language specification.\n\n",
      "name": "Metamodel::EnumHOW"
    },
    {
      "name": "Metamodel::PrivateMethodContainer",
      "desc": "TITLE\nrole Metamodel::PrivateMethodContainer\n\nSUBTITLE\nMetaobject that supports private methods\n\n    role Metamodel::PrivateMethodContainer { ... }\n\nIn Perl 6, classes, roles and grammars can have private methods, that is,\nmethods that are only callable from within the class, and are not inherited\nby types derived by inheritance.\n\n    class A {\n        # the ! declares a private method\n        method !double($x) {\n            say 2 * $x;\n        }\n        method call-double($y) {\n            # call with ! instead of .\n            self!double($y);\n        }\n    }\n\nFor the purposes of dispatching and scoping, private methods are closer to\nsubroutines than to methods. However they share access to self and\nattributes with methods.\n\n"
    },
    {
      "desc": "TITLE\nrole Metamodel::MethodContainer\n\nSUBTITLE\nMetaobject that supports storing and introspecting methods\n\n    role Metamodel::MethodContainer {}\n\nroles, classes, grammars and enums can contain methods. This role\nimplements the API around storing and introspecting them.\n\n    say .name for Int.^methods(:all);\n\n    # don't do that, because it changes type Int globally.\n    # just for demonstration purposes.\n    Int.^add_method('double', method ($x:) { 2 * $x });\n    say 21.double; # OUTPUT: «42␤»\n\n",
      "name": "Metamodel::MethodContainer"
    },
    {
      "name": "Metamodel::Primitives",
      "desc": "TITLE\nclass Metamodel::Primitives\n\nSUBTITLE\nMetaobject that supports low-level type operations\n\n    class Metamodel::Primitives {}\n\nMetamodel::Primitives provides low-level operations for working with types,\nwhich are otherwise only available as implementation-dependent directives.\nThese primitives are available as class methods.\n\nHere is an example that steals the metamodel instance from the Int class to\ncreate a custom type (usually you would create your own metaclass if you\nmess with something as low-level), which allows calling of just one method\ncalled why:\n\n    my Mu $type := Metamodel::Primitives.create_type(Int.HOW, 'P6opaque');\n    $type.^set_name('why oh why?');\n    my %methods =  why => sub ($) { say 42 };\n    Metamodel::Primitives.install_method_cache($type, %methods, :authoritative);\n    $type.why;      # 42\n    $type.list;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::NotFound: Method 'list' not found for invocant of class 'why oh why?'␤»\n\n"
    },
    {
      "desc": "TITLE\nrole Metamodel::Finalization\n\nSUBTITLE\nMetaobject supporting object finalization\n\n    role Metamodel::Finalization { ... }\n\nThis role takes care that DESTROY submethods are called (if they exist)\nwhen an object is garbage-collected.\n\n",
      "name": "Metamodel::Finalization"
    },
    {
      "desc": "TITLE\nrole Metamodel::MultipleInheritance\n\nSUBTITLE\nMetaobject that supports multiple inheritance\n\n    role Metamodel::MultipleInheritance {}\n\nClasses, roles and grammars can have parent classes, that is, classes to\nwhich method lookups fall back to, and to whose type the child class\nconforms to.\n\nThis role implements the capability of having zero, one or more parent (or\nsuper) classes.\n\nIn addition, it supports the notion of hidden classes, whose methods are\nexcluded from the normal dispatching chain, so that for example nextsame\nignores it.\n\nThis can come in two flavors: methods from a class marked as is hidden are\ngenerally excluded from dispatching chains, and class A hides B adds B as a\nparent class to A, but hides it from the method resolution order, so that\nmro_unhidden skips it.\n\n",
      "name": "Metamodel::MultipleInheritance"
    },
    {
      "desc": "TITLE\nrole Metamodel::ParametricRoleHOW\n\nSUBTITLE\nRepresents a non-instantiated, parameterized, role.\n\n    class Metamodel::ParametricRoleHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Versioning\n        does Metamodel::MethodContainer\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::AttributeContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::Stashing\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning\n        does Metamodel::ArrayType {}\n\nA Metamodel::ParametricRoleHOW represents a non-instantiated, possibly\nparameterized, role:\n\n    (role Zape[::T] {}).HOW.say;# OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n    (role Zape {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nAs usual, .new_type will create a new object of this class.\n\n    my \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zape\", group => \"Zape\");\n    say zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nThe extra group argument will need to be used to integrate it in a\nparametric role group, which will need to be defined in advance.\n\nNote: As most of the Metamodel classes, this one is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate, unless their intention is really to create a parametric role\ngroup.",
      "name": "Metamodel::ParametricRoleHOW"
    },
    {
      "desc": "TITLE\nrole Metamodel::ParametricRoleGroupHOW\n\nSUBTITLE\nRepresents a group of roles with different parameterizations\n\n    class Metamodel::ParametricRoleGroupHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Stashing\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning\n        does Metamodel::BoolificationProtocol {}\n\nA ParametricRoleGroupHOW groups a set of ParametricRoleHOW, every one of\nthem representing a single role declaration with their own parameter sets.\n\n    (role Zape[::T] {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n    Zape.HOW.say ; # OUTPUT: «Perl6::Metamodel::ParametricRoleGroupHOW.new␤»\n\n\nParametricRoleHOWs need to be added to this kind of group:\n\n    my \\zape := Metamodel::ParametricRoleGroupHOW.new_type( name => \"zape\");\n    my \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zipi\", group => zape);\n    say zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nNote: As most of the Metamodel classes, this class is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate.",
      "name": "Metamodel::ParametricRoleGroupHOW"
    },
    {
      "desc": "TITLE\nrole Metamodel::MROBasedMethodDispatch\n\nSUBTITLE\nMetaobject that supports resolving inherited methods\n\n    role Metamodel::MROBasedMethodDispatch { }\n\nThis role implements locating methods based on the method resolution order\nof related (usually \"super\"/\"parent\") types.\n\n",
      "name": "Metamodel::MROBasedMethodDispatch"
    },
    {
      "name": "Metamodel::ConcreteRoleHOW",
      "desc": "TITLE\nrole Metamodel::ConcreteRoleHOW\n\nSUBTITLE\nProvides an implementation of a concrete instance of a role\n\n    class Metamodel::ConcreteRoleHOW\n        does Metamodel::Naming\n        does Metamodel::Versioning\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::AttributeContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::ArrayType\n        does Metamodel::Concretization {}\n\nYou can use this to build roles, in the same way that ClassHOW can be used\nto build classes:\n\n    my $a = Metamodel::ConcreteRoleHOW.new_type(name => \"Bar\");\n    $a.^compose;\n    say $a.^roles; # OUTPUT: «(Mu)␤»\n\n\nThe main difference with ClassHOW.new_type is that you can mix-in roles in\nthis newly created one.\n\nThis class is Rakudo specific, and provided only for completeness. Not\nreally intended to be used by the final user."
    },
    {
      "name": "Metamodel::Naming",
      "desc": "TITLE\nrole Metamodel::Naming\n\nSUBTITLE\nMetaobject that supports named types\n\n    role Metamodel::Naming { }\n\nMetamodel role for (optionally) named things, like classes, roles and\nenums.\n\n"
    },
    {
      "name": "Telemetry::Period",
      "desc": "TITLE\nclass Telemetry::Period\n\nSUBTITLE\nPerformance data over a period\n\n    class Telemetry::Period is Telemetry { }\n\n\nNote:  This class is a Rakudo-specific feature and not standard Perl 6.\n\n    # basic usage\n    use Telemetry;\n    my $t0 = Telemetry.new;\n    # execute some code\n    my $t1 = Telemetry.new;\n    my $period = $t1 - $t0;  # creates Telemetry::Period object\n    say \"Code took $period<wallclock> microseconds to execute\";\n\n\nA Telemetry::Period object contains the difference between two Telemetry\nobjects. It is generally not created by calling .new, but it can be if\nneeded. For all practical purposes, it is the same as the Telemetry object,\nbut the meaning of the values is different (and the values are generally\nmuch smaller, as they usually are the difference of two big values of the\nTelemetry objects from which it was created)."
    },
    {
      "desc": "TITLE\nclass Telemetry::Sampler\n\nSUBTITLE\nTelemetry instrument pod\n\n    class Telemetry::Sampler { }\n\n\nNote:  This class is a Rakudo-specific feature and not standard Perl 6.\n\n    use Telemetry;\n    $*SAMPLER.set-instruments(<Usage ThreadPool>); # default setting\n\n\nOne usually does not create any Telemetry::Sampler objects: when the\nTelemetry module is loaded, a Telemetry::Sampler object is automatically\ncreated in the $*SAMPLER dynamic variable.\n\nAn object of the Telemetry::Sampler class knows about which instruments to\nuse when making a snapshot.\n\n  method new\n\n    method new(Telemetry::Sampler: @instruments --> Telemetry::Sampler:D)\n\n\nThe new method takes a list of instruments. If no instruments are\nspecified, then it will look at the RAKUDO_TELEMETRY_INSTRUMENTS\nenvironment variable to find specification of instruments. If that is not\navailable either, then Telemetry::Instrument::Usage and\nTelemetry::Instrument::ThreadPool will be assumed.\n\nInstruments can be specified by either the type object of the instrument\nclass (e.g. Telemetry::Instrument::Usage) or by a string, in which case it\nwill be automatically prefixed with \"Telemetry::Instrument::\", so \"Usage\"\nwould be the same as Telemetry::Instrument::Usage.\n\n  method set-instruments\n\n    method set-instruments(Telemetry::Sampler:D @instruments --> Nil)\n\n\nAllows one to change the instruments on an existing Instrument::Sampler\nobject. Generally only used by calling it on the $*SAMPLER dynamic\nvariable. Takes the same parameters as new, except that specifying no\ninstruments will actually remove all of the instruments, effectively\nblocking any snap taking.",
      "name": "Telemetry::Sampler"
    },
    {
      "desc": "TITLE\nclass Distribution::Locally\n\nSUBTITLE\nDistribution::Locally\n\n    role Distribution::Locally does Distribution { }\n\nProvides read access to specific files pointed at by a distributions\nmetadata, providing the Distribution#method_content method for\nDistribution::Path and Distribution::Hash.\n\n",
      "name": "Distribution::Locally"
    },
    {
      "name": "Distribution::Path",
      "desc": "TITLE\nclass Distribution::Path\n\nSUBTITLE\nDistribution::Path\n\n        class Distribution::Path does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It requires a\nMETA6.json file at its root.\n\n"
    },
    {
      "desc": "TITLE\nclass Distribution::Hash\n\nSUBTITLE\nDistribution::Hash\n\n        class Distribution::Hash does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It does not require\na META6.json file, essentially providing a lower level Distribution::Path.\n\n",
      "name": "Distribution::Hash"
    },
    {
      "desc": "TITLE\nclass X::NYI\n\nSUBTITLE\nError due to use of an unimplemented feature\n\n    class X::NYI is Exception { }\n\nError class for unimplemented features. NYI stands for Not Yet\nImplemented.\n\nIf a Perl 6 compiler is not yet feature complete, it may throw an X::NYI\nexception when a program uses a feature that it can detect and is somehow\nspecified is not yet implemented.\n\nA full-featured Perl 6 compiler must not throw such exceptions, but still\nprovide the X::NYI class for compatibility reasons.\n\nA typical error message is\n\n    HyperWhatever is not yet implemented. Sorry.\n\n\n",
      "name": "X::NYI"
    },
    {
      "desc": "TITLE\nclass X::Bind\n\nSUBTITLE\nError due to binding to something that is not a variable or container\n\n    class X::Bind is Exception {}\n\nIf you write code like this:\n\n    floor(1.1) := 42;\n\n\nit dies with an X::Bind exception:\n\n    Cannot use bind operator with this left-hand side\n",
      "name": "X::Bind"
    },
    {
      "name": "X::IO",
      "desc": "TITLE\nrole X::IO\n\nSUBTITLE\nIO related error\n\n    role X::IO does X::OS {}\n\nCommon role for IO related errors.\n\nThis role does not provide any additional methods."
    },
    {
      "name": "X::Syntax",
      "desc": "TITLE\nrole X::Syntax\n\nSUBTITLE\nSyntax error thrown by the compiler\n\n    role X::Syntax does X::Comp { }\n\nCommon role for syntax errors thrown by the compiler."
    },
    {
      "desc": "TITLE\nrole X::Temporal\n\nSUBTITLE\nError related to DateTime or Date\n\n    role X::Temporal is Exception { }\n\nA common exception type for all errors related to DateTime or Date.",
      "name": "X::Temporal"
    },
    {
      "name": "X::AdHoc",
      "desc": "TITLE\nclass X::AdHoc\n\nSUBTITLE\nError with a custom message\n\n    class X::AdHoc is Exception { }\n\n\nX::AdHoc is the type into which objects are wrapped if they are thrown as\nexceptions, but don't inherit from Exception.\n\nIts benefit over returning non-Exception objects is that it gives access to\nall the methods from class Exception, like backtrace and rethrow.\n\nYou can obtain the original object with the payload method.\n\n    try {\n        die [404, 'File not found']; # throw non-exception object\n    }\n    print \"Got HTTP code \",\n        $!.payload[0],          # 404\n        \" and backtrace \",\n        $!.backtrace.Str;\n\nNote that young code will often be prototyped using X::AdHoc and then later\nbe revised to use more specific subtypes of Exception. As such it is\nusually best not to explicitly rely on receiving an X::AdHoc – in many\ncases using the string returned by the .message method, which all\nExceptions must have, is preferable. Please note that we need to explicitly\ncall .Str to stringify the backtrace correctly.\n\n"
    },
    {
      "desc": "TITLE\nrole X::Comp\n\nSUBTITLE\nCommon role for compile-time errors\n\n    role X::Comp is Exception { }\n\nCommon role for compile-time errors.\n\nNote that since the backtrace of a compile time error generally shows\nroutines from the compiler, not from user-space programs, the Backtrace\nreturned from the backtrace method is not very informative. Instead the\nexception carries its own filename, line and column attributes and public\naccessors.\n\nIf an error occurs while creating an object (like a class or routine) at\ncompile time, generally the exception associated with it does not hold a\nreference to the object (for example a class would not be fully composed,\nand thus not usable). In those cases the name of the would-be-created\nobject is included in the error message instead.\n\n",
      "name": "X::Comp"
    },
    {
      "desc": "TITLE\nrole X::Pod\n\nSUBTITLE\nPod related error\n\n    role X::Pod { }\n\nCommon role for Pod related errors.",
      "name": "X::Pod"
    },
    {
      "desc": "TITLE\nclass X::OutOfRange\n\nSUBTITLE\nError due to indexing outside of an allowed range\n\n    class X::OutOfRange is Exception { }\n\nGeneral error when something (for example an array index) is out of an\nallowed range.\n\nFor example\n\n    say 42[2];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::OutOfRange: Index out of range. Is: 2, should be in 0..0␤»\n\nsince scalars generally act as a one-element list.\n\n",
      "name": "X::OutOfRange"
    },
    {
      "desc": "TITLE\nrole X::OS\n\nSUBTITLE\nError reported by the operating system\n\n    role X::OS { has $.os-error }\n\nCommon role for all exceptions that are triggered by some error reported by\nthe operating system (failed IO, system calls, fork, memory allocation).\n\n",
      "name": "X::OS"
    },
    {
      "name": "X::Control",
      "desc": "TITLE\nrole X::Control\n\nSUBTITLE\nRole for control exceptions\n\n    role X::Control is Exception { }\n\nThis role turns an exception into a control exception, such as CX::Next or\nCX::Take. It has got no code other than the definition.\n\nSince Rakudo 2019.03, throwing an object that mixes in this role X::Control\ncan raise a control exception which is caught by the CONTROL phaser instead\nof CATCH. This allows to define custom control exceptions.\n\nFor example, the custom CX::Oops control exception we define below:\n\n    class CX::Vaya does X::Control {\n        has $.message\n    }\n\n    sub ea {\n        CONTROL {\n            default {\n                say \"Controlled { .^name }: { .message }\"\n            }\n        }\n        CX::Vaya.new( message => \"I messed up!\" ).throw;\n\n    }\n    ea;\n    # OUTPUT: «Controlled CX::Vaya: I messed up!␤»\n"
    },
    {
      "desc": "TITLE\nclass X::TypeCheck\n\nSUBTITLE\nError due to a failed type check\n\n    class X::TypeCheck is Exception { }\n\nError class thrown when a type check fails.\n\n",
      "name": "X::TypeCheck"
    },
    {
      "desc": "TITLE\nclass X::ControlFlow\n\nSUBTITLE\nError due to calling a loop control command in an ineligible scope\n\n    class X::ControlFlow is Exception { }\n\nThrown when a control flow construct (such as next or redo) is called\noutside the dynamic scope of an enclosing construct that is supposed to\ncatch them.\n\nFor example\n\n    last;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow: last without loop construct␤»\n\n",
      "name": "X::ControlFlow"
    },
    {
      "desc": "TITLE\nclass X::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared symbol\n\n    class X::Undeclared does X::Comp {}\n\nThrown when the compiler encounters a symbol that has not been declared,\nbut needs to be.\n\nExample\n\n    $x;\n\n\nresults in\n\n    ===SORRY!===\n    Variable $x is not declared\n\n\n",
      "name": "X::Undeclared"
    },
    {
      "desc": "TITLE\nclass X::StubCode\n\nSUBTITLE\nRuntime error due to execution of stub code\n\n    class X::StubCode is Exception { }\n\nThrown when a piece of stub code (created via !!! or ...) is executed.\n\n",
      "name": "X::StubCode"
    },
    {
      "name": "X::NoDispatcher",
      "desc": "TITLE\nclass X::NoDispatcher\n\nSUBTITLE\nError due to calling a dispatch command in an ineligible scope\n\n    class X::NoDispatcher is Exception { }\n\nWhen a redispatcher like nextsame is called without being in the dynamic\nscope of a call where a redispatch is possible, an X::NoDispatcher is\nthrown.\n\nFor example\n\n    nextsame; # In the mainline\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::NoDispatcher: nextsame is not in the dynamic scope of a dispatcher␤»\n\n"
    },
    {
      "name": "X::Redeclaration",
      "desc": "TITLE\nclass X::Redeclaration\n\nSUBTITLE\nCompilation error due to declaring an already declared symbol\n\n    class X::Redeclaration does X::Comp { }\n\nThrown when a symbol (variable, routine, type, parameter, ...) is\nredeclared. Note that redeclarations are generally fine in an inner scope,\nbut if the redeclaration appears in the same scope as the original\ndeclaration, it usually indicates an error and is treated as one.\n\nExamples\n\n    my $x; my $x;\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of symbol $x\n\n\nIt works with routines too:\n\n    sub f() { }\n    sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of routine f\n\n\nBut those are fine\n\n    my $x;\n    sub f() {\n        my $x;          # not a redeclaration,\n                        # because it's in an inner scope\n        sub f() { };    # same\n    }\n\n\n"
    },
    {
      "name": "X::Obsolete",
      "desc": "TITLE\nclass X::Obsolete\n\nSUBTITLE\nCompilation error due to use of obsolete syntax\n\n    class X::Obsolete does X::Comp { }\n\nSyntax error thrown when the user is attempting to use constructs from\nother languages.\n\nFor example\n\n    m/abc/i\n\n\ndies with\n\n    ===SORRY!===\n    Unsupported use of /i; in Perl 6 please use :i\n\n\n"
    },
    {
      "desc": "TITLE\nclass Backtrace::Frame\n\nSUBTITLE\nSingle frame of a Backtrace\n\n    class Backtrace::Frame { }\n\nA single backtrace frame. It identifies a location in the source code.\n\n",
      "name": "Backtrace::Frame"
    },
    {
      "name": "Pod::Block::Declarator",
      "desc": "TITLE\nclass Pod::Block::Declarator\n\nSUBTITLE\nDeclarator block in a Pod document\n\n    class Pod::Block::Declarator is Pod::Block { }\n\nClass for a declarator Pod block\n\n"
    },
    {
      "desc": "TITLE\nclass Pod::Block::Code\n\nSUBTITLE\nVerbatim code block in a Pod document\n\n    class Pod::Block::Code is Pod::Block { }\n\nClass for a code (verbatim) Pod block.\n\n",
      "name": "Pod::Block::Code"
    },
    {
      "desc": "TITLE\nclass Pod::Block::Table\n\nSUBTITLE\nTable in a Pod document\n\n    class Pod::Block::Table is Pod::Block { }\n\nClass for a table in a Pod document.\n\n",
      "name": "Pod::Block::Table"
    },
    {
      "desc": "TITLE\nclass Pod::Block::Named\n\nSUBTITLE\nNamed block in a Pod document\n\n    class Pod::Block::Named is Pod::Block { }\n\nClass for a named Pod block. For example\n\n    =begin MySection\n    ...\n    =end MySection\n\n\ncreates a Pod::Block::Named with name MySection.\n\n",
      "name": "Pod::Block::Named"
    },
    {
      "name": "Pod::Block::Para",
      "desc": "TITLE\nclass Pod::Block::Para\n\nSUBTITLE\nParagraph in a Pod document\n\n    class Pod::Block::Para is Pod::Block { }\n\nClass for a Pod paragraph."
    },
    {
      "name": "Pod::Block::Comment",
      "desc": "TITLE\nclass Pod::Block::Comment\n\nSUBTITLE\nComment in a Pod document\n\n    class Pod::Block::Comment is Pod::Block { }\n\nClass for a Pod comment."
    },
    {
      "desc": "TITLE\nclass CompUnit::Repository::Installation\n\nSUBTITLE\nCompUnit::Repository::Installation\n\n    class CompUnit::Repository::Installation\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository::Installable\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem, but uses an\ninternal storage format to:\n\n  * Handle case sensitivity issues on filesystems that may conflict as a\n  CompUnit::Repository::FileSystem.\n\n  * Handle allowable filename issues (e.g. unicode) on filesystems that don't\n  support them.\n\n  * Allow multiple distributions with the same name, but with different ver\n  and/or auth and/or api values, to be installed and separately accessible in\n  a single repository.\n\n  * Enable faster module loading by providing module precompilation.\n\nBecause of the internal storage format the usual way to add a distribution\nis not by copying files but by calling\nCompUnit::Repository::Installation#method_install.\n\n",
      "name": "CompUnit::Repository::Installation"
    },
    {
      "name": "CompUnit::Repository::FileSystem",
      "desc": "TITLE\nclass CompUnit::Repository::FileSystem\n\nSUBTITLE\nCompUnit::Repository::FileSystem\n\n    class CompUnit::Repository::FileSystem\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem typically\nused in development situations. This is what is used by -I . / -I lib\n(which are actually -I file#. and -I file#lib) or use lib \".\" / use lib\n\"lib\". Unlike CompUnit::Repository::Installation, this represents a single\ndistribution.\n\n"
    },
    {
      "name": "IO::Socket::INET",
      "desc": "TITLE\nclass IO::Socket::INET\n\nSUBTITLE\nTCP Socket\n\n    class IO::Socket::INET does IO::Socket {}\n\n\nIO::Socket::INET provides TCP sockets, both the server and the client\nside.\n\nFor UDP support, please see IO::Socket::Async.\n\nHere is an example of a very simplistic \"echo\" server that listens on\nlocalhost, port 3333:\n\n    my $listen = IO::Socket::INET.new( :listen,\n                                       :localhost<localhost>,\n                                       :localport(3333) );\n    loop {\n        my $conn = $listen.accept;\n        try {\n            while my $buf = $conn.recv(:bin) {\n                $conn.write: $buf;\n            }\n        }\n        $conn.close;\n\n        CATCH {\n              default { .payload.say;      }\n        }\n\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    my $conn = IO::Socket::INET.new( :host<localhost>,\n                                     :port(3333) );\n    $conn.print: 'Hello, Perl 6';\n    say $conn.recv;\n    $conn.close;\n\n\nPlease bear in mind that this is a synchronous connection; an attempt by\nany of the nodes to write without the other reading will produce an Could\nnot receive data from socket: Connection reset by peer error.\n\n"
    },
    {
      "name": "IO::Socket::Async",
      "desc": "TITLE\nclass IO::Socket::Async\n\nSUBTITLE\nAsynchronous socket in TCP or UDP\n\n    class IO::Socket::Async {}\n\nIO::Socket::Async|/type/IO::Socket::Async provides asynchronous sockets,\nfor both the server and the client side.\n\nHere is a simple example of a simple \"hello world\" HTTP server that listens\non port 3333:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3333) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n        }\n        CATCH {\n            default {\n                say .^name, ': ', .Str;\n                say \"handled in $?LINE\";\n            }\n        }\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    await IO::Socket::Async.connect('127.0.0.1', 3333).then( -> $promise {\n        given $promise.result {\n            .print(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\");\n            react {\n                whenever .Supply() -> $v {\n                    $v.print;\n                    done;\n                }\n            }\n            .close;\n        }\n    });\n\n\nIO::Socket::Async can also send and receive UDP messages An example server\nthat outputs all the data it receives would be:\n\n    my $socket = IO::Socket::Async.bind-udp('localhost', 3333);\n\n    react {\n        whenever $socket.Supply -> $v {\n            if $v.chars > 0 {\n                say $v;\n            }\n        }\n    }\n\n\nAnd an associated client might be:\n\n    my $socket = IO::Socket::Async.udp();\n    await $socket.print-to('localhost', 3333, \"Hello, Perl 6!\");\n\n\nThe CATCH phaser can be included to deal specifically with problems that\nmight occur in this kind of sockets, such as a port being already taken:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3000) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n            QUIT {\n                default {\n                    say .^name, '→ ', .Str;\n                    say \"handled in line $?LINE\";\n                }\n            }\n        }\n\n    }\n    # Will print this, if address 3000 is already in use:\n    # X::AdHoc→ address already in use\n    # handled in 23\n\n\nMain difference with using other phasers such as CATCH is that this kind of\nexception will be caught within the whenever block and will put exiting the\nprogram, or not, under your control.\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Spec::Cygwin\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Cygwin\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec will be available from the $*SPEC variable for a\nperl running on Cygwin .\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n",
      "name": "IO::Spec::Cygwin"
    },
    {
      "desc": "TITLE\nclass IO::Spec::QNX\n\nSUBTITLE\nPlatform specific operations on file and directory paths QNX\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec specific to QNX will be available via $*SPEC if\nthe perl is running on QNX.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n",
      "name": "IO::Spec::QNX"
    },
    {
      "name": "IO::Spec::Unix",
      "desc": "TITLE\nclass IO::Spec::Unix\n\nSUBTITLE\nPlatform specific operations on file and directory paths for POSIX\n\n    class IO::Spec::Unix is IO::Spec  { }\n\nOn object of this type is available via the variable $*SPEC if the Perl 6\ninterpreter is running on a Unix-like platform.\n\nThe IO::Spec::* classes provide low-level path operations. Unless you're\ncreating your own high-level path manipulation routines, you don't need to\nuse IO::Spec::*. Use IO::Path instead.\n\nBeware that no special validation is done by these classes (e.g. check\nwhether path contains a null character). It is the job of higher-level\nclasses, like IO::Path, to do that.\n\n"
    },
    {
      "name": "IO::Spec::Win32",
      "desc": "TITLE\nclass IO::Spec::Win32\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Windows\n\n    class IO::Spec::Win32 is IO::Spec { }\n\nObjects of this class are used not directly but as a sub-class specific to\nthe platform Perl 6 is running on via the $*SPEC variable, which will\ncontain an object of the appropriate type.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Path::Cygwin\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Cygwin\n\n    class IO::Path::Cygwin is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Cygwin in the $.SPEC\nattribute.\n\n",
      "name": "IO::Path::Cygwin"
    },
    {
      "name": "IO::Path::QNX",
      "desc": "TITLE\nclass IO::Path::QNX\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::QNX\n\n    class IO::Path::QNX is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::QNX in the $.SPEC\nattribute.\n\n"
    },
    {
      "name": "IO::Path::Unix",
      "desc": "TITLE\nclass IO::Path::Unix\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Unix\n\n    class IO::Path::Unix is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Unix in the $.SPEC\nattribute.\n\n"
    },
    {
      "desc": "TITLE\nclass IO::Path::Win32\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Win32\n\n    class IO::Path::Win32 is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Win32 in the $.SPEC\nattribute.\n\n",
      "name": "IO::Path::Win32"
    },
    {
      "name": "Telemetry::Instrument::Usage",
      "desc": "TITLE\nclass Telemetry::Instrument::Usage\n\nSUBTITLE\nInstrument for collecting getrusage data\n\n    class Telemetry::Instrument::Usage { }\n\nNote:  This class is a Rakudo-specific feature and not standard Perl 6.\n\nObjects of this class are generally not created by themselves, but rather\nthrough making a snapshot.\n\n  Useful readings\n\nThis class provides the following generally usable readings (in\nalphabetical order):\n\n  * cpu\n\nThe total amount of CPU time (in microseconds), essentially the sum of\ncpu-user and cpu-sys.\n\n  * cpu-sys\n\nThe number of microseconds of CPU used by the system.\n\n  * cpu-user\n\nThe number of microseconds of CPU used by the user program.\n\n  * cpus\n\nThe number of CPU's active, essentially cpu divided by wallclock.\n\n  * max-rss\n\nThe maximum resident set size (in KiB).\n\n  * util%\n\nPercentage of CPU utilization, essentially 100 * cpus / number of CPU\ncores.\n\n  * wallclock\n\nThe time the program has been executing (in microseconds).\n\nhead\nLess useful readings\n\nThe following readings may or may not contain sensible information, mostly\ndepending on hardware and OS being used. Please check your local getrusage\ndocumentation for their exact meaning:\n\n    name        getrusage struct name\n    ====        =====================\n    max-rss     ru_maxrss\n    ix-rss      ru_ixress\n    id-rss      ru_idrss\n    is-rss      ru_isrss\n    minf        ru_minflt\n    majf        ru_majflt\n    nswp        ru_nswap\n    inb         ru_inblock\n    outb        ru_oublock\n    msnd        ru_msgsnd\n    mrcv        ru_msgrcv\n    nsig        ru_nsignals\n    volcsw      ru_nvcsw\n    invcsw      ru_nivcsw\n"
    },
    {
      "desc": "TITLE\nclass Telemetry::Instrument::ThreadPool\n\nSUBTITLE\nInstrument for collecting ThreadPoolScheduler data\n\n    class Telemetry::Instrument::ThreadPool { }\n\nNote: This class is a Rakudo-specific feature and not standard Perl 6.\n\nObjects of this class are generally not created directly, but rather\nthrough making a snapshot. They provide the following attributes (in\nalphabetical order):\n\n  * atc\n\nThe number of tasks completed by affinity thread workers\n(affinity-tasks-completed).\n\n  * atq\n\nThe number of tasks queued for execution for affinity thread workers\n(affinity-tasks-queued).\n\n  * aw\n\nThe number of affinity thread workers (affinity-workers).\n\n  * gtc\n\nThe number of tasks completed by general workers\n(general-tasks-completed).\n\n  * gtq\n\nThe number of tasks queued for execution by general worker\n(general-tasks-queued).\n\n  * gw\n\nThe number of general workers (general-workers).\n\n  * s\n\nThe number of supervisor threads running, usually 0 or 1 (supervisor).\n\n  * ttc\n\nThe number of tasks completed by timer workers (timer-tasks-completed).\n\n  * ttq\n\nThe number of tasks queued for execution by timer workers\n(timer-tasks-queued).\n\n  * tw\n\nThe number of timer workers (timer-workers).",
      "name": "Telemetry::Instrument::ThreadPool"
    },
    {
      "name": "Telemetry::Instrument::Thread",
      "desc": "TITLE\nclass Telemetry::Instrument::Thread\n\nSUBTITLE\nInstrument for collecting Thread data\n\n    class Telemetry::Instrument::Thread { }\n\nNote:  This class is a Rakudo-specific feature and not standard Perl 6.\n\nObjects of this class are generally not created by themselves, but rather\nthrough making a snapshot.\n\nThis class provides the following data points (in alphabetical order):\n\n  * tad\n\nThe number of threads that ended with an exception (threads-aborted).\n\n  * tcd\n\nThe number of threads that completed without any problem\n(threads-completed).\n\n  * thid\n\nHighest OS thread ID seen (thread-highest-id).\n\n  * tjd\n\nThe number of threads that were joined (threads-joined).\n\n  * tsd\n\nThe number of threads that were started (threads-started).\n\n  * tyd\n\nThe number of times a thread was yielded (threads-yielded)."
    },
    {
      "desc": "TITLE\nclass X::Mixin::NotComposable\n\nSUBTITLE\nError due to using an ineligible type as a mixin\n\n    class X::Mixin::NotComposable is Exception { }\n\nThrown when a mixin with infix does or but is done with a composer that\ncannot be used for mixin.\n\nFor example\n\n    class A { };\n    1 but A;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Mixin::NotComposable: Cannot mix in non-composable type A into object of type Int␤»\n\nThe compile-time equivalent of this error is X::Composition::NotComposable\n\n",
      "name": "X::Mixin::NotComposable"
    },
    {
      "name": "X::Temporal::InvalidFormat",
      "desc": "TITLE\nclass X::Temporal::InvalidFormat\n\nSUBTITLE\nError due to using an invalid format when creating a DateTime or Date\n\n    class X::Temporal::InvalidFormat does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime or Date\nobject using an invalid format.\n\n    my $dt = Date.new(\"12/25/2015\");\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Temporal::InvalidFormat: Invalid Date string '12/25/2015'; use yyyy-mm-dd instead␤»\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Eval::NoSuchLang\n\nSUBTITLE\nError due to specifying an unknown language for EVAL\n\n    class X::Eval::NoSuchLang is Exception { }\n\nError thrown when EVAL($str, :$lang) specifies a language that the compiler\ndoes not know how to handle.\n\nFor example\n\n    EVAL 'boo', lang => \"bar\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Eval::NoSuchLang: No compiler available for language 'bar'␤»\n\n",
      "name": "X::Eval::NoSuchLang"
    },
    {
      "name": "X::Inheritance::Unsupported",
      "desc": "TITLE\nclass X::Inheritance::Unsupported\n\nSUBTITLE\nCompilation error due to inheriting from an ineligible type\n\n    class X::Inheritance::Unsupported does X::Comp { }\n\nCompile time error thrown when trying to inherit from a type that does not\nsupport inheritance (like a package or an enum).\n\nFor example\n\n    enum A <Ax Ay>;\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    A does not support inheritance, so B cannot inherit from it\n\n\n"
    },
    {
      "name": "X::Inheritance::NotComposed",
      "desc": "TITLE\nclass X::Inheritance::NotComposed\n\nSUBTITLE\nError due to inheriting from a type that's not composed yet\n\n    class X::Inheritance::NotComposed is Exception {}\n\nWhen you try to inherit from a class that hasn't been composed, an\nexception of type X::Inheritance::NotComposed is thrown.\n\nUsually this happens because it's not yet fully parsed, or that is\nstubbed:\n\nFor example\n\n    class A { ... };    # literal ... for stubbing\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    'B' cannot inherit from 'A' because 'A' isn't composed yet (maybe it is stubbed)\n\n\nThe second common way to trigger this error is by trying to inherit from a\nclass from within the class body.\n\nFor example\n\n    class Outer {\n        class Inner is Outer {\n        }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    'Outer::Inner' cannot inherit from 'Outer' because 'Outer' isn't composed yet (maybe it is stubbed)\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Signature::NameClash\n\nSUBTITLE\nCompilation error due to two named parameters with the same name\n\n    my class X::Signature::NameClash does X::Comp { }\n\nCompile time error thrown when two named parameters have the same name,\npotentially through aliases.\n\nFor example\n\n    sub f(:$a, :a(:@b)) { }\n\n\ndies with\n\n    ===SORRY!===\n    Name a used for more than one named parameter\n\n\n",
      "name": "X::Signature::NameClash"
    },
    {
      "name": "X::Signature::Placeholder",
      "desc": "TITLE\nclass X::Signature::Placeholder\n\nSUBTITLE\nCompilation error due to placeholders in a block with a signature\n\n    class X::Signature::Placeholder does X::Comp { }\n\n\nCompile time error thrown when a block has both an explicit signature and\nplaceholder parameters.\n\nFor example\n\n    sub f() { $^x }\n\n\ndies with\n\n    ===SORRY!===\n    Placeholder variable '$^x' cannot override existing signature\n\n\n"
    },
    {
      "name": "X::Export::NameClash",
      "desc": "TITLE\nclass X::Export::NameClash\n\nSUBTITLE\nCompilation error due to exporting the same symbol twice\n\n    class X::Export::NameClash does X::Comp { }\n\nCompile time error thrown when a symbol is exported twice.\n\nFor example\n\n    sub f() is export { };\n    {\n        sub f() is export { }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    A symbol '&f' has already been exported\n\n\n"
    },
    {
      "name": "X::Method::InvalidQualifier",
      "desc": "TITLE\nclass X::Method::InvalidQualifier\n\nSUBTITLE\nError due to calling a qualified method from an ineligible class\n\n    class X::Method::InvalidQualifier is Exception { }\n\nThrown when a method is call in the form $invocant.TheClass::method if\n<$invocant> does not conform to TheClass.\n\nFor example\n\n    1.Str::split(/a/);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::InvalidQualifier: Cannot dispatch to method split on Str because it is not inherited or done by Int␤»\n\n"
    },
    {
      "desc": "TITLE\nclass X::Method::NotFound\n\nSUBTITLE\nError due to calling a method that isn't there\n\n    class X::Method::NotFound is Exception {}\n\nThrown when the user tries to call a method that isn't there.\n\nFor example\n\n    1.no-such\n\n\nthrows\n\n    No such method 'no-such' for invocant of type 'Int'\n\n\n",
      "name": "X::Method::NotFound"
    },
    {
      "desc": "TITLE\nclass X::Proc::Unsuccessful\n\nSUBTITLE\nException thrown if a Proc object is sunk after the process it ran exited\nunsuccessfully\n\n    class X::Proc::Unsuccessful is Exception {}\n\n",
      "name": "X::Proc::Unsuccessful"
    },
    {
      "desc": "TITLE\nrole X::Proc::Async\n\nSUBTITLE\nException thrown by Proc::Async\n\n    role X::Proc::Async is Exception { ... }\n\nAll exceptions thrown by Proc::Async do this common role.\n\n",
      "name": "X::Proc::Async"
    },
    {
      "name": "X::DateTime::TimezoneClash",
      "desc": "TITLE\nclass X::DateTime::TimezoneClash\n\nSUBTITLE\nError due to using both time zone offset and :timezone\n\n    class X::DateTime::TimezoneClash does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime object\nspecifying both a time zone offset and the named argument :timezone.\n\n    say DateTime.new('2015-12-24T12:23:00+0200');                   # works\n    say DateTime.new('2015-12-24T12:23:00', timezone => 7200);      # works\n    say DateTime.new('2015-12-24T12:23:00+0200', timezone => 7200); # exception\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Scheduler::CueInNaNSeconds\n\nSUBTITLE\nError caused by passing NaN to Scheduler.cue as :at, :in, or :every\n\n    class X::Scheduler::CueInNaNSeconds is Exception { }\n\nWhen calling ThreadPoolScheduler.cue or CurrentThreadScheduler.cue with\n:at, :in, or :every as NaN, this exception gets thrown. For example, the\nfollowing code:\n\n    my Cancellation $c = $*SCHEDULER.cue({\n        say 'This will never output :(';\n    }, at => NaN);\n\n\nThrows with:\n\n    Cannot pass NaN as a number of seconds to Scheduler.cue\n\n\nThis class only exists in releases 2019.05 and later.",
      "name": "X::Scheduler::CueInNaNSeconds"
    },
    {
      "name": "X::Bind::Slice",
      "desc": "TITLE\nclass X::Bind::Slice\n\nSUBTITLE\nError due to binding to a slice\n\n    class X::Bind::Slice is Exception {}\n\nWhen you try to bind to an array or hash slice:\n\n    my @a; @a[0, 1] := [42];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Array slice␤»\n\nand\n\n    my %h; %h<a b> := {};\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Hash slice␤»\n\nyou get an exception of type ::Bind::Slice\n\n"
    },
    {
      "desc": "TITLE\nclass X::Bind::NativeType\n\nSUBTITLE\nCompilation error due to binding to a natively typed variable\n\n    class X::Bind::NativeType does X::Comp { }\n\nCompile-time error thrown when trying to bind to a natively typed\nvariable.\n\nSince native variables explicitly don't have the concept of a container at\nruntime, it does not make sense to support both binding and assignment;\nPerl 6 supports only assignment (which makes more sense, because native\ntypes are value types).\n\nFor example the code\n\n    my int $x := 3;\n\n\ndies with\n\n    Cannot bind to natively typed variable '$x'; use assignment instead\n\n\nand can be fixed by writing it as\n\n    my int $x = 3;\n\n",
      "name": "X::Bind::NativeType"
    },
    {
      "desc": "TITLE\nclass X::Sequence::Deduction\n\nSUBTITLE\nError due to constructing a sequence from ineligible input\n\n    class X::Sequence::Deduction is Exception { }\n\nException type thrown when the ... sequence operator is being called\nwithout an explicit closure, and the sequence cannot be deduced.",
      "name": "X::Sequence::Deduction"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Malformed\n\nSUBTITLE\nCompilation error due to a malformed construct (usually a declarator)\n\n    class X::Syntax::Malformed does X::Syntax {}\n\nThe Perl 6 compiler throws errors of type X::Syntax::Malformed when it\nknows what kind of declaration it is parsing, and encounters a syntax\nerror, but can't give a more specific error message.\n\n    my Int a;   # throws an X::Syntax::Malformed\n\n\nproduces\n\n    ===SORRY!===\n    Malformed my\n    at -e:1\n    ------> my Int ⏏a\n\n\n",
      "name": "X::Syntax::Malformed"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Missing\n\nSUBTITLE\nCompilation error due to a missing piece of syntax\n\n    class X::Syntax::Missing does X::Syntax { }\n\nSyntax error thrown when the previous piece of syntax requires the\nexistence of another piece of syntax, and that second piece is missing.\n\nFor example\n\n    for 1, 2, 3;\n\n\ndies with\n\n    ===SORRY!===\n    Missing block\n\n\nbecause a for that is not a statement modifier must be followed by a\nblock.\n\n",
      "name": "X::Syntax::Missing"
    },
    {
      "name": "X::Syntax::NoSelf",
      "desc": "TITLE\nclass X::Syntax::NoSelf\n\nSUBTITLE\nCompilation error due to implicitly using a self that is not there\n\n    class X::Syntax::NoSelf does X::Syntax { }\n\nCompile time error thrown when $.foo style calls are used where no invocant\nis available.\n\nFor example the code\n\n    $.meth;\n\n\nin the program body throws the error\n\n    ===SORRY!===\n    Variable $.meth used where no 'self' is available\n\n\nbecause $.meth is short for $(self.meth), and there is no self available in\nmainline.\n\n"
    },
    {
      "desc": "TITLE\nclass X::Syntax::UnlessElse\n\nSUBTITLE\nCompilation error due to an unless clause followed by else\n\n    class X::Syntax::UnlessElse does X::Syntax { }\n\nSyntax error thrown when an unless clause is followed by an else clause.\n\nFor example\n\n    unless 1 { } else { };\n\n\ndies with\n\n    ===SORRY!===\n    \"unless\" does not take \"else\", please rewrite using \"if\"\n",
      "name": "X::Syntax::UnlessElse"
    },
    {
      "name": "X::Syntax::NegatedPair",
      "desc": "TITLE\nclass X::Syntax::NegatedPair\n\nSUBTITLE\nCompilation error due to passing an argument to a negated colonpair\n\n    class X::Syntax::NegatedPair does X::Syntax { }\n\nThrown if a colonpair illegally has a value, for example :!a(1). This is an\nerror because the ! negation implies that the value is False.\n\nA typical error message from this class is Argument not allowed on negated\npair with key 'a'.\n\n"
    },
    {
      "desc": "TITLE\nclass X::Syntax::InfixInTermPosition\n\nSUBTITLE\nCompilation error due to an infix in term position\n\n    class X::Syntax::InfixInTermPosition does X::Syntax { }\n\nSyntax error thrown when the parser expects a term, but finds an infix\noperator instead.\n\nFor example\n\n    1, => 2;\n\n\ndies with\n\n    ===SORRY!===\n    Preceding context expects a term, but found infix => instead\n\n\n",
      "name": "X::Syntax::InfixInTermPosition"
    },
    {
      "name": "X::Syntax::P5",
      "desc": "TITLE\nclass X::Syntax::P5\n\nSUBTITLE\nCompilation error due to use of Perl 5-only syntax\n\n    class X::Syntax::P5 does X::Syntax { }\n\nSyntax error thrown when some piece of code is clearly Perl 5, not Perl 6.\n\nFor example\n\n    for my $a (1, 2) { };\n\n\ndies with\n\n    ===SORRY!===\n    This appears to be Perl 5 code\n"
    },
    {
      "name": "X::Syntax::Reserved",
      "desc": "TITLE\nclass X::Syntax::Reserved\n\nSUBTITLE\nCompilation error due to use of syntax reserved for future use\n\n    class X::Syntax::Reserved does X::Syntax { }\n\nSyntax error thrown when a syntax is used which is reserved for future\nexpansion.\n\nFor example\n\n    my @a();\n\n\ndies with\n\n    ===SORRY!===\n    The () shape syntax in array declarations is reserved\n\n\n"
    },
    {
      "name": "X::Syntax::Confused",
      "desc": "TITLE\nclass X::Syntax::Confused\n\nSUBTITLE\nCompilation error due to unrecognized syntax\n\n    class X::Syntax::Confused does X::Syntax { }\n\n\nThe most general syntax error, if no more specific error message can be\ngiven.\n\nFor example\n\n    1∞\n\n\ndies with\n\n    ===SORRY!===\n    Confused\n"
    },
    {
      "desc": "TITLE\nclass X::ControlFlow::Return\n\nSUBTITLE\nError due to calling return outside a routine\n\n    class X::ControlFlow::Return is X::ControlFlow { }\n\nThrown when a return is called from outside a routine.\n\n    return;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»",
      "name": "X::ControlFlow::Return"
    },
    {
      "name": "X::TypeCheck::Return",
      "desc": "TITLE\nclass X::TypeCheck::Return\n\nSUBTITLE\nError due to a failed typecheck during return\n\n    class X::TypeCheck::Return is X::TypeCheck { }\n\nThrown when a return type check fails.\n\nFor example\n\n    sub f(--> Int) { \"foo\" }\n    f();\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Return: Type check failed for return value; expected Int but got Str (\"foo\")␤»"
    },
    {
      "desc": "TITLE\nclass X::TypeCheck::Assignment\n\nSUBTITLE\nError due to a failed type check during assignment\n\n    class X::TypeCheck::Assignment is X::TypeCheck { }\n\nError class thrown when the type check of an assignment fails.\n\nFor example, this will die\n\n    my Int $x = \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (\"foo\")␤»\n\nthough compilers are allowed to detect obvious cases like this example and\ncomplain at compile time with a different error.",
      "name": "X::TypeCheck::Assignment"
    },
    {
      "name": "X::TypeCheck::Binding",
      "desc": "TITLE\nclass X::TypeCheck::Binding\n\nSUBTITLE\nError due to a failed type check during binding\n\n    class X::TypeCheck::Binding is X::TypeCheck { }\n\nThrown when the type check of a binding operation fails.\n\nFor example:\n\n    my Int $x := \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding: Type check failed in binding; expected Int but got Str (\"foo\")␤»\n\nNote that the compiler is free to detect obvious errors at compile time,\nand complain with a different error at compile time."
    },
    {
      "desc": "TITLE\nclass X::TypeCheck::Splice\n\nSUBTITLE\nCompilation error due to a macro trying to splice a non-AST value\n\n    class X::TypeCheck::Splice is X::TypeCheck does X::Comp { }\n\nCompile time error thrown when a Macro or an unquote/hole in a quasi quote\ndoes not return an AST.\n\nFor example\n\n    use experimental :macros;\n    macro quasi-ast { quasi { {{{'not AST'}}} };};\n    say quasi-ast;\n\n\ndies with\n\n    ===SORRY!===\n    Type check failed in macro application; expected AST but got Str(\"not AST\")\n\n\nThis is because you are purposefully creating something that does not\nevaluate to an abstract syntax tree. To fix, instead write\n\n    use experimental :macros;\n    macro an-ast {\n        quasi { 'yes AST' }\n    }\n    say an-ast;              # OUTPUT: «yes AST␤»\n\n\n",
      "name": "X::TypeCheck::Splice"
    },
    {
      "name": "X::Channel::SendOnClosed",
      "desc": "TITLE\nclass X::Channel::SendOnClosed\n\nSUBTITLE\nError due to calling send on a closed channel\n\n    class X::Channel::SendOnClosed {}\n\nThis exception is thrown when a calling send on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.send(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n\n"
    },
    {
      "name": "X::Channel::ReceiveOnClosed",
      "desc": "TITLE\nclass X::Channel::ReceiveOnClosed\n\nSUBTITLE\nError due to calling receive on a closed channel\n\n    class X::Channel::ReceiveOnClosed {}\n\nThis exception is thrown when a calling receive on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.receive;     # Cannot receive a message on a closed channel\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::ReceiveOnClosed: Cannot receive a message on a closed channel␤»\n\n"
    },
    {
      "name": "X::Dynamic::NotFound",
      "desc": "TITLE\nclass X::Dynamic::NotFound\n\nSUBTITLE\nRuntime error thrown when a dynamic variable does not exist\n\n    class X::Dynamic::NotFound is Exception {}\n\nThis exception is raised when a dynamic variable that has not been declared\nis used.\n\n    $*dynamic-not-found = 33;\n    # OUTPUT: «Dynamic variable $*dynamic-not-found not found␤»\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::IO::Move\n\nSUBTITLE\nError while trying to move a file\n\n    class X::IO::Move does X::IO is Exception { }\n\n\nError class for a failed file move operation. A typical error message is\n\n    Failed to move '/tmp/alpha.p6' to 'test.p6': :createonly specified and destination exists\n\n\n",
      "name": "X::IO::Move"
    },
    {
      "name": "X::IO::Dir",
      "desc": "TITLE\nclass X::IO::Dir\n\nSUBTITLE\nError while trying to get a directory's contents\n\n    class X::IO::Dir does X::IO is Exception { }\n\n\nError class that is thrown when a dir call fails.\n\nA typical error message is\n\n    Failed to get the directory contents of '/tmp/': No such file or directory\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::IO::Link\n\nSUBTITLE\nError while trying to create a link\n\n    class X::IO::Link does X::IO is Exception { }\n\n\nError class for failed link operation.\n\nA typical error message is\n\n    Failed to create link called 'my-link' on target 'does-not exist': Failed to link file\n\n\n",
      "name": "X::IO::Link"
    },
    {
      "name": "X::IO::Rmdir",
      "desc": "TITLE\nclass X::IO::Rmdir\n\nSUBTITLE\nError while trying to remove a directory\n\n    my class X::IO::Rmdir does X::IO is Exception { }\n\n\nError class for failed rmdir operations.\n\nA typical error message is\n\n    Failed to remove the directory 'lib': Directory not empty\n\n\n"
    },
    {
      "name": "X::IO::Copy",
      "desc": "TITLE\nclass X::IO::Copy\n\nSUBTITLE\nError while trying to copy a file\n\n    class X::IO::Copy does X::IO is Exception { }\n\n\nError class for failed file copy operations. A typical error message is\n\n    Failed to copy 'source' to 'destination': permission denied\n\n\n"
    },
    {
      "name": "X::IO::DoesNotExist",
      "desc": "TITLE\nclass X::IO::DoesNotExist\n\nSUBTITLE\nError while doing file tests on a non existing path\n\n    class X::IO::DoesNotExist does X::IO is Exception { }\n\n\nThrown when doing file test operations on a non existing path.\n\nA typical error message is\n\n    Failed to find 'euler-5.p6' while trying to do '.f'\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::IO::Symlink\n\nSUBTITLE\nError while trying to create a symbolic link\n\n    class X::IO::Symlink does X::IO is Exception { }\n\n\nError class for failed symlink creation.\n\nA typical error message is\n\n    Failed to create symlink called 'euler' on target '/home/myhome/euler-1.p6': Failed to symlink file: file already exist\n\n\n",
      "name": "X::IO::Symlink"
    },
    {
      "desc": "TITLE\nclass X::IO::Cwd\n\nSUBTITLE\nError while trying to determine the current working directory\n\n    class X::IO::Cwd does X::IO is Exception { }\n\n\nError class when the runtime fails to determine the current directory.\n\nA typical error message is\n\n    Failed to get the working directory: permission denied\n",
      "name": "X::IO::Cwd"
    },
    {
      "desc": "TITLE\nclass X::IO::Unlink\n\nSUBTITLE\nError while trying to remove a file\n\n    class X::IO::Unlink does X::IO is Exception { }\n\n\nError class for failed unlink operation.\n\nA typical error message is\n\n    Failed to remove the file 'secret': Permission defined\n\n\n",
      "name": "X::IO::Unlink"
    },
    {
      "desc": "TITLE\nclass X::IO::Chdir\n\nSUBTITLE\nError while trying to change the working directory\n\n    class X::IO::Chdir does X::IO is Exception { }\n\n\nError class when a chdir call failed.\n\nFor example\n\n    chdir '/home/other'\n\n\nthrows\n\n    Failed to change the working directory to '/home/other': permission denied\n\n\n",
      "name": "X::IO::Chdir"
    },
    {
      "name": "X::IO::Rename",
      "desc": "TITLE\nclass X::IO::Rename\n\nSUBTITLE\nError while trying to rename a file or directory\n\n    class X::IO::Rename does X::IO is Exception { }\n\n\nError class for failed file or directory rename operations. A typical error\nmessage is\n\n    Failed to rename 'source' to 'destination': is a directory\n\n\n"
    },
    {
      "name": "X::IO::Chmod",
      "desc": "TITLE\nclass X::IO::Chmod\n\nSUBTITLE\nError while trying to change file permissions\n\n    class X::IO::Chmod does X::IO is Exception { }\n\n\nError class for failed chmod calls.\n\nA typical error message is\n\n    Failed to set the mode of '/home/other' to '0o777': Permission denied\n"
    },
    {
      "name": "X::IO::Mkdir",
      "desc": "TITLE\nclass X::IO::Mkdir\n\nSUBTITLE\nError while trying to create a directory\n\n    class X::IO::Mkdir does X::IO is Exception { }\n\n\nError class for failed mkdir operations.\n\nA typical error message is\n\n    Failed to create directory 'destination' with mode '0o755': File exists\n\n\n"
    },
    {
      "name": "X::Role::Initialization",
      "desc": "TITLE\nclass X::Role::Initialization\n\nSUBTITLE\nError due to passing an initialization value to an ineligible role\n\n    class X::Role::Initialization is Exception { }\n\nThrown when the SomeRole($init) syntax is used, but SomeRole does not have\nexactly one public attribute.\n\nFor example:\n\n    role R { }; \"D2\" but R(2)\n    CATCH { default { put .^name, ': ', .Str } }\n    # OUTPUT: «X::Role::Initialization: Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'R'␤»\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Package::Stubbed\n\nSUBTITLE\nCompilation error due to a stubbed package that is never defined\n\n    class X::Package::Stubbed does X::Comp { }\n\nThrown at CHECK time when there are packages stubbed but not later\ndefined.\n\nFor example\n\n    class A { ... }     # literal ...\n    class B { ... }     # literal ...\n\n\ndies with\n\n    ===SORRY!===\n    The following packages were stubbed but not defined:\n        A\n        B\n\n\n",
      "name": "X::Package::Stubbed"
    },
    {
      "name": "X::Seq::Consumed",
      "desc": "TITLE\nclass X::Seq::Consumed\n\nSUBTITLE\nError due to trying to reuse a consumed sequence\n\n    class X::Seq::Consumed is Exception { }\n\nThis exception is thrown when a piece of code tries to reuse a Seq which\nhas already been iterated."
    },
    {
      "desc": "TITLE\nclass X::Assignment::RO\n\nSUBTITLE\nException thrown when trying to assign to something read-only\n\n    class X::Assignment::RO is Exception {}\n\nCode like\n\n    sub f() { 42 };\n    f() = 'new value';  # throws an X::Assignment::RO\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\nthrows an exception of type X::Assignment::RO.\n\n",
      "name": "X::Assignment::RO"
    },
    {
      "desc": "TITLE\nclass X::Promise::CauseOnlyValidOnBroken\n\nSUBTITLE\nError due to asking why an unbroken promise has been broken.\n\n    class X::Promise::CauseOnlyValidOnBroken is Exception { }\n\nThis exception is thrown when code expects a Promise to be broken, and asks\nwhy it has been broken, but the Promise has in fact, not yet been broken.\n\n",
      "name": "X::Promise::CauseOnlyValidOnBroken"
    },
    {
      "desc": "TITLE\nclass X::Promise::Vowed\n\nSUBTITLE\nError due to directly trying to keep/break a vowed promise.\n\n    class X::Promise::Vowed is Exception { }\n\nThis exception is thrown when code tries to keep/break an already vowed\npromise without going through the corresponding Vow object.\n\n",
      "name": "X::Promise::Vowed"
    },
    {
      "desc": "TITLE\nclass X::Phaser::Multiple\n\nSUBTITLE\nCompilation error due to multiple phasers of the same type\n\n    class X::Phaser::Multiple does X::Comp { }\n\nThrown when multiple phasers of the same type occur in a block, but only\none is allowed (for example CATCH or CONTROL).\n\nFor example\n\n    CATCH { }; CATCH { }\n\n\ndies with\n\n    ===SORRY!===\n    Only one CATCH block is allowed\n\n\n",
      "name": "X::Phaser::Multiple"
    },
    {
      "desc": "TITLE\nclass X::Phaser::PrePost\n\nSUBTITLE\nError due to a false return value of a PRE/POST phaser\n\n    class X::Phaser::PrePost is Exception { }\n\n\nThrown when the condition inside a PRE or POST phaser evaluate to a false\nvalue.\n\nFor example\n\n    sub f($x) { PRE { $x ~~ Int } };\n    f \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: X::Phaser::PrePost: Precondition '{ $x ~~ Int }' failed«␤»\n\n",
      "name": "X::Phaser::PrePost"
    },
    {
      "name": "X::Declaration::Scope",
      "desc": "TITLE\nclass X::Declaration::Scope\n\nSUBTITLE\nCompilation error due to a declaration with an ineligible scope\n\n    class X::Declaration::Scope does X::Comp { }\n\n\nCompile time error thrown when a declaration does not harmonize with the\ndeclared scope.\n\nFor example\n\n    has sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use 'has' with sub declaration\n\n\n"
    },
    {
      "name": "X::Does::TypeObject",
      "desc": "TITLE\nclass X::Does::TypeObject\n\nSUBTITLE\nError due to mixing into a type object\n\n    class X::Does::TypeObject is Exception {}\n\nWhen you try to add one or more roles to a type object with does after it\nhas been composed, an error of type X::Does::TypeObject is thrown:\n\n    Mu does Numeric;    # Cannot use 'does' operator with a type object.\n\n\nThe correct way to apply roles to a type is at declaration time:\n\n    class GrassmannNumber does Numeric { ... };\n    role AlgebraDebugger does IO { ... };\n    grammar IntegralParser does AlgebraParser { ... };\n\n\nRoles may only be runtime-mixed into defined object instances:\n\n    GrassmannNumber.new does AlgebraDebugger;\n\n\n(This restriction may be worked around by using augment or supersede, or\nwith dark Metamodel magics, but this will likely result in a significant\nperformance penalty.)\n\n"
    },
    {
      "name": "X::Attribute::Required",
      "desc": "TITLE\nclass X::Attribute::Required\n\nSUBTITLE\nCompilation error due to not declaring an attribute with the is required\ntrait\n\n    class X::Attribute::NoPackage does X::MOP { }\n\nCompile time error thrown when a required attribute is not assigned when\ncreating an object.\n\nFor example\n\n    my class Uses-required {\n        has $.req is required\n    };\n    my $object = Uses-required.new()\n\n\nDies with\n\n    OUTPUT: «(exit code 1) The attribute '$!req' is required, but you did not provide a value for it.␤»\n\n\n"
    },
    {
      "name": "X::Attribute::Package",
      "desc": "TITLE\nclass X::Attribute::Package\n\nSUBTITLE\nCompilation error due to declaring an attribute in an ineligible package\n\n    class X::Attribute::Package does X::Comp { }\n\nCompile time error, thrown when the compiler encounters an attribute\ndeclaration inside a package that does not support attributes.\n\nFor example\n\n    module A { has $.x }\n\n\ndies with\n\n    A module cannot have attributes, but you tried to declare '$.x'\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Attribute::NoPackage\n\nSUBTITLE\nCompilation error due to declaring an attribute outside of a package\n\n    class X::Attribute::NoPackage does X::Comp { }\n\nCompile time error thrown when an attribute is declared where it does not\nmake sense (for example in the mainline).\n\nFor example\n\n    has $.x;\n\n\nDies with\n\n    You cannot declare attribute '$.x' here; maybe you'd like a class or a role?\n\n\n",
      "name": "X::Attribute::NoPackage"
    },
    {
      "desc": "TITLE\nclass X::Attribute::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared attribute\n\n    class X::Attribute::Undeclared is X::Undeclared { }\n\nThrown when code refers to an attribute that has not been declared.\n\nFor example the code\n\n    class A { method m { $!notthere } }\n\n\nProduces the error\n\n    Attribute $!notthere not declared in class A\n\n\n",
      "name": "X::Attribute::Undeclared"
    },
    {
      "desc": "TITLE\nclass X::Augment::NoSuchType\n\nSUBTITLE\nCompilation error due to augmenting a non-existing type\n\n    class X::Augment::NoSuchType does X::Comp { }\n\nThrown when trying to augment a type which doesn't exist.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class NoSuch { }\n\n\ndies with\n\n    You tried to augment class NoSuch, but it does not exist\n\n\n",
      "name": "X::Augment::NoSuchType"
    },
    {
      "desc": "TITLE\nclass X::Caller::NotDynamic\n\nSUBTITLE\nError while trying to access a non dynamic variable through CALLER\n\n    class X::Caller::NotDynamic is Exception { }\n\nThrown when trying to access a non dynamic variable through CALLER\n\nA typical error message is\n\n    Cannot access '$x' through CALLER, because it is not declared as dynamic\n\n\n",
      "name": "X::Caller::NotDynamic"
    },
    {
      "desc": "TITLE\nclass X::Parameter::Placeholder\n\nSUBTITLE\nCompilation error due to an unallowed placeholder in a signature\n\n    class X::Parameter::Placeholder does X::Comp { }\n\nThrown when a placeholder parameter is used inside a signature where a\nnormal parameter is expected. The reason is often that a named parameter\n:$param was misspelled as $:param.\n\nFor example\n\n    sub f($:param) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter, placeholder variables like $:param are illegal\n    you probably meant a named parameter: ':$param'\n\n\n",
      "name": "X::Parameter::Placeholder"
    },
    {
      "name": "X::Parameter::WrongOrder",
      "desc": "TITLE\nclass X::Parameter::WrongOrder\n\nSUBTITLE\nCompilation error due to passing parameters in the wrong order\n\n    class X::Parameter::WrongOrder does X::Comp { }\n\nCompile time error that is thrown when parameters in a signature in the\nwrong order (for example if an optional parameter comes before a mandatory\nparameter).\n\nFor example\n\n    sub f($a?, $b) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put required parameter $b after optional parameters\n\n\n"
    },
    {
      "desc": "TITLE\nclass X::Parameter::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a signature\n\n    class X::Parameter::Twigil does X::Comp { }\n\nThrown when a parameter in a signature has a twigil that it may not have.\nOnly !, . and * as twigils are allowed.\n\nExample:\n\n    sub f($=foo) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter $=foo, it is illegal to use the = twigil\n\n\n",
      "name": "X::Parameter::Twigil"
    },
    {
      "desc": "TITLE\nclass X::Parameter::MultipleTypeConstraints\n\nSUBTITLE\nCompilation error due to a parameter with multiple type constraints\n\n    class X::Parameter::MultipleTypeConstraints does X::Comp { }\n\nCompile time error thrown when a parameter has multiple type constraints.\nThis is not allowed in Perl 6.0.\n\nExample:\n\n    sub f(Cool Real $x) { }\n\n\ndies with\n\n    Parameter $x may only have one prefix type constraint\n\n\n",
      "name": "X::Parameter::MultipleTypeConstraints"
    },
    {
      "desc": "TITLE\nclass X::Parameter::Default\n\nSUBTITLE\nCompilation error due to an unallowed default value in a signature\n\n    class X::Parameter::Default does X::Comp { }\n\nCompile-time error thrown when a parameter in a signature has default\nvalue, but isn't allowed to have one. That is the case with slurpy\nparameters (because a slurpy always binds successfully, even to zero\narguments) and with mandatory parameters.\n\nExample:\n\n    sub f($x! = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on required parameter $x\n\n\nAnd\n\n    sub f(*@ = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on anonymous slurpy parameter\n\n\n",
      "name": "X::Parameter::Default"
    },
    {
      "name": "X::Numeric::Real",
      "desc": "TITLE\nclass X::Numeric::Real\n\nSUBTITLE\nError while trying to coerce a number to a Real type\n\n    class X::Numeric::Real is Exception { }\n\nOccurs when an attempt to coerce a Numeric to a Real, Num, Int or Rat fails\n(due to a number with a nonzero imaginary part, for instance).\n\nFor example\n\n    say (1+2i).Int;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Numeric::Real: Can not convert 1+2i to Int: imaginary part not zero␤»\n\n"
    },
    {
      "desc": "TITLE\nclass X::Anon::Multi\n\nSUBTITLE\nCompilation error due to declaring an anonymous multi\n\n    class X::Anon::Multi does X::Comp { }\n\nCompile time error thrown when an anonymous multi is being declared.\n\nFor example\n\n    multi method () { }\n\n\ndies with\n\n    Cannot put multi on anonymous method\n\n\n",
      "name": "X::Anon::Multi"
    },
    {
      "desc": "TITLE\nclass X::Anon::Augment\n\nSUBTITLE\nCompilation error due to augmenting an anonymous package\n\n    class X::Anon::Augment does X::Comp { }\n\nCompile time error thrown when trying to augment an anonymous package.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class { }\n\n\nDies with\n\n    Cannot augment anonymous class\n\n\n",
      "name": "X::Anon::Augment"
    },
    {
      "desc": "TITLE\nclass X::Constructor::Positional\n\nSUBTITLE\nError due to passing positional arguments to a default constructor\n\n    class X::Constructor::Positional is Exception { }\n\nThrown from Mu.new when positional arguments are passed to it.\n\nFor example\n\n    class A { };\n    A.new(2, 3);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Constructor::Positional: Default constructor for 'A' only takes named arguments␤»",
      "name": "X::Constructor::Positional"
    },
    {
      "name": "X::Str::Numeric",
      "desc": "TITLE\nclass X::Str::Numeric\n\nSUBTITLE\nError while trying to coerce a string to a number\n\n    class X::Str::Numeric is Exception { }\n\nError thrown (or wrapped in a Failure) when a conversion from string to a\nnumber fails.\n\nFor example\n\n    say +\"42 answers\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Str::Numeric: Cannot convert string to number: trailing characters after number in '42⏏ answers' (indicated by ⏏)␤»\n\n"
    },
    {
      "desc": "TITLE\nclass X::Placeholder::Block\n\nSUBTITLE\nCompilation error due to a placeholder in an ineligible block\n\n    class X::Placeholder::Block does X::Comp {}\n\nThrown when a placeholder variable is used in a block that does not allow a\nsignature.\n\nFor example\n\n    class A { $^foo }\n\n\ndies with\n\n    Placeholder variable $^foo may not be used here because the surrounding block takes no signature\n\n\n",
      "name": "X::Placeholder::Block"
    },
    {
      "desc": "TITLE\nclass X::Placeholder::Mainline\n\nSUBTITLE\nCompilation error due to a placeholder in the mainline\n\n    class X::Placeholder::Mainline is X::Placeholder::Block { }\n\nThrown when a placeholder variable is used in the mainline, i.e. outside of\nany explicit block.\n\nFor example\n\n    $^x;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use placeholder parameter $^x outside of a sub or block\n\n\nNote that this error can also occur when you think something is a block,\nbut it really is a postcircumfix:<{ }>, for example\n\n    my %h;\n    say %h{ $^x };\n    #     ^^^^^^^  not a block, so $^x is part of the mainline\n",
      "name": "X::Placeholder::Mainline"
    },
    {
      "name": "X::Composition::NotComposable",
      "desc": "TITLE\nclass X::Composition::NotComposable\n\nSUBTITLE\nCompilation error due to composing an ineligible type\n\n    class X::Composition::NotComposable is Exception { }\n\nThrown when trying to compose a type into a target type, but the composer\ntype cannot be used for composition (roles and enums are generally OK).\n\nFor example\n\n    class A { }\n    class B does A { }\n\n\ndies with\n\n    ===SORRY!===\n    ␤A is not composable, so B cannot compose it\n\n\nbecause does is reserved for role composition, and A is not a role, nor\nsomething that knows how to turn into a role.\n\nThe fix is to either make A a role, or use inheritance (class B is A { })\ninstead.\n\n"
    },
    {
      "desc": "TITLE\nclass X::Method::Private::Unqualified\n\nSUBTITLE\nCompilation error due to an unqualified private method call\n\n    class X::Method::Private::Unqualified does X::Comp { }\n\nCompile time error thrown when a private method call on anything but self\nis not fully qualified.\n\nFor example\n\n    1!priv\n\n\ndies with\n\n    ===SORRY!===\n    Private method call to priv must be fully qualified with the package containing the method\n\n\n",
      "name": "X::Method::Private::Unqualified"
    },
    {
      "desc": "TITLE\nclass X::Method::Private::Permission\n\nSUBTITLE\nCompilation error due to calling a private method without permission\n\n    class X::Method::Private::Permission does X::Comp { }\n\nCompile time error thrown when the code contains a call to a private method\nthat isn't defined in the current class, and when no appropriate trusts\nrelation is defined that permits the private method call.\n\nFor example\n\n    1!Int::foo\n\n\ndies with\n\n    ===SORRY!===\n    Cannot call private method 'foo' on package Int because it does not trust GLOBAL\n\n\n",
      "name": "X::Method::Private::Permission"
    },
    {
      "name": "X::Proc::Async::MustBeStarted",
      "desc": "TITLE\nclass X::Proc::Async::MustBeStarted\n\nSUBTITLE\nError due to interacting with a Proc::Async stream before spawning its\nprocess\n\n    class X::Proc::Async::MustBeStarted is Exception {}\n\nSeveral methods from Proc::Async expect that the external program has been\nspawned (by calling .start on it), including say, write, print and\nclose-stdin. If one of those methods is called before .start was called,\nthey throw an exception of type X::Proc::Async::MustBeStarted.\n\n    Proc::Async.new('echo', :w).say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::MustBeStarted: Process must be started first before calling 'say'␤»\n\n"
    },
    {
      "name": "X::Proc::Async::BindOrUse",
      "desc": "TITLE\nclass X::Proc::Async::BindOrUse\n\nSUBTITLE\nError due to trying to bind a handle that is also used\n\n        class X::Proc::Async::BindOrUse does X::Proc::Async {}\n\n\nIn general, it occurs when there's some mistake in the direction the stream\nflows, for instance:\n\n    my $p = Proc::Async.new(\"ls\", :w);\n    my $h = \"ls.out\".IO.open(:w);\n    $p.bind-stdin($h);\n    # Fails with OUTPUT: «Cannot both bind stdin to a handle and also use :w␤»\n\n\nIn this case, stdin is already bound and cannot be used again; one of them\nshould flow :out and the other one :w to work correctly."
    },
    {
      "desc": "TITLE\nclass X::Proc::Async::TapBeforeSpawn\n\nSUBTITLE\nError due to tapping a Proc::Async stream after spawning its process\n\n    class X::Proc::Async::TapBeforeSpawn is Exception {}\n\nIf the stdout or stderr methods of Proc::Async are called after the program\nhas been started, an exception of type X::Proc::Async::TapBeforeSpawn is\nthrown.\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.start;\n    $proc.stdout.tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::TapBeforeSpawn: To avoid data races, you must tap stdout before running the process␤»\n\nThe right way is the reverse order\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.stdout.tap(&print);\n    await $proc.start;\n\n",
      "name": "X::Proc::Async::TapBeforeSpawn"
    },
    {
      "desc": "TITLE\nclass X::Proc::Async::AlreadyStarted\n\nSUBTITLE\nError due to calling start on an already started Proc::Async object\n\n    class X::Proc::Async::AlreadyStarted is Exception {}\n\nWhen you call start twice on the same Proc::Async object, the second\ninvocation will die with an X::Proc::Async::AlreadyStarted exception.\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.start;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::AlreadyStarted: Process has already been started␤»",
      "name": "X::Proc::Async::AlreadyStarted"
    },
    {
      "name": "X::Proc::Async::OpenForWriting",
      "desc": "TITLE\nclass X::Proc::Async::OpenForWriting\n\nSUBTITLE\nError due to writing to a read-only Proc::Async object\n\n    class X::Proc::Async::OpenForWriting is Exception {}\n\nWhen a Proc::Async object is opened only for reading from the external\nprogram (no :w passed to open), and a write operation such as write, print\nand say is performed, an exception of type X::Proc::Async::OpenForWriting\nis thrown:\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::OpenForWriting: Process must be opened for writing with :w to call 'say'␤»\n\nTo fix that you can use writable commands with :w flag:\n\n    my $prog = Proc::Async.new(:w, 'cat');\n    $prog.stdout.tap( -> $str {\n        print $str;\n    });\n    my $promise = $prog.start;\n    await $prog.say('foo');\n    $prog.close-stdin;\n    await $promise;\n\n"
    },
    {
      "name": "X::Proc::Async::CharsOrBytes",
      "desc": "TITLE\nclass X::Proc::Async::CharsOrBytes\n\nSUBTITLE\nError due to tapping the same Proc::Async stream for both text and binary\nreading\n\n    class X::Proc::Async::CharsOrBytes is Exception {}\n\nA Proc::Async object allows subscription to the output or error stream\neither for bytes (Blob) or for text data (Str), but not for both. If you do\ntry both, it throws an exception of type X::Proc::Async::CharsOrBytes.\n\n    my $proc = Proc::Async.new('echo');\n    $proc.stdout.tap(&print);\n    $proc.stdout(:bin).tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::CharsOrBytes: Can only tap one of chars or bytes supply for stdout␤»\n\n"
    },
    {
      "name": "X::Syntax::Signature::InvocantMarker",
      "desc": "TITLE\nclass X::Syntax::Signature::InvocantMarker\n\nSUBTITLE\nCompilation error due to a misplaced invocant marker in a signature\n\n    class X::Syntax::Signature::InvocantMarker does X::Syntax { }\n\nSyntax error when the invocant in a signature is anywhere else than after\nthe first parameter.\n\nFor example\n\n    :($a, $b: $c);\n\n\ndies with\n\n    ===SORRY!===\n    Can only use : as invocant marker in a signature after the first parameter\n\n\nSee also: Signature."
    },
    {
      "desc": "TITLE\nclass X::Syntax::Term::MissingInitializer\n\nSUBTITLE\nCompilation error due to declaring a term without initialization\n\n    class X::Syntax::Term::MissingInitializer does X::Syntax { }\n\nSyntax error when a term (a backslash variable) is declared without\ninitialization assignment.\n\nFor example\n\n    my \\foo;\n\n\ndies with\n\n    ===SORRY!===\n    Term definition requires an initializer\n\n\nValid code would be\n\n    my \\foo = 42;\n",
      "name": "X::Syntax::Term::MissingInitializer"
    },
    {
      "name": "X::Syntax::Variable::Numeric",
      "desc": "TITLE\nclass X::Syntax::Variable::Numeric\n\nSUBTITLE\nCompilation error due to declaring a numeric symbol\n\n    class X::Syntax::Variable::Numeric does X::Syntax { }\n\nSyntax error thrown when trying to declare numeric symbols.\n\nFor example\n\n    my @101;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a numeric variable\n\n\n"
    },
    {
      "name": "X::Syntax::Variable::Match",
      "desc": "TITLE\nclass X::Syntax::Variable::Match\n\nSUBTITLE\nCompilation error due to declaring a match variable\n\n    class X::Syntax::Variable::Match does X::Syntax { }\n\nSyntax error thrown when a match variable like $<thing>  was declared.\n\nFor example\n\n    my $<thing>;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a match variable\n"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Variable::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a declaration\n\n    class X::Syntax::Variable::Twigil does X::Syntax { }\n\nSyntax error thrown when a variable with a twigil is used in an\nincompatible declaration.\n\nFor example\n\n    my $!foo;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use ! twigil on my variable\n\n\n",
      "name": "X::Syntax::Variable::Twigil"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Regex::SolitaryQuantifier\n\nSUBTITLE\nCompilation error due to a regex quantifier without preceding atom\n\n    class X::Syntax::Regex::SolitaryQuantifier does X::Syntax { }\n\nSyntax error when a stand alone quantifier (without a preceding atom to\nquantify) is encountered in a regular expression.\n\nFor example\n\n    / * /;\n\n\ndies with\n\n    ===SORRY!===\n    Quantifier quantifies nothing\n",
      "name": "X::Syntax::Regex::SolitaryQuantifier"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Regex::Adverb\n\nSUBTITLE\nCompilation error due to an unrecognized regex adverb\n\n    class X::Syntax::Regex::Adverb does X::Syntax { }\n\nSyntax error thrown when an unrecognized or illegal regex adverb is\nencountered.\n\nFor example\n\n    rx:g/a/\n\n\ndies with\n\n    ===SORRY!===\n    Adverb g not allowed on rx\n\n\nbecause :g belongs to a match operation, not a regex itself.\n\n",
      "name": "X::Syntax::Regex::Adverb"
    },
    {
      "name": "X::Syntax::Augment::WithoutMonkeyTyping",
      "desc": "TITLE\nclass X::Syntax::Augment::WithoutMonkeyTyping\n\nSUBTITLE\nCompilation error due to augmenting a type without the MONKEY-TYPING\npragma\n\n    class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax { }\n\nCompile time error thrown when augment is used without use MONKEY-TYPING.\n\nSince augment is considered a rather unsafe and impolite action, you have\nto pre-declare your intent with the use MONKEY-TYPING; pragma.\n\nIf you don't do that, like here\n\n    augment class Int { };\n\n\nyou get the error\n\n    ===SORRY!===\n    augment not allowed without 'use MONKEY-TYPING'\n"
    },
    {
      "name": "X::Syntax::Comment::Embedded",
      "desc": "TITLE\nclass X::Syntax::Comment::Embedded\n\nSUBTITLE\nCompilation error due to a malformed inline comment\n\n    class X::Syntax::Comment::Embedded does X::Syntax { }\n\nSyntax error thrown when #` is encountered and it is not followed by an\nopening curly brace.\n\nFor example\n\n    #`\n\n\ndies with\n\n    ===SORRY!===\n    Opening bracket is required for #` comment\n"
    },
    {
      "desc": "TITLE\nclass X::Syntax::Number::RadixOutOfRange\n\nSUBTITLE\nCompilation error due to an unallowed radix in a number literal\n\n    class X::Syntax::Number::RadixOutOfRange does X::Syntax { }\n\nSyntax error that is thrown when the radix of a radix number is not\nallowed, like :1<1>  or :42<ouch> .\n\n",
      "name": "X::Syntax::Number::RadixOutOfRange"
    },
    {
      "name": "X::Syntax::Self::WithoutObject",
      "desc": "TITLE\nclass X::Syntax::Self::WithoutObject\n\nSUBTITLE\nCompilation error due to invoking self in an ineligible scope\n\n    class X::Syntax::Self::WithoutObject does X::Syntax { }\n\nSyntax error thrown when self is referenced in a place where no invocant is\navailable.\n\nFor example\n\n    self;\n\n\noutside a class or role declaration dies with\n\n    ===SORRY!===\n    'self' used where no object is available\n"
    },
    {
      "desc": "TITLE\nclass X::Declaration::Scope::Multi\n\nSUBTITLE\nCompilation error due to declaring a multi with an ineligible scope\n\n    class X::Declaration::Scope::Multi is X::Declaration::Scope { }\n\nThrown when a multi is declared with an incompatible scope.\n\nFor example our multi sub foo() { } dies with\n\n    ===SORRY!===\n    Cannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead\n",
      "name": "X::Declaration::Scope::Multi"
    }
  ]
}