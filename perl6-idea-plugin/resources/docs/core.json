[{"methods":["Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","chr\n\nDefined as:\n\n    multi sub    chr(Int:D  --> Str:D)\n    multi method chr(Int:D: --> Str:D)\n\nReturns a one-character string, by interpreting the integer as a Unicode\ncodepoint number and converting it to the corresponding character.\n\nExample:\n\n    65.chr;  # returns \"A\"\n    196.chr; # returns \"Ä\"","expmod\n\nDefined as:\n\n    multi sub    expmod(      $x,     $y,     $mod --> Int:D)\n    multi sub    expmod(Int:D $x, Int $y, Int $mod --> Int:D)\n    multi method expmod(Int:D:    Int $y, Int $mod --> Int:D)\n\nReturns the given Int raised to the $y power within modulus $mod, that is\ngives the result of ($x ** $y) mod $mod. The subroutine form can accept\nnon-Int arguments, which will be coerced to Int.\n\n    say expmod(4, 2, 5);    # OUTPUT: «1␤»\n    say 7.expmod(2, 5);     # OUTPUT: «4␤»\n\n$y argument can also be negative, in which case, the result is equivalent\nto ($x ** $y) mod $mod.\n\n    say 7.expmod(-2, 5);     # OUTPUT: «4␤»","polymod\n\nDefined as:\n\n    method polymod(Int:D: +@mods)\n\nReturns a sequence of mod results corresponding to the divisors in @mods in\nthe same order as they appear there. For the best effect, the divisors\nshould be given from the smallest \"unit\" to the largest (e.g. 60 seconds\nper minute, 60 minutes per hour) and the results are returned in the same\nway: from smallest to the largest (5 seconds, 4 minutes). The last non-zero\nvalue will be the last remainder.\n\n    say 120.polymod(10);    # OUTPUT: «(0 12)␤»\n    say 120.polymod(10,10); # OUTPUT: «(0 2 1)␤»\n\nIn the first case, 120 is divided by 10 giving as a remainder 12, which is\nthe last element. In the second, 120 is divided by 10, giving 12, whose\nremainder once divided by 10 is 2; the result of the integer division of 12\ndiv 10 is the last remainder. The number of remainders will be always one\nmore item than the number of given divisors. If the divisors are given as a\nlazy list, runs until the remainder is 0 or the list of divisors is\nexhausted. All divisors must be Ints, unless the method is called on a\nnon-Int number.\n\n    my $seconds = 1 * 60*60*24 # days\n                + 3 * 60*60    # hours\n                + 4 * 60       # minutes\n                + 5;           # seconds\n\n    say $seconds.polymod(60, 60);                # OUTPUT: «(5 4 27)␤»\n    say $seconds.polymod(60, 60, 24);            # OUTPUT: «(5 4 3 1)␤»\n\n    say 120.polymod:      1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12 0 0 0)␤»\n    say 120.polymod: lazy 1, 10, 10², 10³, 10⁴;  # OUTPUT: «(0 0 12)␤»\n    say 120.polymod:      1, 10, 10² … ∞;        # OUTPUT: «(0 0 12)␤»\n\n    say ⅔.polymod(⅓);                            # OUTPUT: «(0 2)␤»\n    say 5.Rat.polymod(.3, .2);                   # OUTPUT: «(0.2 0 80)␤»\n\n    my @digits-in-base37 = 9123607.polymod(37 xx *); # Base conversion\n    say @digits-in-base37.reverse                    # OUTPUT: «[4 32 4 15 36]␤»\n\nTo illustrate how the Int, non-lazy version of polymod works, consider this\ncode that implements it:\n\n    my $seconds = 2 * 60*60*24 # days\n                + 3 * 60*60    # hours\n                + 4 * 60       # minutes\n                + 5;           # seconds\n\n    my @pieces;\n    for 60, 60, 24 -> $divisor {\n        @pieces.push: $seconds mod $divisor;\n        $seconds div= $divisor\n    }\n    @pieces.push: $seconds;\n\n    say @pieces; # OUTPUT: «[5 4 3 2]␤»\n\nFor a more detailed discussion, see this blog post","is-prime\n\nDefined as:\n\n    multi sub    is-prime (Int:D $number --> Bool:D)\n    multi method is-prime (Int:D: --> Bool:D)\n\nReturns True if this Int is known to be a prime, or is likely to be a prime\nbased on a probabilistic Miller-Rabin test.\n\nReturns False if this Int is known not to be a prime.\n\n    say 2.is-prime;         # OUTPUT: «True␤»\n    say is-prime(9);        # OUTPUT: «False␤»","lsb\n\nDefined as:\n\n    multi method lsb(Int:D:)\n    multi sub    lsb(Int:D)\n\nShort for \"Least Significant Bit\". Returns Nil if the number is 0.\nOtherwise returns the zero-based index from the right of the least\nsignificant (rightmost) 1 in the binary representation of the number.\n\n    say 0b01011.lsb;        # OUTPUT: «0␤»\n    say 0b01010.lsb;        # OUTPUT: «1␤»\n    say 0b10100.lsb;        # OUTPUT: «2␤»\n    say 0b01000.lsb;        # OUTPUT: «3␤»\n    say 0b10000.lsb;        # OUTPUT: «4␤»","msb\n\nDefined as:\n\n    multi method msb(Int:D:)\n    multi sub    msb(Int:D)\n\nShort for \"Most Significant Bit\". Returns Nil if the number is 0. Otherwise\nreturns the zero-based index from the right of the most significant\n(leftmost) 1 in the binary representation of the number.\n\n    say 0b00001.msb;        # OUTPUT: «0␤»\n    say 0b00011.msb;        # OUTPUT: «1␤»\n    say 0b00101.msb;        # OUTPUT: «2␤»\n    say 0b01010.msb;        # OUTPUT: «3␤»\n    say 0b10011.msb;        # OUTPUT: «4␤»","unival\n\nDefined as:\n\n    multi sub    unival(Int:D  --> Numeric)\n    multi method unival(Int:D: --> Numeric)\n\nReturns the number represented by the Unicode codepoint with the given\ninteger number, or NaN if it does not represent a number.\n\n    say ord(\"¾\").unival;    # OUTPUT: «0.75␤»\n    say 190.unival;         # OUTPUT: «0.75␤»\n    say unival(65);         # OUTPUT: «NaN␤»","Range\n\nReturns a Range object that represents the range of values supported."],"desc":"TITLE\nclass Int\n\nSUBTITLE\nInteger (arbitrary-precision)\n\n    class Int is Cool does Real { }\n\n\nInt objects store integral numbers of arbitrary size. Ints are immutable.\n\nThere are two main syntax forms for Int literals\n\n    123;         # Int in decimal notation\n    :16<BEEF>;   # Int in radix notations\n\nFor your convenience common radix forms come with a prefix shortcut.\n\n    say so :2<11111111> == 0b11111111 == :8<377> == 0o377 == 255 == 0d255 == :16<ff> == 0xff;\n    # OUTPUT: «True␤»\n\nAll forms allow underscores between any two digits which can serve as\nvisual separators, but don't carry any meaning:\n\n    5_00000;       # five Lakhs\n    500_000;       # five hundred thousand\n    0xBEEF_CAFE;   # a strange place\n    :2<1010_1010>; # 0d170\n\nRadix notation also supports round and angle brackets which allow you to\nparse a string for a given base, and putting together digits into a whole\nnumber respectively:\n\n    :16(\"9F\");         # 159\n    :100[99, 2, 3];    # 990203\n\nThese notations allow you to use variables, too:\n\n    my $two = \"2\";\n    my $ninety-nine = \"99\";\n    :16($ninety-nine); # 153\n    :100[99, $two, 3]; # 990203\n\n","name":"Int"},{"desc":"TITLE\nclass Perl\n\nSUBTITLE\nPerl related information\n\n    class Perl does Systemic { }\n\nBuilt-in class for providing perl related information. Usually accessed\nthrough the $*PERL dynamic variable.\n\n","methods":["compiler\n\nInstance method returning the compiler object, of type Compiler, associated\nwith the Perl object.","DISTROnames\n\nInstance / Class method returning the names of the Distro objects that are\nsupported by this version of Perl.","KERNELnames\n\nInstance / Class method returning the names of the Kernel objects that are\nsupported by this version of Perl.","VMnames\n\nInstance / Class method returning the names of the VM objects that are\nsupported by this version of Perl.\n\nSee Also\n\nSystemic, Compiler."],"name":"Perl"},{"name":"Iterable","methods":["iterator\n\nDefined as:\n\n    method iterator(--> Iterator:D)\n\nMethod stub that ensures all classes doing the Iterable role have a method\niterator.\n\nIt is supposed to return an Iterator.\n\n    say (1..10).iterator;","flat\n\nDefined as:\n\n    method flat(--> Iterable)\n\nReturns another Iterable that flattens out all iterables that the first one\nreturns.\n\nFor example\n\n    say (<a b>, 'c').elems;         # OUTPUT: «2␤»\n    say (<a b>, 'c').flat.elems;    # OUTPUT: «3␤»\n\nbecause <a b>  is a List and thus iterable, so  (<a b>, 'c').flat  returns\n('a', 'b', 'c'), which has three elems.\n\nNote that the flattening is recursive, so (((\"a\", \"b\"), \"c\"), \"d\").flat\nreturns (\"a\", \"b\", \"c\", \"d\"), but it does not flatten itemized sublists:\n\n    say ($('a', 'b'), 'c').perl;    # OUTPUT: «($(\"a\", \"b\"), \"c\")␤»","lazy\n\nDefined as:\n\n    method lazy(--> Iterable)\n\nReturns a lazy iterable wrapping the invocant.\n\n    say (1 ... 1000).is-lazy;      # OUTPUT: «False␤»\n    say (1 ... 1000).lazy.is-lazy; # OUTPUT: «True␤»","hyper\n\nDefined as:\n\n    method hyper(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4)\n\nReturns another Iterable that is potentially iterated in parallel, with a\ngiven batch size and degree of parallelism.\n\nThe order of elements is preserved.\n\n    say ([1..100].hyper.map({ $_ +1 }).list);\n\nUse hyper in situations where it is OK to do the processing of items in\nparallel, and the output order should be kept relative to the input order.\nSee race for situations where items are processed in parallel and the\noutput order does not matter.\n\n    Options degree and batch\n\nThe degree option (short for \"degree of parallelism\") configures how many\nparallel workers should be started. To start 4 workers (e.g. to use at most\n4 cores), pass :4degree to the hyper or race method. Note that in some\ncases, choosing a degree higher than the available CPU cores can make\nsense, for example I/O bound work or latency-heavy tasks like web crawling.\nFor CPU-bound work, however, it makes no sense to pick a number higher than\nthe CPU core count.\n\nThe batch size option configures the number of items sent to a given\nparallel worker at once. It allows for making a throughput/latency\ntrade-off. If, for example, an operation is long-running per item, and you\nneed the first results as soon as possible, set it to 1. That means every\nparallel worker gets 1 item to process at a time, and reports the result as\nsoon as possible. In consequence, the overhead for inter-thread\ncommunication is maximized. In the other extreme, if you have 1000 items to\nprocess and 10 workers, and you give every worker a batch of 100 items, you\nwill incur minimal overhead for dispatching the items, but you will only\nget the first results when 100 items are processed by the fastest worker\n(or, for hyper, when the worker getting the first batch returns.) Also, if\nnot all items take the same amount of time to process, you might run into\nthe situation where some workers are already done and sit around without\nbeing able to help with the remaining work. In situations where not all\nitems take the same time to process, and you don't want too much\ninter-thread communication overhead, picking a number somewhere in the\nmiddle makes sense. Your aim might be to keep all workers about evenly busy\nto make best use of the resources available.\n\nYou can also check out this blog post on the semantics of hyper and race","race\n\nDefined as:\n\n    method race(Int(Cool) :$batch = 64, Int(Cool) :$degree = 4 --> Iterable)\n\nReturns another Iterable that is potentially iterated in parallel, with a\ngiven batch size and degree of parallelism (number of parallel workers).\n\nUnlike hyper, race does not preserve the order of elements.\n\n    say ([1..100].race.map({ $_ +1 }).list);\n\nUse race in situations where it is OK to do the processing of items in\nparallel, and the output order does not matter. See hyper for situations\nwhere you want items processed in parallel and the output order should be\nkept relative to the input order.\n\nBlog post on the semantics of hyper and race\n\nSee hyper for an explanation of :$batch and :$degree."],"desc":"TITLE\nrole Iterable\n\nSUBTITLE\nInterface for container objects that can be iterated over\n\n    role Iterable { }\n\nIterable serves as an API for objects that can be iterated with for and\nrelated iteration constructs, like assignment to a Positional variable.\n\nIterable objects nested in other Iterable objects (but not within scalar\ncontainers) flatten in certain contexts, for example when passed to a\nslurpy parameter (*@a), or on explicit calls to flat.\n\nIts most important aspect is a method stub for iterator.\n\n    class DNA does Iterable {\n        has $.chain;\n        method new ($chain where { $chain ~~ /^^ <[ACGT]>+ $$ / } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator(DNA:D:) {\n            $!chain.comb.rotor(3).iterator;\n        }\n    }\n\n    my $a := DNA.new('GAATCC');\n    .say for $a; # OUTPUT: «(G A A)␤(T C C)␤»\n\n\nThis example mixes in the Iterable role to offer a new way of iterating\nover what is essentially a string (constrained by where to just the four\nDNA letters). In the last statement, for actually hooks to the iterator\nrole printing the letters in groups of 3.\n\n"},{"desc":"TITLE\nclass Slip\n\nSUBTITLE\nA kind of List that automatically flattens into an outer container\n\n    class Slip is List {}\n\nA Slip is a List that automatically flattens into an outer List (or other\nlist-like container or iterable).\n\nFor example it allows you to write a map that produces more than one value\ninto the result without nesting:\n\n    say <a b c>.map({ ($_, $_.uc).Slip }).join('|');        # OUTPUT: «a|A|b|B|c|C␤»\n\n\nIn contrast, when returning an ordinary List, the resulting list is\nnested:\n\n    say <a b c>.map({ $_, $_.uc }).join('|');               # OUTPUT: «a A|b B|c C␤»\n\n\nTo create a Slip, either coerce another list-like type to it by calling the\nSlip method, or use the slip subroutine:\n\n    # This says \"1\" and then says \"2\", rather than saying \"(1 2)\"\n    .say for gather {\n        take slip(1, 2);\n    }\n\nA Slip may also be created by using the prefix:<|> operator. This differs\nfrom the slip subroutine in both precedence and treatment of single\narguments. In fact, prefix:<|> only takes a single argument, so in that\nway, it behaves closer to the .Slip method than the slip subroutine.\n\n    my $l = (1, 2, 3);\n    say (1, slip 2, 3).perl;  # says (1, 2, 3)      , slips 2, 3 into (1, …)\n    say (0, slip $l).perl;    # says (0, $(1, 2, 3)), $l does not break apart\n    say (0, $l.Slip).perl;    # says (0, 1, 2, 3)   , slips from $l into (0, …)\n    say (|$l).perl;           # says slip(1, 2, 3)  , breaks apart $l\n    say (0, (|$l, 4), 5);     # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, ($l.Slip, 4), 5); # says (0 (1 2 3 4) 5), slips from $l into (…, 4)\n    say (0, (slip $l, 4), 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n    say (0, ($l, 4).Slip, 5); # says (0 (1 2 3) 4 5), slips ($l, 4) into (0, …, 5)\n\n\nLoops that do not want to produce a value for an iteration use Slips,\nrather than empty Lists to do so, as do if statements that do not run their\nblocks.\n\nPlease note that prefix:<|> will also apply parameters in a slippy manner\nto a routine call. It does not forward a Slip to the called routine, that\nincludes return and take.\n\n    my \\l = gather for 1..10 -> $a, $b { take |($a, $b) }; say l.perl;\n    # OUTPUT: «((1, 2), (3, 4), (5, 6), (7, 8), (9, 10)).Seq␤»\n    my \\m= gather for 1..10 -> $a, $b { take ($a, $b).Slip }; say m.perl;\n    # OUTPUT: «(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).Seq␤»\n\n","methods":["List\n\nDefined as:\n\n    multi method List(Slip:D: --> List:D)\n\nTurns it into a list.\n\n  sub slip\n\nDefined as:\n\n    multi sub slip(--> Empty)\n    multi sub slip(@args --> Slip:D)\n    multi sub slip(+args --> Slip:D)\n\nCreates a Slip from its arguments by calling .Slip on the object formed by\nthem. Returns Empty if called with void arguments.\n\nConstants\n\n  constant Empty\n\nEmpty is a Slip of the empty List.\n\n    say \"\".comb ~~ Empty;\n    # OUTPUT: «True␤»"],"name":"Slip"},{"name":"NFKD","desc":"TITLE\nclass NFKD\n\nSUBTITLE\nCodepoint string in Normal Form KD (compatibility decomposed)\n\n    class NFKD is Uni {}\n\nA Codepoint string in Unicode Normalization Form KD. It is created by\nCompatibility Decomposition. For more information on what this means, see\nUnicode TR15.","methods":[]},{"name":"Test","methods":["sub plan\n\nDefined as:\n\n    multi sub plan(Cool:D :skip-all($reason)!)\n    multi sub plan($number_of_tests)\n\nSpecify the count of tests -- usually written at the beginning of a test\nfile.\n\n    plan 15;   # expect to run 15 tests\n\n\nIn subtests, plan is used to specify the count of tests within the\nsubtest.\n\nIf a plan is used, it's not necessary to specify the end of testing with\ndone-testing.\n\nYou can also provide a :skip-all named argument instead of a test count, to\nindicate that you want to skip all of the tests. Such a plan will call\nexit, unless used inside of a subtest.\n\n    plan :skip-all<These tests are only for Windows> unless $*DISTRO.is-win;\n    plan 1;\n    ok dir 'C:/'; # this won't get run on non-Windows\n\n\nIf used in a subtest, it will instead return from that subtest's Callable.\nFor that reason, to be able to use :skip-all inside a subtest, you must use\na sub instead of a regular block:\n\n    plan 2;\n    subtest \"Some Windows tests\" => sub { # <-- note the `sub`; can't use bare block\n        plan :skip-all<We aren't on Windows> unless $*DISTRO.is-win;\n        plan 1;\n        ok dir 'C:/'; # this won't get run on non-Windows\n    }\n    ok 42; # this will run everywhere and isn't affected by skip-all inside subtest\n\n\nNote that plan with :skip-all is to avoid performing any tests without\nmarking the test run as failed (i.e. the plan is to not run anything and\nthat's all good). Use skip-rest to skip all further tests, once the run has\nstarted (i.e. planned to run some tests, maybe even ran some, but now we're\nskipping all the rest of them). Use bail-out to fail the test run without\nrunning any further tests (i.e. things are so bad, there's no point in\nrunning anything else; we've failed).\n\n  sub done-testing\n\nDefined as:\n\n    sub done-testing()\n\nSpecify that testing has finished. Use this function when you don't have a\nplan with the number of tests to run. A plan is not required when using\ndone-testing.\n\nIt's recommended that the done-testing function be removed and replaced\nwith a plan function when all tests are finalized. Use of plan can help\ndetect test failures otherwise not reported because tests were accidentally\nskipped due to bugs in the tests or bugs in the compiler. For example:\n\n        sub do-stuff {@};\n        use Test;\n        ok .is-prime for do-stuff;\n        done-testing;\n        # output:\n        1..0\n\n\nThe above example is where a done-testing fails. do-stuff() returned\nnothing and tested nothing, even though it should've returned results to\ntest. But the test suite doesn't know how many tests were meant to be run,\nso it passes.\n\nAdding plan gives a true picture of the test:\n\n        sub do-stuff {@};\n        use Test;\n        plan 1;\n        ok .is-prime for do-stuff;\n        # output:\n        1..1\n        # Looks like you planned 1 test, but ran 0\n\n\nNote that leaving the done-testing in place will have no effect on the new\ntest results, but it should be removed for clarity.\n\n  sub ok\n\nDefined as:\n\n    multi sub ok(Mu $cond, $desc = '')\n\nThe ok function marks a test as passed if the given $value evaluates to\nTrue. The nok function marks a test as passed if the given value evaluates\nto False. Both functions accept an optional description of the test as\nsecond parameter.\n\n        my $response; my $query; ...;\n        ok  $response.success, 'HTTP response was successful';\n        nok $query.error,      'Query completed without error';\n\n\nIn principle, you could use ok for every kind of comparison test, by\nincluding the comparison in the expression passed to $value:\n\n        sub factorial($x) { ... };\n        ok factorial(6) == 720, 'Factorial - small integer';\n\n\nHowever, where possible it's better to use one of the specialized\ncomparison test functions below, because they can print more helpful\ndiagnostics output in case the comparison fails.\n\n  sub nok\n\nDefined as:\n\n    multi sub nok(Mu $cond, $desc = '')\n\nThe nok function marks a test as passed if the given value evaluates to\nFalse. It also accepts an optional description of the test as second\nargument.\n\n        my $response; my $query; ...;\n        ok  $response.success, 'HTTP response was successful';\n        nok $query.error,      'Query completed without error';\n\n\n  sub is\n\nDefined as\n\n    multi sub is(Mu $got, Mu:U $expected, $desc = '')\n    multi sub is(Mu $got, Mu:D $expected, $desc = '')\n\nMarks a test as passed if $value and $expected compare positively with the\neq operator, unless $expected is a type object, in which case === operator\nwill be used instead; accepts an optional description of the test as the\nlast argument.\n\nNOTE: eq operator the is() uses stringifies, which means is() is not a good\nfunction for testing more complex things, such as lists: is (1, (2, (3,))),\n[1, 2, 3] passes the test, even though the operands are vastly different.\nFor those cases, use is-deeply routine\n\n        my $pdf-document; sub factorial($x) { ... }; ...;\n        is $pdf-document.author, \"Joe\", 'Retrieving the author field';\n        is factorial(6),         720,   'Factorial - small integer';\n        my Int $a;\n        is $a, Int, 'The variable $a is an unassigned Int';\n\n\nNote: if only whitespace differs between the values, is() will output\nfailure message differently, to show the whitespace in each values. For\nexample, in the output below, the second test shows the literal \\t in the\ngot: line:\n\n    is \"foo\\tbar\", \"foo\\tbaz\";   # expected: 'foo     baz'␤#      got: 'foo   bar'\n    is \"foo\\tbar\", \"foo    bar\"; # expected: \"foo    bar\"␤#      got: \"foo\\tbar\"\n\n\n  sub isnt\n\nDefined as:\n\n    multi sub isnt(Mu $got, Mu:U $expected, $desc = '')\n    multi sub isnt(Mu $got, Mu:D $expected, $desc = '')\n\nMarks a test as passed if $value and $expected are not equal using the same\nrules as is(). The function accepts an optional description of the test.\n\n        isnt pi, 3, 'The constant π is not equal to 3';\n        my Int $a = 23;\n        $a = Nil;\n        isnt $a, Nil, 'Nil should not survive being put in a container';\n\n\n  sub is_approx\n\nDefined as:\n\n    multi sub is_approx(Mu $got, Mu $expected, $desc = '')\n\nNOTE: Deprecated as of version 6.d. Please use is-approx instead.\n\nChecks if result and the expected value are approximately equal to a\ncertain degree of tolerance, fixed to 1e-5 or one-millionth of the expected\nvalue is its value is less than that.\n\n    use Test;\n    is_approx(1e4, 1e4-1e-6, \"Real close\"); # OUTPUT: «ok 1 - Real close␤»\n\n\n(This will print also a deprecation notice if you're using 6.d)\n\n  sub is-approx\n\nDefined as:\n\n    multi sub is-approx(Numeric $got, Numeric $expected, $desc = '')\n\n    multi sub is-approx(Numeric $got, Numeric $expected, Numeric $abs-tol,\n                        $desc = '')\n\n\n    multi sub is-approx(Numeric $got, Numeric $expected, $desc = '',\n                        Numeric :$rel-tol is required)\n\n\n    multi sub is-approx(Numeric $got, Numeric $expected, $desc = '',\n                        Numeric :$abs-tol is required)\n\n\n    multi sub is-approx(Numeric $got, Numeric $expected, $desc = '',\n                        Numeric :$rel-tol is required,\n                        Numeric :$abs-tol is required)\n\n\nMarks a test as passed if the $value and $expected numerical values are\napproximately equal to each other. The subroutine can be called in numerous\nways that let you test using relative tolerance ($rel-tol) or absolute\ntolerance ($abs-tol) of different values.\n\nIf no tolerance is set, the function will base the tolerance on the\nabsolute value of $expected: if it's smaller than 1e-6, use absolute\ntolerance of 1e-5; if it's larger, use relative tolerance of 1e-6.\n\n        my Numeric ($value, $expected, $abs-tol, $rel-tol) = ...\n\n        is-approx $value, $expected;\n        is-approx $value, $expected, 'test description';\n\n        is-approx $value, $expected, $abs-tol;\n        is-approx $value, $expected, $abs-tol, 'test description';\n\n        is-approx $value, $expected, :$rel-tol;\n        is-approx $value, $expected, :$rel-tol, 'test description';\n\n        is-approx $value, $expected, :$abs-tol;\n        is-approx $value, $expected, :$abs-tol, 'test description';\n\n        is-approx $value, $expected, :$abs-tol, :$rel-tol;\n        is-approx $value, $expected, :$abs-tol, :$rel-tol, 'test description';\n\n\n    Absolute tolerance\n\nWhen an absolute tolerance is set, it's used as the actual maximum value by\nwhich the $value and $expected can differ. For example:\n\n        is-approx 3, 4, 2; # success\n        is-approx 3, 6, 2; # fail\n\n        is-approx 300, 302, 2; # success\n        is-approx 300, 400, 2; # fail\n        is-approx 300, 600, 2; # fail\n\n\nRegardless of values given, the difference between them cannot be more than\n2.\n\n    Relative tolerance\n\nWhen a relative tolerance is set, the test checks the relative difference\nbetween values. Given the same tolerance, the larger the numbers given, the\nlarger the value they can differ by can be.\n\nFor example:\n\n        is-approx 10, 10.5, :rel-tol<0.1>; # success\n        is-approx 10, 11.5, :rel-tol<0.1>; # fail\n\n        is-approx 100, 105, :rel-tol<0.1>; # success\n        is-approx 100, 115, :rel-tol<0.1>; # fail\n\n\nBoth versions use 0.1 for relative tolerance, yet the first can differ by\nabout 1 while the second can differ by about 10. The function used to\ncalculate the difference is:\n\n                  |value - expected|\n    ⁣rel-diff = ────────────────────────\n               max(|value|, |expected|)\n\n\nand the test will fail if rel-diff is higher than $rel-tol.\n\n    Both absolute and relative tolerance specified\n\n    is-approx $value, $expected, :rel-tol<.5>, :abs-tol<10>;\n\n\nWhen both absolute and relative tolerances are specified, each will be\ntested independently, and the is-approx test will succeed only if both\npass.\n\n  sub is-approx-calculate\n\nDefined as:\n\n    sub is-approx-calculate ($got,$expected,$abs-tol where { !.defined or $_ >= 0 },$rel-tol where { !.defined or $_ >= 0 },$desc)\n\nThis is the actual routine called by is-approx when absolute and relative\ntolerance are specified. They are tested independently, and the test\nsucceeds only if both pass.\n\n  sub is-deeply\n\nDefined as:\n\n    multi sub is-deeply(Seq:D $got, Seq:D $expected, $reason = '')\n    multi sub is-deeply(Seq:D $got, Mu $expected, $reason = '')\n    multi sub is-deeply(Mu $got, Seq:D $expected, $reason = '')\n    multi sub is-deeply(Mu $got, Mu $expected, $reason = '')\n\nMarks a test as passed if $value and $expected are equivalent, using the\nsame semantics as the eqv operator. This is the best way to check for\nequality of (deep) data structures. The function accepts an optional\ndescription of the test as the last argument.\n\n    use Test;\n    plan 1;\n\n    sub string-info(Str() $_) {\n        Map.new: (\n          length  =>  .chars,\n          char-counts => Bag.new-from-pairs: (\n              letters => +.comb(/<:letter>/),\n              digits  => +.comb(/<:digit>/),\n              other   => +.comb(/<.-:letter-:digit>/),\n        ))\n    }\n\n    is-deeply string-info('42 Butterflies ♥ Perl'), Map.new((\n        :21length,\n        char-counts => Bag.new-from-pairs: ( :15letters, :2digits, :4other, )\n    )), 'string-info gives right info';\n\n\nNote: for historical reasons, Seq:D arguments to is-deeply get converted to\nLists. If you want to ensure strict Seq comparisons, use cmp-ok $got,\n'eqv', $expected, $desc instead.\n\n  sub cmp-ok\n\n    multi sub cmp-ok(Mu $got is raw, $op, Mu $expected is raw, $desc = '')\n\nCompares $value and $expected with the given $comparison comparator and\npasses the test if the comparison yields a True value. The description of\nthe test is optional.\n\nThe $comparison comparator can be either a Callable or a Str containing an\ninfix operator, such as '==', a '~~', or a user-defined infix.\n\n        cmp-ok 'my spelling is apperling', '~~', /perl/, \"bad speller\";\n\n\nMetaoperators cannot be given as a string; pass them as a Callable\ninstead:\n\n        cmp-ok <a b c>, &[!eqv], <b d e>, 'not equal';\n\n\nA Callable $comparison lets you use custom comparisons:\n\n        sub my-comp { $^a / $^b  < rand };\n        cmp-ok 1, &my-comp, 2, 'the dice giveth and the dice taketh away'\n        cmp-ok 2, -> $a, $b { $a.is-prime and $b.is-prime and $a < $b }, 7,\n            'we got primes, one larger than the other!';\n\n\n  sub isa-ok\n\nDefined as:\n\n    multi sub isa-ok(Mu $var, Mu $type, $desc = \"The object is-a '$type.perl()'\")\n\nMarks a test as passed if the given object $value is, or inherits from, the\ngiven $expected-type. For convenience, types may also be specified as a\nstring. The function accepts an optional description of the test, which\ndefaults to a string that describes the object.\n\n        class Womble {}\n        class GreatUncleBulgaria is Womble {}\n        my $womble = GreatUncleBulgaria.new;\n\n        isa-ok $womble, Womble, \"Great Uncle Bulgaria is a womble\";\n        isa-ok $womble, 'Womble';     # equivalent\n\n\n  sub can-ok\n\nDefined as:\n\n    multi sub can-ok(Mu $var, Str $meth,$desc = \"...\" )\n\nMarks a test as passed if the given $variable can run the given\n$method-name. The function accepts an optional description. For instance:\n\n        class Womble {};\n        my $womble = Womble.new;\n\n        # with automatically generated test description\n        can-ok $womble, 'collect-rubbish';\n        #  => An object of type 'Womble' can do the method 'collect-rubbish'\n\n        # with human-generated test description\n        can-ok $womble, 'collect-rubbish', \"Wombles can collect rubbish\";\n        #  => Wombles can collect rubbish\n\n\n  sub does-ok\n\nDefined as:\n\n    multi sub does-ok(Mu $var, Mu $type, $desc = \"...\")\n\nMarks a test as passed if the given $variable can do the given $role. The\nfunction accepts an optional description of the test.\n\n        # create a Womble who can invent\n        role Invent {\n            method brainstorm { say \"Aha!\" }\n        }\n        class Womble {}\n        class Tobermory is Womble does Invent {}\n\n        # ... and later in the tests\n        use Test;\n\n        my $tobermory = Tobermory.new;\n\n        # with automatically generated test description\n        does-ok $tobermory, Invent;\n        #  => The object does role Type\n\n        does-ok $tobermory, Invent, \"Tobermory can invent\";\n        #  => Tobermory can invent\n\n\n  sub like\n\nDefined as:\n\n    sub like(Str() $got, Regex:D $expected,$desc = \"text matches $expected.perl()\")\n\nUse it this way:\n\n        like 'foo', /fo/, 'foo looks like fo';\n\n\nMarks a test as passed if the $value, when coerced to a string, matches the\n$expected-regex. The function accepts an optional description of the test\nwith a default value printing the expected match.\n\n  sub unlike\n\nDefined as:\n\n    multi sub unlike(Str() $got, Regex:D $expected,$desc = \"text does not match $expected.perl()\")\n\nUsed this way:\n\n        unlike 'foo', /bar/, 'foo does not look like bar';\n\n\nMarks a test as passed if the $value, when coerced to a string, does not\nmatch the $expected-regex. The function accepts an optional description of\nthe test, which defaults to printing the text that did not match.\n\n  sub use-ok\n\nDefined as:\n\n    multi sub use-ok(Str $code, $desc = \"$code module can be use-d ok\")\n\nMarks a test as passed if the given $module loads correctly.\n\n        use-ok 'Full::Qualified::ModuleName';\n\n\n  sub dies-ok\n\nDefined as:\n\n    multi sub dies-ok(Callable $code, $reason = '')\n\nMarks a test as passed if the given $code throws an exception.\n\nThe function accepts an optional description of the test.\n\n    sub saruman(Bool :$ents-destroy-isengard) {\n        die \"Killed by Wormtongue\" if $ents-destroy-isengard;\n    }\n\n    dies-ok { saruman(ents-destroy-isengard => True) }, \"Saruman dies\";\n\n\n  sub lives-ok\n\nDefined as:\n\n    multi sub lives-ok(Callable $code, $reason = '')\n\nMarks a test as passed if the given $code does not throw an exception.\n\nThe function accepts an optional description of the test.\n\n    sub frodo(Bool :$destroys-ring) {\n        die \"Oops, that wasn't supposed to happen\" unless $destroys-ring;\n    }\n\n    lives-ok { frodo(destroys-ring => True) }, \"Frodo survives\";\n\n\n  sub eval-dies-ok\n\nDefined as:\n\n    multi sub eval-dies-ok(Str $code, $reason = '')\n\nMarks a test as passed if the given $string throws an exception when evaled\nas code.\n\nThe function accepts an optional description of the test.\n\n    eval-dies-ok q[my $joffrey = \"nasty\";\n                   die \"bye bye Ned\" if $joffrey ~~ /nasty/],\n        \"Ned Stark dies\";\n\n\n  sub eval-lives-ok\n\nDefined as:\n\n    multi sub eval-lives-ok(Str $code, $reason = '')\n\nMarks a test as passed if the given $string does not throw an exception\nwhen evaled as code.\n\nThe function accepts an optional description of the test.\n\n    eval-lives-ok q[my $daenerys-burns = False;\n                    die \"Oops, Khaleesi now ashes\" if $daenerys-burns],\n        \"Dany is blood of the dragon\";\n\n\n  sub throws-like\n\nDefined as:\n\n    sub throws-like($code, $ex_type, $reason?, *%matcher)\n\nMarks a test as passed if the given $code throws the specific exception\nexpected exception type $ex_type. The code $code may be specified as\nsomething Callable or as a string to be EVALed. The exception may be\nspecified as a type object or as a string containing its type name.\n\nIf an exception was thrown, it will also try to match the matcher hash,\nwhere the key is the name of the method to be called on the exception, and\nthe value is the value it should have to pass. For example:\n\n    sub frodo(Bool :$destroys-ring) {\n        fail \"Oops. Frodo dies\" unless $destroys-ring\n    };\n    throws-like { frodo }, Exception, message => /dies/;\n\n\nThe function accepts an optional description of the test as the third\npositional argument.\n\nThe routine makes Failures fatal. If you wish to avoid that, use no fatal\npragma and ensure the tested code does not sink the possible Failures. If\nyou wish to test that the code returns a Failure instead of throwing, use\nfails-like routine instead.\n\n    sub fails-not-throws { +\"a\" }\n    # test passes, even though it's just a Failure and would not always throw:\n    throws-like { fails-not-throws }, Exception;\n\n    # test detects nothing thrown, because our Failure wasn't sunk or made fatal:\n    throws-like { no fatal; my $ = fails-not-throws; Nil }, Exception;\n\n\nPlease note that you can only use the string form (for EVAL) if you are not\nreferencing any symbols in the surrounding scope. If you are, you should\nencapsulate your string with a block and an EVAL instead. For instance:\n\n    throws-like { EVAL q[ fac(\"foo\") ] }, X::TypeCheck::Argument;\n\n\n  sub fails-like\n\nDefined as:\n\n    sub fails-like ( \\test where Callable:D|Str:D, $ex-type, $reason?, *%matcher)\n\nSame interface as throws-like, except checks that the code returns a\nFailure instead of throwing. If the code does throw or if the returned\nFailure has already been handled, that will be considered as a failed\ntest.\n\n    fails-like { +\"a\" }, X::Str::Numeric,\n        :message(/'Cannot convert string to number'/),\n        'converting non-numeric string to number fails';\n\n\n  sub subtest\n\nDefined as:\n\n    multi sub subtest(Pair $what)\n    multi sub subtest($desc, &subtests)\n    multi sub subtest(&subtests, $desc = '')\n\nThe subtest function executes the given block, consisting of usually more\nthan one test, possibly including a plan or done-testing, and counts as one\ntest in plan, todo, or skip counts. It will pass the test only if all tests\nin the block pass. The function accepts an optional description of the\nsubtest.\n\n    class Womble {}\n\n    class GreatUncleBulgaria is Womble {\n        has $.location = \"Wimbledon Common\";\n        has $.spectacles = True;\n    }\n\n    subtest {\n        my $womble = GreatUncleBulgaria.new;\n\n        isa-ok $womble,            Womble,             \"Correct type\";\n        is     $womble.location,   \"Wimbledon Common\", \"Correct location\";\n        ok     $womble.spectacles,                     \"Correct eyewear\";\n\n    }, \"Check Great Uncle Bulgaria\";\n\n\nYou can also place the description as the first positional argument, or use\na Pair with description as the key and subtest's code as the value. This\ncan be useful for subtests with large bodies.\n\n    subtest 'A bunch of tests', {\n        plan 42;\n        ...\n        ...\n    }\n\n    subtest 'Another bunch of tests' => {\n        plan 72;\n        ...\n        ...\n    }\n\n\n  sub todo\n\nDefined as:\n\n    multi sub todo($reason, $count = 1)\n\nSometimes tests just aren't ready to be run, for instance a feature might\nnot yet be implemented, in which case tests can be marked as todo. Or it\ncould be the case that a given feature only works on a particular platform\n- in which case one would skip the test on other platforms.\n\nMark $count tests as TODO, giving a $reason as to why. By default only one\ntest will be marked TODO.\n\n        sub my-custom-pi { 3 };\n\n        todo 'not yet precise enough';         # Mark the test as TODO.\n        is my-custom-pi(), pi, 'my-custom-pi'; # Run the test, but don't report\n                                               # failure in test harness.\n\n\nThe result from the test code above will be something like:\n\n    not ok 1 - my-custom-pi# TODO not yet precise enough\n\n    # Failed test 'my-custom-pi'\n    # at test-todo.t line 7\n    # expected: '3.14159265358979'\n    #      got: '3'\n\n\nNote that if you todo a subtest, all of the failing tests inside of it will\nbe automatically marked TODO as well and will not count towards your\noriginal TODO count.\n\n  sub skip\n\nDefined as:\n\n    multi sub skip()\n    multi sub skip($reason, $count = 1)\n\nSkip $count tests, giving a $reason as to why. By default only one test\nwill be skipped. Use such functionality when a test (or tests) would die if\nrun.\n\n    sub num-forward-slashes($arg) { ... } ;\n\n    if $*KERNEL ~~ 'linux' {\n        is num-forward-slashes(\"/a/b\"),             2;\n        is num-forward-slashes(\"/a//b\".IO.cleanup), 2;\n    }\n    else {\n        skip \"Can't use forward slashes on Windows\", 2;\n    }\n\n\nNote that if you mark a test as skipped, you must also prevent that test\nfrom running.\n\n  sub skip-rest\n\nDefined as:\n\n    sub skip-rest($reason = '<unknown>')\n\nSkip the remaining tests. If the remainder of the tests in the test file\nwould all fail due to some condition, use this function to skip them,\nproviding an optional $reason as to why.\n\n    my $location; sub womble { ... }; ...;\n    unless $location ~~ \"Wimbledon Common\" {\n        skip-rest \"We can't womble, the remaining tests will fail\";\n        exit;\n    }\n\n    # tests requiring functional wombling\n    ok womble();\n    # ...\n\n\nNote that skip-rest requires a plan to be set, otherwise the skip-rest call\nwill throw an error. Note that skip-rest does not exit the test run. Do it\nmanually, or use conditionals to avoid running any further tests.\n\nSee also plan :skip-all('...') to avoid running any tests at all and\nbail-out to abort the test run and mark it as failed.\n\n  sub bail-out\n\n    sub bail-out ($desc?)\n\nIf you already know the tests will fail, you can bail out of the test run\nusing bail-out():\n\n    my $has-db-connection;\n    ...\n    $has-db-connection  or bail-out 'Must have database connection for testing';\n\n\nThe function aborts the current test run, signaling failure to the harness.\nTakes an optional reason for bailing out. The subroutine will call exit(),\nso if you need to do a clean-up, do it before calling bail-out().\n\nIf you want to abort the test run, but without marking it as failed, see\nskip-rest or plan :skip-all('...')\n\n  sub pass\n\nDefined as:\n\n    multi sub pass($desc = '')\n\nThe pass function marks a test as passed. flunk marks a test as not passed.\nBoth functions accept an optional test description.\n\n    pass \"Actually, this test has passed\";\n    flunk \"But this one hasn't passed\";\n\n\nSince these subroutines do not provide indication of what value was\nreceived and what was expected, they should be used sparingly, such as when\nevaluating a complex test condition.\n\n  sub flunk\n\n    multi sub flunk($reason = '')\n\nThe opposite of pass, makes a test fail with an optional message.\n\n  sub diag\n\n    sub diag($message)\n\nDisplay diagnostic information in a TAP-compatible manner on the standard\nerror stream. This is usually used when a particular test has failed to\nprovide information that the test itself did not provide. Or it can be used\nto provide visual markers on how the testing of a test-file is progressing\n(which can be important when doing stress testing).\n\n    diag \"Yay!  The tests got to here!\";"],"desc":"TITLE\nmodule Test\n\nSUBTITLE\nWriting and running tests\n\nThis module provides a testing framework, and is used in the official suite\nthat tests the specification. All its functions emit output conforming to\nthe Test Anything Protocol.\n\n"},{"methods":["subbuf-rw\n\n    method subbuf-rw($from = 0, $elems = self.elems - $from) is rw\n\nA mutable version of subbuf that returns a Proxy functioning as a writable\nreference to a part of a buffer. Its first argument, $from specifies the\nindex in the buffer from which a substitution should occur, and its last\nargument, $elems specifies how many elements are to be replaced.\n\nFor example, to replace one element at index 3 with two elements, 100 and\n101:\n\n    my Buf $b .= new(0..5);\n    $b.subbuf-rw(3,1) = Buf.new(100, 101);\n    say $b.perl;   # OUTPUT: «Buf.new(0,1,2,100,101,4,5)␤»\n\nIn the case the $elems argument is not specified, the substitution happens\nat the specified index $from removing all trailing elements:\n\n    my Buf $b .= new(0..5);\n    $b.subbuf-rw(3) = Buf.new(200);\n    say $b.perl;   # OUTPUT: «Buf.new(0,1,2,200)␤»\n\nIn the case the $from argument is not specified, the substitution happens\nfrom the very beginning of the buffer:\n\n    my Buf $b .= new(0..5);\n    $b.subbuf-rw = Buf.new(123, 123);\n    say $b.perl;   # OUTPUT: «Buf.new(123, 123)␤»","subbuf-rw\n\nDeclared as\n\n    multi sub subbuf-rw(Buf:D \\b) is rw\n    multi sub subbuf-rw(Buf:D \\b, Int() $from) is rw\n    multi sub subbuf-rw(Buf:D \\b, $from, $elems) is rw\n\nReturns a writable reference to a part of a buffer. Invokes the subbuf-rw\nmethod on the specified Buf:\n\n    my Buf $b .= new(1,2,3);\n    subbuf-rw($b,2,1) = Buf.new(42);\n    say $b.perl;   # OUTPUT: «Buf.new(1,2,42)␤»","reallocate\n\n    method reallocate($elems)\n\nChange the number of elements of the Buf, returning the changed Buf. The\nsize of Buf will be adapted depending on the number of $elems specified: if\nit is smaller than the actual size of the Buf the resulting Buf will be\nshrunk down, otherwise it will be enlarged to fit the number of $elems. In\nthe case the Buf is enlarged, newly created items will be assigned a\nVirtual Machine specific null value, therefore you should not rely upon\ntheir value since it could be inconsistent across different virtual\nmachines.\n\n    my Buf $b .= new(^10);\n    $b.reallocate(5);\n    say $b.perl;  # OUTPUT: «Buf.new(0,1,2,3,4)␤»\n\n    $b = Buf.new( 1..3 );\n    $b.reallocate( 10 );\n    $b.perl.say; # OUTPUT: «Buf.new(1,2,3,0,0,0,0,0,0,0)␤»","list\n\nDefined as:\n\n    multi method list(Buf:D:)\n\nReturns a Seq of codepoints.\n\n    say Buf.new(122,105,112,205).list; # OUTPUT: «(122 105 112 205)␤»","push\n\n    method push( $elems )\n\nAdds elements at the end of the buffer\n\n    my @φ =  1,1, * + * … ∞;\n    my $bú = Buf.new( @φ[^5] );\n    $bú.push( @φ[5] );\n    say $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8)»","pop\n\n    method pop()\n\nExtracts the last element of the buffer\n\n    say $bú.pop(); # OUTPUT: «8»\n    say $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5)»","append\n\n    method append( $elems )\n\nAppends at the end of the buffer\n\n    $bú.append( @φ[5..10] );\n    say $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8,13,21,34,55,89)»","prepend\n\n    method prepend( $elems )\n\nAdds elements at the beginning of the buffer\n\n    $bú.prepend( 0 );\n    say $bú.perl; # OUTPUT: «Buf.new(0,1,1,2,3,5,8,13,21,34,55,89)»","shift\n\n    method shift()\n\nTakes out the first element of the buffer\n\n    $bú.shift();\n    say $bú.perl; # OUTPUT: «Buf.new(1,1,2,3,5,8,13,21,34,55,89)»","unshift\n\n    method unshift()\n\nAdds elements at the beginning of the buffer\n\n    $bú.unshift( 0 );\n    say $bú.perl; # OUTPUT: «Buf.new(0,1,1,2,3,5,8,13,21,34,55,89)»","splice\n\n    method splice( Buf:D: $start = 0, $elems?, *@replacement --> Buf)\n\nSubstitutes elements of the buffer by other elements\n\n    $bú.splice:  0, 3, <3 2 1>;\n    say $bú.perl; # OUTPUT: «Buf.new(3,2,1,2,3,5,8,13,21,34,55,89)»"],"desc":"TITLE\nrole Buf\n\nSUBTITLE\nMutable buffer for binary data\n\n    role Buf[::T = uint8] does Blob[T] is repr('VMArray') is array_type(T){ ... }\n\nA Buf does the role of a mutable sequence of (usually unsigned) integers.\n\n    my $b = Buf.new(1, 2, 3);\n    $b[1] = 42;\n\nHowever, it's a parameterized type, and you can instantiate with several\ninteger types:\n\n    my $b = Buf[int32].new( 3, -3, 0xff32, -44)\n    # OUTPUT: «Buf[int32]:0x<03 -3 FF32 -2C>»\n\n\nBy default, Buf uses 8-bit unsigned integers, that is, it is equivalent to\nBuf[uint8]. Some other types of Bufs which are used often get their own\nclass name.\n\n  buf8   Buf[uint8]\n  buf16  Buf[uint16]\n  buf32  Buf[uint32]\n  buf64  Buf[uint64]\n\n\nYou can use these in pretty much the same way you would with Buf:\n\n    my $buf = buf8.new(3,6, 254);\n    say $buf; # OUTPUT: «Buf[uint8]:0x<03 06 fe>␤»\n\nPlus there are some object methods, like encode that might return a buf8 in\nsome cases where it is the best representation for a particular encoding.\n\n","name":"Buf"},{"name":"DateTime","desc":"TITLE\nclass DateTime\n\nSUBTITLE\nCalendar date with time\n\n    class DateTime does Dateish {}\n\nFor handling points in civil time, a DateTime object stores year, month,\nday, hour, minute (all Int), second (potentially fractional) and a time\nzone.\n\nIt provides methods for calculating with date and time.\n\nDateTime methods are immutable; if you are tempted to modify one, create a\nmodified copy instead.\n\nTime zones are handled as Integers in seconds offset from UTC, not by time\nzone name.\n\n    my $dt = DateTime.new(\n        year    => 2015,\n        month   => 11,\n        day     => 21,\n        hour    => 16,\n        minute  => 1,\n    );\n\n    say $dt;                            # OUTPUT: «2015-11-21T16:01:00Z␤»\n    say $dt.later(days => 20);          # OUTPUT: «2015-12-11T16:01:00Z␤»\n    say $dt.truncated-to('hour');       # OUTPUT: «2015-11-21T16:00:00Z␤»\n    say $dt.in-timezone(-8 * 3600);     # OUTPUT: «2015-11-21T08:01:00-0800␤»\n\n    my $now = DateTime.now(formatter => { sprintf \"%02d:%02d\", .hour, .minute });\n    say $now;                           # 12:45 (or something like that)\n\n\n","methods":["new\n\nDefined as:\n\n    multi method new(Int :$year!, Int :$month = 1, Int :$day = 1,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Date :$date!,\n                     Int :$hour = 0, Int :$minute = 0, :$second = 0,\n                     Int :$timezone = 0, :&formatter)\n    multi method new(Int() $year, Int() $month, Int() $day,\n                     Int() $hour, Int $minute, $second,\n                     Int() :$timezone = 0, :&formatter)\n    multi method new(Instant:D $i,  :$timezone=0, :&formatter)\n    multi method new(Int:D $posix,  :$timezone=0, :&formatter)\n    multi method new(Str:D $format, :$timezone=0, :&formatter)\n\n\nCreates a new DateTime object. One option for creating a new DateTime\nobject is from the components (year, month, day, hour, ...) separately.\nAnother is to pass a Date object for the date component, and specify the\ntime component-wise. Yet another is to obtain the time from an Instant, and\nonly supply the time zone and formatter. Or instead of an Instant you can\nsupply an Int as a UNIX timestamp.\n\nYou can also supply a Str formatted in ISO 8601 timestamp notation or as a\nfull RFC 3339 date and time. Strings should be formatted as\nyyyy-mm-ddThh:mm:ssZ or yyyy-mm-ddThh:mm:ss+0100. We are somewhat less\nrestrictive than the ISO 8601 standard, as we allow Unicode digits and\nmixing of condensed and extended time formats.\n\nAn invalid input string throws an exception of type\nX::Temporal::InvalidFormat. If you supply a string that includes a time\nzone and supply the timezone named argument, an exception of type\nX::DateTime::TimezoneClash is thrown.\n\n    my $datetime = DateTime.new(year => 2015,\n                                month => 1,\n                                day => 1,\n                                hour => 1,\n                                minute => 1,\n                                second => 1,\n                                timezone => 1);\n    $datetime = DateTime.new(date => Date.new('2015-12-24'),\n                             hour => 1,\n                             minute => 1,\n                             second => 1,\n                             timezone => 1);\n    $datetime = DateTime.new(2015, 1, 1, # First January of 2015\n                             1, 1, 1);   # Hour, minute, second with default time zone\n    $datetime = DateTime.new(now);                       # Instant.\n    # from a Unix timestamp\n    say $datetime = DateTime.new(1470853583);            # OUTPUT: «2016-08-10T18:26:23Z␤»\n    $datetime = DateTime.new(\"2015-01-01T03:17:30+0500\") # Formatted string","now\n\nDefined as:\n\n    method now(:$timezone = $*TZ, :&formatter --> DateTime:D)\n\nCreates a new DateTime object from the current system time. A custom\nformatter and timezone can be provided. The :$timezone is the offset in\nseconds from GMT and defaults to the value of $*TZ variable.\n\n    say DateTime.now; # OUTPUT: «2018-01-08T13:05:32.703292-06:00␤»\n\nNote that one may use the methods shown below chained to the .now to easily\nexpress current values, e.g.,\n\n    say DateTime.now.year; # OUTPUT: «2018␤»","clone\n\nDefined as:\n\n    method clone(:$year, :$month, :$day, :$hour, :$minute, :$second, :$timezone, :&formatter)\n\nCreates a new DateTime object based on the invocant, but with the given\narguments overriding the values from the invocant.\n\n    say DateTime.new('2015-12-24T12:23:00Z').clone(hour => 0);\n    # OUTPUT: «2015-12-24T00:23:00Z␤»\n\nNote that this can lead to invalid dates in some circumstances:\n\n    say DateTime.new(\"2012-02-29T12:34:56Z\").clone(year => 2015);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::OutOfRange: Day out of range. Is: 29, should be in 1..28␤»","hh-mm-ss\n\nDefined as:\n\n    method hh-mm-ss(DateTime:D: --> Str:D)\n\nReturns the time represented by the object as a string in 24-hour HH:MM:SS\nformat:\n\n    say DateTime.new(\"2052-02-29T22:34:56Z\").hh-mm-ss;\n    # OUTPUT: «22:34:56␤»","hour\n\nDefined as:\n\n    method hour(DateTime:D: --> Int:D)\n\nReturns the hour component.\n\n    say DateTime.new('2012-02-29T12:34:56Z').hour;      # OUTPUT: «12␤»","minute\n\nDefined as:\n\n    method minute(DateTime:D: --> Int:D)\n\nReturns the minute component.\n\n    say DateTime.new('2012-02-29T12:34:56Z').minute;     # OUTPUT: «34␤»","second\n\nDefined as:\n\n    method second(DateTime:D:)\n\nReturns the second component, including potentially fractional seconds.\n\n    say DateTime.new('2012-02-29T12:34:56Z').second;     # OUTPUT: «56␤»\n    say DateTime.new('2012-02-29T12:34:56.789Z').second; # OUTPUT: «56.789␤»\n    say DateTime.new('2012-02-29T12:34:56,789Z').second; # comma also ok","whole-second\n\nDefined as:\n\n    method whole-second(DateTime:D:)\n\nReturns the second component, rounded down to an Int.\n\n    say DateTime.new('2012-02-29T12:34:56.789Z').whole-second;      # OUTPUT: «56␤»","timezone\n\nDefined as:\n\n    method timezone(DateTime:D: --> Int:D)\n\nReturns the time zone in seconds as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').timezone;          # OUTPUT: «7200␤»","offset\n\nDefined as:\n\n    method offset(DateTime:D: --> Int:D)\n\nReturns the time zone in seconds as an offset from UTC. This is an alias\nfor #method timezone.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset;            # OUTPUT: «7200␤»","offset-in-minutes\n\nDefined as:\n\n    method offset-in-minutes(DateTime:D: --> Real:D)\n\nReturns the time zone in minutes as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-minutes; # OUTPUT: «120␤»","offset-in-hours\n\nDefined as:\n\n    method offset-in-hours(DateTime:D: --> Real:D)\n\nReturns the time zone in hours as an offset from UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').offset-in-hours;   # OUTPUT: «2␤»","Str\n\nDefined as:\n\n    method Str(DateTime:D: --> Str:D)\n\nReturns a string representation of the invocant, as done by the formatter.\nIf no formatter was specified, an ISO 8601 timestamp will be returned.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').Str;\n    # OUTPUT: «2015-12-24T12:23:00+02:00␤»","Instant\n\nDefined as:\n\n    method Instant(DateTime:D: --> Instant:D)\n\nReturns an Instant object based on the invocant.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').Instant; # OUTPUT: «Instant:1450952616␤»","posix\n\nDefined as:\n\n    method posix(Bool:D: $ignore-timezone = False --> Int:D)\n\nReturns the date and time as a POSIX/UNIX timestamp (seconds since the\nEpoch, 1st January 1970 UTC).\n\nIf $ignore-timezone is True, the DateTime object will be treated as if the\ntime zone offset is zero.\n\n    say DateTime.new('2015-12-24T12:23:00Z').posix;       # OUTPUT: «1450959780␤»","later\n\nDefined as:\n\n    method later(DateTime:D: *%unit)\n\nReturns a DateTime object based on the current one, but with a time delta\napplied. The time delta can be passed as a named argument where the\nargument name is the unit.\n\nUnless the given unit is second or seconds, the given value will be\nconverted to an Int.\n\nAllowed units are second, seconds, minute, minutes, hour, hours, day, days,\nweek, weeks, month, months, year, years. Please note that the plural forms\ncan only be used with the later and earlier methods.\n\nThe :2nd form of colonpairs can be used as a compact and self-documenting\nway of specifying the delta:\n\n    say DateTime.new('2015-12-24T12:23:00Z').later(:2years);\n    # OUTPUT: «2017-12-24T12:23:00Z␤»\n\nSince addition of several different time units is not commutative, only one\nunit may be passed.\n\n    my $d = DateTime.new(date => Date.new('2015-02-27'));\n    say $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29T00:00:00Z␤»\n    say $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01T00:00:00Z␤»\n    say $d.later(days => 2).later(:month);   # same, as +True === 1\n\nIf the resultant time has value 60 for seconds, yet no leap second actually\nexists for that time, seconds will be set to 59:\n\n    say DateTime.new('2008-12-31T23:59:60Z').later: :1day;\n    # OUTPUT: «2009-01-01T23:59:59Z␤»\n\nNegative offsets are allowed, though earlier is more idiomatic for that.","earlier\n\nDefined as:\n\n    method earlier(DateTime:D: *%unit)\n\nReturns a DateTime object based on the current one, but with a time delta\ntowards the past applied. Unless the given unit is second or seconds, the\ngiven value will be converted to an Int. See #method later for usage.\n\n    my $d = DateTime.new(date => Date.new('2015-02-27'));\n    say $d.earlier(month => 1).earlier(:2days);  # OUTPUT: «2015-01-25T00:00:00Z␤»\n\nIf the resultant time has value 60 for seconds, yet no leap second actually\nexists for that time, seconds will be set to 59:\n\n    say DateTime.new('2008-12-31T23:59:60Z').earlier: :1day;\n    # OUTPUT: «2008-12-30T23:59:59Z␤»\n\nNegative offsets are allowed, though later is more idiomatic for that.","truncated-to\n\nDefined as:\n\n    method truncated-to(DateTime:D: Cool $unit)\n\nReturns a copy of the invocant, with everything smaller than the specified\nunit truncated to the smallest possible value.\n\n    my $d = DateTime.new(\"2012-02-29T12:34:56.946314Z\");\n    say $d.truncated-to('second');      # OUTPUT: «2012-02-29T12:34:56Z␤»\n    say $d.truncated-to('minute');      # OUTPUT: «2012-02-29T12:34:00Z␤»\n    say $d.truncated-to('hour');        # OUTPUT: «2012-02-29T12:00:00Z␤»\n    say $d.truncated-to('day');         # OUTPUT: «2012-02-29T00:00:00Z␤»\n    say $d.truncated-to('month');       # OUTPUT: «2012-02-01T00:00:00Z␤»\n    say $d.truncated-to('year');        # OUTPUT: «2012-01-01T00:00:00Z␤»\n\nDateTimes with fractional seconds can be truncated to whole seconds with\n.truncated-to('second').","Date\n\nDefined as:\n\n    multi method Date(DateTime:U --> Date:U)\n    multi method Date(DateTime:D --> Date:D)\n\nConverts the invocant to Date.\n\n    say DateTime.new(\"2012-02-29T12:34:56.946314Z\").Date; # OUTPUT: «2012-02-29␤»\n    say DateTime.Date;                                    # OUTPUT: «(Date)␤»","DateTime\n\nDefined as:\n\n    method DateTime(--> DateTime)\n\nReturns the invocant.\n\n    say DateTime.new(\"2012-02-29T12:34:56.946314Z\").DateTime;\n    # OUTPUT: «2012-02-29T12:34:56.946314Z␤»\n    say DateTime.DateTime;\n    # OUTPUT: «(DateTime)␤»","utc\n\nDefined as:\n\n    method utc(DateTime:D: --> DateTime:D)\n\nReturns a DateTime object for the same time, but in time zone UTC.\n\n    say DateTime.new('2015-12-24T12:23:00+0200').utc;\n    # OUTPUT: «2015-12-24T10:23:00Z␤»","in-timezone\n\nDefined as:\n\n    method in-timezone(DateTime:D: Int(Cool) $timezone = 0 --> DateTime:D)\n\nReturns a DateTime object for the same time, but in the specified\n$timezone, which is the offset in seconds from GMT.\n\n    say DateTime.new('2015-12-24T12:23:00Z').in-timezone(3600 + 1800); # OUTPUT: «2015-12-24T13:53:00+0130␤»\n\nPer RFC 7164, leap seconds do not respect local time and always occur at\nthe end of the UTC day:\n\n    say DateTime.new: '2017-01-01T00:59:60+01:00'\n    # OUTPUT: «2017-01-01T00:59:60+01:00␤»","local\n\nDefined as:\n\n    method local(DateTime:D: --> DateTime:D)\n\nReturns a DateTime object for the same time, but in the local time zone\n($*TZ).\n\n    my $*TZ = -3600;\n    say DateTime.new('2015-12-24T12:23:00+0200').local; # OUTPUT: «2015-12-24T09:23:00-0100␤»\n\n  sub infix:<->\n\n    multi sub infix:<-> (DateTime:D, Duration:D --> DateTime:D)\n    multi sub infix:<-> (DateTime:D, DateTime:D --> Duration:D)\n\nTakes a DateTime to subtract from and either a Duration or another DateTime\nobject. Returns a new DateTime object or the Duration between the two\ndates, respectively. When subtracting Duration, time zone of the original\nDateTime is preserved in the returned DateTime object.\n\n    say perl DateTime.new(:2016year) - DateTime.new(:2015year):;\n    # OUTPUT: «Duration.new(31536001.0)␤»\n    say DateTime.new(:2016year, :3600timezone) - Duration.new(31536001.0);\n    # OUTPUT: «2015-01-01T00:00:00+01:00␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+> (DateTime:D, Duration:D --> DateTime:D)\n    multi sub infix:<+> (Duration:D, DateTime:D --> DateTime:D)\n\nTakes a DateTime and increases it by the given Duration, preserving the\ntime zone.\n\n    say DateTime.new(:2015year) + Duration.new(31536001.0);\n    # OUTPUT: «2016-01-01T00:00:00Z␤»\n    say Duration.new(42) + DateTime.new(:2015year, :3600timezone);\n    # OUTPUT: «2015-01-01T00:00:42+01:00␤»\n\n  sub infix:«<=>»\n\n    multi sub infix:«<=>»(DateTime:D \\a, DateTime:D \\b --> Order:D)\n\nCompares the equivalent instant, returns the Order.\n\n    say DateTime.now <=> DateTime.now; # OUTPUT: «Less␤»\n\n  sub infix:«cmp»\n\n    multi sub infix:«cmp»(DateTime:D \\a, DateTime:D \\b --> Order:D)\n\nCompares the equivalent instant, returns the Order.\n\n  sub infix:«<»\n\n    multi sub infix:«<»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«>»\n\n    multi sub infix:«>»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«<=»\n\n    multi sub infix:«<=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«>=»\n\n    multi sub infix:«>=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«==»\n\n    multi sub infix:«==»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool\n\n  sub infix:«!=»\n\n    multi sub infix:«!=»(DateTime:D \\a, DateTime:D \\b --> Bool:D)\n\nCompares the equivalent instant, returns a Bool"]},{"desc":"TITLE\nclass Num\n\nSUBTITLE\nFloating-point number\n\n    class Num is Cool does Real { }\n\nA Num object stores a floating-point number. It is immutable. On most\nplatforms, it's an IEEE 754 64-bit floating point numbers, aka \"double\nprecision\".\n\n \n\n  Inf\n\nThe value Inf is an instance of Num and represents value that's too large\nto represent in 64-bit double-precision floating point number (roughly,\nabove 1.7976931348623158e308 for positive Inf and below\n-1.7976931348623157e308 for negative Inf) as well as returned from certain\noperations as defined by the IEEE 754-2008 standard.\n\n    say 2e300 ** 2e300; # OUTPUT: «Inf␤»\n    say (-1/0).Num;     # OUTPUT: «-Inf␤»\n\nThe ∞ U+221E Unicode character can be used instead of the word Inf and can\nbe handy when Inf would otherwise require an unspace, such as when writing\nComplex numbers:\n\n    say Inf+Inf\\i; # Backslash (unspace) before `i` required\n    say ∞+∞i;      # No backslash is needed\n\nNote that there are just two infinities (positive and negative), so even if\nan operation that would instinctively give a \"larger\" infinity is\nperformed, the result in still an infinity of the original magnitude. The\ninfinities can be compared, operated and used as an argument as if they\nwere simply a number that's too big to represent or to signify \"without\nbounds\" or limits:\n\n    say ∞²;                       # OUTPUT: «Inf␤»\n    say 42 + Inf === ∞;           # OUTPUT: «True␤»\n    say atan ∞;                   # OUTPUT: «1.5707963267949␤»\n    say -∞ < 42 < ∞;              # OUTPUT: «True␤»\n    my  $l := 1, 2, 4, 8 ... Inf; # Infinite sequence (no limits)\n\nIn some cases, it's used as an implicit value to represent \"all of them\"\n\n    say \"House of M\".comb(3,Inf).join(\"←X→\");\n    # OUTPUT: «Hou←X→se ←X→of ←X→M␤»\n\nIn the example above, Inf can be eliminated, since it's the default value\nfor the second argument of .comb, used to indicate how many parts should be\nreturned.\n\nDivision of an infinity by another infinity results in a NaN:\n\n    say ∞/∞;             # OUTPUT: «NaN␤»\n\n  NaN\n\nThe value NaN is an instance of Num and represents a floating point\nnot-a-number value, which is returned from some routines where a concrete\nnumber as the answer is not defined, but a Numeric value is still\nacceptable. NaN is defined and boolifies to True, but is not numerically\nequal to any value (including itself).\n\n    say cos ∞;     # OUTPUT: «NaN␤»\n    say (0/0).Num; # OUTPUT: «NaN␤»\n\nTo test for NaN, use isNaN method or === operator:\n\n    say (0/0).isNaN;       # OUTPUT: «True␤»\n    say (0/0).Num === NaN; # OUTPUT: «True␤»\n\n  method rand\n\n    method rand(Num:D: --> Num)\n\nReturns a pseudo random number between 0 and the invocant.\n\n  sub srand\n\n    sub srand(Int $seed --> Int:D)\n\nSeeds the pseudo random number generator used by Num.rand with the provided\nvalue. Note that srand is called with a platform dependent value when a\nRaku program is started.\n\n  method Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.\n\n  Int\n\n    method Int(Num:D:)\n\nConverts the number to an Int. Fails with X::Numeric::CannotConvert if the\ninvocant is a NaN or Inf/-Inf. No rounding is performed.\n\n  Rat\n\n    method Rat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a Rat with $epsilon precision. If the invocant is a\nInf, -Inf, or a NaN, converts them to a Rat with 0 denominator and 1, -1,\nor 0 numerator, respectively.\n\n  FatRat\n\n    method FatRat(Num:D: Real $epsilon = 1e-6)\n\nConverts the number to a FatRat with the precision $epsilon. If invocant is\na Inf, -Inf, or a NaN, converts them to a FatRat with 0 denominator and 1,\n-1, or 0 numerator, respectively.","methods":[],"name":"Num"},{"name":"Method","desc":"TITLE\nclass Method\n\nSUBTITLE\nMember function\n\n    class Method is Routine { }\n\nA type for methods that behave the same way then Routine with some\nexceptions listed in the following. For details of a method's parameter\nlist see Signature.\n\nTo create a method outside a class definition, use the declarators my and\nmethod. If an identifier is provided the methods name will be injected into\nthe scope specified by the declarator.\n\n    my $m = method ($invocant: $param) {\n        say \"$invocant: '$param'\";\n    }\n    \"greeting\".$m(\"hello\");  # OUTPUT: «greeting: 'hello'␤»\n\n    <a b c>.&(my method (List:D:) { say self.perl; self }).say;\n    # OUTPUT: «(\"a\", \"b\", \"c\")␤(a b c)␤»\n\nThe invocant of a method defaults to self. A type constraint including a\ntype-smiley can be used and is honored both for methods defined in a class\nand for free floating methods. Call the latter with .& on an object.\n\n    my method m(Int:D: $b){\n        say self.^name\n    }\n    my $i = 1;\n    $i.&m(<a>);\n    # OUTPUT: «Int␤»\n\n ","methods":["will ignore extra named arguments where other types of Routine\nwill throw at runtime. Extra arguments will be forwarded by nextsame and\nfriends.\n\n    class A {\n        multi method m(:$a, :$b) { say \"2 named\" }\n    }\n\n    class B is A {\n        method m(:$a) { say \"1 named\"; nextsame }\n    }\n    B.m( :1a, :2b );\n    # OUTPUT: «1 named␤2 named␤»\n\n  sub lastcall\n\n    sub lastcall(--> True)\n\nTruncates the current dispatch chain, which means any calls to nextsame,\ncallsame, nextwith, and callwith will not find any of the next candidates.\nNote that since samewith restarts the dispatch from the start, it's not\naffected by the truncation of current chain with lastcall.\n\nConsider example below. foo(6) uses nextsame when lastcall hasn't been\ncalled, and so it reaches the Any candidate. foo(2) calls nextsame as well,\nbut since lastcall was called first, the dispatch chain was truncated and\nthe Any candidate was not reached. The last call, foo(1), calls lastcall\ntoo, however, it then uses samewith, which isn't affected by it, and so the\ndispatch re-starts from scratch, hits the Int candidate with the new\nargument 6, and then proceeds to the Any candidate via nextsame (which\nisn't affected by the lastcall that was used before the samewith was\ncalled):\n\n    multi foo (Int $_) {\n        say \"Int: $_\";\n        lastcall   when *.is-prime;\n        nextsame   when *  %% 2;\n        samewith 6 when * !%% 2;\n    }\n    multi foo (Any $x) { say \"Any $x\" }\n\n    foo 6; say '----';\n    foo 2; say '----';\n    foo 1;\n\n    # OUTPUT:\n    # Int: 6\n    # Any 6\n    # ----\n    # Int: 2\n    # ----\n    # Int: 1\n    # Int: 6\n    # Any 6"]},{"name":"Sub","desc":"TITLE\nclass Sub\n\nSUBTITLE\nSubroutine\n\n    class Sub is Routine { }\n\nA type for subroutines and operators. Subs are created with the sub\ndeclarator keyword followed by an optional identifier. This short tutorial\nexplains how operators are declared. For details of a sub's parameter list,\nsee Signature.\n\nNote that subs that go by the same name as coercers will not take\nprecedence over them. Use the &-sigil to call them.\n\n    sub Int(Str $s){'what?'};\n    say [Int, Int('42'),&Int('42')];\n    # OUTPUT: «[(Int) 42 what?]␤»\n\n Subs can be nested and scoped with my and our, whereby my is the default.\nA sub declared with my cannot be reached from any outer scope. An our\nscoped sub will not redefine a sub of the same name in the outer scope. Any\nsub can be accessed via a closure from any outer scope. For instance, in\nthis example\n\n    sub can-be-seener( $whatever ) {\n      my sub can-be-seen ( $objection ) {\n        return $whatever but $objection;\n      }\n      return &can-be-seen\n    }\n\n    my $objectioner = can-be-seener( \"Really?\");\n    say $objectioner(42).Int; # OUTPUT: «42␤»\n\n$objectioner will contain the can-be-seen subroutine, even if it has been\ndeclared in another scope; calling it with 42 will return \"Really?\" with\nthe number 42 mixed in, as shown in the last sentence.\n\nOperators\n\nOperators are also Subs. Their definition includes the category they belong\nto and their code, precedence and associativity. The syntax used in their\ndefinition is an example of extended identifiers.\n\nTraits \n\nA Trait is a sub that is applied at compile time to various objects like\nclasses, routines or containers. It is declared with the trait_mod\ndeclarator followed by a colon and a string literal containing the name of\nthe trait. A single positional parameter defines the type of the object\nthat the trait is applied to. A single named argument defines the secondary\nname and may carry arguments when the trait is called. Traits are a special\ngrammar category and are allowed to be placed after most language object\nnames or parameter lists.\n\n    say 'start';\n    multi sub trait_mod:<is>(Sub $s, :$foo){\n        say \"⟨is foo⟩ has been called with ⟨$foo⟩ on {$s.WHICH}\";\n    }\n    sub bar() is foo<oi‽> {\n        say 'bar has been called'\n    }\n    bar();\n    # OUTPUT: «⟨is foo⟩ has been called with ⟨oi‽⟩ on Sub|47563000␤start␤bar has been called␤»\n\nUse destructuring to call traits with complex arguments.\n\n    multi trait_mod:<is>(Variable $a, :@foo [$firstpos, *@restpos, :$named, *%restnameds]) {\n        say [$firstpos, @restpos, $named, %restnameds]\n    }\n    my $x is foo[1,2,3,:named<a>, :2b, :3c] = 1\n    # OUTPUT: «[1 [2 3] a {b => 2, c => 3}]␤»\n\nDespite its funky syntax, a trait is just a normal Sub. We can apply traits\nto it (or even themselves) and we can apply traits to objects at runtime.\n\n    multi sub trait_mod:<is> (Sub $s, :$foo) is foo {\n        say 'is foo called'\n    }\n    sub bar {}\n    &trait_mod:<is>(&bar, :foo);\n    # OUTPUT: «is foo called␤is foo called␤»","methods":[]},{"desc":"TITLE\nclass NFD\n\nSUBTITLE\nCodepoint string in Normal Form D (decomposed)\n\n    class NFD is Uni {}\n\nA Codepoint string in the \"D\" Unicode Normalization Form","methods":[],"name":"NFD"},{"name":"Iterator","desc":"TITLE\nrole Iterator\n\nSUBTITLE\nGeneric API for producing a sequence of values\n\n    constant IterationEnd\n    role Iterator { }\n\n\nA Iterator is an object that can generate or provide elements of a\nsequence. Users usually don't have to care about iterators, their usage is\nhidden behind iteration APIs such as for @list { }, map, grep, head, tail,\nskip and list indexing with .[$idx].\n\nThe main API is the pull-one method, which either returns the next value,\nor the sentinel value IterationEnd if no more elements are available. Each\nclass implementing Iterator must provide a pull-one method. All other\nnon-optional Iterator API methods are implemented in terms of pull-one, but\ncan also be overridden by consuming classes for performance or other\nreasons. There are also optional Iterator API methods that will only be\ncalled if they are implemented by the consuming class: these are not\nimplemented by the Iterator role.\n\nIterationEnd\n\nIterators only allow one iteration over the entire sequence. It's forbidden\nto make attempts to fetch more data, once IterationEnd has been generated,\nand behavior for doing so is undefined. For example, the following Seq will\nnot cause the die to be called under normal use, because pull-one will\nnever be called after it returns IterationEnd:\n\n    class SkippingArray is Array {\n        # skip all undefined values while iterating\n        method iterator {\n            class :: does Iterator {\n                has $.index is rw = 0;\n                has $.array is required;\n                method pull-one {\n                    $.index++ while !$.array.AT-POS($.index).defined && $.array.elems > $.index;\n                    $.array.elems > $.index ?? $.array.AT-POS($.index++) !! IterationEnd\n                }\n            }.new(array => self)\n        }\n    }\n\n    my @a := SkippingArray.new;\n\n    @a.append: 1, Any, 3, Int, 5, Mu, 7;\n\n    for @a -> $a, $b {\n        say [$a, $b];\n    }\n\n    # OUTPUT: «[1 3]␤[5 7]␤»\n\n\nThe only valid use of the sentinel value IterationEnd in a program is\nidentity comparison (using =:=) with the result of a method in the iterator\nAPI. Any other behavior is undefined and implementation dependent.\n\nPlease bear in mind that IterationEnd is a constant, so if you are going to\ncompare it against the value of a variable, this variable will have to be\nbound, not assigned. Comparing directly to the output of pull-one will\nwork.\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    say $it.pull-one =:= IterationEnd; # OUTPUT: «True␤»\n\n\nHowever, if we use a variable we and we assign it, the result will be\nincorrect:\n\n    my $it = (1,2).iterator;\n    $it.pull-one for ^2;\n    my $is-it-the-end = $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «False␤»\n\n\nSo we'll have to bind the variable to make it work:\n\n    my $is-it-the-end := $it.pull-one;\n    say $is-it-the-end =:= IterationEnd; # OUTPUT: «True␤»\n\n\n","methods":["pull-one\n\nDefined as:\n\n    method pull-one(Iterator:D: --> Mu)\n\nThis method stub ensures that classes implementing the Iterator role\nprovide a method named pull-one.\n\nThe pull-one method is supposed to produce and return the next value if\npossible, or return the sentinel value IterationEnd if no more values could\nbe produced.\n\n    my $i = (1 .. 3).iterator;\n    say $i.pull-one;       # OUTPUT: «1␤»\n    say $i.pull-one;       # OUTPUT: «2␤»\n    say $i.pull-one;       # OUTPUT: «3␤»\n    say $i.pull-one.perl;  # OUTPUT: «IterationEnd␤»\n\nAs a more illustrative example of its use, here is a count down iterator\nalong with a simplistic subroutine re-implementation of the for loop.\n\n    # works the same as (10 ... 1, 'lift off')\n    class CountDown does Iterator {\n        has Int:D $!current = 10;\n\n        method pull-one ( --> Mu ) {\n            my $result = $!current--;\n            if $result ==  0 { return 'lift off' }\n            if $result == -1 { return IterationEnd }\n\n            # calling .pull-one again after it returns IterationEnd is undefined\n            if $result <= -2 {\n                # so for fun we will give them nonsense data\n                return (1..10).pick;\n            }\n\n            return $result;\n        }\n    }\n\n    sub for( Iterable:D $sequence, &do --> Nil ) {\n        my Iterator:D $iterator = $sequence.iterator;\n\n        loop {\n            # must bind the result so that =:= works\n            my Mu $pulled := $iterator.pull-one;\n\n            # always check the result and make sure that .pull-one\n            # is not called again after it returns IterationEnd\n            if $pulled =:= IterationEnd { last }\n\n            do( $pulled );\n        }\n    }\n\n    for( Seq.new(CountDown.new), &say );  # OUTPUT: «10␤9␤8␤7␤6␤5␤4␤3␤2␤1␤lift off␤»\n\nIt would be more idiomatic to use while or until, and a sigilless\nvariable.\n\n    until IterationEnd =:= (my \\pulled = $iterator.pull-one) {\n        do( pulled );\n    }","push-exactly\n\nDefined as:\n\n    method push-exactly(Iterator:D: $target, int $count --> Mu)\n\nShould produce $count elements, and for each of them, call\n$target.push($value).\n\nIf fewer than $count elements are available from the iterator, it should\nreturn the sentinel value IterationEnd. Otherwise it should return $count.\n\n    my @array;\n    say (1 .. ∞).iterator.push-exactly(@array, 3); # OUTPUT: «3␤»\n    say @array; # OUTPUT: «[1 2 3]␤»\n\nThe Iterator role implements this method in terms of pull-one. In general,\nthis is a method that is not intended to be called directly from the end\nuser who, instead, should implement it in classes that mix the iterator\nrole. For instance, this class implements that role:\n\n    class DNA does Iterable does Iterator {\n        has $.chain;\n        has Int $!index = 0;\n\n        method new ($chain where {\n                           $chain ~~ /^^ <[ACGT]>+ $$ / and\n                           $chain.chars %% 3 } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator( ){ self }\n\n        method pull-one( --> Mu){\n          if $!index < $.chain.chars {\n             my $codon = $.chain.comb.rotor(3)[$!index div 3];\n             $!index += 3;\n             return $codon;\n          } else {\n            return IterationEnd;\n          }\n        }\n\n        method push-exactly(Iterator:D: $target, int $count --> Mu) {\n            return IterationEnd if $.chain.elems / 3 < $count;\n            for ^($count) {\n                $target.push: $.chain.comb.rotor(3)[ $_ ];\n            }\n        }\n\n    };\n\n    my $b := DNA.new(\"AAGCCT\");\n    for $b -> $a, $b, $c { say \"Never mind\" }; # Does not enter the loop\n    my $þor := DNA.new(\"CAGCGGAAGCCT\");\n    for $þor -> $first, $second {\n        say \"Coupled codons: $first, $second\";\n        # OUTPUT: «Coupled codons: C A G, C G G␤Coupled codons: A A G, C C T␤»\n    }\n\n\nThis code, which groups DNA chains in triplets (usually called codons)\nreturns those codons when requested in a loop; if too many are requested,\nlike in the first case for $b -> $a, $b, $c, it simply does not enter the\nloop since push-exactly will return IterationEnd since it is not able to\nserve the request for exactly 3 codons. In the second case, however, it\nrequests exactly two codons in each iteration of the loop; push-exactly is\nbeing called with the number of loop variables as the $count variable.","push-at-least\n\nDefined as:\n\n    method push-at-least(Iterator:D: $target, int $count --> Mu)\n\nShould produce at least $count elements, and for each of them, call\n$target.push($value).\n\nIf fewer than $count elements are available from the iterator, it should\nreturn the sentinel value IterationEnd. Otherwise it should return $count.\n\nIterators with side effects should produce exactly $count elements;\niterators without side effects (such as Range iterators) can produce more\nelements to achieve better performance.\n\n    my @array;\n    say (1 .. ∞).iterator.push-at-least(@array, 10); # OUTPUT: «10␤»\n    say @array; # OUTPUT: «[1 2 3 4 5 6 7 8 9 10]␤»\n\nThe Iterator role implements this method in terms of pull-one. In general,\nit is also not intended to be called directly as in the example above. It\ncan be implemented, if unhappy with this default implementation, by those\nusing this role. See the documentation for push-exactly for an example\nimplementation.","push-all\n\nDefined as:\n\n    method push-all(Iterator:D: $target)\n\nShould produce all elements from the iterator and push them to $target.\n\n    my @array;\n    say (1 .. 1000).iterator.push-all(@array); # All 1000 values are pushed\n\nThe Iterator role implements this method in terms of push-at-least. As in\nthe case of the other push-* methods, it is mainly intended for developers\nimplementing this role. push-all is called when assigning an object with\nthis role to an array, for instance, like in this example:\n\n    class DNA does Iterable does Iterator {\n        has $.chain;\n        has Int $!index = 0;\n\n        method new ($chain where {\n                           $chain ~~ /^^ <[ACGT]>+ $$ / and\n                           $chain.chars %% 3 } ) {\n            self.bless( :$chain );\n        }\n\n        method iterator( ){ self }\n        method pull-one( --> Mu){\n          if $!index < $.chain.chars {\n             my $codon = $.chain.comb.rotor(3)[$!index div 3];\n             $!index += 3;\n             return $codon;\n          } else {\n            return IterationEnd;\n          }\n        }\n\n        method push-all(Iterator:D: $target) {\n            for $.chain.comb.rotor(3) -> $codon {\n                $target.push: $codon;\n            }\n        }\n\n    };\n\n    my $b := DNA.new(\"AAGCCT\");\n    my @dna-array = $b;\n    say @dna-array; # OUTPUT: «[(A A G) (C C T)]␤»\n\n\nThe push-all method implemented pushes to the target iterator in lists of\nthree aminoacid representations; this is called under the covers when we\nassign $b to @dna-array.","push-until-lazy\n\nDefined as:\n\n    method push-until-lazy(Iterator:D: $target --> Mu)\n\nShould produce values until it considers itself to be lazy, and push them\nonto $target.\n\nThe Iterator role implements this method as a no-op if is-lazy returns a\nTrue value, or as a synonym of push-all if not.\n\nThis matters mostly for iterators that have other iterators embedded, some\nof which might be lazy, while others aren't.","is-lazy\n\nDefined as:\n\n    method is-lazy(Iterator:D: --> Bool:D)\n\nShould return True for iterators that consider themselves lazy, and False\notherwise.\n\nBuilt-in operations that know that they can produce infinitely many values\nreturn True here, for example (1..6).roll(*).\n\n    say (1 .. 100).is-lazy; # OUTPUT: «False␤»\n    say (1 .. ∞).is-lazy; # OUTPUT: «True␤»\n\nThe Iterator role implements this method returning False, indicating a\nnon-lazy iterator.","sink-all\n\nDefined as:\n\n    method sink-all(Iterator:D: --> IterationEnd)\n\nShould exhaust the iterator purely for the side-effects of producing the\nvalues, without actually saving them in any way. Should always return\nIterationEnd. If there are no side-effects associated with producing a\nvalue, then it can be implemented by a consuming class to be a virtual\nno-op.\n\n    say (1 .. 1000).iterator.sink-all;  # OUTPUT: «IterationEnd␤»\n\nThe Iterator role implements this method as a loop that calls pull-one\nuntil it is exhausted.","skip-one\n\nDefined as:\n\n    method skip-one(Iterator:D: $target --> Mu)\n\nShould skip producing one value. The return value should be truthy if the\nskip was successful and falsy if there were no values to be skipped:\n\n    my $i = <a b>.iterator;\n    say $i.skip-one; say $i.pull-one; say $i.skip-one\n    # OUTPUT: «1␤b␤0␤»\n\nThe Iterator role implements this method as a call pull-one and returning\nwhether the value obtained was not IterationEnd.","skip-at-least\n\nDefined as:\n\n    method skip-at-least(Iterator:D: $target, int $to-skip --> Mu)\n\nShould skip producing $to-skip values. The return value should be truthy if\nthe skip was successful and falsy if there were not enough values to be\nskipped:\n\n    my $i = <a b c>.iterator;\n    say $i.skip-at-least(2); say $i.pull-one; say $i.skip-at-least(20);\n    # OUTPUT: «1␤c␤0␤»\n\nThe Iterator role implements this method as a loop calling skip-one and\nreturning whether it returned a truthy value sufficient number of times.","skip-at-least-pull-one\n\nDefined as:\n\n    method skip-at-least-pull-one(Iterator:D: $target, int $to-skip --> Mu)\n\nShould skip producing $to-skip values and if the iterator is still not\nexhausted, produce and return the next value. Should return IterationEnd if\nthe iterator got exhausted at any point:\n\n    my $i = <a b c>.iterator;\n    say $i.skip-at-least-pull-one(2);\n    say $i.skip-at-least-pull-one(20) =:= IterationEnd;\n    # OUTPUT: «c␤True␤»\n\nThe Iterator role implements this method as calling skip-at-least and then\ncalling pull-one if it was not exhausted yet.\n\nPredictive iterators\n\nPlease see the PredictiveIterator role if your Iterator can know how many\nvalues it can still produce without actually producing them."]},{"name":"Instant","methods":["from-posix\n\n    method from-posix($posix, Bool $prefer-leap-second = False)\n\nConverts the POSIX timestamp $posix to an Instant. If $prefer-leap-second\nis True, the return value will be the first of the two possible seconds in\nthe case of a leap second.\n\n    say DateTime.new(Instant.from-posix(915148800, True));  # OUTPUT: «1998-12-31T23:59:60Z␤»\n    say DateTime.new(Instant.from-posix(915148800));        # OUTPUT: «1999-01-01T00:00:00Z␤»","to-posix\n\n    method to-posix()\n\nConverts the invocant to a POSIX timestamp and returns a two element list\ncontaining the POSIX timestamp and a Bool. It is the inverse of #method\nfrom-posix, except that the second return value is True if *and only if*\nthis Instant is in a leap second.\n\n    say DateTime.new(\"1999-01-01T00:00:00Z\").Instant.to-posix; # OUTPUT: «(915148800 False)␤»\n    say DateTime.new('1998-12-31T23:59:60Z').Instant.to-posix; # OUTPUT: «(915148800 True)␤»","Date\n\nDefined as:\n\n    method Date(Instant:D: --> Date:D)\n\nCoerces the invocant to Date.\n\n    my $i = \"/etc/passwd\".IO.modified;\n    say $i;             # OUTPUT: «Instant:1451489025.878018␤»\n    say $i.Date;        # OUTPUT: «2015-12-30␤»","DateTime\n\nDefined as:\n\n    method DateTime(Instant:D: --> DateTime:D)\n\nCoerces the invocant to DateTime.\n\n    say now.DateTime;  # OUTPUT: «2017-05-09T14:02:58.147165Z␤»"],"desc":"TITLE\nclass Instant\n\nSUBTITLE\nSpecific moment in time\n\n    class Instant is Cool does Real { }\n\nAn Instant is a particular moment in time measured in atomic seconds, with\nfractions. It is not tied to or aware of any epoch.\n\nAn Instant can be used to create a DateTime object set to that Instant. The\npseudo-constant now returns the current time as an Instant.\n\nBasic math is defined for Instants (as well as Durations). Adding an\nInstant to a Duration returns another Instant. Subtracting two Instants\nwill yield a Duration. Adding two Instants is explicitly disallowed. All\nother operations with Instants are undefined.\n\nFuture Leap Seconds\n\nThe methods that involve knowledge of leap seconds always assume that there\nwill be no further leaps after the last leap second that the implementation\nknows about, which may not be the last leap second that has actually been\nscheduled. This means you can get different results, depending on the\ncompiler version you're using. For example, the December 31, 2016 leap\nsecond was announced in July and shipped with Rakudo 2016.07, so 2016.06\nand earlier releases won't know about it:\n\n    $ perl6-2016.06 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726631\n\n    $ perl6-2016.07 -e 'say Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\nSince a Rakudo compiler always returns 0 for future leap seconds it doesn't\nknow about, you can patch your old code when new leap seconds are\nannounced, so it will give correct results, regardless of what version of\nthe compiler it runs on:\n\n    $ perl6-2016.06 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n    $ perl6-2016.07 -e 'say ($*VM.version before v2016.07 ?? 1 !! 0) + Instant.from-posix: 1485726595'\n    Instant:1485726632\n\n\n"},{"name":"Mixy","methods":["total\n\n    method total(--> Real)\n\nReturns the sum of all the weights\n\n    say mix('a', 'b', 'c', 'a', 'a', 'd').total == 6;  # OUTPUT: «True␤»\n    say %(a => 5.6, b => 2.4).Mix.total == 8;          # OUTPUT: «True␤»","roll\n\n    method roll($count = 1)\n\nSimilar to a Bag.roll, but with Real weights rather than integral ones.\n\nSee Also\n\nSets, Bags, and Mixes"],"desc":"TITLE\nrole Mixy\n\nSUBTITLE\nCollection of distinct objects with Real weights\n\n    role Mixy does Baggy { }\n\nA role for collections of weighted values. See Mix and MixHash. Mixy\nobjects differ from Baggy objects in that the weights of Mixy are Reals\nrather than Ints.\n\n"},{"methods":[],"desc":"TITLE\nclass CurrentThreadScheduler\n\nSUBTITLE\nScheduler that synchronously executes code on the current thread\n\n    class CurrentThreadScheduler does Scheduler {}\n\n\nCurrentThreadScheduler executes tasks on the current threads. This means\nthat method cue blocks until the code has finished executing.","name":"CurrentThreadScheduler"},{"name":"Signature","methods":["params\n\n    method params(Signature:D: --> Positional)\n\nReturns the list of Parameter objects that make up the signature.","arity\n\n    method arity(Signature:D: --> Int:D)\n\nReturns the minimal number of positional arguments required to satisfy the\nsignature.","count\n\n    method count(Signature:D: --> Real:D)\n\nReturns the maximal number of positional arguments which can be bound to\nthe signature. Returns Inf if there is a slurpy positional parameter.","returns\n\nWhatever the Signature's return constraint is:\n\n    :($a, $b --> Int).returns # OUTPUT: «(Int)»","ACCEPTS\n\n    multi method ACCEPTS(Signature:D: Signature $topic)\n    multi method ACCEPTS(Signature:D: Capture $topic)\n    multi method ACCEPTS(Signature:D: Mu \\topic)\n\nIf $topic is a Signature returns True if anything accepted by $topic would\nalso be accepted by the invocant, otherwise returns False:\n\n    :($a, $b) ~~ :($foo, $bar, $baz?);   # OUTPUT: «True»\n    :(Int $n) ~~ :(Str);                 # OUTPUT: «False»\n\nThe $topic is a Capture, returns True if it can be bound to the invocant,\ni.e., if a function with invocant's Signature would be able to be called\nwith the $topic:\n\n    \\(1, 2, :foo) ~~ :($a, $b, :foo($bar)); # OUTPUT: «True»\n    \\(1, :bar)    ~~ :($a);                 # OUTPUT: «False»\n\nLastly, the candidate with Mu \\topic converts topic to Capture and follows\nthe same semantics as Capture $topic:\n\n    <a b c d>  ~~ :(Int $a);      # OUTPUT: «False»\n    42         ~~ :(Int);         # OUTPUT: «False» (Int.Capture throws)\n    set(<a b>) ~~ :(:$a, :$b);    # OUTPUT: «True»\n\nSince where clauses are not introspectable, the method cannot determine\nwhether two signatures ACCEPTS the same sort of where-constrained\nparameters. Such comparisons will return False. This includes signatures\nwith literals, which are just sugar for the where-constraints:\n\n    say :(42) ~~ :($ where 42)    # OUTPUT: «False␤»","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.\n\nRuntime creation of Signature objects (6.d, 2019.03 and later)\n\n    Signature.new(params => (...), returns => Type, arity => 1, count => 1)\n\n\nIn some situations, specifically when working with the MetaObject Protocol,\nit makes sense to create Signature objects programmatically. For this\npurpose, you can call the new method with the following named parameters:\n\n  * params\n\nA list of Parameter objects for this signature.\n\n  * returns\n\nAny constraint the return value should match. Defaults to Mu, which\neffectively implies no return value constraint check.\n\n  * arity\n\nThe minimal number of positional arguments required to satisfy the\nsignature. Defaults to the number of Parameter objects given with the\nparams parameter.\n\n  * count\n\nThe maximal number of positional arguments which can be bound to the\nsignature. Defaults to the arity if not specified. Specify Inf if there is\na slurpy positional parameter."],"desc":"TITLE\nclass Signature\n\nSUBTITLE\nParameter list pattern\n\n    class Signature { }\n\nA signature is a static description of the parameter list of a code object.\nThat is, it describes what and how many arguments you need to pass to the\ncode or function in order to call it.\n\nPassing arguments to a signature binds the arguments, contained in a\nCapture, to the signature.\n\n \n\nSignature literals\n\nSignatures appear inside parentheses after subroutine and method names, on\nblocks after a ->  or <->  arrow, as the input to variable declarators like\nmy, or as a separate term starting with a colon.\n\n    sub f($x) { }\n    #    ^^^^ Signature of sub f\n    my method x() { }\n    #          ^^ Signature of a method\n    my $s = sub (*@a) { }\n    #           ^^^^^ Signature of an anonymous function\n\n    for <a b c> -> $x { }\n    #              ^^   Signature of a Block\n\n    my ($a, @b) = 5, (6, 7, 8);\n    #  ^^^^^^^^ Signature of a variable declarator\n\n    my $sig = :($a, $b);\n    #          ^^^^^^^^ Standalone Signature object\n\nSignature literals can be used to define the signature of a callback or a\nclosure.\n\n    sub f(&c:(Int)) { }\n    sub will-work(Int) { }\n    sub won't-work(Str) { }\n    f(&will-work);\n\n    f(&won't-work);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding::Parameter: Constraint type check failed in binding to parameter '&c'␤»\n\n    f(-> Int { 'this works too' } );\n\nSmartmatching signatures against a List is supported.\n\n    my $sig = :(Int $i, Str $s);\n    say (10, 'answer') ~~ $sig;\n    # OUTPUT: «True␤»\n    my $sub = sub ( Str $s, Int $i ) { return $s xx $i };\n    say $sub.signature ~~ :( Str, Int );\n    # OUTPUT: «True␤»\n    given $sig {\n        when :(Str, Int) { say 'mismatch' }\n        when :($, $)     { say 'match' }\n        default          { say 'no match' }\n    }\n    # OUTPUT: «match␤»\n\nIt matches the second when clause since :($, $) represents a Signature with\ntwo scalar, anonymous, arguments, which is a more general version of $sig.\n\nWhen smartmatching against a Hash, the signature is assumed to consist of\nthe keys of the Hash.\n\n    my %h = left => 1, right => 2;\n    say %h ~~ :(:$left, :$right);\n    # OUTPUT: «True␤»\n\nSignature literals can contain string/numeric literals\n\n    my $sig = :('Þor', Str, Int);\n    say <Þor Hammer 1> ~~ $sig; # OUTPUT: «True␤»\n\nAnd they can also contain the invocant marker\n\n    class Foo {\n        method bar( $self: ){ \"baz\" }\n    };\n    say Foo.^methods.first(*.name eq 'bar').signature ~~ :($: *%) ;\n    # OUTPUT: «True␤»\n\n  Parameter separators\n\nA signature consists of zero or more parameters, separated by commas.\n\n    my $sig = :($a, @b, %c);\n    sub add($a, $b) { $a + $b };\n\nAs an exception the first parameter may be followed by a colon instead of a\ncomma to mark the invocant of a method. The invocant is the object that was\nused to call the method, which is usually bound to self. By specifying it\nin the signature, you can change the variable name it is bound to.\n\n    method ($a: @b, %c) {};       # first argument is the invocant\n\n    class Foo {\n        method whoami($me:) {\n            \"Well I'm class $me.^name(), of course!\"\n        }\n    }\n    say Foo.whoami; # OUTPUT: «Well I'm class Foo, of course!␤»\n\n \n\n  Type constraints\n\nParameters can optionally have a type constraint (the default is Any).\nThese can be used to restrict the allowed input to a function.\n\n    my $sig = :(Int $a, Str $b);\n\n\nType constraints can have any compile-time defined value\n\n    subset Positive-integer of Int where * > 0;\n    sub divisors(Positive-integer $n) { $_ if $n %% $_ for 1..$n };\n    divisors 2.5;\n    # ERROR «Type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Rat (2.5) $n)»\n    divisors -3;\n    # ERROR: «Constraint type check failed in binding to parameter '$n';\n    # expected Positive-integer but got Int (-3)»\n\n\nPlease note that in the code above type constraints are enforced at two\ndifferent levels: the first level checks if it belongs to the type in which\nthe subset is based, in this case Int. If it fails, a Type check error is\nproduced. Once that filter is cleared, the constraint that defined the\nsubset is checked, producing a Constraint type check error if it fails.\n\n Anonymous arguments are fine too, if you don't actually need to refer to a\nparameter by name, for instance to distinguish between different signatures\nin a multi or to check the signature of a Callable.\n\n    my $sig = :($, @, %a);          # two anonymous and a \"normal\" parameter\n    $sig = :(Int, Positional);      # just a type is also fine (two parameters)\n    sub baz(Str) { \"Got passed a Str\" }\n\nType constraints may also be type captures.\n\n In addition to those nominal types, additional constraints can be placed\non parameters in the form of code blocks which must return a true value to\npass the type check\n\n    sub f(Real $x where { $x > 0 }, Real $y where { $y >= $x }) { }\n\nThe code in where clauses has some limitations: anything that produces\nside-effects (e.g., printing output, pulling from an iterator, or\nincreasing a state variable) is not supported and may produce surprising\nresults if used. Also, the code of the where clause may run more than once\nfor a single typecheck in some implementations.\n\nThe where clause doesn't need to be a code block, anything on the right of\nthe where-clause will be used to smartmatch the argument against it. So you\ncan also write:\n\n    multi factorial(Int $ where 0) { 1 }\n    multi factorial(Int $x)        { $x * factorial($x - 1) }\n\nThe first of those can be shortened to\n\n    multi factorial(0) { 1 }\n\ni.e., you can use a literal directly as a type and value constraint on an\nanonymous parameter.\n\nTip: pay attention to not accidentally leave off a block when you, say,\nhave several conditions:\n\n    -> $y where   .so && .name    {}( sub one   {} ); # WRONG!!\n    -> $y where { .so && .name }  {}( sub two   {} ); # OK!\n    -> $y where   .so &  .name.so {}( sub three {} ); # Also good\n\nThe first version is wrong and will issue a warning about a sub object\ncoerced to string. The reason is the expression is equivalent to ($y ~~\n($y.so && $y.name)); that is \"call .so, and if that is True, call .name; if\nthat is also True use its value for smartmatching…\". It's the result of\n(.so && .name) it will be smartmatched against, but we want to check that\nboth .so and .name are truthy values. That is why an explicit Block or a\nJunction is the right version.\n\nAll previous arguments that are not part of a sub-signature in a Signature\nare accessible in a where-clause that follows an argument. Therefore, the\nwhere-clause of the last argument has access to all arguments of a\nsignature that are not part of a sub-signature. For a sub-signature place\nthe where-clause inside the sub-signature.\n\n    sub foo($a, $b where * == $a ** 2) { say \"$b is a square of $a\" }\n    foo 2, 4; # OUTPUT: «4 is a square of 2␤»»\n    # foo 2, 3;\n    # OUTPUT: «Constraint type check failed in binding to parameter '$b'…»\n\n    Constraining optional arguments\n\nOptional arguments can have constraints, too. Any where clause on any\nparameter will be executed, even if it's optional and not provided by the\ncaller. In that case you may have to guard against undefined values within\nthe where clause.\n\n    sub f(Int $a, UInt $i? where { !$i.defined or $i > 5 }) { ... }\n\n    Constraining slurpy arguments\n\nSlurpy arguments can not have type constraints. A where-clause in\nconjunction with a Junction can be used to that effect.\n\n    sub f(*@a where {$_.all ~~ Int}) { say @a };\n    f(42);\n    f(<a>);\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «[42]␤Constraint type check failed in binding to parameter '@a' ...»\n\n\n    Constraining named arguments\n\nConstraints against Named arguments apply to the value part of the\ncolon-pair.\n\n    sub f(Int :$i){};\n    f :i<forty-two>;\n    CATCH { default { say .^name, ' ==> ', .Str }  }\n    # OUTPUT: «X::TypeCheck::Binding::Parameter ==> Type check failed in\n    # binding to parameter '$i'; expected Int but got Str (\"forty-two\")␤»\n\n  \n\n    Constraining argument definiteness\n\nNormally, a type constraint only checks whether the value of the parameter\nis of the correct type. Crucially, both object instances and type objects\nwill satisfy such a constraint as illustrated below:\n\n    say  42.^name;    # OUTPUT: «Int␤»\n    say  42 ~~ Int;   # OUTPUT: «True␤»\n    say Int ~~ Int;   # OUTPUT: «True␤»\n\nNote how both 42 and Int satisfy the match.\n\nSometimes we need to distinguish between these object instances (42) and\ntype objects (Int). Consider the following code:\n\n    sub limit-lines(Str $s, Int $limit) {\n        my @lines = $s.lines;\n        @lines[0 .. min @lines.elems, $limit].join(\"\\n\")\n    }\n    say (limit-lines \"a \\n b \\n c \\n d \\n\", 3).perl; # \"a \\n b \\n c \\n d \"\n    say limit-lines Str, 3;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller lines(Str: );\n    # none of these signatures match:\n    #     (Str:D $: :$count!, *%_)\n    #     (Str:D $: $limit, *%_)\n    #     (Str:D $: *%_)»\n    say limit-lines \"a \\n b\", Int; # Always returns the max number of lines\n\nHere we really only want to deal with string instances, not type objects.\nTo do this, we can use the :D type constraint. This constraint checks that\nthe value passed is an object instance, in a similar fashion to calling its\nDEFINITE (meta)method.\n\nTo warm up, let's apply :D to the right-hand side of our humble Int\nexample:\n\n    say  42 ~~ Int:D;  # OUTPUT: «True␤»\n    say Int ~~ Int:D;  # OUTPUT: «False␤»\n\nNote how only 42 matches Int:D in the above.\n\nReturning to limit-lines, we can now amend its signature to catch the error\nearly:\n\n    sub limit-lines(Str:D $s, Int $limit) { };\n    say limit-lines Str, 3;\n    CATCH { default { put .^name ~ '--' ~ .Str } };\n    # OUTPUT: «Parameter '$s' of routine 'limit-lines' must be an object instance of type 'Str',\n    #          not a type object of type 'Str'.  Did you forget a '.new'?»\n\nThis is much better than the way the program failed before, since here the\nreason for failure is clearer.\n\nIt's also possible that type objects are the only ones that make sense for\na routine to accept. This can be done with the :U type constraint, which\nchecks whether the value passed is a type object rather than an object\ninstance. Here's our Int example again, this time with :U applied:\n\n    say  42 ~~ Int:U;  # OUTPUT: «False␤»\n    say Int ~~ Int:U;  # OUTPUT: «True␤»\n\nNow 42 fails to match Int:U while Int succeeds.\n\nHere's a more practical example:\n\n    sub can-turn-into(Str $string, Any:U $type) {\n       return so $string.$type;\n    }\n    say can-turn-into(\"3\", Int);        # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Int);      # OUTPUT: «True␤»\n    say can-turn-into(\"6.5\", Num);      # OUTPUT: «True␤»\n    say can-turn-into(\"a string\", Num); # OUTPUT: «False␤»\n\nCalling can-turn-into with an object instance as its second parameter will\nyield a constraint violation as intended:\n\n    say can-turn-into(\"a string\", 123);\n    # OUTPUT: «Parameter '$type' of routine 'can-turn-into' must be a type object\n    # of type 'Any', not an object instance of type 'Int'...»\n\n\nFor explicitly indicating the normal behavior, that is, not constraining\nwhether the argument will be an instance or a type object, :_ can be used,\nbut this is unnecessary. :(Num:_ $) is the same as :(Num $).\n\nTo recap, here is a quick illustration of these type constraints, also\nknown collectively as type smileys:\n\n    # Checking a type object\n    say Int ~~ Any:D;    # OUTPUT: «False␤»\n    say Int ~~ Any:U;    # OUTPUT: «True␤»\n    say Int ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an object instance\n    say 42 ~~ Any:D;     # OUTPUT: «True␤»\n    say 42 ~~ Any:U;     # OUTPUT: «False␤»\n    say 42 ~~ Any:_;     # OUTPUT: «True␤»\n\n    # Checking a user-supplied class\n    class Foo {};\n    say Foo ~~ Any:D;    # OUTPUT: «False␤»\n    say Foo ~~ Any:U;    # OUTPUT: «True␤»\n    say Foo ~~ Any:_;    # OUTPUT: «True␤»\n\n    # Checking an instance of a class\n    my $f = Foo.new;\n    say $f  ~~ Any:D;    # OUTPUT: «True␤»\n    say $f  ~~ Any:U;    # OUTPUT: «False␤»\n    say $f  ~~ Any:_;    # OUTPUT: «True␤»\n\nThe Classes and Objects document further elaborates on the concepts of\ninstances and type objects and discovering them with the .DEFINITE method.\n\nKeep in mind all parameters have values; even optional ones have default\nvalues that are the type object of the constrained type for explicit type\nconstraints. If no explicit type constraint exists, the default value is an\nAny type object for methods, submethods, and subroutines, and a Mu type\nobject for blocks. This means that if you use the :D type smiley, you'd\nneed to provide a default value or make the parameter required. Otherwise,\nthe default value would be a type object, which would fail the definiteness\nconstraint.\n\n    sub divide (Int:D :$a = 2, Int:D :$b!) { say $a/$b }\n    divide :1a, :2b; # OUTPUT: «0.5␤»\n\nThe default value will kick in when that particular parameter, either\npositional or named, gets no value at all.\n\n    sub f($a = 42){\n      my $b is default('answer');\n      say $a;\n      $b = $a;\n      say $b\n    };\n    f;     # OUTPUT: «42␤42␤»\n    f Nil; # OUTPUT: «Nil␤answer␤»\n\n$a has 42 as its default value. With no value, $a will be assigned the\ndefault value declared in the Signature. However, in the second case, it\ndoes receive a value, which happens to be Nil. Assigning Nil to any\nvariable resets it to its default value, which has been declared as\n'answer' by use of the default trait. That explains what happens the second\ntime we call f. Routine parameters and variables deal differently with\ndefault value, which is in part clarified by the different way default\nvalues are declared in each case (using = for parameters, using the default\ntrait for variables).\n\nNote: in 6.c language, the default value of :U/:D constrained variables was\na type object with such a constraint, which is not initializable, thus you\ncannot use the .= operator, for example.\n\n    use v6.c;\n    my Int:D $x .= new: 42;\n    # OUTPUT: You cannot create an instance of this type (Int:D)\n    # in block <unit> at -e line 1\n\n\nIn the 6.d language, the default default is the type object without the\nsmiley constraint:\n\n    use v6.d;\n    my Int:D $x .= new: 42; # OUTPUT: «42␤»\n\n\nA closing remark on terminology: this section is about the use of the type\nsmileys :D and :U to constrain the definiteness of arguments. Occasionally\ndefinedness is used as a synonym for definiteness; this may be confusing,\nsince the terms have subtly different meanings.\n\nAs explained above, definiteness is concerned with the distinction between\ntype objects and object instances. A type object is always indefinite,\nwhile an object instance is always definite. Whether an object is a type\nobject/indefinite or an object instance/definite can be verified using the\nDEFINITE (meta)method.\n\nDefiniteness should be distinguished from definedness, which is concerned\nwith the difference between defined and undefined objects. Whether an\nobject is defined or undefined can be verified using the defined-method,\nwhich is implemented in class Mu. By default a type object is considered\nundefined, while an object instance is considered defined; that is:\n.defined returns False on a type object, and True otherwise. But this\ndefault behavior may be overridden by subclasses. An example of a subclass\nthat overrides the default .defined behavior is Failure, so that even an\ninstantiated Failure acts as an undefined value:\n\n    my $a = Failure;                # Initialize with type object\n    my $b = Failure.new(\"foo\");     # Initialize with object instance\n    say $a.DEFINITE;                # Output: «False␤» : indefinite type object\n    say $b.DEFINITE;                # Output: «True␤»  : definite object instance\n    say $a.defined;                 # Output: «False␤» : default response\n    say $b.defined;                 # Output: «False␤» : .defined override\n\n    Constraining signatures of Callables\n\nThe signature of a Callable parameter can be constrained by specifying a\nSignature literal right after the parameter (no whitespace allowed):\n\n    sub f(&c:(Int, Str))  { say c(10, 'ten') };\n    sub g(Int $i, Str $s) { $s ~ $i };\n    f(&g);\n    # OUTPUT: «ten10␤»\n\nThis shorthand syntax is available only for parameters with the & sigil.\nFor others, you need to use the long version:\n\n    sub f($c where .signature ~~ :(Int, Str))  { say $c(10, 'ten') }\n    sub g(Num $i, Str $s) { $s ~ $i }\n    sub h(Int $i, Str $s) { $s ~ $i }\n    # f(&g); # Constraint type check failed\n    f(&h);   # OUTPUT: «ten10␤»\n\n    Constraining return types\n\nThere are multiple ways to constrain return types on a Routine. All\nversions below are currently valid and will force a type check on\nsuccessful execution of a routine.\n\nNil and Failure are always allowed as return types, regardless of any type\nconstraint. This allows Failure to be returned and passed on down the call\nchain.\n\n    sub foo(--> Int) { Nil };\n    say foo.perl; # OUTPUT: «Nil␤»\n\nType captures are not supported.\n\n \n\n    Return type arrow: -->\n\nThis form of indicating return types (or constants) in the signature is\npreferred, since it can handle constant values while the others can't. For\nconsistency, it is the only form accepted on this site.\n\nThe return type arrow has to be placed at the end of the parameter list,\nwith or without a , before it.\n\n    sub greeting1(Str $name  --> Str) { say \"Hello, $name\" } # Valid\n    sub greeting2(Str $name, --> Str) { say \"Hello, $name\" } # Valid\n\n    sub favorite-number1(--> 42) {        } # OUTPUT: 42\n    sub favorite-number2(--> 42) { return } # OUTPUT: 42\n\n\nIf the type constraint is a constant expression, it is used as the return\nvalue of the routine. Any return statement in that routine has to be\nargumentless.\n\n    sub foo(Str $word --> 123) { say $word; return; }\n    my $value = foo(\"hello\"); # OUTPUT: hello\n    say $value;               # OUTPUT: 123\n\n\n    # The code below will not compile\n    sub foo(Str $word --> 123) { say $word; return $word; }\n    my $value = foo(\"hello\");\n    say $value;\n\n\n    returns\n\nThe keyword returns following a signature declaration has the same function\nas --> with the caveat that this form does not work with constant values.\nYou cannot use it in a block either. That is why the pointy arrow form is\nalways preferred.\n\n    sub greeting(Str $name) returns Str { say \"Hello, $name\" } # Valid\n\n\n    sub favorite-number returns 42 {        } # This will fail.\n\n\n    of\n\nof is just the real name of the returns keyword.\n\n    sub foo() of Int { 42 }; # Valid\n\n\n    sub foo() of 42 {  };    # This will fail.\n\n\n    prefix(C-like) form\n\nThis is similar to placing type constraints on variables like my Type $var\n= 20;, except the $var is a definition for a routine.\n\n    my Int sub bar { 1 };     # Valid\n\n\n    my 42 sub bad-answer {};  # This will fail.\n\n\n    Coercion type\n\nTo accept one type but coerce it automatically to another, use the accepted\ntype as an argument to the target type. If the accepted type is Any it can\nbe omitted.\n\n    sub f(Int(Str) $want-int, Str() $want-str) {\n        say $want-int.^name ~ ' ' ~ $want-str.^name\n    }\n    f '10', 10;\n    # OUTPUT: «Int Str␤»\n\n    use MONKEY;\n    augment class Str { method Date() { Date.new(self) } };\n    sub foo(Date(Str) $d) { say $d.^name; say $d };\n    foo \"2016-12-01\";\n    # OUTPUT: «Date␤2016-12-01␤»\n\nThe coercion is performed by calling the method with the name of the type\nto coerce to, if it exists (e.g. Foo(Bar) coercer, would call method Foo).\nThe method is assumed to return the correct type—no additional checks on\nthe result are currently performed.\n\nCoercion can also be performed on return types:\n\n    sub square-str (Int $x --> Str(Int)) {\n        $x²\n    }\n\n    for 2,4, *²  … 256 -> $a {\n        say $a, \"² is \", square-str( $a ).chars, \" figures long\";\n    }\n\n    # OUTPUT: «2² is 1 figures long␤\n    #          4² is 2 figures long␤\n    #          16² is 3 figures long␤\n    #          256² is 5 figures long␤»\n\n\nIn this example, coercing the return type to String allows us to directly\napply string methods, such as the number of characters.\n\n  \n\n  Slurpy (A.K.A. variadic) parameters\n\nA function is variadic if it can take a varying number of arguments; that\nis, its arity is not fixed. Therefore, optional, named, and slurpy\nparameters are variadic. An array or hash parameter can be marked as slurpy\nby leading single (*) or double asterisk (**) or a leading plus (+). A\nslurpy parameter can bind to an arbitrary number of arguments (zero or\nmore), and it will result in a type that is compatible with the sigil.\n\nThese are called \"slurpy\" because they slurp up any remaining arguments to\na function, like someone slurping up noodles.\n\n    $ = :($a, @b);  # exactly two arguments, where the second one must be Positional\n    $ = :($a, *@b); # at least one argument, @b slurps up any beyond that\n    $ = :(*%h);     # no positional arguments, but any number of named arguments\n\n    sub one-arg (@)  { }\n    sub slurpy  (*@) { }\n    one-arg (5, 6, 7); # ok, same as one-arg((5, 6, 7))\n    slurpy  (5, 6, 7); # ok\n    slurpy   5, 6, 7 ; # ok\n    # one-arg(5, 6, 7) ; # X::TypeCheck::Argument\n    # one-arg  5, 6, 7 ; # X::TypeCheck::Argument\n\n    sub named-names (*%named-args) { %named-args.keys };\n    say named-names :foo(42) :bar<baz>; # OUTPUT: «foo bar␤»\n\n\nPositional and named slurpies can be combined; named arguments (i.e.,\nPairs) are collected in the specified hash, positional arguments in the\narray:\n\n    sub combined-slurpy (*@a, *%h) { { array => @a, hash => %h } }\n    # or: sub combined-slurpy (*%h, *@a) { ... }\n\n    say combined-slurpy(one => 1, two => 2);\n    # OUTPUT: «{array => [], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4);\n    # OUTPUT: «{array => [3 4], hash => {one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5);\n    # OUTPUT: «{array => [3 4], hash => {five => 5, one => 1, two => 2}}␤»\n    say combined-slurpy(one => 1, two => 2, 3, 4, five => 5, 6);\n    # OUTPUT: «{array => [3 4 6], hash => {five => 5, one => 1, two => 2}}␤»\n\n\nNote that positional parameters aren't allowed after slurpy parameters:\n\n    :(*@args, $last);\n    # ===SORRY!=== Error while compiling:\n    # Cannot put required parameter $last after variadic parameters\n\n\nNormally a slurpy parameter will create an Array (or compatible type),\ncreate a new Scalar container for each argument, and assign the value from\neach argument to those Scalars. If the original argument also had an\nintermediary Scalar it is bypassed during this process, and is not\navailable inside the called function.\n\nSigiled parameters will always impose a context on the collected arguments.\nSigilless parameters can also be used slurpily, preceded by a + sign, to\nwork with whatever initial type they started with:\n\n    sub zipi( +zape ) {\n        zape.^name => zape\n    };\n    say zipi( \"Hey \"); # OUTPUT: «List => (Hey )␤»\n    say zipi( 1...* ); # OUTPUT: «Seq => (...)␤»\n\n\nSlurpy parameters have special behaviors when combined with some traits and\nmodifiers, as described in the section on slurpy array parameters.\n\n  Types of slurpy array parameters\n\nThere are three variations to slurpy array parameters.\n\n  * The single asterisk form flattens passed arguments.\n\n  * The double asterisk form does not flatten arguments.\n\n  * The plus form flattens according to the single argument rule.\n\nEach will be described in detail in the next few sections. As the\ndifference between each is a bit nuanced, examples are provided for each to\ndemonstrate how each slurpy convention varies from the others.\n\n    Flattened slurpy\n\nSlurpy parameters declared with one asterisk will flatten arguments by\ndissolving one or more layers of bare Iterables.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub a(*@a)  { @a.perl.say };\n    a(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]»\n    a(1, $list, [2, 3]);       # OUTPUT: «[1, \"d\", \"e\", \"f\", 2, 3]»\n    a([1, 2]);                 # OUTPUT: «[1, 2]»\n    a(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, 1, 2, 3, 4, 5]»\n    a(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]»\n\n\nA single asterisk slurpy flattens all given iterables, effectively hoisting\nany object created with commas up to the top level.\n\n    Unflattened slurpy\n\nSlurpy parameters declared with two stars do not flatten any Iterable\narguments within the list, but keep the arguments more or less as-is:\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub b(**@b) { @b.perl.say };\n    b(@array);                 # OUTPUT: «[[\"a\", \"b\", \"c\"],]␤»\n    b(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    b([1, 2]);                 # OUTPUT: «[[1, 2],]␤»\n    b(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    b(($_ for 1, 2, 3));       # OUTPUT: «[(1, 2, 3),]␤»\n\n\nThe double asterisk slurpy hides the nested comma objects and leaves them\nas-is in the slurpy array.\n\n    Single argument rule slurpy\n\nA slurpy parameter created using a plus engages the \"single argument rule\",\nwhich decides how to handle the slurpy argument based upon context.\nBasically, if only a single argument is passed and that argument is\nIterable, that argument is used to fill the slurpy parameter array. In any\nother case, +@ works like **@.\n\n    my @array = <a b c>;\n    my $list := <d e f>;\n    sub c(+@b) { @b.perl.say };\n    c(@array);                 # OUTPUT: «[\"a\", \"b\", \"c\"]␤»\n    c(1, $list, [2, 3]);       # OUTPUT: «[1, (\"d\", \"e\", \"f\"), [2, 3]]␤»\n    c([1, 2]);                 # OUTPUT: «[1, 2]␤»\n    c(1, [1, 2], ([3, 4], 5)); # OUTPUT: «[1, [1, 2], ([3, 4], 5)]␤»\n    c(($_ for 1, 2, 3));       # OUTPUT: «[1, 2, 3]␤»\n\n\nFor additional discussion and examples, see Slurpy Conventions for\nFunctions.\n\n  Type captures\n\nType captures allow deferring the specification of a type constraint to the\ntime the function is called. They allow referring to a type both in the\nsignature and the function body.\n\n    sub f(::T $p1, T $p2, ::C){\n        # $p1 and $p2 are of the same type T, that we don't know yet\n        # C will hold a type we derive from a type object or value\n        my C $division = $p1 / $p2;\n        return sub (T $p1) {\n            $division * $p1;\n        }\n    }\n\n    # The first parameter is Int and so must be the 2nd.\n    # We derive the 3rd type from calling the operator that is used in &f.\n    my &s = f(10, 2, Int.new / Int.new);\n    say s(2); # 10 / 2 * 2 == 10\n\n \n\n  Positional vs. named arguments\n\nAn argument can be positional or named. By default, arguments are\npositional, except slurpy hash and arguments marked with a leading colon :.\nThe latter is called a colon-pair. Check the following signatures and what\nthey denote:\n\n    $ = :($a);               # a positional argument\n    $ = :(:$a);              # a named argument of name 'a'\n    $ = :(*@a);              # a slurpy positional argument\n    $ = :(*%h);              # a slurpy named argument\n\nOn the caller side, positional arguments are passed in the same order as\nthe arguments are declared.\n\n    sub pos($x, $y) { \"x=$x y=$y\" }\n    pos(4, 5);                          # OUTPUT: «x=4 y=5»\n\nIn the case of named arguments and parameters, only the name is used for\nmapping arguments to parameters. If a fat arrow is used to construct a Pair\nonly those with valid identifiers as keys are recognized as named\narguments.\n\n    sub named(:$x, :$y) { \"x=$x y=$y\" }\n    named( y => 5, x => 4);             # OUTPUT: «x=4 y=5»\n\n\nYou can invoke the routine using a variable with the same name as the named\nargument; in that case : will be used for the invocation so that the name\nof the variable is understood as the key of the argument.\n\n    sub named-shortcut( :$shortcut ) {\n        say \"Looks like $shortcut\"\n    }\n    named-shortcut( shortcut => \"to here\"); # OUTPUT: «Looks like to here␤»\n    my $shortcut = \"Þor is mighty\";\n    named-shortcut( :$shortcut );           # OUTPUT: «Looks like Þor is mighty␤»\n\nIt is possible to have a different name for a named argument than the\nvariable name:\n\n    sub named(:official($private)) { \"Official business!\" if $private }\n    named :official;\n\n  Argument aliases\n\nThe colon-pair syntax can be used to provide aliases for arguments:\n\n    sub alias-named(:color(:$colour), :type(:class($kind))) {\n        say $colour ~ \" \" ~ $kind\n    }\n    alias-named(color => \"red\", type => \"A\");    # both names can be used\n    alias-named(colour => \"green\", type => \"B\"); # more than two names are ok\n    alias-named(color => \"white\", class => \"C\"); # every alias is independent\n\nThe presence of the colon : will decide whether we are creating a new named\nargument or not. :$colour will not only be the name of the aliased\nvariable, but also a new named argument (used in the second invocation).\nHowever, $kind will just be the name of the aliased variable, that does not\ncreate a new named argument. More uses of aliases can be found in sub\nMAIN.\n\nA function with named arguments can be called dynamically, dereferencing a\nPair with | to turn it into a named argument.\n\n    multi f(:$named) { note &?ROUTINE.signature };\n    multi f(:$also-named) { note &?ROUTINE.signature };\n    for 'named', 'also-named' -> $n {\n        f(|($n => rand))                # OUTPUT: «(:$named)␤(:$also-named)␤»\n    }\n\n    my $pair = :named(1);\n    f |$pair;                           # OUTPUT: «(:$named)␤»\n\nThe same can be used to convert a Hash into named arguments.\n\n    sub f(:$also-named) { note &?ROUTINE.signature };\n    my %pairs = also-named => 4;\n    f |%pairs;                              # OUTPUT: «(:$also-named)␤»\n\nA Hash that contains a list may prove problematic when slipped into named\narguments. To avoid the extra layer of containers coerce to Map before\nslipping.\n\n    class C { has $.x; has $.y; has @.z };\n    my %h = <x y z> Z=> (5, 20, [1,2]);\n    say C.new(|%h.Map);\n    # OUTPUT: «C.new(x => 5, y => 20, z => [1, 2])␤»\n\nYou can create as many aliases to a named argument as you want:\n\n    sub alias-named(:color(:$colour),\n                    :variety(:style(:sort(:type(:class($kind)))))) {\n        return $colour ~ \" \" ~ $kind\n    }\n    say alias-named(color => \"red\", style => \"A\");\n    say alias-named(colour => \"green\", variety => \"B\");\n    say alias-named(color => \"white\", class => \"C\");\n\n\n  Optional and mandatory arguments\n\nPositional parameters are mandatory by default, and can be made optional\nwith a default value or a trailing question mark:\n\n    $ = :(Str $id);         # required parameter\n    $ = :($base = 10);      # optional parameter, default value 10\n    $ = :(Int $x?);         # optional parameter, default is the Int type object\n\n Named parameters are optional by default, and can be made mandatory with a\ntrailing exclamation mark:\n\n    $ = :(:%config);        # optional parameter\n    $ = :(:$debug = False); # optional parameter, defaults to False\n    $ = :(:$name!);         # mandatory 'name' named parameter\n\nDefault values can depend on previous parameters, and are (at least\nnotionally) computed anew for each call\n\n    $ = :($goal, $accuracy = $goal / 100);\n    $ = :(:$excludes = ['.', '..']);        # a new Array for every call\n\n  Dynamic variables\n\nDynamic variables are allowed in signatures although they don't provide\nspecial behavior because argument binding does connect two scopes anyway.\n\n  Destructuring arguments\n\nNon-scalar parameters can be followed or substituted by a sub-signature in\nparentheses, which will destructure the argument given. The destructuring\nof a list is just its elements:\n\n    sub first(@array ($first, *@rest)) { $first }\n\nor\n\n    sub first([$f, *@]) { $f }\n\nWhile the destructuring of a hash is its pairs:\n\n    sub all-dimensions(% (:length(:$x), :width(:$y), :depth(:$z))) {\n        $x andthen $y andthen $z andthen True\n    }\n\nPointy loops can also destructure hashes, allowing assignment to\nvariables:\n\n    my %hhgttu = (:40life, :41universe, :42everything);\n    for %hhgttu -> (:$key, :$value) {\n      say \"$key → $value\";\n    }\n    # OUTPUT: «universe → 41␤life → 40␤everything → 42␤»\n\nIn general, an object is destructured based on its attributes. A common\nidiom is to unpack a Pair's key and value in a for loop:\n\n    for <Peter Paul Merry>.pairs -> (:key($index), :value($guest)) { }\n\nHowever, this unpacking of objects as their attributes is only the default\nbehavior. To make an object get destructured differently, change its\nCapture method.\n\n  Sub-signatures\n\nTo match against a compound parameter use a sub-signature following the\nargument name in parentheses.\n\n    sub foo(|c(Int, Str)){\n       put \"called with {c.perl}\"\n    };\n    foo(42, \"answer\");\n    # OUTPUT: «called with \\(42, \"answer\")␤»\n\n  Long names\n\nTo exclude certain parameters from being considered in multiple dispatch,\nseparate them with a double semicolon.\n\n    multi sub f(Int $i, Str $s;; :$b) { say \"$i, $s, {$b.perl}\" };\n    f(10, 'answer');\n    # OUTPUT: «10, answer, Any␤»\n\n  Capture parameters\n\nPrefixing a parameter with a vertical bar | makes the parameter a Capture,\nusing up all the remaining positional and named arguments.\n\nThis is often used in proto definitions (like proto foo (|) {*}) to\nindicate that the routine's multi definitions can have any type\nconstraints. See proto for an example.\n\nIf bound to a variable arguments can be forwarded as a whole using the slip\noperator |.\n\n    sub a(Int $i, Str $s) { say $i.^name ~ ' ' ~ $s.^name }\n    sub b(|c) { say c.^name; a(|c) }\n    b(42, \"answer\");\n    # OUTPUT: «Capture␤Int Str␤»\n\n  Parameter traits and modifiers\n\nBy default, parameters are bound to their argument and marked as read-only.\nOne can change that with traits on the parameter.\n\n The is copy trait causes the argument to be copied, and allows it to be\nmodified inside the routine\n\n    sub count-up($x is copy) {\n        $x = ∞ if $x ~~ Whatever;\n        .say for 1..$x;\n    }\n\n The is rw trait, which stands for is read-write, makes the parameter bind\nto a variable (or other writable container). Assigning to the parameter\nchanges the value of the variable at the caller side.\n\n    sub swap($x is rw, $y is rw) {\n        ($x, $y) = ($y, $x);\n    }\n\nOn slurpy parameters, is rw is reserved for future use by language\ndesigners.\n\n The is raw trait is automatically applied to parameters declared with a\nbackslash as a \"sigil\", and may also be used to make normally sigiled\nparameters behave like these do. In the special case of slurpies, which\nnormally produce an Array full of Scalars as described above, is raw will\ninstead cause the parameter to produce a List. Each element of that list\nwill be bound directly as raw parameter.\n\n To explicitly ask for a read-only parameter use the is readonly trait.\nPlease note that this applies only to the container. The object inside can\nvery well have mutator methods and Raku will not enforce immutability on\nthe attributes of the object.\n\nTraits can be followed by the where clause:\n\n    sub ip-expand-ipv6($ip is copy where m:i/^<[a..f\\d\\:]>**3..39$/) { }\n\n"},{"name":"Numeric","methods":["Numeric\n\nDefined as:\n\n    multi method Numeric(Numeric:D: --> Numeric:D)\n    multi method Numeric(Numeric:U: --> Numeric:D)\n\nThe :D variant simply returns the invocant. The :U variant issues a warning\nabout using an uninitialized value in numeric context and then returns\nself.new.","Int\n\n    method Int(Numeric:D: --> Int:D)\n\nIf this Numeric is equivalent to a Real, return the equivalent of calling\ntruncate on that Real to get an Int. Fail with X::Numeric::Real otherwise.","Rat\n\n    method Rat(Numeric:D: Real $epsilon = 1.0e-6 --> Rat:D)\n\nIf this Numeric is equivalent to a Real, return a Rat which is within\n$epsilon of that Real's value. Fail with X::Numeric::Real otherwise.","Num\n\n    method Num(Numeric:D: --> Num:D)\n\nIf this Numeric is equivalent to a Real, return that Real as a Num as\naccurately as is possible. Fail with X::Numeric::Real otherwise.","narrow\n\n    method narrow(Numeric:D --> Numeric:D)\n\nReturns the number converted to the narrowest type that can hold it without\nloss of precision.\n\n    say (4.0 + 0i).narrow.perl;     # OUTPUT: «4␤»\n    say (4.0 + 0i).narrow.^name;    # OUTPUT: «Int␤»","ACCEPTS\n\n    multi method ACCEPTS(Numeric:D: $other)\n\nReturns True if $other can be coerced to Numeric and is numerically equal\nto the invocant (or both evaluate to NaN).","log\n\n    multi sub    log(Numeric:D, Numeric $base = e --> Numeric:D)\n    multi method log(Numeric:D: Numeric $base = e --> Numeric:D)\n\nCalculates the logarithm to base $base. Defaults to the natural logarithm.\nReturns NaN if $base is negative. Throws an exception if $base is 1.","log10\n\n    multi sub    log10(Numeric:D  --> Numeric:D)\n    multi method log10(Numeric:D: --> Numeric:D)\n\nCalculates the logarithm to base 10. Returns NaN for negative arguments and\n-Inf for 0.","exp\n\n    multi sub    exp(Numeric:D, Numeric:D $base = e --> Numeric:D)\n    multi method exp(Numeric:D: Numeric:D $base = e --> Numeric:D)\n\nReturns $base to the power of the number, or e to the power of the number\nif called without a second argument.","roots\n\n    multi method roots(Numeric:D: Int:D $n --> Positional)\n\nReturns a list of the $n complex roots, which evaluate to the original\nnumber when raised to the $nth power.","abs\n\n    multi sub    abs(Numeric:D  --> Real:D)\n    multi method abs(Numeric:D: --> Real:D)\n\nReturns the absolute value of the number.","sqrt\n\n    multi sub    sqrt(Numeric:D --> Numeric:D)\n    multi method sqrt(Numeric:D --> Numeric:D)\n\nReturns a square root of the number. For real numbers the positive square\nroot is returned.\n\nOn negative real numbers, sqrt returns NaN rather than a complex number, in\norder to not confuse people who are not familiar with complex arithmetic.\nIf you want to calculate complex square roots, coerce to Complex first, or\nuse the roots method.","conj\n\n    multi method conj(Numeric:D --> Numeric:D)\n\nReturns the complex conjugate of the number. Returns the number itself for\nreal numbers.","Bool\n\n    multi method Bool(Numeric:D:)\n\nReturns False if the number is equivalent to zero, and True otherwise.","succ\n\n    method succ(Numeric:D:)\n\nReturns the number incremented by one (successor).","pred\n\n    method pred(Numeric:D:)\n\nReturns the number decremented by one (predecessor)."],"desc":"TITLE\nrole Numeric\n\nSUBTITLE\nNumber or object that can act as a number\n\n    role Numeric { ... }\n\nCommon role for numbers and types that can act as numbers.\n\nBinary numeric operations return an object of the \"wider\" type:\n\n    Int         narrowest\n    Rat\n    FatRat\n    Num\n    Complex     widest\n\n\nSo for example the product of a Rat and an Int is a Rat.\n\nUnary operations that in pure math usually return an irrational number\ngenerally return Num in Raku.\n\n"},{"desc":"TITLE\nrole IO\n\nSUBTITLE\nInput/output related routines\n\nThe role provides no methods, but exists so that IO() coercers, which\ncoerce to IO::Path, correctly type-check the resultant value. The role is\nimplemented by IO::Path and IO::Special.\n\nSee also the related classes IO::Handle and IO::Path.","methods":[],"name":"IO"},{"name":"Nil","methods":["append\n\n    method append(*@)\n\nWarns the user that they tried to append onto a Nil.","gist\n\n    method gist(--> Str:D)\n\nReturns \"Nil\".","Str\n\n    method Str()\n\nWarns the user that they tried to stringify a Nil.","new\n\n    method new(*@)\n\nReturns Nil","prepend\n\n    method prepend(*@)\n\nWarns the user that they tried to prepend onto a Nil.","push\n\n    method push(*@)\n\nWarns the user that they tried to push onto a Nil.","unshift\n\n    method unshift(*@)\n\nWarns the user that they tried to unshift onto a Nil.","FALLBACK\n\n    method FALLBACK(| --> Nil) {}\n\nThe fallback method takes any arguments and always returns a Nil.","Numeric\n\n    method Numeric()\n\nWarns the user that they tried to numify a Nil."],"desc":"TITLE\nclass Nil\n\nSUBTITLE\nAbsence of a value or a benign failure\n\n    class Nil is Cool { }\n\nThe value Nil may be used to fill a spot where a value would normally go,\nand in so doing, explicitly indicate that no value is present. It may also\nbe used as a cheaper and less explosive alternative to a Failure. (In fact,\nclass Failure is derived from Nil, so smartmatching Nil will also match\nFailure.)\n\nThe class Nil is the same exact thing as its only possible value, Nil.\n\n    say Nil === Nil.new;        # OUTPUT: «True␤»\n\nAlong with Failure, Nil and its sub classes may always be returned from a\nroutine even when the routine specifies a particular return type. It may\nalso be returned regardless of the definedness of the return type, however,\nNil is considered undefined for all other purposes.\n\n    sub a( --> Int:D ) { return Nil }\n    a().say;                    # OUTPUT: «Nil␤»\n\nNil is what is returned from empty routines or closure, or routines that\nuse a bare return statement.\n\n    sub a { }; a().say;         # OUTPUT: «Nil␤»\n    sub b { return }; b().say;  # OUTPUT: «Nil␤»\n    say (if 1 { });             # OUTPUT: «Nil␤»\n    { ; }().say;                # OUTPUT: «Nil␤»\n    say EVAL \"\";                # OUTPUT: «Nil␤»\n\nIn a list, Nil takes the space of one value. Iterating a Nil behaves like\niteration of any non-iterable value, producing a sequence of one Nil. (When\nyou need the other meaning, the special value Empty is available to take no\nspaces when inserted into list, and to return no values when iterated.)\n\n    (1, Nil, 3).elems.say;      # OUTPUT: «3␤»\n    (for Nil { $_ }).perl.say;  # OUTPUT: «(Nil,)␤»\n\nAny method call on Nil of a method that does not exist, and consequently,\nany subscripting operation, will succeed and return Nil.\n\n    say Nil.ITotallyJustMadeThisUp;  # OUTPUT: «Nil␤»\n    say (Nil)[100];                  # OUTPUT: «Nil␤»\n    say (Nil){100};                  # OUTPUT: «Nil␤»\n\n When assigned to a container, the Nil value (but not any subclass of Nil)\nwill attempt to revert the container to its default value; if no such\ndefault is declared, Raku assumes Any.\n\nSince a hash assignment expects two elements, use Empty not Nil, e.g.\n\n    my %h = 'a'..'b' Z=> 1..*;\n    # stuff happens\n    %h = Empty; # %h = Nil will generate an error\n\nHowever, if the container type is constrained with :D, assigning Nil to it\nwill immediately throw an exception. (In contrast, an instantiated Failure\nmatches :D because it's a definite value, but will fail to match the actual\nnominal type unless it happens to be a parent class of Failure.) Native\ntypes can not have default values nor hold a type object. Assigning Nil to\na native type container will fail with a runtime error.\n\n    my Int $x = 42;\n    $x = Nil;\n    $x.say;                     # OUTPUT: «(Int)␤»\n\n    sub f( --> Int:D ){ Nil };  # this definedness constraint is ignored\n    my Int:D $i = f;            # this definedness constraint is not ignored, so throws\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)»\n\n    sub g( --> Int:D ){ fail \"oops\" }; # this definedness constraint is ignored\n    my Any:D $h = g;                   # failure object matches Any:D, so is assigned\n\nbut\n\n    my Int:D $j = g;\n    # It will throw both exceptions:\n    # Earlier failure:\n    #  oops\n    #   in sub g at <unknown file> line 1\n    #   in block <unit> at <unknown file> line 1\n    #\n    # Final error:\n    #  Type check failed in assignment to $j; expected Int:D but got Failure (Failure.new(exception...)\n    #   in block <unit> at <unknown file> line 1\n\n\nBecause an untyped variable is type Any, assigning a Nil to one will result\nin an (Any) type object.\n\n    my $x = Nil;\n    $x.say;          # OUTPUT: «(Any)␤»\n    my Int $y = $x;  # will throw an exception\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $y; expected Int but got Any (Any)␤»\n\nIf you are looking for a variable which transforms objects into type\nobjects when said variable appears on the right-hand side, you can type the\ncontainer as Nil.\n\n    my Nil $x;\n    my Str $s = $x;\n    $s.say;          # OUTPUT: «(Str)␤»\n\nThere is an important exception to this transforms-into-type-object rule:\nassigning Nil to a variable which has a default will restore that default.\n\n    my Int $x is default(42) = -1;\n    my $y = 1;\n    for $x, $y -> $val is rw { $val = Nil unless $val > 0 }\n    $x.say;          # OUTPUT: «42␤»\n\n"},{"methods":[],"desc":"TITLE\nclass Duration\n\nSUBTITLE\nLength of time\n\n    class Duration is Cool does Real { }\n\nA Duration represents a length of time in atomic seconds, with fractions.\nLike an Instant, it is epoch-agnostic.\n\nDurations can be subtracted from or added to Instants to yield another, new\nInstant. Subtracting one Instant from another yields a Duration. A Duration\ncan also result from mathematical operations between two Durations when it\nmakes sense (namely, the addition, subtraction, or modulus of two\nDurations). It can also be added, subtracted or divided modulo Real\nnumbers.\n\nThe type of object returned for other numeric operations is currently\nunspecified.","name":"Duration"},{"desc":"TITLE\nrole Enumeration\n\nSUBTITLE\nWorking with the role behind the enum type\n\n    role Enumeration { }\n\nThis is the role implemented by the enum-pairs in the enum type. In\ngeneral, it is used to create constant sets, the elements of which become\nalso constant symbols in the current namespace and to establish a\nrelationship between the symbols belonging to the same set. In general, you\nwill find Enumeration in enum types:\n\n    enum norse-gods <Þor Oðin Loki>;\n    my $one-of-them = norse-gods.pick;\n    say $one-of-them ~~ Enumeration; # OUTPUT: «True␤»\n\nbut nothing prevents you from using it in your own programs if you want to\nrestrict somehow the relationship between the key and the value:\n\n    class DNA does Enumeration {\n        my %pairings = %( A => \"T\",\n                          T => \"A\",\n                          C => \"G\",\n                          G => \"C\" );\n\n        method new( $base-pair where \"A\" | \"C\" | \"G\" | \"T\" )  {\n            self.bless( key => $base-pair,\n                        value => %pairings{$base-pair});\n        }\n\n        multi method gist(::?CLASS:D:) {\n            return \"$!key → $!value\";\n        }\n\n    }\n\n    enum Chain ();\n    constant length = 16;\n    for <A C G T>.roll( length ) -> $letter {\n        my DNA $base = DNA.new( $letter );\n        Chain.HOW.add_enum_value( Chain, $base );\n    }\n\n    for ^length {\n        my $base = Chain.pick;\n        say \"{$base.key} and {$base.value}\";\n    }\n\n\nIn this code, DNA consumes the Enumeration role, which is from this point\nof view a pair of key and value; we can use the generated DNA objects to\ncompose an enum type from which elements can be picked one by one, with the\noutput shown below.\n\n    T and A\n    C and G\n    T and A\n    # and so on...\n\n\n","methods":["These are the methods included in this role:","key\n\nAn Enumeration property.\n\n    enum Norse-gods <Þor Oðin Freija>;\n    say Freija.key; # OUTPUT: «Freija␤»","value\n\nThese are Enumeration properties.\n\n    enum Norse-gods <Þor Oðin Freija>;\n    say Oðin.value; # OUTPUT: «1␤»\n\nThe value is assigned automatically by the enum type starting at 0. Oðin\ngets 1 since it is the second in the enum.","enums\n\nDefined as:\n\n    method enums()\n\nReturns a Map of enum values. Works both on the enum type and any key.\n\n    enum Mass ( mg => 1/1000, g => 1/1, kg => 1000/1 );\n    say Mass.enums; # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»\n    say g.enums;    # OUTPUT: «Map.new((g => 1, kg => 1000, mg => 0.001))␤»","kv\n\nDefined as:\n\n    multi method kv(::?CLASS:D:)\n\nReturns a list with key and value of the enum-pair.\n\n    say g.kv; # OUTPUT: «(g 1)␤»","pair\n\nDefined as:\n\n    method pair(::?CLASS:D:)\n\nReturns it as a Pair.\n\n    say g.pair; # OUTPUT: «g => 1␤»","CALL-ME\n\nDefined as:\n\n    multi method CALL-ME(|)\n\nReturns an Enumeration instance given an enum value.\n\n    enum Mass ( mg => 1/1000, g => 1/1, kg => 1000/1 );\n    say Mass(1/1000); # OUTPUT: mg","pick\n\nDefined as:\n\n    multi method pick(::?CLASS:U:)\n    multi method pick(::?CLASS:U: \\n)\n    multi method pick(::?CLASS:D: *@pos)\n\nIt works on the defined class, selecting one element and eliminating it.\n\n    say Norse-gods.pick() for ^3;  # OUTPUT: «Þor␤Freija␤Oðin␤»","roll\n\nDefined as:\n\n    multi method roll(::?CLASS:U:)\n    multi method roll(::?CLASS:U: \\n)\n    multi method roll(::?CLASS:D: *@pos)\n\nThey work on the defined class selecting one or n elements without\neliminating them.\n\n    say Norse-gods.roll() for ^3;  # OUTPUT: «Freija␤Freija␤Oðin␤»","pred\n\nDefined as:\n\n    method pred(::?CLASS:D:)\n\n    say Freija.pred;  # OUTPUT: «Oðin␤»","succ\n\nDefined as:\n\n    method succ(::?CLASS:D:)\n\n    say Oðin.succ;  # OUTPUT: «Freija␤»","Numeric\n\nDefined as:\n\n    multi method Numeric(::?CLASS:D:)\n\nTakes a value of an enum and returns it after coercion to Numeric:\n\n    enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\n    say cool.Numeric;       # OUTPUT: «42␤»\n    say almost-pi.Numeric;  # OUTPUT: «3.14␤»\n    say sqrt-n-one.Numeric; # OUTPUT: «0+1i␤»\n\nNote that if the value cannot be coerced to Numeric, an exception will be\nthrown.","Int\n\nDefined as:\n\n    multi method Int(::?CLASS:D:)\n\nTakes a value of an enum and returns it after coercion to Int:\n\n    enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\n    say cool.Int;           # OUTPUT: «42␤»\n    say almost-pi.Int;      # OUTPUT: «3␤»\n    try say sqrt-n-one.Int;\n    say $!.message if $!;   # OUTPUT: «Cannot convert 0+1i to Int: imaginary part not zero␤»\n\nNote that if the value cannot be coerced to Int, an exception will be\nthrown.","Real\n\nDefined as:\n\n    multi method Real(::?CLASS:D:)\n\nTakes a value of an enum and returns it after coercion to Real:\n\n    enum Numbers ( cool => '42', almost-pi => '3.14', sqrt-n-one => 'i' );\n    say cool.Real;           # OUTPUT: «42␤»\n    say almost-pi.Real;      # OUTPUT: «3.14␤»\n    try say sqrt-n-one.Real;\n    say $!.message if $!;    # OUTPUT: «Cannot convert 0+1i to Real: imaginary part not zero␤»\n\nNote that if the value cannot be coerced to Real, an exception will be\nthrown.","===\n\nDefined as\n\n    multi infix:<===> (Enumeration:D \\a, Enumeration:D \\b)\n\nEquality of Enumeration symbols:\n\n    say Norse-gods.pick() === Freija for ^3; # OUTPUT: «False␤False␤True␤»"],"name":"Enumeration"},{"name":"Label","desc":"TITLE\nclass Label\n\nSUBTITLE\nTagged location in the source code\n\n    class Label {}\n\nLabels are used in Raku to tag loops so that you can specify the one you\nwant to jump to with statements such as last. You can use it to jump out of\nloops and get to outer ones, instead of just exiting the current loop or\ngoing to the statement before.\n\n    USERS:          # the label\n    for @users -> $u {\n        for $u.pets -> $pet {\n            # usage of a label\n            next USERS if $pet.barks;\n        }\n        say \"None of {$u}'s pets barks\";\n    }\n    say USERS.^name;        # OUTPUT: «Label␤»\n\n\nThose label are objects of type Label, as shown in the last statement.\nLabels can be used in any loop construct, as long as they appear right\nbefore the loop statement.\n\n    my $x = 0;\n    my $y = 0;\n    my $t = '';\n    A: while $x++ < 2 {\n        $t ~= \"A$x\";\n        B: while $y++ < 2 {\n            $t ~= \"B$y\";\n            redo A if $y++ == 1;\n            last A\n        }\n    }\n    say $t; # OUTPUT: «A1B1A1A2»\n\n\nPutting them on the line before the loop or the same line is optional.\nLabels must follow the syntax of ordinary identifiers, although\ntraditionally we will use the latin alphabet in uppercase so that they\nstand out in the source. You can use, however, other alphabets like here:\n\n    駱駝道: while True {\n      say 駱駝道.name;\n      last 駱駝道;\n    }\n\n","methods":["name\n\nDefined as:\n\n    method name()\n\nNot terribly useful, returns the name of the defined label:\n\n    A: while True {\n      say A.name; # OUTPUT: «A»\n      last A;\n    }","next\n\nDefined as:\n\n    method next(Label:)\n\nBegin the next iteration of the loop associated with the label.\n\n    MY-LABEL:\n    for 1..10 {\n        next MY-LABEL if $_ < 5;\n        print \"$_ \";\n    }\n\n    # OUTPUT: «5 6 7 8 9 10 »","redo\n\nDefined as:\n\n    method redo(Label:)\n\nRepeat the same iteration of the loop associated with the label.\n\n    my $has-repeated = False;\n\n    MY-LABEL:\n    for 1..10 {\n        print \"$_ \";\n        if $_ == 5 {\n            LEAVE $has-repeated = True;\n            redo MY-LABEL unless $has-repeated;\n        }\n    }\n\n    # OUTPUT: «1 2 3 4 5 5 6 7 8 9 10 »","last\n\nDefined as:\n\n    method last(Label:)\n\nTerminate the execution of the loop associated with the label.\n\n    MY-LABEL:\n    for 1..10 {\n        last MY-LABEL if $_ > 5;\n        print \"$_ \";\n    }\n\n    # OUTPUT: «1 2 3 4 5 »"]},{"name":"VM","methods":["osname\n\nDefined as:\n\n    multi method osname(VM:U:)\n    multi method osname(VM:D:)\n\nInstance / Class method returning the name of the Operating System, as\nknown by the configuration of the VM object / currently running virtual\nmachine.","precomp-ext\n\nInstance method returning a string of the extension that should be used for\nprecompiled files of the VM object.","precomp-target\n\nInstance method returning a string of the value of the compilation target\nthat should be used when precompiling source-files with the VM object.","prefix\n\nInstance method returning a string of the path in which the virtual machine\nof the VM object is installed."],"desc":"TITLE\nclass VM\n\nSUBTITLE\nRaku Virtual Machine related information\n\n    class VM does Systemic { }\n\nBuilt-in class for providing information about the virtual machine in which\nRaku is running. Usually accessed through the $*VM dynamic variable.\n\n"},{"desc":"TITLE\nclass ThreadPoolScheduler\n\nSUBTITLE\nScheduler that distributes work among a pool of threads\n\n    class ThreadPoolScheduler does Scheduler {}\n\n\nThe ThreadPoolScheduler has a range of number of threads that it maintains,\nand it distributes work among those threads. When the upper limit of\nthreads isn't reached yet, and there is work pending, it spawns new threads\nto handle the work.\n\n","methods":["new\n\n    method new(Int :$initial_threads = 0, Int :$max_threads=16)\n\nCreates a new ThreadPoolScheduler object with the given range of threads to\nmaintain."],"name":"ThreadPoolScheduler"},{"name":"Any","desc":"TITLE\nclass Any\n\nSUBTITLE\nThing/object\n\n    class Any is Mu {}\n\nWhile Mu is the root of the Raku class hierarchy, Any is the class that\nserves as a default base class for new classes, and as the base class for\nmost built-in classes.\n\nSince Raku intentionally confuses items and single-element lists, most\nmethods in Any are also present on class List, and coerce to List or a\nlist-like type.\n\n","methods":["ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(Any:D: Mu $other)\n\nUsage:\n\n    EXPR.ACCEPTS(EXPR);\n\n\nReturns True if $other === self (i.e. it checks object identity).\n\nMany built-in types override this for more specific comparisons.","any\n\nDefined as:\n\n    method any(--> Junction:D)\n\nInterprets the invocant as a list and creates an any-Junction from it.\n\n    say so 2 == <1 2 3>.any;        # OUTPUT: «True␤»\n    say so 5 == <1 2 3>.any;        # OUTPUT: «False␤»","all\n\nDefined as:\n\n    method all(--> Junction:D)\n\nInterprets the invocant as a list and creates an all-Junction from it.\n\n    say so 1 < <2 3 4>.all;         # OUTPUT: «True␤»\n    say so 3 < <2 3 4>.all;         # OUTPUT: «False␤»","one\n\nDefined as:\n\n    method one(--> Junction:D)\n\nInterprets the invocant as a list and creates a one-Junction from it.\n\n    say so 1 == (1, 2, 3).one;      # OUTPUT: «True␤»\n    say so 1 == (1, 2, 1).one;      # OUTPUT: «False␤»","none\n\nDefined as:\n\n    method none(--> Junction:D)\n\nInterprets the invocant as a list and creates a none-Junction from it.\n\n    say so 1 == (1, 2, 3).none;     # OUTPUT: «False␤»\n    say so 4 == (1, 2, 3).none;     # OUTPUT: «True␤»","list\n\nDefined as:\n\n    multi method list(Any:U: --> List)\n    multi method list(Any:D \\SELF: --> List)\n\nApplies the infix , operator to the invocant and returns the resulting\nList:\n\n    say 42.list.^name;           # OUTPUT: «List␤»\n    say 42.list.elems;           # OUTPUT: «1␤»\n\nSubclasses of Any may choose to return any core type that does the\nPositional role from .list. Use .List to coerce specifically to List.\n\n @ can also be used as a list or Positional contextualizer:\n\n    my $not-a-list-yet = $[1,2,3];\n    say $not-a-list-yet.perl;             # OUTPUT: «$[1, 2, 3]␤»\n    my @maybe-a-list = @$not-a-list-yet;\n    say @maybe-a-list.^name;              # OUTPUT: «Array␤»\n\n\nIn the first case, the list is itemized. @ as a prefix puts the initial\nscalar in a list context by calling .list and turning it into an Array.","push\n\nDefined as:\n\n    method push(|values --> Positional:D)\n\nThe method push is defined for undefined invocants and allows for\nautovivifying undefined to an empty Array, unless the undefined value\nimplements Positional already. The argument provided will then be pushed\ninto the newly created Array.\n\n    my %h;\n    say %h<a>;     # OUTPUT: «(Any)␤»      <-- Undefined\n    %h<a>.push(1); # .push on Any\n    say %h;        # OUTPUT: «{a => [1]}␤» <-- Note the Array","reverse\n\nDefined as:\n\n    multi sub    reverse(*@list  --> Seq:D)\n    multi method reverse(List:D: --> Seq:D)\n\nReturns a Seq with the same elements in reverse order.\n\nNote that reverse always refers to reversing elements of a list; to reverse\nthe characters in a string, use flip.\n\nExamples:\n\n    say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\n    say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»","sort\n\nDefined as:\n\n    multi method sort()\n    multi method sort(&custom-routine-to-use)\n\nSorts iterables with cmp or given code object and returns a new Seq.\nOptionally, takes a Callable as a positional parameter, specifying how to\nsort.\n\nExamples:\n\n    say <b c a>.sort;                           # OUTPUT: «(a b c)␤»\n    say 'bca'.comb.sort.join;                   # OUTPUT: «abc␤»\n    say 'bca'.comb.sort({$^b cmp $^a}).join;    # OUTPUT: «cba␤»\n    say '231'.comb.sort(&infix:«<=>»).join;     # OUTPUT: «123␤»","map\n\nDefined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nmap will iterate over the invocant and apply the number of positional\nparameters of the code object from the invocant per call. The returned\nvalues of the code object will become elements of the returned Seq.\n\nThe :$label and :$item are useful only internally, since for loops get\nconverted to maps. The :$label takes an existing Label to label the .map's\nloop with and :$item controls whether the iteration will occur over (SELF,)\n(if :$item is set) or SELF.\n\nIn sub form, will apply the code block to the values, which will be used as\ninvocant.\n\nThe form with \\c, Iterable:D \\iterable and Hash:D \\hash as signatures will\nfail with X::Cannot::Map, and are mainly meant to catch common traps.","deepmap\n\nDefined as:\n\n    method deepmap(&block --> List) is nodal\n\ndeepmap will apply &block to each element and return a new List with the\nreturn values of &block, unless the element does the Iterable role. For\nthose elements deepmap will descend recursively into the sublist.\n\n    say [[1,2,3],[[4,5],6,7]].deepmap(* + 1);\n    # OUTPUT: «[[2 3 4] [[5 6] 7 8]]␤»\n\nIn the case of Associatives, it will be applied to its values:\n\n    { what => \"is\", this => \"thing\", a => <real list> }.deepmap( *.flip ).say\n    # OUTPUT: «{a => (laer tsil), this => gniht, what => si}␤»","duckmap\n\nDefined as:\n\n    method duckmap(&block) is rw is nodal\n\nduckmap will apply &block on each element that behaves in such a way that\n&block can be applied. If it fails, it will descend recursively if\npossible, or otherwise return the item without any transformation. It will\nact on values if the object is Associative.\n\n    <a b c d e f g>.duckmap(-> $_ where <c d e>.any { .uc }).say;\n    # OUTPUT: «(a b C D E f g)␤»\n    (('d', 'e'), 'f').duckmap(-> $_ where <e f>.any { .uc }).say;\n    # OUTPUT: «((d E) F)␤»\n    { first => ('d', 'e'), second => 'f'}.duckmap(-> $_ where <e f>.any { .uc }).say;\n    # OUTPUT: «{first => (d E), second => F}␤»\n\n\nIn the first case, it is applied to c, d and e which are the ones that meet\nthe conditions for the block ({ .uc }) to be applied; the rest are returned\nas is.\n\nIn the second case, the first item is a list that does not meet the\ncondition, so it's visited; that flat list will behave in the same way as\nthe first one. In this case:\n\n    say [[1,2,3],[[4,5],6,7]].duckmap( *² ); # OUTPUT: «[9 9]␤»\n\nYou can square anything as long as it behaves like a number. In this case,\nthere are two arrays with 3 elements each; these arrays will be converted\ninto the number 3 and squared. In the next case, however\n\n    say [[1,2,3],[[4,5],6.1,7.2]].duckmap( -> Rat $_ { $_²} );\n    # OUTPUT: «[[1 2 3] [[4 5] 37.21 51.84]]␤»\n\n3-item lists are not Rat, so it descends recursively, but eventually only\napplies the operation to those that walk (or slither, as the case may be)\nlike a Rat.\n\nAlthough on the surface (and name), duckmap might look similar to deepmap,\nthe latter is applied recursively regardless of the type of the item.","nodemap\n\nDefined as:\n\n    method nodemap(&block --> List) is nodal\n\nnodemap will apply &block to each element and return a new List with the\nreturn values of &block. In contrast to deepmap it will not descend\nrecursively into sublists if it finds elements which do the Iterable role.\n\n    say [[1,2,3], [[4,5],6,7], 7].nodemap(*+1);\n    # OUTPUT: «(4, 4, 8)␤»\n\n    say [[2, 3], [4, [5, 6]]]».nodemap(*+1)\n    # OUTPUT: «((3 4) (5 3))␤»\n\nThe examples above would have produced the exact same results if we had\nused map instead of nodemap. The difference between the two lies in the\nfact that map flattens out slips while nodemap doesn't.\n\n    say [[2,3], [[4,5],6,7], 7].nodemap({.elems == 1 ?? $_ !! slip});\n    # OUTPUT: «(() () 7)␤»\n    say [[2,3], [[4,5],6,7], 7].map({.elems == 1 ?? $_ !! slip});\n    # OUTPUT: «(7)␤»\n\nWhen applied to Associatives, it will act on the values:\n\n    { what => \"is\", this => \"thing\" }.nodemap( *.flip ).say;\n    # OUTPUT: «{this => gniht, what => si}␤»","flat\n\nDefined as:\n\n    method flat() is nodal\n\nInterprets the invocant as a list, flattens non-containerized Iterables\ninto a flat list, and returns that list. Keep in mind Map and Hash types\nare Iterable and so will be flattened into lists of pairs.\n\n    say ((1, 2), (3), %(:42a));      # OUTPUT: «((1 2) 3 {a => 42})␤»\n    say ((1, 2), (3), %(:42a)).flat; # OUTPUT: «(1 2 3 a => 42)␤»\n\nNote that Arrays containerize their elements by default, and so flat will\nnot flatten them. You can use hyper method call to call .List method on all\nthe inner Iterables and so de-containerize them, so that flat can flatten\nthem:\n\n    say [[1, 2, 3], [(4, 5), 6, 7]]      .flat; # OUTPUT: «([1 2 3] [(4 5) 6 7])␤»\n    say [[1, 2, 3], [(4, 5), 6, 7]]».List.flat; # OUTPUT: «(1 2 3 4 5 6 7)␤»\n\nFor more fine-tuned options, see deepmap, duckmap, and signature\ndestructuring","eager\n\nDefined as:\n\n    method eager() is nodal\n\nInterprets the invocant as a List, evaluates it eagerly, and returns that\nList.\n\n    my  $range = 1..5;\n    say $range;         # OUTPUT: «1..5␤»\n    say $range.eager;   # OUTPUT: «(1 2 3 4 5)␤»","elems\n\nDefined as:\n\n    multi method elems(Any:U: --> 1)\n    multi method elems(Any:D:)\n\nInterprets the invocant as a list, and returns the number of elements in\nthe list.\n\n    say 42.elems;                   # OUTPUT: «1␤»\n    say <a b c>.elems;              # OUTPUT: «3␤»\n    say Whatever.elems ;            # OUTPUT: «1␤»\n\nIt will also return 1 for classes.","end\n\n    multi method end(Any:U: --> 0)\n    multi method end(Any:D:)\n\nInterprets the invocant as a list, and returns the last index of that\nlist.\n\n    say 6.end;                      # OUTPUT: «0␤»\n    say <a b c>.end;                # OUTPUT: «2␤»","pairup\n\nDefined as:\n\n    multi method pairup(Any:U:)\n    multi method pairup(Any:D:)\n\nReturns an empty Seq if the invocant is a type object\n\n    Range.pairup.say; # OUTPUT: «()␤»\n\nInterprets the invocant as a list, and constructs a list of pairs from it,\nin the same way that assignment to a Hash does. That is, it takes two\nconsecutive elements and constructs a pair from them, unless the item in\nthe key position already is a pair (in which case the pair is passed\nthrough, and the next list item, if any, is considered to be a key again).\nIt returns a Seq of Pairs.\n\n    say (a => 1, 'b', 'c').pairup.perl;     # OUTPUT: «(:a(1), :b(\"c\")).Seq␤»\n\n  sub item\n\nDefined as:\n\n    multi item(\\x)\n    multi item(|c)\n    multi item(Mu $a)\n\nForces given object to be evaluated in item context and returns the value\nof it.\n\n    say item([1,2,3]).perl;              # OUTPUT: «$[1, 2, 3]␤»\n    say item( %( apple => 10 ) ).perl;   # OUTPUT: «${:apple(10)}␤»\n    say item(\"abc\").perl;                # OUTPUT: «\"abc\"␤»\n\nYou can also use $ as item contextualizer.\n\n    say $[1,2,3].perl;                   # OUTPUT: «$[1, 2, 3]␤»\n    say $(\"abc\").perl;                   # OUTPUT: «\"abc\"␤»","Array\n\nDefined as:\n\n    method Array(--> Array:D) is nodal\n\nCoerces the invocant to an Array.","List\n\nDefined as:\n\n    method List(--> List:D) is nodal\n\nCoerces the invocant to List, using the list method.","serial\n\nDefined as\n\n    multi method serial()\n\nThis method is Rakudo specific, and is not included in the Raku spec.\n\nThe method returns the self-reference to the instance itself:\n\n    my $b;                 # defaults to Any\n    say $b.serial.^name;   # OUTPUT: «Any␤»\n    say $b.^name;          # OUTPUT: «Any␤»\n    my $breakfast = 'food';\n    $breakfast.serial.say; # OUTPUT: «food␤»\n\n\nThis is apparently a no-op, as exemplified by the third example above.\nHowever, in HyperSeqs and RaceSeqs it returns a serialized Seq, so it can\nbe considered the opposite of the hyper/race methods. As such, it ensures\nthat we are in serial list-processing mode, as opposed to the autothreading\nmode of those methods.","Hash\n\nDefined as:\n\n    multi method Hash( --> Hash:D)\n\nCoerces the invocant to Hash.","hash\n\nDefined as:\n\n    multi method hash(Any:U:)\n    multi method hash(Any:D:)\n\nWhen called on a type object, returns an empty Hash. On instances, it is\nequivalent to assigning the invocant to a %-sigiled variable and returning\nthat.\n\nSubclasses of Any may choose to return any core type that does the\nAssociative role from .hash. Use .Hash to coerce specifically to Hash.\n\n    my $d; # $d is Any\n    say $d.hash; # OUTPUT: {}\n\n    my %m is Map = a => 42, b => 666;\n    say %m.hash;  # Map.new((a => 42, b => 666))\n    say %m.Hash;  # {a => 42, b => 666}","Slip\n\nDefined as:\n\n    method Slip(--> Slip:D) is nodal\n\nCoerces the invocant to Slip.","Map\n\nDefined as:\n\n    method Map(--> Map:D) is nodal\n\nCoerces the invocant to Map.","Bag\n\nDefined as:\n\n    method Bag(--> Bag:D) is nodal\n\nCoerces the invocant to Bag, whereby Positionals are treated as lists of\nvalues.","BagHash\n\nDefined as:\n\n    method BagHash(--> BagHash:D) is nodal\n\nCoerces the invocant to BagHash, whereby Positionals are treated as lists\nof values.","Set\n\nDefined as:\n\n    method Set(--> Set:D) is nodal\n\nCoerces the invocant to Set, whereby Positionals are treated as lists of\nvalues.","SetHash\n\nDefined as:\n\n    method SetHash(--> SetHash:D) is nodal\n\nCoerces the invocant to SetHash, whereby Positionals are treated as lists\nof values.","Mix\n\nDefined as:\n\n    method Mix(--> Mix:D) is nodal\n\nCoerces the invocant to Mix, whereby Positionals are treated as lists of\nvalues.","MixHash\n\nDefined as:\n\n    method MixHash(--> MixHash:D) is nodal\n\nCoerces the invocant to MixHash, whereby Positionals are treated as lists\nof values.","Supply\n\nDefined as:\n\n    method Supply(--> Supply:D) is nodal\n\nFirst, it coerces the invocant to a list by applying its .list method, and\nthen to a Supply.","min\n\nDefined as:\n\n    multi method min()\n    multi method min(&by)\n    multi sub min(+args, :&by!)\n    multi sub min(+args)\n\nCoerces the invocant to Iterable and returns the numerically smallest\nelement; in the case of Hashes, it returns the Pair with the lowest value.\nIn sub form, the invocant is passed as an argument.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original value is still the one returned from min.\n\n    say (1,7,3).min();              # OUTPUT:«1␤»\n    say (1,7,3).min({1/$_});        # OUTPUT:«7␤»\n    say min(1,7,3);                 # OUTPUT: «1␤»\n    say min(1,7,3,:by( { 1/$_ } )); # OUTPUT: «7␤»\n    min( %(a => 3, b=> 7 ) ).say ;  # OUTPUT: «a => 3␤»","max\n\nDefined as:\n\n    multi method max()\n    multi method max(&by)\n    multi sub max(+args, :&by!)\n    multi sub max(+args)\n\nCoerces the invocant to Iterable and returns the numerically largest\nelement; in the case of Hashes, the Pair with the highest value.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and the return value is compared instead of the original value.\nThe original value is still the one returned from max.\n\n    say (1,7,3).max();                # OUTPUT:«7␤»\n    say (1,7,3).max({1/$_});          # OUTPUT:«1␤»\n    say max(1,7,3,:by( { 1/$_ } ));   # OUTPUT: «1␤»\n    say max(1,7,3);                   # OUTPUT: «7␤»\n    max( %(a => 'B', b=> 'C' ) ).say; # OUTPUT: «b => C␤»","minmax\n\nDefined as:\n\n    multi method minmax()\n    multi method minmax(&by)\n    multi sub minmax(+args, :&by!)\n    multi sub minmax(+args)\n\nReturns a Range from the smallest to the largest element.\n\nIf a Callable positional argument is provided, each value is passed into\nthe filter, and its return value is compared instead of the original value.\nThe original values are still used in the returned Range.\n\n    say (1,7,3).minmax();        # OUTPUT:«1..7␤»\n    say (1,7,3).minmax({-$_});   # OUTPUT:«7..1␤»\n    say minmax(1,7,3);           # OUTPUT: «1..7␤»\n    say minmax(1,7,3,:by( -* )); # OUTPUT: «7..1␤»","minpairs\n\nDefined as:\n\n    multi method minpairs(Any:D:)\n\nCalls .pairs and returns a Seq with all of the Pairs with minimum values,\nas judged by the cmp operator:\n\n    <a b c a b c>.minpairs.perl.put; # OUTPUT: «(0 => \"a\", 3 => \"a\").Seq␤»\n    %(:42a, :75b).minpairs.perl.put; # OUTPUT: «(:a(42),).Seq␤»","maxpairs\n\nDefined as:\n\n    multi method maxpairs(Any:D:)\n\nCalls .pairs and returns a Seq with all of the Pairs with maximum values,\nas judged by the cmp operator:\n\n    <a b c a b c>.maxpairs.perl.put; # OUTPUT: «(2 => \"c\", 5 => \"c\").Seq␤»\n    %(:42a, :75b).maxpairs.perl.put; # OUTPUT: «(:b(75),).Seq␤»","keys\n\nDefined as:\n\n    multi method keys(Any:U: --> List)\n    multi method keys(Any:D: --> List)\n\nFor defined Any returns its keys after calling list on it, otherwise calls\nlist and returns it.\n\n    my $setty = Set(<Þor Oðin Freija>);\n    say $setty.keys; # OUTPUT: «(Þor Oðin Freija)␤»\n\nSee also List.keys.\n\nTrying the same on a class will return an empty list, since most of them\ndon't really have keys.","flatmap\n\nDefined as:\n\n    method flatmap(&block, :$label)\n\nDEPRECATION NOTICE: This method is deprecated in 6.d and will be removed in\n6.e. Use .map followed by .flat instead.\n\nApplies map to every element with the block and Label used as an argument\nand flattens out the result using .flat.\n\n    say \"aabbccc\".comb.Mix.flatmap: \"→ \" ~ *; # OUTPUT: «(→ b␉2 → c␉3 → a␉2)␤»\n\nIn this case, the elements of the Mix are itemized to key␉value, and then\nmapped and flattened. Same result as\n\n    say \"aabbccc\".comb.Mix.map( \"→ \" ~ * ).flat\n\nWhich is why it is deprecated in 6.d and will be eventually eliminated in\n6.e.","roll\n\nDefined as:\n\n    multi method roll(--> Any)\n    multi method roll($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.roll on it.\n\n    my Mix $m = (\"þ\" xx 3, \"ð\" xx 4, \"ß\" xx 5).Mix;\n    say $m.roll;    # OUTPUT: «ð␤»\n    say $m.roll(5); # OUTPUT: «(ß ß þ ß þ)␤»\n\n$m, in this case, is converted into a list and then a (weighted in this\ncase) dice is rolled on it. See also List.roll for more information.","iterator\n\nDefined as:\n\n    multi method iterator(Any:)\n\nReturns the object as an iterator after converting it to a list. This is\nthe function called from the for statement.\n\n    .say for 3; # OUTPUT: «3␤»\n\nMost subclasses redefine this method for optimization, so it's mostly types\nthat do not actually iterate the ones that actually use this\nimplementation.","pick\n\nDefined as:\n\n    multi method pick(--> Any)\n    multi method pick($n --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.pick on it.\n\n    my Range $rg = 'α'..'ω';\n    say $rg.pick(3); # OUTPUT: «(β α σ)␤»","skip\n\nDefined as:\n\n    multi method skip()\n    multi method skip(Whatever)\n    multi method skip(Callable:D $w)\n    multi method skip(Int() $n)\n\nCreates a Seq from 1-item list's iterator and uses Seq.skip on it, please\ncheck that document for real use cases; calling skip without argument is\nequivalent to skip(1).\n\nCalling it with Whatever will return an empty iterator:\n\n    say <1 2 3>.skip(*);   # OUTPUT: «()␤»\n\nThe multi that uses a Callable is intended mainly to be used this way:\n\n    say <1 2 3>.skip(*-1); # OUTPUT: «(3)␤»\n\nInstead of throwing away the first $n elements, it throws away everything\nbut the elements indicated by the WhateverCode, in this case all but the\nlast one.","prepend\n\nDefined as:\n\n    multi method prepend(--> Array)\n    multi method prepend(@values --> Array)\n\nCalled with no arguments on an empty variable, it initializes it as an\nempty Array; if called with arguments, it creates an array and then applies\nArray.prepend on it.\n\n    my $a;\n    say $a.prepend; # OUTPUT: «[]␤»\n    say $a;         # OUTPUT: «[]␤»\n    my $b;\n    say $b.prepend(1,2,3); # OUTPUT: «[1 2 3]␤»","unshift\n\nDefined as:\n\n    multi method unshift(--> Array)\n    multi method unshift(@values --> Array)\n\nInitializes Any variable as empty Array and calls Array.unshift on it.\n\n    my $a;\n    say $a.unshift; # OUTPUT: «[]␤»\n    say $a;         # OUTPUT: «[]␤»\n    my $b;\n    say $b.unshift([1,2,3]); # OUTPUT: «[[1 2 3]]␤»","first\n\nDefined as:\n\n    multi method first(Bool:D $t)\n    multi method first(Regex:D $test, :$end, *%a)\n    multi method first(Callable:D $test, :$end, *%a is copy)\n    multi method first(Mu $test, :$end, *%a)\n    multi method first(:$end, *%a)\n    multi sub first(Bool:D $t, |)\n    multi sub first(Mu $test, +values, *%a)\n\nIn general, coerces the invocant to a list by applying its .list method and\nuses List.first on it.\n\nHowever, this is a multi with different signatures, which are implemented\nwith (slightly) different behavior, although using it as a subroutine is\nequivalent to using it as a method with the second argument as the object.\n\nFor starters, using a Bool as the argument will always return a Failure.\nThe form that uses a $test will return the first element that smartmatches\nit, starting from the end if :end is used.\n\n    say (3..33).first;           # OUTPUT: «3␤»\n    say (3..33).first(:end);     # OUTPUT: «33␤»\n    say (⅓,⅔…30).first( 0xF );   # OUTPUT: «15␤»\n    say first 0xF, (⅓,⅔…30);     # OUTPUT: «15␤»\n    say (3..33).first( /\\d\\d/ ); # OUTPUT: «10␤»\n\nThe third and fourth examples use the Mu $test forms which smartmatches and\nreturns the first element that does. The last example uses as a test a\nregex for numbers with two figures, and thus the first that meets that\ncriterion is number 10. This last form uses the Callable multi:\n\n    say (⅓,⅔…30).first( * %% 11, :end, :kv ); # OUTPUT: «(65 22)␤»\n\nBesides, the search for first will start from the :end and returns the set\nof key/values in a list; the key in this case is simply the position it\noccupies in the Seq. The :kv argument, which is part of the %a argument in\nthe definitions above, modifies what first returns, providing it as a\nflattened list of keys and values; for a listy object, the key will always\nbe the index.\n\nFrom version 6.d, the test can also be a Junction:\n\n    say (⅓,⅔…30).first( 3 | 33, :kv ); # OUTPUT: «(8 3)␤»","unique\n\nDefined as:\n\n    multi method unique()\n    multi method unique( :&as!, :&with! )\n    multi method unique( :&as! )\n    multi method unique( :&with! )\n\nCreates a sequence of unique elements either of the object or of values in\nthe case it's called as a sub.\n\n    <1 2 2 3 3 3>.unique.say; # OUTPUT: «(1 2 3)␤»\n    say unique <1 2 2 3 3 3>; # OUTPUT: «(1 2 3)␤»\n\nThe :as and :with parameters receive functions that are used for\ntransforming the item before checking equality, and for checking equality,\nsince by default the === operator is used:\n\n    (\"1\", 1, \"1 \", 2).unique( as => Int, with => &[==] ).say; #OUTPUT: «(1 2)␤»\n\nPlease see unique for additional examples that use its sub form.","repeated\n\nDefined as:\n\n    multi method repeated()\n    multi method repeated( :&as!, :&with! )\n    multi method repeated( :&as! )\n    multi method repeated( :&with! )\n\nSimilarly to unique, finds repeated elements in values (as a routine) or in\nthe object, using the :as associative argument as a normalizing function\nand :with as equality function.\n\n    <1 -1 2 -2 3>.repeated(:as(&abs),:with(&[==])).say; # OUTPUT: «(-1 -2)␤»\n    (3+3i, 3+2i, 2+1i).repeated(as => *.re).say;        # OUTPUT: «(3+2i)␤»\n\nIt returns the last repeated element before normalization, as shown in the\nexample above. See repeated for more examples that use its sub form.","squish\n\nDefined as:\n\n    multi method squish( :&as!, :&with = &[===] )\n    multi method squish( :&with = &[===] )\n\nSimilar to .repeated, returns the sequence of first elements of contiguous\nsequences of equal elements, after normalization by the function :as, if\npresent, and using as an equality operator the :with argument or === by\ndefault.\n\n    \"aabbccddaa\".comb.squish.say;             # OUTPUT: «(a b c d a)␤»\n    \"aABbccdDaa\".comb.squish( :as(&lc) ).say; # OUTPUT: «(a B c d a)␤»\n    (3+2i,3+3i,4+0i).squish( as => *.re, with => &[==]).put; #OUTPUT: «3+2i 4+0i␤»\n\n\nAs shown in the last example, a sequence can contain a single element. See\nsquish for additional sub examples.","permutations\n\nDefined as:\n\n    method permutations(|c)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.permutations on it.\n\n    say <a b c>.permutations;\n    # OUTPUT: «((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))␤»\n    say set(1,2).permutations;\n    # OUTPUT: «((2 => True 1 => True) (1 => True 2 => True))␤»","join\n\nDefined as\n\n    method join($separator = '') is nodal\n\nConverts the object to a list by calling self.list, and calls .join on the\nlist. Can take a separator, which is an empty string by default.\n\n    (1..3).join.say;       # OUTPUT: «123␤»\n    <a b c>.join(\"❧\").put; # OUTPUT: «a❧b❧c␤»","categorize\n\nDefined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThe two first forms fail with an error message.\n\nIn its simplest form, it uses a $test whose result will be used as a key;\nthe values of the key will be an array of the elements that produced that\nkey as a result of the test.\n\n    say (1..13).categorize( * %% 3);\n    say categorize( * %% 3, 1..13)\n    # OUTPUT: «{False => [1 2 4 5 7 8 10 11 13], True => [3 6 9 12]}␤»\n\n\nThe :as argument will normalize before categorizing\n\n    say categorize( * %% 3, -5..5, as => &abs )\n    # OUTPUT: «{False => [5 4 2 1 1 2 4 5], True => [3 0 3]}␤»\n\n\nThe $into associative argument can be used to put the result instead of\nreturning a new Hash\n\n    my %leap-years;\n    my @years = (2002..2009).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.categorize( *.is-leap-year , into => %leap-years );\n    say %leap-years\n    # OUTPUT:\n    # «{ False\n    # => [2002-01-01 2003-01-01 2005-01-01 2006-01-01 2007-01-01 2009-01-01],\n    #    True => [2004-01-01 2008-01-01]}␤»\n\n\nThe function used to categorize can return an array indicating all possible\nbins their argument can be put into:\n\n    sub divisible-by( Int $n --> Array(Seq) ) {\n        gather {\n            for <2 3 5 7> {\n                take $_ if $n %% $_;\n            }\n        }\n    }\n\n    say (3..13).categorize( &divisible-by );\n    # OUTPUT:\n    # «{2 => [4 6 8 10 12], 3 => [3 6 9 12], 5 => [5 10], 7 => [7]}␤»\n\n\nIn this case, every number in the range is classified in as many bins as it\ncan be divided by.","classify\n\nDefined as:\n\n    multi method classify()\n    multi method classify(Whatever)\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nThe two first forms will fail. The rest include a $test, which is a\nfunction that will return a scalar for every input; these will be used as\nkeys of a hash whose values will be arrays with the elements that output\nthat key for the test function.\n\n    my @years = (2003..2008).map( { Date.new( $_~\"-01-01\" ) } );\n    @years.classify( *.is-leap-year , into => my %leap-years );\n    say %leap-years;\n    # OUTPUT: «{False => [2003-01-01 2005-01-01 2006-01-01 2007-01-01],\n    #           True => [2004-01-01 2008-01-01]}␤»\n\n\nSimilarly to .categorize, elements can be normalized by the Callable passed\nwith the :as argument, and it can use the :into named argument to pass a\nHash the results will be classified into; in the example above, it's\ndefined on the fly.\n\nFrom version 6.d, .classify will also work with Junctions.","reduce\n\nDefined as:\n\n    multi method reduce(Any:U: & --> Nil)\n    multi method reduce(Any:D: &with)\n    multi sub reduce (&with, +list)\n\nApplying it to a class will always produce Nil. Applies its argument (or\nfirst argument, in case it's a sub) as an operator to all the elements in\nthe object (or second argument), producing a single result. The argument\nmust be an infix operator or take, in any case, two positional arguments.\n\n    (1..13).reduce( &[*] ).say; # OUTPUT: «6227020800␤»","produce\n\nDefined as:\n\n    multi method produce(Any:U: & --> Nil)\n    multi method produce(Any:D: &with)\n    multi sub produce (&with, +list)\n\nThis is similar to reduce, but returns a list with the accumulated values\ninstead of a single result.\n\n    <10 5 3>.reduce( &[*] ).say ; # OUTPUT: «150␤»\n    <10 5 3>.produce( &[*] ).say; # OUTPUT: «(10 50 150)␤»\n\n\nThe last element of the produced list would be the output produced by the\n.reduce method.\n\nIf it's a class, it will simply return Nil.","pairs\n\nDefined as:\n\n    multi method pairs(Any:U:)\n    multi method pairs(Any:D:)\n\nReturns an empty List if the invocant is a type object:\n\n    say Num.pairs; # OUTPUT: «()␤»\n\nFor a value object, it converts the invocant to a List via the list method\nand returns the result of List.pairs on it.\n\n    <1 2 2 3 3 3>.Bag.pairs.say;# OUTPUT: «(1 => 1 3 => 3 2 => 2)␤»\n\nIn this case, every element (with weight) in a bag is converted to a pair.","antipairs\n\nDefined as:\n\n    multi method antipairs(Any:U:)\n    multi method antipairs(Any:D:)\n\nReturns an empty List if the invocant is a type object\n\n    Range.antipairs.say; # OUTPUT: «()␤»\n\nIf it's a value object, it returns the inverted list of pairs after\nconverting it to a list of pairs; the values will become keys and the other\nway round.\n\n    %(s => 1, t=> 2, u => 3).antipairs.say ;# OUTPUT: «(2 => t 1 => s 3 => u)␤»","invert\n\nDefined as:\n\n    multi method invert(Any:U:)\n    multi method invert(Any:D:)\n\nApplied to a type object will return an empty list; applied to an object\nwill convert it to a list and apply List.invert to it, that is, interchange\nkey with value in every Pair. The resulting list needs to be a list of\nPairs.\n\n    \"aaabbcccc\".comb.Bag.invert.say; # OUTPUT: «(4 => c 3 => a 2 => b)␤»\n\nIn this case, a Bag can be converted to a list of Pairs. If the result of\nconverting the object to a list is not a list of pairs, the method will\nfail.","kv\n\nDefined as:\n\n    multi method kv(Any:U:)\n    multi method kv(Any:D:)\n    multi sub    kv($x)\n\nReturns an empty List if the invocant is a type object:\n\n    Sub.kv.say ;# OUTPUT: «()␤»\n\nIt calls list on the invocant for value objects and returns the result of\nList.kv on it as a list where keys and values will be ordered and\ncontiguous\n\n    <1 2 3>.kv.say; # OUTPUT: «(0 1 1 2 2 3)␤»\n\nIn the case of Positionals, the indices will be considered keys.","toggle\n\nDefined as:\n\n    method toggle(Any:D: *@conditions where .all ~~ Callable:D, Bool :$off  --> Seq:D)\n\nIterates over the invocant, producing a Seq, toggling whether the received\nvalues are propagated to the result on and off, depending on the results of\ncalling Callables in @conditions:\n\n    say (1..15).toggle(* < 5, * > 10, * < 15); # OUTPUT: «(1 2 3 4 11 12 13 14)␤»\n    say (1..15).toggle(:off, * > 2, * < 5, * > 10, * < 15); # OUTPUT: «(3 4 11 12 13 14)␤»\n\n\nImagine a switch that's either on or off (True or False), and values are\nproduced if it's on. By default, the initial state of that switch is in\n\"on\" position, unless :$off is set to a true value, in which case the\ninitial state will be \"off\".\n\nA Callable from the head of @conditions is taken (if any are available) and\nit becomes the current tester. Each value from the original sequence is\ntested by calling the tester Callable with that value. The state of our\nimaginary switch is set to the return value from the tester: if it's\ntruthy, set switch to \"on\", otherwise set it to \"off\".\n\nWhenever the switch is toggled (i.e. switched from \"off\" to \"on\" or from\n\"on\" to \"off\"), the current tester Callable is replaced by the next\nCallable in @conditions, if available, which will be used to test any\nfurther values. If no more tester Callables are available, the switch will\nremain in its current state until the end of iteration.\n\n    # our original sequence of elements:\n    say list ^10; # OUTPUT: «(0 1 2 3 4 5 6 7 8 9)␤»\n    # toggled result:\n    say ^10 .toggle: * < 4, * %% 2, &is-prime; # OUTPUT: «(0 1 2 3 6 7)␤»\n\n    # First tester Callable is `* < 4` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 < 4 === True  switch is on, value gets into result, switch is\n    #                      toggled, so we keep using the same Callable:\n    # 1 => 1 < 4 === True  same\n    # 2 => 2 < 4 === True  same\n    # 3 => 3 < 4 === True  same\n    # 4 => 4 < 4 === False switch is now off, \"4\" does not make it into the\n    #                      result. In addition, our switch got toggled, so\n    #                      we're switching to the next tester Callable\n    # 5 => 5 %% 2 === False  switch is still off, keep trying to find a value\n    # 6 => 6 %% 2 === True   switch is now on, take \"6\" into result. The switch\n    #                        toggled, so we'll use the next tester Callable\n    # 7 => is-prime(7) === True  switch is still on, take value and keep going\n    # 8 => is-prime(8) === False switch is now off, \"8\" does not make it into\n    #                            the result. The switch got toggled, but we\n    #                            don't have any more tester Callables, so it\n    #                            will remain off for the rest of the sequence.\n\n\nSince the toggle of the switch's state loads the next tester Callable,\nsetting :$off to a True value affects when first tester is discarded:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: * > 1; # OUTPUT: «()␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"on\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                      In addition, switch got toggled, so we change the\n    #                      tester Callable, and since we don't have any more\n    #                      of them, the switch will remain \"off\" until the end\n\n\nThe behavior changes when :off is used:\n\n    # our original sequence of elements:\n    say <0 1 2>; # OUTPUT: «(0 1 2)␤»\n    # toggled result:\n    say <0 1 2>.toggle: :off, * > 1; # OUTPUT: «(2)␤»\n\n    # First tester Callable is `* > 1` and initial state of switch is \"off\".\n    # As we iterate over our original sequence:\n    # 0 => 0 > 1 === False  switch is off, \"0\" does not make it into result.\n    #                       The switch did NOT get toggled this time, so we\n    #                       keep using our current tester Callable\n    # 1 => 1 > 1 === False  same\n    # 2 => 2 > 1 === True   switch is on, \"2\" makes it into the result","head\n\nDefined as:\n\n    multi method head(Any:D:) is raw\n    multi method head(Any:D: Callable:D $w)\n    multi method head(Any:D: $n)\n\nReturns either the first element in the object, or the first $n if that's\nused.\n\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «c␉1␤»\n    \"aaabbc\".comb.Mix.head.put; # OUTPUT: «a␉3␤»\n    say ^10 .head(5);           # OUTPUT: «(0 1 2 3 4)␤»\n    say ^∞ .head(5);            # OUTPUT: «(0 1 2 3 4)␤»\n    say ^10 .head;              # OUTPUT: «0␤»\n    say ^∞ .head;               # OUTPUT: «0␤»\n\nIn the first two cases, the results are different since there's no defined\norder in Mixes. In the other cases, it returns a Seq. A Callable can be\nused to return all but the last elements:\n\n    say (^10).head( * - 3 );# OUTPUT: «(0 1 2 3 4 5 6)␤»","tail\n\nDefined as:\n\n    multi method tail() is raw\n    multi method tail($n)\n\nReturns the last or the list of the $n last elements of an object. $n can\nbe a Callable, usually a WhateverCode, which will be used to get all but\nthe first n elements of the object.\n\n    say (^12).reverse.tail ;     # OUTPUT: «0␤»\n    say (^12).reverse.tail(3);   # OUTPUT: «(2 1 0)␤»\n    say (^12).reverse.tail(*-7); # OUTPUT: «(4 3 2 1 0)␤»","tree\n\nDefined as:\n\n    multi method tree(Any:U:)\n    multi method tree(Any:D:)\n    multi method tree(Any:D: Whatever )\n    multi method tree(Any:D: Int(Cool) $count)\n    multi method tree(Any:D: @ [&first, *@rest])\n    multi method tree(Any:D: &first, *@rest)\n\nReturns the class if it's undefined or if it's not Iterable, returns the\nresult of applying the tree method to its invocant otherwise.\n\n    say Any.tree; # OUTPUT: «Any␤»\n\n.tree has different prototypes for Iterable elements.\n\n    my @floors = ( 'A', ('B','C', ('E','F','G')));\n    say @floors.tree(1).flat.elems; # OUTPUT: «6␤»\n    say @floors.tree(2).flat.elems; # OUTPUT: «2␤»\n    say @floors.tree( *.join(\"-\"),*.join(\"—\"),*.join(\"|\"));# OUTPUT: «A-B—C—E|F|G␤»\n\n\nWith a number, it iteratively applies tree to every element in the lower\nlevel; the first instance will apply .tree(0) to every element in the\narray, and likewise for the next example.\n\nThe second prototype applies the Whatever code passed as arguments to every\nlevel in turn; the first argument will go to level 1 and so on. tree can,\nthus, be a great way to process complex all levels of complex, multi-level,\ndata structures.","nl-out\n\nDefined as:\n\n    method nl-out(--> Str)\n\nReturns Str with the value of \"\\n\". See IO::Handle.nl-out for the details.\n\n    Num.nl-out.print;     # OUTPUT: «␤»\n    Whatever.nl-out.print;# OUTPUT: «␤»\n    33.nl-out.print;      # OUTPUT: «␤»","combinations\n\nDefined as:\n\n    method combinations(|c)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.combinations on it.\n\n    say (^3).combinations; # OUTPUT: «(() (0) (1) (2) (0 1) (0 2) (1 2) (0 1 2))␤»","grep\n\nDefined as:\n\n    method grep(Mu $matcher, :$k, :$kv, :$p, :$v --> Seq)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.grep on it.\n\nBased on $matcher value can be either ((Any)) or empty List.\n\n    my $a;\n    say $a.grep({ True }); # OUTPUT: «((Any))␤»\n    say $a.grep({ $_ });   # OUTPUT: «()␤»","append\n\nDefined as:\n\n    multi method append(Any:U \\SELF: |values --> Array)\n\nIn the case the instance is not a positional-thing, it instantiates it as a\nnew Array, otherwise clone the current instance. After that, it appends the\nvalues passed as arguments to the array obtained calling Array.append on\nit.\n\n    my $a;\n    say $a.append; # OUTPUT: «[]␤»\n    my $b;\n    say $b.append((1,2,3)); # OUTPUT: «[1 2 3]␤»","values\n\nDefined as:\n\n    multi method values(Any:U:)\n    multi method values(Any:D:)\n\nWill return an empty list for undefined or class arguments, and the object\nconverted to a list otherwise.\n\n    say (1..3).values; # OUTPUT: «(1 2 3)␤»\n    say List.values;   # OUTPUT: «()␤»","collate\n\nDefined as:\n\n    method collate()\n\nCollate sorts taking into account Unicode grapheme characteristics; that\nis, sorting more or less as one would expect instead of using the order in\nwhich their codepoints appear. collate will behave this way if the object\nit is applied to is Iterable.\n\n    say ('a', 'Z').sort; # (Z a)\n    say ('a', 'Z').collate; # (a Z)\n    say <ä a o ö>.collate; # (a ä o ö)\n    my %hash = 'aa' => 'value', 'Za' => 'second';\n    say %hash.collate; # (aa => value Za => second);\n\n\nThis method is affected by the $*COLLATION variable, which configures the\nfour collation levels. While the Primary, Secondary and Tertiary mean\ndifferent things for different scripts, for the Latin script used in\nEnglish they mostly correspond with Primary being Alphabetic, Secondary\nbeing Diacritics and Tertiary being Case.\n\nIn the example below you can see how when we disable tertiary collation\nwhich in Latin script generally is for case, and also disable quaternary\nwhich breaks any ties by checking the codepoint values of the strings, we\nget Same back for A and a:\n\n    $*COLLATION.set(:quaternary(False), :tertiary(False));\n    say 'a' coll 'A'; #OUTPUT: «Same␤»\n    say ('a','A').collate == ('A','a').collate; # OUTPUT: «True␤»\n\nThe variable affects the coll operator as shown as well as this method.","cache\n\nDefined as:\n\n    method cache()\n\nProvides a List representation of the object itself, calling the method\nlist on the instance.","batch\n\nDefined as:\n\n    multi method batch(Int:D $batch)\n    multi method batch(Int:D :$elems!)\n\nCoerces the invocant to a list by applying its .list method and uses\nList.batch on it.","rotor\n\nDefined as:\n\n    multi method rotor(Any:D: Int:D $batch, :$partial)\n    multi method rotor(Any:D: *@cycle, :$partial)\n\nGroups the elements of the object in lists of $batch elements.\n\n    say (3..9).rotor(3); # OUTPUT: «((3 4 5) (6 7 8))␤»\n\nWith the :partial named argument, it will also include lists that do not\nget to be the $batch size:\n\n    say (3..10).rotor(3, :partial); # OUTPUT: «((3 4 5) (6 7 8) (9 10))␤»\n\n.rotor can be called with an array of integers and pairs, which will be\napplied in turn. While integers will establish the batch size, as above,\nPairs will use the key as batch size and the value as number of elements to\nskip if it's positive, or overlap if it's negative.\n\n    say (3..11).rotor(3, 2 => 1, 3 => -2, :partial);\n    # OUTPUT: «((3 4 5) (6 7) (9 10 11) (10 11))␤»\n\nIn this case, the first batch (ruled by an integer) has 3 elements; the\nsecond one has 2 elements (key of the pair), but skips one (the number 8);\nthe third one has size 2 (because partials are allowed), and an overlap of\n2 also.\n\nPlease see also list.rotor for examples applied to lists.","sum\n\nDefined as:\n\n    method sum() is nodal\n\nIf the content is iterable, it returns the sum of the values after pulling\nthem one by one.\n\n    (3,2,1).sum; # OUTPUT: «6␤»\n    say 3.sum;   # OUTPUT: «3␤»\n\n\nIt will fail if any of the elements cannot be converted to a number."]},{"methods":[],"desc":"TITLE\nclass Macro\n\nSUBTITLE\nCompile-time routine\n\n    class Macro is Routine { }\n\nA macro is a Routine whose invocation typically happens during parsing. By\nreturning an AST, a macro can inject code into the calling location.","name":"Macro"},{"methods":["(in the case that the package is\nalso a class) have a separate method table, and are accessible through\nintrospection on the class itself, via .can and .^methods."],"desc":"TITLE\nclass Stash\n\nSUBTITLE\nTable for \"our\"-scoped symbols\n\n    class Stash is Hash { }\n\nA Stash is a hash that is used for symbol tables at the package scoping\nlevel in Raku.\n\nTo get a Stash, you can call the .WHO pseudo-method on a package (because\nit answers the question who lives here?), or if you write the package name\nas a literal, append two colons:\n\n    class Boring {\n        class Nested { };\n        our sub package_sub { }\n        my sub lexical { };\n        method a_method() { }\n    }\n    say Boring::.^name;             # OUTPUT: «Stash␤»\n    say Boring.WHO === Boring::;    # OUTPUT: «True␤»\n\nSince it inherits from Hash, you can use all the usual hash functionality:\n\n    say Boring::.keys.sort;         # OUTPUT: «(&package_sub Nested)␤»\n    say Boring::<Nested>;           # OUTPUT: «(Nested)␤»\n\n\nAs the example above shows only \"our\"-scoped things appear in the Stash\n(nested classes are \"our\" by default, but can be excluded with \"my\".)\nLexicals and methods are not included in a Stash, since they do not live in\nthe package table. Lexicals live in a separate lexical pad, which is only\nvisible from inside the scope. ","name":"Stash"},{"methods":["arch\n\n    method arch\n\nInstance method returning the \"arch\" (as in \"architecture\") information of\nthe Kernel object. Dies if the \"arch\" could not be established.","archname\n\n    method archname\n\nInstance method returning the concatenation of hardware and name.","bits\n\n    method bits\n\nInstance method returning the number of bits used in the architecture of\nthe processor. Usually 32 or 64.","cpu-cores\n\n    method cpu-cores(--> Int)\n\nInstance / Class method returning the number of CPU cores that are\navailable.\n\n    say $*KERNEL.cpu-cores; # OUTPUT: «8␤»","cpu-usage\n\n    method cpu-usage(--> Int)\n\nInstance / Class method returning the amount of CPU uses since the start of\nthe program (in microseconds).","free-memory\n\n    method free-memory(--> Int)\n\nInstance / Class method returning the available memory on the system. When\nusing the JVM, this returns the available memory to the JVM instead. This\nmethod is only available in release v2019.06 and later.","total-memory\n\n    method total-memory(--> Int)\n\nInstance / Class method returning the total memory available to the system.\nWhen using the JVM, this returns the total memory available to the JVM\ninstead. This method is only available in release v2019.06 and later.","endian\n\n    method endian(--> Endian:D)\n\nClass method that returns the Endian object associated with the kernel\narchitecture (either LittleEndian or BigEndian).","hardware\n\nDefined as\n\n    method hardware\n\nInstance method returning the hardware information of the Kernel object.\nDies if the hardware information could not be established.\n\n    say $*KERNEL.hardware; # OUTPUT: «x86_64␤»","hostname\n\n    method hostname\n\nInstance method returning the hostname of the Kernel object.","release\n\n    method release\n\nInstance method returning the release information of the Kernel object.\nDies if the release information could not be established.","signal\n\nDefined as:\n\n    multi method signal(Kernel:D: Str:D $signal --> Int:D)\n    multi method signal(Kernel:D: Signal:D \\signal --> Int:D)\n    multi method signal(Kernel:D: Int:D \\signal --> Int:D)\n\nInstance method returning the Signal numeric code for a given name for the\nKernel object.\n\n    say $*KERNEL.signal(\"INT\"); # OUTPUT: «2␤»","signals\n\nInstance method returning a list of Signals that are supported by the\nkernel represented by the Kernel object."],"desc":"TITLE\nclass Kernel\n\nSUBTITLE\nKernel related information\n\n    class Kernel does Systemic { }\n\nBuilt-in class for providing kernel related information. Usually accessed\nthrough the $*KERNEL dynamic variable.\n\n","name":"Kernel"},{"name":"Promise","desc":"TITLE\nclass Promise\n\nSUBTITLE\nStatus/result of an asynchronous computation\n\n    my enum PromiseStatus (:Planned(0), :Kept(1), :Broken(2));\n    class Promise {}\n\nA Promise is used to handle the result of a computation that might not have\nfinished. It allows the user to execute code once the computation is done\n(with the then method), execution after a time delay (with in), combining\npromises, and waiting for results.\n\n    my $p = Promise.start({ sleep 2; 42});\n    $p.then({ say .result });   # will print 42 once the block finished\n    say $p.status;              # OUTPUT: «Planned␤»\n    $p.result;                  # waits for the computation to finish\n    say $p.status;              # OUTPUT: «Kept␤»\n\nThere are two typical scenarios for using promises. The first is to use a\nfactory method (start, in, at, anyof, allof, kept, broken) on the type\nobject; those will make sure that the promise is automatically kept or\nbroken for you, and you can't call break or keep on these promises\nyourself.\n\nThe second is to create your promises yourself with Promise.new. If you\nwant to ensure that only your code can keep or break the promise, you can\nuse the vow method to get a unique handle, and call keep or break on it:\n\n    sub async-get-with-promise($user-agent, $url) {\n        my $p = Promise.new;\n        my $v = $p.vow;\n\n        # do an asynchronous call on a fictive user agent,\n        # and return the promise:\n        $user-agent.async-get($url,\n                on-error => -> $error {\n                    $v.break($error);\n                },\n                on-success => -> $response {\n                    $v.keep($response);\n                }\n        );\n        return $p;\n    }\n\n\nFurther examples can be found in the concurrency page.\n\n","methods":["start\n\n    method start(Promise:U: &code, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that runs the given code object. The promise will be\nkept when the code terminates normally, or broken if it throws an\nexception. The return value or exception can be inspected with the result\nmethod.\n\nThe scheduler that handles this promise can be passed as a named argument.\n\nThere is also a statement prefix start that provides syntactic sugar for\nthis method:\n\n    # these two are equivalent:\n    my $p1 = Promise.start({ ;#`( do something here ) });\n    my $p2 = start { ;#`( do something here ) };\n\nAs of the 6.d version of the language, start statement prefix used in sink\ncontext will automatically attach an exceptions handler. If an exception\noccurs in the given code, it will be printed and the program will then\nexit, like if it were thrown without any start statement prefixes\ninvolved.\n\n    use v6.c;\n    start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n\n    use v6.d;\n    start { die }; sleep ⅓; say \"hello\";\n    # OUTPUT:\n    # Unhandled exception in code scheduled on thread 4\n    # Died\n    #     in block  at -e line 1\n\n\nIf you wish to avoid this behavior, use start in non-sink context or catch\nthe exception yourself:\n\n    # Don't sink it:\n    my $ = start { die }; sleep ⅓; say \"hello\"; # OUTPUT: «hello␤»\n\n    # Catch yourself:\n    start { die; CATCH { default { say \"caught\" } } };\n    sleep ⅓;\n    say \"hello\";\n    # OUTPUT: «caught␤hello␤»\n\n\nThis behavior exists only syntactically, by using an alternate .sink method\nfor Promise objects created by start blocks in sink context, thus simply\nsinking a Promise object that was created by other means won't trigger this\nbehavior.","in\n\n    method in(Promise:U: $seconds, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that will be kept in $seconds seconds, or later.\n\n    my $proc = Proc::Async.new('perl6', '-e', 'sleep 10; warn \"end\"');\n\n    my $result = await Promise.anyof(\n        my $promise = $proc.start,  # may or may not work in time\n        Promise.in(5).then: {       # fires after 5 seconds no matter what\n            unless $promise {       # don't do anything if we were successful\n                note 'timeout';\n                $proc.kill;\n            }\n        }\n    ).then: { $promise.result }\n    # OUTPUT: «timeout␤»\n\n$seconds can be fractional or negative. Negative values are treated as 0\n(i.e. keeping the returned Promise right away).\n\nPlease note that situations like these are often more clearly handled with\na react and whenever block.","at\n\n    method at(Promise:U: $at, :$scheduler = $*SCHEDULER --> Promise:D)\n\nCreates a new Promise that will be kept $at the given time—which is given\nas an Instant or equivalent Numeric—or as soon as possible after it.\n\n    my $p = Promise.at(now + 2).then({ say \"2 seconds later\" });\n    # do other stuff here\n\n    await $p;   # wait here until the 2 seconds are over\n\nIf the given time is in the past, it will be treated as now (i.e. keeping\nthe returned Promise right away).\n\nPlease note that situations like these are often more clearly handled with\na react and whenever block.","kept\n\n    multi method kept(Promise:U: \\result = True --> Promise:D)\n\nReturns a new promise that is already kept, either with the given value, or\nwith the default value True.","broken\n\n    multi method broken(Promise:U: --> Promise:D)\n    multi method broken(Promise:U: \\exception --> Promise:D)\n\nReturns a new promise that is already broken, either with the given value,\nor with the default value X::AdHoc.new(payload => \"Died\")","allof\n\n    method allof(Promise:U: *@promises --> Promise:D)\n\nReturns a new promise that will be kept when all the promises passed as\narguments are kept or broken. The result of the individual Promises is not\nreflected in the result of the returned promise: it simply indicates that\nall the promises have been completed in some way. If the results of the\nindividual promises are important then they should be inspected after the\nallof promise is kept.\n\nIn the following requesting the result of a broken promise will cause the\noriginal Exception to be thrown. (You may need to run it several times to\nsee the exception.)\n\n    my @promises;\n    for 1..5 -> $t {\n        push @promises, start {\n            sleep $t;\n        };\n    }\n    my $all-done = Promise.allof(@promises);\n    await $all-done;\n    @promises>>.result;\n    say \"Promises kept so we get to live another day!\";","anyof\n\n    method anyof(Promise:U: *@promises --> Promise:D)\n\nReturns a new promise that will be kept as soon as any of the promises\npassed as arguments is kept or broken. The result of the completed Promise\nis not reflected in the result of the returned promise which will always be\nKept.\n\nYou can use this to wait at most a number of seconds for a promise:\n\n    my $timeout = 5;\n    await Promise.anyof(\n        Promise.in($timeout),\n        start {\n            # do a potentially long-running calculation here\n        },\n    );","then\n\n    method then(Promise:D: &code)\n\nSchedules a piece of code to be run after the invocant has been kept or\nbroken, and returns a new promise for this computation. In other words,\ncreates a chained promise.\n\n    my $timer = Promise.in(2);\n    my $after = $timer.then({ say \"2 seconds are over!\"; 'result' });\n    say $after.result;  # 2 seconds are over\n                        # result","keep\n\n    multi method keep(Promise:D: \\result = True)\n\nKeeps a promise, optionally setting the result. If no result is passed, the\nresult will be True.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    if Bool.pick {\n        $p.keep;\n    }\n    else {\n         $p.break;\n    }","break\n\n    multi method break(Promise:D: \\cause = False)\n\nBreaks a promise, optionally setting the cause. If no cause is passed, the\ncause will be False.\n\nThrows an exception of type X::Promise::Vowed if a vow has already been\ntaken. See method vow for more information.\n\n    my $p = Promise.new;\n\n    $p.break('sorry');\n    say $p.status;          # OUTPUT: «Broken␤»\n    say $p.cause;           # OUTPUT: «sorry␤»","result\n\n    method result(Promise:D)\n\nWaits for the promise to be kept or broken. If it is kept, returns the\nresult; otherwise throws the result as an exception.","cause\n\n    method cause(Promise:D)\n\nIf the promise was broken, returns the result (or exception). Otherwise,\nthrows an exception of type X::Promise::CauseOnlyValidOnBroken.","Bool\n\n    multi method Bool(Promise:D:)\n\nReturns True for a kept or broken promise, and False for one in state\nPlanned.","status\n\n    method status(Promise:D --> PromiseStatus)\n\nReturns the current state of the promise: Kept, Broken or Planned:\n\n    say \"promise got Kept\" if $promise.status ~~ Kept;","scheduler\n\n    method scheduler(Promise:D:)\n\nReturns the scheduler that manages the promise.","vow\n\n    my class Vow {\n        has Promise $.promise;\n        method keep() { ... }\n        method break() { ... }\n    }\n    method vow(Promise:D: --> Vow:D)\n\n\nReturns an object that holds the sole authority over keeping or breaking a\npromise. Calling keep or break on a promise that has vow taken throws an\nexception of type X::Promise::Vowed.\n\n    my $p   = Promise.new;\n    my $vow = $p.vow;\n    $vow.keep($p);\n    say $p.status;          # OUTPUT: «Kept␤»","Supply\n\n    method Supply(Promise:D:)\n\nReturns a Supply that will emit the result of the Promise being Kept or\nquit with the cause if the Promise is Broken.\n\n  sub await\n\n    multi sub await(Promise:D --> Promise)\n    multi sub await(*@ --> Array)\n\nWaits until one or more promises are all fulfilled, and then returns their\nvalues. Also works on channels. Any broken promises will rethrow their\nexceptions. If a list is passed it will return a list containing the\nresults of awaiting each item in turn."]},{"name":"Mix","methods":["Bag\n\nDefined as:\n\n    method Bag (--> Bag:D)\n\nCoerces the Mix to a Bag. The weights are convert to Int, which means the\nnumber of keys in the resulting Bag can be fewer than in the original Mix,\nif any of the weights are negative or truncate to zero.","BagHash\n\nDefined as:\n\n    method BagHash (--> BagHash:D)\n\nCoerces the Mix to a BagHash. The weights are convert to Int, which means\nthe number of keys in the resulting BagHash can be fewer than in the\noriginal Mix, if any of the weights are negative or truncate to zero.","reverse\n\nNote: This method is inherited from Any, however, Mixes do not have an\ninherent order and you should not trust it returning a consistent output.\n\n  Note on order\n\nSame as the other elements in the Bag/Mix suite, order is not guaranteed or\nconsistent and you shouldn't rely on methods like reverse above returning\nalways the same result.\n\nSee Also\n\nSets, Bags, and Mixes"],"desc":"TITLE\nclass Mix\n\nSUBTITLE\nImmutable collection of distinct objects with Real weights\n\n    class Mix does Mixy { }\n\nA Mix is an immutable collection of distinct elements in no particular\norder that each have a real-number weight assigned to them. (For mutable\nmixes, see MixHash instead.)\n\nMixes are often used for performing weighted random selections - see\n.roll.\n\nObjects/values of any type are allowed as mix elements. Within a Mix, items\nthat would compare positively with the === operator are considered the same\nelement, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixes can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the corresponding numeric weight for keys that are elements\nof the mix, and 0 for keys that aren't:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).Mix;\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\nCreating Mix objects\n\nMixes can be composed using the mix subroutine (or Mix.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the mix - with a weight of 1 for each time the parameter\noccurred:\n\n    my $n = mix \"a\", \"a\", \"b\" => 0, 3.14, π, π; # The Pair is a single element\n    say $n.keys.map: *.^name; # OUTPUT: «(Rat Pair Num Str)␤»\n    say $n.pairs;\n    # OUTPUT: «(3.14 => 1 (b => 0) => 1 3.141592653589793 => 2 a => 2)␤»\n\nAlternatively, the .Mix coercer (or its functional form, Mix()) can be\ncalled on an existing object to coerce it to a Mix. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a mix with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the mix, and the (cumulative) values become the associated numeric\nweights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).Mix;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nElements with a 0 value, as b above, are simply eliminated from the Mix.\n\nAlternatively, since Mixes are Associative, we can use the % sigil to\ndeclare them; in that case, we can employ is to declare their type:\n\n    my %n is Mix = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14);\n    say %n.^name; # OUTPUT: «Mix␤»\n    say %n;       # OUTPUT: «Mix(a(2), c(3.14))␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a Mix. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = Mix[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %m is Mix[Str] = <a b b c c c>;\n    say %m<b>;  # 2\n    say %m<d>;  # 0\n\n    # only allow whole numbers\n    my %m is Mix[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nMixes can use all kind of set operators returning either Bool or other\nMixes:\n\n    my $this-mix = (sugar => ⅓, spice => ¼, all-things-nice => ¾);\n    my $that-mix = ( sugar => 1, spice => 2);\n\n    say $that-mix (<) $this-mix;     # OUTPUT: «True␤»\n    say $that-mix (^) $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix (+) $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nWith their equivalent Unicode operators:\n\n    say $that-mix ⊂ $this-mix;     # OUTPUT: «True␤»\n    say $that-mix ⊖ $this-mix;     # OUTPUT: «set(all-things-nice)␤»\n    say $that-mix ⊎ $this-mix;     # OUTPUT: «Bag(spice(2), sugar)␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\n  sub mix\n\n    sub mix(*@args --> Mix)\n\nCreates a new Mix from @args.\n\n"},{"methods":["new\n\n    method new(Str:D $s)\n\nCreates a Version from a string $s. The string is combed for the numeric,\nalphabetic, and wildcard components of the version object. Any characters\nother than alphanumerics and asterisks are assumed to be equivalent to a\ndot. A dot is also assumed between any adjacent numeric and alphabetic\ncharacters.","parts\n\n    method parts(Version:D: --> List:D)\n\nReturns the list of parts that make up this Version object\n\n    my $v1 = v1.0.1;\n    my $v2 = v1.0.1+;\n    say $v1.parts;                                    # OUTPUT: «(1 0 1)␤»\n    say $v2.parts;                                    # OUTPUT: «(1 0 1)␤»\n\nThe + suffix is not considered a part of the Version object, and thus not\nreturned by this method, as shown above in the $v2 variable.","plus\n\n    method plus(Version:D: --> Bool:D)\n\nReturns True if comparisons against this version allow larger versions\ntoo.\n\n    my $v1 = v1.0.1;\n    my $v2 = v1.0.1+;\n    say $v1.plus;                                     # OUTPUT: «False␤»\n    say $v2.plus;                                     # OUTPUT: «True␤»","Str\n\n    method Str(Version:D: --> Str:D)\n\nReturns a string representation of the invocant.\n\n    my $v1 = v1.0.1;\n    my $v2 = Version.new('1.0.1');\n    say $v1.Str;                                      # OUTPUT: «1.0.1␤»\n    say $v2.Str;                                      # OUTPUT: «1.0.1␤»","gist\n\n    method gist(Version:D: --> Str:D)\n\nReturns a string representation of the invocant, just like Str, prepended\nwith a lower-case v.\n\n    my $v1 = v1.0.1;\n    my $v2 = Version.new('1.0.1');\n    say $v1.gist;                                      # OUTPUT: «v1.0.1␤»\n    say $v2.gist;                                      # OUTPUT: «v1.0.1␤»","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture."],"desc":"TITLE\nclass Version\n\nSUBTITLE\nModule version descriptor\n\n    class Version { }\n\nVersion objects identify version of software components (and potentially\nother entities). Raku uses them internally for versioning modules.\n\nA version consists of several parts, which are visually represented by\njoining them with a dot. A version part is usually an integer, a string\nlike alpha, or a Whatever-star *. The latter is used to indicate that any\nversion part is acceptable in another version that is compared to the\ncurrent one.\n\n    say v1.0.1 ~~ v1.*;     # OUTPUT: «True␤»\n    say v1.0.1 ~~ v1.*.1;   # OUTPUT: «True␤»\n\nThe first part of version literals contains v and a number; this might be\nfollowed by alphanumeric and Whatever parts and trailed by +. Multiple\nparts are separate with a dot .. A trailing + indicates that higher\nversions are OK in comparisons:\n\n    say v1.2 ~~ v1.0;                 # OUTPUT: «False␤»\n    say v1.2 ~~ v1.0+;                # OUTPUT: «True␤»\n    say v0.and.anything.else ~~ v0+;  # OUTPUT: «True␤»\n\nIn comparisons, order matters, and every part is compared in turn.\n\n    say v1.2 cmp v2.1;      # OUTPUT: «Less␤»\n\nThe + suffix is always taken into account in comparisons:\n\n    say v1.0.1+ <=> v1.0.1; # OUTPUT: «More␤»\n\nAnd * (Whatever) is too, and considered always Less than whatever digit is\nin the corresponding part, even if * is trailed by +:\n\n    say v1.* <=> v1.0;      # OUTPUT: «Less␤»\n    say v1.* <= v1.0;       # OUTPUT: «True␤»\n    say v1.*+ <= v1.0;      # OUTPUT: «True␤»\n\nPlease note that method calls, including pseudo methods like WHAT, require\nversion literals either to be enclosed with parentheses or use some other\nmethod to separate them from the dot that denotes a method call, like in\nthese examples:\n\n    say (v0.and.some.*.stuff).parts;  # OUTPUT: «(0 and some * stuff)␤»\n    say v0.and.some.*.stuff .parts;   # OUTPUT: «(0 and some * stuff)␤»\n\n","name":"Version"},{"name":"Sequence","methods":["TBD"],"desc":"TITLE\nclass Sequence\n\nSUBTITLE\nOperations for higher-level sequences\n\n    class Sequence does PositionalBindFailover { }\n\nA Sequence implements a series of methods for converting hight-level Seqs\ninto different types of objects, from positional to other.\n\n"},{"name":"Rat","desc":"TITLE\nclass Rat\n\nSUBTITLE\nRational number (limited-precision)\n\n    class Rat is Cool does Rational[Int, uint64] { }\n\nRat objects store rational numbers as a pair of a numerator and\ndenominator. Number literals with a dot but without exponent produce Rats.\n\n    say 3.1;          # OUTPUT: «3.1␤»      (same as: Rat.new(31, 10))\n    say 3.1.^name;    # OUTPUT: «Rat␤»\n    say 3.1.nude;     # OUTPUT: «(31 10)␤»\n\n    say <1/2>;        # OUTPUT: «0.5␤»      (same as: Rat.new(1, 2))\n    say <1/2>.^name;  # OUTPUT: «Rat␤»\n    say <1/2>.nude;   # OUTPUT: «(1 2)␤»\n\nThus arithmetic with short dotted-decimal numbers does not suffer from\nfloating point errors.\n\nTo prevent the numerator and denominator from becoming pathologically\nlarge, the denominator is limited to 64 bit storage. On overflow of the\ndenominator a Num (floating-point number) is returned instead.\n\nFor example this function crudely approximates a square root, and overflows\nthe denominator quickly:\n\n    sub approx-sqrt($n, $iterations) {\n        my $x = $n;\n        $x = ($x + $n / $x) / 2 for ^$iterations;\n        return $x;\n    }\n    say approx-sqrt(2, 5).^name;     # OUTPUT: «Rat␤»\n    say approx-sqrt(2, 10).^name;    # OUTPUT: «Num␤»\n\nIf you want arbitrary precision arithmetic with rational numbers, use the\nFatRat type instead.\n\nRat objects are immutable.\n\n","methods":["perl\n\n    multi method perl(Rat:D: --> Str:D)\n\nReturns an implementation-specific string that produces an equivalent\nobject when given to EVAL.\n\n    say (1/3).perl;                # OUTPUT: «<1/3>␤»\n    say (2/4).perl;                # OUTPUT: «0.5␤»"]},{"name":"Scheduler","methods":["uncaught_handler\n\n    method uncaught_handler() is rw\n\nRW-Accessor for the handler that is caught for uncaught exceptions from the\ncode that is being scheduled and run.","cue\n\n    method cue(&code, Instant :$at, :$in, :$every, :$times = 1; :&catch --> Cancellation)\n\nSchedules a callable (&code) for execution and returns an instantiated\nCancellation object to cancel the scheduling of the code for execution\n(which is especially important if you specify the every = time> named\nparameter. The adverbs control when and how the code is run:\n\n$at can be an Instant before which the code won't be run. Alternatively $in\nis the number of seconds (possibly fractional) to wait before running the\ncode. If $at is in the past or $in is negative, the delay is treated as\nzero. Implementations may equate to zero very small values (e.g. lower than\n0.001s) of $in or result of $at - now.\n\nIf $every is specified, it is interpreted as the number of seconds\n(possibly fractional) to wait before re-executing the code. Implementations\nmay treat too-small values as lowest resolution they support, possibly\nwarning in such situations; e.g. treating 0.0001 as 0.001.\n\n$times tells the scheduler how many times to run the code.\n\n&catch is called with the Exception as its sole argument if &code dies.\n\nIf $at or $in are Inf, &code will never be run; if $every is Inf, &code\nwill only be run once. If any of the three are -Inf, &code will be run\nimmediately. If any of the three are NaN, an X::Scheduler::CueInNaNSeconds\nexception will be thrown. This only applies to releases 2019.05 and later.\n\nOne should call the cancel method on the returned Cancellation object to\ncancel the (possibly repeated) cueing of the code."],"desc":"TITLE\nrole Scheduler\n\nSUBTITLE\nScheme for automatically assigning tasks to threads\n\n    role Scheduler {\n        has &.uncaught_handler is rw\n    }\n\nCommon role for schedulers. A scheduler is a piece of code that determines\nwhich resources to use to run which task, and when.\n\nSome operations for example on Proc::Async, Promise, Supply allow you to\nspecify a scheduler explicitly; they generally expect those schedulers to\nfollow the interface defined by Scheduler\n\n"},{"name":"Submethod","desc":"TITLE\nclass Submethod\n\nSUBTITLE\nMember function that is not inherited by subclasses\n\n    class Submethod is Routine {}\n\nA Submethod is a method that is not inherited by child classes. They are\ntypically used for per-class initialization and tear-down tasks which are\ncalled explicitly per class in an inheritance tree, usually for enforcing a\nparticular order. For example object construction with the BUILD submethod\nhappens from the least-derived to most-derived, so that the most-derived\n(child) classes can depend on the parent already being initialized.\n\nSubmethods are of type Submethod, and are declared with the submethod\ndeclarator:\n\n    class Area {\n        has $.size;\n        submethod BUILD(:$x, :$y, :$z) {\n            $!size = $x * $y * $z;\n        }\n    }\n\n","methods":["gist\n\nDefined as:\n\n    multi method gist(Submethod:D:)\n\nReturns the name of the submethod."]},{"name":"RaceSeq","methods":["iterator\n\n    method iterator(RaceSeq:D: --> Iterator:D)\n\nReturns the underlying iterator.","grep\n\n    method grep(RaceSeq:D: $matcher, *%options)\n\nApplies grep to the RaceSeq similarly to how it would do it on a Seq.\n\n    my @raced = (^10000).map(*²).race;\n    @raced.grep( * %% 3 ).say;\n    # OUTPUT: «(0 9 36 81 144 …»\n\n\nWhen you use race on a Seq, this is the method that is actually called.","map\n\n    method map(RaceSeq:D: $matcher, *%options)\n\nUses maps on the RaceSeq, generally created by application of .race to a\npreexisting Seq.","invert\n\n    method invert(RaceSeq:D:)\n\nInverts the RaceSeq created from a Seq by .race.","race\n\n    method race(RaceSeq:D:)\n\nReturns the object.","hyper\n\n    method hyper(RaceSeq:D:)\n\nCreates a HyperSeq object out of the current one.","serial\n\n    multi method serial(RaceSeq:D:)\n\nConverts the object to a Seq and returns it.","is-lazy\n\n    method is-lazy(--> False )\n\nReturns False.","sink\n\nDefined as:\n\n    method sink(--> Nil)\n\nSinks the underlying data structure, producing any side effects."],"desc":"TITLE\nclass RaceSeq\n\nSUBTITLE\nPerforms batches of work in parallel without respecting original order.\n\n    class RaceSeq does Iterable does Sequence { }\n\nAn RaceSeq is the intermediate object used when the operator race is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n"},{"methods":["new\n\n    method new(Rat $i, Str $s)\n\nThe constructor requires both the Rat and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = RatStr.new(42.1, \"forty two and a bit\");\n    say +$f; # OUTPUT: «42.1␤»\n    say ~$f; # OUTPUT: «\"forty two and a bit\"␤»","Bool\n\nDefined as:\n\n    multi method Bool(RatStr:D: --> Bool:D)\n\nThis method may be provided by the parent classes and not implemented in\nRatStr directly.\n\nReturns False if the numerator of the numeric portion is 0, otherwise\nreturns True. This applies for < 0/0 > zero-denominator RatStr as well,\ndespite ?< 0/0 >.Num being True. String portion is not considered.","Capture\n\nDefined as:\n\n    method Capture(RatStr:D --> Capture:D)\n\nEquivalent to Mu.Capture.","Numeric\n\nDefined as:\n\n    multi method Numeric(RatStr:D: --> Rat:D)\n    multi method Numeric(RatStr:U: --> Rat:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0.0.","Rat\n\n    method Rat\n\nReturns the Rat value of the RatStr.","Real\n\nDefined as:\n\n    multi method Real(Real:D: --> Rat:D)\n    multi method Real(Real:U: --> Rat:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0.0.","Str\n\nReturns the string value of the RatStr.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(RatStr:D: Any:D $value)\n\nIf $value is Numeric (including another allomorph), checks if invocant's\nNumeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str\npart ACCEPTS the $value. If value is anything else, checks if both Numeric\nand Str parts ACCEPTS the $value.\n\n    say <5.0> ~~ \"5\"; # OUTPUT: «False␤»\n    say <5.0> ~~  5 ; # OUTPUT: «True␤»\n    say <5.0> ~~ <5>; # OUTPUT: «True␤»"],"desc":"TITLE\nclass RatStr\n\nSUBTITLE\nDual value rational number and string\n\n    class RatStr is Rat is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1>; say $f.^name; # OUTPUT: «RatStr␤»\n\nAs a subclass of both Rat and Str, a RatStr will be accepted where either\nis expected. However, RatStr does not share object identity with Rat- or\nStr-only variants:\n\n    my $rat-str = <42.1>;\n    my Rat $rat = $rat-str; # OK!\n    my Str $str = $rat-str; # OK!\n    say 42.1 ∈ <42.1  55  1>; # False; ∈ operator cares about object identity\n\n","name":"RatStr"},{"name":"Range","desc":"TITLE\nclass Range\n\nSUBTITLE\nInterval of ordered values\n\n    class Range is Cool does Iterable does Positional {}\n\nRanges serve two main purposes: to generate lists of consecutive numbers or\nstrings, and to act as a matcher to check if a number or string is within a\ncertain range.\n\nRanges are constructed using one of the four possible range operators,\nwhich consist of two dots, and optionally a caret which indicates that the\nendpoint marked with it is excluded from the range.\n\n    1 .. 5;  # 1 <= $x <= 5\n    1^.. 5;  # 1 <  $x <= 5\n    1 ..^5;  # 1 <= $x <  5\n    1^..^5;  # 1 <  $x <  5\n\nThe caret is also a prefix operator for constructing numeric ranges\nstarting from zero:\n\n    my $x = 10;\n    say ^$x;     # same as 0 ..^ $x.Numeric\n\nIterating a range (or calling the list method) uses the same semantics as\nthe ++ prefix and postfix operators, i.e., it calls the succ method on the\nstart point, and then the generated elements.\n\nRanges always go from small to larger elements; if the start point is\nbigger than the end point, the range is considered empty.\n\n    for 1..5 { .say };       # OUTPUT: «1␤2␤3␤4␤5␤»\n    ('a' ^..^ 'f').list;     # RESULT: «'b', 'c', 'd', 'e'»\n    5 ~~ ^5;                 # RESULT: «False»\n    4.5 ~~ 0..^5;            # RESULT: «True»\n    (1.1..5).list;           # RESULT: «(1.1, 2.1, 3.1, 4.1)»\n\nUse the ... sequence operator to produce lists of elements that go from\nlarger to smaller values, or to use offsets other than increment-by-1 and\nother complex cases.\n\nUse ∞ or * (Whatever) to indicate an end point to be open-ended.\n\n    for 1..* { .say };       # start from 1, continue until stopped\n    for 1..∞ { .say };       # the same\n\n\nBeware that a WhateverCode end point, instead of a plain Whatever, will go\nthrough the range operator and create another WhateverCode which returns a\nRange:\n\n    # A Whatever produces the 1..Inf range\n    say (1..*).^name;        # OUTPUT: «Range␤»\n    say (1..*);              # OUTPUT: «1..Inf␤»\n    # Upper end point is now a WhateverCode\n    say (1..*+20).^name;     # OUTPUT: «{ ... }␤»\n    say (1..*+20).WHAT;      # OUTPUT: «(WhateverCode)␤»\n    say (1..*+20).(22);      # OUTPUT: «1..42␤»\n\n\nRanges implement Positional interface, so its elements can be accessed\nusing an index. In a case when the index given is bigger than the Range\nobject's size, Nil object will be returned. The access works for lazy Range\nobjects as well.\n\n    say (1..5)[1];  # OUTPUT: «2␤»\n    say (1..5)[10]; # OUTPUT: «Nil␤»\n    say (1..*)[10]; # OUTPUT: «11␤»\n\n\n  Ranges in subscripts\n\nA Range can be used in a subscript to get a range of values. Please note\nthat assigning a Range to a scalar container turns the Range into an item.\nUse binding, @-sigiled containers or a slip to get what you mean.\n\n    my @numbers =  <4 8 15 16 23 42>;\n    my $range := 0..2;\n    .say for @numbers[$range]; # OUTPUT: «4␤8␤15␤»\n    my @range = 0..2;\n    .say for @numbers[@range]; # OUTPUT: «4␤8␤15␤»\n\n  Shifting and scaling intervals\n\nIt is possible to shift or scale the interval of a range:\n\n    say (1..10) + 1;       # OUTPUT: «2..11␤»\n    say (1..10) - 1;       # OUTPUT: «0..9␤»\n    say (1..10) * 2;       # OUTPUT: «2..20␤»\n    say (1..10) / 2;       # OUTPUT: «0.5..5.0␤»\n\n  Matching against Ranges\n\nYou can use smartmatch to match against Ranges.\n\n    say 3 ~~ 1..12;          # OUTPUT: «True␤»\n    say 2..3 ~~ 1..12;       # OUTPUT: «True␤»\n\n In Rakudo only, you can use the in-range method for matching against a\nrange, which in fact is equivalent to smartmatch except it will throw an\nexception when out of range, instead of returning False:\n\n    say ('א'..'ת').in-range('ע');  # OUTPUT: «True␤»\n\nHowever, if it is not included in the range:\n\n    say ('א'..'ת').in-range('p', \"Letter 'p'\");\n    # OUTPUT: «(exit code 1) Letter 'p' out of range. Is: \"p\", should be in \"א\"..\"ת\"␤\n\n\nThe second parameter to in-range is the optional message that will be\nprinted with the exception. It will print Value by default.\n\n","methods":["ACCEPTS\n\nDefined as\n\n    multi method ACCEPTS(Range:D: Mu \\topic)\n    multi method ACCEPTS(Range:D: Range \\topic)\n    multi method ACCEPTS(Range:D: Cool:D \\got)\n    multi method ACCEPTS(Range:D: Complex:D \\got)\n\nIndicates if the Range contains (overlaps with) another Range. As an\nexample:\n\n    my $p = Range.new( 3, 5  );\n    my $r = Range.new( 1, 10 );\n\n    say $p.ACCEPTS( $r );    # OUTPUT: «False␤»\n    say $r.ACCEPTS( $p );    # OUTPUT: «True␤»\n    say $r ~~ $p;            # OUTPUT: «False␤»  (same as $p.ACCEPTS( $r )\n    say $p ~~ $r;            # OUTPUT: «True␤»   (same as $r.ACCEPTS( $p )\n\nOf course, an infinite Range always contains another Range, therefore:\n\n    say 1..10 ~~ -∞..∞;    # OUTPUT: «True␤»\n    say 1..10 ~~ -∞^..^∞;  # OUTPUT: «True␤»\n\nSimilarly, a Range with open boundaries often includes other ranges:\n\n    say 1..2 ~~ *..10;  # OUTPUT: «True␤»\n    say 2..5 ~~ 1..*;   # OUTPUT: «True␤»\n\nIt is also possible to use non-numeric ranges, for instance string based\nones:\n\n    say 'a'..'j' ~~ 'b'..'c';  # OUTPUT: «False␤»\n    say 'b'..'c' ~~ 'a'..'j';  # OUTPUT: «True␤»\n    say 'perl' ~~ -∞^..^∞;     # OUTPUT: «True␤»\n    say 'perl' ~~ -∞..∞;       # OUTPUT: «True␤»\n    say 'perl' ~~ 1..*;        # OUTPUT: «True␤»\n\nWhen smartmatching a Range of integers with a Cool (string) the ACCEPTS\nmethods exploits the before and after operators in order to check that the\nCool value is overlapping the range:\n\n    say 1.10 ~~ '5';   # OUTPUT: «False␤»\n    say '5' before 1;  # OUTPUT: «False␤»\n    say '5' after 10;  # OUTPUT: «True␤»\n    say '5' ~~ *..10;  # OUTPUT: «False␤»\n\nIn the above example, since the '5' string is after the 10 integer value,\nthe Range does not overlap with the specified value.\n\nWhen matching with a Mu instance (i.e., a generic instance), the cmp\noperator is used.","min\n\n    method min(Range:D:)\n\nReturns the start point of the range.\n\n    say (1..5).min;                                   # OUTPUT: «1␤»\n    say (1^..^5).min;                                 # OUTPUT: «1␤»","excludes-min\n\n    method excludes-min(Range:D: --> Bool:D)\n\nReturns True if the start point is excluded from the range, and False\notherwise.\n\n    say (1..5).excludes-min;                          # OUTPUT: «False␤»\n    say (1^..^5).excludes-min;                        # OUTPUT: «True␤»","max\n\n    method max(Range:D:)\n\nReturns the end point of the range.\n\n    say (1..5).max;                                   # OUTPUT: «5␤»\n    say (1^..^5).max;                                 # OUTPUT: «5␤»","excludes-max\n\n    method excludes-max(Range:D: --> Bool:D)\n\nReturns True if the end point is excluded from the range, and False\notherwise.\n\n    say (1..5).excludes-max;                          # OUTPUT: «False␤»\n    say (1^..^5).excludes-max;                        # OUTPUT: «True␤»","bounds\n\n    method bounds()\n\nReturns a list consisting of the start and end point.\n\n    say (1..5).bounds;                                # OUTPUT: «(1 5)␤»\n    say (1^..^5).bounds;                              # OUTPUT: «(1 5)␤»","infinite\n\n    method infinite(Range:D: --> Bool:D)\n\nReturns True if either end point was declared with ∞ or *.\n\n    say (1..5).infinite;                              # OUTPUT: «False␤»\n    say (1..*).infinite;                              # OUTPUT: «True␤»","is-int\n\n    method is-int(Range:D: --> Bool:D)\n\nReturns True if both end points are Int values.\n\n    say ('a'..'d').is-int;                            # OUTPUT: «False␤»\n    say (1..^5).is-int;                               # OUTPUT: «True␤»\n    say (1.1..5.5).is-int;                            # OUTPUT: «False␤»","int-bounds\n\n    proto method int-bounds(|)\n    multi method int-bounds()\n    multi method int-bounds($from is rw, $to is rw)\n\nIf the Range is an integer range (as indicated by is-int), then this method\nreturns a list with the first and last value it will iterate over (taking\ninto account excludes-min and excludes-max). Returns a Failure if it is not\nan integer range.\n\n    say (2..5).int-bounds;                            # OUTPUT: «(2 5)␤»\n    say (2..^5).int-bounds;                           # OUTPUT: «(2 4)␤»\n\nIf called with (writable) arguments, these will take the the values of the\nhigher and lower bound:\n\n    (3..5).int-bounds( my $min, my $max);\n    say \"$min, $max\" ; # OUTPUT: «3, 5␤»","minmax\n\nDefined as:\n\n    multi method minmax(Range:D: --> List:D)\n\nIf the Range is an integer range (as indicated by is-int), then this method\nreturns a list with the first and last value it will iterate over (taking\ninto account excludes-min and excludes-max). If the range is not an integer\nrange, the method will return a two element list containing the start and\nend point of the range unless either of excludes-min or excludes-max are\nTrue in which case a Failure is returned.\n\n    my $r1 = (1..5); my $r2 = (1^..5);\n    say $r1.is-int, ', ', $r2.is-int;                 # OUTPUT: «True, True␤»\n    say $r1.excludes-min, ', ', $r2.excludes-min;     # OUTPUT: «False, True␤»\n    say $r1.minmax, ', ', $r2.minmax;                 # OUTPUT: «(1 5), (2 5)␤»\n\n    my $r3 = (1.1..5.2); my $r4 = (1.1..^5.2);\n    say $r3.is-int, ', ', $r4.is-int;                 # OUTPUT: «False, False␤»\n    say $r3.excludes-max, ', ', $r4.excludes-max;     # OUTPUT: «False, True␤»\n    say $r3.minmax;                                   # OUTPUT: «(1.1 5.2)␤»\n    say $r4.minmax;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::AdHoc: Cannot return minmax on Range with excluded ends␤»","elems\n\n    method elems(Range:D: --> Numeric:D)\n\nReturns the number of elements in the range, e.g. when being iterated over,\nor when used as a List. Returns Inf if either end point was specified as\nInf or *.\n\n    say (1..5).elems;                                 # OUTPUT: «5␤»\n    say (1^..^5).elems;                               # OUTPUT: «3␤»","list\n\n    method list(Range:D: --> List:D)\n\nGenerates the list of elements that the range represents.\n\n    say (1..5).list;                                  # OUTPUT: «(1 2 3 4 5)␤»\n    say (1^..^5).list;                                # OUTPUT: «(2 3 4)␤»","flat\n\n    method flat(Range:D: --> List:D)\n\nGenerates the list of elements that the range represents.","pick\n\n    multi method pick(Range:D:         --> Any:D)\n    multi method pick(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.pick, but attempts to optimize by\nnot actually generating the list if it is not necessary.","roll\n\n    multi method roll(Range:D:         --> Any:D)\n    multi method roll(Range:D: $number --> Seq:D)\n\nPerforms the same function as Range.list.roll, but attempts to optimize by\nnot actually generating the list if it is not necessary.","sum\n\n    multi method sum(--> Numeric:D)\n\nReturns the sum of all elements in the Range. Throws X::Str::Numeric if an\nelement can not be coerced into Numeric.\n\n    (1..10).sum                                       # 55","reverse\n\n    method reverse(Range:D: --> Seq:D)\n\nReturns a Seq where all elements that the Range represents have been\nreversed. Note that reversing an infinite Range won't produce any\nmeaningful results.\n\n    say (1^..5).reverse;                            # OUTPUT: «(5 4 3 2)␤»\n    say ('a'..'d').reverse;                         # OUTPUT: «(d c b a)␤»\n    say (1..∞).reverse;                             # OUTPUT: «(Inf Inf Inf ...)␤»","Capture\n\nDefined as:\n\n    method Capture(Range --> Capture:D)\n\nReturns a Capture with values of .min .max, .excludes-min, .excludes-max,\n.infinite, and .is-int as named arguments.","rand\n\nDefined as:\n\n    method rand(Range:D --> Num:D)\n\nReturns a pseudo-random value belonging to the range.\n\n    say (1^..5).rand;                              # OUTPUT: «1.02405550417031␤»\n    say (0.1..0.3).rand;                           # OUTPUT: «0.2130353370062␤»","EXISTS-POS\n\nDefined as\n\n    multi method EXISTS-POS(Range:D: int \\pos)\n    multi method EXISTS-POS(Range:D: Int \\pos)\n\nReturns True if pos is greater or equal than zero and lower than\nself.elems. Returns False otherwise.\n\n    say (6..10).EXISTS-POS(2); # OUTPUT: «True␤»\n    say (6..10).EXISTS-POS(7); # OUTPUT: «False␤»","AT-POS\n\nDefined as\n\n    multi method AT-POS(Range:D: int \\pos)\n    multi method AT-POS(Range:D: int:D \\pos)\n\nChecks if the Int position exists and in that case returns the element in\nthat position.\n\n    say (1..4).AT-POS(2) # OUTPUT: «3␤»","perl\n\nDefined as\n\n    multi method perl(Range:D:)\n\nReturns an implementation-specific string that produces an equivalent\nobject when given to EVAL.\n\n    say (1..2).perl # OUTPUT: «1..2␤»","fmt\n\nDefined as\n\n    method fmt(|c)\n\nReturns a string where min and max in the Range have been formatted\naccording to |c.\n\nFor more information about formats strings, see sprintf.\n\n    say (1..2).fmt(\"Element: %d\", \",\") # OUTPUT: «Element: 1,Element: 2␤»","WHICH\n\nDefined as\n\n    multi method WHICH (Range:D:)\n\nThis returns a string that identifies the object. The string is composed by\nthe type of the instance (Range) and the min and max attributes:\n\n    say (1..2).WHICH # OUTPUT: «Range|1..2␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+>(Range:D \\r, Real:D \\v)\n    multi sub infix:<+>(Real:D \\v, Range:D \\r)\n\nTakes an Real and adds that number to both boundaries of the Range object.\nBe careful with the use of parenthesis.\n\n    say (1..2) + 2; # OUTPUT: «3..4␤»\n    say 1..2 + 2;   # OUTPUT: «1..4␤»\n\n  sub infix:<->\n\n    multi sub infix:<->(Range:D \\r, Real:D \\v)\n\nTakes an Real and subtract that number to both boundaries of the Range\nobject. Be careful with the use of parenthesis.\n\n    say (1..2) - 1; # OUTPUT: «0..1␤»\n    say 1..2 - 1;   # OUTPUT: «1..1␤»\n\n  sub infix:<*>\n\n    multi sub infix:<*>(Range:D \\r, Real:D \\v)\n    multi sub infix:<*>(Real:D \\v, Range:D \\r)\n\nTakes an Real and multiply both boundaries of the Range object by that\nnumber.\n\n    say (1..2) * 2; # OUTPUT: «2..4␤»\n\n  sub infix:</>\n\n    multi sub infix:</>(Range:D \\r, Real:D \\v)\n\nTakes an Real and divide both boundaries of the Range object by that\nnumber.\n\n    say (2..4) / 2; # OUTPUT: «1..2␤»\n\n  sub infix:<cmp>\n\n    multi sub infix:<cmp>(Range:D \\a, Range:D \\b --> Order:D)\n    multi sub infix:<cmp>(Num(Real) \\a, Range:D \\b --> Order:D)\n    multi sub infix:<cmp>(Range:D \\a, Num(Real) \\b --> Order:D)\n    multi sub infix:<cmp>(Positional \\a, Range:D \\b --> Order:D)\n    multi sub infix:<cmp>(Range:D \\a, Positional \\b --> Order:D)\n\nCompares two Range objects. If you use a Real, it will be compared to the\nRange b..b. If you use a Positional.\n\n    say (1..2) cmp (1..2); # OUTPUT: «Same␤»\n    say (1..2) cmp (1..3); # OUTPUT: «Less␤»\n    say (1..4) cmp (1..3); # OUTPUT: «More␤»\n    say (1..2) cmp 3;      # OUTPUT: «Less␤»\n    say (1..2) cmp [1,2];  # OUTPUT: «Same␤»"]},{"desc":"TITLE\nclass Tap\n\nSUBTITLE\nSubscription to a Supply\n\n    class Tap {}\n\nA Tap is a subscription to a Supply.\n\n    my $s = Supplier.new;\n    my $tap = $s.Supply.on-close({ say \"Tap closed\" }).tap(\n        -> $v { say \"the value is $v\" },\n        done    => { say \"Supply is done\" },\n        quit    => -> $ex { say \"Supply finished with error $ex\" },\n    );\n\n    # later\n    $tap.close;\n\n","methods":["close\n\n    method close(Tap:D:)\n\nCloses the tap."],"name":"Tap"},{"name":"PositionalBindFailover","methods":["cache\n\n    method cache(PositionalBindFailover:D: --> List:D)\n\nReturns a List based on the iterator method, and caches it. Subsequent\ncalls to cache always return the same List object.","list\n\n    method list(PositionalBindFailover:D: --> List:D)\n\nReturns a List based on the iterator method without caching it.","iterator\n\n    method iterator(PositionalBindFailover:D:) { ... }\n\nThis method stub ensure that a class implementing role\nPositionalBindFailover provides an iterator method."],"desc":"TITLE\nrole PositionalBindFailover\n\nSUBTITLE\nFailover for binding to a Positional\n\n    role PositionalBindFailover { ... }\n\nThis role provides an interface by which an object can be coerced into a\nPositional when binding to Positional parameters.\n\nFor example, Seq type is not Positional, but you can still write the\nfollowing, because it does PositionalBindFailover role:\n\n    sub fifths(@a) {        # @a is constraint to Positional\n        @a[4];\n    }\n    my $seq := gather {     # a Seq, which is not Positional\n        take $_ for 1..*;\n    }\n    say fifths($seq);       # OUTPUT: «5␤»\n\nThe invocation of fifths in the example above would ordinarily give a type\nerror, because $seq is of type Seq, which doesn't do the Positional\ninterface that the @-sigil implies.\n\nBut the signature binder recognizes that Seq does the\nPositionalBindFailover role, and calls its cache method to coerce it to a\nList, which does the Positional role.\n\nThe same happens with custom classes that do the role; they simply need to\nprovide an iterator method that produces an Iterator:\n\n    class Foo does PositionalBindFailover {\n        method iterator {\n            class :: does Iterator {\n                method pull-one {\n                    return 42 unless $++;\n                    IterationEnd\n                }\n            }.new\n        }\n    }\n\n    sub first-five (@a) { @a[^5].say }\n    first-five Foo.new; # OUTPUT: # OUTPUT: «(42 Nil Nil Nil Nil)␤»\n\n"},{"name":"SetHash","desc":"TITLE\nclass SetHash\n\nSUBTITLE\nMutable collection of distinct objects\n\n    class SetHash does Setty { }\n\nA SetHash is a mutable set, meaning a collection of distinct elements in no\nparticular order. (For immutable sets, see Set instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSetHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the value True for keys that are elements of the\nset, and False for keys that aren't. Assigning a value that boolifies to\nTrue or False, respectively, can be used to add or remove a set element:\n\n    my $fruits = <peach apple orange apple apple>.SetHash;\n\n    say $fruits<apple>;     # OUTPUT: «True␤»\n    say $fruits<kiwi>;      # OUTPUT: «False␤»\n\n    $fruits<apple kiwi> = False, True;\n    say $fruits.keys.sort;  # OUTPUT: «kiwi orange peach␤»\n\n\nHere is a convenient shorthand idiom for adding and removing SetHash\nelements:\n\n    my SetHash $fruits .= new;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<cherry>++;\n    say $fruits<cherry>;      # OUTPUT: «True␤»\n    $fruits<apple banana kiwi>»++; # Add multiple elements\n\n    $fruits<cherry>--;\n    say $fruits<cherry>;      # OUTPUT: «False␤»\n    $fruits<banana kiwi>»--; # Remove multiple elements\n\n\n\nCreating SetHash objects\n\nSetHashes can be composed using SetHash.new. Any positional parameters,\nregardless of their type, become elements of the set:\n\n    my $n = SetHash.new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .SetHash coercer (or its functional form, SetHash()) can\nbe called on an existing object to coerce it to a SetHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a set with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the set - and keys mapped to values which boolify to\nFalse are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).SetHash;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nIt is also possible to initialize a single key with the use of {}:\n\n    my $sh = SetHash.new;\n    $sh{ 'key1' } = True;\n    $sh{ 'key2' } = 'Hello World!';\n    $sh{ 'key3' } = 0;  # does not store the key since 0.Bool is False\n    say $sh;            # OUTPUT: «SetHash(key1 key2)␤»\n    say $sh.keys.perl;  # OUTPUT: «(\"key1\", \"key2\").Seq␤»\n\nor, in order to initialize more than one key at the same time, use a list\nassignment:\n\n    my $sh = SetHash.new;\n    $sh{ 'a', 'b', 'c' } = True, False, True;\n    say $sh.keys.perl;  # OUTPUT: «(\"a\", \"c\").Seq␤»\n\nYou can also create SetHash masquerading as a hash by using the is trait:\n\n    my %sh is SetHash = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a SetHash. This can either be done when\ncalling .new:\n\n    # only allow Pairs\n    my $n = SetHash[Pair].new: \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %sh is SetHash[Str] = <a b c>;\n    say %sh<a>;  # True\n    say %sh<d>;  # False\n\n    # only allow whole numbers\n    my %sh is SetHash[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set operators, which can take SetHashes (or any other\ncollections) as input, although result sets are returned as immutable Sets.\nFor example:\n\n    my ($a, $b) = SetHash.new(1, 2, 3), SetHash.new(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a (|) $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n    say $a ∪ $b;  # OUTPUT: «set(1, 2, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSee Also\n\nSets, Bags, and Mixes","methods":[]},{"name":"HyperSeq","desc":"TITLE\nclass HyperSeq\n\nSUBTITLE\nAn object for performing batches of work in parallel with ordered output\n\n    class HyperSeq does Iterable does Sequence { }\n\nAn HyperSeq is the intermediate object used when the operator hyper is\ninvoked on a Seq. In general, it's not intended for direct consumption by\nthe developer.\n\n","methods":["iterator\n\n    method iterator(HyperSeq:D: --> Iterator:D)\n\nReturns the underlying iterator.","grep\n\n    method grep(HyperSeq:D: $matcher, *%options)\n\nApplies grep to the HyperSeq similarly to how it would do it on a Seq.\n\n    my @hyped = (^10000).map(*²).hyper;\n    @hyped.grep( * %% 3 ).say;\n    # OUTPUT: «(0 9 36 81 144…»\n\n\nWhen you use hyper on a Seq, this is the method that is actually called.","map\n\n    method map(HyperSeq:D: $matcher, *%options)\n\nUses maps on the HyperSeq, generally created by application of hyper to a\npreexisting Seq.","invert\n\n    method invert(HyperSeq:D:)\n\nInverts the HyperSeq created from a Seq by .hyper.","hyper\n\n    method hyper(HyperSeq:D:)\n\nReturns the object.","race\n\n    method race(HyperSeq:D:)\n\nCreates a RaceSeq object out of the current one.","serial\n\n    multi method serial(HyperSeq:D:)\n\nConverts the object to a Seq and returns it.","is-lazy\n\n    method is-lazy(--> False )\n\nReturns False.","sink\n\nDefined as:\n\n    method sink(--> Nil)\n\nSinks the underlying data structure, producing any side effects."]},{"name":"Distro","desc":"TITLE\nclass Distro\n\nSUBTITLE\nDistribution related information\n\n    class Distro does Systemic { }\n\nBuilt-in class for providing distribution related information. Usually\naccessed through the $*DISTRO dynamic variable.\n\n","methods":["is-win\n\nInstance method returning a Bool indicating whether the distribution is a\nversion of the Windows operating system.","path-sep\n\nInstance method returning the string that can be used to delimit elements\nin a path specification.","release\n\nInstance method returning the release information of the Distro object.\nDies if the release information could not be established."]},{"name":"NumStr","methods":["new\n\n    method new(Num $i, Str $s)\n\nThe constructor requires both the Num and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = NumStr.new(42.1e0, \"forty two and a bit\");\n    say +$f; # OUTPUT: «42.1␤»\n    say ~$f; # OUTPUT: «\"forty two and a bit\"␤»","Bool\n\nDefined as:\n\n    multi method Bool(NumStr:D: --> Bool:D)\n\nThis method may be provided by the parent classes and not implemented in\nNumStr directly.\n\nReturns False if the invocant is numerically ±0e0, otherwise returns True.\nString portion is not considered.","Num\n\n    method Num\n\nReturns the Num value of the NumStr.","Numeric\n\nDefined as:\n\n    multi method Numeric(NumStr:D: --> Num:D)\n    multi method Numeric(NumStr:U: --> Num:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0e0.","Real\n\nDefined as:\n\n    multi method Real(NumStr:D: --> Num:D)\n    multi method Real(NumStr:U: --> Num:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0e0.","Str\n\nReturns the string value of the NumStr.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(NumStr:D: Any:D $value)\n\nIf $value is Numeric (including another allomorph), checks if invocant's\nNumeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str\npart ACCEPTS the $value. If value is anything else, checks if both Numeric\nand Str parts ACCEPTS the $value.\n\n    say <5e0> ~~ \"5.0\"; # OUTPUT: «False␤»\n    say <5e0> ~~  5.0 ; # OUTPUT: «True␤»\n    say <5e0> ~~ <5.0>; # OUTPUT: «True␤»"],"desc":"TITLE\nclass NumStr\n\nSUBTITLE\nDual value floating-point number and string\n\n    class NumStr is Num is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42.1e0>; say $f.^name; # OUTPUT: «NumStr␤»\n\nAs a subclass of both Num and Str, a NumStr will be accepted where either\nis expected. However, NumStr does not share object identity with Num- or\nStr-only variants:\n\n    my $num-str = <42e10>;\n    my Num $num = $num-str; # OK!\n    my Str $str = $num-str; # OK!\n    say 42e10 ∈ <42e10  55  1>; # False; ∈ operator cares about object identity\n\n"},{"name":"Rational","desc":"TITLE\nrole Rational\n\nSUBTITLE\nNumber stored as numerator and denominator\n\n    role Rational[::NuT, ::DeT] does Real { ... }\n\nRational is the common role for numbers that are stored as pairs of\nnumerator and denominator. It is parameterized by the types of the\nnumerator (NuT) and denominator (DeT). By default, these are Int, but other\ntypes of Rational are possible by using a different parameterization. In\naddition, Rational objects are immutable throughout their life.\n\n    class Positive does Rational[UInt] {};\n    my Positive $one-third = Positive.new(1,3);\n    say $one-third;                         # OUTPUT: «0.333333␤»\n    my Positive $fail =Positive.new(-2,3);  # OUTPUT: «Type check failed in binding to parameter 'nu'; expected UInt but got Int (-2)␤»\n\nPlease note that, since DeT is by default equal to NuT, in this case both\nare instantiated to UInt. Built into Raku are Rat and FatRat, which both do\nthe Rational role.\n\n","methods":["new\n\n        method new(NuT:D $numerator, DeT:D $denominator --> Rational:D)\n\n\nCreates a new rational object from numerator and denominator, which it\nnormalizes to the lowest terms. The $denominator can be zero, in which case\nthe numerator is normalized to -1, 0, or 1 depending on whether the\noriginal is negative, zero, or positive, respectively.","Bool\n\nDefined as:\n\n    multi method Bool(Rational:D: --> Bool:D)\n\nReturns False if numerator is 0, otherwise returns True. This applies for\n<0/0> zero-denominator Rational as well, despite ?<0/0>.Num being True.","Int\n\nDefined as:\n\n    method Int(Rational:D: --> Int:D)\n\nCoerces the invocant to Int by truncating non-whole portion of the\nrepresented number, if any. If the denominator is zero, will fail with\nX::Numeric::DivideByZero.","Num\n\nDefined as:\n\n    method Num(Rational:D: --> Num:D)\n\nCoerces the invocant to Num by dividing numerator by denominator. If\ndenominator is 0, returns Inf, -Inf, or NaN, based on whether numerator is\na positive number, negative number, or 0, respectively.","ceiling\n\nDefined as:\n\n    method ceiling(Rational:D: --> Int:D)\n\nReturn the smallest integer not less than the invocant. If denominator is\nzero, fails with X::Numeric::DivideByZero.","floor\n\nDefined as:\n\n    method floor(Rational:D: --> Int:D)\n\nReturn the largest integer not greater than the invocant. If denominator is\nzero, fails with X::Numeric::DivideByZero.","isNaN\n\n    method isNaN(Rational:D: --> Bool:D)\n\nTests whether the invocant's Num value is a NaN, an acronym for Not\navailable Number. That is both its numerator and denominator are zero.","numerator\n\n        method numerator(Rational:D: --> NuT:D)\n\n\nReturns the numerator.","denominator\n\n        method denominator(Rational:D: --> DeT:D)\n\n\nReturns the denominator.","nude\n\n    method nude(Rational:D: --> Positional)\n\nReturns a list of the numerator and denominator.","norm\n\n    method norm(Rational:D: --> Rational:D)\n\nDEPRECATED as of 6.d. The method is no longer needed, because as of 6.d\nlanguage version, it's required for Rational type to be normalized on\ncreation.\n\nReturns a normalized Rational object, i.e. with positive denominator, and\nnumerator and denominator coprime. The denominator can also by zero, but\nusing it in any operation or a conversion to string will result in an\nexception.\n\n    use v6.c;\n    my Rational $by-zero = 3/0;\n    say $by-zero.norm.perl; # OUTPUT: «<1/0>␤»\n\n\n    say $by-zero; # OUTPUT: «Attempt to divide by zero when coercing Rational to Str␤","base-repeating\n\n    method base-repeating(Rational:D: Int:D() $base = 10)\n\nReturns a list of two strings that, when concatenated, represent the number\nin base $base. The second element is the one that repeats. For example:\n\n    my ($non-rep, $repeating) = (19/3).base-repeating(10);\n    say $non-rep;                               # OUTPUT: «6.␤»\n    say $repeating;                             # OUTPUT: «3␤»\n    printf '%s(%s)', $non-rep, $repeating;      # OUTPUT: «6.(3)»\n\n19/3 is 6.333333... with the 3 repeating indefinitely.\n\nIf no repetition occurs, the second string is empty:\n\n    say (5/2).base-repeating(10).perl;          # OUTPUT: «(\"2.5\", \"\")␤»\n\nThe precision for determining the repeating group is limited to 1000\ncharacters, above that, the second string is ???.\n\n$base defaults to 10.","Range\n\nReturns a Range object that represents the range of values supported."]},{"name":"Proc","methods":["new\n\n    method new(Proc:U:\n            :$in = '-',\n            :$out = '-',\n            :$err = '-',\n            Bool :$bin = False,\n            Bool :$chomp = True,\n            Bool :$merge = False,\n            Str:D :$enc = 'UTF-8',\n            Str:D :$nl = \"\\n\",\n        --> Proc:D)\n\n    sub shell(\n            $cmd,\n            :$in = '-',\n            :$out = '-',\n            :$err = '-',\n            Bool :$bin = False,\n            Bool :$chomp = True,\n            Bool :$merge = False,\n            Str:D :$enc = 'UTF-8',\n            Str:D :$nl = \"\\n\",\n            :$cwd = $*CWD,\n            Hash() :$env = %*ENV\n        --> Proc:D)\n\n\nnew creates a new Proc object, whereas run or shell create one and spawn it\nwith the command and arguments provided in @args or $cmd, respectively.\n\n$in, $out and $err are the three standard streams of the to-be-launched\nprogram, and default to \"-\" meaning they inherit the stream from the parent\nprocess. Setting one (or more) of them to True makes the stream available\nas an IO::Pipe object of the same name, like for example $proc.out. You can\nset them to False to discard them. Or you can pass an existing IO::Handle\nobject (for example IO::Pipe) in, in which case this handle is used for the\nstream.\n\nPlease bear in mind that the process streams reside in process variables,\nnot in the dynamic variables that make them available to our programs.\nThus, modifying the dynamic filehandle variables (such as $*OUT) inside the\nhost process will have no effect in the spawned process, unlike $*CWD and\n$*ENV, whose changes will be actually reflected in it.\n\n    my $p-name = \"/tmp/program.p6\";\n    my $program = Q:to/END/;\n        #!/usr/bin/env perl6\n\n        $*OUT.say( qq/\\t$*PROGRAM: This goes to standard output/ );\n    END\n\n    spurt $p-name, $program;\n\n    $*OUT.put: \"1. standard output before doing anything weird\";\n\n    {\n        temp $*OUT = open '/tmp/out.txt', :w;\n        $*OUT.put: \"2. temp redefine standard output before this message\";\n        shell( \"perl6 $p-name\" ).so;\n    }\n\n    $*OUT.put: \"3. everything should be back to normal\";\n    # OUTPUT\n    # 1. standard output before doing anything weird\n    #     /tmp/program.p6: This goes to standard output\n    # 3. everything should be back to normal\n\n    # /tmp/out.txt will contain:\n    # 2. temp redefine standard output before this message\n\n\nThis program shows that the program spawned with shell is not using the\ntemporary $*OUT value defined in the host process (redirected to\n/tmp/out.txt), but the initial STDOUT defined in the process.\n\n$bin controls whether the streams are handled as binary (i.e. Blob object)\nor text (i.e. Str objects). If $bin is False, $enc holds the character\nencoding to encode strings sent to the input stream and decode binary data\nfrom the output and error streams.\n\nWith $chomp set to True, newlines are stripped from the output and err\nstreams when reading with lines or get. $nl controls what your idea of a\nnewline is.\n\nIf $merge is set to True, the standard output and error stream end up\nmerged in $proc.out.","sink\n\nDefined as:\n\n    method sink(--> Nil)\n\nWhen sunk, the Proc object will throw X::Proc::Unsuccessful if the process\nit ran exited unsuccessfully.\n\n    shell 'ls /qqq';\n    # OUTPUT: «(exit code 1) ls: cannot access '/qqq': No such file or directory␤The spawned command 'ls /qqq' exited unsuccessfully (exit code: 2)␤\n    n block <unit> at /tmp/3169qXElwq line 1␤␤»","spawn\n\n    method spawn(*@args ($, *@), :$cwd = $*CWD, Hash() :$env = %*ENV --> Bool:D)\n\nRuns the Proc object with the given command, argument list, working\ndirectory, and environment.","shell\n\n    method shell($cmd, :$cwd = $*CWD, :$env --> Bool:D)\n\nRuns the Proc object with the given command and environment which are\npassed through to the shell for parsing and execution. See shell for an\nexplanation of which shells are used by default in the most common\noperating systems.","command\n\n    method command(Proc:D: --> List:D)\n\nThe command method is an accessor to a list containing the arguments that\nwere passed when the Proc object was executed via spawn or shell or run.","pid\n\n    method pid()\n\nReturns the PID value of the process if available, or Nil.","exitcode\n\n    method exitcode(Proc:D: --> Int:D)\n\nReturns the exit code of the external process, or -1 if it has not exited\nyet.","signal\n\n    method signal(Proc:D:)\n\nReturns the signal number with which the external process was killed, or 0\nor an undefined value otherwise."],"desc":"TITLE\nclass Proc\n\nSUBTITLE\nRunning process (filehandle-based interface)\n\n    class Proc {}\n\nProc is a representation of an invocation of an external process. It\nprovides access to the input, output and error stream as well as the exit\ncode. It is typically created through the run subroutine:\n\n    my $proc = run 'echo', 'Hallo world', :out;\n    my $captured-output = $proc.out.slurp: :close;\n    say \"Output was $captured-output.perl()\";# OUTPUT: «Output was \"Hallo world\\n\"␤»\n\n\nPiping several commands is easy too. To achieve the equivalent of the pipe\necho \"Hello, world\" | cat -n in Raku, and capture the output from the\nsecond command, you can do\n\n    my $p1 = run 'echo', 'Hello, world', :out;\n    my $p2 = run 'cat', '-n', :in($p1.out), :out;\n    say $p2.out.get;\n\n\nYou can also feed the :in (standard input) pipe directly from your program,\nby setting it to True, which will make the pipe available via .in method on\nthe Proc:\n\n    my $p = run \"cat\", \"-n\", :in, :out;\n    $p.in.say: \"Hello,\\nworld!\";\n    $p.in.close;\n    say $p.out.slurp: :close;\n    # OUTPUT: «1  Hello,␤\n    #          2  world!␤»\n\n\nIn order to capture the standard error, :err can be supplied:\n\n    my $p = run \"ls\", \"-l\", \".\", \"qqrq\", :out, :err;\n    my $captured-output = $p.out.slurp: :close;\n    my $captured-error  = $p.err.slurp: :close;\n    my $exit-code       = $p.exitcode;\n\n\nIn sink context, a Proc will call its sink method, throwing an exception if\nthe process has exited with an exit code different from zero:\n\n    shell 'exit 1'\n    # OUTPUT: «(exit code 1) The spawned command 'exit 1' exited unsuccessfully (exit code: 1)␤»\n\n\nNote: Versions of Rakudo older than 2017.04 do not have .slurp available on\nIO::Pipe objects; use .slurp-rest instead.\n\nUse Proc::Async for non-blocking operations.\n\n"},{"methods":["new\n\n    method new(*@codes --> Uni:D)\n\nCreates a new Uni instance from the given codepoint numbers.","NFC\n\n    method NFC(Uni:D: --> NFC:D)\n\nReturns a NFC (Normal Form Composed)-converted version of the invocant.","NFD\n\n    method NFD(Uni:D: --> NFD:D)\n\nReturns a NFD (Normal Form Decomposed)-converted version of the invocant.","NFKC\n\n    method NFKC(Uni:D: --> NFKC:D)\n\nReturns a NFKC (Normal Form Compatibility Composed)-converted version of\nthe invocant.","NFKD\n\n    method NFKD(Uni:D: --> NFKD:D)\n\nReturns a NFKD (Normal Form Compatibility Decomposed)-converted version of\nthe invocant.","codes\n\n    method codes(Uni:D: --> Int:D)\n\nReturns the number of codepoints in the invocant.","elems\n\n    method elems(Uni:D: --> Int:D)\n\nReturns the number of codepoints in the invocant."],"desc":"TITLE\nclass Uni\n\nSUBTITLE\nA string of Unicode codepoints\n\n    class Uni does Positional[uint32] does Stringy { }\n\nUnlike Str, which is made of Grapheme clusters, Uni is string strictly made\nof Unicode codepoints. That is, base characters and combining characters\nare separate elements of a Uni instance.\n\nUni presents itself with a list-like interface of integer Codepoints.\n\nTypical usage of Uni is through one of its subclasses, NFC, NFD, NFKD and\nNFKC, which represent strings in one of the Unicode Normalization Forms of\nthe same name.\n\n","name":"Uni"},{"name":"Lock","methods":["protect\n\nDefined as:\n\n    method protect(Lock:D: &code)\n\nObtains the lock, runs &code, and releases the lock afterwards. Care is\ntaken to make sure the lock is released even if the code is left through an\nexception.\n\nNote that the Lock itself needs to be created outside the portion of the\ncode that gets threaded and it needs to protect. In the first example\nbelow, Lock is first created and assigned to $lock, which is then used\ninside the Promises to protect the sensitive code. In the second example, a\nmistake is made: the Lock is created right inside the Promise, so the code\nends up with a bunch of separate locks, created in a bunch of threads, and\nthus they don't actually protect the code we want to protect.\n\n    # Right: $lock is instantiated outside the portion of the\n    # code that will get threaded and be in need of protection\n    my $lock = Lock.new;\n    await ^20 .map: {\n        start {\n            $lock.protect: {\n                print \"Foo\";\n                sleep rand;\n                say \"Bar\";\n            }\n        }\n    }\n\n    # !!! WRONG !!! Lock is created inside threaded area!\n    await ^20 .map: {\n        start {\n            Lock.new.protect: {\n                print \"Foo\"; sleep rand; say \"Bar\";\n            }\n        }\n    }","lock\n\nDefined as:\n\n    method lock(Lock:D:)\n\nAcquires the lock. If it is currently not available, waits for it.\n\n    my $l = Lock.new;\n    $l.lock;\n\nSince a Lock is implemented using OS-provided facilities, a thread waiting\nfor the lock will not be scheduled until the lock is available for it.\nSince Lock is re-entrant, if the current thread already holds the lock,\ncalling lock will simply bump a recursion count.\n\nWhile it's easy enough to use the lock method, it's more difficult to\ncorrectly use unlock. Instead, prefer to use the protect method instead,\nwhich takes care of making sure the lock/unlock calls always both occur.","unlock\n\nDefined as:\n\n    method unlock(Lock:D:)\n\nReleases the lock.\n\n    my $l = Lock.new;\n    $l.lock;\n    $l.unlock;\n\nIt is important to make sure the Lock is always released, even if an\nexception is thrown. The safest way to ensure this is to use the protect\nmethod, instead of explicitly calling lock and unlock. Failing that, use a\nLEAVE phaser.\n\n    my $l = Lock.new;\n    {\n        $l.lock;\n        LEAVE $l.unlock;\n    }","condition\n\nDefined as:\n\n    my class ConditionVariable {\n        method wait();\n        method signal();\n        method signal_all();\n    }\n\n    method condition(Lock:D: --> ConditionVariable:D)\n\n\nReturns a condition variable. Compare\nhttps://web.stanford.edu/~ouster/cgi-bin/cs140-spring14/lecture.php?topic=locks\nor https://en.wikipedia.org/wiki/Monitor_%28synchronization%29 for\nbackground.\n\n    my $l = Lock.new;\n    $l.condition;"],"desc":"TITLE\nclass Lock\n\nSUBTITLE\nA low-level, re-entrant, mutual exclusion lock\n\n    class Lock {}\n\nA Lock is a low-level concurrency control construct. It provides mutual\nexclusion, meaning that only one thread may hold the lock at a time. Once\nthe lock is unlocked, another thread may then lock it.\n\nA Lock is typically used to protect access to one or more pieces of state.\nFor example, in this program:\n\n    my $x = 0;\n    my $l = Lock.new;\n    await (^10).map: {\n        start {\n            $l.protect({ $x++ });\n        }\n    }\n    say $x;         # OUTPUT: «10␤»\n\nThe Lock is used to protect operations on $x. An increment is not an atomic\noperation; without the lock, it would be possible for two threads to both\nread the number 5 and then both store back the number 6, thus losing an\nupdate. With the use of the Lock, only one thread may be running the\nincrement at a time.\n\nA Lock is re-entrant, meaning that a thread that holds the lock can lock it\nagain without blocking. That thread must unlock the same number of times\nbefore the lock can be obtained by another thread (it works by keeping a\nrecursion count).\n\nIt's important to understand that there is no direct connection between a\nLock and any particular piece of data; it is up to the programmer to ensure\nthat the Lock is held during all operations that involve the data in\nquestion. The OO::Monitors module, while not a complete solution to this\nproblem, does provide a way to avoid dealing with the lock explicitly and\nencourage a more structured approach.\n\nThe Lock class is backed by operating-system provided constructs, and so a\nthread that is waiting to acquire a lock is, from the point of view of the\noperating system, blocked.\n\nCode using high-level Raku concurrency constructs should avoid using Lock.\nWaiting to acquire a Lock blocks a real Thread, meaning that the thread\npool (used by numerous higher-level Raku concurrency mechanisms) cannot use\nthat thread in the meantime for anything else.\n\nAny await performed while a Lock is held will behave in a blocking manner;\nthe standard non-blocking behavior of await relies on the code following\nthe `await` resuming on a different Thread from the pool, which is\nincompatible with the requirement that a Lock be unlocked by the same\nthread that locked it. See Lock::Async for an alternative mechanism that\ndoes not have this shortcoming.\n\nBy their nature, Locks are not composable, and it is possible to end up\nwith hangs should circular dependencies on locks occur. Prefer to structure\nconcurrent programs such that they communicate results rather than modify\nshared data structures, using mechanisms like Promise, Channel and Supply.\n\n"},{"name":"Backtrace","desc":"TITLE\nclass Backtrace\n\nSUBTITLE\nSnapshot of the dynamic call stack\n\n    class Backtrace {}\n\nA backtrace contains the dynamic call stack, usually leading up to a point\nwhere an exception was thrown, and is a List of Backtrace::Frame objects.\nIts default stringification excludes backtrace frames that are deemed\nunnecessary or confusing; for example routines like &die are hidden by\ndefault. Being a list, you can also access individual elements.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try {\n        zipi;\n    }\n    if ($!) {\n        say $!.backtrace[*-1].perl;\n    }\n\n\nThis will print the last frame in the list, pointing at the line where it's\nhappened.\n\n","methods":["new\n\nDefined as:\n\n    multi method new()\n    multi method new(Int:D $offset)\n    multi method new(Mu \\ex)\n    multi method new(Mu \\ex, Int:D $offset)\n    multi method new(List:D $bt)\n    multi method new(List:D $bt, Int:D $offset)\n\nCreates a new backtrace, using its calling location as the origin of the\nbacktrace or the $offset that is passed as a parameter. If an object or a\nlist (that will already contain a backtrace in list form) is passed, they\nwill be used instead of the current code.\n\n    my $backtrace = Backtrace.new;","gist\n\nDefined as:\n\n    multi method gist(Backtrace:D:)\n\nReturns string \"Backtrace(42 frames)\" where the number indicates the number\nof frames available via list method.","Str\n\nDefined as:\n\n    multi method Str(Backtrace:D:)\n\nReturns a concise string representation of the backtrace, omitting routines\nmarked as is hidden-from-backtrace, and at the discretion of the\nimplementation, also some routines from the setting.\n\n    my $backtrace = Backtrace.new;\n    say $backtrace.Str;","next-interesting-index\n\nDefined as:\n\n    method next-interesting-index(Backtrace:D: Int $idx = 0, :$named, :$noproto, :$setting)\n\nReturns the index of the next interesting frame, once hidden and other\nsettings are taken into account. $named will decide whether to printed only\nthose with a name, $noproto will hide protos, and $setting will hide those\nare considered setting.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.next-interesting-index;           # OUTPUT: «2␤»\n    say $!.backtrace.next-interesting-index( :named ); #  OUTPUT: «4␤»","outer-caller-idx\n\nDefined as:\n\n    method outer-caller-idx(Backtrace:D: Int $startidx)\n\nReturns as a list the index of the frames that called the current one.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.outer-caller-idx( 4 ); # OUTPUT: «[6]␤»","nice\n\nDefined as:\n\n    method nice(Backtrace:D: :$oneline)\n\nReturns the backtrace as a list of interesting frames. If :$oneline is set,\nwill stop after the first frame.\n\n    sub zipi { { { die \"Something bad happened\" }() }() };\n    try zipi;\n    say $!.backtrace.nice( :oneline ) if $!;\n    # OUTPUT: «  in sub zipi at /tmp/... line 1␤␤»","full\n\nDefined as:\n\n    multi method full(Backtrace:D:)\n\nReturns a full string representation of the backtrace, including hidden\nframes, compiler-specific frames, and those from the setting.\n\n    my $backtrace = Backtrace.new;\n    say $backtrace.full;","list\n\nDefined as:\n\n    multi method list(Backtrace:D:)\n\nReturns a list of Backtrace::Frame objects for this backtrace.","summary\n\nDefined as:\n\n    method summary(Backtrace:D: --> Str:D)\n\nReturns a summary string representation of the backtrace, filtered by\n!.is-hidden && (.is-routine || !.is-setting).\n\nThis program:\n\n    sub inner { say Backtrace.new.summary }\n    sub outer { inner; }\n    outer;\n\nresults in:\n\n    in method new at SETTING::src/core/Backtrace.pm6 line 85\n    in sub inner at test.p6 line 1\n    in sub outer at test.p6 line 2\n    in block <unit> at test.p6 line 3","concise\n\nDefined as:\n\n    method concise(Backtrace:D:)\n\nReturns a concise string representation of the backtrace, filtered by\n!.is-hidden && .is-routine && !.is-setting.\n\nThis program:\n\n    sub inner { say Backtrace.new.concise }\n    sub outer { inner; }\n    outer;\n\nresults in:\n\n    in sub inner at test.p6 line 1\n    in sub outer at test.p6 line 2","map\n\nDefined as:\n\n    multi method map(Backtrace:D: &block --> Seq:D)\n\nIt invokes &block for each element and gathers the return values in a\nsequence and returns it.\n\nThis program:\n\n    sub inner { Backtrace.new.map({ say \"{$_.file}: {$_.line}\" }); }\n    sub outer { inner; }\n    outer;\n\nresults in:\n\n    SETTING::src/core/Backtrace.pm6: 85\n    SETTING::src/core/Backtrace.pm6: 85\n    test.p6: 1\n    test.p6: 2\n    test.p6: 3\n    test.p6: 1","flat\n\nDefined as:\n\n    multi method flat(Backtrace:D:)\n\nReturns the backtrace same as list."]},{"name":"ComplexStr","methods":["new\n\n    method new(Complex $i, Str $s)\n\nThe constructor requires both the Complex and the Str value, when\nconstructing one directly the values can be whatever is required:\n\n    my $f = ComplexStr.new(42+0i, \"forty two (but complicated)\");\n    say +$f; # OUTPUT: «42+0i␤»\n    say ~$f; # OUTPUT: «\"forty two (but complicated)\"␤»","Bool\n\nDefined as:\n\n    multi method Bool(ComplexStr:D: --> Bool:D)\n\nThis method may be provided by the parent classes and not implemented in\nComplexStr directly.\n\nReturns False if the invocant is numerically ±0±0i, otherwise returns True.\nString portion is not considered.","Capture\n\nDefined as:\n\n    method Capture(ComplexStr:D --> Capture:D)\n\nEquivalent to Mu.Capture.","Complex\n\n    method Complex\n\nReturns the Complex value of the ComplexStr.","Numeric\n\nDefined as:\n\n    multi method Numeric(ComplexStr:D: --> Complex:D)\n    multi method Numeric(ComplexStr:U: --> Complex:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value <0+0i>.","Real\n\nDefined as:\n\n    multi method Real(ComplexStr:D: --> Num:D)\n    multi method Real(ComplexStr:U: --> Num:D)\n\nCoerces the numeric portion of the invocant to Num. If the imaginary part\nisn't approximately zero, coercion fails with X::Numeric::Real.\n\nThe :D variant returns the result of that coercion. The :U variant issues a\nwarning about using an uninitialized value in numeric context and then\nreturns value 0e0.","Str\n\nReturns the string value of the ComplexStr.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(ComplexStr:D: Any:D $value)\n\nIf $value is Numeric (including another allomorph), checks if invocant's\nNumeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str\npart ACCEPTS the $value. If value is anything else, checks if both Numeric\nand Str parts ACCEPTS the $value.\n\n    say < 5+0i> ~~ \"5.0\"; # OUTPUT: «False␤»\n    say < 5+0i> ~~  5.0 ; # OUTPUT: «True␤»\n    say < 5+0i> ~~ <5.0>; # OUTPUT: «True␤»"],"desc":"TITLE\nclass ComplexStr\n\nSUBTITLE\nDual value complex number and string\n\n    class ComplexStr is Complex is Str {}\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42+0i>; say $f.^name; # OUTPUT: «ComplexStr␤»\n\nAs a subclass of both Complex and Str, a ComplexStr will be accepted where\neither is expected. However, ComplexStr does not share object identity with\nComplex- or Str-only variants:\n\n    my $complex-str = < 42+0i >;\n    my Complex $complex = $complex-str; # OK!\n    my Str     $str     = $complex-str; # OK!\n    say 42+0i ∈ <42+0i  55  1>; # False; ∈ operator cares about object identity\n\n"},{"methods":["new\n\n    method new()\n\nThe Supplier constructor.","Supply\n\n    method Supply(Supplier:D: --> Supply)\n\nThis creates a new Supply object to which any values which are emitted on\nthis supplier are passed. This is the factory for all live supplies.","emit\n\n    method emit(Supplier:D: Mu \\value)\n\nSends the given value to all of the taps on all of the supplies created by\nSupply on this Supplier.","done\n\n    method done(Supplier:D:)\n\nCalls the done callback on all the taps that have one.\n\n    my $supplier = Supplier.new;\n    my $supply   = $supplier.Supply;\n    $supply.tap(-> $v { say $v }, done => { say \"no more answers\" });\n    $supplier.emit(42);\n    $supplier.done;\n\nWill output:\n\n    42\n    no more answers","quit\n\n    multi method quit(Supplier:D: Exception $ex)\n    multi method quit(Supplier:D: Str() $message)\n\nCalls the quit callback on all the taps that have one, passing the\nexception to them. If called with a Str the exception will be an X::AdHoc\nwith the supplied message.\n\nThis is meant for shutting down a supply with an error."],"desc":"TITLE\nclass Supplier\n\nSUBTITLE\nLive Supply factory\n\n    class Supplier { }\n\nThis is a factory for live Supply objects, which provides the mechanism for\nemitting new values onto the supplies:\n\n    my $supplier = Supplier.new;\n    my $supply_1 = $supplier.Supply;\n    $supply_1.tap(-> $v { say \"One $v\" });\n    my $supply_2 = $supplier.Supply;\n    $supply_2.tap(-> $v { say \"Two $v\" });\n    $supplier.emit(42);\n\nWill output:\n\n    One 42\n    Two 42\n\n\non demand supplies are created by the factory methods of the Supply class\nor by the supply keyword. A mixture of a live and on-demand Supply can be\ncreated with a Supplier::Preserving.\n\n","name":"Supplier"},{"name":"List","desc":"TITLE\nclass List\n\nSUBTITLE\nSequence of values\n\n    my class List does Iterable does Positional { }\n\n\nList stores items sequentially and potentially lazily.\n\nIndexes into lists and arrays start at 0 by default.\n\nYou can assign to list elements if they are containers. Use Arrays to have\nevery value of the list stored in a container.\n\nList implements Positional and as such provides support for subscripts.\n\nItems, flattening and sigils\n\nIn Raku, assigning a List to a scalar variable does not lose information.\nThe difference is that iteration generally treats a list (or any other\nlist-like object, like a Seq or an Array) inside a scalar as a single\nelement.\n\n    my $s = (1, 2, 3);\n    for $s { }      # one iteration\n    for $s.list { } # three iterations\n\n    my $t = [1, 2, 3];\n    for $t { }      # one iteration\n    for $t.list { } # three iterations\n\n    my @a = 1, 2, 3;\n    for @a { }      # three iterations\n    for @a.item { } # one iteration\n\nThis operation is called itemization or putting in an item context. .item\ndoes the job for objects, as well as $( ... ) and, on array variables,\n$@a.\n\nLists generally don't interpolate (flatten) into other lists, except when\nthey are in list context and the single argument to an operation such as\nappend:\n\n    my $a = (1, 2, 3);\n    my $nested = ($a, $a);  # two elements\n\n    my $flat = $nested.map({ .Slip });  # six elements, with explicit Slip\n\n    my @b = <a b>;\n    @b.append: $a.list;     # The array variable @b has 5 elements, because\n                            # the list $a is the sole argument to append\n\n    say @b.elems;           # OUTPUT: «5␤»\n\n    my @c = <a b>;\n    @c.append: $a.list, 7;  # The array variable @c has 4 elements, because\n                            # the list $a wasn't the only argument and thus\n                            # wasn't flatten by the append operation\n\n    say @c.elems;           # OUTPUT: «4␤»\n\n    my @d = <a b>;\n    @d.append: $a;          # The array variable @d has 3 elements, because\n                            # $a is in an item context and as far as append is\n                            # concerned a single element\n\n    say @d.elems;           # OUTPUT: «3␤»\n\nThe same flattening behavior applies all objects that do the Iterable role,\nnotable hashes:\n\n    my %h = a => 1, b => 2;\n    my @b = %h;   say @b.elems;     # OUTPUT: «2␤»\n    my @c = %h, ; say @c.elems;     # OUTPUT: «1␤»\n    my @d = $%h;  say @d.elems;     # OUTPUT: «1␤»\n\nSlurpy parameters (*@a) flatten non-itemized sublists:\n\n    sub fe(*@flat) { @flat.elems }\n    say fe(<a b>, <d e>);           # OUTPUT: «4␤»\n    say fe(<a b>, <d e>.item);      # OUTPUT: «3␤»\n\n The empty list is created with (). Smartmatching against the empty list\nwill check for the absence of elements.\n\n    my @a;\n    for @a, @a.list, @a.Seq -> \\listoid {\n        say listoid ~~ ()\n    }\n    # OUTPUT: «True␤True␤True␤»\n\nCoercion to Bool also indicates if the List got any elements.\n\n    my @a;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[0 False False]␤»\n    @a.push: 42;\n    say [@a.elems, @a.Bool, ?@a]; # OUTPUT: «[1 True True]␤»\n    say 'empty' unless @a;        # no output\n\n","methods":["ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(List:D: $topic)\n\nIf $topic is an Iterable, returns True or False based on whether the\ncontents of the two Iterables match. A Whatever element in the invocant\nmatches anything in the corresponding position of the $topic Iterable. A\nHyperWhatever matches any number of any elements, including no elements:\n\n    say (1, 2, 3)       ~~ (1,  *, 3);  # OUTPUT: «True␤»\n    say (1, 2, 3)       ~~ (9,  *, 5);  # OUTPUT: «False␤»\n    say (1, 2, 3)       ~~ (   **, 3);  # OUTPUT: «True␤»\n    say (1, 2, 3)       ~~ (   **, 5);  # OUTPUT: «False␤»\n    say (1, 3)          ~~ (1, **, 3); # OUTPUT: «True␤»\n    say (1, 2, 4, 5, 3) ~~ (1, **, 3); # OUTPUT: «True␤»\n    say (1, 2, 4, 5, 6) ~~ (1, **, 5); # OUTPUT: «False␤»\n    say (1, 2, 4, 5, 6) ~~ (   **   ); # OUTPUT: «True␤»\n    say ()              ~~ (   **   ); # OUTPUT: «True␤»\n\nIn addition, returns False if either the invocant or $topic is a lazy\nIterable, unless $topic is the same object as the invocant, in which case\nTrue is returned.\n\nIf $topic is not an Iterable, returns the invocant if the invocant has no\nelements or its first element is a Match object (this behavior powers m:g//\nsmartmatch), or False otherwise.","elems\n\nDefined as:\n\n    sub    elems($list --> Int:D)\n    method elems(List:D: --> Int:D)\n\nReturns the number of elements in the list.\n\n    say (1,2,3,4).elems; # OUTPUT: «4␤»","end\n\nDefined as:\n\n    sub    end($list --> Int:D)\n    method end(List:D: --> Int:D)\n\nReturns the index of the last element.\n\n    say (1,2,3,4).end; # OUTPUT: «3␤»","keys\n\nDefined as:\n\n    sub    keys($list --> Seq:D)\n    method keys(List:D: --> Seq:D)\n\nReturns a sequence of indexes into the list (e.g., 0..(@list.elems-1)).\n\n    say (1,2,3,4).keys; # OUTPUT: «0..3␤»","values\n\nDefined as:\n\n    sub    values($list --> Seq:D)\n    method values(List:D: --> Seq:D)\n\nReturns a sequence of the list elements, in order.\n\n    say (1,2,3,4).^name;        # OUTPUT: «List␤»\n    say (1,2,3,4).values.^name; # OUTPUT: «Seq␤»","kv\n\nDefined as:\n\n    sub    kv($list --> Seq:D)\n    method kv(List:D: --> Seq:D)\n\nReturns an interleaved sequence of indexes and values. For example\n\n    <a b c>.kv; # (0 a 1 b 2 c)","pairs\n\nDefined as:\n\n    sub    pairs($list --> Seq:D)\n    method pairs(List:D: --> Seq:D)\n\nReturns a sequence of pairs, with the indexes as keys and the list values\nas values.\n\n    <a b c>.pairs   # (0 => a 1 => b 2 => c)","antipairs\n\nDefined as:\n\n    method antipairs(List:D: --> Seq:D)\n\nReturns a Seq of pairs, with the values as keys and the indexes as values,\ni.e. the direct opposite to pairs.\n\n    say <a b c>.antipairs;  # OUTPUT: «(a => 0 b => 1 c => 2)␤»","invert\n\nDefined as:\n\n    method invert(List:D: --> Seq:D)\n\nAssumes every element of the List is a Pair. Returns all elements as a Seq\nof Pairs where the keys and values have been exchanged. If the value of a\nPair is an Iterable, then it will expand the values of that Iterable into\nseparate pairs.\n\n    my $l = List.new('a' => (2, 3), 'b' => 17);\n    say $l.invert;   # OUTPUT: «(2 => a 3 => a 17 => b)␤»","join\n\nDefined as:\n\n    sub    join($separator, *@list)\n    method join(List:D: $separator = \"\")\n\nTreats the elements of the list as strings by calling .Str on each of them,\ninterleaves them with $separator and concatenates everything into a single\nstring. Note that you can omit the $separator if you use the method\nsyntax.\n\nExample:\n\n    join ', ', <a b c>;             # RESULT: «a, b, c»\n\nNote that the method form does not flatten sublists:\n\n    say (1, <a b c>).join('|');     # OUTPUT: «1|a b c␤»\n\nThe method form also allows you to omit the separator:\n\n    say <a b c>.join;               # OUTPUT: «abc␤»\n\nBut it behaves slurpily, flattening all arguments after the first into a\nsingle list:\n\n    say join('|', 3, 'þ', 1+4i);    # OUTPUT: «3|þ|1+4i␤»\n    say join ', ', <a b c>, 'd', 'e' , 'f'; # OUTPUT: «a, b, c, d, e, f␤»\n\nIn this case, the first list <a b c is slurped and flattened, unlike what\nhappens when join is invoked as a method.\n\nIf one of the elements of the list happens to be a Junction, then join will\nalso return a Junction with concatenation done as much as possible:\n\n    say (\"a\"|\"b\",\"c\",\"d\").join;     # OUTPUT: «any(acd,bcd)␤»","map\n\nDefined as:\n\n    multi method map(Hash:D \\hash)\n    multi method map(Iterable:D \\iterable)\n    multi method map(|c)\n    multi method map(\\SELF: &block;; :$label, :$item)\n    multi sub map(&code, +values)\n\nExamples applied to lists are included here for the purpose of\nillustration.\n\nFor a list, it invokes &code for each element and gathers the return values\nin a sequence and returns it. This happens lazily, i.e. &code is only\ninvoked when the return values are accessed.Examples:\n\n    say ('hello', 1, 22/7, 42, 'world').map: { .^name } # OUTPUT: «(Str Int Rat Int Str)␤»\n    say map *.Str.chars, 'hello', 1, 22/7, 42, 'world'; # OUTPUT: «(5 1 8 2 5)␤»\n\n\nmap inspects the arity of the code object, and tries to pass as many\narguments to it as expected:\n\n    sub b($a, $b) { \"$a before $b\" };\n    say <a b x y>.map(&b).join(', ');   # OUTPUT: «a before b, x before y␤»\n\niterates the list two items at a time.\n\nNote that map does not flatten embedded lists and arrays, so\n\n    ((1, 2), <a b>).map({ .join(',')})\n\npasses (1, 2) and <a b>  in turn to the block, leading to a total of two\niterations and the result sequence \"1,2\", \"a,b\". See method flatmap for an\nalternative that flattens.\n\nIf &code is a Block loop phasers will be executed and loop control\nstatements will be treated as in loop control flow. Please note that return\nis executed in the context of its definition. It is not the return\nstatement of the block but the surrounding Routine. Using a Routine will\nalso handle loop control statements and loop phasers. Any Routine specific\ncontrol statement or phaser will be handled in the context of that\nRoutine.\n\n    sub s {\n        my &loop-block = {\n            return # return from sub s\n        };\n        say 'hi';\n        (1..3).map: &loop-block;\n        say 'oi‽' # dead code\n    };\n    s\n    # RESULT: «hi»","flatmap\n\nDefined as:\n\n    method flatmap(List:D: &code --> Seq:D)\n\nLike map iterates over the elements of the invocant list, feeding each\nelement in turn to the code reference, and assembling the return values\nfrom these invocations in a result list.\n\nThe use of flatmap is strongly discouraged. Instead of .flatmap( ), please\nuse .map( ).flat as it is clear when the .flat is called and is not\nconfusing like .flatmap.\n\nUnlike map it flattens non-itemized lists and arrays, so\n\n    ## flatmap\n    my @list = ('first1', ('second2', ('third3', 'third4'), 'second5'), 'first6');\n    say @list.flatmap({.reverse}).perl;\n    # OUTPUT «(\"first1\", \"second5\", \"third3\", \"third4\", \"second2\", \"first6\").Seq␤»\n    ## map\n    say @list.map({\"$_ was a {.^name}\"}).perl;\n    # OUTPUT «(\"first1 was a Str\", \"second2 third3 third4 second5 was a List\", \"first6 was a Str\").Seq␤»\n    ## .map .flat has the same output as .flatmap\n    say @list.map({.reverse}).flat.perl\n    # OUTPUT «(\"first1\", \"second5\", \"third3\", \"third4\", \"second2\", \"first6\").Seq␤»","gist\n\nDefined as:\n\n    multi method gist(List:D: --> Str:D)\n\nReturns the string containing the parenthesized \"gist\" of the List, listing\nup to the first 100 elements, separated by space, appending an ellipsis if\nthe List has more than 100 elements. If List is-lazy, returns string\n'(...)'\n\n    put (1, 2, 3).gist;   # OUTPUT «(1 2 3)␤»\n    put (1..∞).List.gist; # OUTPUT «(...)␤»\n\n    put (1..200).List.gist;\n    # OUTPUT:\n    # (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26\n    # 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49\n    # 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72\n    # 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95\n    # 96 97 98 99 100 ...)","grep\n\nDefined as:\n\n    sub    grep(Mu $matcher, *@elems, :$k, :$kv, :$p, :$v --> Seq:D)\n    method grep(List:D:  Mu $matcher, :$k, :$kv, :$p, :$v --> Seq:D)\n\nReturns a sequence of elements against which $matcher smartmatches. The\nelements are returned in the order in which they appear in the original\nlist.\n\nExamples:\n\n    say ('hello', 1, 22/7, 42, 'world').grep: Int;              # OUTPUT: «(1 42)␤»\n    say grep { .Str.chars > 3 }, 'hello', 1, 22/7, 42, 'world'; # OUTPUT: «(hello 3.142857 world)␤»\n\nNote that if you want to grep for elements that do not match, you can use a\nnone-Junction:\n\n    say <a b 6 d 8 0>.grep(none Int);           # OUTPUT: «(a b d)␤»\n    say <a b c d e f>.grep(none /<[aeiou]>/);   # OUTPUT: «(b c d f)␤»\n\nAnother option to grep for elements that do not match a regex is to use a\nblock:\n\n    say <a b c d e f>.grep({! /<[aeiou]>/})     # OUTPUT: «(b c d f)␤»\n\nThe reason the example above works is because a regex in boolean context\napplies itself to $_. In this case, ! boolifies the /<[aeiou]>/ regex and\nnegates the result. Smartmatching against a Callable (in this case a Block)\nreturns the value returned from that callable, so the boolified result of a\nregex is then used to decide whether the current value should be kept in\nthe result of a grep.\n\nThe optional named parameters :k, :kv, :p, :v provide the same\nfunctionality as on slices:\n\n  * k\n\nOnly return the index values of the matching elements in order.\n\n  * kv\n\nReturn both the index and matched elements in order.\n\n  * p\n\nReturn the index and the matched element as a Pair, in order.\n\n  * v\n\nOnly return the matched elements (same as not specifying any named\nparameter at all).\n\nExamples:\n\n    say ('hello', 1, 22/7, 42, 'world').grep: Int, :k;\n    # OUTPUT: «(1 3)␤»\n    say grep { .Str.chars > 3 }, :kv, 'hello', 1, 22/7, 42, 'world';\n    # OUTPUT: «(0 hello 2 3.142857 4 world)␤»\n    say grep { .Str.chars > 3 }, :p, 'hello', 1, 22/7, 42, 'world';\n    # OUTPUT: «(0 => hello 2 => 3.142857 4 => world)␤»","first\n\nDefined as:\n\n    sub    first(Mu $matcher, *@elems, :$k, :$kv, :$p, :$end)\n    method first(List:D:  Mu $matcher?, :$k, :$kv, :$p, :$end)\n\nReturns the first item of the list which smartmatches against $matcher,\nreturns Nil when no values match. The optional named parameter :end\nindicates that the search should be from the end of the list, rather than\nfrom the start.\n\nExamples:\n\n    say (1, 22/7, 42, 300).first: * > 5;                  # OUTPUT: «42␤»\n    say (1, 22/7, 42, 300).first: * > 5, :end;            # OUTPUT: «300␤»\n    say ('hello', 1, 22/7, 42, 'world').first: Complex;   # OUTPUT: «Nil␤»\n\nThe optional named parameters :k, :kv, :p provide the same functionality as\non slices:\n\n  * k\n\nReturn the index value of the matching element. Index is always counted\nfrom the beginning of the list, regardless of whether the :end named\nparameter is specified or not.\n\n  * kv\n\nReturn both the index and matched element.\n\n  * p\n\nReturn the index and the matched element as a Pair.\n\nExamples:\n\n    say (1, 22/7, 42, 300).first: * > 5, :k;        # OUTPUT: «2␤»\n    say (1, 22/7, 42, 300).first: * > 5, :p;        # OUTPUT: «2 => 42␤»\n    say (1, 22/7, 42, 300).first: * > 5, :kv, :end; # OUTPUT: «(3 300)␤»\n\nIn method form, the $matcher can be omitted, in which case the first\navailable item (or last if :end is set) will be returned. See also head and\ntail methods.","head\n\nDefined as:\n\n    multi method head(Any:D:) is raw\n    multi method head(Any:D: Callable:D $w)\n    multi method head(Any:D: $n)\n\nThis method is directly inherited from Any, and it returns the first $n\nitems of the list, an empty list if $n <= 0, or the first element with no\nargument. The version that takes a Callable uses a WhateverCode to specify\nall elements, starting from the first, but the last ones.\n\nExamples:\n\n    say <a b c d e>.head ;     # OUTPUT: «a␤»\n    say <a b c d e>.head(2);   # OUTPUT: «(a b)␤»\n    say <a b c d e>.head(*-3); # OUTPUT: «(a b)␤»","tail\n\nDefined as:\n\n    multi method tail(List:D:)\n    multi method tail(List:D: $n --> Seq:D)\n\nReturns a Seq containing the last $n items of the list. Returns an empty\nSeq if $n <= 0. Defaults to the last element if no argument is specified.\nThrows an exception if the list is lazy.\n\nExamples:\n\n    say <a b c d e>.tail(*-3);# OUTPUT: «(d e)␤»\n    say <a b c d e>.tail(2);  # OUTPUT: «(d e)␤»\n    say <a b c d e>.tail;     # OUTPUT: «e␤»\n\n\nIn the first case, $n is taking the shape of a WhateverCode to indicate the\nnumber of elements from the beginning that will be excluded. $n can be\neither a Callable, in which case it will be called with the value 0, or\nanything else that can be converted to a number, in which case it will use\nthat as the number of elements in the output Seq.\n\n    say <a b c d e>.tail( { $_ - 2 } ); # OUTPUT: «(c d e)␤»","categorize\n\nDefined as:\n\n    multi method categorize()\n    multi method categorize(Whatever)\n    multi method categorize($test, :$into!, :&as)\n    multi method categorize($test, :&as)\n    multi sub categorize($test, +items, :$into!, *%named )\n    multi sub categorize($test, +items, *%named )\n\nThese methods are directly inherited from Any; see Any.list for more\nexamples.\n\nThis routine transforms a list of values into a hash representing the\ncategorizations of those values according to $test, which is called once\nfor every element in the list; each hash key represents one possible\ncategorization for one or more of the incoming list values, and the\ncorresponding hash value contains an array of those list values categorized\nby the $test, acting like a mapper, into the category of the associated\nkey.\n\nNote that, unlike classify, which assumes that the return value of the\nmapper is a single value, categorize always assumes that the return value\nof the mapper is a list of categories that are appropriate to the current\nvalue.\n\nExample:\n\n    sub mapper(Int $i) returns List {\n        $i %% 2 ?? 'even' !! 'odd',\n        $i.is-prime ?? 'prime' !! 'not prime'\n    }\n    say categorize &mapper, (1, 7, 6, 3, 2);  # OUTPUT: «{even => [6 2], not prime => [1 6],\n                                              #          odd => [1 7 3], prime => [7 3 2]}␤»","classify\n\nDefined as:\n\n    multi method classify($test, :$into!, :&as)\n    multi method classify($test, :&as)\n    multi sub classify($test, +items, :$into!, *%named )\n    multi sub classify($test, +items, *%named )\n\nTransforms a list of values into a hash representing the classification of\nthose values; each hash key represents the classification for one or more\nof the incoming list values, and the corresponding hash value contains an\narray of those list values classified into the category of the associated\nkey. $test will be an expression that will produce the hash keys according\nto which the elements are going to be classified.\n\nExample:\n\n    say classify { $_ %% 2 ?? 'even' !! 'odd' }, (1, 7, 6, 3, 2);\n    # OUTPUT: «{even => [6 2], odd => [1 7 3]}␤»\n    say ('hello', 1, 22/7, 42, 'world').classify: { .Str.chars };\n    # OUTPUT: «{1 => [1], 2 => [42], 5 => [hello world], 8 => [3.142857]}␤»\n\nIt can also take :as as a named parameter, transforming the value before\nclassifying it:\n\n    say <Innie Minnie Moe>.classify( { $_.chars }, :as{ lc $_ });\n    # OUTPUT: «{3 => [moe], 5 => [innie], 6 => [minnie]}␤»\n\nThis code is classifying by number of characters, which is the expression\nthat has been passed as $test parameter, but the :as block lowercases it\nbefore doing the transformation. The named parameter :into can also be used\nto classify into a newly defined variable:\n\n    <Innie Minnie Moe>.classify( { $_.chars }, :as{ lc $_ }, :into( my %words{Int} ) );\n    say %words; # OUTPUT: «{3 => [moe], 5 => [innie], 6 => [minnie]}␤»\n\nWe are declaring the scope of %words{Int} on the fly, with keys that are\nactually integers; it gets created with the result of the classification.","Bool\n\nDefined as:\n\n    method Bool(List:D: --> Bool:D)\n\nReturns True if the list has at least one element, and False for the empty\nlist.\n\n    say ().Bool;  # OUTPUT: «False␤»\n    say (1).Bool; # OUTPUT: «True␤»","Str\n\nDefined as:\n\n    method Str(List:D: --> Str:D)\n\nStringifies the elements of the list and joins them with spaces (same as\n.join(' ')).\n\n    say (1,2,3,4,5).Str; # OUTPUT: «1 2 3 4 5␤»","Int\n\nDefined as:\n\n    method Int(List:D: --> Int:D)\n\nReturns the number of elements in the list (same as .elems).\n\n    say (1,2,3,4,5).Int; # OUTPUT: «5␤»","Numeric\n\nDefined as:\n\n    method Numeric(List:D: --> Int:D)\n\nReturns the number of elements in the list (same as .elems).\n\n    say (1,2,3,4,5).Numeric; # OUTPUT: «5␤»","Capture\n\nDefined as:\n\n    method Capture(--> Capture:D)\n\nReturns a Capture where each Pair, if any, in the List has been converted\nto a named argument (with the key of the Pair stringified). All other\nelements in the List are converted to positional arguments in the order\nthey are found, i.e. the first non pair item in the list becomes the first\npositional argument, which gets index 0, the second non pair item becomes\nthe second positional argument, getting index 1 etc.\n\n    my $list = (7, 5, a => 2, b => 17);\n    my $capture = $list.Capture;\n    say $capture.keys;                                # OUTPUT: «(0 1 a b)␤»\n    my-sub(|$capture);                                # RESULT: «7, 5, 2, 17»\n\n    sub my-sub($first, $second, :$a, :$b) {\n        say \"$first, $second, $a, $b\"\n    }\n\nA more advanced example demonstrating the returned Capture being matched\nagainst a Signature.\n\n    my $list = (7, 5, a => 2, b => 17);\n    say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «True␤»\n\n    $list = (8, 5, a => 2, b => 17);\n    say so $list.Capture ~~ :($ where * == 7,$,:$a,:$b); # OUTPUT: «False␤»","pick\n\nDefined as:\n\n    multi sub    pick($count, *@list --> Seq:D)\n    multi method pick(List:D: $count --> Seq:D)\n    multi method pick(List:D: --> Mu)\n\nIf $count is supplied: Returns $count elements chosen at random and without\nrepetition from the invocant. If * is passed as $count, or $count is\ngreater than or equal to the size of the list, then all elements from the\ninvocant list are returned in a random sequence; i.e. they are returned\nshuffled.\n\nIn method form, if $count is omitted: Returns a single random item from the\nlist, or Nil if the list is empty\n\nExamples:\n\n    say <a b c d e>.pick;           # OUTPUT: «b␤»\n    say <a b c d e>.pick: 3;        # OUTPUT: «(c a e)␤»\n    say <a b c d e>.pick: *;        # OUTPUT: «(e d a b c)␤»","roll\n\nDefined as:\n\n    multi sub    roll($count, *@list --> Seq:D)\n    multi method roll(List:D: $count --> Seq:D)\n    multi method roll(List:D: --> Mu)\n\nIf $count is supplied: Returns a sequence of $count elements, each randomly\nselected from the list. Each random choice is made independently, like a\nseparate die roll where each die face is a list element. If * is passed as\n$count returns a lazy, infinite sequence of randomly chosen elements from\nthe original list.\n\nIf $count is omitted: Returns a single random item from the list, or Nil if\nthe list is empty\n\nExamples:\n\n    say <a b c d e>.roll;       # 1 random letter\n    say <a b c d e>.roll: 3;    # 3 random letters\n    say roll 8, <a b c d e>;    # 8 random letters\n\n    my $random-digits := (^10).roll(*);\n    say $random-digits[^15];    # 15 random digits","eager\n\nDefined as:\n\n    multi method eager(List:D: --> List:D)\n    multi sub eager(*@elems --> List:D)\n\nEvaluates all elements in the List eagerly, and returns them as a List.\n\n    my  \\ll = (lazy 1..5).cache;\n\n    say ll[];     # OUTPUT: «(...)␤»\n    say ll.eager  # OUTPUT: «(1 2 3 4 5)␤»","reverse\n\nDefined as:\n\n    multi sub    reverse(*@list  --> Seq:D)\n    multi method reverse(List:D: --> Seq:D)\n\nReturns a Seq with the same elements in reverse order.\n\nNote that reverse always refers to reversing elements of a list; to reverse\nthe characters in a string, use flip.\n\nExamples:\n\n    say <hello world!>.reverse;     # OUTPUT: «(world! hello)␤»\n    say reverse ^10;                # OUTPUT: «(9 8 7 6 5 4 3 2 1 0)␤»","rotate\n\nDefined as:\n\n    multi sub    rotate(@list,  Int:D $n = 1 --> List:D)\n    multi method rotate(List:D: Int:D $n = 1 --> List:D)\n\nReturns the list rotated by $n elements.\n\nExamples:\n\n    <a b c d e>.rotate(2);   # <c d e a b>\n    <a b c d e>.rotate(-1);  # <e a b c d>","sort\n\nDefined as:\n\n    multi sub    sort(*@elems      --> Seq:D)\n    multi sub    sort(&custom-routine-to-use, *@elems --> Seq:D)\n    multi method sort(List:D:      --> Seq:D)\n    multi method sort(List:D: &custom-routine-to-use  --> Seq:D)\n\nSorts the list, smallest element first. By default infix:<cmp>  is used for\ncomparing list elements.\n\nIf &custom-routine-to-use is provided, and it accepts two arguments, it is\ninvoked for pairs of list elements, and should return Order::Less,\nOrder::Same or Order::More.\n\nIf &custom-routine-to-use accepts only one argument, the list elements are\nsorted according to custom-routine-to-use($a) cmp custom-routine-to-use($b)\n. The return values of &custom-routine-to-use are cached, so that\n&custom-routine-to-use is only called once per list element.\n\nExamples:\n\n    say (3, -4, 7, -1, 2, 0).sort;                  # OUTPUT: «(-4 -1 0 2 3 7)␤»\n    say (3, -4, 7, -1, 2, 0).sort: *.abs;           # OUTPUT: «(0 -1 2 3 -4 7)␤»\n    say (3, -4, 7, -1, 2, 0).sort: { $^b leg $^a }; # OUTPUT: «(7 3 2 0 -4 -1)␤»\n\nAdditionally, if &custom-routine-to-use returns a List, elements will be\nsorted based upon multiple values with subsequent values in the List being\nused to break the tie if the comparison between the prior elements evaluate\nto Order::Same.\n\n    my @resistance = (\n        %( first-name => 'Kyle',  last-name => 'Reese'  ),\n        %( first-name => 'Sarah', last-name => 'Connor' ),\n        %( first-name => 'John',  last-name => 'Connor' ),\n    );\n    .say for @resistance.sort: { .<last-name>, .<first-name> };\n\n    #`(\n    OUTPUT:\n      {first-name => John, last-name => Connor}\n      {first-name => Sarah, last-name => Connor}\n      {first-name => Kyle, last-name => Reese}\n    )\n\nThis sorting can be based on characteristics of a single element:\n\n    say <ddd aaa bbb bb ccc c>.sort( {.chars, .Str} );\n    # OUTPUT: «(c bb aaa bbb ccc ddd)␤»\n\n\nIn this case, elements of the array are sorted in ascending order according\nfirst to the string length (.chars) and second to the actual alphabetical\norder .Str) if the length is exactly the same.\n\nAny number of criteria can be used in this:\n\n    say <01 11 111 2 20 02>.sort( { .Int, .comb.sum, .Str } );\n    # OUTPUT: «(01 02 2 11 20 111)␤»","reduce\n\nDefined as:\n\n    multi method reduce(Any:U: & --> Nil)\n    multi method reduce(Any:D: &with)\n    multi sub reduce (&with, +list)\n\nThe first form is obviously a no-op. The second form generates a single\n\"combined\" value from a list of arbitrarily many values, by iteratively\napplying a function which knows how to combine two values.\n\nIf @values contains just a single element, the operator is applied to that\nsingle element if possible; if not, it returns the element itself.\n\n    say [-] <10 5 3>; #OUTPUT: 2␤\n    say [-] 10;       #OUTPUT: 10␤\n\nIf it contains no elements, an exception is thrown, unless &with is an\noperator with a known identity value. For this reason, you may want to\nprefix the input list with an explicit identity value:\n\n    my @strings = (\"One good string!\", \"And one another good string!\");\n    say reduce { $^a ~ $^b }, '', |@strings;               # like @strings.join\n    my @numbers = (1,2,3,4,5);\n    say reduce { $^a > $^b ?? $^a !! $^b }, 0, |@numbers;  # like @numbers.max\n\nIf &with is the function object of an operator, its inherent identity value\nand associativity is respected - in other words, (VAL1, VAL2,\nVAL3).reduce(&[OP]) is the same as VAL1 OP VAL2 OP VAL3 even for operators\nwhich aren't left-associative:\n\n    # Raise 2 to the 81st power, because 3 to the 4th power is 81\n    [2,3,4].reduce(&[**]).lsb.say;        # OUTPUT: «81␤»\n    (2**(3**4)).lsb.say;                  # OUTPUT: «81␤»\n    (2**3**4).lsb.say;                    # OUTPUT: «81␤»\n\n    # Subtract 4 from -1, because 2 minus 3 is -1\n    [2,3,4].reduce(&[-]).say;             # OUTPUT: «-5␤»\n    ((2-3)-4).say;                        # OUTPUT: «-5␤»\n    (2-3-4).say;                          # OUTPUT: «-5␤»\n\nSince reducing with an infix operator is a common thing to do, the [ ]\nmetaoperator provides a syntactic shortcut:\n\n    # The following all do the same thing...\n    my @numbers = (1,2,3,4,5);\n    say reduce { $^a + $^b }, 0, |@numbers;\n    say reduce * + *, 0, |@numbers;\n    say reduce &[+], @numbers; # operator does not need explicit identity\n    say [+] @numbers;          # most people write it this way\n\nPlease note also the use of reduce in sub form. Since reduce is an implicit\nloop, it responds to next, last and redo statements inside &with:\n\n    say (2,3,4,5).reduce: { last if $^a > 7; $^a + $^b }; # says 9\n\nPractical example:\n\n    # Generate a random-ish math formula like \"(4 + ((3 * x) + 11) / 6))\"\n\n    my @ops = [Z] (<+ - * />, 1..20)».roll(4);\n\n    say ('x', |@ops).reduce: -> $formula, [$op, $number] {\n        Bool.pick ?? \"($formula $op $number)\"\n                  !! \"($number $op $formula)\"\n    }\n\nNote: In the functional programming world, this operation is generally\ncalled a fold. With a right-associative operator it is a right fold,\notherwise (and usually) it is a left fold:\n\n    sub infix:<foo>($a, $b) is assoc<right> { \"($a, $b)\" }\n    say [foo] 1, 2, 3, 4; # OUTPUT: «(1, (2, (3, 4)))␤»\n\n    sub infix:<bar>($a, $b) is assoc<left> { \"($a, $b)\" }\n    say [bar] 1, 2, 3, 4; # OUTPUT: «(((1, 2), 3), 4)␤»","produce\n\nDefined as:\n\n    multi sub    produce(&with, *@values)\n    multi method produce(List:D: &with)\n\nGenerates a list of all intermediate \"combined\" values along with the final\nresult by iteratively applying a function which knows how to combine two\nvalues.\n\nIf @values contains just a single element, a list containing that element\nis returned immediately. If it contains no elements, an exception is\nthrown, unless &with is an operator with a known identity value.\n\nIf &with is the function object of an operator, its inherent identity value\nand associativity is respected - in other words, (VAL1, VAL2,\nVAL3).produce(&[OP]) is the same as VAL1 OP VAL2 OP VAL3 even for operators\nwhich aren't left-associative:\n\n    # Raise 2 to the 81st power, because 3 to the 4th power is 81\n    [2,3,4].produce(&[**]).say;        # OUTPUT: «(4 81 2417851639229258349412352)␤»\n    say produce &[**], (2,3,4);        # OUTPUT: «(4 81 2417851639229258349412352)␤»\n    say [\\**] (2,3,4);                 # OUTPUT: «(4 81 2417851639229258349412352)␤»\n\n    # Subtract 4 from -1, because 2 minus 3 is -1\n    [2,3,4].produce(&[-]).say;         # OUTPUT: «(2 -1 -5)␤»\n    say produce &[-], (2,3,4);         # OUTPUT: «(2 -1 -5)␤»\n    say [\\-] (2,3,4);                  # OUTPUT: «(2 -1 -5)␤»\n\nA triangle metaoperator [\\ ] provides a syntactic shortcut for producing\nwith an infix operator:\n\n    # The following all do the same thing...\n    my @numbers = (1,2,3,4,5);\n    say produce { $^a + $^b }, @numbers;\n    say produce * + *, @numbers;\n    say produce &[+], @numbers; # operator does not need explicit identity\n    say [\\+] @numbers;          # most people write it this way\n\nThe visual picture of a triangle [\\ is not accidental. To produce a\ntriangular list of lists, you can use a \"triangular comma\":\n\n    [\\,] 1..5;\n    # (\n    # (1)\n    # (1 2)\n    # (1 2 3)\n    # (1 2 3 4)\n    # (1 2 3 4 5)\n    # )\n\nSince produce is an implicit loop, it responds to next, last and redo\nstatements inside &with:\n\n    say (2,3,4,5).produce: { last if $^a > 7; $^a + $^b }; # OUTPUT: «(2 5 9)␤»","combinations\n\nDefined as:\n\n    multi sub    combinations($from, $of = 0..*             --> Seq:D)\n    multi method combinations(List:D: Int() $of             --> Seq:D)\n    multi method combinations(List:D: Iterable:D $of = 0..* --> Seq:D)\n\nReturns a Seq with all $of-combinations of the invocant list. $of can be a\nnumeric Range, in which case combinations of the range of item numbers it\nrepresents will be returned (i.e. 2.6 .. 4 will return 2-, 3-, and 4-item\ncombinations>). Otherwise, $of is coerced to an Int.\n\n    .say for <a b c>.combinations: 2;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n\nAbove, there are three possible ways to combine the 2-items lists from the\noriginal list, which is what we receive in the output. See permutations if\nyou want permutations instead of combinations.\n\nWith Range argument, we get both three 2-item combinations and one 3-item\ncombination:\n\n    .say for <a b c>.combinations: 2..3;\n    # OUTPUT:\n    # (a b)\n    # (a c)\n    # (b c)\n    # (a b c)\n\nIf $of is negative or is larger than there are items in the given list, an\nempty list will be returned. If $of is zero, a 1-item list containing an\nempty list will be returned (there's exactly 1 way to pick no items).\n\nThe subroutine form is equivalent to the method form called on the first\nargument ($from), with the exception that if $from is not an Iterable, it\ngets coerced to an Int and combinations are made from a Range constructed\nwith 0..^$from instead:\n\n    .say for combinations 3, 2\n    # OUTPUT:\n    # (0 1)\n    # (0 2)\n    # (1 2)\n\nNote: some implementations may limit the maximum value of non-Iterable\n$from. On Rakudo, 64-bit systems have a limit of 2³¹-1 and 32-bit systems\nhave a limit of 2²⁸-1.","permutations\n\nDefined as:\n\n    multi sub    permutations(Int()    $from --> Seq:D)\n    multi sub    permutations(Iterable $from --> Seq:D)\n    multi method permutations(List:D:        --> Seq:D)\n\nReturns all possible permutations of a list as a Seq of lists:\n\n    .say for <a b c>.permutations;\n    # OUTPUT:\n    # (a b c)\n    # (a c b)\n    # (b a c)\n    # (b c a)\n    # (c a b)\n    # (c b a)\n\npermutations treats all elements as unique, thus (1, 1, 2).permutations\nreturns a list of 6 elements, even though there are only three distinct\npermutations, due to first two elements being the same.\n\nThe subroutine form behaves the same as the method form, computing\npermutations from its first argument $from. If $from is not an Iterable,\ncoerces $from to an Int and picks from a Range constructed with 0..^$from:\n\n    .say for permutations 3;\n    # OUTPUT:\n    # (0 1 2)\n    # (0 2 1)\n    # (1 0 2)\n    # (1 2 0)\n    # (2 0 1)\n    # (2 1 0)","rotor\n\nDefined as:\n\n    method rotor(*@cycle, Bool() :$partial --> Seq:D)\n\nReturns a sequence of lists, where each sublist is made up of elements of\nthe invocant.\n\nIn the simplest case, @cycle contains just one integer, in which case the\ninvocant list is split into sublists with as many elements as the integer\nspecifies. If :$partial is True, the final chunk is included even if it\ndoesn't satisfy the length requirement:\n\n    say ('a'..'h').rotor(3).join('|');              # OUTPUT: «a b c|d e f␤»\n    say ('a'..'h').rotor(3, :partial).join('|');    # OUTPUT: «a b c|d e f|g h␤»\n\nIf the element of @cycle is a Pair instead, the key of the pair specifies\nthe length of the return sublist, and the value the gap between sublists;\nnegative gaps produce overlap:\n\n    say ('a'..'h').rotor(2 => 1).join('|');         # OUTPUT: «a b|d e|g h␤»\n    say ('a'..'h').rotor(3 => -1).join('|');        # OUTPUT: «a b c|c d e|e f g␤»\n\nIf @cycle contains more than element, rotor cycles through it to find the\nnumber of elements for each sublist:\n\n    say ('a'..'h').rotor(2, 3).join('|');           # OUTPUT: «a b|c d e|f g␤»\n    say ('a'..'h').rotor(1 => 1, 3).join('|');      # OUTPUT: «a|c d e|f␤»\n\nCombining multiple cycles and :partial also works:\n\n    say ('a'..'h').rotor(1 => 1, 3 => -1, :partial).join('|');\n    # OUTPUT: «a|c d e|e|g h␤»\n\nSee this blog post for more elaboration on rotor.","batch\n\nDefined As:\n\n    multi method batch(Int:D $batch --> Seq)\n    multi method batch(Int:D :$elems --> Seq)\n\nReturns a Seq of the elements in batches of :$elems or $batch,\nrespectively. If the number of elements is not a multiple of $batch, the\nlast batch may have less than $batch elements, similar to .rotor($batch,\n:partial).","cross\n\n    sub cross(+@e, :&with --> Seq:D)\n\nComputes the cross-product of two or more lists or iterables. This returns\na sequence of lists where the first item in each list is an item from the\nfirst iterable, the second is from the second given iterable, etc. Every\nitem will be paired with every other item in all the other lists.\n\n    say cross(<a b c>, <d e f>).map(*.join).join(\",\")\n    # OUTPUT: «ad,ae,af,bd,be,bf,cd,ce,cf␤»\n\nThe cross routine has an infix synonym as well, named X.\n\n    say (<a b c> X <d e f>).map(*.join).join(\",\")\n    # output is the same as the previous example\n\nIf the optional with parameter is passed, it is used as a reduction\noperation to apply to each of the cross product items.\n\n    say cross([1, 2, 3], [4, 5, 6], :with(&infix:<*>)).join(\",\");\n    # OUTPUT: «4,5,6,8,10,12,12,15,18␤»\n\nThe X operator can be combined with another operator as a metaoperator to\nperform a reduction as well:\n\n    say ([1, 2, 3] X* [4, 5, 6]).join(\",\")\n    # same output as the previous example","zip\n\nDefined as:\n\n    sub zip(+@e, :&with --> Seq:D)\n\nBuilds a 'list of lists', returned as a sequence, from multiple input lists\nor other iterables.\n\nzip iterates through each of the input lists synchronously, 'Zipping' them\ntogether, so that elements are grouped according to their input list index,\nin the order that the lists are provided.\n\n    say zip(<a b c>, <d e f>, <g h i>);\n    # OUTPUT: «((a d g) (b e h) (c f i))␤»\n\nzip has an infix synonym, the Z operator.\n\n    say <a b c> Z <d e f> Z <g h i>;                   # same output\n\nzip can provide input to a for loop :\n\n    for <a b c> Z <d e f> Z <g h i> -> [$x,$y,$z] {say ($x,$y,$z).join(\",\")}\n    # OUTPUT: «a,d,g␤\n    # b,e,h␤\n    # c,f,i␤»\n\n, or more succinctly:\n\n    say .join(\",\") for zip <a b c>, <d e f>, <g h i>;  # same output\n\nNote, that if the input lists have an unequal number of elements, then zip\nterminates once the shortest input list is exhausted, and trailing elements\nfrom longer input lists are discarded.\n\n    say <a b c> Z <d e f m n o p> Z <g h i>;\n    # ((a d g) (b e h) (c f i))\n\nIn cases where data clipping is possible, but undesired, then consider\nusing roundrobin instead of zip.\n\nThe optional with parameter will additionally reduce the zipped lists. For\nexample, the following multiplies corresponding elements together to return\na single list of products.\n\n    .say for zip <1 2 3>, [1, 2, 3], (1, 2, 3), :with(&infix:<*>);\n    # OUTPUT: «1␤\n    # 8␤\n    # 27␤»\n\nThe Z form can also be used to perform reduction by implicitly setting the\nwith parameter with a metaoperator :\n\n    .say for <1 2 3> Z* [1, 2, 3] Z* (1, 2, 3);        # same output","roundrobin\n\nDefined as:\n\n    sub roundrobin(+list-of-lists --> Seq)\n\nBuilds a 'list of lists', returned as a sequence, from multiple input lists\nor other iterables. roundrobin returns an identical result to that of zip,\nexcept when the input lists are allowed to have an unequal number of\nelements.\n\n    say roundrobin <a b c>, <d e f>, <g h i>;\n    # OUTPUT: «((a d g) (b e h) (c f i))␤»\n\n    say .join(\",\") for roundrobin([1, 2], [2, 3], [3, 4]);\n    # OUTPUT: «1,2,3␤\n    # 2,3,4␤»\n\nroundrobin does not terminate once one or more of the input lists become\nexhausted, but proceeds until all elements from all lists have been\nprocessed.\n\n    say roundrobin <a b c>, <d e f m n o p>, <g h i j>;\n    # OUTPUT: «((a d g) (b e h) (c f i) (m j) (n) (o) (p))␤»\n\n    say .join(\",\") for roundrobin([1, 2], [2, 3, 57, 77], [3, 4, 102]);\n    # OUTPUT: «1,2,3␤\n    # 2,3,4␤\n    # 57,102␤\n    # 77␤»\n\nTherefore no data values are lost due in the 'zipping' operation. A record\nof which input list provided which element cannot be gleaned from the\nresulting sequence, however.\n\nroundrobin can be useful in combining messy data to the point where a\nmanual post-processing step can then be undertaken.","sum\n\nDefined as:\n\n    sub    sum($list   --> Numeric:D)\n    method sum(List:D: --> Numeric:D)\n\nReturns the sum of all elements in the list or 0 if the list is empty.\nThrows an exception if an element can not be coerced into Numeric.\n\n    say (1, 3, pi).sum;       # OUTPUT: «7.14159265358979␤»\n    say (1, \"0xff\").sum;      # OUTPUT: «256␤»\n    say sum(0b1111, 5);       # OUTPUT: «20␤»\n\nWhen being called on native integer arrays, it is also possible to specify\na :wrap named parameter. This will add the values as native integers,\nwrapping around if they exceed the size of a native integer. If you are\nsure you will not exceed that value, or if you don't mind, using :wrap will\nmake the calculation about 20x as fast.\n\n    my int @values = ^1_000_000;\n    say @a.sum(:wrap);        # OUTPUT: «499999500000␤»","fmt\n\nDefined as:\n\n    method fmt($format = '%s', $separator = ' ' --> Str:D)\n\nReturns a string where each element in the list has been formatted\naccording to $format and where each element is separated by $separator.\n\nFor more information about formats strings, see sprintf.\n\n    my @a = 8..11;\n    say @a.fmt('%03d', ',');  # OUTPUT: «008,009,010,011␤»","from\n\nAssumes the list contains Match objects and returns the value of .from\ncalled on the first element of the list.\n\n    'abcdefg' ~~ /(c)(d)/;\n    say $/.list.from;         # OUTPUT: «2␤»\n\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.list.from;         # OUTPUT: «3␤»","to\n\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.to; # OUTPUT: «6␤»\n\nAssumes the List contains Match objects, such as the $/ variable being a\nList, when using :g modifier in regexes. Returns the value of .to called on\nthe last element of the list.","sink\n\nDefined as:\n\n    method sink(--> Nil) { }\n\nIt does nothing, and returns Nil, as the definition clearly shows.\n\n    sink [1,2,Failure.new(\"boo!\"),\"still here\"]; # OUTPUT: «»","Set\n\nIn general, creates a set which has as members elements of the list.\n\n    say <æ ß þ €>.Set;  # OUTPUT: «set(ß æ þ €)␤»\n\nHowever, there might be some unexpected changes in case the list includes\nnon-scalar data structures. For instance, with Pairs:\n\n    my @a = (:42a, :33b);\n    say @a;                # OUTPUT: «[a => 42 b => 33]␤»\n    say @a.Set;            # OUTPUT: «set(a b)␤»\n\nThe set will be composed of the keys of the Pair whose corresponding value\nis not 0, eliminating all the values. Please check the Set documentation\nfor more examples and a more thorough explanation."]},{"name":"Blob","methods":["new\n\nDefined as:\n\n    multi method new(Blob:)\n    multi method new(Blob: Blob:D $blob)\n    multi method new(Blob: int @values)\n    multi method new(Blob: @values)\n    multi method new(Blob: *@values)\n\nCreates an empty Blob, or a new Blob from another Blob, or from a list of\nintegers or values (which will have to be coerced into integers):\n\n    my $blob = Blob.new([1, 2, 3]);\n    say Blob.new(<1 2 3>); # OUTPUT: «Blob:0x<01 02 03>␤»","Bool\n\nDefined as:\n\n    multi method Bool(Blob:D:)\n\nReturns False if and only if the buffer is empty.\n\n    my $blob = Blob.new();\n    say $blob.Bool; # OUTPUT: «False␤»\n    $blob = Blob.new([1, 2, 3]);\n    say $blob.Bool; # OUTPUT: «True␤»","Capture\n\nDefined as:\n\n    method Capture(Blob:D)\n\nEquivalent to calling .List.Capture on the invocant.","elems\n\nDefined as:\n\n    multi method elems(Blob:D:)\n    multi method elems(Blob:U: --> 1)\n\nReturns the number of elements of the buffer.\n\n    my $blob = Blob.new([1, 2, 3]);\n    say $blob.elems; # OUTPUT: «3␤»\n\nIt will also return 1 on the class object.","bytes\n\nDefined as:\n\n    method bytes(Blob:D: --> Int:D)\n\nReturns the number of bytes used by the elements in the buffer.\n\n    say Blob.new([1, 2, 3]).bytes;      # OUTPUT: «3␤»\n    say blob16.new([1, 2, 3]).bytes;    # OUTPUT: «6␤»\n    say blob64.new([1, 2, 3]).bytes;    # OUTPUT: «24␤»","chars\n\nDefined as:\n\n    method chars(Blob:D:)\n\nThrows X::Buf::AsStr with chars as payload.","Str\n\nDefined as:\n\n    multi method Str(Blob:D:)\n\nThrows X::Buf::AsStr with Str as payload. In order to convert to a Str you\nneed to use .decode.","Stringy\n\nDefined as:\n\n    multi method Stringy(Blob:D:)\n\nThrows X::Buf::AsStr with Stringy as payload.","decode\n\nDefined as:\n\n    multi method decode(Blob:D: $encoding = self.encoding // \"utf-8\")\n\n    multi method decode(Blob:D: $encoding, Str :$replacement!,\n                        Bool:D :$strict = False)\n\n\n    multi method decode(Blob:D: $encoding, Bool:D :$strict = False)\n\nApplies an encoding to turn the blob into a Str; the encoding will be UTF-8\nby default.\n\n    my Blob $blob = \"string\".encode('utf-8');\n    say $blob.decode('utf-8'); # OUTPUT: «string␤»\n\nOn malformed utf-8 .decode will throw X::AdHoc. To handle sloppy utf-8 use\nutf8-c8.","list\n\nDefined as:\n\n    multi method list(Blob:D:)\n\nReturns the list of codepoints:\n\n    say \"zipi\".encode(\"ascii\").list; # OUTPUT: «(122 105 112 105)␤»","gist\n\nDefined as:\n\n    method gist(Blob:D: --> Str:D)\n\nReturns the string containing the \"gist\" of the Blob, listing up to the\nfirst 100 elements, separated by space, appending an ellipsis if the Blob\nhas more than 100 elements.\n\n    put Blob.new(1, 2, 3).gist; # OUTPUT: «Blob:0x<01 02 03>␤»\n    put Blob.new(1..2000).gist;\n    # OUTPUT:\n    # Blob:0x<01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15\n    # 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C\n    # 2D 2E 2F 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43\n    # 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53 54 55 56 57 58 59 5A\n    # 5B 5C 5D 5E 5F 60 61 62 63 64 ...>","subbuf\n\nDefined as:\n\n    multi method subbuf(Int $from, Int $len = self.elems --> Blob:D)\n    multi method subbuf(Range $range --> Blob:D)\n\nExtracts a part of the invocant buffer, starting from the index with\nelements $from, and taking $len elements (or less if the buffer is\nshorter), and creates a new buffer as the result.\n\n    say Blob.new(1..10).subbuf(2, 4);    # OUTPUT: «Blob:0x<03 04 05 06>␤»\n    say Blob.new(1..10).subbuf(*-2);     # OUTPUT: «Blob:0x<09 0a>␤»\n    say Blob.new(1..10).subbuf(*-5,2);   # OUTPUT: «Blob:0x<06 07>␤»\n\nFor convenience, also allows a Range to be specified to indicate which part\nof the invocant buffer you would like:\n\n    say Blob.new(1..10).subbuf(2..5);    # OUTPUT: «Blob:0x<03 04 05 06>␤»","allocate\n\nDefined as:\n\n    multi method allocate(Blob:U: Int:D $elements)\n    multi method allocate(Blob:U: Int:D $elements, int $value)\n    multi method allocate(Blob:U: Int:D $elements, Int:D \\value)\n    multi method allocate(Blob:U: Int:D $elements, Mu:D $got)\n    multi method allocate(Blob:U: Int:D $elements, int @values)\n    multi method allocate(Blob:U: Int:D $elements, Blob:D $blob)\n    multi method allocate(Blob:U: Int:D $elements, @values)\n\nReturns a newly created Blob object with the given number of elements.\nOptionally takes a second argument that indicates the pattern with which to\nfill the Blob: this can be a single (possibly native) integer value, or any\nIterable that generates integer values, including another Blob. The pattern\nwill be repeated if not enough values are given to fill the entire Blob.\n\n    my Blob $b0 = Blob.allocate(10,0);\n    $b0.say; # OUTPUT: «Blob:0x<00 00 00 00 00 00 00 00 00 00>␤»\n\nIf the pattern is a general Mu value, it will fail.","unpack\n\nThis method is considered experimental, in order to use it you will need to\ndo:\n\n    use experimental :pack;\n\nDefined as:\n\n    multi method unpack(Blob:D: Str:D $template)\n    multi method unpack(Blob:D: @template)\n    multi sub unpack(Blob:D \\blob, Str:D $template)\n    multi sub unpack(Blob:D \\blob, @template)\n\nExtracts features from the blob according to the template string, and\nreturns them as a list.\n\nThe template string consists of zero or more units that begin with an ASCII\nletter, and are optionally followed by a quantifier. The quantifier can be\n* (which typically stands for \"use up the rest of the Blob here\"), or a\npositive integer (without a +).\n\nWhitespace between template units is ignored.\n\nExamples of valid templates include \"A4 C n*\" and \"A*\".\n\nThe following letters are recognized:\n\n  Letter  Meaning\n  A       Extract a string, where each element of the Blob maps to a codepoint\n  a       Same as A\n  C       Extract an element from the blob as an integer\n  H       Extracts a hex string\n  L       Extracts four elements and returns them as a single unsigned integer\n  n       Extracts two elements and combines them in \"network\" (BigEndian) byte order into a single integer\n  N       Extracts four elements and combines them in \"network\" (BigEndian) byte order into a single integer\n  S       Extracts two elements and returns them as a single unsigned integer\n  v       Same as S\n  V       Same as L\n  x       Drop an element from the blob (that is, ignore it)\n  Z       Same as A\n\n\nExample:\n\n    use experimental :pack;\n    say Blob.new(1..10).unpack(\"C*\");\n    # OUTPUT: «(1 2 3 4 5 6 7 8 9 10)␤»\n\n  sub pack\n\nThis subroutine is considered experimental, in order to use it you will\nneed to do:\n\n    use experimental :pack;\n\n\n    multi sub pack(Str $template, *@items)\n    multi sub pack(@template, *@items)\n\n\nPacks the given items according to the template and returns a buffer\ncontaining the packed bytes.\n\nThe template string consists of zero or more units that begin with an ASCII\nletter, and are optionally followed by a quantifier. For details, see\nunpack.","reverse\n\nDefined as:\n\n    method reverse(Blob:D: --> Blob:D)\n\nReturns a Blob with all elements in reversed order.\n\n    say Blob.new([1, 2, 3]).reverse;    # OUTPUT: «Blob:0x<03 02 01>␤»\n    say blob16.new([2]).reverse;        # OUTPUT: «Blob[uint16]:0x<02>␤»\n    say buf32.new([16, 32]).reverse;    # OUTPUT: «Buf[uint32]:0x<20 10>␤»"],"desc":"TITLE\nrole Blob\n\nSUBTITLE\nImmutable buffer for binary data ('Binary Large OBject')\n\n    role Blob[::T = uint8] does Positional[T] does Stringy { }\n\nThe Blob role is an immutable interface to binary types, and offers a\nlist-like interface to lists of integers, typically unsigned integers.\n\n"},{"name":"Independent routines","desc":"TITLE\nIndependent routines\n\nSUBTITLE\nRoutines not defined within any class or role.\n\nThese routines are defined in different files along with one or several\nother classes, but are not actually attached to any particular class or\nrole.\n\n  routine EVAL\n\nDefined as:\n\n    proto sub EVAL($code where Blob|Cool|Callable, Str() :$lang = 'perl6',\n                    PseudoStash :$context, *%n)\n\n\n    multi sub EVAL($code, Str :$lang where { ($lang // '') eq 'Perl5' },\n                    PseudoStash :$context)\n\n\nThis routine coerces Cool $code to Str. If $code is a Blob, it'll be\nprocessed using the same encoding as the $lang compiler would: for perl6\n$lang, uses utf-8; for Perl5, processes using the same rules as perl.\n\nThis works as-is with a literal string parameter. More complex input, such\nas a variable or string with embedded code, is illegal by default. This can\nbe overridden in any of several ways:\n\n    use MONKEY-SEE-NO-EVAL; # Or...\n    use MONKEY;             # shortcut that turns on all MONKEY pragmas\n    use Test;\n\n    # any of the above allows:\n    EVAL \"say { 5 + 5 }\";   # OUTPUT: «10␤»\n\nIn case the MONKEY-SEE-NO-EVAL pragma is not activated, the compiler will\ncomplain with a EVAL is a very dangerous function!!! exception. And it is\nessentially right, since that will run arbitrary code with the same\npermissions as the program. You should take care of cleaning the code that\nis going to pass through EVAL if you activate the MONKEY-SEE-NO-EVAL\npragma.\n\nPlease note that you can interpolate to create routine names using\nquotation, as can be seen in this example or other ways to interpolate to\ncreate identifier names. This only works, however, for already declared\nfunctions and other objects and is thus safer to use.\n\nSymbols in the current lexical scope are visible to code in an EVAL.\n\n    my $answer = 42;\n    EVAL 'say $answer;';    # OUTPUT: «42␤»\n\nHowever, since the set of symbols in a lexical scope is immutable after\ncompile time, an EVAL can never introduce symbols into the surrounding\nscope.\n\n    EVAL 'my $lives = 9'; say $lives;   # error, $lives not declared\n\n\nFurthermore, the EVAL is evaluated in the current package:\n\n    module M {\n        EVAL 'our $answer = 42'\n    }\n    say $M::answer;         # OUTPUT: «42␤»\n\nAnd also in the current language, meaning any added syntax is available:\n\n    sub infix:<mean>(*@a) is assoc<list> {\n        @a.sum / @a.elems\n    }\n    EVAL 'say 2 mean 6 mean 4';     # OUTPUT: «4␤»\n\nAn EVAL statement evaluates to the result of the last statement:\n\n    sub infix:<mean>(*@a) is assoc<list> {\n        @a.sum / @a.elems\n    }\n    say EVAL 'say 1; 2 mean 6 mean 4';         # OUTPUT: «1␤4␤»\n\n\nEVAL is also a gateway for executing code in other languages:\n\n    EVAL \"use v5.20; say 'Hello from perl5!'\", :lang<Perl5>;\n\n\nYou need to have Inline::Perl5 for this to work correctly.\n\n  sub EVALFILE\n\nDefined as:\n\n    sub EVALFILE($filename where Blob|Cool, :$lang = 'perl6')\n\nSlurps the specified file and evaluates it. Behaves the same way as EVAL\nwith regard to Blob decoding, scoping, and the $lang parameter. Evaluates\nto the value produced by the final statement in the file.\n\n    EVALFILE \"foo.p6\";\n\n\n  sub mkdir\n\nDefined as:\n\n    sub    mkdir(IO() $path, Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory; see mode for explanation and valid values for\n$mode. Returns the IO::Path object pointing to the newly created directory\non success; fails with X::IO::Mkdir if directory cannot be created.\n\nAlso creates parent directories, as needed (similar to *nix utility mkdir\nwith -p option); that is, mkdir \"foo/bar/ber/meow\" will create foo,\nfoo/bar, and foo/bar/ber directories if they do not exist, as well as\nfoo/bar/ber/meow.\n\n  sub chdir\n\nDefined as:\n\n    sub chdir(IO() $path, :$d = True, :$r, :$w, :$x --> IO::Path:D)\n\nChanges value of $*CWD variable to the provided $path, optionally ensuring\nthe new path passes several file tests. NOTE: that this routine does NOT\nalter the process's current directory (see &*chdir).\n\nReturns IO::Path representing new $*CWD on success. On failure, returns\nFailure and leaves $*CWD untouched. The $path can be any object with an IO\nmethod that returns an IO::Path object. The available file tests are:\n\n  * :d — check .d returns True\n\n  * :r — check .r returns True\n\n  * :w — check .w returns True\n\n  * :x — check .x returns True\n\nBy default, only :d test is performed.\n\n    chdir         '/tmp'; # change $*CWD to '/tmp' and check its .d is True\n    chdir :r, :w, '/tmp'; # … check its .r and .w are True\n    chdir '/not-there';   # returns Failure\n\n\nNote that the following construct is a mistake:\n\n    # WRONG! DO NOT DO THIS!\n    my $*CWD = chdir '/tmp/';\n\n\nUse indir instead.\n\n  sub &*chdir\n\nDefined as:\n\n    PROCESS::<&chdir> = sub (IO() $path --> IO::Path:D) { }\n\n\nChanges value of $*CWD variable to the provided $path and sets the\nprocess's current directory to the value of $path.absolute. NOTE: that in\nmost cases, you want to use chdir routine instead.\n\nReturns an IO::Path representing the new $*CWD on success. On failure,\nreturns Failure and leaves $*CWD untouched. The $path can be any object\nwith an IO method that returns an IO::Path object.\n\nNote that unlike regular chdir, there are no arguments to specify which\nfile tests to perform.\n\n    &*chdir('/tmp');  # change $*CWD and process's current directory to '/tmp'\n    &*chdir('/not-there'); # returns Failure\n\n\nNote that the following construct is a mistake:\n\n    # WRONG! DO NOT DO THIS!\n    my $*CWD = &*chdir('/tmp');\n\n\nUse the following, instead; or see indir if you do not need to change\nprocess's current directory:\n\n    temp $*CWD;\n    &*chdir('/tmp');\n\n\n  sub chmod\n\nDefined as:\n\n    sub chmod(Int() $mode, *@filenames --> List)\n\nCoerces all @filenames to IO::Path and calls IO::Path.chmod with $mode on\nthem. Returns a List containing a subset of @filenames for which chmod was\nsuccessfully executed.\n\n    chmod 0o755, <myfile1  myfile2>; # make two files executable by the owner\n\n  sub indir\n\nDefined as:\n\n    sub indir(IO() $path, &code, :$d = True, :$r, :$w, :$x --> Mu)\n\nTakes Callable &code and executes it after locally (to &code) changing\n$*CWD variable to an IO::Path object based on $path, optionally ensuring\nthe new path passes several file tests. If $path is relative, it will be\nturned into an absolute path, even if an IO::Path object was given. NOTE:\nthat this routine does NOT alter the process's current directory (see\n&*chdir). The $*CWD outside of the &code is not affected, even if &code\nexplicitly assigns a new value to $*CWD.\n\nReturns the return value of &code on success. On failure to successfully\nchange $*CWD, returns Failure. WARNING: keep in mind that lazily evaluated\nthings might end up NOT having the $*CWD set by indir in their dynamic\nscope by the time they're actually evaluated. Either ensure the generators\nhave their $*CWD set or eagerly evaluate them before returning the results\nfrom indir:\n\n    say indir(\"/tmp\", {\n        gather { take \".\".IO }\n    })».CWD; # OUTPUT: «(/home/camelia)␤»\n\n    say indir(\"/tmp\", {\n        eager gather { take \".\".IO }\n    })».CWD; # OUTPUT: «(/tmp)␤»\n\n    say indir(\"/tmp\", {\n        my $cwd = $*CWD;\n        gather { temp $*CWD = $cwd; take \".\".IO }\n    })».CWD; # OUTPUT: «(/tmp)␤»\n\nThe routine's $path argument can be any object with an IO method that\nreturns an IO::Path object. The available file tests are:\n\n  * :d — check .d returns True\n\n  * :r — check .r returns True\n\n  * :w — check .w returns True\n\n  * :x — check .x returns True\n\nBy default, only :d test is performed.\n\n    say $*CWD;                   # OUTPUT: «\"/home/camelia\".IO␤»\n    indir '/tmp', { say $*CWD }; # OUTPUT: «\"/tmp\".IO␤»\n    say $*CWD;                   # OUTPUT: «\"/home/camelia\".IO␤»\n\n    indir '/not-there', {;};     # returns Failure; path does not exist\n\n  sub print\n\nDefined as:\n\n    multi sub print(**@args --> True)\n    multi sub print(Junction:D --> True)\n\nPrints the given text on standard output (the $*OUT filehandle), coercing\nnon-Str objects to Str by calling .Str method. Junction arguments\nautothread and the order of printed strings is not guaranteed.\n\n    print \"Hi there!\\n\";   # OUTPUT: «Hi there!␤»\n    print \"Hi there!\";     # OUTPUT: «Hi there!»\n    print [1, 2, 3];       # OUTPUT: «1 2 3»\n\nTo print text and include the trailing newline, use put.\n\n  sub put\n\nDefined as:\n\n    multi sub put(**@args --> True)\n    multi sub put(Junction:D --> True)\n\nSame as print, except it uses print-nl (which prints a newline, by default)\nat the end. Junction arguments autothread and the order of printed strings\nis not guaranteed.\n\n    put \"Hi there!\\n\";   # OUTPUT: «Hi there!␤␤»\n    put \"Hi there!\";     # OUTPUT: «Hi there!␤»\n    put [1, 2, 3];       # OUTPUT: «1 2 3␤»\n\n  sub say\n\nDefined as:\n\n    multi sub say(**@args --> True)\n\nPrints the \"gist\" of given objects. Same as put, except uses .gist method\nto obtain string representation of the object.\n\nNOTE: the .gist method of some objects, such as Lists, returns only partial\ninformation about the object (hence the \"gist\"). If you mean to print\ntextual information, you most likely want to use put instead.\n\n    say Range;        # OUTPUT: «(Range)␤»\n    say class Foo {}; # OUTPUT: «(Foo)␤»\n    say 'I ♥ Perl6';  # OUTPUT: «I ♥ Perl6␤»\n    say 1..Inf;       # OUTPUT: «1..Inf␤»\n\n  routine note\n\nDefined as:\n\n    method note(Mu: -->Bool:D)\n    multi sub note(            --> Bool:D)\n    multi sub note(Str:D $note --> Bool:D)\n    multi sub note(**@args     --> Bool:D)\n\nLike say, except prints output to $*ERR handle (STDERR). If no arguments\nare given to subroutine forms, will use string \"Noted\".\n\n    note;       # STDERR OUTPUT: «Noted␤»\n    note 'foo'; # STDERR OUTPUT: «foo␤»\n    note 1..*;  # STDERR OUTPUT: «1..Inf␤»\n\n\n  sub prompt\n\n    multi sub prompt()\n    multi sub prompt($msg)\n\nPrints $msg to $*OUT handle if $msg was provided, then gets a line of input\nfrom $*IN handle. By default, this is equivalent to printing $msg to\nSTDOUT, reading a line from STDIN, removing the trailing new line, and\nreturning the resultant string. As of Rakudo 2018.08, prompt will create\nallomorphs for numeric values, equivalent to calling val prompt.\n\n    my $name = prompt \"What's your name? \";\n    say \"Hi, $name! Nice to meet you!\";\n    my $age = prompt(\"Say your age (number)\");\n    my Int $years = $age;\n    my Str $age-badge = $age;\n\n\nIn the code above, $age will be duck-typed to the allomorph IntStr if it's\nentered correctly as a number.\n\n  sub open\n\n    multi sub open(IO() $path, |args --> IO::Handle:D)\n\nCreates a handle with the given $path, and calls IO::Handle.open, passing\nany of the remaining arguments to it. Note that IO::Path type provides\nnumerous methods for reading and writing from files, so in many common\ncases you do not need to open files or deal with IO::Handle type directly.\n\n    my $fh = open :w, '/tmp/some-file.txt';\n    $fh.say: 'I ♥ writing Perl code';\n    $fh.close;\n\n    $fh = open '/tmp/some-file.txt';\n    print $fh.readchars: 4;\n    $fh.seek: 7, SeekFromCurrent;\n    say $fh.readchars: 4;\n    $fh.close;\n\n    # OUTPUT: «I ♥ Perl␤»\n\n\n  sub slurp\n\nDefined as:\n\n    multi sub slurp(IO::Handle:D $fh = $*ARGFILES, |c)\n    multi sub slurp(IO() $path, |c)\n\nSlurps the contents of the entire file into a Str (or Buf if :bin). Accepts\n:bin and :enc optional named parameters, with the same meaning as open();\npossible encodings are the same as in all the other IO methods and are\nlisted in encoding routine. The routine will fail if the file does not\nexist, or is a directory. Without any arguments, sub slurp operates on\n$*ARGFILES, which defaults to $*IN in the absence of any filenames.\n\n    # read entire file as (Unicode) Str\n    my $text_contents   = slurp \"path/to/file\";\n\n    # read entire file as Latin1 Str\n    my $text_contents   = slurp \"path/to/file\", enc => \"latin1\";\n\n    # read entire file as Buf\n    my $binary_contents = slurp \"path/to/file\", :bin;\n\n\n  sub spurt\n\nDefined as:\n\n    multi spurt(IO() $path, |c)\n\nThe $path can be any object with an IO method that returns an IO::Path\nobject. Calls IO::Path.spurt on the $path, forwarding any of the remaining\narguments.\n\n    Options\n\n  * :enc\n\nThe encoding with which the contents will be written.\n\n  * :append\n\nBoolean indicating whether to append to a (potentially) existing file. If\nthe file did not exist yet, it will be created. Defaults to False.\n\n  * :createonly\n\nBoolean indicating whether to fail if the file already exists. Defaults to\nFalse.\n\n    Examples\n\n    # write directly to a file\n    spurt 'path/to/file', 'default text, directly written';\n\n    # write directly with a non-Unicode encoding\n    spurt 'path/to/latin1_file', 'latin1 text: äöüß', :enc<latin1>;\n\n    spurt 'file-that-already-exists', 'some text';           # overwrite file's contents:\n    spurt 'file-that-already-exists', ' new text', :append;  # append to file's contents:\n    say slurp 'file-that-already-exists';                    # OUTPUT: «some text new text␤»\n\n    # fail when writing to a pre-existing file\n    spurt 'file-that-already-exists', 'new text', :createonly;\n    # OUTPUT: «Failed to open file /home/camelia/file-that-already-exists: file already exists …»\n\n\n  sub run\n\nDefined as:\n\n    sub run(\n        *@args ($, *@),\n        :$in = '-',\n        :$out = '-',\n        :$err = '-',\n        Bool :$bin = False,\n        Bool :$chomp = True,\n        Bool :$merge = False,\n        Str:D :$enc = 'UTF-8',\n        Str:D :$nl = \"\\n\",\n        :$cwd = $*CWD,\n        Hash() :$env = %*ENV\n    --> Proc:D)\n\n\nRuns an external command without involving a shell and returns a Proc\nobject. By default, the external command will print to standard output and\nerror, and read from standard input.\n\n    run 'touch', '>foo.txt'; # Create a file named >foo.txt\n\n    run <<rm >foo.txt>>; # Another way to use run, using word quoting for the\n                         # arguments\n\nIf you want to pass some variables you can still use < >, but try to avoid\nusing « » as it will do word splitting if you forget to quote variables:\n\n    my $file = ‘--my arbitrary filename’;\n    run ‘touch’, ‘--’, $file;  # RIGHT\n    run <touch -->, $file;     # RIGHT\n\n    run «touch -- \"$file\"»;    # RIGHT but WRONG if you forget quotes\n    run «touch -- $file»;      # WRONG; touches ‘--my’, ‘arbitrary’ and ‘filename’\n    run ‘touch’, $file;        # WRONG; error from `touch`\n    run «touch \"$file\"»;       # WRONG; error from `touch`\n\n\nNote that -- is required for many programs to disambiguate between\ncommand-line arguments and filenames that begin with hyphens.\n\nA sunk Proc object for a process that exited unsuccessfully will throw. If\nyou wish to ignore such failures, simply use run in non-sink context:\n\n    run 'false';     # SUNK! Will throw\n    run('false').so; # OK. Evaluates Proc in Bool context; no sinking\n\nIf you want to capture standard output or error instead of having it\nprinted directly you can use the :out or :err arguments, which will make\nthem available using their respective methods: Proc.out and Proc.err.\n\n    my $proc = run 'echo', 'Raku is Great!', :out, :err;\n    $proc.out.slurp(:close).say; # OUTPUT: «Raku is Great!␤»\n    $proc.err.slurp(:close).say; # OUTPUT: «␤»\n\nYou can use these arguments to redirect them to a filehandle, thus creating\na kind of pipe:\n\n    my $ls-alt-handle = open :w, '/tmp/cur-dir-ls-alt.txt';\n    my $proc = run \"ls\", \"-alt\", :out($ls-alt-handle);\n    # (The file will contain the output of the ls -alt command)\n\nThese argument are quite flexible and admit, for instance, handles to\nredirect them. See Proc and Proc::Async for more details.\n\nSee also new for more examples.\n\n  sub shell\n\n    multi sub shell($cmd, :$in = '-', :$out = '-', :$err = '-',\n                    Bool :$bin, Bool :$chomp = True, Bool :$merge,\n                    Str :$enc, Str:D :$nl = \"\\n\", :$cwd = $*CWD, :$env)\n\n\nRuns a command through the system shell, which defaults to %*ENV<ComSpec>\n/c in Windows, /bin/sh -c otherwise. All shell metacharacters are\ninterpreted by the shell, including pipes, redirects, environment variable\nsubstitutions and so on. Shell escapes are a severe security concern and\ncan cause confusion with unusual file names. Use run if you want to be\nsafe.\n\nThe return value is of type Proc.\n\n    shell 'ls -lR | gzip -9 > ls-lR.gz';\n\nSee Proc for more details, for example on how to capture output.\n\n  routine unpolar\n\nDefined as:\n\n    method unpolar(Real $angle)\n    multi sub unpolar(Real $mag, Real $angle)\n\nReturns a Complex with the coordinates corresponding to the angle in\nradians and magnitude corresponding to the object value or $mag in the case\nit's being used as a sub\n\n    say 1.unpolar(⅓*pi);\n    # OUTPUT: «0.5000000000000001+0.8660254037844386i␤»\n\n  routine printf\n\nDefined as:\n\n    method printf (*@args)\n    multi sub printf(Cool:D $format, *@args)\n\nAs a method, takes the object as a format using the same language as\nStr.sprintf; as a sub, its first argument will be the format string, and\nthe rest of the arguments will be substituted in the format following the\nformat conventions.\n\n    \"%s is %s\".printf(\"þor\", \"mighty\");    # OUTPUT: «þor is mighty»\n    printf( \"%s is %s\", \"þor\", \"mighty\");  # OUTPUT: «þor is mighty»\n\n  routine sprintf\n\nDefined as:\n\n    method sprintf(*@args)\n    multi sub sprintf(Cool:D $format, *@args)\n\nFormats and outputs a string, following the same language as Str.sprintf,\nusing as such format either the object (if called in method form) or the\nfirst argument (if called as a routine)\n\n    sprintf( \"%s the %d%s\", \"þor\", 1, \"st\").put; #OUTPUT: «þor the 1st␤»\n    sprintf( \"%s is %s\", \"þor\", \"mighty\").put;   # OUTPUT: «þor is mighty␤»\n    \"%s's weight is %.2f %s\".sprintf( \"Mjölnir\", 3.3392, \"kg\").put;\n    # OUTPUT: «Mjölnir's weight is 3.34 kg␤»\n\nThis function is mostly identical to the C library's sprintf and printf\nfunctions. The only difference between the two functions is that sprintf\nreturns a string while the printf function writes to a filehandle. sprintf\nreturns a Str, not a literal.\n\nThe $format is scanned for % characters. Any % introduces a format token.\nDirectives guide the use (if any) of the arguments. When a directive other\nthan % is used, it indicates how the next argument passed is to be\nformatted into the string to be created.\n\nThe information below is for a fully functioning sprintf implementation\nwhich hasn't been achieved yet. Formats or features not yet implemented are\nmarked NYI.\n\nThe directives are:\n\n  %  a literal percent sign\n  c  a character with the given codepoint\n  s  a string\n  d  a signed integer, in decimal\n  u  an unsigned integer, in decimal\n  o  an unsigned integer, in octal\n  x  an unsigned integer, in hexadecimal\n  e  a floating-point number, in scientific notation\n  f  a floating-point number, in fixed decimal notation\n  g  a floating-point number, in %e or %f notation\n  X  like x, but using uppercase letters\n  E  like e, but using an uppercase \"E\"\n  G  like g, but with an uppercase \"E\" (if applicable)\n  b  an unsigned integer, in binary\n\n\nCompatibility:\n\n  i  a synonym for %d\n  D  a synonym for %ld\n  U  a synonym for %lu\n  O  a synonym for %lo\n  F  a synonym for %f\n\n\nModifiers change the meaning of format directives, but are largely no-ops\n(the semantics are still being determined).\n\n       h   interpret integer as native \"short\" (typically int16)\n  NYI  l   interpret integer as native \"long\" (typically int32 or int64)\n  NYI  ll  interpret integer as native \"long long\" (typically int64)\n  NYI  L   interpret integer as native \"long long\" (typically uint64)\n  NYI  q   interpret integer as native \"quads\" (typically int64 or larger)\n\n\nBetween the % and the format letter, you may specify several additional\nattributes controlling the interpretation of the format. In order, these\nare:\n\n    Format parameter index\n\nAn explicit format parameter index, such as 2$. By default, sprintf will\nformat the next unused argument in the list, but this allows you to take\nthe arguments out of order:\n\n    sprintf '%2$d %1$d', 12, 34;      # OUTPUT: «34 12␤»\n    sprintf '%3$d %d %1$d', 1, 2, 3;  # OUTPUT: «3 1 1␤»\n\n    Flags\n\nOne or more of:\n\n  space  prefix non-negative number with a space\n  +      prefix non-negative number with a plus sign\n  -      left-justify within the field\n  0      use leading zeros, not spaces, for required padding\n  #      ensure the leading \"0\" for any octal, prefix non-zero hexadecimal with \"0x\" or \"0X\", prefix non-zero binary with \"0b\" or \"0B\"\n\n\nFor example:\n\n    sprintf '<% d>',  12;   # RESULT: «< 12>␤»\n    sprintf '<% d>',   0;   # RESULT: «< 0>\"»\n    sprintf '<% d>', -12;   # RESULT: «<-12>␤»\n    sprintf '<%+d>',  12;   # RESULT: «<+12>␤»\n    sprintf '<%+d>',   0;   # RESULT: «<+0>\"»\n    sprintf '<%+d>', -12;   # RESULT: «<-12>␤»\n    sprintf '<%6s>',  12;   # RESULT: «<    12>␤»\n    sprintf '<%-6s>', 12;   # RESULT: «<12    >␤»\n    sprintf '<%06s>', 12;   # RESULT: «<000012>␤»\n    sprintf '<%#o>',  12;   # RESULT: «<014>␤»\n    sprintf '<%#x>',  12;   # RESULT: «<0xc>␤»\n    sprintf '<%#X>',  12;   # RESULT: «<0XC>␤»\n    sprintf '<%#b>',  12;   # RESULT: «<0b1100>␤»\n    sprintf '<%#B>',  12;   # RESULT: «<0B1100>␤»\n\nWhen a space and a plus sign are given as the flags at once, the space is\nignored:\n\n    sprintf '<%+ d>', 12;   # RESULT: «<+12>␤»\n    sprintf '<% +d>', 12;   # RESULT: «<+12>␤»\n\nWhen the # flag and a precision are given in the %o conversion, the\nnecessary number of 0s is added at the beginning. If the value of the\nnumber is 0 and the precision is 0, it will output nothing; precision 0 or\nsmaller than the actual number of elements will return the number with 0 to\nthe left:\n\n    say sprintf '<%#.5o>', 0o12;     # OUTPUT: «<00012>␤»\n    say sprintf '<%#.5o>', 0o12345;  # OUTPUT: «<012345>␤»\n    say sprintf '<%#.0o>', 0;        # OUTPUT: «<>␤» zero precision and value 0 results in no output!\n    say sprintf '<%#.0o>', 0o1       # OUTPUT: «<01>␤»\n\n    Vector flag\n\nThis flag tells Raku to interpret the supplied string as a vector of\nintegers, one for each character in the string. Raku applies the format to\neach integer in turn, then joins the resulting strings with a separator (a\ndot, '.', by default). This can be useful for displaying ordinal values of\ncharacters in arbitrary strings:\n\n    NYI sprintf \"%vd\", \"AB\\x[100]\";           # \"65.66.256\"\n\n\nYou can also explicitly specify the argument number to use for the join\nstring using something like *2$v; for example:\n\n    NYI sprintf '%*4$vX %*4$vX %*4$vX',       # 3 IPv6 addresses\n            @addr[1..3], \":\";\n\n\n    (Minimum) Width\n\nArguments are usually formatted to be only as wide as required to display\nthe given value. You can override the width by putting a number here, or\nget the width from the next argument (with * ) or from a specified argument\n(e.g., with *2$):\n\n     sprintf \"<%s>\", \"a\";           # RESULT: «<a>␤»\n     sprintf \"<%6s>\", \"a\";          # RESULT: «<     a>␤»\n     sprintf \"<%*s>\", 6, \"a\";       # RESULT: «<     a>␤»\n     NYI sprintf '<%*2$s>', \"a\", 6; # \"<     a>\"\n     sprintf \"<%2s>\", \"long\";       # RESULT: «<long>␤» (does not truncate)\n\n\nIf a field width obtained through * is negative, it has the same effect as\nthe - flag: left-justification.\n\n    Precision, or maximum width\n\nYou can specify a precision (for numeric conversions) or a maximum width\n(for string conversions) by specifying a . followed by a number. For\nfloating-point formats, except g and G, this specifies how many places\nright of the decimal point to show (the default being 6). For example:\n\n    # these examples are subject to system-specific variation\n    sprintf '<%f>', 1;    # RESULT: «\"<1.000000>\"␤»\n    sprintf '<%.1f>', 1;  # RESULT: «\"<1.0>\"␤»\n    sprintf '<%.0f>', 1;  # RESULT: «\"<1>\"␤»\n    sprintf '<%e>', 10;   # RESULT: «\"<1.000000e+01>\"␤»\n    sprintf '<%.1e>', 10; # RESULT: «\"<1.0e+01>\"␤»\n\nFor \"g\" and \"G\", this specifies the maximum number of digits to show,\nincluding those prior to the decimal point and those after it; for\nexample:\n\n    # These examples are subject to system-specific variation.\n    sprintf '<%g>', 1;        # RESULT: «<1>␤»\n    sprintf '<%.10g>', 1;     # RESULT: «<1>␤»\n    sprintf '<%g>', 100;      # RESULT: «<100>␤»\n    sprintf '<%.1g>', 100;    # RESULT: «<1e+02>␤»\n    sprintf '<%.2g>', 100.01; # RESULT: «<1e+02>␤»\n    sprintf '<%.5g>', 100.01; # RESULT: «<100.01>␤»\n    sprintf '<%.4g>', 100.01; # RESULT: «<100>␤»\n\nFor integer conversions, specifying a precision implies that the output of\nthe number itself should be zero-padded to this width, where the 0 flag is\nignored:\n\n(Note that this feature currently works for unsigned integer conversions,\nbut not for signed integer.)\n\n    sprintf '<%.6d>', 1;      # <000001>\n    NYI sprintf '<%+.6d>', 1;     # <+000001>\n    NYI sprintf '<%-10.6d>', 1;   # <000001    >\n    sprintf '<%10.6d>', 1;    # <    000001>\n    NYI sprintf '<%010.6d>', 1;   #     000001>\n    NYI sprintf '<%+10.6d>', 1;   # <   +000001>\n    sprintf '<%.6x>', 1;         # RESULT: «<000001>␤»\n    sprintf '<%#.6x>', 1;        # RESULT: «<0x000001>␤»\n    sprintf '<%-10.6x>', 1;      # RESULT: «<000001    >␤»\n    sprintf '<%10.6x>', 1;       # RESULT: «<    000001>␤»\n    sprintf '<%010.6x>', 1;      # RESULT: «<    000001>␤»\n    sprintf '<%#10.6x>', 1;      # RESULT: «<  0x000001>␤»\n\n\nFor string conversions, specifying a precision truncates the string to fit\nthe specified width:\n\n    sprintf '<%.5s>', \"truncated\";   # RESULT: «<trunc>␤»\n    sprintf '<%10.5s>', \"truncated\"; # RESULT: «<     trunc>␤»\n\nYou can also get the precision from the next argument using .*, or from a\nspecified argument (e.g., with .*2$):\n\n    sprintf '<%.6x>', 1;       # RESULT: «<000001>␤»\n    sprintf '<%.*x>', 6, 1;    # RESULT: «<000001>␤»\n    NYI sprintf '<%.*2$x>', 1, 6;  # \"<000001>\"\n    NYI sprintf '<%6.*2$x>', 1, 4; # \"<  0001>\"\n\n\nIf a precision obtained through * is negative, it counts as having no\nprecision at all:\n\n    sprintf '<%.*s>',  7, \"string\";   # RESULT: «<string>␤»\n    sprintf '<%.*s>',  3, \"string\";   # RESULT: «<str>␤»\n    sprintf '<%.*s>',  0, \"string\";   # RESULT: «<>␤»\n    sprintf '<%.*s>', -1, \"string\";   # RESULT: «<string>␤»\n    sprintf '<%.*d>',  1, 0;          # RESULT: «<0>␤»\n    sprintf '<%.*d>',  0, 0;          # RESULT: «<>␤»\n    sprintf '<%.*d>', -1, 0;          # RESULT: «<0>␤»\n\n    Size\n\nFor numeric conversions, you can specify the size to interpret the number\nas using l, h, V, q, L, or ll. For integer conversions (d u o x X b i D U\nO), numbers are usually assumed to be whatever the default integer size is\non your platform (usually 32 or 64 bits), but you can override this to use\ninstead one of the standard C types, as supported by the compiler used to\nbuild Raku:\n\n(Note: None of the following have been implemented.)\n\n  hh           interpret integer as C type \"char\" or \"unsigned char\"\n  h            interpret integer as C type \"short\" or \"unsigned short\"\n  j            interpret integer as C type \"intmax_t\", only with a C99 compiler (unportable)\n  l            interpret integer as C type \"long\" or \"unsigned long\"\n  q, L, or ll  interpret integer as C type \"long long\", \"unsigned long long\", or \"quad\" (typically 64-bit integers)\n  t            interpret integer as C type \"ptrdiff_t\"\n  z            interpret integer as C type \"size_t\"\n\n\n    Order of arguments\n\nNormally, sprintf takes the next unused argument as the value to format for\neach format specification. If the format specification uses * to require\nadditional arguments, these are consumed from the argument list in the\norder they appear in the format specification before the value to format.\nWhere an argument is specified by an explicit index, this does not affect\nthe normal order for the arguments, even when the explicitly specified\nindex would have been the next argument.\n\nSo:\n\n    my $a = 5; my $b = 2; my $c = 'net';\n    sprintf \"<%*.*s>\", $a, $b, $c; # RESULT: «<   ne>␤»\n\nuses $a for the width, $b for the precision, and $c as the value to format;\nwhile:\n\n    NYI sprintf '<%*1$.*s>', $a, $b;\n\n\nwould use $a for the width and precision and $b as the value to format.\n\nHere are some more examples; be aware that when using an explicit index,\nthe $ may need escaping:\n\n    sprintf \"%2\\$d %d\\n\",      12, 34;     # RESULT: «34 12␤␤»\n    sprintf \"%2\\$d %d %d\\n\",   12, 34;     # RESULT: «34 12 34␤␤»\n    sprintf \"%3\\$d %d %d\\n\",   12, 34, 56; # RESULT: «56 12 34␤␤»\n    NYI sprintf \"%2\\$*3\\$d %d\\n\",  12, 34,  3; # \" 34 12\\n\"\n    NYI sprintf \"%*1\\$.*f\\n\",       4,  5, 10; # \"5.0000\\n\"\n\n\nOther examples:\n\n    NYI sprintf \"%ld a big number\", 4294967295;\n    NYI sprintf \"%%lld a bigger number\", 4294967296;\n    sprintf('%c', 97);                  # RESULT: «a␤»\n    sprintf(\"%.2f\", 1.969);             # RESULT: «1.97␤»\n    sprintf(\"%+.3f\", 3.141592);         # RESULT: «+3.142␤»\n    sprintf('%2$d %1$d', 12, 34);       # RESULT: «34 12␤»\n    sprintf(\"%x\", 255);                 # RESULT: «ff␤»\n\n\nSpecial case: sprintf(\"<b>%s</b>\\n\", \"Raku\") will not work, but one of the\nfollowing will:\n\n    sprintf Q:b \"<b>%s</b>\\n\",  \"Raku\"; # RESULT: «<b>Raku</b>␤␤»\n    sprintf     \"<b>\\%s</b>\\n\", \"Raku\"; # RESULT: «<b>Raku</b>␤␤»\n    sprintf     \"<b>%s\\</b>\\n\", \"Raku\"; # RESULT: «<b>Raku</b>␤␤»\n\n\n  sub flat\n\nDefined as:\n\n    multi flat(**@list)\n    multi flat(Iterable \\a)\n\nConstructs a list which contains any arguments provided, and returns the\nresult of calling the .flat method (inherited from Any) on that list or\nIterable:\n\n    say flat 1, (2, (3, 4), $(5, 6)); # OUTPUT: «(1 2 3 4 (5 6))␤»\n\n  routine unique\n\nDefined as:\n\n    multi sub unique(+values, |c)\n\nReturns a sequence of unique values from the invocant/argument list, such\nthat only the first occurrence of each duplicated value remains in the\nresult list. unique uses the semantics of the === operator to decide\nwhether two objects are the same, unless the optional :with parameter is\nspecified with another comparator. The order of the original list is\npreserved even as duplicates are removed.\n\nExamples:\n\n    say <a a b b b c c>.unique;   # OUTPUT: «(a b c)␤»\n    say <a b b c c b a>.unique;   # OUTPUT: «(a b c)␤»\n\n(Use squish instead if you know the input is sorted such that identical\nobjects are adjacent.)\n\nThe optional :as parameter allows you to normalize/canonicalize the\nelements before unique-ing. The values are transformed for the purposes of\ncomparison, but it's still the original values that make it to the result\nlist; however, only the first occurrence will show up in that list:\n\nExample:\n\n    say <a A B b c b C>.unique(:as(&lc))      # OUTPUT: «(a B c)␤»\n\nOne can also specify the comparator with the optional :with parameter. For\ninstance if one wants a list of unique hashes, one could use the eqv\ncomparator.\n\nExample:\n\n    my @list = %(a => 42), %(b => 13), %(a => 42);\n    say @list.unique(:with(&[eqv]))           # OUTPUT: «({a => 42} {b => 13})␤»\n\nNote: since :with Callable has to be tried with all the items in the list,\nthis makes unique follow a path with much higher algorithmic complexity.\nYou should try to use the :as argument instead, whenever possible.\n\n  routine repeated\n\nDefined as:\n\n    multi sub    repeated(+values, |c)\n\nThis returns a sequence of repeated values from the invocant/argument list.\nIt takes the same parameters as unique, but instead of passing through any\nelements when they're first seen, they're only passed through as soon as\nthey're seen for the second time (or more).\n\nExamples:\n\n    say <a a b b b c c>.repeated;                   # OUTPUT: «(a b b c)␤»\n    say <a b b c c b a>.repeated;                   # OUTPUT: «(b c b a)␤»\n    say <a A B b c b C>.repeated(:as(&lc));         # OUTPUT: «(A b b C)␤»\n\n    my @list = %(a => 42), %(b => 13), %(a => 42);\n    say @list.repeated(:with(&[eqv]))               # OUTPUT: «({a => 42})␤»\n\nAs in the case of unique the associative argument :as takes a Callable that\nnormalizes the element before comparison, and :with takes a the equality\ncomparison function that is going to be used.\n\n  routine squish\n\nDefined as:\n\n    sub          squish( +values, |c)\n\nReturns a sequence of values from the invocant/argument list where runs of\none or more values are replaced with only the first instance. Like unique,\nsquish uses the semantics of the === operator to decide whether two objects\nare the same. Unlike unique, this function only removes adjacent\nduplicates; identical values further apart are still kept. The order of the\noriginal list is preserved even as duplicates are removed.\n\nExamples:\n\n    say <a a b b b c c>.squish; # OUTPUT: «(a b c)␤»\n    say <a b b c c b a>.squish; # OUTPUT: «(a b c b a)␤»\n\nThe optional :as parameter, just like with unique, allows values to be\ntemporarily transformed before comparison.\n\nThe optional :with parameter is used to set an appropriate comparison\noperator:\n\n    say [42, \"42\"].squish;                      # OUTPUT: «(42 42)␤»\n    # Note that the second item in the result is still Str\n    say [42, \"42\"].squish(with => &infix:<eq>); # OUTPUT: «(42)␤»\n    # The resulting item is Int\n\n  sub emit\n\nDefined as\n\n    sub emit(\\value --> Nil)\n\nIf used outside any supply or react block, throws an exception emit without\nsupply or react. Within a Supply block, it will add a message to the\nstream.\n\n    my $supply = supply {\n      for 1 .. 10 {\n          emit($_);\n      }\n    }\n    $supply.tap( -> $v { say \"First : $v\" });\n\n\nSee also the page for emit methods.\n\n  sub undefine\n\nDefined as:\n\n    multi sub undefine(Mu    \\x)\n    multi sub undefine(Array \\x)\n    multi sub undefine(Hash  \\x)\n\nDEPRECATED in 6.d language version and will be removed in 6.e. For Array\nand Hash, it will become equivalent to assigning Empty; for everything\nelse, equivalent to assigning Nil or Empty in the case of arrays or hashes,\nwhose use is advised.\n\nControl routines\n\nRoutines that change the flow of the program, maybe returning a value.\n\n  sub exit\n\nDefined as:\n\n    multi sub exit()\n    multi sub exit(Int(Any) $status)\n\nExits the current process with return code $status or zero if no value has\nbeen specified. The exit value ($status), when different from zero, has to\nbe opportunely evaluated from the process that catches it (e.g., a shell);\nit is the only way to return an exit code different from zero from a Main.\n\nexit prevents the LEAVE phaser to be executed, but it will run the code in\nthe &*EXIT variable.\n\nexit should be used as last resort only to signal the parent process about\nan exit code different from zero, and not to terminate exceptionally a\nmethod or a sub: use exceptions instead.\n\n  sub done\n\nDefined as\n\n    sub done(--> Nil)\n\nIf used outside any supply or react block, throws an exception done without\nsupply or react. Within a Supply block, it will indicate the supply will no\nlonger emit anything. See also documentation on method done.\n\n    my $supply = supply {\n        for 1 .. 3 {\n            emit($_);\n        }\n        done;\n    }\n    $supply.tap( -> $v { say \"Second : $v\" }, done => { say \"No more\" });\n    # OUTPUT: OUTPUT: «Second : 1␤Second : 2␤Second : 3␤No More␤»\n\n\nThe block passed to the done named argument will be run when done is called\nwithin the supply block.","methods":[]},{"name":"Distribution","methods":["meta\n\n    method meta(--> Hash:D) { ... }\n\nReturns a Hash with the representation of the metadata. Please note that an\nactual META6.json file does not need to exist, just a representation in\nthat format.","content\n\n    method content($name-path --> IO::Handle:D) { ... }\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt."],"desc":"TITLE\nrole Distribution\n\nSUBTITLE\nDistribution\n\n    role Distribution { }\n\nInterface for objects that provide API access mapping META6 data to the\nfiles its represents. Objects that fulfill the Distribution role can be\nread by e.g. CompUnit::Repository::Installation. Generally a Distribution\nprovides read access to a set of modules and metadata. These may be backed\nby the filesystem (Distribution::Path, Distribution::Hash) but could also\nread from an e.g. tar file or socket.\n\nRequired "},{"name":"UInt","methods":[],"desc":"TITLE\nSubset UInt\n\nSUBTITLE\nUnsigned integer (arbitrary-precision)\n\nThe UInt is defined as a subset of Int:\n\n    my subset UInt of Int where {not .defined or $_ >= 0};\n\n\nConsequently, it cannot be instantiated or subclassed; however, that\nshouldn't affect most normal uses.\n\nSome examples of its behavior and uses:\n\n    say UInt ~~ Int; # OUTPUT: «True␤»\n    my UInt $u = 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff; # 64-bit unsigned value\n    say $u.base(16); # OUTPUT: «FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF␤» (32 digits)\n    ++$u;\n    say $u.base(16); # OUTPUT: «100000000000000000000000000000000␤» (33 digits!)\n    my Int $i = $u;\n    say $i.base(16); # same as above\n    say $u.^name;    # OUTPUT: «Int␤» - UInt is a subset, so the type is still Int.\n    say $i.^name;    # OUTPUT: «Int␤»\n    # Difference in assignment\n    my UInt $a = 5;  # nothing wrong\n    my UInt $b = -5; # Exception about failed type check\n    my UInt $c = 0;\n    --$c;            # Exception again\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $b; expected UInt but got Int (-5)␤»\n\n    # Non-assignment operations are fine\n    my UInt $d = 0;\n    say $d - 3;      # OUTPUT: «-3␤»"},{"desc":"TITLE\nclass ValueObjAt\n\nSUBTITLE\nUnique identification for value types\n\n    class ValueObjAt is ObjAt { }\n\nA subclass of ObjAt that should be used to indicate that a class produces\nobjects that are value types (in other words: are immutable after they have\nbeen initialized.\n\n    my %h = a => 42;        # mutable Hash\n    say %h.WHICH;           # OUTPUT: «ObjAt.new(\"Hash|1402...888\")␤»\n\n    my %m is Map = a => 42; # immutable Map\n    say %m.WHICH;           # OUTPUT: «ValueObjAt.new(\"Map|AAF...09F61F\")␤»\n\nIf you create a class that should be considered a value type, you should\nadd a WHICH method to that class that returns a ValueObjAt object, for\ninstance:\n\n    class YourClass {\n        has $.foo;  # note these are not mutable\n        has $.bar;\n\n        method WHICH() {\n            ValueObjAt.new(\"YourClass|$!foo|$!bar\");\n        }\n    }\n\nNote that it is customary to always start the identifying string with the\nname of the object, followed by a \"|\". This to prevent confusion with other\nclasses that may generate similar string values: the name of the class\nshould then be enough of a differentiator to prevent collisions.","methods":[],"name":"ValueObjAt"},{"methods":["ACCEPTS\n\n    multi method ACCEPTS(Code:D: Mu $topic)\n\nUsually calls the code object and passes $topic as an argument. However,\nwhen called on a code object that takes no arguments, the code object is\ninvoked with no arguments and $topic is dropped. The result of the call is\nreturned.","arity\n\nDefined as:\n\n    method arity(Code:D: --> Int:D)\n\nReturns the minimum number of positional arguments that must be passed in\norder to call the code object. Any optional or slurpy parameters in the\ncode object's Signature do not contribute, nor do named parameters.\n\n    sub argless() { }\n    sub args($a, $b?) { }\n    sub slurpy($a, $b, *@c) { }\n    say &argless.arity;             # OUTPUT: «0␤»\n    say &args.arity;                # OUTPUT: «1␤»\n    say &slurpy.arity;              # OUTPUT: «2␤»","assuming\n\n    method assuming(Callable:D $self: |primers)\n\nReturns a Callable that implements the same behavior as the original, but\nhas the values passed to .assuming already bound to the corresponding\nparameters.\n\n    my sub slow($n){ my $i = 0; $i++ while $i < $n; $i };\n\n    # takes only one parameter and as such wont forward $n\n    sub bench(&c){ c, now - ENTER now };\n\n    say &slow.assuming(10000000).&bench; # OUTPUT: «(10000000 7.5508834)␤»\n\nFor a sub with arity greater than one, you can use Whatever * for all of\nthe positional parameters that are not \"assumed\".\n\n    sub first-and-last ( $first, $last ) {\n        say \"Name is $first $last\";\n    }\n\n    my &surname-smith = &first-and-last.assuming( *, 'Smith' );\n\n    &surname-smith.( 'Joe' ); # OUTPUT: «Name is Joe Smith␤»\n\nYou can handle any combination of assumed and not assumed positional\nparameters:\n\n    sub longer-names ( $first, $middle, $last, $suffix ) {\n        say \"Name is $first $middle $last $suffix\";\n    }\n\n    my &surname-public = &longer-names.assuming( *, *, 'Public', * );\n\n    &surname-public.( 'Joe', 'Q.', 'Jr.'); # OUTPUT: «Name is Joe Q. Public Jr.␤»\n\n\nNamed parameters can be assumed as well:\n\n    sub foo { say \"$^a $^b $:foo $:bar\" }\n    &foo.assuming(13, :42foo)(24, :72bar); # OUTPUT: «13 24 42 72␤»\n\nAnd you can use .assuming on all types of Callables, including"],"desc":"TITLE\nclass Code\n\nSUBTITLE\nCode object\n\n    class Code is Any does Callable {}\n\nCode is the ultimate base class of all code objects in Raku. It exposes\nfunctionality that all code objects have. While thunks are directly of type\nCode, most code objects (such as those resulting from blocks, subroutines\nor methods) will belong to some subclass of Code.\n\n","name":"Code"},{"methods":["pos\n\n    method pos()\n\nReturns the current position as a string index into Match.target for a\nregex match in progress:\n\n    my $a = 'abcdef';\n    $a ~~ /b. {say $/.pos }../; say $/.pos;     # OUTPUT: «3␤»\n\nYou should not use this method on finished Match, as the output can be\nimplementation specific.","target\n\n    method target()\n\nReturns a string representation of the object against which the regex\nmatches. This is the value that the regex engine works with internally.\n\n    my $a = \"þor\" ~~ /o/;\n    say $a.target # OUTPUT: «þor␤»","chars\n\nReturns the numbers of characters in the matched string.\n\nReturns the same as .Str.chars.","clone\n\nDefined as:\n\n    method clone()\n\nClones the Match object.","orig\n\nReturns the original input to the regex engine, which is usually a string,\nbut doesn't need to be (could be anything that can be coerced to a\nstring):\n\n    42 ~~ /.+/;\n    say $/.orig;            # OUTPUT: «42»\n    say $/.orig.^name;      # OUTPUT: «Int»\n\nSee #method target for a close equivalent that always returns a string.","from\n\nReturns the index of the starting position of the match.","to\n\nReturns the index of the end position of the match.","made\n\nReturns the payload that was set with make.","make\n\nDefined as\n\n    method make(Match:D: Mu $payload)\n    sub make(Mu $payload)\n\nSets the .ast attribute, which will be retrieved using .made.\n\n    $/.make(\"your payload here\");\n\nThat is, it stores an arbitrary payload into the Match object that can\nlater be retrieved via .made method.\n\nThis is typically used in a grammar's actions class methods, where a piece\nof data is stored by one method and then later retrieved by another. It's\nup to you what data you store. It could be a tree node, result of a\ncalculation, or a list of values.\n\nThe sub form operates on the current Match $/, which can be a convenient\nshortcut:\n\n    method my-action ($/) {\n        make \"foo: $/\";\n    }","actions\n\n    method actions(Match:D: --> Mu)\n\nReturns the actions object (if any was set; else Mu) that the grammar used\nfrom which this Match object was created.","ast\n\nAlias for #method made.","Bool\n\nDefined as:\n\n    method Bool(Capture:D: --> Bool:D)\n\nReturns True on successful and False on unsuccessful matches. Please note\nthat any zero-width match can also be successful.\n\n    say 'abc' ~~ /^/;                   # OUTPUT: «｢｣␤»\n    say $/.from, ' ',  $/.to, ' ', ?$/; # OUTPUT: «0 0 True␤»","Str\n\nDefined as:\n\n    method Str(Match:D: --> Str:D)\n\nReturns the matched text.\n\n    \"abc123def\" ~~ /\\d+/;\n    say $/.Str;               # OUTPUT: «123␤»","Int\n\nDefined as:\n\n    method Int(Match:D: --> Int:D)\n\nTries to convert stringified result of the matched text into Int.\n\n    say ('12345' ~~ /234/).Int;       # OUTPUT: «234␤»\n    say ('12345' ~~ /234/).Int.^name; # OUTPUT: «Int␤»\n    # the next line produces a warning about using Nil (result of a no match) in numeric context\n    say ('one-two' ~~ /234/).Int;     # OUTPUT: «0␤» # because Nil.Int returns 0","caps\n\nReturns a list of pairs, with the index or submatch name as key and the\nsubmatches as values. The list is ordered by starting position of the\nsubmatches.","chunks\n\nReturns a list of pairs, with the index or submatch name as key and the\nsubmatches as values. The list is ordered by starting position of the\nsubmatches.\n\nThose parts of the string that were not matched by submatches are\ninterleaved with the other pairs, with the string ~ as key.","list\n\nReturns a list of positional submatches.","hash\n\nReturns a hash of named submatches.","prematch\n\nDefined as:\n\n    method prematch(Match:D: --> Str:D)\n\nReturns the part of the original string leading up to the match.\n\n    'abcdefg' ~~ /cd/;\n    say $/.prematch;          # OUTPUT: «ab␤»\n\n    # will return a list of three match objects\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.[1].prematch;      # OUTPUT: «abc1␤»","postmatch\n\nDefined as:\n\n    method postmatch(Match:D: --> Str:D)\n\nReturns the part of the original string following the match.\n\n    'abcdefg' ~~ /cd/;\n    say $/.postmatch;         # OUTPUT: «efg␤»\n\n    # will return a list of three match objects\n    \"abc123def\" ~~ m:g/\\d/;\n    say $/.[1].postmatch;     # OUTPUT: «3def␤»","infix:<eqv>\n\nDefined as:\n\n    multi sub infix:<eqv>(Match:D \\a, Match:D \\b)\n\nReturns True if the attributes pos, from and orig are equal, and if made,\nCapture::list and Capture::hash are either the same or both undefined."],"desc":"TITLE\nclass Match\n\nSUBTITLE\nResult of a successful regex match\n\n    class Match is Capture is Cool does NQPMatchRole {}\n\nMatch objects are the result of a successful regex match, this does include\nany zero-width match. They store a reference to the original string\n(.orig), positional and named captures, the positions of the start and end\nof the match in the original string, and a payload referred to as AST\n(abstract syntax tree), which can be used to build data structures from\ncomplex regexes and grammars.\n\nThe last match is also stored in the $¢ Match object, which is lexically\nscoped to the regex, that is, only available from within the regular\nexpression, as shown here:\n\n    my $c;\n    'abc' ~~ /.$${ $c = $¢ }/;\n    say $c; # OUTPUT: «｢c｣␤»\n\nIn this case, we are running the code among curly braces when the match\noccurs, in this case the last letter in the string (actually, the last,\nindicated by the double $, character); $c gets the value of the cursor $¢,\nwhich contains the Match; when used with say, the Match is stringified by\ncalling .Str on it. This $¢ offers a way of capturing the Match inside a\nregular expression; outside, you need to use $/\n\n    my $c; 'camelia' ~~ /<[ l m ]> {$c = $¢}/;\n    say $c; # OUTPUT: «｢m｣␤»\n    say $/; # OUTPUT: «｢m｣␤»\n\nNote: This feature works only from Raku version 2018.02. It would have\nreturned Nil with any previous version. Alternatively and prior to that\nversion, you could use $/ which, inside the regex, has the same value:\n\n    '123' ~~ / (\\d) { say $0; say $/; } \\d+ /; # OUTPUT: «｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n\nThe main difference between $/ and $¢ is scope: the latter only has a value\ninside the regex:\n\n    '123' ~~ / (\\d) { say $/; say $¢; } \\d+ /; # OUTPUT: «｢1｣␤ 0 => ｢1｣␤｢1｣␤ 0 => ｢1｣␤»\n    say \"¢ → \", $¢, \"/ is $/\"; ; # OUTPUT: «¢ → Nil/ is 123␤»\n\n\nSubmatches are also Match objects (or lists of Match objects, if the\ncorresponding regex was quantified), so each match object can be seen as\nthe root of a tree of match objects.\n\nA Match object can also hold the result of a match in progress (while the\ngrammar engine is running), in which case the pos method returns the\ncurrent position. This view on Match objects is only visible if you call\ncode from within a regex.\n\nNote (deprecated): There is a synonym for this class, Cursor, defined as:\n\n    my constant Cursor = Match\n\nInitially, it was used to keep track of initial position in regex matches.\nIn current versions, it's an alias for Match.\n\n","name":"Match"},{"desc":"TITLE\nclass IntStr\n\nSUBTITLE\nDual value integer and string\n\n    class IntStr is Int is Str { }\n\nThe dual value types (often referred to as allomorphs) allow for the\nrepresentation of a value as both a string and a numeric type. Typically\nthey will be created for you when the context is \"stringy\" but they can be\ndetermined to be numbers, such as in some quoting constructs:\n\n    my $f = <42>; say $f.^name; # OUTPUT: «IntStr␤»\n\nAs a subclass of both Int and Str, an IntStr will be accepted where either\nis expected. However, IntStr does not share object identity with Int- or\nStr-only variants:\n\n    my $int-str = <42>;\n    my Int $int = $int-str; # OK!\n    my Str $str = $int-str; # OK!\n    say 42 ∈ <42  55  1>;   # False; ∈ operator cares about object identity\n\n","methods":["new\n\n    method new(Int $i, Str $s)\n\nThe constructor requires both the Int and the Str value, when constructing\none directly the values can be whatever is required:\n\n    my $f = IntStr.new(42, \"forty two\");\n    say +$f; # OUTPUT: «42␤»\n    say ~$f; # OUTPUT: «\"forty two\"␤»","Bool\n\nDefined as:\n\n    multi method Bool(IntStr:D: --> Bool:D)\n\nThis method may be provided by the parent classes and not implemented in\nIntStr directly.\n\nReturns False if the invocant is numerically 0, otherwise returns True.\nString portion is not considered.","Int\n\n    method Int\n\nReturns the integer value of the IntStr.","Numeric\n\nDefined as:\n\n    multi method Numeric(IntStr:D: --> Int:D)\n    multi method Numeric(IntStr:U: --> Int:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0.","Real\n\nDefined as:\n\n    multi method Real(IntStr:D: --> Int:D)\n    multi method Real(IntStr:U: --> Int:D)\n\nThe :D variant returns the numeric portion of the invocant. The :U variant\nissues a warning about using an uninitialized value in numeric context and\nthen returns value 0.","Str\n\nReturns the string value of the IntStr.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(IntStr:D: Any:D $value)\n\nIf $value is Numeric (including another allomorph), checks if invocant's\nNumeric part ACCEPTS the $value. If $value is Str, checks if invocant's Str\npart ACCEPTS the $value. If value is anything else, checks if both Numeric\nand Str parts ACCEPTS the $value.\n\n    say <5> ~~ \"5.0\"; # OUTPUT: «False␤»\n    say <5> ~~  5.0 ; # OUTPUT: «True␤»\n    say <5> ~~ <5.0>; # OUTPUT: «True␤»"],"name":"IntStr"},{"desc":"TITLE\nclass Failure\n\nSUBTITLE\nDelayed exception\n\n    class Failure is Nil { }\n\nA Failure is a soft or unthrown Exception, usually generated by calling\n&fail. It acts as a wrapper around an Exception object.\n\nSink (void) context causes a Failure to throw, i.e. turn into a normal\nexception. The use fatal pragma causes this to happen in all contexts\nwithin the pragma's scope. Inside try blocks, use fatal is automatically\nset, and you can disable it with no fatal.\n\nThat means that Failures are generally only useful in cases of code that\nnormally would produce an rvalue; Failures are more or less equivalent to\nExceptions in code that will frequently be called in sink context (i.e.,\nfor its side-effects, such as with say).\n\nSimilarly, you should generally use &fail only inside code that is normally\nexpected to return something.\n\nChecking a Failure for truth (with the Bool method) or definedness (with\nthe defined method) marks the failure as handled, and causes it not to\nthrow in sink context anymore.\n\nYou can call the handled method to check if a failure has been handled.\n\nCalling methods on unhandled failures propagates the failure. The\nspecification says the result is another Failure, in Rakudo it causes the\nfailure to throw.\n\nBecause a Failure is Nil, which is undefined, a common idiom for safely\nexecuting code that may fail uses a with/else statement:\n\n    sub may_fail( --> Numeric:D ) {\n      my $value = (^10).pick || fail \"Zero is unacceptable\";\n      fail \"Odd is also not okay\" if $value % 2;\n      return $value;\n    }\n\n    with may_fail() -> $value { # defined, so didn't fail\n      say \"I know $value isn't zero or odd.\"\n    } else { # undefined, so failed, and the Failure is the topic\n      say \"Uh-oh: {.exception.message}.\"\n    }\n\n\n","methods":["new\n\nDefined as:\n\n    method new(Failure:D: $payload --> Failure)\n\nReturns a new Failure instance with the given payload. The latter can be\neither an Exception or a payload for an Exception. A typical payload would\nbe a Str with an error message. A list of payloads is also accepted.\n\n    my $e = Failure.new(now.DateTime, 'WELP‼');\n    say $e;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::AdHoc: 2017-09-10T11:56:05.477237ZWELP‼␤»","handled\n\nDefined as:\n\n    method handled(Failure:D: --> Bool:D)\n\nReturns True for handled failures, False otherwise.\n\n    sub f() { fail }; my $v = f; say $v.handled; # OUTPUT: «False␤»\n\nThe handled method is an lvalue, which means you can also use it to set the\nhandled state:\n\n    sub f() { fail }\n    my $v = f;\n    $v.handled = True;\n    say $v.handled; # OUTPUT: «True␤»","exception\n\nDefined as:\n\n    method exception(Failure:D: --> Exception)\n\nReturns the Exception object that the failure wraps.\n\n    sub failer() { fail };\n    my $failure = failer;\n    my $ex = $failure.exception;\n    put \"$ex.^name(): $ex\";\n    # OUTPUT: «X::AdHoc: Failed␤»","self\n\nDefined as:\n\n    method self(Failure:D: --> Failure:D)\n\nIf the invocant is a handled Failure, returns it as is. If not handled,\nthrows its Exception. Since Mu type provides .self for every class, calling\nthis method is a handy way to explosively filter out Failures:\n\n    my $num1 = '♥'.Int;\n    # $num1 now contains a Failure object, which may not be desirable\n\n    my $num2 = '♥'.Int.self;\n    # .self method call on Failure causes an exception to be thrown\n\n    my $num3 = '42'.Int.self;\n    # Int type has a .self method, so here $num3 has `42` in it\n\n    (my $stuff = '♥'.Int).so;\n    say $stuff.self; # OUTPUT: «(HANDLED) Cannot convert string to number…»\n    # Here, Failure is handled, so .self just returns it as is","Bool\n\nDefined as:\n\n    multi method Bool(Failure:D: --> Bool:D)\n\nReturns False, and marks the failure as handled.\n\n    sub f() { fail }; my $v = f; say $v.handled; $v.Bool; say $v.handled;\n    # OUTPUT: «False␤\n    # True␤»","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture if the invocant is a type object or a handled\nFailure. Otherwise, throws the invocant's exception.","defined\n\nDefined as:\n\n    multi method defined(Failure:D: --> Bool:D)\n\nReturns False (failures are officially undefined), and marks the failure as\nhandled.\n\n    sub f() { fail }; my $v = f; say $v.defined; # OUTPUT: «False␤»"],"name":"Failure"},{"desc":"TITLE\nrole Systemic\n\nSUBTITLE\nInformation related to the build system\n\nBuilt-in class for providing built system related information. Usually\naccessed through dynamic variables mixing this role such as the $*KERNEL,\n$*VM, or $*PERL.\n\n","methods":["auth\n\nInstance method returning the \"auth\" (as in \"author\" or \"authority\") of the\nobject. Returns \"unknown\" if the \"auth\" could not be established.","config\n\nInstance returning a hash with object configuration information. Subject to\nchange without notice, but can be helpful in environments where only one\ntype of virtual machine is in use, or to find about the configuration of\nany other object that mixes in this role.","desc\n\nInstance method returning the \"desc\" (as in \"description\") of the VM\nobject. Returns a Str type object if the \"desc\" could not be established.","name\n\nInstance method returning the name of the object.","signature\n\nInstance method returning the signature of the object. Returns a Blob type\nobject if the signature could not be established.","version\n\nInstance method returning the version of the object as a Version object.\nReturns a Version object \"unknown\" if the version could not be\nestablished.","gist\n\n    method gist( Systemic:D: )\n\nInstance method returning the name and version of the object.\n\n    say $*PERL.gist; # OUTPUT: «Raku (6.c)␤»\n\n$*PERL is an object of the Perl type, which mixes in this role and thus\nimplements this method.","Str\n\n    method Str\n\nInstance method returning the name of the object.\n\n    say $*PERL.Str; # OUTPUT: «Raku␤»"],"name":"Systemic"},{"desc":"TITLE\nclass Str\n\nSUBTITLE\nString of characters\n\n    class Str is Cool does Stringy { }\n\nBuilt-in class for strings. Objects of type Str are immutable, but read the\nFAQ to understand precisely what this means.\n\n","methods":["chop\n\n    multi method chop(Str:D:)\n    multi method chop(Str:D: Int() $chopping)\n\nReturns the string with $chopping characters removed from the end.\n\n    say \"Whateverable\".chop(3.6);  # OUTPUT: «Whatevera␤»\n    my $string= \"Whateverable\";\n    say $string.chop(\"3\");         # OUTPUT: «Whatevera␤»\n\nThe $chopping positional is converted to Int before being applied to the\nstring.","chomp\n\nDefined as:\n\n    multi sub    chomp(Str:D  --> Str:D)\n    multi method chomp(Str:D: --> Str:D)\n\nReturns the string with a logical newline (any codepoint that has the\nNEWLINE property) removed from the end.\n\nExamples:\n\n    say chomp(\"abc\\n\");       # OUTPUT: «abc␤»\n    say \"def\\r\\n\".chomp;      # OUTPUT: «def␤» NOTE: \\r\\n is a single grapheme!\n    say \"foo\\r\".chomp;        # OUTPUT: «foo␤»","contains\n\nDefined as:\n\n    multi method contains(Str:D: Cool:D $needle --> Bool:D)\n    multi method contains(Str:D: Str:D $needle --> Bool:D)\n    multi method contains(Str:D: Cool:D $needle, Int(Cool:D) $pos --> Bool:D)\n    multi method contains(Str:D: Str:D $needle, Int:D $pos --> Bool:D)\n\nCoerces the invocant (represented in the signature by Str:D:, that would be\nthe haystack) and first argument (which we are calling $needle) to Str (if\nit's not already, that is, in the first and third multi forms), and\nsearches for $needle in the invocant (or haystack) starting from $pos\ncharacters into the string, if that is included as an argument. Returns\nTrue if $needle is found. $pos is an optional parameter, and if it's not\npresent, contains will search from the beginning of the string (using the\nfirst two forms of the multi).\n\n    say <Hello, World>.contains('Hello', 0);   # OUTPUT: «True␤»\n    say \"Hello, World\".contains('Hello');      # OUTPUT: «True␤»\n    say \"Hello, World\".contains('hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".contains('Hello', 1);   # OUTPUT: «False␤»\n    say \"Hello, World\".contains(',');          # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 3);       # OUTPUT: «True␤»\n    say \"Hello, World\".contains(',', 10);      # OUTPUT: «False␤»\n\nIn the first example, coercion is used to convert a List to a Str. In the\n4th case, the 'Hello' string is not found since we have started looking at\nthe second position in it (index 1). Note that because of how a List or\nArray is coerced into a Str, the results may sometimes be surprising. See\ntraps.","lc\n\nDefined as:\n\n    multi sub    lc(Str:D  --> Str:D)\n    multi method lc(Str:D: --> Str:D)\n\nReturns a lower-case version of the string.\n\nExamples:\n\n    lc(\"A\"); # RESULT: «\"a\"»\n    \"A\".lc;  # RESULT: «\"a\"»","uc\n\n    multi sub    uc(Str:D  --> Str:D)\n    multi method uc(Str:D: --> Str:D)\n\nReturns an uppercase version of the string.","fc\n\n    multi sub    fc(Str:D  --> Str:D)\n    multi method fc(Str:D: --> Str:D)\n\nDoes a Unicode \"fold case\" operation suitable for doing caseless string\ncomparisons. (In general, the returned string is unlikely to be useful for\nany purpose other than comparison.)","tc\n\n    multi sub    tc(Str:D  --> Str:D)\n    multi method tc(Str:D: --> Str:D)\n\nDoes a Unicode \"titlecase\" operation, that is changes the first character\nin the string to title case, or to upper case if the character has no title\ncase mapping","tclc\n\n    multi sub    tclc(Str:D  --> Str:D)\n    multi method tclc(Str:D: --> Str:D)\n\nTurns the first character to title case, and all other characters to lower\ncase","wordcase\n\n    multi sub    wordcase(Cool $x  --> Str)\n    multi sub    wordcase(Str:D $x --> Str)\n    multi method wordcase(Str:D: :&filter = &tclc, Mu :$where = True --> Str)\n\n\nReturns a string in which &filter has been applied to all the words that\nmatch $where. By default, this means that the first letter of every word is\ncapitalized, and all the other letters lowercased.","unival\n\n    multi method unival(Str:D --> Numeric)\n\nReturns the numeric value that the first codepoint in the invocant\nrepresents, or NaN if it's not numeric.\n\n    say '4'.unival;     # OUTPUT: «4␤»\n    say '¾'.unival;     # OUTPUT: «0.75␤»\n    say 'a'.unival;     # OUTPUT: «NaN␤»","univals\n\n    multi method univals(Str:D --> List)\n\nReturns a list of numeric values represented by each codepoint in the\ninvocant string, and NaN for non-numeric characters.\n\n    say \"4a¾\".univals;  # OUTPUT: «(4 NaN 0.75)␤»","chars\n\n    multi sub    chars(Cool  $x --> Int:D)\n    multi sub    chars(Str:D $x --> Int:D)\n    multi sub    chars(str   $x --> int)\n    multi method chars(Str:D:   --> Int:D)\n\nReturns the number of characters in the string in graphemes. On the JVM,\nthis currently erroneously returns the number of codepoints instead.","encode\n\n    multi method encode(Str:D $encoding = 'utf8', :$replacement, Bool() :$translate-nl = False, :$strict)\n\nReturns a Blob which represents the original string in the given encoding\nand normal form. The actual return type is as specific as possible, so\n$str.encode('UTF-8') returns a utf8 object, $str.encode('ISO-8859-1') a\nbuf8. If :translate-nl is set to True, it will translate newlines from \\n\nto \\n\\r, but only in Windows. $replacement indicates how characters are\ngoing to be replaced in the case they are not available in the current\nencoding, while $strict indicates whether unmapped codepoints will still\ndecode; for instance, codepoint 129 which does not exist in windows-1252.\n\n    my $str = \"Þor is mighty\";\n    say $str.encode(\"ascii\", :replacement( 'Th') ).decode(\"ascii\");\n    # OUTPUT: «Thor is mighty␤»\n\nIn this case, any unknown character is going to be substituted by Th. We\nknow in advance that the character that is not known in the ascii encoding\nis Þ, so we substitute it by its latin equivalent, Th. In the absence of\nany replacement set of characters, :replacement is understood as a Bool:\n\n    say $str.encode(\"ascii\", :replacement).decode(\"ascii\"); # OUTPUT: «?or is mighty␤»\n\n\nIf :replacement is not set or assigned a value, the error Error encoding\nASCII string: could not encode codepoint 222 will be issued (in this case,\nsince þ is codepoint 222).\n\nSince the Blob returned by encode is the original string in normal form,\nand every element of a Blob is a byte, you can obtain the length in bytes\nof a string by calling a method that returns the size of the Blob on it:\n\n    say \"þor\".encode.bytes; # OUTPUT: «4␤»\n    say \"þor\".encode.elems; # OUTPUT: «4␤»","index\n\n    multi method index(Str:D: Cool:D $needle --> Int:D)\n    multi method index(Str:D: Str:D $needle --> Int:D)\n    multi method index(Str:D: Cool:D $needle, Cool:D $pos --> Int:D)\n    multi method index(Str:D: Str:D $needle, Int:D $pos --> Int:D)\n\nSearches for $needle in the string starting from $pos (if present). It\nreturns the offset into the string where $needle was found, and Nil if it\nwas not found.\n\nExamples:\n\n    say index \"Camelia is a butterfly\", \"a\";     # OUTPUT: «1␤»\n    say index \"Camelia is a butterfly\", \"a\", 2;  # OUTPUT: «6␤»\n    say index \"Camelia is a butterfly\", \"er\";    # OUTPUT: «17␤»\n    say index \"Camelia is a butterfly\", \"Camel\"; # OUTPUT: «0␤»\n    say index \"Camelia is a butterfly\", \"Onion\"; # OUTPUT: «Nil␤»\n\n    say index(\"Camelia is a butterfly\", \"Onion\").defined ?? 'OK' !! 'NOT'; # OUTPUT: «NOT␤»\n\nOther forms of index, including a sub, are inherited from Cool. Check them\nthere.","rindex\n\n    multi sub    rindex(Str:D $haystack, Str:D $needle, Int $startpos = $haystack.chars --> Int)\n    multi method rindex(Str:D $haystack: Str:D $needle, Int $startpos = $haystack.chars --> Int)\n\nReturns the last position of $needle in $haystack not after $startpos.\nReturns Nil if $needle wasn't found.\n\nExamples:\n\n    say rindex \"Camelia is a butterfly\", \"a\";     # OUTPUT: «11␤»\n    say rindex \"Camelia is a butterfly\", \"a\", 10; # OUTPUT: «6␤»","indices\n\nDefined as:\n\n    multi method indices(Str:D: Str:D $needle, :$overlap --> List:D)\n    multi method indices(Str:D: Str:D $needle, Int:D $start, :$overlap --> List:D)\n\nSearches for all occurrences of $needle in the string starting from\nposition $start, or zero if it is not specified, and returns a List with\nall offsets in the string where $needle was found, or an empty list if it\nwas not found.\n\nIf the optional parameter :overlap is specified the search continues from\nthe index directly following the previous match, otherwise the search will\ncontinue after the previous match.\n\n    say \"banana\".indices(\"a\");              # OUTPUT: «(1 3 5)␤»\n    say \"banana\".indices(\"ana\");            # OUTPUT: «(1)␤»\n    say \"banana\".indices(\"ana\", :overlap);  # OUTPUT: «(1 3)␤»\n    say \"banana\".indices(\"ana\", 2);         # OUTPUT: «(3)␤»","match\n\n    method match($pat, :continue(:$c), :pos(:$p), :global(:$g), :overlap(:$ov), :exhaustive(:$ex), :st(:$nd), :rd(:$th), :$nth, :$x --> Match)\n\nPerforms a match of the string against $pat and returns a Match object if\nthere is a successful match; it returns (Any) otherwise. Matches are stored\nin the default match variable $/. If $pat is not a Regex object, match will\ncoerce the argument to a Str and then perform a literal match against\n$pat.\n\nA number of optional named parameters can be specified, which alter how the\nmatch is performed.\n\n  * :continue\n\nThe :continue adverb takes as an argument the position where the regex\nshould start to search. If no position is specified for :c it will default\nto 0 unless $/ is set, in which case it defaults to $/.to.\n\n  * :pos\n\nTakes a position as an argument. Fails if regex cannot be matched from that\nposition, unlike :continue.\n\n  * :global\n\nInstead of searching for just one match and returning a Match object,\nsearch for every non-overlapping match and return them in a List.\n\n  * :overlap\n\nFinds all matches including overlapping matches, but only returns one match\nfrom each starting position.\n\n  * :exhaustive\n\nFinds all possible matches of a regex, including overlapping matches and\nmatches that start at the same position.\n\n  * :st, :nd, :rd, :nth\n\nReturns the nth match in the string. The argument can be a Numeric or an\nIterable producing monotonically increasing numbers (that is, the next\nproduced number must be larger than the previous one). The Iterable will be\nlazily reified and if non-monotonic sequence is encountered an exception\nwill be thrown.\n\nIf Iterable argument is provided the return value and $/ variable will be\nset to a possibly-empty List of Match objects.\n\n  * :x\n\nTakes as an argument the number of matches to return, stopping once the\nspecified number of matches has been reached. The value must be a Numeric\nor a Range; other values will cause .match to return a Failure containing\nX::Str::Match::x exception.\n\nExamples:\n\n    say \"properly\".match('perl');                     # OUTPUT: «｢perl｣␤»\n    say \"properly\".match(/p.../);                     # OUTPUT: «｢prop｣␤»\n    say \"1 2 3\".match([1,2,3]);                       # OUTPUT: «｢1 2 3｣␤»\n    say \"a1xa2\".match(/a./, :continue(2));            # OUTPUT: «｢a2｣␤»\n    say \"abracadabra\".match(/ a .* a /, :exhaustive);\n    # OUTPUT: «(｢abracadabra｣ ｢abracada｣ ｢abraca｣ ｢abra｣ ｢acadabra｣ ｢acada｣ ｢aca｣ ｢adabra｣ ｢ada｣ ｢abra｣)␤»\n    say 'several words here'.match(/\\w+/,:global);    # OUTPUT: «(｢several｣ ｢words｣ ｢here｣)␤»\n    say 'abcdef'.match(/.*/, :pos(2));                # OUTPUT: «｢cdef｣␤»\n    say \"foo[bar][baz]\".match(/../, :1st);            # OUTPUT: «｢fo｣␤»\n    say \"foo[bar][baz]\".match(/../, :2nd);            # OUTPUT: «｢o[｣␤»\n    say \"foo[bar][baz]\".match(/../, :3rd);            # OUTPUT: «｢ba｣␤»\n    say \"foo[bar][baz]\".match(/../, :4th);            # OUTPUT: «｢r]｣␤»\n    say \"foo[bar][baz]bada\".match('ba', :x(2));       # OUTPUT: «(｢ba｣ ｢ba｣)␤»","Numeric\n\nDefined as:\n\n    method Numeric(Str:D: --> Numeric:D)\n\nCoerces the string to Numeric using semantics equivalent to val routine.\nFails with X::Str::Numeric if the coercion to a number cannot be done.\n\nOnly Unicode characters with property Nd, as well as leading and trailing\nwhitespace are allowed, with the special case of the empty string being\ncoerced to 0. Synthetic codepoints (e.g. \"7\\x[308]\") are forbidden.\n\nWhile Nl and No characters can be used as numeric literals in the language,\ntheir conversion via Str.Numeric will fail, by design. See unival if you\nneed to coerce such characters to Numeric.","Int\n\nDefined as:\n\n    method Int(Str:D: --> Int:D)\n\nCoerces the string to Int, using the same rules as Str.Numeric.","Rat\n\nDefined as:\n\n    method Rat(Str:D: --> Rational:D)\n\nCoerces the string to a Rat object, using the same rules as Str.Numeric. If\nthe denominator is larger than 64-bits is it still kept and no degradation\nto Num occurs.","Bool\n\nDefined as:\n\n    method Bool(Str:D: --> Bool:D)\n\nReturns False if the string is empty, True otherwise.","parse-base\n\n    multi sub    parse-base(Str:D $num, Int:D $radix --> Numeric)\n    multi method parse-base(Str:D $num: Int:D $radix --> Numeric)\n\nPerforms the reverse of base by converting a string with a base-$radix\nnumber to its Numeric equivalent. Will fail if radix is not in range 2..36\nor if the string being parsed contains characters that are not valid for\nthe specified base.\n\n    1337.base(32).parse-base(32).say; # OUTPUT: «1337␤»\n    'Perl6'.parse-base(30).say;       # OUTPUT: «20652936␤»\n    'FF.DD'.parse-base(16).say;       # OUTPUT: «255.863281␤»\n\nSee also: :16<FF> syntax for number literals","parse-names\n\n    sub    parse-names(Str:D $names  --> Str:D)\n    method parse-names(Str:D $names: --> Str:D)\n\nDEPRECATED. Use uniparse instead. Existed in Rakudo implementation as a\nproof of viability implementation before being renamed and will be removed\nwhen 6.e language is released.","uniparse\n\n    sub    uniparse(Str:D $names  --> Str:D)\n    method uniparse(Str:D $names: --> Str:D)\n\nTakes string with comma-separated Unicode names of characters and returns a\nstring composed of those characters. Will fail if any of the characters'\nnames are empty or not recognized. Whitespace around character names is\nignored.\n\n    say \"I {uniparse 'TWO HEARTS'} Perl\"; # OUTPUT: «I \uD83D\uDC95 Perl␤»\n    'TWO HEARTS, BUTTERFLY'.uniparse.say; # OUTPUT: «\uD83D\uDC95\uD83E\uDD8B␤»\n\nNote that unlike \\c[...] construct available in string interpolation,\nuniparse does not accept decimal numerical values. Use chr routine to\nconvert those:\n\n    say \"\\c[1337]\"; # OUTPUT: «Թ␤»\n    say '1337'.chr; # OUTPUT: «Թ␤»\n\nNote: before being standardized in 2017.12, this routine was known under\nits working name of parse-names. This denomination will be removed in the\n6.e version.","split\n\n    multi sub    split(  Str:D $delimiter, Str:D $input, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\n    multi sub    split(Regex:D $delimiter, Str:D $input, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\n    multi sub    split(List:D $delimiters, Str:D $input, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\n    multi method split(Str:D:   Str:D $delimiter, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\n    multi method split(Str:D: Regex:D $delimiter, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\n    multi method split(Str:D: List:D $delimiters, $limit = Inf,\n      :$skip-empty, :$v, :$k, :$kv, :$p)\n\n\nSplits a string up into pieces based on delimiters found in the string.\n\nIf DELIMITER is a string, it is searched for literally and not treated as a\nregex. If DELIMITER is the empty string, it effectively returns all\ncharacters of the string separately (plus an empty string at the begin and\nat the end). If PATTERN is a regular expression, then that will be used to\nsplit up the string. If DELIMITERS is a list, then all of its elements will\nbe considered a delimiter (either a string or a regular expression) to\nsplit the string on.\n\nThe optional LIMIT indicates in how many segments the string should be\nsplit, if possible. It defaults to Inf (or *, whichever way you look at\nit), which means \"as many as possible\". Note that specifying negative\nlimits will not produce any meaningful results.\n\nA number of optional named parameters can be specified, which alter the\nresult being returned. The :v, :k, :kv and :p named parameters all perform\na special action with regards to the delimiter found.\n\n  * :skip-empty\n\nIf specified, do not return empty strings before or after a delimiter.\n\n  * :v\n\nAlso return the delimiter. If the delimiter was a regular expression, then\nthis will be the associated Match object. Since this stringifies as the\ndelimiter string found, you can always assume it is the delimiter string if\nyou're not interested in further information about that particular match.\n\n  * :k\n\nAlso return the index of the delimiter. Only makes sense if a list of\ndelimiters was specified: in all other cases, this will be 0.\n\n  * :kv\n\nAlso return both the index of the delimiter, as well as the delimiter.\n\n  * :p\n\nAlso return the index of the delimiter and the delimiter as a Pair.\n\nExamples:\n\n    say split(\";\", \"a;b;c\").perl;           # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say split(\";\", \"a;b;c\", :v).perl;       # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say split(\";\", \"a;b;c\", 2).perl;        # OUTPUT: «(\"a\", \"b;c\").Seq␤»\n    say split(\";\", \"a;b;c\", 2, :v).perl;    # OUTPUT: «(\"a\", \";\", \"b;c\").Seq␤»\n    say split(\";\", \"a;b;c,d\").perl;         # OUTPUT: «(\"a\", \"b\", \"c,d\").Seq␤»\n    say split(/\\;/, \"a;b;c,d\").perl;        # OUTPUT: «(\"a\", \"b\", \"c,d\").Seq␤»\n    say split(<; ,>, \"a;b;c,d\").perl;       # OUTPUT: «(\"a\", \"b\", \"c\", \"d\").Seq␤»\n    say split(/<[;,]>/, \"a;b;c,d\").perl;    # OUTPUT: «(\"a\", \"b\", \"c\", \"d\").Seq␤»\n    say split(<; ,>, \"a;b;c,d\", :k).perl;   # OUTPUT: «(\"a\", 0, \"b\", 0, \"c\", 1, \"d\").Seq␤»\n    say split(<; ,>, \"a;b;c,d\", :kv).perl;  # OUTPUT: «(\"a\", 0, \";\", \"b\", 0, \";\", \"c\", 1, \",\", \"d\").Seq␤»\n\n    say \"\".split(\"x\").perl;                 # OUTPUT: «(\"\",).Seq␤»\n    say \"\".split(\"x\", :skip-empty).perl;    # OUTPUT: «().Seq␤»\n\n    say \"abcde\".split(\"\").perl;             # OUTPUT: «(\"\", \"a\", \"b\", \"c\", \"d\", \"e\", \"\").Seq␤»\n    say \"abcde\".split(\"\",:skip-empty).perl; # OUTPUT: «(\"a\", \"b\", \"c\", \"d\", \"e\").Seq␤»","comb\n\n    multi sub    comb(Str:D   $matcher, Str:D $input, $limit = Inf)\n    multi sub    comb(Regex:D $matcher, Str:D $input, $limit = Inf, Bool :$match)\n    multi sub    comb(Int:D $size, Str:D $input, $limit = Inf)\n    multi method comb(Str:D $input:)\n    multi method comb(Str:D $input: Str:D   $matcher, $limit = Inf)\n    multi method comb(Str:D $input: Regex:D $matcher, $limit = Inf, Bool :$match)\n    multi method comb(Str:D $input: Int:D $size, $limit = Inf)\n\nSearches for $matcher in $input and returns a Seq of non-overlapping\nmatches limited to at most $limit matches. If $matcher is a Regex, each\nMatch object is converted to a Str, unless $match is set.\n\nIf no matcher is supplied, a Seq of characters in the string is returned,\nas if the matcher was rx/./.\n\nExamples:\n\n    say \"abc\".comb.perl;                 # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say 'abcdefghijk'.comb(3).perl;      # OUTPUT: «(\"abc\", \"def\", \"ghi\", \"jk\").Seq␤»\n    say 'abcdefghijk'.comb(3, 2).perl;   # OUTPUT: «(\"abc\", \"def\").Seq␤»\n    say comb(/\\w/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \"b\", \"c\").Seq␤»\n    say comb(/\\N/, \"a;b;c\").perl;        # OUTPUT: «(\"a\", \";\", \"b\", \";\", \"c\").Seq␤»\n    say comb(/\\w/, \"a;b;c\", 2).perl;     # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say comb(/\\w\\;\\w/, \"a;b;c\", 2).perl; # OUTPUT: «(\"a;b\",).Seq␤»\n    say comb(/.<(.)>/, \"<>[]()\").perl;   # OUTPUT: «(\">\", \"]\", \")\").Seq␤»\n\nIf the matcher is an integer value, comb behaves as if the matcher was rx/\n. ** {1..$matcher} /, but which is optimized to be much faster.\n\nNote that a Regex matcher may control which portion of the matched text is\nreturned by using features which explicitly set the top-level capture.","lines\n\nDefined as:\n\n    multi method lines(Str:D: $limit)\n    multi method lines(Str:D:)\n\nReturns a list of lines (without trailing newline characters), i.e. the\nsame as a call to $input.comb( / ^^ \\N* /, $limit ) would.\n\nExamples:\n\n    say lines(\"a\\nb\").perl;    # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say lines(\"a\\nb\").elems;   # OUTPUT: «2␤»\n    say \"a\\nb\".lines.elems;    # OUTPUT: «2␤»\n    say \"a\\n\".lines.elems;     # OUTPUT: «1␤»\n\nYou can limit the number of lines returned by setting the $limit variable\nto a non-zero, non-Infinity value:\n\n    say <not there yet>.join(\"\\n\").lines( 2 ); # OUTPUT: «(not there)␤»\n\nDEPRECATED as of 6.d language, the :count argument was used to return the\ntotal number of lines:\n\n    say <not there yet>.join(\"\\n\").lines( :count ); # OUTPUT: «3␤»\n\nUse elems call on the returned Seq instead:\n\n    say <not there yet>.join(\"\\n\").lines.elems; # OUTPUT: «3␤»","words\n\n    multi method words(Str:D: $limit)\n    multi method words(Str:D:)\n\nReturns a list of non-whitespace bits, i.e. the same as a call to\n$input.comb( / \\S+ /, $limit ) would.\n\nExamples:\n\n    say \"a\\nb\\n\".words.perl;       # OUTPUT: «(\"a\", \"b\").Seq␤»\n    say \"hello world\".words.perl;  # OUTPUT: «(\"hello\", \"world\").Seq␤»\n    say \"foo:bar\".words.perl;      # OUTPUT: «(\"foo:bar\",).Seq␤»\n    say \"foo:bar\\tbaz\".words.perl; # OUTPUT: «(\"foo:bar\", \"baz\").Seq␤»\n\nIt can also be used as a subroutine, turning the first argument into the\ninvocant. $limit is optional, but if it is provided (and not equal to Inf),\nit will return only the first $limit words.\n\n    say words(\"I will be very brief here\", 2); # OUTPUT: «(I will)␤»","flip\n\n    multi sub    flip(Str:D  --> Str:D)\n    multi method flip(Str:D: --> Str:D)\n\nReturns the string reversed character by character.\n\nExamples:\n\n    \"Perl\".flip;  # RESULT: «lreP»\n    \"ABBA\".flip;  # RESULT: «ABBA»","starts-with\n\n    multi method starts-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or starts with $needle.\n\n    say \"Hello, World\".starts-with(\"Hello\");     # OUTPUT: «True␤»\n    say \"https://perl6.org/\".starts-with('ftp'); # OUTPUT: «False␤»","ends-with\n\n    multi method ends-with(Str:D: Str(Cool) $needle --> Bool:D)\n\nReturns True if the invocant is identical to or ends with $needle.\n\n    say \"Hello, World\".ends-with('Hello');      # OUTPUT: «False␤»\n    say \"Hello, World\".ends-with('ld');         # OUTPUT: «True␤»","subst\n\n    multi method subst(Str:D: $matcher, $replacement, *%opts)\n\nReturns the invocant string where $matcher is replaced by $replacement (or\nthe original string, if no match was found).\n\nThere is an in-place syntactic variant of subst spelled\ns/matcher/replacement/ and with adverb following the s or inside the\nmatcher.\n\n$matcher can be a Regex, or a literal Str. Non-Str matcher arguments of\ntype Cool are coerced to Str for literal matching. If a Regex $matcher is\nused, the $/ special variable will be set to Nil (if no matches occurred),\na Match object, or a List of Match objects (if multi-match options like :g\nare used).\n\n    Literal replacement substitution\n\n    my $some-string = \"Some foo\";\n    my $another-string = $some-string.subst(/foo/, \"string\"); # gives 'Some string'\n    $some-string.=subst(/foo/, \"string\"); # in-place substitution. $some-string is now 'Some string'\n\n    Callable\n\nThe replacement can be a Callable in which the current Match object will be\nplaced in the $/ variable, as well as the $_ topic variable. Using a\nCallable as replacement is how you can refer to any of the captures created\nin the regex:\n\n    # Using capture from $/ variable (the $0 is the first positional capture)\n    say 'abc123defg'.subst(/(\\d+)/, { \" before $0 after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using capture from $/ variable (the $<foo> is a named capture)\n    say 'abc123defg'.subst(/$<foo>=\\d+/, { \" before $<foo> after \" });\n    # OUTPUT: «abc before 123 after defg␤»\n\n    # Using WhateverCode to operate on the Match given in $_:\n    say 'abc123defg'.subst(/(\\d+)/, \"[ \" ~ *.flip ~ \" ]\");\n    # OUTPUT: «abc[ 321 ]defg␤»\n\n    # Using a Callable to generate substitution without involving current Match:\n    my $i = 41;\n    my $str = \"The answer is secret.\";\n    say $str.subst(/secret/, {++$i}); # The answer to everything\n    # OUTPUT: «The answer is 42.␤»\n\n    Adverbs\n\nThe following adverbs are supported\n\n  short                        long        meaning\n  :g                           :global     tries to match as often as possible\n  :nth(Int|Callable|Whatever)              only substitute the nth match; aliases: :st, :nd, :rd, and :th\n  :ss                          :samespace  preserves whitespace on substitution\n  :ii                          :samecase   preserves case on substitution\n  :mm                          :samemark   preserves character marks (e.g. 'ü' replaced with 'o' will result in 'ö')\n  :x(Int|Range|Whatever)                   substitute exactly $x matches\n\n\nNote that only in the s/// form :ii implies :i and :ss implies :s. In the\nmethod form, the :s and :i modifiers must be added to the regex, not the\nsubst method call.\n\n    More Examples\n\nHere are other examples of usage:\n\n    my $str = \"Hey foo foo foo\";\n    $str.subst(/foo/, \"bar\", :g); # global substitution - returns Hey bar bar bar\n\n    $str.subst(/foo/, \"no subst\", :x(0)); # targeted substitution. Number of times to substitute. Returns back unmodified.\n    $str.subst(/foo/, \"bar\", :x(1)); #replace just the first occurrence.\n\n    $str.subst(/foo/, \"bar\", :nth(3)); # replace nth match alone. Replaces the third foo. Returns Hey foo foo bar\n\nThe :nth adverb has readable English-looking variants:\n\n    say 'ooooo'.subst: 'o', 'x', :1st; # OUTPUT: «xoooo␤»\n    say 'ooooo'.subst: 'o', 'x', :2nd; # OUTPUT: «oxooo␤»\n    say 'ooooo'.subst: 'o', 'x', :3rd; # OUTPUT: «ooxoo␤»\n    say 'ooooo'.subst: 'o', 'x', :4th; # OUTPUT: «oooxo␤»","subst-mutate\n\nNOTE: .subst-mutate is deprecated in the 6.d version, and will be removed\nin future ones. You can use subst with .= method call assignment operator\nor s/// substitution operator instead. \n\nWhere subst returns the modified string and leaves the original unchanged,\nit is possible to mutate the original string by using subst-mutate. If the\nmatch is successful, the method returns a Match object representing the\nsuccessful match, otherwise returns Nil. If :nth (or one of its aliases)\nwith Iterable value, :g, :global, or :x arguments are used, returns a List\nof Match objects, or an empty List if no matches occurred.\n\n    my $some-string = \"Some foo\";\n    my $match = $some-string.subst-mutate(/foo/, \"string\");\n    say $some-string;  # OUTPUT: «Some string␤»\n    say $match;        # OUTPUT: «｢foo｣␤»\n    $some-string.subst-mutate(/<[oe]>/, '', :g); # remove every o and e, notice the :g named argument from .subst\n\nIf a Regex $matcher is used, the $/ special variable will be set to Nil (if\nno matches occurred), a Match object, or a List of Match objects (if\nmulti-match options like :g are used).","substr\n\n    multi sub    substr(Str:D $s, $from, $chars?  --> Str:D)\n    multi sub    substr(Str:D $s, Range  $from-to --> Str:D)\n    multi method substr(Str:D $s: $from, $chars?  --> Str:D)\n    multi method substr(Str:D $s: Range $from-to  --> Str:D)\n\nReturns a substring of the original string, between the indices specified\nby $from-to's endpoints (coerced to Int) or from index $from and of length\n$chars.\n\nBoth $from and $chars can be specified as Callable, which will be invoked\nwith the length of the original string and the returned value will be used\nas the value for the argument. If $from or $chars are not Callable, they'll\nbe coerced to Int.\n\nIf $chars is omitted or is larger than the available characters, the string\nfrom $from until the end of the string is returned. If $from-to's starting\nindex or $from is less than zero, X::OutOfRange exception is thrown. The\n$from-to's ending index is permitted to extend past the end of string, in\nwhich case it will be equivalent to the index of the last character.\n\n    say substr(\"Long string\", 3..6);     # RESULT: «g st␤»\n    say substr(\"Long string\", 6, 3);     # RESULT: «tri␤»\n    say substr(\"Long string\", 6);        # RESULT: «tring␤»\n    say substr(\"Long string\", 6, *-1);   # RESULT: «trin␤»\n    say substr(\"Long string\", *-3, *-1); # RESULT: «in␤»","substr-eq\n\n    multi method substr-eq(Str:D:  Str(Cool) $test-string, Int(Cool) $from --> Bool)\n    multi method substr-eq(Cool:D: Str(Cool) $test-string, Int(Cool) $from --> Bool)\n\nReturns True if the $test-string exactly matches the String object,\nstarting from the given initial index $from. For example, beginning with\nthe string \"foobar\", the substring \"bar\" will match from index 3:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"bar\", 3);    # OUTPUT: «True␤»\n\nHowever, the substring \"barz\" starting from index 3 won't match even though\nthe first three letters of the substring do match:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"barz\", 3);   # OUTPUT: «False␤»\n\nNaturally, to match the entire string, one merely matches from index 0:\n\n    my $string = \"foobar\";\n    say $string.substr-eq(\"foobar\", 0); # OUTPUT: «True␤»\n\nSince this method is inherited from the Cool type, it also works on\nintegers. Thus the integer 42 will match the value 342 starting from index\n1:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 1);      # OUTPUT: «True␤»\n\nAs expected, one can match the entire value by starting at index 0:\n\n    my $integer = 342;\n    say $integer.substr-eq(342, 0);     # OUTPUT: «True␤»\n\nAlso using a different value or an incorrect starting index won't match:\n\n    my $integer = 342;\n    say $integer.substr-eq(42, 3);      # OUTPUT: «False␤»\n    say $integer.substr-eq(7342, 0);    # OUTPUT: «False␤»","substr-rw\n\n    method substr-rw($from, $length = *)\n\nA version of substr that returns a Proxy functioning as a writable\nreference to a part of a string variable. Its first argument, $from\nspecifies the index in the string from which a substitution should occur,\nand its last argument, $length specifies how many characters are to be\nreplaced. If not specified, $length defaults to the length of the string.\n\nFor example, in its method form, if one wants to take the string \"abc\" and\nreplace the second character (at index 1) with the letter \"z\", then one\ndoes this:\n\n    my $string = \"abc\";\n    $string.substr-rw(1, 1) = \"z\";\n    $string.say;                         # OUTPUT: «azc␤»\n\nNote that new characters can be inserted as well:\n\n    my $string = 'azc';\n    $string.substr-rw(2, 0) = \"-Zorro-\"; # insert new characters BEFORE the character at index 2\n    $string.say;                         # OUTPUT: «az-Zorro-c␤»\n\nsubstr-rw also has a function form, so the above examples can also be\nwritten like so:\n\n    my $string = \"abc\";\n    substr-rw($string, 1, 1) = \"z\";\n    $string.say;                          # OUTPUT: «azc␤»\n    substr-rw($string, 2, 0) = \"-Zorro-\";\n    $string.say;                          # OUTPUT: «az-Zorro-c␤»\n\nIt is also possible to alias the writable reference returned by substr-rw\nfor repeated operations:\n\n    my $string = \"A character in the 'Flintstones' is: barney\";\n    $string ~~ /(barney)/;\n    my $ref := substr-rw($string, $0.from, $0.to-$0.from);\n    $string.say;\n    # OUTPUT: «A character in the 'Flintstones' is: barney␤»\n    $ref = \"fred\";\n    $string.say;\n    # OUTPUT: «A character in the 'Flintstones' is: fred␤»\n    $ref = \"wilma\";\n    $string.say;\n    # OUTPUT: «A character in the 'Flintstones' is: wilma␤»","samemark\n\n    multi sub samemark(Str:D $string, Str:D $pattern --> Str:D)\n    method    samemark(Str:D: Str:D $pattern --> Str:D)\n\nReturns a copy of $string with the mark/accent information for each\ncharacter changed such that it matches the mark/accent of the corresponding\ncharacter in $pattern. If $string is longer than $pattern, the remaining\ncharacters in $string receive the same mark/accent as the last character in\n$pattern. If $pattern is empty no changes will be made.\n\nExamples:\n\n    say 'åäö'.samemark('aäo');                        # OUTPUT: «aäo␤»\n    say 'åäö'.samemark('a');                          # OUTPUT: «aao␤»\n\n    say samemark('Pêrl', 'a');                        # OUTPUT: «Perl␤»\n    say samemark('aöä', '');                          # OUTPUT: «aöä␤»","succ\n\n    method succ(Str:D --> Str:D)\n\nReturns the string incremented by one.\n\nString increment is \"magical\". It searches for the last alphanumeric\nsequence that is not preceded by a dot, and increments it.\n\n    '12.34'.succ;      # RESULT: «13.34»\n    'img001.png'.succ; # RESULT: «img002.png»\n\nThe actual increment step works by mapping the last alphanumeric character\nto a character range it belongs to, and choosing the next character in that\nrange, carrying to the previous letter on overflow.\n\n    'aa'.succ;   # RESULT: «ab»\n    'az'.succ;   # RESULT: «ba»\n    '109'.succ;  # RESULT: «110»\n    'α'.succ;    # RESULT: «β»\n    'a9'.succ;   # RESULT: «b0»\n\nString increment is Unicode-aware, and generally works for scripts where a\ncharacter can be uniquely classified as belonging to one range of\ncharacters.","pred\n\n    method pred(Str:D: --> Str:D)\n\nReturns the string decremented by one.\n\nString decrementing is \"magical\" just like string increment (see succ). It\nfails on underflow\n\n    'b0'.pred;           # RESULT: «a9»\n    'a0'.pred;           # Failure\n    'img002.png'.pred;   # RESULT: «img001.png»","ord\n\n    multi sub    ord(Str:D  --> Int:D)\n    multi method ord(Str:D: --> Int:D)\n\nReturns the codepoint number of the base characters of the first grapheme\nin the string.\n\nExample:\n\n    ord(\"A\"); # 65\n    \"«\".ord;  # 171","ords\n\n    multi method ords(Str:D: --> Seq)\n\nReturns a list of Unicode codepoint numbers that describe the codepoints\nmaking up the string.\n\nExample:\n\n    \"aå«\".ords; # (97 229 171)\n\nStrings are represented as graphemes. If a character in the string is\nrepresented by multiple codepoints, then all of those codepoints will\nappear in the result of ords. Therefore, the number of elements in the\nresult may not always be equal to chars, but will be equal to codes; codes\ncomputes the codepoints in a different way, so the result might be faster.\n\nThe codepoints returned will represent the string in NFC. See the NFD,\nNFKC, and NFKD methods if other forms are required.","trans\n\n    multi method trans(Str:D: Pair:D \\what, *%n --> Str)\n    multi method trans(Str:D: *@changes, :complement(:$c), :squash(:$s), :delete(:$d) --> Str)\n\nReplaces one or many characters with one or many characters. Ranges are\nsupported, both for keys and values. Regexes work as keys. In case a list\nof keys and values is used, substrings can be replaced as well. When called\nwith :complement anything but the matched value or range is replaced with a\nsingle value; with :delete the matched characters without corresponding\nreplacement are removed. Combining :complement and :delete will remove\nanything but the matched values, unless replacement characters have been\nspecified, in which case, :delete would be ignored. The adverb :squash will\nreduce repeated matched characters to a single character.\n\nExample:\n\n    my $str = 'say $x<b> && $y<a>';\n    $str.=trans( '<' => '«' );\n    $str.=trans( '<' => '«', '>' => '»' );\n\n    $str.=trans( [ '<'   , '>'   , '&' ] =>\n                 [ '&lt;', '&gt;', '&amp;' ]);\n\n    $str.=trans( ['a'..'y'] => ['A'..'z'] );\n\n    \"abcdefghij\".trans(/<[aeiou]> \\w/ => '');                     # RESULT: «cdgh»\n\n    \"a123b123c\".trans(['a'..'z'] => 'x', :complement);            # RESULT: «axxxbxxxc»\n    \"aaa1123bb123c\".trans('a'..'z' => 'A'..'Z', :squash);         # RESULT: «A1123B123C»\n    \"aaa1123bb123c\".trans('a'..'z' => 'x', :complement, :squash); # RESULT: «aaaxbbxc»\n\nIn general, the strings will have the same length after the substitution:\n\n    say \"a123b123c\".trans('23' => '4');   # OUTPUT: «a144b144c␤»\n    say \"a123b123c\".trans('123' => 'þð'); # OUTPUT: «aþðþbþðþc␤»\n\n:squash and :delete will have the same effect in this case making it a\nstrict substitution:\n\n    say \"a123b123c\".trans('123' => 'þð', :squash); # OUTPUT: «aþðbþðc␤»\n    say \"a123b123c\".trans('123' => 'þð', :delete); # OUTPUT: «aþðbþðc␤»\n\n:delete will also remove non-matched characters from the original string:\n\n    say \"abc\".trans(\"abc\".comb => 1..2, :delete);  # OUTPUT: «12␤»\n\nPlease note that the behavior of the two versions of the multi method is\nslightly different. The first form will transpose only one character if the\norigin is also one character:\n\n    say \"abcd\".trans( \"a\" => \"zz\" );  # OUTPUT: «zbcd␤»\n    say \"abcd\".trans( \"ba\" => \"yz\" ); # OUTPUT: «zycd␤»\n\n\nIn the second case, behavior is as expected, since the origin is more than\none char long. However, if the Pair in the multi method does not have a Str\nas an origin or target, it is handled to the second multi method, and\nbehavior changes:\n\n    say \"abcd\".trans: [\"a\"] => [\"zz\"]; # OUTPUT: «zzbcd␤»\n\nIn this case, neither origin nor target in the Pair are Str; the method\nwith the Pair signature then calls the second, making this call above\nequivalent to \"abcd\".trans: [\"a\"] => [\"zz\"],  (with the comma behind,\nmaking it a Positional, instead of a Pair), resulting in the behavior shown\nas output.","indent\n\n    multi method indent(Int $steps where { $_ == 0 } )\n    multi method indent(Int $steps where { $_ > 0  } )\n    multi method indent($steps where { .isa(Whatever) || .isa(Int) && $_ < 0 } )\n\nIndents each line of the string by $steps. If $steps is negative, it\noutdents instead. If $steps is *, then the string is outdented to the\nmargin:\n\n    \"  indented by 2 spaces\\n    indented even more\".indent(*)\n        eq \"indented by 2 spaces\\n  indented even more\"","trim\n\n    method trim(Str:D: --> Str)\n\nRemove leading and trailing whitespace. It can be used both as a method on\nstrings and as a function. When used as a method it will return the trimmed\nstring. In order to do in-place trimming, one needs to write .=trim\n\n    my $line = '   hello world    ';\n    say '<' ~ $line.trim ~ '>';        # OUTPUT: «<hello world>␤»\n    say '<' ~ trim($line) ~ '>';       # OUTPUT: «<hello world>␤»\n    $line.trim;\n    say '<' ~ $line ~ '>';             # OUTPUT: «<   hello world    >␤»\n    $line.=trim;\n    say '<' ~ $line ~ '>';             # OUTPUT: «<hello world>␤»\n\nSee also trim-trailing and trim-leading.","trim-trailing\n\n    method trim-trailing(Str:D: --> Str)\n\nRemoves the whitespace characters from the end of a string. See also trim.","trim-leading\n\n    method trim-leading(Str:D: --> Str)\n\nRemoves the whitespace characters from the beginning of a string. See also\ntrim.","NFC\n\n    method NFC(Str:D: --> NFC:D)\n\nReturns a codepoint string in NFC format (Unicode Normalization Form C /\nComposed).","NFD\n\n    method NFD(Str:D: --> NFD:D)\n\nReturns a codepoint string in NFD format (Unicode Normalization Form D /\nDecomposed).","NFKC\n\n    method NFKC(Str:D: --> NFKC:D)\n\nReturns a codepoint string in NFKC format (Unicode Normalization Form KC /\nCompatibility Composed).","NFKD\n\n    method NFKD(Str:D: --> NFKD:D)\n\nReturns a codepoint string in NFKD format (Unicode Normalization Form KD /\nCompatibility Decomposed).","ACCEPTS\n\n    multi method ACCEPTS(Str:D: $other)\n\nReturns True if the string is the same as $other.","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture.","val\n\n    multi sub val(Str:D $MAYBEVAL, :$val-or-fail)\n\nGiven a Str that may be parsable as a numeric value, it will attempt to\nconstruct the appropriate allomorph, returning one of IntStr, NumStr,\nRatStr or ComplexStr or a plain Str if a numeric value cannot be parsed. If\nthe :val-or-fail adverb is provided it will return an X::Str::Numeric\nrather than the original string if it cannot parse the string as a number.\n\n    say val(\"42\").^name;    # OUTPUT: «IntStr␤»\n    say val(\"42e0\").^name;  # OUTPUT: «NumStr␤»\n    say val(\"42.0\").^name;  # OUTPUT: «RatStr␤»\n    say val(\"42+0i\").^name; # OUTPUT: «ComplexStr␤»\n\nWhile characters belonging to the Unicode categories Nl (number letters)\nand No (other numbers) can be used as numeric literals in the language,\nthey will not be converted to a number by val, by design. See unival if you\nneed to convert such characters to Numeric."],"name":"Str"},{"methods":["ACCEPTS\n\n    multi method ACCEPTS(Whatever:D: Mu $other)\n    multi method ACCEPTS(Whatever:U: Mu $other)\n\nIf the invocant is an instance, always returns True. If the invocant is a\ntype object, performs a typecheck.\n\n    say 42 ~~ (*);       # OUTPUT: «True␤»\n    say 42 ~~ Whatever;  # OUTPUT: «False␤»","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture."],"desc":"TITLE\nclass Whatever\n\nSUBTITLE\nPlaceholder for the value of an unspecified argument\n\n    class Whatever { }\n\nWhatever is a class whose objects don't have any explicit meaning; it gets\nits semantics from other routines that accept Whatever-objects as markers\nto do something special. Using the * literal as an operand creates a\nWhatever object.\n\nMuch of *'s charm comes from Whatever-currying. When * is used in term\nposition, that is, as an operand, in combination with most operators, the\ncompiler will transform the expression into a closure of type WhateverCode,\nwhich is actually a Block that can be used wherever Callables are\naccepted.\n\n    my $c = * + 2;          # same as   -> $x { $x + 2 };\n    say $c(4);              # OUTPUT: «6␤»\n\nMultiple * in one expression generate closures with as many arguments:\n\n    my $c = * + *;          # same as   -> $x, $y { $x + $y }\n\nUsing * in complex expressions will also generate closures:\n\n    my $c = 4 * * + 5;      # same as   -> $x { 4 * $x + 5 }\n\nCalling a method on * also creates a closure:\n\n    <a b c>.map: *.uc;      # same as    <a b c>.map: -> $char { $char.uc }\n\n\nAs mentioned before, not all operators and syntactic constructs curry * (or\nWhatever-stars) to WhateverCode. In the following cases, * will remain a\nWhatever object.\n\n  Exception        Example  What it does\n  comma            1, *, 2  generates a List with a * element\n  range operators  1 .. *   Range.new(:from(1), :to(*));\n  series operator  1 ... *  infinite list\n  assignment       $x = *   assign * to $x\n  binding          $x := *  bind * to $x\n  list repetition  1 xx *   generates an infinite list\n\n\nThe range operators are handled specially. They do not curry with\nWhatever-stars, but they do curry with WhateverCode\n\n    say (1..*).^name;       # OUTPUT: «Range␤»\n    say ((1..*-1)).^name;   # OUTPUT: «WhateverCode␤»\n\nThis allows all these constructs to work:\n\n    .say for 1..*;          # infinite loop\n\n\nand\n\n    my @a = 1..4;\n    say @a[0..*];           # OUTPUT: «(1 2 3 4)␤»\n    say @a[0..*-2];         # OUTPUT: «(1 2 3)␤»\n\nBecause Whatever-currying is a purely syntactic compiler transform, you\nwill get no runtime currying of stored Whatever-stars into WhateverCodes.\n\n    my $x = *;\n    $x + 2;   # Not a closure, dies because it can't coerce $x to Numeric\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Multi::NoMatch: Cannot resolve caller Numeric(Whatever: );\n    # none of these signatures match:␤\n    # (Mu:U \\v: *%_)»\n\n\nThe use cases for stored Whatever-stars involve those curry-exception cases\nmentioned above. For example, if you want an infinite series by default.\n\n    my $max    = potential-upper-limit() // *;\n    my $series = known-lower-limit() ... $max;\n\n\nA stored * will also result in the generation of a WhateverCode in the\nspecific case of smartmatch. Note that this is not actually the stored *\nwhich is being curried, but rather the * on the left-hand side.\n\n    my $constraint           = find-constraint() // *;\n    my $maybe-always-matcher = * ~~ $constraint;\n\n\nIf this hypothetical find-constraint were to have found no constraint,\n$maybe-always-matcher would evaluate to True for anything.\n\n    $maybe-always-matcher(555);      # True\n    $maybe-always-matcher(Any);      # True\n\n\nHyperWhatever's functionality is similar to Whatever, except it refers to\nmultiple values, instead of a single one.\n\n","name":"Whatever"},{"desc":"TITLE\nclass Complex\n\nSUBTITLE\nComplex number\n\n    class Complex is Cool does Numeric {}\n\nRepresents a number in the complex plane.\n\nComplex objects are immutable.\n\nOperators\n\n  postfix i\n\nAdding a trailing i to a number literal makes it a Complex, for example:\n\n    say 2i;     # same as Complex.new(0, 2);\n    say 1-2e3i; # same as Complex.new(1, -2e3);\n\n","methods":["new\n\nDefined as:\n\n    multi method new(Real $re, Real $im --> Complex:D)\n\nCreates a new Complex object from real and imaginary parts.\n\n    my $complex = Complex.new(1, 1);\n    say $complex;    # OUTPUT: «1+1i␤»\n\nWhen created without arguments, both parts are considered to be zero.\n\n    say Complex.new; # OUTPUT: «0+0i␤»","re\n\nDefined as:\n\n    method re(Complex:D: --> Real:D)\n\nReturns the real part of the complex number.\n\n    say (3+5i).re;    # OUTPUT: «3␤»","im\n\nDefined as:\n\n    method im(Complex:D: --> Real:D)\n\nReturns the imaginary part of the complex number.\n\n    say (3+5i).im;    # OUTPUT: «5␤»","reals\n\nDefined as:\n\n    method reals(Complex:D: --> Positional:D)\n\nReturns a two-element list containing the real and imaginary parts for this\nvalue.\n\n    say (3+5i).reals;    # OUTPUT: «(3 5)␤»","isNaN\n\nDefined as:\n\n    method isNaN(Complex:D: --> Bool:D)\n\nReturns true if the real or imaginary part is NaN (not a number).\n\n    say (NaN+5i).isNaN; # OUTPUT: «True␤»\n    say (7+5i).isNaN;   # OUTPUT: «False␤»","polar\n\nDefined as:\n\n    method polar(Complex:D: --> Positional:D)\n\nReturns a two-element list of the polar coordinates for this value, i.e.\nmagnitude and angle in radians.\n\n    say (10+7i).polar; # OUTPUT: «(12.2065556157337 0.610725964389209)␤»","floor\n\nDefined as:\n\n    method floor(Complex:D: --> Complex:D)\n\nReturns self.re.floor + self.im.floor. That is, each of the real and\nimaginary parts is rounded to the highest integer not greater than the\nvalue of that part.\n\n    say (1.2-3.8i).floor;           # OUTPUT: «1-4i␤»","ceiling\n\nDefined as:\n\n    method ceiling(Complex:D: --> Complex:D)\n\nReturns self.re.ceiling + self.im.ceiling. That is, each of the real and\nimaginary parts is rounded to the lowest integer not less than the value of\nthat part.\n\n    say (1.2-3.8i).ceiling;         # OUTPUT: «2-3i␤»","round\n\nDefined as:\n\n    multi method round(Complex:D: --> Complex:D)\n    multi method round(Complex:D: Real() $scale --> Complex:D)\n\nWith no arguments, rounds both the real and imaginary parts to the nearest\ninteger and returns a new Complex number. If $scale is given, rounds both\nparts of the invocant to the nearest multiple of $scale. Uses the same\nalgorithm as Real.round on each part of the number.\n\n    say (1.2-3.8i).round;           # OUTPUT: «1-4i␤»\n    say (1.256-3.875i).round(0.1);  # OUTPUT: «1.3-3.9i␤»","truncate\n\nDefined as:\n\n    method truncate(Complex:D: --> Complex:D)\n\nRemoves the fractional part of both the real and imaginary parts of the\nnumber, using Real.truncate, and returns the result as a new Complex.\n\n    say (1.2-3.8i).truncate;        # OUTPUT: «1-3i␤»","abs\n\nDefined as:\n\n    method abs(Complex:D: --> Num:D)\n    multi sub abs(Complex:D $z --> Num:D)\n\nReturns the absolute value of the invocant (or the argument in sub form).\nFor a given complex number $z the absolute value |$z| is defined as\nsqrt($z.re * $z.re + $z.im * $z.im).\n\n    say (3+4i).abs;                 # OUTPUT: «5␤»\n                                    # sqrt(3*3 + 4*4) == 5","conj\n\nDefined as:\n\n    method conj(Complex:D: --> Complex:D)\n\nReturns the complex conjugate of the invocant (that is, the number with the\nsign of the imaginary part negated).\n\n    say (1-4i).conj;                # OUTPUT: «1+4i␤»","sqrt\n\nDefined as:\n\n    method sqrt(Complex:D: --> Complex:D)\n\nReturns the complex square root of the invocant, i.e. the root where the\nreal part is ≥ 0 and the imaginary part has the same sign as the imaginary\npart of the invocant.\n\n    say (3-4i).sqrt;                # OUTPUT: «2-1i␤»\n    say (-3+4i).sqrt;               # OUTPUT: «1+2i␤»","gist\n\nDefined as:\n\n    method gist(Complex:D: --> Str:D)\n\nReturns a string representation of the form \"1+2i\", without internal\nspaces. (Str coercion also returns this.)\n\n    say (1-4i).gist;                # OUTPUT: «1-4i␤»","perl\n\nDefined as:\n\n    method perl(Complex:D: --> Str:D)\n\nReturns an implementation-specific string that produces an equivalent\nobject when given to EVAL.\n\n    say (1-3i).perl;                # OUTPUT: «<1-3i>␤»","Real\n\nDefined as:\n\n    multi method Real(Complex:D: --> Num:D)\n    multi method Real(Complex:U: --> Num:D)\n\nCoerces the invocant to Num. If the imaginary part isn't approximately\nzero, coercion fails with X::Numeric::Real.\n\nThe :D variant returns the result of that coercion. The :U variant issues a\nwarning about using an uninitialized value in numeric context and then\nreturns value 0e0.\n\n  sub infix:<**>\n\nDeclared as\n\n    multi sub infix:<**>(Complex:D \\a, Complex:D \\b --> Complex:D)\n    multi sub infix:<**>(Num(Real) \\a, Complex:D \\b --> Complex:D)\n    multi sub infix:<**>(Complex:D \\a, Num(Real) \\b --> Complex:D)\n\nThe exponentiation operator coerces the second argument to Complex and\ncalculates the left-hand-side raised to the power of the right-hand side.\nSince 6.d, either argument can be equal to zero.\n\n    say i ** i; # OUTPUT: «0.20787957635076193+0i␤»\n    say 2 ** i; # OUTPUT: «0.7692389013639721+0.6389612763136348i␤»\n    say i ** 2; # OUTPUT: «-1+1.2246467991473532e-16i␤»\n    say 0 ** 1; # OUTPUT: «0+0i␤»"],"name":"Complex"},{"desc":"TITLE\nrole Stringy\n\nSUBTITLE\nString or object that can act as a string\n\n    role Stringy { ... }\n\nCommon role for string types (such as Str).","methods":[],"name":"Stringy"},{"name":"Positional","methods":["of\n\n    method of()\n\nReturns the type constraint for elements of the positional container.\nDefaults to Mu."],"desc":"TITLE\nrole Positional\n\nSUBTITLE\nObject that supports looking up values by index\n\n    role Positional { ... }\n\nRole for objects which support indexing them using postcircumfix:«[ ]»\n(usually list-like objects). Example types with Positional role include\nList, Array, Range, and Buf.\n\n"},{"desc":"TITLE\nclass NFKC\n\nSUBTITLE\nCodepoint string in Normal Form KC (compatibility composed)\n\n    class NFKC is Uni {}\n\nA Codepoint string in Unicode Normalization Form KC. It is created by\nCompatibility Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15.","methods":[],"name":"NFKC"},{"name":"PredictiveIterator","methods":["count-only\n\nDefined as:\n\n    method count-only(--> Int:D) { ... }\n\nIt is expected to return the number of values the iterator can still\nproduce without actually producing them. The returned number must adjust\nitself for items already pulled, so that the method can be called on a\npartially consumed Iterator.\n\nIt will be used in situations where only the number of values of an\niterator is needed, e.g. when the .elems method is called.\n\nImportant: it's expected the Iterators that implement this method can\nreturn that number without producing any values. In other words, it's\nexpected the user of the class will be able to still pull-one after calling\nthis method, and eventually receive as many values as the return value of\nthis method indicated.","bool-only\n\nDefaults to the Booleanification of the result of calling the count-only\nmethod. If it is possible to have a faster way of finding out whether the\niterator is capable of producing any value, it should be implemented.\n\nDefined as:\n\n    method bool-only(--> Bool:D) { self.count-only.Bool }"],"desc":"TITLE\nrole PredictiveIterator\n\nSUBTITLE\nIterators that can predict number of values\n\nA PredictiveIterator is a special kind of Iterator that can know how many\nvalues it will (still) generate without actually needing to generate those\nvalues.\n\nThe main addition to the API of the Iterator role, is the count-only\nmethod, which should return the number of values the Iterator is still able\nto generate.\n\nThe other addition is the bool-only method, that should return a Bool\nindicating whether the Iterator is still capable of producing values (aka,\nis not exhausted yet). By default, this is the Booleanification of the\nresult of the call to the count-only method.\n\n"},{"name":"Callable","desc":"TITLE\nrole Callable\n\nSUBTITLE\nInvocable code object\n\n    role Callable { ... }\n\nRole for objects which support calling them. It's used in Block, Routine,\nSub, Method, Submethod and Macro types.\n\nCallables can be stored in &-sigiled containers, the default type\nconstraint of such a container is Callable.\n\n    my &a = {;}; # Empty block needs a semicolon\n    my &b = -> {};\n    my &c = sub () {};\n    sub foo() {};\n    my &d = &foo;\n\n","methods":["CALL-ME\n\n    method CALL-ME(Callable:D $self: |arguments)\n\nThis method is required for postfix:«( )» and postfix:«.( )». It's what\nmakes an object actually call-able and needs to be overloaded to let a\ngiven object act like a routine. If the object needs to be stored in a\n&-sigiled container, is has to implement Callable.\n\n    class A does Callable {\n        submethod CALL-ME(|c){ 'called' }\n    }\n    my &a = A;\n    say a(); # OUTPUT: «called␤»\n\nApplying the Callable role is not a requirement to make an object callable;\nif a class simply wants to add subroutine-like semantics in a regular\nscalar container, the submethod CALL-ME can be used for that.\n\n    class A {\n        has @.values;\n        submethod CALL-ME(Int $x where 0 <= * < @!values.elems) {\n            @!values[$x]\n        }\n    }\n    my $a = A.new: values => [4,5,6,7]\n    say $a(2); # OUTPUT: «6␤»","Capture\n\nDefined as:\n\n    method Capture()\n\nThrows X::Cannot::Capture."]},{"name":"Grammar","methods":["parse\n\nDefined as:\n\n    method parse($target, :$rule = 'TOP',  Capture() :$args = \\(), Mu :$actions = Mu, *%opt)\n\nParses the $target, which will be coerced to Str if it isn't one, using\n$rule as the starting rule. Additional $args will be passed to the starting\nrule if provided.\n\n    grammar RepeatChar {\n        token start($character) { $character+ }\n    }\n\n    say RepeatChar.parse('aaaaaa', :rule('start'), :args(\\('a')));\n    say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')));\n\n    # OUTPUT:\n    # ｢aaaaaa｣\n    # ｢bbbbbb｣\n\nIf the action named argument is provided, it will be used as an action\nobject, that is, for each successful regex match, a method of the same\nname, if it exists, is called on the action object, passing the match\nobject as the sole positional argument.\n\n    my $actions = class { method TOP($/) { say \"7\" } };\n    grammar { token TOP { a { say \"42\" } b } }.parse('ab', :$actions);\n    # OUTPUT : «42␤7␤»\n\nAdditional named arguments are used as options for matching, so you can\nspecify things like :pos(4) to start parsing from the fourth (zero-base)\ncharacter. All matching adverbs are allowed, but not all of them take\neffect. There are several types of adverbs that a regex can have, some of\nwhich apply at compile time, like :s and :i. You cannot pass those to\n.parse, because the regexes have already been compiled. But, you can pass\nthose adverbs that affect the runtime behavior, such as :pos and\n:continue.\n\n    say RepeatChar.parse('bbbbbb', :rule('start'), :args(\\('b')), :pos(4)).Str;\n    # OUTPUT : «bb␤»\n\n\nMethod parse only succeeds if the cursor has arrived at the end of the\ntarget string when the match is over. Use method subparse if you want to be\nable to stop in the middle.\n\nReturns a Match object on success, and Nil on failure.","subparse\n\nDefined as:\n\n    method subparse($target, :$rule = 'TOP', Capture() :$args = \\(),  Mu :$actions = Mu, *%opt)\n\nDoes exactly the same as method parse, except that cursor doesn't have to\nreach the end of the string to succeed. That is, it doesn't have to match\nthe whole string.\n\nNote that unlike method parse, subparse always returns a Match object,\nwhich will be a failed match (and thus falsy), if the grammar failed to\nmatch.\n\n    grammar RepeatChar {\n        token start($character) { $character+ }\n    }\n\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('b')));\n    say RepeatChar.parse('bbbabb', :rule('start'), :args(\\('b')));\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')));\n    say RepeatChar.subparse('bbbabb', :rule('start'), :args(\\('a')), :pos(3));\n\n\n    # OUTPUT:\n    # ｢bbb｣\n    # Nil\n    # #<failed match>\n    # ｢a｣","parsefile\n\nDefined as:\n\n    method parsefile(Str(Cool) $filename, :$enc, *%opts)\n\nReads file $filename encoding by $enc, and parses it. All named arguments\nare passed on to method parse.\n\n    grammar Identifiers {\n        token TOP        { [<identifier><.ws>]+ }\n        token identifier { <initial> <rest>* }\n        token initial    { <+myletter +[_]> }\n        token rest       { <+myletter +mynumber +[_]> }\n        token myletter   { <[A..Za..z]> }\n        token mynumber   { <[0..9]> }\n    }\n\n    say Identifiers.parsefile('users.txt', :enc('UTF-8'))\n        .Str.trim.subst(/\\n/, ',', :g);\n\n    # users.txt :\n    # TimToady\n    # lizmat\n    # jnthn\n    # moritz\n    # zoffixznet\n    # MasterDuke17\n\n    # OUTPUT : «TimToady,lizmat,jnthn,moritz,zoffixznet,MasterDuke17␤»"],"desc":"TITLE\nclass Grammar\n\nSUBTITLE\nFormal grammar made up of named regexes\n\n    class Grammar is Match {}\n\nEvery type declared with grammar and not explicitly stating its superclass,\nbecomes a subclass of Grammar.\n\n    grammar Identifier {\n        token TOP       { <initial> <rest>* }\n        token initial   { <+myletter +[_]> }\n        token rest      { <+myletter +mynumber +[_]> }\n        token myletter  { <[A..Za..z]> }\n        token mynumber  { <[0..9]> }\n    }\n\n    say Identifier.isa(Grammar);                # OUTPUT: «True␤»\n    my $match = Identifier.parse('W4anD0eR96');\n    say ~$match;                                # OUTPUT: «W4anD0eR96␤»\n\nMore documentation on grammars is available.\n\n"},{"methods":["name\n\n    method name(Variable:D: str)\n\nReturns the name of the variable, including the sigil."],"desc":"TITLE\nclass Variable\n\nSUBTITLE\nObject representation of a variable for use in traits\n\n    class Variable {}\n\nVariables have a wealth of compile-time information, but at runtime,\naccesses to a variable usually act on the value stored inside it, not the\nvariable itself. The runtime class of a variable is Scalar.\n\nClass Variable holds the compile-time information that traits can use to\nintrospect and manipulate variables.\n\nTraits\n\n  trait is default\n\nSets the default value with which a variable is initialized, and to which\nit is reset when Nil is assigned to it. Trait arguments are evaluated at\ncompile time. Closures won't do what you expect: they are stored as is and\nneed to be called by hand.\n\n    my Int $x is default(42);\n    say $x;     # OUTPUT: «42␤»\n    $x = 5;\n    say $x;     # OUTPUT: «5␤»\n    # explicit reset:\n    $x = Nil;\n    say $x;     # OUTPUT: «42␤»\n\nThe trait is default can be used also with subscripting things like arrays\nand hashes:\n\n    my @array is default( 'N/A' );\n    @array[22].say;  # OUTPUT: N/A\n    @array = Nil;\n    @array.say;      # OUTPUT: [N/A]\n    @array[4].say;   # OUTPUT: N/A\n\n    my %hash is default( 'no-value-here' );\n    %hash<non-existent-key>.say; # OUTPUT: no-value-here\n    %hash<foo> = 'bar';\n    %hash<>.say;                 # OUTPUT: {foo => bar}\n    %hash<wrong-key>.say;        # OUTPUT: no-value-here\n\n\n  trait is dynamic\n\n    multi sub trait_mod:<is>(Variable:D, :$dynamic)\n\nMarks a variable as dynamic, that is, accessible from inner dynamic scopes\nwithout being in an inner lexical scope.\n\n    sub introspect() {\n        say $CALLER::x;\n    }\n    my $x is dynamic = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Caller::NotDynamic\n    }\n\n\nThe is dynamic trait is a rather cumbersome way of creating and accessing\ndynamic variables. A much easier way is to use the * twigil:\n\n    sub introspect() {\n        say $*x;\n    }\n    my $*x = 23;\n    introspect;         # OUTPUT: «23␤»\n    {\n        # not dynamic\n        my $x;\n        introspect()    # dies with an exception of type X::Dynamic::NotFound\n    }\n\n\n  trait of\n\n    multi sub trait_mod:<of>(Mu:U $target, Mu:U $type)\n\nSets the type constraint of a container bound to a variable.\n\n    my $i of Int = 42;\n    $i = \"forty plus two\";\n    CATCH { default { say .^name, ' ', .Str } }\n    # OUTPUT: «X::TypeCheck::Assignment Type check failed in assignment to $i; expected Int but got Str (\"forty plus two\")␤»\n\nYou can use any value defined in compile time as a type constraint,\nincluding constants:\n\n    constant \\T = Int;\n    my $i of T = 42;\n\nwhich would be equivalent to the previous definition.\n\n","name":"Variable"},{"desc":"TITLE\nclass Date\n\nSUBTITLE\nCalendar date\n\n    class Date { }\n\nA Date is an immutable object identifying a day in the Gregorian calendar.\n\nDate objects support addition and subtraction of integers, where an integer\nis interpreted as the number of days. You can compare Date objects with the\nnumeric comparison operators ==, <, <=, >, >=, != . Their stringification\nin YYYY-MM-DD format means that comparing them with the string operators\neq, lt, le etc. also gives the right result.\n\nDate.today creates an object the current day according to the system\nclock.\n\n    my $d = Date.new(2015, 12, 24); # Christmas Eve!\n    say $d;                         # OUTPUT: «2015-12-24␤»\n    say $d.year;                    # OUTPUT: «2015␤»\n    say $d.month;                   # OUTPUT: «12␤»\n    say $d.day;                     # OUTPUT: «24␤»\n    say $d.day-of-week;             # OUTPUT: «4␤» (Thursday)\n    say $d.later(days => 20);       # OUTPUT: «2016-01-13␤»\n    my $n = Date.new('2015-12-31'); # New Year's Eve\n    say $n - $d;                    # OUTPUT: «7␤», 7 days between New Years/Christmas Eve\n    say $n + 1;                     # OUTPUT: «2016-01-01␤»\n\nNote since version 6.d, .perl can be called on Date.\n\n","methods":["new\n\nDefined as:\n\n    multi method new($year, $month, $day, :&formatter --> Date:D)\n    multi method new(:$year!, :$month = 1, :$day = 1  --> Date:D)\n    multi method new(Str $date                        --> Date:D)\n    multi method new(Instant:D $dt                    --> Date:D)\n    multi method new(DateTime:D $dt                   --> Date:D)\n\nCreates a new Date object, either from a triple of (year, month, day) that\ncan be coerced to integers, or from a string of the form YYYY-MM-DD (ISO\n8601), or from an Instant or DateTime object. Optionally accepts a\nformatter as a named parameter.\n\n    my $date = Date.new(2042, 1, 1);\n    $date = Date.new(year => 2042, month => 1, day => 1);\n    $date = Date.new(\"2042-01-01\");\n    $date = Date.new(Instant.from-posix: 1482155532);\n    $date = Date.new(DateTime.now);","new-from-daycount\n\nDefined as:\n\n    method new-from-daycount($daycount,:&formatter --> Date:D)\n\nCreates a new Date object given $daycount which is the number of days from\nepoch Nov. 17, 1858, i.e. the Modified Julian Day. Optionally accepts a\nformatter as a named parameter.\n\n    say Date.new-from-daycount(49987);          # OUTPUT: «1995-09-27␤»","clone\n\nDefined as:\n\n    method clone(:$year, :$month, :$day, :&formatter)\n\nCreates a new Date object based on the invocant, but with the given\narguments overriding the values from the invocant.\n\n    say Date.new('2015-11-24').clone(month => 12);    # OUTPUT: «2015-12-24␤»","today\n\nDefined as:\n\n    method today(:&formatter --> Date:D)\n\nReturns a Date object for the current day. Optionally accepts a formatter\nnamed parameter.\n\n    say Date.today;","later\n\nDefined as:\n\n    method later(Date:D: *%unit)\n\nReturns a Date object based on the current one, but with a date delta\napplied. The date delta can be passed as a named argument where the\nargument name is the unit.\n\nAllowed units are day, days, week, weeks, month, months, year, years.\nPlease note that the plural forms can only be used with the later method.\n\nPlease note that the special \":2nd\" named parameter syntax can be a compact\nand self-documenting way of specifying the delta\n\n    say Date.new('2015-12-24').later(:2years);  # OUTPUT: «2017-12-24␤»\n\nSince addition of several different time units is not commutative, only one\nunit may be passed.\n\n    my $d = Date.new('2015-02-27');\n    say $d.later(month => 1).later(:2days);  # OUTPUT: «2015-03-29␤»\n    say $d.later(days => 2).later(:1month);  # OUTPUT: «2015-04-01␤»\n    say $d.later(days => 2).later(:month);   # same, as +True === 1\n\nNegative offsets are allowed, though #method earlier is more idiomatic for\nthat.","earlier\n\nDefined as:\n\n    method earlier(Date:D: *%unit)\n\nReturns a Date object based on the current one, but with a date delta\ntowards the past applied. See #method later for usage.\n\n    my $d = Date.new('2015-02-27');\n    say $d.earlier(month => 5).earlier(:2days);  # OUTPUT: «2014-09-25␤»","truncated-to\n\nDefined as:\n\n    method truncated-to(Date:D: Cool $unit)\n\nReturns a Date truncated to the first day of its year, month or week. For\nexample\n\n    my $c = Date.new('2012-12-24');\n    say $c.truncated-to('year');     # OUTPUT: «2012-01-01␤»\n    say $c.truncated-to('month');    # OUTPUT: «2012-12-01␤»\n    say $c.truncated-to('week');     # OUTPUT: «2012-12-24␤», because it's Monday already","succ\n\nDefined as:\n\n    method succ(Date:D: --> Date:D)\n\nReturns a Date of the following day. \"succ\" is short for \"successor\".\n\n    say Date.new(\"2016-02-28\").succ;   # OUTPUT: «2016-02-29␤»","pred\n\nDefined as:\n\n    method pred(Date:D: --> Date:D)\n\nReturns a Date of the previous day. \"pred\" is short for \"predecessor\".\n\n    say Date.new(\"2016-01-01\").pred;   # OUTPUT: «2015-12-31␤»","Str\n\nDefined as:\n\n    multi method Str(Date:D: --> Str:D)\n\nReturns a string representation of the invocant, as specified by the\nformatter. If no formatter was specified, an (ISO 8601) date will be\nreturned.\n\n    say Date.new('2015-12-24').Str;                     # OUTPUT: «2015-12-24␤»\n\n    my $fmt = { sprintf \"%02d/%02d/%04d\", .month, .day, .year };\n    say Date.new('2015-12-24', formatter => $fmt).Str;  # OUTPUT: «12/24/2015␤»","gist\n\nDefined as:\n\n    multi method gist(Date:D: --> Str:D)\n\nReturns the date in YYYY-MM-DD format (ISO 8601)\n\n    say Date.new('2015-12-24').gist;                    # OUTPUT: «2015-12-24␤»","Date\n\nDefined as:\n\n    method Date(--> Date)\n\nReturns the invocant.\n\n    say Date.new('2015-12-24').Date;  # OUTPUT: «2015-12-24␤»\n    say Date.Date;                    # OUTPUT: «(Date)␤»","DateTime\n\nDefined as:\n\n    multi method DateTime(Date:U --> DateTime:U)\n    multi method DateTime(Date:D --> DateTime:D)\n\nConverts the invocant to DateTime\n\n    say Date.new('2015-12-24').DateTime; # OUTPUT: «2015-12-24T00:00:00Z␤»\n    say Date.DateTime;                   # OUTPUT: «(DateTime)␤»\n\nFunctions\n\n  sub sleep\n\n    sub sleep($seconds = Inf --> Nil)\n\nAttempt to sleep for the given number of $seconds. Returns Nil on\ncompletion. Accepts Int, Num, Rat, or Duration types as an argument since\nall of these also do Real.\n\n    sleep 5;                # Int\n    sleep 5.2;              # Num\n    sleep (5/2);            # Rat\n    sleep (now - now + 5);  # Duration\n\n\nIt is thus possible to sleep for a non-integer amount of time. For\ninstance, the following code shows that sleep (5/2) sleeps for 2.5 seconds\nand sleep 5.2 sleeps for 5.2 seconds:\n\n    my $before = now;\n    sleep (5/2);\n    my $after = now;\n    say $after-$before;  # OUTPUT: «2.502411561␤»\n\n    $before = now;\n    sleep 5.2;\n    $after = now;\n    say $after-$before;  # OUTPUT: «5.20156987␤»\n\n  sub sleep-timer\n\n    sub sleep-timer(Real() $seconds = Inf --> Duration:D)\n\nThis function is implemented like sleep, but unlike the former it does\nreturn a Duration instance with the number of seconds the system did not\nsleep.\n\nIn particular, the returned Duration will handle the number of seconds\nremaining when the process has been awakened by some external event (e.g.,\nVirtual Machine or Operating System events). Under normal condition, when\nsleep is not interrupted, the returned Duration has a value of 0, meaning\nno extra seconds remained to sleep. Therefore, in normal situations:\n\n    say sleep-timer 3.14;  # OUTPUT: «0␤»\n\nThe same result applies to edge cases, when a negative or zero time to\nsleep is passed as argument:\n\n    say sleep-timer -2; # OUTPUT: 0\n    say sleep-timer 0;  # OUTPUT: 0\n\n\nSee also sleep-until.\n\n  sub sleep-until\n\n    sub sleep-until(Instant $until --> Bool)\n\nWorks similar to sleep but checks the current time and keeps sleeping until\nthe required instant in the future has been reached. It uses internally the\nsleep-timer method in a loop to ensure that, if accidentally woken up\nearly, it will wait again for the specified amount of time remaining to\nreach the specified instant. goes back to sleep\n\nReturns True if the Instant in the future has been achieved (either by mean\nof sleeping or because it is right now), False in the case an Instant in\nthe past has been specified.\n\nTo sleep until 10 seconds into the future, one could write something like\nthis:\n\n    say sleep-until now+10;   # OUTPUT: «True␤»\n\nTrying to sleep until a time in the past doesn't work:\n\n    my $instant = now - 5;\n    say sleep-until $instant; # OUTPUT: «False␤»\n\nHowever if we put the instant sufficiently far in the future, the sleep\nshould run:\n\n    my $instant = now + 30;\n    # assuming the two commands are run within 30 seconds of one another...\n    say sleep-until $instant; # OUTPUT: «True␤»\n\n\nTo specify an exact instant in the future, first create a DateTime at the\nappropriate point in time, and cast to an Instant.\n\n    my $instant = DateTime.new(\n        year => 2020,\n        month => 9,\n        day => 1,\n        hour => 22,\n        minute => 5);\n    say sleep-until $instant.Instant; # True (eventually...)\n\n\nThis could be used as a primitive kind of alarm clock. For instance, say\nyou need to get up at 7am on the 4th of September 2015, but for some reason\nyour usual alarm clock is broken and you only have your laptop. You can\nspecify the time to get up (being careful about time zones, since\nDateTime.new uses UTC by default) as an Instant and pass this to\nsleep-until, after which you can play an mp3 file to wake you up instead of\nyour normal alarm clock. This scenario looks roughly like this:\n\n    # DateTime.new uses UTC by default, so get time zone from current time\n    my $timezone = DateTime.now.timezone;\n    my $instant = DateTime.new(\n        year => 2015,\n        month => 9,\n        day => 4,\n        hour => 7,\n        minute => 0,\n        timezone => $timezone\n    ).Instant;\n    sleep-until $instant;\n    qqx{mplayer wake-me-up.mp3};\n\n\n  sub infix:<->\n\n    multi sub infix:<-> (Date:D, Int:D --> Date:D)\n    multi sub infix:<-> (Date:D, Date:D --> Int:D)\n\nTakes a date to subtract from and either an Int, representing the number of\ndays to subtract, or another Date object. Returns a new Date object or the\nnumber of days between the two dates, respectively.\n\n    say Date.new('2016-12-25') - Date.new('2016-12-24'); # OUTPUT: «1␤»\n    say Date.new('2015-12-25') - Date.new('2016-11-21'); # OUTPUT: «-332␤»\n    say Date.new('2016-11-21') - 332;                    # OUTPUT: «2015-12-25␤»\n\n  sub infix:<+>\n\n    multi sub infix:<+> (Date:D, Int:D --> Date:D)\n    multi sub infix:<+> (Int:D, Date:D --> Date:D)\n\nTakes an Int and adds that many days to the given Date object.\n\n    say Date.new('2015-12-25') + 332; # OUTPUT: «2016-11-21␤»\n    say 1 + Date.new('2015-12-25');   # OUTPUT: «2015-12-26␤»"],"name":"Date"},{"name":"Associative","methods":["of\n\nDefined as:\n\n    method of()\n\nAssociative is actually a parameterized role which can use different\nclasses for keys and values. As seen at the top of the document, by default\nit coerces to Str for the key and uses a very generic Mu for value.\n\n    my %any-hash;\n    say %any-hash.of;#  OUTPUT: «(Mu)␤»\n\nThe value is the first parameter you use when instantiating Associative\nwith particular classes:\n\n    class DateHash is Hash does Associative[Cool,DateTime] {};\n    my %date-hash := DateHash.new;\n    say %date-hash.of; # OUTPUT: «(Cool)␤»","keyof\n\nDefined as:\n\n    method keyof()\n\nReturns the parameterized key used for the Associative role, which is Any\ncoerced to Str by default. This is the class used as second parameter when\nyou use the parameterized version of Associative.\n\n    my %any-hash;\n    %any-hash.keyof; #OUTPUT: «(Str(Any))␤»"],"desc":"TITLE\nrole Associative\n\nSUBTITLE\nObject that supports looking up values by key\n\n    role Associative[::TValue = Mu, ::TKey = Str(Any)] { }\n\nA common role for types that support name-based lookup through\npostcircumfix:<{ }>, for example Hash and Map. It is used for type checks\nin operators that expect to find specific methods to call. See Subscripts\nfor details.\n\nThe % sigil restricts variables to objects that do Associative, so you will\nhave to mix in that role if you want to use it for your classes.\n\n    class Whatever {};\n    my %whatever := Whatever.new;\n    # OUTPUT: «Type check failed in binding; expected Associative but got Whatever\n\n\nPlease note that we are using binding := here, since by default %\nassignments expect a Hash in the right-hand side. However, with the\nAssociative role:\n\n    class Whatever is Associative {};\n    my %whatever := Whatever.new;\n\nwill be syntactically correct.\n\n"},{"name":"Supply","desc":"TITLE\nclass Supply\n\nSUBTITLE\nAsynchronous data stream with multiple subscribers\n\n    class Supply {}\n\nA supply is a thread-safe, asynchronous data stream like a Channel, but it\ncan have multiple subscribers (taps) that all get the same values flowing\nthrough the supply.\n\nIt is a thread-safe implementation of the Observer Pattern, and central to\nsupporting reactive programming in Raku.\n\nThere are two types of Supplies: live and on demand. When tapping into a\nlive supply, the tap will only see values that are flowing through the\nsupply after the tap has been created. Such supplies are normally infinite\nin nature, such as mouse movements. Closing such a tap does not stop mouse\nevents from occurring, it just means that the values will go by unseen. All\ntappers see the same flow of values.\n\nA tap on an on demand supply will initiate the production of values, and\ntapping the supply again may result in a new set of values. For example,\nSupply.interval produces a fresh timer with the appropriate interval each\ntime it is tapped. If the tap is closed, the timer simply stops emitting\nvalues to that tap.\n\nA live Supply is obtained from the Supplier factory method Supply. New\nvalues are emitted by calling emit on the Supplier object.\n\n    my $supplier = Supplier.new;\n    my $supply = $supplier.Supply;\n    $supply.tap(-> $v { say \"$v\" });\n    $supplier.emit(42); # Will cause the tap to output \"42\"\n\nThe live method returns True on live supplies. Factory methods such as\ninterval, from-list will return on demand supplies.\n\nA live Supply that keeps values until tapped the first time can be created\nwith Supplier::Preserving.\n\nFurther examples can be found in the concurrency page.\n\n","methods":["that return Taps","tap\n\n    method tap(Supply:D: &emit = -> $ { },\n            :&done,\n            :&quit,\n            :&tap\n        --> Tap:D)\n\n\nCreates a new tap (a kind of subscription if you will), in addition to all\nexisting taps. The first positional argument is a piece of code that will\nbe called when a new value becomes available through the emit call.\n\nThe &done callback can be called in a number of cases: if a supply block is\nbeing tapped, when a done routine is reached; if a supply block is being\ntapped, it will be automatically triggered if the supply block reaches the\nend; if the done method is called on the parent Supplier (in the case of a\nsupply block, if there are multiple Suppliers referenced by whenever, they\nmust all have their done method invoked for this to trigger the &done\ncallback of the tap as the block will then reach its end).\n\nThe &quit callback is called if the tap is on a supply block which exits\nwith an error. It is also called if the quit method is invoked on the\nparent Supplier (in the case of a supply block any one Supplier quitting\nwith an uncaught exception will call the &quit callback as the block will\nexit with an error). The error is passed as a parameter to the callback.\n\nThe &tap callback is called once the Tap object is created, which is passed\nas a parameter to the callback. The callback is called ahead of\nemit/done/quit, providing a reliable way to get the Tap object. One case\nwhere this is useful is when the Supply begins emitting values\nsynchronously, since the call to .tap won't return the Tap object until it\nis done emitting, preventing it from being stopped if needed.\n\nMethod tap returns an object of type Tap, on which you can call the close\nmethod to cancel the subscription.\n\n    my $s = Supply.from-list(0 .. 5);\n    my $t = $s.tap(-> $v { say $v }, done => { say \"no more ticks\" });\n\nProduces:\n\n    0\n    1\n    2\n    3\n    4\n    5\n    no more ticks","act\n\n    method act(Supply:D: &act --> Tap:D)\n\nCreates a tap on the given supply with the given code. Differently from\ntap, the given code is guaranteed to be only executed by one thread at a\ntime.\n\nUtility methods","Capture\n\nDefined as:\n\n    method Capture(Supply:D --> Capture:D)\n\nEquivalent to calling .List.Capture on the invocant.","Channel\n\n    method Channel(Supply:D: --> Channel:D)\n\nReturns a Channel object that will receive all future values from the\nsupply, and will be closed when the Supply is done, and quit (shut down\nwith error) when the supply is quit.","Promise\n\n    method Promise(Supply:D: --> Promise:D)\n\nReturns a Promise that will be kept when the Supply is done. If the Supply\nalso emits any values, then the Promise will be kept with the final value.\nOtherwise, it will be kept with Nil. If the Supply ends with a quit instead\nof a done, then the Promise will be broken with that exception.\n\n    my $supplier = Supplier.new;\n    my $s = $supplier.Supply;\n    my $p = $s.Promise;\n    $p.then(-> $v { say \"got $v.result()\" });\n    $supplier.emit('cha');         # not output yet\n    $supplier.done();              # got cha\n\nThe Promise method is most useful when dealing with supplies that will tend\nto produce just one value, when only the final value is of interest, or\nwhen only completion (successful or not) is relevant.","live\n\n    method live(Supply:D: --> Bool:D)\n\nReturns True if the supply is \"live\", that is, values are emitted to taps\nas soon as they arrive. Always returns True in the default Supply (but for\nexample on the supply returned from Supply.from-list it's False).\n\n    say Supplier.new.Supply.live;    # OUTPUT: «True␤»","schedule-on\n\n    method schedule-on(Supply:D: Scheduler $scheduler)\n\nRuns the emit, done and quit callbacks on the specified scheduler.\n\nThis is useful for GUI toolkits that require certain actions to be run from\nthe GUI thread."]},{"desc":"TITLE\nclass Set\n\nSUBTITLE\nImmutable collection of distinct objects\n\n    class Set does Setty { }\n\nA Set is an immutable set, meaning a collection of distinct elements in no\nparticular order. (For mutable sets, see SetHash instead.)\n\nObjects/values of any type are allowed as set elements. Within a Set, every\nelement is guaranteed to be unique (in the sense that no two elements would\ncompare positively with the === operator):\n\n    my $fruits = set <peach apple orange apple apple>;\n\n    say $fruits.elems;      # OUTPUT: «3␤»\n    say $fruits.keys.sort;  # OUTPUT: «apple orange peach␤»\n\n\nSets can be treated as object hashes using the { } postcircumfix operator,\nwhich returns the value True for keys that are elements of the set, and\nFalse for keys that aren't:\n\n    my $fruits = set <peach apple orange apple apple>;\n    say $fruits<apple>;  # OUTPUT: «True␤»\n    say $fruits<kiwi>;   # OUTPUT: «False␤»\n\nCreating Set objects\n\nSets can be composed using the set subroutine (or Set.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the set:\n\n    my $n = set \"zero\" => 0, \"one\" => 1, \"two\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:two(2), :zero(0), :one(1)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n\nAlternatively, the .Set coercer (or its functional form, Set()) can be\ncalled on an existing object to coerce it to a Set. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a set with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the set - and keys mapped to values which boolify to False are skipped:\n\n    my $n = (\"zero\" => 0, \"one\" => 1, \"two\" => 2).Set;\n    say $n.keys.perl;        # OUTPUT: «(\"one\", \"two\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n\nFurthermore, you can get a Set by using set operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Set on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (^) 4;  # OUTPUT: «set(1, 2, 3, 5)␤»\n\nOf course, you can also create a Set with the .new method.\n\n    my $fruits = Set.new( <peach apple orange apple apple> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Set, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Set\n    my $fruits = Set[Str].new( <peach apple orange apple apple> );\n\n    # only allow whole numbers (Int) in the Set\n    my $fruits = Set[Int].new( <peach apple orange apple apple> );\n    # Type check failed in binding; expected Int but got Str (\"peach\")\n\nFinally, you can create Set masquerading as a hash by using the is trait:\n\n    my %s is Set = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %s is Set[Str] = <a b c>;\n    say %s<a>;  # True\n    say %s<d>;  # False\n\n    # limit to whole numbers\n    my %s is Set[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set operators, which can take Sets (or any other\ncollections) as input, and return result sets as new Set objects. For\nexample:\n\n    my ($a, $b) = set(1, 2, 3), set(2, 4);\n\n    say $a (<) $b;  # OUTPUT: «False␤»\n    say $a (&) $b;  # OUTPUT: «set(2)␤»\n    say $a (^) $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ∩ $b;  # OUTPUT: «set(2)␤»\n    say $a ⊖ $b;  # OUTPUT: «set(1, 3, 4)␤»\n\n\nSee Set/Bag Operators for a complete list of set operators with detailed\nexplanations.\n\nSubroutines\n\n  sub set\n\n    sub set(*@args --> Set)\n\nCreates a Set from the given @args\n\nSee Also\n\nSets, Bags, and Mixes","methods":[],"name":"Set"},{"desc":"TITLE\nenum Endian\n\nSUBTITLE\nIndicate endianness (6.d, 2018.12 and later)\n\n    enum Endian <NativeEndian LittleEndian BigEndian>;\n\n    An enum for indicating endianness, specifically with methods on blob8\nand buf8. Consists of NativeEndian, LittleEndian and BigEndian.\n\n","methods":["Numeric\n\n    multi method Numeric(Endian:D --> Int:D)\n\nReturns the value part of the enum pair.\n\n    say NativeEndian.Numeric;    # OUTPUT: «0␤»\n    say LittleEndian.Numeric;    # OUTPUT: «1␤»\n    say BigEndian.Numeric;       # OUTPUT: «2␤»\n\nNote that the actual numeric values are subject to change. So please use\nthe named values instead."],"name":"Endian"},{"desc":"TITLE\nclass Junction\n\nSUBTITLE\nLogical superposition of values\n\n    class Junction is Mu { }\n\nA junction is an unordered composite value of zero or more values.\nJunctions autothread over many operations, which means that the operation\nis carried out for each junction element (also known as eigenstate), and\nthe result is junction of the return values of all those operators.\n\nJunctions collapse into a single value in boolean context, so when used in\na conditional, a negation or an explicit coercion to Bool through the so or\n? prefix operators. The semantics of this collapse depend on the junction\ntype, which can be all, any, one or none.\n\n  type  constructor  operator  True if ...\n  all   all          &         no value evaluates to False\n  any   any          |         at least one value evaluates to True\n  one   one          ^         exactly one value evaluates to True\n  none  none                   no value evaluates to True\n\n\nAs the table shows, in order to create junctions, you use the string that\nrepresents the type followed by any object, or else call .all, .none or\n.one on the object.\n\n    say so 3 == (1..30).one;         # OUTPUT: «True␤»\n    say so (\"a\" ^ \"b\" ^ \"c\") eq \"a\"; # OUTPUT: «True␤»\n\nJunctions are very special objects. They fall outside the Any hierarchy,\nbeing only, as any other object, subclasses of Mu. That enables a feature\nfor most methods: autothreading. Autothreading happens when a junction is\nbound to a parameter of a code object that doesn't accept values of type\nJunction. Instead of producing an error, the signature binding is repeated\nfor each value of the junction.\n\nExample:\n\n    my $j = 1|2;\n    if 3 == $j + 1 {\n        say 'yes';\n    }\n\nFirst autothreads over the infix:<+>  operator, producing the Junction 2|3.\nThe next autothreading step is over infix:<==> , which produces False|True.\nThe if conditional evaluates the junction in boolean context, which\ncollapses it to True. So the code prints yes\\n.\n\nThe type of a Junction does not affect the number of items in the resultant\nJunction after autothreading. For example, using a one Junction during Hash\nkey lookup, still results in a Junction with several items. It is only in\nboolean context would the type of the Junction come into play:\n\n    my %h = :42foo, :70bar;\n    say    %h{one <foo meow>}:exists; # OUTPUT: «one(True, False)␤»\n    say so %h{one <foo meow>}:exists; # OUTPUT: «True␤»\n    say    %h{one <foo  bar>}:exists; # OUTPUT: «one(True, True)␤»\n    say so %h{one <foo  bar>}:exists; # OUTPUT: «False␤»\n\nNote that the compiler is allowed, but not required, to parallelize\nautothreading (and Junction behavior in general), so it is usually an error\nto autothread junctions over code with side effects.\n\nAutothreading implies that the function that's autothreaded will also\nreturn a Junction of the values that it would usually return.\n\n    (1..3).head( 2|3 ).say; # OUTPUT: «any((1 2), (1 2 3))␤»\n\nSince .head returns a list, the autothreaded version returns a Junction of\nlists.\n\n    (1..3).contains( 2&3 ).say; # OUTPUT: «all(True, True)␤»\n\nLikewise, .contains returns a Boolean; thus, the autothreaded version\nreturns a Junction of Booleans. In general, all methods and routines that\ntake an argument of type T and return type TT, will also accept junctions\nof T, returning junctions of TT.\n\nImplementations are allowed to short-circuit Junctions. For example one or\nmore routine calls (a(), b(), or c()) in the code below might not get\nexecuted at all, if the result of the conditional has been fully determined\nfrom routine calls already performed (only one truthy return value is\nenough to know the entire Junction is true):\n\n    if a() | b() | c() {\n        say \"At least one of the routines was called and returned a truthy value\"\n    }\n\n\nJunctions are meant to be used as matchers in boolean context;\nintrospection of junctions is not supported. If you feel the urge to\nintrospect a junction, use a Set or a related type instead.\n\nUsage examples:\n\n    my @list = <1 2 \"Great\">;\n    @list.append(True).append(False);\n    my @bool_or_int = grep Bool|Int, @list;\n\n    sub is_prime(Int $x) returns Bool {\n        # 'so' is for boolean context\n        so $x %% none(2..$x.sqrt);\n    }\n    my @primes_ending_in_1 = grep &is_prime & / 1$ /, 2..100;\n    say @primes_ending_in_1;        # OUTPUT: «[11 31 41 61 71]␤»\n\n    my @exclude = <~ .git>;\n    for dir(\".\") { say .Str if .Str.ends-with(none @exclude) }\n\nSpecial care should be taken when using all with arguments that may produce\nan empty list:\n\n    my @a = ();\n    say so all(@a) # True, because there are 0 False's\n\nTo express \"all, but at least one\", you can use @a && all(@a)\n\n    my @a = ();\n    say so @a && all(@a);   # OUTPUT: «False␤»\n\nNegated operators are special-cased when it comes to autothreading. $a !op\n$b is rewritten internally as !($a op $b). The outer negation collapses any\njunctions, so the return value always a plain Bool.\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word !eq any @negations {\n        say '\"yes\" is not a negation';\n    }\n\nNote that without this special-casing, an expression like $word ne any\n@words would always evaluate to True for non-trivial lists on one side.\n\nFor this purpose, infix:<ne>  counts as a negation of infix:<eq> .\n\nIn general it is more readable to use a positive comparison operator and a\nnegated junction:\n\n    my $word = 'yes';\n    my @negations = <no none never>;\n    if $word eq none @negations {\n        say '\"yes\" is not a negation';\n    }\n\nFailures and exceptions\n\nFailures are just values like any other, as far as Junctions are\nconcerned:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    my @list = gather for $j -> $e {\n        take $e if $e.defined;\n    }\n    @list.say; # OUTPUT: «[42 2.1]␤»\n\nAbove, we've used prefix + operator on a Junction to coerce the strings\ninside of it to Numeric. Since the operator returns a Failure when a Str\nthat doesn't contain a number gets coerced to Numeric, one of the elements\nin the Junction is a Failure. Failures do not turn into exceptions until\nthey are used or sunk, but we can check for definedness to avoid that. That\nis what we do in the loop that runs over the elements of the junction,\nadding them to a list only if they are defined.\n\nThe exception will be thrown, if you try to use the Failure as a value—just\nlike as if this Failure were on its own and not part of the Junction:\n\n    my $j = +any \"not a number\", \"42\", \"2.1\";\n    try say $j == 42;\n    $! and say \"Got exception: $!.^name()\";\n    # OUTPUT: «Got exception: X::Str::Numeric␤»\n\n\nNote that if an exception gets thrown when any of the values in a Junction\nget computed, it will be thrown just as if the problematic value were\ncomputed on its own and not with a Junction; you can't just compute the\nvalues that work while ignoring exceptions:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    say try calc $j; # OUTPUT: «Nil␤»\n\nOnly one value above causes an exception, but the result of the try block\nis still a Nil. A possible way around it is to cheat and evaluate the\nvalues of the Junction individually and then re-create the Junction from\nthe result:\n\n    sub calc ($_) { die when 13 }\n    my $j = any 1..42;\n    $j = any (gather $j».take).grep: {Nil !=== try calc $_};\n    say so $j == 42; # OUTPUT: «True␤»\n\nSmartmatching\n\nNote that using Junctions on the right-hand side of ~~ works slightly\ndifferently than using Junctions with other operators.\n\nConsider this example:\n\n    say 25 == (25 | 42);    # OUTPUT: «any(True, False)␤» – Junction\n    say 25 ~~ (25 | 42);    # OUTPUT: «True␤»             – Bool\n\nThe reason is that == (and most other operators) are subject to\nauto-threading, and therefore you will get a Junction as a result. On the\nother hand, ~~ will call .ACCEPTS on the right-hand-side (in this case on a\nJunction) and the result will be a Bool.\n\n","methods":["new\n\nDefined as:\n\n    multi method new(Junction: \\values, Str :$type!)\n    multi method new(Junction: Str:D \\type, \\values)\n\nConstructor to define a new Junction from the type that defines de Junction\nand a set of values.\n\n    my $j = Junction.new(<Þor Oðinn Loki>, type => \"all\");\n    my $n = Junction.new( \"one\", 1..6 )","defined\n\nDefined as:\n\n    multi method defined(Junction:D:)\n\nChecks for definedness instead of Boolean values.\n\n    say ( 3 | Str).defined ;   # OUTPUT: «True␤»\n    say (one 3, Str).defined;  # OUTPUT: «True␤»\n    say (none 3, Str).defined; # OUTPUT: «False␤»\n\nFailures are also considered non-defined:\n\n    my $foo=Failure.new;\n    say (one 3, $foo).defined; # OUTPUT: «True␤»\n\nSince 6.d, this method will autothread.","Bool\n\nDefined as:\n\n    multi method Bool(Junction:D:)\n\nCollapses the Junction and returns a single Boolean value according to the\ntype and the values it holds. Every element is transformed to Bool.\n\n    my $n = Junction.new( \"one\", 1..6 );\n    say $n.Bool;                         # OUTPUT: «False␤»\n\n\nAll elements in this case are converted to True, so it's false to assert\nthat only one of them is.\n\n    my $n = Junction.new( \"one\", <0 1> );\n    say $n.Bool;                         # OUTPUT: «True␤»\n\n\nJust one of them is truish in this case, 1, so the coercion to Bool returns\nTrue.","Str\n\nDefined as:\n\n    multi method Str(Junction:D:)\n\nAutothreads the .Str method over its elements and returns results as a\nJunction. Output methods that use .Str method (print and put) are\nspecial-cased to autothread junctions, despite being able to accept a Mu\ntype.","gist\n\nDefined as:\n\n    multi method gist(Junction:D:)\n\nCollapses the Junction and returns a Str composed of the type of the\njunction and the gists of its components:\n\n    <a 42 c>.all.say; # OUTPUT: «all(a, 42, c)␤»","perl\n\nDefined as:\n\n    multi method perl(Junction:D:)\n\nCollapses the Junction and returns a Str composed of perls of its\ncomponents that evaluates to the equivalent Junction with equivalent\ncomponents:\n\n    <a 42 c>.all.perl.put; # OUTPUT: «all(\"a\", IntStr.new(42, \"42\"), \"c\")␤»\n\n  infix ~\n\nDefined as:\n\n    multi sub infix:<~>(Str:D $a, Junction:D $b)\n    multi sub infix:<~>(Junction:D $a, Str:D $b)\n    multi sub infix:<~>(Junction:D \\a, Junction:D \\b)\n\nThe infix ~ concatenation can be used to merge junctions into a single one\nor merge Junctions with strings. The resulting junction will have all\nelements merged as if they were joined into a nested loop:\n\n    my $odd  = 1|3|5;\n    my $even = 2|4|6;\n\n    my $merged = $odd ~ $even;\n    say $merged; #OUTPUT: «any(12, 14, 16, 32, 34, 36, 52, 54, 56)␤»\n\n    say \"Found 34!\" if 34 == $merged; #OUTPUT: «Found 34!␤»\n    my $prefixed = \"0\" ~ $odd;\n    say \"Found 03\" if \"03\" == $prefixed; #OUTPUT: «Found 03!␤»\n\n    my $postfixed = $odd ~ \"1\";\n    say \"Found 11\" if 11 == $postfixed; #OUTPUT: «Found 11!␤»\n\n\nOn the other hand, the versions of ~ that use a string as one argument will\njust concatenate the string to every member of the Junction, creating\nanother Junction with the same number of elements.\n\nSee Also\n\n  * https://perlgeek.de/blog-en/perl-5-to-6/08-junctions.html\n\n  * http://perl6maven.com/perl6-is-a-value-in-a-given-list-of-values\n\n  * https://perl6advent.wordpress.com/2009/12/13/day-13-junctions/"],"name":"Junction"},{"name":"Bag","desc":"TITLE\nclass Bag\n\nSUBTITLE\nImmutable collection of distinct objects with integer weights\n\n    class Bag does Baggy { }\n\nA Bag is an immutable bag/multiset implementing Associative, meaning a\ncollection of distinct elements in no particular order that each have an\ninteger weight assigned to them signifying how many copies of that element\nare considered \"in the bag\". (For mutable bags, see BagHash instead.)\n\nBags are often used for performing weighted random selections - see .pick\nand .roll.\n\nObjects/values of any type are allowed as bag elements. Within a Bag, items\nthat would compare positively with the === operator are considered the same\nelement, with the number of how many there are as its weight. But of course\nyou can also easily get back the expanded list of items (without the\norder):\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBags can be treated as object hashes using the { } postcircumfix operator,\nor the < >  operator for literal string keys, which returns the\ncorresponding integer weight for keys that are elements of the bag, and 0\nfor keys that aren't:\n\n    my $breakfast = bag <spam eggs spam spam bacon spam>;\n    say $breakfast<bacon>;    # OUTPUT: «1␤»\n    say $breakfast<spam>;     # OUTPUT: «4␤»\n    say $breakfast<sausage>;  # OUTPUT: «0␤»\n\nCreating Bag objects\n\nBags can be composed using the bag subroutine (or Bag.new, for which it is\na shorthand). Any positional parameters, regardless of their type, become\nelements of the bag:\n\n    my $n = bag \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.keys.perl;        # OUTPUT: «(:c(2), :b(1), :a(0)).Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Pair) (Pair) (Pair))␤»\n    say $n.values.perl;      # OUTPUT: «(2, 1, 1).Seq␤»\n\nAlternatively, the .Bag coercer (or its functional form, Bag()) can be\ncalled on an existing object to coerce it to a Bag. Its semantics depend on\nthe type and contents of the object. In general it evaluates the object in\nlist context and creates a bag with the resulting items as elements,\nalthough for Hash-like objects or Pair items, only the keys become elements\nof the bag, and the (cumulative) values become the associated integer\nweights:\n\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).Bag;\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nFurthermore, you can get a Bag by using bag operators (see next section) on\nobjects of other types such as List, which will act like they internally\ncall .Bag on them before performing the operation. Be aware of the tight\nprecedence of those operators though, which may require you to use\nparentheses around arguments:\n\n    say (1..5) (+) 4;  # OUTPUT: «bag(1, 2, 3, 4(2), 5)␤»\n\nOf course, you can also create a Bag with the .new method.\n\n    my $breakfast = Bag.new( <spam eggs spam spam bacon spam> );\n\nSince 6.d (2019.03 and later) you can also use this syntax for\nparameterization of the Bag, to specify which type of values are\nacceptable:\n\n    # only allow strings (Str) in the Bag\n    my $breakfast = Bag[Str].new( <spam eggs spam spam bacon spam> );\n\n    # only allow whole numbers (Int) in the Bag\n    my $breakfast = Bag[Int].new( <spam eggs spam spam bacon spam> );\n    # Type check failed in binding; expected Int but got Str (\"spam\")\n\nFinally, you can create Bag masquerading as a hash by using the is trait:\n\n    my %b is Bag = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\nSince 6.d (2019.03 and later), this syntax also allows you to specify the\ntype of values you would like to allow:\n\n    # limit to strings\n    my %b is Bag[Str] = <a b c>;\n    say %b<a>;  # True\n    say %b<d>;  # False\n\n    # limit to whole numbers\n    my %b is Bag[Int] = <a b c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set and bag operators, which can take Bags (or any\nother collections) as input, and return result as Bool, Set or Bag values.\nFor example:\n\n    my ($a, $b) = bag(2, 2, 4), bag(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nSubroutines\n\n  sub bag\n\n    sub bag(*@args --> Bag)\n\nCreates a new Bag from @args.\n\nNote on reverse and ordering\n\nThis method is inherited from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nSee also\n\nSets, Bags, and Mixes","methods":[]},{"desc":"TITLE\nclass StrDistance\n\nSUBTITLE\nContains the result of a string transformation.\n\nStrDistance objects are used to represent the return of the string\ntransformation operator.\n\n    say (($ = \"fold\") ~~ tr/old/new/).^name;  # OUTPUT: «StrDistance␤»\n\nA StrDistance object will stringify to the resulting string after the\ntransformation, and will numify to the distance between the two strings.\n\n    my $str = \"fold\";\n    my $str-dist = ($str ~~ tr/old/new/);\n    say ~$str-dist;  # OUTPUT: «fnew␤»\n    say +$str-dist;  # OUTPUT: «3␤»\n\n\n","methods":["before\n\nThis is actually a class attribute, and called as a method returns the\nstring before the transformation:\n\n    say $str-dist.before; # OUTPUT: «fold␤»","after\n\nAlso a class attribute, returns the string after the transformation:\n\n    say $str-dist.after;  # OUTPUT: «fnew␤»","Bool\n\nReturns True if before is different from after.","Numeric\n\nReturns the distance as a number.","Int\n\nDefined as:\n\n    multi method Int(StrDistance:D:)\n\nReturns the distance between the string before and after the\ntransformation.","Str\n\nDefined as:\n\n    multi method Str(StrDistance:D: --> Str)\n\nReturns an after string value.\n\n        my $str-dist = ($str ~~ tr/old/new/);\n        say $str-dist.Str; # OUTPUT: «fnew␤»\n        say ~$str-dist;    # OUTPUT: «fnew␤»"],"name":"StrDistance"},{"name":"Encoding","methods":["name\n\n    method name(--> Str)\n\nAbstract method that would return the primary name of the encoding.","alternative-names\n\n    method alternative-names()\n\nAbstract methods that should get a list of alternative names for the\nencoding.","decoder\n\n    method decoder(*%options --> Encoding::Decoder)\n\nShould get a character decoder instance for this encoding, configured with\nthe provided options. Options vary by encoding. The built-in encodings all\nsupport translate-nl, which if True will translate \\r\\n into \\n while\ndecoding.","encoder\n\nDefined as:\n\n    method encoder(*%options --> Encoding::Encoder)\n\nGets a character encoder instance for this encoding, configured with the\nprovided options. Options vary by encoding. The built-in encodings all\nsupport both replacement (either a Str replacement sequence or True to use\na default replacement sequence for unencodable characters) and translate-nl\n(when set to True, turns \\n into \\r\\n if the current platform is Windows)."],"desc":"TITLE\nrole Encoding\n\nSUBTITLE\nSupport for character encodings.\n\n    role Encoding { ... }\n\nThe Encoding role is implemented by classes that provide a character\nencoding, such as ASCII or UTF-8. Besides being used by the built-in\ncharacter encodings, it may also be implemented by users to provide new\nencodings. Instances of objects doing this role are typically obtained\nusing Encoding::Registry. For a list of supported encodings, see\nIO::Handle.\n\nAll methods provided by this role are stubs; they should be implemented by\nconsumers of the role.\n\n"},{"name":"Cancellation","desc":"TITLE\nclass Cancellation\n\nSUBTITLE\nRemoval of a task from a Scheduler before normal completion\n\n    my class Cancellation {}\n\nA low level part of the Raku concurrency system. Some Scheduler objects\nreturn a Cancellation with the .cue method which can be used to cancel the\nscheduled execution before normal completion. Cancellation.cancelled is a\nboolean that is true after #cancel is called.\n\n","methods":["cancel\n\nDefined as:\n\n    method cancel()\n\nUsage:\n\n    Cancellation.cancel\n\n\nCancels the scheduled execution of a task before normal completion."]},{"name":"Attribute","methods":["The usual way to obtain an object of type Attribute is by introspection:\n\n    class Useless {\n        has @!things;\n    }\n    my $a = Useless.^attributes(:local)[0];\n    say $a.perl;            # OUTPUT: «Attribute.new␤»\n    say $a.name;            # OUTPUT: «@!things␤»\n    say $a.package;         # OUTPUT: «(Useless)␤»\n    say $a.has_accessor;    # OUTPUT: «False␤»\n\nModifying a private attribute from the outside is usually not possible, but\nsince Attribute is at the level of the metaclass, all is fair game.","name\n\nDefined as:\n\n    method name(Attribute:D: --> Str:D)\n\nReturns the name of the attribute. Note that this is always the private\nname, so if an attribute is declared as has $.a, the name returned is $!a.\n\n    class Foo {\n        has @!bar;\n    }\n    my $a = Foo.^attributes(:local)[0];\n    say $a.name;            # OUTPUT: «@!bar␤»","package\n\nDefined as:\n\n    method package()\n\nReturns the package (class/grammar/role) to which this attribute belongs.\n\n    class Boo {\n        has @!baz;\n    }\n    my $a = Boo.^attributes(:local)[0];\n    say $a.package;         # OUTPUT: «(Boo)␤»","has_accessor\n\nDefined as:\n\n    method has_accessor(Attribute:D: --> Bool:D)\n\nReturns True if the attribute has a public accessor method.\n\n    class Container {\n        has $!private;\n        has $.public;\n    }\n    my $private = Container.^attributes(:local)[0];\n    my $public = Container.^attributes(:local)[1];\n    say $private.has_accessor; # OUTPUT: «False␤»\n    say $public.has_accessor;  # OUTPUT: «True␤»","rw\n\nDefined as:\n\n    method rw(Attribute:D: --> Bool:D)\n\nReturns True for attributes that have the \"is rw\" trait applied to them.\n\n    class Library {\n        has $.address; # Read-only value\n        has @.new-books is rw;\n    }\n    my $addr = Library.^attributes(:local)[0];\n    my $new-books = Library.^attributes(:local)[1];\n    say $addr.rw;      # OUTPUT: «False␤»\n    say $new-books.rw; # OUTPUT: «True␤»","readonly\n\nDefined as:\n\n    method readonly(Attribute:D: --> Bool:D)\n\nReturns True for readonly attributes, which is the default, or False for\nattributes marked as is rw.\n\n    class Library {\n        has $.address; # Read-only value\n        has @.new-books is rw;\n    }\n    my $addr = Library.^attributes(:local)[0];\n    my $new-books = Library.^attributes(:local)[1];\n    say $addr.readonly;      # OUTPUT: «True␤»\n    say $new-books.readonly; # OUTPUT: «False␤»","required\n\nDefined as:\n\n    method required(Attribute:D: --> Any:D)\n\nReturns 1 for attributes that have the \"is required\" trait applied, or Mu\nif the attribute did not have that trait applied. If the \"is required\"\ntrait is applied with a string, then that string will be returned instead\nof 1.\n\n    class Library {\n        has $.address is required;\n        has @.new-books is required(\"we always need more books\");\n    }\n    my $addr = Library.^attributes(:local)[0];\n    my $new-books = Library.^attributes(:local)[1];\n    say $addr.required;      # OUTPUT: «1␤»\n    say $new-books.readonly; # OUTPUT: «\"we always need more books\"␤»","type\n\nDefined as:\n\n    method type(Attribute:D: --> Mu)\n\nReturns the type constraint of the attribute.\n\n    class TypeHouse {\n        has Int @.array;\n        has $!scalar;\n        has @.mystery;\n    }\n    my @types = TypeHouse.^attributes(:local)[0..2];\n    for 0..2 { say @types[$_].type }\n    # OUTPUT: «(Positional[Int])\n    # (Mu)\n    # (Positional)␤»","get_value\n\nDefined as:\n\n    method get_value(Mu $obj)\n\nReturns the value stored in this attribute of object $obj.\n\n    class Violated {\n        has $!private-thing = 5;\n    }\n    my $private = Violated.^attributes(:local)[0];\n    say $private.get_value(Violated.new); # OUTPUT: «5␤»\n\nNote that this method violates encapsulation of the object, and should be\nused with care. Here be dragons.","set_value\n\nDefined as:\n\n    method set_value(Mu $obj, Mu \\new_val)\n\nBinds the value new_val to this attribute of object $obj.\n\n    class A {\n        has $!a = 5;\n        method speak() { say $!a; }\n    }\n    my $attr = A.^attributes(:local)[0];\n    my $a = A.new;\n    $a.speak; # OUTPUT: «5␤»\n    $attr.set_value($a, 42);\n    $a.speak; # OUTPUT: «42␤»\n\nNote that this method violates encapsulation of the object, and should be\nused with care. Here be dragons.","gist\n\nDefined as\n\n    multi method gist(Attribute:D:)\n\nReturns the name of the type followed by the name of the attribute.\n\n    class Hero {\n        has @!inventory;\n        has Str $.name;\n        submethod BUILD( :$name, :@inventory ) {\n            $!name = $name;\n            @!inventory = @inventory\n        }\n    }\n    say Hero.^attributes(:local)[0]; # OUTPUT: «Positional @!inventory»\n\n\nSince say implicitly calls .gist, that is what produces the output here.\n\nOptional introspection\n\n  DEPRECATED\n\nIf an attribute is marked as DEPRECATED, then calling the DEPRECATED method\nis possible and will return \"something else\" (if no specific reason was\nspecified) or the string that was specified with the DEPRECATED trait.\n\nIf an attribute is not marked as DEPRECATED, one cannot not call the\nDEPRECATED method. Therefore, the .?method syntax should be used.\n\n    class Hangout {\n        has $.table;\n        has $.bar is DEPRECATED(\"the patio\");\n    }\n    my $attr-table = Hangout.^attributes(:local)[0];\n    my $attr-bar = Hangout.^attributes(:local)[1];\n    with $attr-table.?DEPRECATED -> $text {     # does not trigger\n        say \"Table is deprecated with '$text'\";\n        # OUTPUT:\n    }\n    with $attr-table.?DEPRECATED -> $text {\n        say \"Bar is deprecated with '$text'\";\n        # OUTPUT: «Bar is deprecated with 'the patio'\"␤»\n    }"],"desc":"TITLE\nclass Attribute\n\nSUBTITLE\nMember variable\n\n    class Attribute { }\n\nIn Raku lingo, an attribute refers to a per-instance/object storage slot.\nAn Attribute is used to talk about classes' and roles' attributes at the\nmetalevel.\n\nNormal usage of attributes does not require the user to use this class\nexplicitly.\n\nTraits\n\n  Trait is default\n\nAn attribute that is assigned Nil will revert to its default value set with\nthe trait is default. In the case of arrays or associatives, the argument\nof is default will set the default item value or hash value.\n\n    class C {\n        has $.a is default(42) is rw = 666\n    }\n    my $c = C.new;\n    say $c;\n    $c.a = Nil;\n    say $c;\n    # OUTPUT: «C.new(a => 666)␤C.new(a => 42)␤»\n    class Foo {\n        has @.bar is default(42) is rw\n    };\n    my $foo = Foo.new( bar => <a b c> );\n    $foo.bar =Nil;\n    say $foo; # OUTPUT: «Foo.new(bar => [42])␤»\n\n  Trait is required\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute $attr, :$required!)\n\nThe trait is required will mark the attribute as to be filled with a value\nwhen the object is instantiated. Failing to do so will result in a runtime\nerror.\n\n    class C {\n        has $.a is required\n    }\n    my $c = C.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required, but you did not provide a value for it.␤»\n\nAvailable as of 6.d language version (early implementation exists in Rakudo\ncompiler 2018.08+): You can specify a reason why the attribute is\nrequired:\n\n    class D {\n        has $.a is required(\"it is a good idea\");\n    }\n    my $d = D.new;\n    CATCH{ default { say .^name, ': ', .Str } }\n    # OUTPUT: «X::Attribute::Required: The attribute '$!a' is required because it is a good idea,␤but you did not provide a value for it.␤»\n\n\nis required doesn't just affect the default constructor, it checks for the\nattribute at a lower level, so it will work for custom constructors written\nusing bless.\n\n  trait is DEPRECATED\n\n    multi sub trait_mod:<is>(Attribute:D $r, :$DEPRECATED!)\n\nMarks an attribute as deprecated, optionally with a message what to use\ninstead.\n\n    class C {\n        has $.foo is DEPRECATED(\"'bar'\");\n    }\n    my $c = C.new( foo => 42 );  # doesn't trigger with initialization (yet)\n    say $c.foo;                  # does trigger on usage\n\nAfter the program is finished, this will show something like this on\nSTDERR:\n\n    # Saw 1 occurrence of deprecated code.\n    # =====================================\n    # Method foo (from C) seen at:\n    # script.p6, line 5\n    # Please use 'bar' instead.\n\n  trait is rw\n\nDefined as:\n\n    multi sub trait_mod:<is> (Attribute:D $attr, :$rw!)\n\nMarks an attribute as read/write as opposed to the default readonly. The\ndefault accessor for the attribute will return a writable value.\n\n    class Boo {\n       has $.bar is rw;\n       has $.baz;\n    };\n\n    my $boo = Boo.new;\n    $boo.bar = 42; # works\n    $boo.baz = 42;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\n"},{"name":"HyperWhatever","desc":"TITLE\nclass HyperWhatever\n\nSUBTITLE\nPlaceholder for multiple unspecified values/arguments\n\n    class HyperWhatever { }\n\nHyperWhatever is very similar in functionality to Whatever. The difference\nlies in HyperWhatever standing in for multiple values, rather than a single\none.\n\nStandalone term\n\nJust like with Whatever, if a HyperWhatever is used as a term on its own,\nno currying is done and the HyperWhatever object will be used as-is:\n\n    sub foo ($arg) { say $arg.^name }\n    foo **; # OUTPUT: «HyperWhatever␤»\n\nYou can choose to interpret such a value as standing for multiple values in\nyour own routines. In core, a HyperWhatever can be used with this meaning\nwhen smartmatching with Lists:\n\n    say (1, 8)                ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 4, 5, 6, 7, 8) ~~ (1, **, 8); # OUTPUT: «True␤»\n    say (1, 2, 8, 9)          ~~ (1, **, 8); # OUTPUT: «False␤»\n\nWherever a HyperWhatever appears in the list on the right-hand side means\nany number of elements can fill that space in the list being smartmatched.\n\nCurrying\n\nWhen it comes to currying, the HyperWhatever follows the same rules as\nWhatever. The only difference is HyperWhatever produces a Callable with a\n*@ slurpy as a signature:\n\n    say (**²)(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nA HyperWhatever closure can be imagined as a Whatever closure with another\nsub wrapped around it that simply maps each element in the arguments over:\n\n    my &hyper-whatever = sub (*@args) { map *², @args }\n    say hyper-whatever(1, 2, 3, 4, 5); # OUTPUT: «(1 4 9 16 25)␤»\n\nWhen currying, mixing HyperWhatever with Whatever is not permitted.","methods":[]},{"methods":["hash\n\n    method hash()\n\nCoerces the QuantHash object to a Hash (by stringifying the objects for the\nkeys) with the values of the hash limited to the same limitation as\nQuantHash, and returns that.","Hash\n\n    method Hash()\n\nCoerces the QuantHash object to a Hash (by stringifying the objects for the\nkeys) without any limitations on the values, and returns that.","of\n\n    method of()\n\nReturns the type of value a value of this QuantHash may have. This is\ntypically Bool for Setty, UInt for Baggy or Real for Mixy roles.","keyof\n\n    method keyof()\n\nReturns the type of value a key of this QuantHash may have. This is\ntypically Mu.","Setty\n\n    method Setty(--> Setty:D)\n\nCoerce the QuantHash object to the equivalent object that uses the Setty\nrole. Note that for Mixy type coercion items with negative values will be\nskipped.\n\n    my %b is Bag = one => 1, two => 2;\n    say %b.Setty; # OUTPUT: «set(one two)␤»\n    my %m is Mix = one => 1, minus => -1;\n    say %m.Setty; # OUTPUT: «set(one)␤»","Baggy\n\n    method Baggy(--> Baggy:D)\n\nCoerce the QuantHash object to the equivalent object that uses the Baggy\nrole. Note that for Mixy type coercion items with negative values will be\nskipped.\n\n    my %s is Set = <one two>;\n    say %s.Baggy; # OUTPUT: «Bag(one, two)␤»\n    my %m is Mix = one => 1, minus => -1;\n    say %m.Baggy; # OUTPUT: «Bag(one)␤»","Mixy\n\n    method Mixy(--> Mixy:D)\n\nCoerce the QuantHash object to the equivalent object that uses the Mixy\nrole.\n\n    my %s is Set = <one two>;\n    say %s.Mixy; # OUTPUT: «Mix(one, two)␤»\n    my %b is Bag = one => 1, two => 2;\n    say %b.Mixy; # OUTPUT: «Mix(one, two)␤»"],"desc":"TITLE\nrole QuantHash\n\nSUBTITLE\nObject hashes with limitation on type of value\n\n    role QuantHash does Associative { }\n\nThe QuantHash role provides the basic functionality shared by the Setty,\nBaggy and Mixy roles. These provide object hashes of which the values are\nlimited in some way.\n\nQuantHashes are what set operators use internally.\n\n","name":"QuantHash"},{"name":"Baggy","methods":["new-from-pairs\n\nDefined as:\n\n    method new-from-pairs(*@pairs --> Baggy:D)\n\nConstructs a Baggy objects from a list of Pair objects given as positional\narguments:\n\n    say Mix.new-from-pairs: 'butter' => 0.22, 'sugar' => 0.1, 'sugar' => 0.02;\n    # OUTPUT: «mix(butter(0.22), sugar(0.12))␤»\n\nNote: be sure you aren't accidentally passing the Pairs as positional\narguments; the quotes around the keys in the above example are\nsignificant.","grab\n\nDefined as:\n\n    multi method grab(Baggy:D: --> Any)\n    multi method grab(Baggy:D: $count --> Seq:D)\n\nLike pick, a grab returns a random selection of elements, weighted by the\nvalues corresponding to each key. Unlike pick, it works only on mutable\nstructures, e.g. BagHash. Use of grab on an immutable structure results in\nan X::Immutable exception. If * is passed as $count, or $count is greater\nthan or equal to the total of the invocant, then total elements from the\ninvocant are returned in a random sequence; i.e. they are returned\nshuffled.\n\nGrabbing decrements the grabbed key's weight by one (deleting the key when\nit reaches 0). By definition, the total of the invocant also decreases by\none, so the probabilities stay consistent through subsequent grab\noperations.\n\n    my $cars = ('Ford' => 2, 'Rover' => 3).BagHash;\n    say $cars.grab;                                   # OUTPUT: «Ford␤»\n    say $cars.grab(2);                                # OUTPUT: «(Rover Rover)␤»\n    say $cars.grab(*);                                # OUTPUT: «(Rover Ford)␤»\n\n    my $breakfast = ('eggs' => 2, 'bacon' => 3).Bag;\n    say $breakfast.grab;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Immutable: Cannot call 'grab' on an immutable 'Bag'␤»","grabpairs\n\nDefined as:\n\n    multi method grabpairs(Baggy:D: --> Any)\n    multi method grabpairs(Baggy:D: $count --> Seq:D)\n\nReturns a Pair or a Seq of Pairs depending on the version of the method\nbeing invoked. Each Pair returned has an element of the invocant as its key\nand the elements weight as its value. Unlike pickpairs, it works only on\nmutable structures, e.g. BagHash. Use of grabpairs on 'an immutable\nstructure results in an X::Immutable exception. If * is passed as $count,\nor $count is greater than or equal to the number of elements of the\ninvocant, then all element/weight Pairs from the invocant are returned in a\nrandom sequence.\n\nWhat makes grabpairs different from pickpairs is that the 'grabbed'\nelements are in fact removed from the invocant.\n\n    my $breakfast = (eggs => 2, bacon => 3).BagHash;\n    say $breakfast.grabpairs;                         # OUTPUT: «bacon => 3␤»\n    say $breakfast;                                   # OUTPUT: «BagHash.new(eggs(2))␤»\n    say $breakfast.grabpairs(1);                      # OUTPUT: «(eggs => 2)␤»\n    say $breakfast.grabpairs(*);                      # OUTPUT: «()␤»\n\n    my $diet = ('eggs' => 2, 'bacon' => 3).Bag;\n    say $diet.grabpairs;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Immutable: Cannot call 'grabpairs' on an immutable 'Bag'␤»","pick\n\nDefined as:\n\n    multi method pick(Baggy:D: --> Any)\n    multi method pick(Baggy:D: $count --> Seq:D)\n\nLike an ordinary list pick, but returns keys of the invocant weighted by\ntheir values, as if the keys were replicated the number of times indicated\nby the corresponding value and then list pick used. The underlying metaphor\nfor picking is that you're pulling colored marbles out a bag. (For \"picking\nwith replacement\" see roll instead). If * is passed as $count, or $count is\ngreater than or equal to the total of the invocant, then total elements\nfrom the invocant are returned in a random sequence.\n\nNote that each pick invocation maintains its own private state and has no\neffect on subsequent pick invocations.\n\n    my $breakfast = bag <eggs bacon bacon bacon>;\n    say $breakfast.pick;                              # OUTPUT: «eggs␤»\n    say $breakfast.pick(2);                           # OUTPUT: «(eggs bacon)␤»\n\n    say $breakfast.total;                             # OUTPUT: «4␤»\n    say $breakfast.pick(*);                           # OUTPUT: «(bacon bacon bacon eggs)␤»","pickpairs\n\nDefined as:\n\n    multi method pickpairs(Baggy:D: --> Pair:D)\n    multi method pickpairs(Baggy:D: $count --> Seq:D)\n\nReturns a Pair or a Seq of Pairs depending on the version of the method\nbeing invoked. Each Pair returned has an element of the invocant as its key\nand the elements weight as its value. The elements are 'picked' without\nreplacement. If * is passed as $count, or $count is greater than or equal\nto the number of elements of the invocant, then all element/weight Pairs\nfrom the invocant are returned in a random sequence.\n\nNote that each pickpairs invocation maintains its own private state and has\nno effect on subsequent pickpairs invocations.\n\n    my $breakfast = bag <eggs bacon bacon bacon>;\n    say $breakfast.pickpairs;                         # OUTPUT: «eggs => 1␤»\n    say $breakfast.pickpairs(1);                      # OUTPUT: «(bacon => 3)␤»\n    say $breakfast.pickpairs(*);                      # OUTPUT: «(eggs => 1 bacon => 3)␤»","roll\n\nDefined as:\n\n    multi method roll(Baggy:D: --> Any:D)\n    multi method roll(Baggy:D: $count --> Seq:D)\n\nLike an ordinary list roll, but returns keys of the invocant weighted by\ntheir values, as if the keys were replicated the number of times indicated\nby the corresponding value and then list roll used. The underlying metaphor\nfor rolling is that you're throwing $count dice that are independent of\neach other, which (in bag terms) is equivalent to picking a colored marble\nout your bag and then putting it back, and doing this $count times. In dice\nterms, the number of marbles corresponds to the number of sides, and the\nnumber of marbles of the same color corresponds to the number of sides with\nthe same color. (For \"picking without replacement\" see pick instead).\n\nIf * is passed to $count, returns a lazy, infinite sequence of randomly\nchosen elements from the invocant.\n\n    my $breakfast = bag <eggs bacon bacon bacon>;\n    say $breakfast.roll;                                  # OUTPUT: «bacon␤»\n    say $breakfast.roll(3);                               # OUTPUT: «(bacon eggs bacon)␤»\n\n    my $random_dishes := $breakfast.roll(*);\n    say $random_dishes[^5];                               # OUTPUT: «(bacon eggs bacon bacon bacon)␤»","pairs\n\nDefined as:\n\n    method pairs(Baggy:D: --> Seq:D)\n\nReturns all elements and their respective weights as a Seq of Pairs where\nthe key is the element itself and the value is the weight of that element.\n\n    my $breakfast = bag <bacon eggs bacon>;\n    my $seq = $breakfast.pairs;\n    say $seq.sort;                                    # OUTPUT: «(bacon => 2 eggs => 1)␤»","antipairs\n\nDefined as:\n\n    method antipairs(Baggy:D: --> Seq:D)\n\nReturns all elements and their respective weights as a Seq of Pairs, where\nthe element itself is the value and the weight of that element is the key,\ni.e. the opposite of method pairs.\n\n    my $breakfast = bag <bacon eggs bacon>;\n    my $seq = $breakfast.antipairs;\n    say $seq.sort;                                    # OUTPUT: «(1 => eggs 2 => bacon)␤»","invert\n\nDefined as:\n\n    method invert(Baggy:D: --> Seq:D)\n\nReturns all elements and their respective weights as a Seq of Pairs, where\nthe element itself is the value and the weight of that element is the key,\ni.e. the opposite of method pairs. Except for some esoteric cases invert on\na Baggy type returns the same result as antipairs.\n\n    my $breakfast = bag <bacon eggs bacon>;\n    my $seq = $breakfast.invert;\n    say $seq.sort;                                    # OUTPUT: «(1 => eggs 2 => bacon)␤»","classify-list\n\nDefined as:\n\n    multi method classify-list(&mapper, *@list --> Baggy:D)\n    multi method classify-list(%mapper, *@list --> Baggy:D)\n    multi method classify-list(@mapper, *@list --> Baggy:D)\n\nPopulates a mutable Baggy by classifying the possibly-empty @list of values\nusing the given mapper. The @list cannot be lazy.\n\n    say BagHash.new.classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: BagHash.new(even(5), odd(5))\n\n    my @mapper = <zero one two three four five>;\n    say MixHash.new.classify-list: @mapper, 1, 2, 3, 4, 4, 6;\n    # OUTPUT: MixHash.new((Any), two, three, four(2), one)\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\nThe mapper's value is used as the key of the Baggy that will be incremented\nby 1. See .categorize-list if you wish to classify an item into multiple\ncategories at once.\n\nNote: unlike the Hash's .classify-list, returning an Iterable mapper's\nvalue will throw, as Baggy types do not support nested classification. For\nthe same reason, Baggy's .classify-list does not accept :&as parameter.","categorize-list\n\nDefined as:\n\n    multi method categorize-list(&mapper, *@list --> Baggy:D)\n    multi method categorize-list(%mapper, *@list --> Baggy:D)\n    multi method categorize-list(@mapper, *@list --> Baggy:D)\n\nPopulates a mutable Baggy by categorizing the possibly-empty @list of\nvalues using the given mapper. The @list cannot be lazy.\n\n    say BagHash.new.categorize-list: {\n        gather {\n            take 'largish' if $_ > 5;\n            take .is-prime ?? 'prime' !! 'non-prime';\n            take $_ %% 2   ?? 'even'  !! 'odd';\n        }\n    }, ^10;\n    # OUTPUT: BagHash.new(largish(4), even(5), non-prime(6), prime(4), odd(5))\n\n    my %mapper = :sugar<sweet white>, :lemon<sour>, :cake('sweet', 'is a lie');\n    say MixHash.new.categorize-list: %mapper, <sugar lemon cake>;\n    # OUTPUT: MixHash.new(is a lie, sour, white, sweet(2))\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\nThe mapper's value is used as a possibly-empty list of keys of the Baggy\nthat will be incremented by 1.\n\nNote: unlike the Hash's .categorize-list, returning a list of Iterables as\nmapper's value will throw, as Baggy types do not support nested\ncategorization. For the same reason, Baggy's .categorize-list does not\naccept :&as parameter.","keys\n\nDefined as:\n\n    method keys(Baggy:D: --> Seq:D)\n\nReturns a Seq of all keys in the Baggy object without taking their\nindividual weights into account as opposed to kxxv.\n\n    my $breakfast = bag <eggs spam spam spam>;\n    say $breakfast.keys.sort;                        # OUTPUT: «(eggs spam)␤»\n\n    my $n = (\"a\" => 5, \"b\" => 2).BagHash;\n    say $n.keys.sort;                                # OUTPUT: «(a b)␤»","values\n\nDefined as:\n\n    method values(Baggy:D: --> Seq:D)\n\nReturns a Seq of all values, i.e. weights, in the Baggy object.\n\n    my $breakfast = bag <eggs spam spam spam>;\n    say $breakfast.values.sort;                      # OUTPUT: «(1 3)␤»\n\n    my $n = (\"a\" => 5, \"b\" => 2, \"a\" => 1).BagHash;\n    say $n.values.sort;                              # OUTPUT: «(2 6)␤»","kv\n\nDefined as:\n\n    method kv(Baggy:D: --> Seq:D)\n\nReturns a Seq of keys and values interleaved.\n\n    my $breakfast = bag <eggs spam spam spam>;\n    say $breakfast.kv;                                # OUTPUT: «(spam 3 eggs 1)␤»\n\n    my $n = (\"a\" => 5, \"b\" => 2, \"a\" => 1).BagHash;\n    say $n.kv;                                        # OUTPUT: «(a 6 b 2)␤»","kxxv\n\nDefined as:\n\n    method kxxv(Baggy:D: --> Seq:D)\n\nReturns a Seq of the keys of the invocant, with each key multiplied by its\nweight. Note that kxxv only works for Baggy types which have integer\nweights, i.e. Bag and BagHash.\n\n    my $breakfast = bag <spam eggs spam spam bacon>;\n    say $breakfast.kxxv.sort;                         # OUTPUT: «(bacon eggs spam spam spam)␤»\n\n    my $n = (\"a\" => 0, \"b\" => 1, \"b\" => 2).BagHash;\n    say $n.kxxv;                                      # OUTPUT: «(b b b)␤»","elems\n\nDefined as:\n\n    method elems(Baggy:D: --> Int:D)\n\nReturns the number of elements in the Baggy object without taking the\nindividual elements weight into account.\n\n    my $breakfast = bag <eggs spam spam spam>;\n    say $breakfast.elems;                             # OUTPUT: «2␤»\n\n    my $n = (\"b\" => 9.4, \"b\" => 2).MixHash;\n    say $n.elems;                                     # OUTPUT: «1␤»","total\n\nDefined as:\n\n    method total(Baggy:D:)\n\nReturns the sum of weights for all elements in the Baggy object.\n\n    my $breakfast = bag <eggs spam spam bacon>;\n    say $breakfast.total;                             # OUTPUT: «4␤»\n\n    my $n = (\"a\" => 5, \"b\" => 1, \"b\" => 2).BagHash;\n    say $n.total;                                     # OUTPUT: «8␤»","default\n\nDefined as:\n\n    method default(Baggy:D: --> Int:D)\n\nReturns zero.\n\n    my $breakfast = bag <eggs bacon>;\n    say $breakfast.default;                           # OUTPUT: «0␤»","hash\n\nDefined as:\n\n    method hash(Baggy:D: --> Hash:D)\n\nReturns a Hash where the elements of the invocant are the keys and their\nrespective weights the values.\n\n    my $breakfast = bag <eggs bacon bacon>;\n    my $h = $breakfast.hash;\n    say $h.^name;                    # OUTPUT: «Hash[Any,Any]␤»\n    say $h;                          # OUTPUT: «{bacon => 2, eggs => 1}␤»","Bool\n\nDefined as:\n\n    method Bool(Baggy:D: --> Bool:D)\n\nReturns True if the invocant contains at least one element.\n\n    my $breakfast = ('eggs' => 1).BagHash;\n    say $breakfast.Bool;                              # OUTPUT: «True   (since we have one element)␤»\n    $breakfast<eggs> = 0;                             # weight == 0 will lead to element removal\n    say $breakfast.Bool;                              # OUTPUT: «False␤»","Set\n\nDefined as:\n\n    method Set(--> Set:D)\n\nReturns a Set whose elements are the keys of the invocant.\n\n    my $breakfast = (eggs => 2, bacon => 3).BagHash;\n    say $breakfast.Set;                               # OUTPUT: «set(bacon, eggs)␤»","SetHash\n\nDefined as:\n\n    method SetHash(--> SetHash:D)\n\nReturns a SetHash whose elements are the keys of the invocant.\n\n    my $breakfast = (eggs => 2, bacon => 3).BagHash;\n    my $sh = $breakfast.SetHash;\n    say $sh.^name;                            # OUTPUT: «SetHash␤»\n    say $sh.elems;                            # OUTPUT: «2␤»","ACCEPTS\n\nDefined as:\n\n    method ACCEPTS($other --> Bool:D)\n\nUsed in smartmatching if the right-hand side is a Baggy.\n\nIf the right-hand side is the type object, i.e. Baggy, the method returns\nTrue if $other does Baggy otherwise False is returned.\n\nIf the right-hand side is a Baggy object, True is returned only if $other\nhas the same elements, with the same weights, as the invocant.\n\n    my $breakfast = bag <eggs bacon>;\n    say $breakfast ~~ Baggy;                            # OUTPUT: «True␤»\n    say $breakfast.does(Baggy);                         # OUTPUT: «True␤»\n\n    my $second-breakfast = (eggs => 1, bacon => 1).Mix;\n    say $breakfast ~~ $second-breakfast;                # OUTPUT: «True␤»\n\n    my $third-breakfast = (eggs => 1, bacon => 2).Bag;\n    say $second-breakfast ~~ $third-breakfast;          # OUTPUT: «False␤»\n\nSee Also\n\nSets, Bags, and Mixes"],"desc":"TITLE\nrole Baggy\n\nSUBTITLE\nCollection of distinct weighted objects\n\n    role Baggy does QuantHash { }\n\nA role for collections of weighted objects. See Bag, BagHash, and Mixy.\n\n"},{"name":"Regex","desc":"TITLE\nclass Regex\n\nSUBTITLE\nString pattern\n\n    class Regex is Method { }\n\nA regex is a kind of pattern that describes a set of strings. The process\nof finding out whether a given string is in the set is called matching. The\nresult of such a matching is a Match object, which evaluates to True in\nboolean context if the string is in the set.\n\nA regex is typically constructed by a regex literal\n\n    rx/ ^ab /;      # describes all strings starting with 'ab'\n    / ^ ab /;       # same\n    rx/ \\d ** 2/;   # describes all strings containing at least two digits\n\n A named regex can be defined with the regex declarator followed by its\ndefinition in curly braces. Since any regex does Callable introspection\nrequires referencing via &-sigil.\n\n    my regex R { \\N };\n    say &R.^name; # OUTPUT: «Regex␤»\n\nTo match a string against a regex, you can use the smartmatch operator:\n\n    my $match = 'abc' ~~ rx/ ^ab /;\n    say $match.Bool;                # OUTPUT: «True␤»\n    say $match.orig;                # OUTPUT: «abc␤»\n    say $match.Str;                 # OUTPUT: «ab␤»\n    say $match.from;                # OUTPUT: «0␤»\n    say $match.to;                  # OUTPUT: «2␤»\n\nOr you can evaluate the regex in boolean context, in which case it matches\nagainst the $_ variable\n\n    $_ = 'abc';\n    if / ^ab / {\n        say '\"abc\" begins with \"ab\"';\n    }\n    else {\n        say 'This is a weird alternative Universe';\n    }\n\n","methods":["ACCEPTS\n\n    multi method ACCEPTS(Regex:D: Mu --> Match:D)\n    multi method ACCEPTS(Regex:D: @)\n    multi method ACCEPTS(Regex:D: %)\n\nMatches the regex against the argument passed in. If the argument is\nPositional, it returns the first successful match of any list item. If the\nargument is Associative, it returns the first successful match of any key.\nOtherwise it interprets the argument as a Str and matches against it.\n\nIn the case of Positional and Associative matches, Nil is returned on\nfailure.","Bool\n\n    multi method Bool(Regex:D: --> Bool:D)\n\nMatches against the caller's $_ variable, and returns True for a match or\nFalse for no match."]},{"desc":"TITLE\nclass CompUnit\n\nSUBTITLE\nCompUnit\n\n    class CompUnit {}\n\nThe CompUnit represents the metainformation about a compilation unit. This\nusually relates to source code that resides in a file on a filesystem,\nrather than code that is executed using an EVAL statement.\n\n","methods":["auth\n\n    method auth(--> Str:D)\n\nReturns the authority information with which the CompUnit object was\ncreated (if any).","distribution\n\n    method distribution(--> Distribution:D)\n\nReturns the Distribution object with which the CompUnit object was created\n(if any).","from\n\n    method from(--> Str:D)\n\nReturns the name of the language with which the CompUnit object was created\n(if any). It will be Perl6 by default.","precompiled\n\n    method precompiled(--> Bool:D)\n\nReturns whether the CompUnit object originated from a precompiled source.","repo\n\n    method repo(--> CompUnit::Repository:D)\n\nReturns the CompUnit::Repository object with which the CompUnit object was\ncreated.","repo-id\n\n    method repo-id(--> Str:D)\n\nReturns the identification string with which the CompUnit object can be\nidentified in the associated repo.","short-name\n\n    method short-name(--> Str:D)\n\nReturns The short name with which the CompUnit object was created (if\nany).","version\n\n    method version(--> Version:D)\n\nReturns the version information with which the CompUnit object was created\n(if any)."],"name":"CompUnit"},{"desc":"TITLE\nclass ObjAt\n\nSUBTITLE\nUnique identification for an object\n\n    class ObjAt is Any {}\n\nObjects of type ObjAt are the return value of .WHICH calls on other\nobjects, and identify an object uniquely.\n\nIf two objects compare equally via ===, their .WHICH methods return the\nsame ObjAt object.\n\nSee also ValueObjAt for value types.\n\n","methods":["infix eqv\n\nDefined as:\n\n    multi sub infix:<eqv>(ObjAt:D $a, ObjAt:D $b)\n\nReturns True if the two ObjAt are the same, that is, if the object they\nidentify is the same.\n\n    my @foo = [2,3,1];\n    my @bar := @foo;\n    say @foo.WHICH eqv @bar.WHICH; # OUTPUT: «True␤»"],"name":"ObjAt"},{"methods":[],"desc":"TITLE\nclass utf8\n\nSUBTITLE\nMutable uint8 buffer for utf8 binary data\n\n    class utf8 does Blob[uint8] is repr('VMArray') {}\n\nA utf8 is a subtype of Blob which is specifically uint8 data for holding\nUTF-8 encoded text.\n\n    my utf8 $b = \"hello\".encode;\n    say $b[1].fmt(\"0x%X\"); # OUTPUT: «0x65␤»","name":"utf8"},{"name":"BagHash","desc":"TITLE\nclass BagHash\n\nSUBTITLE\nMutable collection of distinct objects with integer weights\n\n    class BagHash does Baggy { }\n\nA BagHash is a mutable bag/multiset, meaning a collection of distinct\nelements in no particular order that each have an integer weight assigned\nto them signifying how many copies of that element are considered \"in the\nbag\". (For immutable bags, see Bag instead.)\n\nObjects/values of any type are allowed as bag elements. Within a BagHash,\nitems that would compare positively with the === operator are considered\nthe same element, with the number of how many there were as its weight. But\nof course you can also easily get back the expanded list of items (without\nthe order):\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n\n    say $breakfast.elems;      # OUTPUT: «3␤»\n    say $breakfast.keys.sort;  # OUTPUT: «bacon eggs spam␤»\n\n    say $breakfast.total;      # OUTPUT: «6␤»\n    say $breakfast.kxxv.sort;  # OUTPUT: «bacon eggs spam spam spam spam␤»\n\n\nBagHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding integer weight for keys that are\nelements of the bag, and 0 for keys that aren't. It can also be used to\nmodify weights; setting a weight to 0 automatically removes that element\nfrom the bag, and setting a weight to a positive number adds that element\nif it didn't already exist:\n\n    my $breakfast = <spam eggs spam spam bacon spam>.BagHash;\n    say $breakfast<bacon>;     # OUTPUT: «1␤»\n    say $breakfast<spam>;      # OUTPUT: «4␤»\n    say $breakfast<sausage>;   # OUTPUT: «0␤»\n\n    $breakfast<sausage> = 2;\n    $breakfast<bacon>--;\n    say $breakfast.kxxv.sort;  # OUTPUT: «eggs sausage sausage spam spam spam spam␤»\n\n\nCreating BagHash objects\n\nBagHashes can be composed using BagHash.new. Any positional parameters,\nregardless of their type, become elements of the bag:\n\n    my $n = BagHash.new: \"a\", \"b\", \"c\", \"c\";\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"a\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 1, 2).Seq␤»\n\nBesides, BagHash.new-from-pairs can create a BagHash with items and their\noccurrences.\n\n    my $n = BagHash.new-from-pairs: \"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2;\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n    say $n.keys.perl;        # OUTPUT: «(\"b\", \"c\").Seq␤»\n    say $n.values.perl;      # OUTPUT: «(1, 4).Seq␤»\n\nAlternatively, the .BagHash coercer (or its functional form, BagHash()) can\nbe called on an existing object to coerce it to a BagHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a bag with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the bag, and the (cumulative) values become the\nassociated integer weights:\n\n    my $m = (\"a\", \"b\", \"c\", \"c\").BagHash;\n    my $n = (\"a\" => 0, \"b\" => 1, \"c\" => 2, \"c\" => 2).BagHash;\n    say $m.perl;             # OUTPUT: «(\"b\"=>1,\"a\"=>1,\"c\"=>2).BagHash␤»\n    say $n.perl;             # OUTPUT: «(\"b\"=>1,\"c\"=>4).BagHash␤»\n\nYou can also create BagHash masquerading as a hash by using the is trait:\n\n    my %bh is BagHash = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a BagHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = BagHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %bh is BagHash[Str] = <a b b c c c>;\n    say %bh<b>;  # 2\n    say %bh<d>;  # 0\n\n    # only allow whole numbers\n    my %bh is BagHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\nRaku provides common set and bag operators, which can take BagHashes (or\nany other collections) as input, and return result as Bool, Set or Bag\nvalues. For example:\n\n    my ($a, $b) = BagHash.new(2, 2, 4), BagHash.new(2, 3, 3, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Bag(3(2), 2)␤»\n    say $a (+) $b;   # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Bag(3(2), 2)␤»\n    say $a ⊎ $b;  # OUTPUT: «Bag(2(3), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nBagHash inherits reverse from Any, however, Bags do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a BagHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = BagHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «BagHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\nSee Also\n\nSets, Bags, and Mixes","methods":[]},{"desc":"TITLE\nclass Semaphore\n\nSUBTITLE\nControl access to shared resources by multiple threads\n\n    class Semaphore { }\n\nProtect your shared code, data or device access using semaphores. An\nexample is a printer manager managing a pool of printers without the need\nof storing print jobs when all printers are occupied. The next job is just\nblocked until a printer becomes available.\n\n    class print-manager {\n      has Array $!printers;\n      has Semaphore $!print-control;\n\n      method BUILD( Int:D :$nbr-printers ) {\n        for ^$nbr-printers -> $pc {\n          $!printers[$pc] = { :name{\"printer-$pc\"} };\n        }\n\n        $!print-control .= new($nbr-printers);\n      }\n\n      method find-available-printer-and-print-it($job) { say \"Is printed!\"; }\n\n      method print( $print-job ) {\n        $!print-control.acquire;\n\n        self.find-available-printer-and-print-it($print-job);\n\n        $!print-control.release;\n      }\n    }\n\nAnother example is a protection around code updating sensitive data. In\nsuch a case the semaphore is typically initialized to 1.\n\nIt is important to have a release on every exit of your program! While this\nis obvious, it is easy to fall in traps such as throwing an exception\ncaused by some event. When the program dies there is no problem. When the\nexception is caught your program might eventually come back to the acquire\nmethod and will hang indefinitely.\n\n","methods":["new\n\n    method new( int $permits )\n\nInitialize the semaphore with the number of permitted accesses. E.g. when\nset to 2, program threads can pass the acquire method twice until it blocks\non the third time acquire is called.","acquire\n\n    method acquire()\n\nAcquire access. When other threads have called the method before and the\nnumber of permits are used up, the process blocks until threads passed\nbefore releases the semaphore.","try_acquire\n\n    method try_acquire(--> Bool)\n\nSame as acquire but will not block. Instead it returns True if access is\npermitted or False otherwise.","release\n\n    method release()\n\nRelease the semaphore raising the number of permissions. Any blocked thread\nwill get access after that."],"name":"Semaphore"},{"name":"atomicint","methods":[],"desc":"TITLE\nclass atomicint\n\nSUBTITLE\nInteger (native storage at the platform's atomic operation size)\n\n    class atomicint is Int is repr('P6int') { }\n\nAn atomicint is a native integer sized such that CPU-provided atomic\noperations can be performed upon it. On a 32-bit CPU it will typically be\n32 bits in size, and on an a 64-bit CPU it will typically be 64 bits in\nsize. It exists to allow writing portable code that uses atomic\noperations.\n\nNote: Rakudo releases before 2017.08 had no support for atomicints.\n\n    # Would typically only work on a 64-bit machine and VM build.\n    my int64 $active = 0;\n    $active⚛++;\n\n    # Would typically only work on a 32-bit machine and VM build.\n    my int32 $active = 0;\n    $active⚛++;\n\n    # Will work portably, though can only portably assume range of 32 bits.\n    my atomicint $active = 0;\n    $active⚛++;\n\nThe use of the atomicint type does not automatically provide atomicity; it\nmust be used in conjunction with the atomic operations.\n\n    # Correct (will always output 80000)\n    my atomicint $total = 0;\n    await start { for ^20000 { $total⚛++ } } xx 4;\n    say $total;\n\n    # *** WRONG *** due to lack of use of the atomicint type.\n    # Either works correctly or dies, depending on platform.\n    my int $total = 0;\n    await start { for ^20000 { $total⚛++ } } xx 4;\n    say $total;\n\n    # *** WRONG *** due to lack of use of the atomic increment operator.\n    my atomicint $total = 0;\n    await start { for ^20000 { $total++ } } xx 4;\n    say $total;\n\nRoutines\n\n  sub atomic-assign\n\nDefined as:\n\n    multi sub atomic-assign(atomicint $ is rw, int $value)\n    multi sub atomic-assign(atomicint $ is rw, Int() $value)\n\nPerforms an atomic assignment to a native integer, which may be in a\nlexical, attribute, or native array element. If $value cannot unbox to a\n64-bit native integer due to being too large, an exception will be thrown.\nIf the size of atomicint is only 32 bits, then an out of range $value will\nbe silently truncated. The atomic-assign routine ensures that any required\nbarriers are performed such that the changed value will be \"published\" to\nother threads.\n\n  sub atomic-fetch\n\nDefined as:\n\n    multi sub atomic-fetch(atomicint $ is rw)\n\nPerforms an atomic read of a native integer, which may live in a lexical,\nattribute, or native array element. Using this routine instead of simply\nusing the variable ensures that the latest update to the variable from\nother threads will be seen, both by doing any required hardware barriers\nand also preventing the compiler from lifting reads. For example:\n\n    my atomicint $i = 0;\n    start { atomic-assign($i, 1) }\n    while atomic-fetch($i) == 0 { }\n\nIs certain to terminate, while in:\n\n    my atomicint $i = 0;\n    start { atomic-assign($i, 1) }\n    while $i == 0 { }\n\nIt would be legal for a compiler to observe that $i is not updated in the\nloop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  sub atomic-fetch-inc\n\nDefined as:\n\n    multi sub atomic-fetch-inc(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore incrementing it. Overflow will wrap around silently.\n\n  sub atomic-fetch-dec\n\nDefined as:\n\n    multi sub atomic-fetch-dec(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore decrementing it. Overflow will wrap around silently.\n\n  sub atomic-fetch-add\n\nDefined as:\n\n    multi sub atomic-fetch-add(atomicint $ is rw, int $value)\n    multi sub atomic-fetch-add(atomicint $ is rw, Int() $value)\n\nPerforms an atomic addition on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore the addition was performed. Overflow will wrap around silently. If\n$value is too big to unbox to a 64-bit integer, an exception will be\nthrown. If $value otherwise overflows atomicint then it will be silently\ntruncated before the addition is performed.\n\n  sub atomic-fetch-sub\n\nDefined as:\n\n    multi sub atomic-fetch-sub(atomicint $ is rw, int $value)\n    multi sub atomic-fetch-sub(atomicint $ is rw, Int() $value)\n\nPerforms an atomic subtraction on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore the subtraction was performed. Underflow will wrap around silently.\nIf $value is too big to unbox to a 64-bit integer, an exception will be\nthrown. If $value otherwise overflows atomicint then it will be silently\ntruncated before the subtraction is performed.\n\n  sub atomic-inc-fetch\n\n    multi sub atomic-inc-fetch(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the increment. Overflow will wrap around silently.\n\n  sub atomic-dec-fetch\n\n    multi sub atomic-dec-fetch(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the decrement. Overflow will wrap around silently.\n\n  sub cas\n\nDefined as:\n\n    multi sub cas(atomicint $target is rw, int $expected, int $value)\n    multi sub cas(atomicint $target is rw, Int() $expected, Int() $value)\n    multi sub cas(atomicint $target is rw, &operation)\n\nPerforms an atomic compare and swap of the native integer value in location\n$target. The first two forms have semantics like:\n\n    my int $seen = $target;\n    if $seen == $expected {\n        $target = $value;\n    }\n    return $seen;\n\n\nExcept it is performed as a single hardware-supported atomic instruction,\nas if all memory access to $target were blocked while it took place.\nTherefore it is safe to attempt the operation from multiple threads without\nany other synchronization. For example:\n\n    my atomicint $master = 0;\n    await start {\n        if cas($master, 0, 1) == 0 {\n            say \"Master!\"\n        }\n    } xx 4\n\nWill reliably only ever print Master! one time, as only one of the threads\nwill be successful in changing the 0 into a 1.\n\nBoth $expected and $value will be coerced to Int and unboxed if needed. An\nexception will be thrown if the value cannot be represented as a 64-bit\ninteger. If the size of atomicint is only 32 bits then the values will be\nsilently truncated to this size.\n\nThe third form, taking a code object, will first do an atomic fetch of the\ncurrent value and invoke the code object with it. It will then try to do an\natomic compare and swap of the target, using the value passed to the code\nobject as $expected and the result of the code object as $value. If this\nfails, it will read the latest value, and retry, until a CAS operation\nsucceeds. Therefore, an atomic multiply of an atomicint $i by 2 could be\nimplemented as:\n\n    cas $i, -> int $current { $current * 2 }\n\n\nIf another thread changed the value while $current * 2 was being calculated\nthen the block would be called again with the latest value for a further\nattempt, and this would be repeated until success.\n\nOperators\n\n  infix ⚛=\n\n    multi sub infix:<⚛=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic assignment to a native integer, which may be in a\nlexical, attribute, or native array element. If $value cannot unbox to a\n64-bit native integer due to being too large, an exception will be thrown.\nIf the size of atomicint is only 32 bits, then an out of range $value will\nbe silently truncated. The ⚛= operator ensures that any required barriers\nare performed such that the changed value will be \"published\" to other\nthreads.\n\n  prefix ⚛\n\n    multi sub prefix:<⚛>(atomicint $ is rw)\n\nPerforms an atomic read of a native integer, which may live in a lexical,\nattribute, or native array element. Using this operator instead of simply\nusing the variable ensures that the latest update to the variable from\nother threads will be seen, both by doing any required hardware barriers\nand also preventing the compiler from lifting reads. For example:\n\n    my atomicint $i = 0;\n    start { $i ⚛= 1 }\n    while ⚛$i == 0 { }\n\nIs certain to terminate, while in:\n\n    my atomicint $i = 0;\n    start { $i ⚛= 1 }\n    while $i == 0 { }\n\nIt would be legal for a compiler to observe that $i is not updated in the\nloop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  prefix ++⚛\n\n    multi sub prefix:<++⚛>(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the increment. Overflow will wrap around silently.\n\n  postfix ⚛++\n\n    multi sub postfix:<⚛++>(atomicint $ is rw)\n\nPerforms an atomic increment on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore incrementing it. Overflow will wrap around silently.\n\n  prefix --⚛\n\n    multi sub prefix:<--⚛>(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value resulting\nfrom the decrement. Overflow will wrap around silently.\n\n  postfix ⚛--\n\n    multi sub postfix:<⚛-->(atomicint $ is rw)\n\nPerforms an atomic decrement on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Returns the value as seen\nbefore decrementing it. Overflow will wrap around silently.\n\n  infix ⚛+=\n\nDefined as:\n\n    multi sub infix:<⚛+=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛+=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic addition on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Evaluates to the result of the\naddition. Overflow will wrap around silently. If $value is too big to unbox\nto a 64-bit integer, an exception will be thrown. If $value otherwise\noverflows atomicint then it will be silently truncated before the addition\nis performed.\n\n  infix ⚛-=\n\nDefined as:\n\n    multi sub infix:<⚛-=>(atomicint $ is rw, int $value)\n    multi sub infix:<⚛-=>(atomicint $ is rw, Int() $value)\n\nPerforms an atomic subtraction on a native integer. This will be performed\nusing hardware-provided atomic operations. Since the operation is atomic,\nit is safe to use without acquiring a lock. Evaluates to the result of the\nsubtraction. Underflow will wrap around silently. If $value is too big to\nunbox to a 64-bit integer, an exception will be thrown. If $value otherwise\noverflows atomicint then it will be silently truncated before the\nsubtraction is performed.\n\n  infix ⚛−=\n\nSynonym for ⚛-= using U+2212 minus."},{"desc":"TITLE\nenum Bool\n\nSUBTITLE\nLogical boolean\n\n    enum Bool <False True>\n\n   An enum for boolean true/false decisions.\n\n","methods":["ACCEPTS\n\n    method ACCEPTS(Bool:D: --> Bool:D)\n\nUsed for smartmatch comparison. When the right side is True returns always\nTrue, when the right side of the match is False returns always False. In\nparticular, ACCEPTS returns always the instance on which it is invoked,\nthat is the right side of a smartmatch. As an example:\n\n    my $b = Bool.new( True );\n    # when True on the right side returns\n    # always True\n    True  ~~ $b;     # True\n    False ~~ $b;     # True\n\n    $b = Bool.new( False );\n    # when False on the right side\n    # returns always False\n    False ~~ $b;     # False\n    True ~~ $b;      # False","succ\n\n    method succ(--> Bool:D)\n\nReturns True.\n\n    say True.succ;                                    # OUTPUT: «True␤»\n    say False.succ;                                   # OUTPUT: «True␤»\n\nsucc is short for \"successor\"; it returns the next enum value. Bool is a\nspecial enum with only two values, False and True. When sorted, False comes\nfirst, so True is its successor. And since True is the \"highest\" Bool enum\nvalue, its own successor is also True.","pred\n\n    method pred(--> Bool:D)\n\nReturns False.\n\n    say True.pred;                                    # OUTPUT: «False␤»\n    say False.pred;                                   # OUTPUT: «False␤»\n\npred is short for \"predecessor\"; it returns the previous enum value. Bool\nis a special enum with only two values, False and True. When sorted, False\ncomes first, so False is the predecessor to True. And since False is the\n\"lowest\" Bool enum value, its own predecessor is also False.","enums\n\n    method enums(--> Hash:D)\n\nReturns a Hash of enum-pairs. Works on both the Bool type and any key.\n\n    say Bool.enums;                                   # OUTPUT: «{False => 0, True => 1}␤»\n    say False.enums;                                  # OUTPUT: «{False => 0, True => 1}␤»","pick\n\n    multi method pick(Bool:U --> Bool:D)\n    multi method pick(Bool:U $count --> Seq:D)\n\nReturns True or False if called without any argument. Otherwise returns\n$count elements chosen at random (without repetition) from the enum. If *\nis passed as $count, or $count is greater than or equal to two, then both\nelements are returned in random order.\n\n    say Bool.pick;                                    # OUTPUT: «True␤»\n    say Bool.pick(1);                                 # OUTPUT: «(False)␤»\n    say Bool.pick(*);                                 # OUTPUT: «(False True)␤»","roll\n\n    multi method roll(Bool:U --> Bool:D)\n    multi method roll(Bool:U $count --> Seq:D)\n\nReturns True or False if called without any argument. Otherwise returns\n$count elements chosen at random. Note that each random choice from the\nenum is made independently, like a separate coin toss where each side of\nthe coin represents one of the two values of the enum. If * is passed as\n$count an infinite Seq of Bools is returned.\n\n    say Bool.roll;                                    # OUTPUT: «True␤»\n    say Bool.roll(3);                                 # OUTPUT: «(True False False)␤»\n    say Bool.roll(*);                                 # OUTPUT: «(...)␤»","Int\n\n    multi method Int(Bool:D --> Int:D)\n\nReturns the value part of the enum pair.\n\n    say False.Int;                                # OUTPUT: «0␤»\n    say True.Int;                                 # OUTPUT: «1␤»","Numeric\n\n    multi method Numeric(Bool:D --> Int:D)\n\nReturns the value part of the enum pair.\n\n    say False.Numeric;                                # OUTPUT: «0␤»\n    say True.Numeric;                                 # OUTPUT: «1␤»"],"name":"Bool"},{"desc":"TITLE\nclass Proxy\n\nSUBTITLE\nItem container with custom storage and retrieval\n\n    class Proxy {}\n\nA Proxy is an object that allows you to set a hook that executes whenever a\nvalue is retrieved from a container (FETCH) or when it is set (STORE).\nPlease note that Proxy can introduce mutability at places where it would\nbreak behavior, e.g. in Hash keys.\n\nTo create a container that returns twice what was stored in it, you do\nsomething like this:\n\n    sub double() is rw {\n        my $storage = 0;\n        Proxy.new(\n            FETCH => method ()     { $storage * 2    },\n            STORE => method ($new) { $storage = $new },\n        )\n     }\n     my $doubled := double();\n     $doubled = 4;\n     say $doubled;       # OUTPUT: «8␤»\n\n","methods":["new\n\n    method new(:&FETCH!, :&STORE! --> Proxy:D)\n\nCreates a new Proxy object. &FETCH is called with one argument (the proxy\nobject) when the value is accessed, and must return the value that the\nfetch produces. &STORE is called with two arguments (the proxy object, and\nthe new value) when a new value is stored in the container."],"name":"Proxy"},{"methods":["Bridge\n\nDefined as:\n\n    method Bridge(Real:D:)\n\nDefault implementation coerces the invocant to Num and that's the behavior\nof this method in core Real types. This method primarily exist to make it\neasy to implement custom Real types by users, with the Bridge method\nreturning one of the core Real types (NOT necessarily a Num) that best\nrepresent the custom Real type. In turn, this lets all the core operators\nand methods obtain a usable value they can work with.\n\nAs an example, we can implement a custom Temperature type. It has a unit of\nmeasure and the value, which are given during instantiation. We can\nimplement custom operators or conversion methods that work with this type.\nWhen it comes to regular mathematical operators, however, we can simply use\nthe .Bridge method to convert the Temperature to Kelvin expressed in one of\nthe core numeric types:\n\n    class Temperature is Real {\n        has Str:D  $.unit  is required where any <K F C>;\n        has Real:D $.value is required;\n        method new ($value, :$unit = 'K') { self.bless :$value :$unit }\n        # Note: implementing .new() that handles $value of type Temperature is left as an exercise\n\n        method Bridge {\n            when $!unit eq 'F' { ($!value + 459.67) × 5/9 }\n            when $!unit eq 'C' {  $!value + 273.15 }\n            $!value\n        }\n        method gist { self.Str }\n        method Str  { \"$!value degrees $!unit\" }\n    }\n\n    sub postfix:<℃> { Temperature.new: $^value, :unit<C> }\n    sub postfix:<℉> { Temperature.new: $^value, :unit<F> }\n    sub postfix:<K> { Temperature.new: $^value, :unit<K> }\n\n    my $human := 36.6℃;\n    my $book  := 451℉;\n    my $sun   := 5778K;\n    say $human;                # OUTPUT: «36.6 degrees C␤»\n    say $human + $book + $sun; # OUTPUT: «6593.677777777778␤»\n    say 123K + 456K;           # OUTPUT: «579␤»\n\nAs we can see from the last two lines of the output, the type of the\nbridged result is not forced to be any particular core type. It is a Rat,\nwhen we instantiated Temperature with a Rat or when conversion was\ninvolved, and it is an Int when we instantiated Temperature with an Int.","Complex\n\n    method Complex(Real:D: --> Complex:D)\n\nConverts the number to a Complex with the number converted to a Num as its\nreal part and 0e0 as the imaginary part.","Rat\n\n    method Rat(Real:D: Real $epsilon = 1e-6)\n\nConverts the number to a Rat with the precision $epsilon.","Real\n\nDefined as:\n\n    multi method Real(Real:D: --> Real:D)\n    multi method Real(Real:U: --> Real:D)\n\nThe :D variant simply returns the invocant. The :U variant issues a warning\nabout using an uninitialized value in numeric context and then returns\nself.new.","rand\n\n    sub term:<rand> (--> Num:D)\n    method rand(Real:D: --> Real:D)\n\nReturns a pseudo-random number between zero (inclusive) and the number\n(non-inclusive). The Bridge method is used to coerce the Real to a numeric\nthat supports rand method.\n\nThe term form returns a pseudo-random Num between 0e0 (inclusive) and 1e0\n(non-inclusive.)","sign\n\n    method sign(Real:D:)\n\nReturns -1 if the number is negative, 0 if it is zero and 1 otherwise.","round\n\n    method round(Real:D: $scale = 1)\n\nRounds the number to scale $scale. If $scale is 1, rounds to an integer. If\nscale is 0.1, rounds to one digit after the comma etc.","floor\n\n    method floor(Real:D --> Int:D)\n\nReturn the largest integer not greater than the number.","ceiling\n\n    method ceiling(Real:D --> Int:D)\n\nReturns the smallest integer not less than the number.","truncate\n\n    method truncate(Real:D --> Int:D)\n\nRounds the number towards zero.","polymod\n\n    method polymod(Real:D: +@mods)\n\nReturns the remainders after applying sequentially all divisors in the\n@mods argument; the last element of the array will be the last remainder.\n\n    say (1e8+1).polymod(10 xx 8);  # OUTPUT: «(1 0 0 0 0 0 0 0 1)␤»\n\n10 xx 8 is simply an array with eight number 10s; the first division by 10\nwill return 1 as a remainder, while the rest, up to the last, will return\n0. With 8 divisors, as above, the result will have one more elements, in\nthis case for the last remainder.","base\n\n    method base(Real:D: Int:D $base where 2..36, $digits? --> Str:D)\n\nConverts the number to a string, using $base as base. For $base larger than\nten, capital Latin letters are used.\n\n    255.base(16);            # 'FF'\n\nThe optional $digits argument asks for that many digits of fraction (which\nmay not be negative). If omitted, a reasonable default is chosen based on\ntype. For Int this default is 0. For Num, the default is 8. For Rational,\nthe number of places is scaled to the size of the denominator, with a\nminimum of 6.\n\nA special value of Whatever (*) can be given as $digits, which functions\nthe same as when $digits is not specified for all Real types except the\nRationals. For Rationals, the Whatever indicates that you wish all of the\npossible digits of the fractional part, but use caution: since there's no\ndetection of repeating fractional parts (the algorithm will eventually stop\nafter generating 2**63 digits).\n\nThe final digit produced is always rounded.\n\n    say pi.base(10, 3);      # OUTPUT: «3.142␤»\n    say (1/128).base(10, *); # OUTPUT: «0.0078125␤»\n    say (1/100).base(10, *); # OUTPUT: «0.01␤»\n    say (1/3)  .base(10, *); # WRONG: endlessly repeating fractional part\n\nFor reverse operation, see parse-base"],"desc":"TITLE\nrole Real\n\nSUBTITLE\nNon-complex number\n\n    role Real does Numeric { ... }\n\nCommon role for non-Complex numbers.\n\n","name":"Real"},{"methods":[],"desc":"TITLE\nclass AST\n\nSUBTITLE\nAbstract representation of a piece of source code\n\n    class AST { }\n\nAn AST or Abstract Syntax Tree is a partially processed representation of a\nprogram. ASTs are return values of the quasi quoting construct, and are\ntypically used within macros to generate code that is inserted in the\ncalling location of the macro.\n\nThere is no API defined for ASTs yet. Hopefully that will emerge as part of\nthe work on macros.","name":"AST"},{"name":"Seq","desc":"TITLE\nclass Seq\n\nSUBTITLE\nAn iterable, lazy sequence of values\n\n    class Seq is Cool does Iterable does PositionalBindFailover { }\n\nA Seq represents anything that can lazily produce a sequence of values. A\nSeq is born in a state where iterating it will consume the values. However,\ncalling .cache on a Seq will return a List that is still lazy, but stores\nthe generated values for later access. However, assigning a Seq to an array\nconsumes the Seq; alternatively, you can use the lazy statement prefix to\navoid it from being iterated during the assignment:\n\n    # The Seq created by gather ... take is consumed on the spot here.\n    my @a = gather do { say 'consuming...'; take 'one' };  # OUTPUT: «consuming...␤»\n\n    # The Seq here is only consumed as we iterate over @a later.\n    my @a = lazy gather do { say 'consuming...'; take 'one' };  # outputs nothing.\n    .say for @a;  # OUTPUT: «consuming...␤one␤»\n\n\nA typical use case is method lines in IO::Handle, which could use a lot of\nmemory if it stored all the lines read from the file. So\n\n    for open('README.md').lines -> $line {\n        say $line;\n    }\n\n\nwon't keep all lines from the file in memory.\n\nThis implies that you cannot iterate the same Seq object twice (otherwise\nit couldn't throw away old values), so this dies:\n\n    my @a = 1, 2, 3;\n    my @b = <a b c>;\n    my \\c = @a Z=> @b;\n    .say for c;\n    .say for c; # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Seq::Consumed: This Seq has already been iterated, and its values consumed\n    # (you might solve this by adding .cache on usages of the Seq, or\n    # by assigning the Seq into an array)»\n\nA high-level construct to generate a Seq is gather/take, as well as many\nbuilt-in methods like map and grep, low-level constructors to create a Seq\nfrom an iterator or from looping constructs are available too.\n\nCaution: No program should ever assume a Seq may only be iterated once even\nif not cached by the program. Caching is a volatile state exposed to the\ndeveloper as an optimization. The Seq may become cached by many operations,\nincluding calling perl on the Seq (if called prior to a non-cached\niteration). From version 6.d, you .perl can be called on consumed <Seq>. If\na program assumes a Seq can only iterate once, but then is later changed to\ncall one of these operations during the loop, that assumption will fail.\n\n","methods":["new\n\n    method new(Iterator:D $iter --> Seq:D)\n\nCreates a new Seq object from the iterator passed as the single argument.","iterator\n\n    method iterator(Seq:D: --> Iterator:D)\n\nReturns the underlying iterator, and marks the invocant as consumed. If\ncalled on an already consumed sequence, throws an error of type\nX::Seq::Consumed.","elems\n\n    method elems(Seq:D:)\n\nIf the caller Seq is not lazy, consumes and caches its values, returning\ntheir length. Otherwise, throws an error of type X::Cannot::Lazy.","is-lazy\n\n    method is-lazy(Seq:D: --> Bool:D)\n\nReturns True if the sequence is lazy and potentially infinite, and False\notherwise. If called on an already consumed sequence, throws an error of\ntype X::Seq::Consumed.","eager\n\n    method eager(Seq:D: --> List:D)\n\nReturns an eagerly evaluated List based on the invocant sequence, and marks\nit as consumed. If called on an already consumed sequence, throws an error\nof type X::Seq::Consumed.\n\n    my $s = lazy 1..5;\n\n    say $s.is-lazy; # OUTPUT: «True␤»\n    say $s.eager;   # OUTPUT: «(1 2 3 4 5)␤»\n\n    say $s.eager;\n    CATCH {\n        when X::Seq::Consumed {\n            say 'Throws exception if already consumed';\n        }\n    }\n    # OUTPUT: «Throws exception if already consumed␤»","from-loop\n\n    multi method from-loop(&body --> Seq:D)\n    multi method from-loop(&body, &cond, :$repeat --> Seq:D)\n    multi method from-loop(&body, &cond, &afterward --> Seq:D)\n\nThese methods create new Seq-based callbacks.\n\nThe first form produces an infinite Seq by calling &body each time a new\nelement is requested, using the return value from &body as the item. This\nemulates (or implements) a loop { body } construct.\n\nThe second form calls &cond before each call to &body, and terminates the\nsequence if &cond returns a false value. If $repeat is set to a true value,\nthe first call to &cond is omitted, and &body called right away. This\nemulates (or implements) while cond { body } and repeat { body } while cond\nloops.\n\nThe third form enables C-style looping by calling a third callback,\n&afterward, after each call to &body.","sink\n\nDefined as:\n\n    method sink(--> Nil)\n\nCalls sink-all if it is an Iterator, sink if the Sequence is a list.\n\n    say (1 ... 1000).sink; # OUTPUT: «Nil␤»\n\nThis is something you might want to do for the side effects of producing\nthose values.","skip\n\nDefined as:\n\n    multi method skip(Int() $n = 1 --> Seq)\n\nReturns a Seq containing whatever is left of the invocant after throwing\naway $n of the next available values. Negative values of $n count as 0.\nAlso can take a WhateverCode to indicate how many values to skip from the\nend. Will block on lazy Seqs until the requested number of values have been\ndiscarded.\n\n    say (1..5).map({$_}).skip;      # OUTPUT: «(2,3,4,5)␤»\n    say (1..5).map({$_}).skip(3);   # OUTPUT: «(4,5)␤»\n    say (1..5).map({$_}).skip(5);   # OUTPUT: «()␤»\n    say (1..5).map({$_}).skip(-1);  # OUTPUT: «(1,2,3,4,5)␤»\n    say (1..5).map({$_}).skip(*-3); # OUTPUT: «(3,4,5)␤»"]},{"name":"Array","desc":"TITLE\nclass Array\n\nSUBTITLE\nSequence of itemized values\n\n    class Array is List {}\n\nAn Array is a List which forces all its elements to be scalar containers,\nwhich means you can assign to array elements.\n\nArray implements Positional and as such provides support for subscripts.\n\nNote from version 6.d, .perl can be called on multi-dimensional arrays.\n\n","methods":["gist\n\nExactly the same as List.gist, except using square brackets for surrounding\ndelimiters.","pop\n\nDefined as:\n\n    multi sub    pop(Array:D )\n    multi method pop(Array:D:)\n\nRemoves and returns the last item from the array. Fails for an empty\narray.\n\nExample:\n\n    my @foo = <a b>; # a b\n    @foo.pop;        # b\n    pop @foo;        # a\n    pop @foo;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Cannot::Empty: Cannot pop from an empty Array␤»","push\n\nDefined as:\n\n    multi sub    push(Array:D, **@values --> Array:D)\n    multi method push(Array:D: **@values --> Array:D)\n\nAdds the @values to the end of the array, and returns the modified array.\nThrows for lazy arrays.\n\nExample:\n\n    my @foo = <a b c>;\n    @foo.push: 'd';\n    say @foo;                   # OUTPUT: «[a b c d]␤»\n\nNote that push does not attempt to flatten its argument list. If you pass\nan array or list as the thing to push, it becomes one additional element:\n\n    my @a = <a b c>;\n    my @b = <d e f>;\n    @a.push: @b;\n    say @a.elems;               # OUTPUT: «4␤»\n    say @a[3].join;             # OUTPUT: «def␤»\n\nOnly if you supply multiple values as separate arguments to push are\nmultiple values added to the array:\n\n    my @a = '1';\n    my @b = <a b>;\n    my @c = <E F>;\n    @a.push: @b, @c;\n    say @a.elems;                # OUTPUT: «3␤»\n\nSee method append for when you want to append multiple values that are\nstored in a single array.","append\n\nDefined as\n\n    sub append(\\array, |elems)\n    multi method append(Array:D: \\values)\n    multi method append(Array:D: **@values is raw)\n\nAppends the argument list to the array passed as the first argument. This\nmodifies the array in-place. Returns the modified array. Throws for lazy\narrays.\n\nThe difference from method push is that if you append a single array or\nlist argument, append will flatten that array / list, whereas push appends\nthe list / array as just a single element.\n\nExample:\n\n    my @a = <a b c>;\n    my @b = <d e f>;\n    @a.append: @b;\n    say @a.elems;               # OUTPUT: «6␤»\n    say @a;                     # OUTPUT: «[a b c d e f]␤»","elems\n\nDefined as:\n\n    method elems(Array:D: --> Int:D)\n\nReturns the number of elements in the invocant. Throws X::Cannot::Lazy\nexception if the invocant is lazy. For shaped arrays, returns the outer\ndimension; see shape if you need information for all dimensions.\n\n    say [<foo bar ber>] .elems; # OUTPUT: «3␤»\n    say (my @a[42;3;70]).elems; # OUTPUT: «42␤»\n\n    try [-∞...∞].elems;\n    say $!.^name;               # OUTPUT: «X::Cannot::Lazy␤»","clone\n\nDefined as:\n\n    method clone(Array:D: --> Array:D)\n\nClones the original Array. Modifications of elements in the clone are not\npropagated to the original and vice-versa:\n\n    my @a = <a b c>; my @b = @a.clone;\n    @b[1] = 42; @a.push: 72;\n    say @b; # OUTPUT: «[a 42 c]␤»\n    say @a; # OUTPUT: «[a b c 72]␤»\n\nHowever, note that the reifier is shared between the two Arrays, so both\nArrays will have the same elements even when each is randomly-generated on\nreification and each element will be reified just once, regardless of\nwhether the reification was done by the clone or the original Array. Note:\njust as reifying an Array from multiple threads is not safe, so is, for\nexample, reifying the clone from one thread while reifying the original\nfrom another thread is not safe.\n\n    my @a = 1, {rand} … ∞; my @b = @a.clone;\n    say @b[^3]; # OUTPUT: «(1 0.0216426755282736 0.567660896142156)␤»\n    say @a[^3]; # OUTPUT: «(1 0.0216426755282736 0.567660896142156)␤»","shift\n\nDefined as:\n\n    multi sub    shift(Array:D )\n    multi method shift(Array:D:)\n\nRemoves and returns the first item from the array. Fails for an empty\narrays.\n\nExample:\n\n    my @foo = <a b>;\n    say @foo.shift;             # OUTPUT: «a␤»\n    say @foo.shift;             # OUTPUT: «b␤»\n    say @foo.shift;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Cannot::Empty: Cannot shift from an empty Array␤»","unshift\n\nDefined as:\n\n    multi sub    unshift(Array:D, **@values --> Array:D)\n    multi method unshift(Array:D: **@values --> Array:D)\n\nAdds the @values to the start of the array, and returns the modified array.\nFails if @values is a lazy list.\n\nExample:\n\n    my @foo = <a b c>;\n    @foo.unshift: 1, 3 ... 11;\n    say @foo;                   # OUTPUT: «[(1 3 5 7 9 11) a b c]␤»\n\nThe notes in the documentation for method push apply, regarding how many\nelements are added to the array.\n\n#method prepend is the equivalent for adding multiple elements from one\nlist or array.","prepend\n\nDefined as\n\n    sub prepend(\\array, |elems)\n    multi method prepend(Array:D: \\values)\n    multi method prepend(Array:D: **@values is raw)\n\nAdds the elements from LIST to the front of the array, modifying it\nin-place.\n\nExample:\n\n    my @foo = <a b c>;\n    @foo.prepend: 1, 3 ... 11;\n    say @foo;                   # OUTPUT: «[1 3 5 7 9 11 a b c]␤»\n\nThe difference from method unshift is that if you prepend a single array or\nlist argument, prepend will flatten that array / list, whereas unshift\nprepends the list / array as just a single element.","splice\n\nDefined as:\n\n    multi sub    splice(@list,   $start = 0, $elems?, *@replacement --> Array)\n    multi method splice(Array:D: $start = 0, $elems?, *@replacement --> Array)\n\nDeletes $elems elements starting from index $start from the Array, returns\nthem and replaces them by @replacement. If $elems is omitted or is larger\nthan the number of elements starting from $start, all the elements starting\nfrom index $start are deleted. If both $start and $elems are omitted, all\nelements are deleted from the Array and returned.\n\nEach of $start and $elems can be specified as a Whatever or as a Callable\nthat returns an int-compatible value.\n\nA Whatever $start uses the number of elements of @list (or invocant). A\nCallable $start is called with one argument—the number of elements in\n@list—and its return value is used as $start.\n\nA Whatever $elems deletes from $start to end of @list (same as no $elems).\nA Callable $elems is called with just one argument—the number of elements\nin @list minus the value of $start—and its return value is used the value\nof $elems.\n\nExample:\n\n    my @foo = <a b c d e f g>;\n    say @foo.splice(2, 3, <M N O P>);        # OUTPUT: «[c d e]␤»\n    say @foo;                                # OUTPUT: «[a b M N O P f g]␤»","shape\n\nDefined as:\n\n    method shape() { (*,) }\n\nReturns the shape of the array as a list.\n\nExample:\n\n    my @foo[2;3] = ( < 1 2 3 >, < 4 5 6 > ); # Array with fixed dimensions\n    say @foo.shape;                          # OUTPUT: «(2 3)␤»\n    my @bar = ( < 1 2 3 >, < 4 5 6 > );      # Normal array (of arrays)\n    say @bar.shape;                          # OUTPUT: «(*)␤»","default\n\nDefined as:\n\n    method default\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen trying to access an element in the Array which has not been previously\ninitialized or when accessing an element which has explicitly been set to\nNil. Unless the Array is declared as having a default value by using the is\ndefault trait the method returns the type object (Any).\n\n    my @a1 = 1, \"two\", 2.718;\n    say @a1.default;                               # OUTPUT: «(Any)␤»\n    say @a1[4];                                    # OUTPUT: «(Any)␤»\n\n    my @a2 is default(17) = 1, \"two\", 3;\n    say @a2.default;                               # OUTPUT: «17␤»\n    say @a2[4];                                    # OUTPUT: «17␤»\n    @a2[1] = Nil;                                  # (resets element to its default)\n    say @a2[1];                                    # OUTPUT: «17␤»","of\n\nDefined as:\n\n    method of\n\nReturns the type constraint for the values of the invocant. By default,\ni.e. if no type constraint is given during declaration, the method returns\n(Mu).\n\n    my @a1 = 1, 'two', 3.14159;              # (no type constraint specified)\n    say @a1.of;                              # OUTPUT: «(Mu)␤»\n\n    my Int @a2 = 1, 2, 3;                    # (values must be of type Int)\n    say @a2.of;                              # OUTPUT: «(Int)␤»\n    @a2.push: 'd';\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to @a2; expected Int but got Str (\"d\")␤»","dynamic\n\nDefined as:\n\n    method dynamic(Array:D: --> Bool:D)\n\nReturns True if the invocant has been declared with the is dynamic trait.\n\n    my @a;\n    say @a.dynamic;                          # OUTPUT: «False␤»\n\n    my @b is dynamic;\n    say @b.dynamic;                          # OUTPUT: «True␤»\n\nIf you declare a variable with the * twigil is dynamic is implied.\n\n    my @*b;\n    say @*b.dynamic;                         # OUTPUT: «True␤»\n\nNote that in the Scalar case you have to use the VAR method in order to get\ncorrect information.\n\n    my $s is dynamic = [1, 2, 3];\n    say $s.dynamic;                          # OUTPUT: «False␤»  (wrong, don't do this)\n    say $s.VAR.dynamic;                      # OUTPUT: «True␤»   (correct approach)"]},{"name":"Map","desc":"TITLE\nclass Map\n\nSUBTITLE\nImmutable mapping from strings to values\n\n    class Map does Associative does Iterable { }\n\nA Map is an immutable mapping from string keys to values of arbitrary\ntypes. It serves as a base class for Hash, which is mutable.\n\nIn list context a Map behaves as a list of Pair objects.\n\nNote that the order in which keys, values and pairs are retrieved is\ngenerally arbitrary, but the keys, values and pairs methods return them\nalways in the same order when called on the same object.\n\n    my %e := Map.new('a', 1, 'b', 2);\n    say %e.keys;    # can print \"a b\\n\" or \"b a\\n\";\n    say %e.values;  # prints \"1 2\\n\" if the previous line\n                    # printed \"a b\\n\", \"b a\\n\" otherwise\n\nTo retrieve a value from the Map by key, use the { } postcircumfix\noperator:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    say $map{'a'};      # OUTPUT: «1␤»\n    say $map{ 'a', 'b' }; # OUTPUT: «(1 2)␤»\n\nTo check whether a given key is stored in a Map, modify the access with the\n:exists adverb:\n\n    my $map = Map.new('a', 1, 'b', 2);\n    my $key = 'a';\n    if $map{$key}:exists {\n        say \"$map{} has key $key\";\n    }\n\nBeing an immutable instance, it is not possible to add keys after a Map has\nbeen initialized:\n\n    my $m = Map.new( 'a', 1, 'b', 2 );\n    $m{ 'c' } = 'foo'; # WRONG!\n                       # Cannot modify an immutable Str\n\n","methods":["new\n\nDefined as:\n\n    method new(*@args)\n\nCreates a new Map from a list of alternating keys and values, with the same\nsemantics as described for hash assigning in the Hash documentation,\nexcept, for literal pair handling. To ensure pairs correctly get passed,\nadd extra parentheses around all the arguments.\n\n    my %h = Map.new('a', 1, 'b', 2);\n\n    # WRONG: :b(2) interpreted as named argument\n    say Map.new('a', 1, :b(2) ).keys; # OUTPUT: «(a)␤»\n\n    # RIGHT: :b(2) interpreted as part of Map's contents\n    say Map.new( ('a', 1, :b(2)) ).keys; # OUTPUT: «(a b)␤»","elems\n\nDefined as:\n\n    method elems(Map:D: --> Int:D)\n\nReturns the number of pairs stored in the Map.\n\n    my %map = Map.new('a', 1, 'b', 2);\n    say %map.elems; # OUTPUT: «2␤»","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(Map:D: Positional $topic)\n    multi method ACCEPTS(Map:D: Cool:D     $topic)\n    multi method ACCEPTS(Map:D: Regex      $topic)\n    multi method ACCEPTS(Map:D: Any        $topic)\n\nUsed in smartmatching if the right-hand side is an Map.\n\nIf the topic is list-like (Positional), returns True if any of the list\nelements exist as a key in the Map.\n\nIf the topic is of type Cool (strings, integers etc.), returns True if the\ntopic exists as a key.\n\nIf the topic is a regex, returns True if any of the keys match the regex.\n\nAs a fallback, the topic is coerced to a list, and the Positional behavior\nis applied.","gist\n\nDefined as:\n\n    method gist(Map:D: --> Str:D)\n\nReturns the string containing the \"gist\" of the Map, sorts the pairs and\nlists up to the first 100, appending an ellipsis if the Map has more than\n100 pairs.","keys\n\nDefined as:\n\n    method keys(Map:D: --> Seq:D)\n\nReturns a Seq of all keys in the Map.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.keys; # OUTPUT: «(a b)␤»","values\n\nDefined as:\n\n    method values(Map:D: --> Seq:D)\n\nReturns a Seq of all values in the Map.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.values; # OUTPUT: «((2 3) 17)␤»","pairs\n\nDefined as:\n\n    method pairs(Map:D: --> Seq:D)\n\nReturns a Seq of all pairs in the Map.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.pairs; # OUTPUT: «(a => (2 3) b => 17)␤»","antipairs\n\nDefined as:\n\n    method antipairs(Map:D: --> Seq:D)\n\nReturns all keys and their respective values as a Seq of Pairs where the\nkeys and values have been exchanged, i.e. the opposite of method pairs.\nUnlike the invert method, there is no attempt to expand list values into\nmultiple pairs.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.antipairs;                                  # OUTPUT: «((2 3) => a 17 => b)␤»","invert\n\nDefined as:\n\n    method invert(Map:D: --> Seq:D)\n\nReturns all keys and their respective values as a Seq of Pairs where the\nkeys and values have been exchanged. The difference between invert and\nantipairs is that invert expands list values into multiple pairs.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.invert;                                    # OUTPUT: «(2 => a 3 => a 17 => b)␤»","kv\n\nDefined as:\n\n    method kv(Map:D: --> Seq:D)\n\nReturns a Seq of keys and values interleaved.\n\n    Map.new('a', 1, 'b', 2).kv  # (a 1 b 2)","list\n\nDefined as:\n\n    method list(Map:D: --> List:D)\n\nReturns a List of all keys and values in the Map.\n\n    my $m = Map.new('a' => (2, 3), 'b' => 17);\n    say $m.list;                                      # OUTPUT: «(b => 17 a => (2 3))␤»","sort\n\nDefined as:\n\n    multi method sort(Map:D: --> Seq:D)\n\nReturns a Seq of Pair objects, which are the pairs of the hash, sorted by\nkey. Equivalent to %hash.sort: *.key\n\n    # These are equivalent:\n    say Map.new(<c 3 a 1 b 2>).sort;        # OUTPUT: «(a => 1 b => 2 c => 3)␤»\n    say Map.new(<c 3 a 1 b 2>).sort: *.key; # OUTPUT: «(a => 1 b => 2 c => 3)␤»\n\nSee Any.sort for additional available candidates.","Int\n\nDefined as:\n\n    method Int(Map:D: --> Int:D)\n\nReturns the number of pairs stored in the Map (same as .elems).\n\n    my $m = Map.new('a' => 2, 'b' => 17);\n    say $m.Int;                                       # OUTPUT: «2␤»","Numeric\n\nDefined as:\n\n    method Numeric(Map:D: --> Int:D)\n\nReturns the number of pairs stored in the Map (same as .elems).\n\n    my $m = Map.new('a' => 2, 'b' => 17);\n    say $m.Numeric;                                   # OUTPUT: «2␤»","Bool\n\nDefined as:\n\n    method Bool(Map:D: --> Bool:D)\n\nReturns True if the invocant contains at least one key/value pair.\n\n    my $m = Map.new('a' => 2, 'b' => 17);\n    say $m.Bool;                                      # OUTPUT: «True␤»","Capture\n\nDefined as:\n\n    method Capture(Map:D:)\n\nReturns a Capture where each key, if any, has been converted to a named\nargument with the same value as it had in the original Map. The returned\nCapture will not contain any positional arguments.\n\n    my $map = Map.new('a' => 2, 'b' => 17);\n    my $capture = $map.Capture;\n    my-sub(|$capture);                                # RESULT: «2, 17»\n\n    sub my-sub(:$a, :$b) {\n        say \"$a, $b\"\n    }"]},{"desc":"TITLE\nclass Compiler\n\nSUBTITLE\nInformation related to the compiler that is being used\n\n    class Compiler does Systemic {}\n\nBuilt-in class for providing compiler related information. Usually accessed\nthrough the compiler attribute of the $*PERL dynamic variable.\n\n    say $*PERL.compiler; # OUTPUT: «rakudo (2019.03.1.385.ga.643.b.8.be.1)␤»\n\n","methods":["id\n\nReturns an unique identifier, a long hexadecimal string","release\n\nIt's empty, but it might contain the release number for specific releases.","codename\n\nIt's empty, but it might contain the codename for specific releases.","build-date\n\n    method build-date()\n\nUp to version 2019.03.1, it returns the date when it was built.\n\n    say $*PERL.compiler.build-date; #OUTPUT: «2018-05-05T21:49:43Z␤»","verbose-config\n\n    method verbose-config(:$say)\n\nIf $say is True, it prints the different items included in the\nconfiguration of the compiler; if it is not, returns a Hash with the same\ninformation.\n\n    say $*PERL.compiler.verbose-config; # OUTPUT: «distro::auth=https://www.opensuse.org/␤distro::desc=2018-05-06T09:19:17.571307+02:00␤» ... And the rest of the configuration\n\nSee Also: Systemic"],"name":"Compiler"},{"methods":["in Cool coerce the invocant to a more specific type, and then call\nthe same method on that type. For example both Int and Str inherit from\nCool, and calling method substr on an Int converts the integer to Str\nfirst.\n\n    123.substr(1, 1);   # '2', same as 123.Str.substr(1, 1)\n\nThe following built-in types inherit from Cool: Array Bool Complex Cool\nDuration Map FatRat Hash Instant Int List Match Nil Num Range Seq Stash\nStr.\n\nThe following table summarizes the methods that Cool provides, and what\ntype they coerce to:","coercion type\n  abs            Numeric\n  conj           Numeric\n  sqrt           Numeric\n  sign           Real\n  rand           Numeric\n  sin            Numeric\n  asin           Numeric\n  cos            Numeric\n  acos           Numeric\n  tan            Numeric\n  tanh           Numeric\n  atan           Numeric\n  atan2          Numeric\n  atanh          Numeric\n  sec            Numeric\n  asec           Numeric\n  cosec          Numeric\n  acosec         Numeric\n  cotan          Numeric\n  cotanh         Numeric\n  acotan         Numeric\n  sinh           Numeric\n  asinh          Numeric\n  cosh           Numeric\n  acosh          Numeric\n  sech           Numeric\n  asech          Numeric\n  cosech         Numeric\n  acosech        Numeric\n  acotanh        Numeric\n  cis            Numeric\n  log            Numeric\n  exp            Numeric\n  roots          Numeric\n  log10          Numeric\n  unpolar        Numeric\n  round          Numeric\n  floor          Numeric\n  ceiling        Numeric\n  truncate       Numeric\n  chr            Int\n  ord            Str\n  chars          Str\n  fmt            Str\n  uniname        Str\n  uninames       Seq\n  unival         Str\n  univals        Str\n  uniprop        Str\n  unimatch       Str\n  uc             Str\n  lc             Str\n  fc             Str\n  tc             Str\n  tclc           Str\n  flip           Str\n  trans          Str\n  contains       Str\n  index          Str\n  rindex         Str\n  ords           Str\n  split          Str\n  match          Str\n  comb           Str\n  subst          Str\n  sprintf        Str\n  printf         Str\n  samecase       Str\n  trim           Str\n  trim-leading   Str\n  trim-trailing  Str\n  EVAL           Str\n  chomp          Str\n  chop           Str\n  codes          Str"],"desc":"TITLE\nclass Cool\n\nSUBTITLE\nObject that can be treated as both a string and number\n\n    class Cool is Any { }\n\nCool, also known as the Convenient OO Loop, is a base class employed by a\nnumber of built-in classes whose instances can be meaningfully coerced to a\nstring and a number. For example, an Array can be used in mathematical\noperations, where its numerical representation is the number of elements it\ncontains. At the same time, it can be concatenated to a string, where its\nstringy representation is all of its elements joined by a space. Because\nArray is Cool, the appropriate coercion happens automatically.\n\n","name":"Cool"},{"desc":"TITLE\nclass Mu\n\nSUBTITLE\nThe root of the Raku type hierarchy.\n\n    class Mu { }\n\nThe root of the Raku type hierarchy. For the origin of the name, see\nhttps://en.wikipedia.org/wiki/Mu_%28negative%29. One can also say that\nthere are many undefined values in Raku, and Mu is the most undefined\nvalue.\n\nNote that most classes do not derive from Mu directly, but rather from\nAny.\n\n","methods":["iterator\n\nDefined as:\n\n    method iterator(--> Iterator)\n\nCoerces the invocant to a list by applying its .list method and uses\niterator on it.\n\n    my $it = Mu.iterator;\n    say $it.pull-one; # OUTPUT: «(Mu)␤»\n    say $it.pull-one; # OUTPUT: «IterationEnd␤»","defined \n\nDeclared as\n\n    multi method defined(   --> Bool:D)\n\nReturns False on a type object, and True otherwise.\n\n    say Int.defined;                # OUTPUT: «False␤»\n    say 42.defined;                 # OUTPUT: «True␤»\n\nA few types (like Failure) override defined to return False even for\ninstances:\n\n    sub fails() { fail 'oh noe' };\n    say fails().defined;            # OUTPUT: «False␤»","defined\n\nDeclared as\n\n    multi sub defined(Mu --> Bool:D)\n\ninvokes the .defined method on the object and returns its result.","isa\n\n    multi method isa(Mu $type     --> Bool:D)\n    multi method isa(Str:D $type  --> Bool:D)\n\nReturns True if the invocant is an instance of class $type, a subset type\nor a derived class (through inheritance) of $type. does is similar, but\nincludes roles.\n\n    my $i = 17;\n    say $i.isa(\"Int\");   # OUTPUT: «True␤»\n    say $i.isa(Any);     # OUTPUT: «True␤»\n    role Truish {};\n    my $but-true = 0 but Truish;\n    say $but-true.^name;        # OUTPUT: «Int+{Truish}␤»\n    say $but-true.does(Truish); # OUTPUT: «True␤»\n    say $but-true.isa(Truish);  # OUTPUT: «False␤»","does\n\n    method does(Mu $type --> Bool:D)\n\nReturns True if and only if the invocant conforms to type $type.\n\n    my $d = Date.new('2016-06-03');\n    say $d.does(Dateish);             # True    (Date does role Dateish)\n    say $d.does(Any);                 # True    (Date is a subclass of Any)\n    say $d.does(DateTime);            # False   (Date is not a subclass of DateTime)\n\n\nUnlike isa, which returns True only for superclasses, does includes both\nsuperclasses and roles.\n\n    say $d.isa(Dateish); # OUTPUT: «False␤»\n\n\nUsing the smartmatch operator ~~ is a more idiomatic alternative.\n\n    my $d = Date.new('2016-06-03');\n    say $d ~~ Dateish;                # OUTPUT: «True␤»\n    say $d ~~ Any;                    # OUTPUT: «True␤»\n    say $d ~~ DateTime;               # OUTPUT: «False␤»","Bool\n\n    multi sub    Bool(Mu --> Bool:D)\n    multi method Bool(   --> Bool:D)\n\nReturns False on the type object, and True otherwise.\n\nMany built-in types override this to be False for empty collections, the\nempty string or numerical zeros\n\n    say Mu.Bool;                    # OUTPUT: «False␤»\n    say Mu.new.Bool;                # OUTPUT: «True␤»\n    say [1, 2, 3].Bool;             # OUTPUT: «True␤»\n    say [].Bool;                    # OUTPUT: «False␤»\n    say %( hash => 'full' ).Bool;   # OUTPUT: «True␤»\n    say {}.Bool;                    # OUTPUT: «False␤»\n    say \"\".Bool;                    # OUTPUT: «False␤»\n    say 0.Bool;                     # OUTPUT: «False␤»\n    say 1.Bool;                     # OUTPUT: «True␤»\n    say \"0\".Bool;                   # OUTPUT: «True␤»","Capture\n\nDeclared as:\n\n    method Capture(Mu:D: --> Capture:D)\n\nReturns a Capture with named arguments corresponding to invocant's public\nattributes:\n\n    class Foo {\n        has $.foo = 42;\n        has $.bar = 70;\n        method bar { 'something else' }\n    }.new.Capture.say; # OUTPUT: «\\(:bar(\"something else\"), :foo(42))␤»","Str\n\n    multi method Str(--> Str)\n\nReturns a string representation of the invocant, intended to be machine\nreadable. Method Str warns on type objects, and produces the empty string.\n\n    say Mu.Str;   # Use of uninitialized value of type Mu in string context.\n    my @foo = [2,3,1];\n    say @foo.Str  # OUTPUT: «2 3 1␤»","gist\n\n    multi sub    gist(+args --> Str)\n    multi method gist(   --> Str)\n\nReturns a string representation of the invocant, optimized for fast\nrecognition by humans. As such lists will be truncated at 100 elements. Use\n.perl to get all elements.\n\nThe default gist method in Mu re-dispatches to the perl method for defined\ninvocants, and returns the type name in parenthesis for type object\ninvocants. Many built-in classes override the case of instances to\nsomething more specific that may truncate output.\n\ngist is the method that say calls implicitly, so say $something and say\n$something.gist generally produce the same output.\n\n    say Mu.gist;        # OUTPUT: «(Mu)␤»\n    say Mu.new.gist;    # OUTPUT: «Mu.new␤»","perl\n\n    multi method perl(--> Str)\n\nReturns a Perlish representation of the object (i.e., can usually be\nre-evaluated with EVAL to regenerate the object). The exact output of perl\nis implementation specific, since there are generally many ways to write a\nPerl expression that produces a particular value.","item\n\n    method item(Mu \\item:) is raw\n\nForces the invocant to be evaluated in item context and returns the value\nof it.\n\n    say [1,2,3].item.perl;          # OUTPUT: «$[1, 2, 3]␤»\n    say %( apple => 10 ).item.perl; # OUTPUT: «${:apple(10)}␤»\n    say \"abc\".item.perl;            # OUTPUT: «\"abc\"␤»","self\n\n    method self(--> Mu)\n\nReturns the object it is called on.","clone\n\n    multi method clone(Mu:U: *%twiddles)\n    multi method clone(Mu:D: *%twiddles)\n\nThis method will clone type objects, or die if it's invoked with any\nargument.\n\n    say Num.clone( :yes )\n    # OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block <unit>␤␤»\n\n\nIf invoked with value objects, it creates a shallow clone of the invocant,\nincluding shallow cloning of private attributes. Alternative values for\npublic attributes can be provided via named arguments with names matching\nthe attributes' names.\n\n    class Point2D {\n        has ($.x, $.y);\n        multi method gist(Point2D:D:) {\n            \"Point($.x, $.y)\";\n        }\n    }\n\n    my $p = Point2D.new(x => 2, y => 3);\n\n    say $p;                     # OUTPUT: «Point(2, 3)␤»\n    say $p.clone(y => -5);      # OUTPUT: «Point(2, -5)␤»\n\n\nNote that .clone does not go the extra mile to shallow-copy @. and %.\nsigiled attributes and, if modified, the modifications will still be\navailable in the original object:\n\n    class Foo {\n        has $.foo is rw = 42;\n        has &.boo is rw = { say \"Hi\" };\n        has @.bar       = <a b>;\n        has %.baz       = <a b c d>;\n    }\n\n    my $o1 = Foo.new;\n    with my $o2 = $o1.clone {\n        .foo = 70;\n        .bar = <Z Y>;\n        .baz = <Z Y X W>;\n        .boo = { say \"Bye\" };\n    }\n\n    # Hash and Array attribute modifications in clone appear in original as well:\n    say $o1;\n    # OUTPUT: «Foo.new(foo => 42, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    say $o2;\n    # OUTPUT: «Foo.new(foo => 70, bar => [\"Z\", \"Y\"], baz => {:X(\"W\"), :Z(\"Y\")}, …␤»\n    $o1.boo.(); # OUTPUT: «Hi␤»\n    $o2.boo.(); # OUTPUT: «Bye␤»\n\n\nTo clone those, you could implement your own .clone that clones the\nappropriate attributes and passes the new values to Mu.clone, for example,\nvia nextwith.\n\n    class Bar {\n        has $.quux;\n        has @.foo = <a b>;\n        has %.bar = <a b c d>;\n        method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }\n    }\n\n    my $o1 = Bar.new( :42quux );\n    with my $o2 = $o1.clone {\n        .foo = <Z Y>;\n        .bar = <Z Y X W>;\n    }\n\n    # Hash and Array attribute modifications in clone do not affect original:\n    say $o1;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"a\", \"b\"], bar => {:a(\"b\"), :c(\"d\")})␤»\n    say $o2;\n    # OUTPUT: «Bar.new(quux => 42, foo => [\"Z\", \"Y\"], bar => {:X(\"W\"), :Z(\"Y\")})␤»\n\n\nThe |%_ is needed to slurp the rest of the attributes that would have been\ncopied via shallow copy.","new\n\n    multi method new(*%attrinit)\n    multi method new($, *@)\n\nDefault method for constructing (create + initialize) new objects of a\nclass. This method expects only named arguments which are then used to\ninitialize attributes with accessors of the same name.\n\nClasses may provide their own new method to override this default.\n\nnew triggers an object construction mechanism that calls submethods named\nBUILD in each class of an inheritance hierarchy, if they exist. See the\ndocumentation on object construction for more information.","bless\n\n    method bless(*%attrinit --> Mu:D)\n\nLow-level object construction method, usually called from within new,\nimplicitly from the default constructor, or explicitly if you create your\nown constructor. bless creates a new object of the same type as the\ninvocant, using the named arguments to initialize attributes and returns\nthe created object.\n\nIt is usually invoked within custom new method implementations:\n\n    class Point {\n        has $.x;\n        has $.y;\n        multi method new($x, $y) {\n            self.bless(:$x, :$y);\n        }\n    }\n    my $p = Point.new(-1, 1);\n\n\nIn this case we are declaring new as a multi method so that we can still\nuse the default constructor like this: Point.new( x => 3, y => 8 ). In this\ncase we are declaring this new method simply to avoid the extra syntax of\nusing pairs when creating the object. self.bless returns the object, which\nis in turn returned by new.\n\nHowever, in general, implementing a customized new method might not be the\nbest way of initializing a class, even more so if the default constructor\nis disabled, since it can make it harder to correctly initialize the class\nfrom a subclass. For instance, in the above example, the new implementation\ntakes two positional arguments that must be passed from the subclass to the\nsuperclass in the exact order. That is not a real problem if it's\ndocumented, but take into account bless will eventually be calling BUILD in\nthe class that is being instantiated. This might result in some unwanted\nproblems, like having to create a BUILD submethod to serve it correctly:\n\n    class Point {\n        has Int $.x;\n        has Int $.y;\n        multi method new($x, $y) {\n            self.bless(:$x, :$y);\n        }\n    }\n\n    class Point-with-ID is Point {\n        has Int $.ID  is rw = 0;\n\n        submethod BUILD( *%args ) {\n            say %args;                # OUTPUT: «{x => 1, y => 2}␤»\n            for self.^attributes -> $attr {\n                if $attr.Str ~~ /ID/ {\n                    $attr.set_value( self, \"*\" ~ %args<x> ~ \"-\" ~ %args<y> ) ;\n                }\n            }\n        }\n    }\n\n    my $p = Point-with-ID.new(1,2);\n    say $p.perl;\n    # OUTPUT: «Point-with-ID.new(ID => \"*1-2\", x => 1, y => 2)␤»\n\n\nIn this code, bless, called within Point.new, is eventually calling BUILD\nwith the same parameters. We have to create a convoluted way of using the\n$.ID attribute using the metaobject protocol so that we can instantiate it\nand thus serve that new constructor, which can be called on Point-with-ID\nsince it is a subclass.\n\nWe might have to use something similar if we want to instantiate\nsuperclasses. bless will help us with that, since it is calling across all\nthe hierarchy:\n\n    class Str-with-ID is Str {\n        my $.counter = 0;\n        has Int $.ID  is rw = 0;\n\n        multi method new( $str ) {\n            self.bless( value => $str, ID => $.counter++ );\n        }\n\n        submethod BUILD( *%args ) {\n            for self.^attributes -> $attr {\n                if $attr.Str ~~ /ID/ {\n                    $attr.set_value( self, %args<ID> ) ;\n                }\n            }\n        }\n    }\n\n    say Str-with-ID.new(\"1.1,2e2\").ID;                  # OUTPUT: «0␤»\n    my $enriched-str = Str-with-ID.new(\"3,4\");\n    say \"$enriched-str, {$enriched-str.^name}, {$enriched-str.ID}\";\n    # OUTPUT: «3,4, Str-with-ID, 1␤»\n\n\nWe are enriching Str with an auto-incrementing ID. We create a new since we\nwant to initialize it with a string and, besides, we need to instantiate\nthe superclass. We do so using bless from within new. bless is going to\ncall Str.BUILD. It will *capture* the value it's looking for, the pair\nvalue = $str> and initialize itself. But we have to initialize also the\nproperties of the subclass, which is why within BUILD we use the previously\nexplained method to initialize $.ID with the value that is in the %args\nvariable. As shown in the output, the objects will be correctly initialized\nwith its ID, and will correctly behave as Str, converting themselves in\njust the string in the say statement, and including the ID property as\nrequired.\n\nFor more details see the documentation on object construction.","CREATE\n\n    method CREATE(--> Mu:D)\n\nAllocates a new object of the same type as the invocant, without\ninitializing any attributes.\n\n    say Mu.CREATE.defined;  # OUTPUT: «True␤»","print\n\n    multi method print(--> Bool:D)\n\nPrints value to $*OUT after stringification using .Str method without\nadding a newline at end.\n\n    \"abc\\n\".print;          # RESULT: «abc␤»","put\n\n    multi method put(--> Bool:D)\n\nPrints value to $*OUT, adding a newline at end, and if necessary,\nstringifying non-Str object using the .Str method.\n\n    \"abc\".put;              # RESULT: «abc␤»","say\n\n    multi method say()\n\nWill say to standard output.\n\n    say 42;                 # OUTPUT: «42␤»\n\nWhat say actually does is, thus, deferred to the actual subclass. In most\ncases it calls .gist on the object, returning a compact string\nrepresentation.\n\nIn non-sink context, say will always return True.\n\n    say (1,[1,2],\"foo\",Mu).map: so *.say ;\n    # OUTPUT: «1␤[1 2]␤foo␤(Mu)␤(True True True True)␤»\n\nHowever, this behavior is just conventional and you shouldn't trust it for\nyour code. It's useful, however, to explain certain behaviors.\n\nsay is first printing out in *.say, but the outermost say is printing the\nTrue values returned by the so operation.","ACCEPTS\n\n    multi method ACCEPTS(Mu:U: $other)\n\nACCEPTS is the method that smartmatching with the infix ~~ operator and\ngiven/when invokes on the right-hand side (the matcher).\n\nThe Mu:U multi performs a type check. Returns True if $other conforms to\nthe invocant (which is always a type object or failure).\n\n    say 42 ~~ Mu;           # OUTPUT: «True␤»\n    say 42 ~~ Int;          # OUTPUT: «True␤»\n    say 42 ~~ Str;          # OUTPUT: «False␤»\n\nNote that there is no multi for defined invocants; this is to allow\nautothreading of junctions, which happens as a fallback mechanism when no\ndirect candidate is available to dispatch to.","WHICH\n\n    multi method WHICH(--> ObjAt:D)\n\nReturns an object of type ObjAt which uniquely identifies the object. Value\ntypes override this method which makes sure that two equivalent objects\nreturn the same return value from WHICH.\n\n    say 42.WHICH eq 42.WHICH;       # OUTPUT: «True␤»","WHERE\n\n    method WHERE(--> Int)\n\nReturns an Int representing the memory address of the object.","WHY\n\n    multi method WHY(--> Pod::Block::Declarator)\n\nReturns the attached Pod::Block::Declarator.\n\nFor instance:\n\n    #| Initiate a specified spell normally\n    sub cast(Spell $s) {\n      do-raw-magic($s);\n    }\n    #= (do not use for class 7 spells)\n    say &cast.WHY;\n    # OUTPUT: «Initiate a specified spell normally␤(do not use for class 7 spells)␤»\n\n\nSee Pod declarator blocks for details about attaching Pod to variables,\nclasses, functions, methods, etc.\n\n  trait is export\n\n    multi sub trait_mod:<is>(Mu:U \\type, :$export!)\n\nMarks a type as being exported, that is, available to external users.\n\n    my class SomeClass is export { }\n\nA user of a module or class automatically gets all the symbols imported\nthat are marked as is export.\n\nSee Exporting and Selective Importing Modules for more details.","return\n\n    method return()\n\nThe method return will stop execution of a subroutine or method, run all\nrelevant phasers and provide invocant as a return value to the caller. If a\nreturn type constraint is provided it will be checked unless the return\nvalue is Nil. A control exception is raised and can be caught with\nCONTROL.\n\n    sub f { (1|2|3).return };\n    say f(); # OUTPUT: «any(1, 2, 3)␤»","return-rw\n\nSame as method return except that return-rw returns a writable container to\nthe invocant (see more details here: return-rw).","emit\n\n    method emit()\n\nEmits the invocant into the enclosing supply or react block.\n\n    react { whenever supply { .emit for \"foo\", 42, .5 } {\n        say \"received {.^name} ($_)\";\n    }}\n\n    # OUTPUT:\n    # received Str (foo)\n    # received Int (42)\n    # received Rat (0.5)","take\n\n    method take()\n\nReturns the invocant in the enclosing gather block.\n\n    sub insert($sep, +@list) {\n        gather for @list {\n            FIRST .take, next;\n            take slip $sep, .item\n        }\n    }\n\n    say insert ':', <a b c>;\n    # OUTPUT: «(a : b : c)␤»","take\n\n    sub take(\\item)\n\nTakes the given item and passes it to the enclosing gather block.\n\n    #| randomly select numbers for lotto\n    my $num-selected-numbers = 6;\n    my $max-lotto-numbers = 49;\n    gather for ^$num-selected-numbers {\n        take (1 .. $max-lotto-numbers).pick(1);\n    }.say;    # six random values","take-rw\n\n    sub take-rw(\\item)\n\nReturns the given item to the enclosing gather block, without introducing a\nnew container.\n\n    my @a = 1...3;\n    sub f(@list){ gather for @list { take-rw $_ } };\n    for f(@a) { $_++ };\n    say @a;\n    # OUTPUT: «[2 3 4]␤»","so\n\n    method so()\n\nEvaluates the item in boolean context (and thus, for instance, collapses\nJunctions), and returns the result. It is the opposite of not, and\nequivalent to the ? operator.\n\nOne can use this method similarly to the English sentence: \"If that is so,\nthen do this thing\". For instance,\n\n    my @args = <-a -e -b -v>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if $verbose-selected.so {\n        say \"Verbose option detected in arguments\";\n    } # OUTPUT: «Verbose option detected in arguments␤»\n\nThe $verbose-selected variable in this case contains a Junction, whose\nvalue is any(any(False, False), any(False, False), any(False, False),\nany(True, False)). That is actually a truish value; thus, negating it will\nyield False. The negation of that result will be True. so is performing all\nthose operations under the hood.","not\n\n    method not()\n\nEvaluates the item in boolean context (leading to final evaluation of\nJunctions, for instance), and negates the result. It is the opposite of so\nand its behavior is equivalent to the ! operator.\n\n    my @args = <-a -e -b>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if $verbose-selected.not {\n        say \"Verbose option not present in arguments\";\n    } # OUTPUT: «Verbose option not present in arguments␤»\n\nSince there is also a prefix version of not, this example reads better as:\n\n    my @args = <-a -e -b>;\n    my $verbose-selected = any(@args) eq '-v' | '-V';\n    if not $verbose-selected {\n        say \"Verbose option not present in arguments\";\n    } # OUTPUT: «Verbose option not present in arguments␤»"],"name":"Mu"},{"name":"Routine","methods":["name\n\n    method name(Routine:D: --> Str:D)\n\nReturns the name of the sub or method.","package\n\n    method package(Routine:D:)\n\nReturns the package in which the routine is defined.","multi\n\n    method multi(Routine:D: --> Bool:D)\n\nReturns True if the routine is a multi sub or method. Note that the name of\na multi sub refers to its proto and this method would return false if\ncalled on it. It needs to be called on the candidates themselves:\n\n    multi foo ($, $) {};\n    say &foo.multi;             # OUTPUT: «False␤»\n    say &foo.candidates».multi; # OUTPUT: «(True)␤»","candidates\n\n    method candidates(Routine:D: --> Positional:D)\n\nReturns a list of multi candidates, or a one-element list with itself if\nit's not a multi","cando\n\n    method cando(Capture $c)\n\nReturns a possibly-empty list of candidates that can be called with the\ngiven Capture, ordered by narrowest candidate first. For methods, the first\nelement of the Capture needs to be the invocant:\n\n    .signature.say for \"foo\".^can(\"comb\")[0].cando: \\(Cool, \"o\");\n    # OUTPUT: «(Cool $: Str $matcher, $limit = Inf, *%_)␤»","wrap\n\n    method wrap(Routine:D: &wrapper)\n\nWraps (i.e. in-place modifies) the routine. That means a call to this\nroutine first calls &wrapper, which then can (but doesn't have to) call the\noriginal routine with the callsame, callwith, nextsame and nextwith\ndispatchers. The return value from the routine is also the return value\nfrom the wrapper.\n\nwrap returns an instance of a private class called Routine::WrapHandle,\nwhich you can pass to unwrap to restore the original routine.","unwrap\n\n    method unwrap($wraphandle)\n\nRestores the original routine after it has been wrapped with wrap. While\nthe signature allows any type to be passed, only the Routine::WrapHandle\ntype returned from wrap can usefully be.","yada\n\n    method yada(Routine:D: --> Bool:D)\n\nReturns True if the routine is a stub\n\n    say (sub f() { ... }).yada;      # OUTPUT: «True␤»\n    say (sub g() { 1;  }).yada;      # OUTPUT: «False␤»\n\n  trait is cached\n\n    multi sub trait_mod:<is>(Routine $r, :$cached!)\n\nCauses the return value of a routine to be stored, so that when subsequent\ncalls with the same list of arguments are made, the stored value can be\nreturned immediately instead of re-running the routine.This is still in\nexperimental stage. Please check the corresponding section in the\nexperimental features document\n\nUseful when storing and returning the computed value is much faster than\nre-computing it every time, and when the time saved trumps the cost of the\nuse of more memory.\n\nEven if the arguments passed to the routine are \"reference types\" (such as\nobjects or arrays), then for the purpose of caching they will only be\ncompared based on their contents. Thus the second invocation will hit the\ncache in this case:\n\n    say foo( [1, 2, 3] );   # runs foo\n    say foo( [1, 2, 3] );   # doesn't run foo, uses cached value\n\n\nSince it's still at the experimental stage, you will have to insert the use\nexperimental :cached; statement in any module or script that uses it.\n\n    use experimental :cached;\n\n    sub nth-prime(Int:D $x where * > 0) is cached {\n        say \"Calculating {$x}th prime\";\n        return (2..*).grep(*.is-prime)[$x - 1];\n    }\n\n    say nth-prime(43);\n    say nth-prime(43);\n    say nth-prime(43);\n\n\nproduces this output:\n\n    Calculating 43th prime\n    191\n    191\n    191\n\n\n  trait is pure\n\n    multi sub trait_mod:<is>(Routine $r, :$pure!)\n\nMarks a subroutine as pure, that is, it asserts that for the same input, it\nwill always produce the same output without any additional side effects.\n\nThe is pure trait is a promise by the programmer to the compiler that it\ncan constant-fold calls to such functions when the arguments are known at\ncompile time.\n\n    sub syllables() is pure {\n        say \"Generating syllables\";\n        my @vowels = <a e i o u>;\n        return  @vowels.append: <k m n sh d r t y> X~ @vowels;\n    }\n\nYou can mark function as pure even if they throw exceptions in edge cases\nor if they modify temporary objects; hence the is pure trait can cover\ncases that the compiler cannot deduce on its own. On the other hand, you\nmight not want to constant-fold functions that produce a large return value\n(such as the string or list repetition operators, infix x and xx) even if\nthey are pure, to avoid large precompilation files.\n\nTo see it an action with a particular compiler you can try this example:\n\n    BEGIN { say ‘Begin’ }\n    say ‘Start’;\n    say (^100).map: { syllables().pick(2..5).join(\"\") };\n\n\n    # Example output:\n    # Begin\n    # Generating syllables\n    # Start\n    # (matiroi yeterani shoriyuru...\n\n\nEssentially this allows the compiler to perform some operations at compile\ntime. The benefits of constant-folding may include better performance,\nespecially in cases when the folded code is precompiled.\n\nIn addition, using a pure function or operator in sink context (that is,\nwhere the result is discarded) may lead to a warning. The code\n\n    sub double($x) is pure { 2 * $x };\n    double(21);\n    say \"anything\";\n    # WARNING: «Useless use of \"double(21)\" in expression \"double(21)\" in sink context (line 2)»\n\nIf you want to apply this trait to a multi, you need to apply it to the\nproto; it will not work otherwise, at least in versions 2018.08 and below.\n\n  trait is rw\n\n    multi sub trait_mod:<is>(Routine $r, :$rw!)\n\nWhen a routine is modified with this trait, its return value will be\nwritable. This is useful when returning variables or writable elements of\nhashes or arrays, for example:\n\n    sub walk(\\thing, *@keys) is rw {\n        my $current := thing;\n        for @keys -> $k {\n            if $k ~~ Int {\n                $current := $current[$k];\n            }\n            else {\n                $current := $current{$k};\n            }\n        }\n        $current;\n    }\n\n    my %hash;\n    walk(%hash, 'some', 'key', 1, 2) = 'autovivified';\n\n    say %hash.perl;\n\n\nproduces\n\n    (\"some\" => {\"key\" => [Any, [Any, Any, \"autovivified\"]]}).hash\n\n\nNote that return marks return values as read only; if you need an early\nexit from an is rw routine, you have to use return-rw instead.\n\n  trait is export\n\n    multi sub trait_mod:<is>(Routine $r, :$export!)\n\nMarks a routine as exported to the rest of the world\n\n    module Foo {\n        sub double($x) is export {\n            2 * $x\n        }\n    }\n\n    import Foo;         # makes sub double available\n    say double 21;      # 42\n\n\nFrom inside another file you'd say use Foo; to load a module and import the\nexported functions.\n\nSee Exporting and Selective Importing Modules for more details.\n\n  trait is DEPRECATED\n\n    multi sub trait_mod:<is>(Routine:D $r, :$DEPRECATED!)\n\nMarks a routine as deprecated, optionally with a message what to use\ninstead.\n\nThis code\n\n    sub f() is DEPRECATED('the literal 42') { 42 }\n    say f();\n\n\nproduces this output:\n\n    42\n    Saw 1 occurrence of deprecated code.\n    ================================================================================\n    Sub f (from GLOBAL) seen at:\n      deprecated.p6, line 2\n    Please use the literal 42 instead.\n    --------------------------------------------------------------------------------\n    Please contact the author to have these occurrences of deprecated code\n    adapted, so that this message will disappear!\n\n\n  trait is hidden-from-backtrace\n\n    multi sub trait_mod:<is>(Routine:D, :$hidden-from-backtrace!)\n\nHides a routine from showing up in a default backtrace. For example\n\n    sub inner { die \"OH NOEZ\" };\n    sub outer { inner() };\n    outer();\n\n\nproduces the error message and backtrace\n\n    OH NOEZ\n      in sub inner at bt.p6:1\n      in sub outer at bt.p6:2\n      in block <unit> at bt.p6:3\n\n\nbut if inner is marked with hidden-from-backtrace\n\n    sub inner is hidden-from-backtrace { die \"OH NOEZ\" };\n    sub outer { inner() };\n    outer();\n\n\nthe error backtrace does not show it:\n\n    OH NOEZ\n      in sub outer at bt.p6:2\n      in block <unit> at bt.p6:3\n\n\n  trait is default\n\nDefined as\n\n    multi sub trait_mod:<is>(Routine:D $r, :$default!)\n\nThere is a special trait for Routines called is default. This trait is\ndesigned as a way to disambiguate multi calls that would normally throw an\nerror because the compiler would not know which one to use. This means that\ngiven the following two Routines, the one with the is default trait will be\ncalled.\n\n    multi sub f() is default { say \"Hello there\" }\n    multi sub f() { say \"Hello friend\" }\n    f();   # OUTPUT: «\"Hello there\"␤»\n\nThe is default trait can become very useful for debugging and other uses\nbut keep in mind that it will only resolve an ambiguous dispatch between\ntwo Routines of the same precedence. If one of the Routines is narrower\nthan another, then that one will be called. For example:\n\n    multi sub f() is default { say \"Hello there\" }\n    multi sub f(:$greet) { say \"Hello \" ~ $greet }\n    f();   # \"Use of uninitialized value $greet...\"\n\n\nIn this example, the multi without is default was called because it was\nactually narrower than the Sub with it.\n\n  trait is raw\n\nDefined as:\n\n    multi sub trait_mod:<is>(Routine:D $r, :$raw!)\n\nGives total access to the data structure returned by the routine.\n\n    my @zipi = <zape zapatilla>;\n    sub þor() is raw {\n        return @zipi\n    };\n    þor()[1] = 'pantuflo';\n    say @zipi;  # OUTPUT: «[zape pantuflo]␤»"],"desc":"TITLE\nclass Routine\n\nSUBTITLE\nCode object with its own lexical scope and return handling\n\n    class Routine is Block { }\n\nA Routine is a code object meant for larger unities of code than Block.\nRoutine is the common superclass for Sub (and therefore operators) and\nMethod, the two primary code objects for code reuse.\n\nRoutines serve as a scope limiter for return (i.e. a return returns from\nthe innermost outer Routine).\n\nThe routine level is also the one at which multiness (multi subs and multi\nmethods) are handled. Subroutines can also be declared anon. See the\ndocumentation on the anon declarator for more information.\n\n"},{"name":"Exception","desc":"TITLE\nclass Exception\n\nSUBTITLE\nAnomalous event capable of interrupting normal control-flow\n\n    class Exception {}\n\nAll exceptions that are placed into the $! variable (or into $_ in CATCH\nblocks) inherit from Exception. When you call die or fail with a\nnon-Exception argument, it is wrapped into an X::AdHoc object, which also\ninherits from Exception.\n\nUser-defined exception classes should inherit from Exception too, and\ndefine at least a method message.\n\n    class X::YourApp::SomeError is Exception {\n        method message() {\n            \"A YourApp-Specific error occurred: out of coffee!\";\n        }\n    }\n\n","methods":["message\n\nDefined as:\n\n    method message(Exception:D: --> Str:D)\n\nThis is a stub that must be overwritten by subclasses, and should return\nthe exception message.\n\nSpecial care should be taken that this method does not produce an exception\nitself.\n\n    try die \"Something bad happened\";\n    if ($!) {\n        say $!.message; # OUTPUT: «Something bad happened.␤»\n    }","backtrace\n\nDefined as:\n\n    method backtrace(Exception:D:)\n\nReturns the backtrace associated with the exception in a Backtrace object\nor an empty string if there is none. Only makes sense on exceptions that\nhave been thrown at least once.\n\n    try die \"Something bad happened\";\n    with $! { .backtrace.print ; }","throw\n\nDefined as:\n\n    method throw(Exception:D:)\n\nThrows the exception.\n\n    my $exception = X::AdHoc.new;    # Totally fine\n    try $exception.throw;            # Throws\n    if ($!) { #`( some handling ) }; # Suppress the exception","resume\n\nDefined as:\n\n    method resume(Exception:D:)\n\nResumes control flow where .throw left it when handled in a CATCH block.\n\n    # For example, resume control flow for any exception\n    CATCH { default { .resume } }","rethrow\n\nDefined as:\n\n    method rethrow(Exception:D:)\n\nRethrows an exception that has already been thrown at least once. This is\ndifferent from throw in that it preserves the original backtrace.\n\n    my $e = X::AdHoc.new(payload => \"Bad situation\");\n    sub f() { die 'Bad' };\n    sub g() { try f; CATCH { default { .rethrow } } };\n    g;\n    CATCH { default { say .backtrace.full } };","fail\n\nDefined as:\n\n    multi sub    fail(*@text)\n    multi sub    fail(Exception $e)\n    method fail(Exception:D:)\n\nExits the calling Routine and returns a Failure object wrapping the\nexception $e - or, for the *@text form, an X::AdHoc exception constructed\nfrom the concatenation of @text. If the caller activated fatal exceptions\nvia the pragma use fatal;, the exception is thrown instead of being\nreturned as a Failure.\n\n    # A custom exception defined\n    class ForbiddenDirectory is Exception {\n        has Str $.name;\n\n        method message { \"This directory is forbidden: '$!name'\" }\n    }\n\n    sub copy-directory-tree ($dir) {\n        # We don't allow for non-directories to be copied\n        fail \"$dir is not a directory\" if !$dir.IO.d;\n        # We don't allow 'foo' directory to be copied too\n        fail ForbiddenDirectory.new(:name($dir)) if $dir eq 'foo';\n        # or above can be written in method form as:\n        # ForbiddenDirectory.new(:name($dir)).fail if $dir eq 'foo';\n        # Do some actual copying here\n        ...\n    }\n\n    # A Failure with X::AdHoc exception object is returned and\n    # assigned, so no throwing Would be thrown without an assignment\n    my $result = copy-directory-tree(\"cat.jpg\");\n    say $result.exception; # OUTPUT: «cat.jpg is not a directory␤»\n\n    # A Failure with a custom Exception object is returned\n    $result = copy-directory-tree('foo');\n    say $result.exception; # OUTPUT: «This directory is forbidden: 'foo'␤»","gist\n\nDefined as:\n\n    multi method gist(Exception:D:)\n\nReturns whatever the exception printer should produce for this exception.\nThe default implementation returns message and backtrace separated by a\nnewline.\n\n    my $e = X::AdHoc.new(payload => \"This exception is pretty bad\");\n    try $e.throw;\n    if ($!) { say $!.gist; };\n    # OUTPUT: «This exception is pretty bad\n    #   in block <unit> at <unknown file> line 1␤»\n\n  sub die\n\nDefined as:\n\n    multi sub die()\n    multi sub die(*@message)\n    multi sub die(Exception:D $e)\n    method    die(Exception:D:)\n\nThrows a fatal Exception. The default exception handler prints each element\nof the list to $*ERR (STDERR).\n\n    die \"Important reason\";\n\n\nIf the subroutine form is called without arguments, the value of $!\nvariable is checked. If it is set to a .DEFINITE value, its value will be\nused as the Exception to throw if it's of type Exception, otherwise, it\nwill be used as payload of X::AdHoc exception. If $! is not .DEFINITE,\nX::AdHoc with string \"Died\" as payload will be thrown.\n\ndie will print by default the line number where it happens\n\n    die \"Dead\";\n    # OUTPUT: «(exit code 1) Dead␤\n    # in block <unit> at /tmp/dead.p6 line 1␤␤»\n\n\nHowever, that default behavior is governed at the Exception level and thus\ncan be changed to anything we want by capturing the exception using CATCH.\nThis can be used, for instance, to suppress line numbers.\n\n    CATCH {\n      default {\n        .payload.say\n      }\n    };\n    die \"Dead\" # OUTPUT: «Dead␤»\n\n\n  sub warn\n\nDefined as:\n\n    multi sub warn(*@message)\n\nThrows a resumable warning exception, which is considered a control\nexception, and hence is invisible to most normal exception handlers. The\noutermost control handler will print the warning to $*ERR. After printing\nthe warning, the exception is resumed where it was thrown. To override this\nbehavior, catch the exception in a CONTROL block. A quietly {...} block is\nthe opposite of a try {...} block in that it will suppress any warnings but\npass fatal exceptions through.\n\nTo simply print to $*ERR, please use note instead. warn should be reserved\nfor use in threatening situations when you don't quite want to throw an\nexception.\n\n    warn \"Warning message\";"]},{"name":"PseudoStash","desc":"TITLE\nclass PseudoStash\n\nSUBTITLE\nStash type for pseudo-packages\n\n    class PseudoStash is Map { }\n\nPseudoStash is the stash type (hanging off .WHO) that backs various\npseudo-packages. So, when you do MY:: or CALLER::, that gives back a\nPseudoStash. In most cases, Package:: gives back a Stash. Neither of these\nare objects the user is expected to create by themselves, but in case you\nhave one, you can just use it like a hash.\n\n    my $a = 42;\n    my $b = q/$a/;\n    say MY::{$b};\n    #OUTPUT: «42␤»\n\n\nThis shows how you can use a PseudoStash to look up variables, by name, at\nruntime.","methods":[]},{"methods":[],"desc":"TITLE\nenum Order\n\nSUBTITLE\nHuman readable form for comparison operators. \n\n    enum Order (:Less(-1), :Same(0), :More(1));\n\nOperators\n\n  infix cmp\n\n    multi sub infix:<cmp>(\\a, \\b --> Order:D)\n\ncmp will first try to compare operands as strings (via coercion to\nStringy), and, failing that, will try to compare numerically via the <=>\noperator or any other type-appropriate comparison operator. See also the\ndocumentation for the cmp operator.\n\n  infix <=>\n\n    multi sub infix:«<=>»(Int:D \\a, Int:D \\b --> Order:D)\n\nSpecialized form for Int.","name":"Order"},{"name":"Telemetry","desc":"TITLE\nclass Telemetry\n\nSUBTITLE\nCollect performance state for analysis\n\n    class Telemetry { }\n\nNote:  This class is a Rakudo-specific feature and not standard Raku.\n\nOn creation, a Telemetry object contains a snapshot of various aspects of\nthe current state of the virtual machine. This is in itself useful, but\ngenerally one needs two snapshots for the difference (which is a\nTelemetry::Period object).\n\nThe Telemetry object is really a collection of snapshots taken by different\n\"instruments\". By default, the Telemetry::Instrument::Usage and\nTelemetry::Instrument::ThreadPool instruments are activated.\n\nThe Telemetry (and Telemetry::Period) object also Associative. This means\nthat you can treat a Telemetry object as a read-only Hash, with all of the\ndata values of the instruments as keys.\n\nYou can determine which instruments Telemetry should use by setting the\n$*SAMPLER dynamic variable, which is a Telemetry::Sampler object.\n\nCurrently, the following instruments are supported by the Rakudo core:\n\n  * Telemetry::Instrument::Usage\n\nProvides (in alphabetical order): cpu, cpu-sys, cpu-user, cpus, id-rss,\ninb, invcsw, is-rss, ix-rss, majf, max-rss, minf, mrcv, msnd, nsig, nswp,\nvolcsw, outb, util% and wallclock. For complete documentation of the\nmeaning of these data values, see Telemetry::Instrument::Usage.\n\n  * Telemetry::Instrument::Thread\n\nProvides (in alphabetical order): tad, tcd, thid, tjd, tsd and tys. For\ncomplete documentation of the meaning of these data values, see\nTelemetry::Instrument::Thread.\n\n  * Telemetry::Instrument::ThreadPool\n\nProvides (in alphabetical order): atc, atq, aw, gtc, gtq, gw, s, ttc, ttq\nand tw. For complete documentation of the meaning of these data values, see\nTelemetry::Instrument::ThreadPool.\n\n  * Telemetry::Instrument::AdHoc\n\nDoes not provide any data by itself: one must indicate which variables are\nto be monitored, which will then become available as methods with the same\nname on the instrument. For complete documentation, see\nTelemetry::Instrument::AdHoc.\n\n  routine T\n\n    sub T()\n\nShortcut for Telemetry.new. It is exported by default. Since the Telemetry\nclass also provides an Associative interface, one can easily interpolate\nmultiple values in a single statement:\n\n    use Telemetry;\n    say \"Used {T<max-rss cpu>} (KiB CPU) so far\";\n\n\n  routine snap\n\n    multi sub snap(--> Nil)\n    multi sub snap(@s --> Nil)\n\nThe snap subroutine is shorthand for creating a new Telemetry object and\npushing it to an array for later processing. It is exported by default.\n\n    use Telemetry;\n    my @t;\n    for ^5 {\n        snap(@t);\n        # do some stuff\n        LAST snap(@t);\n    }\n\n\nIf no array is specified, it will use an internal array for convenience.\n\n  routine snapper\n\n    sub snapper($sleep = 0.1, :$stop, :$reset --> Nil)\n\nThe snapper routine starts a separate thread that will call snap repeatedly\nuntil the end of program. It is exported by default.\n\nBy default, it will call snap every 0.1 second. The only positional\nparameter is taken to be the delay between snaps.\n\nPlease see the snapper module for externally starting a snapper without\nhaving to change the code. Simply adding -Msnapper as a command line\nparameter, will then start a snapper for you.\n\n  routine periods\n\n    multi sub periods( --> Seq)\n    multi sub periods(@s --> Seq)\n\nThe periods subroutine processes an array of Telemetry objects and\ngenerates a Seq of Telemetry::Period objects out of that. It is exported by\ndefault.\n\n    .<cpu wallclock>.say for periods(@t);\n\n    # OUTPUT:\n    # ====================\n    # (164 / 160)\n    # (23 / 21)\n    # (17 / 17)\n    # (15 / 16)\n    # (29 / 28)\n\n\nIf no array is specified, it will use the internal array of snap without\nparameters and will reset that array upon completion (so that new snaps can\nbe added again).\n\n    use Telemetry;\n    for ^5 {\n        snap;\n        LAST snap;\n    }\n    say .<cpu wallclock>.join(\" / \") for periods;\n\n    # OUTPUT:\n    # ====================\n    # 172 / 168\n    # 24 / 21\n    # 17 / 18\n    # 17 / 16\n    # 27 / 27\n\n\nIf only one snap was done, another snap will be done to create at least one\nTelemetry::Period object.\n\n  routine report\n\n    multi sub report(:@columns, :$legend, :$header-repeat, :$csv, :@format)\n\nThe report subroutine generates a report about an array of Telemetry\nobjects. It is exported by default. These can have been created by\nregularly calling snap, or by having a snapper running. If no positional\nparameter is used, it will assume the internal array to which the\nparameterless snap pushes.\n\nBelow are the additional named parameters of report.\n\n  * :columns\n\nSpecify the names of the columns to be included in the report. Names can be\nspecified with the column name (e.g. gw). If not specified, defaults to\nwhat is specified in the RAKUDO_REPORT_COLUMNS environment variable. If\nthat is not set either, defaults to:\n\n    wallclock util% max-rss gw gtc tw ttc aw atc\n\n\n  * :header-repeat\n\nSpecifies after how many lines the header should be repeated in the report.\nIf not specified, defaults to what is specified in the\nRAKUDO_REPORT_HEADER_REPEAT environment variable. If that is not set\neither, defaults to 32.\n\n  * :legend\n\nSpecifies whether a legend should be added to the report. If not specified,\ndefaults to what is specified in the RAKUDO_REPORT_LEGEND environment\nvariable. If that is not set either, defaults to True.\n\nIf there are snaps available in the internal array at the end of the\nprogram, then report will be automatically generated and printed on\nSTDERR.\n\n  module snapper\n\nStart a thread taking repeated system state snapshots.\n\nThis module contains no subroutines or methods or anything. It is intended\nas a shortcut for starting the snapper subroutine of the Telemetry module,\nallowing taking snapshots of the execution of a program without needing to\nchange the program. Simple loading the module with -Msnapper will do all\nthat is needed to start the snapper, and have a report printed on STDERR\nupon completion of the program.\n\nThe RAKUDO_SNAPPER environment variable can be set to indicate the time\nbetween snapshots. If not specified, it will default to 0.1 seconds.","methods":[]},{"name":"Hash","desc":"TITLE\nclass Hash\n\nSUBTITLE\nMapping from strings to itemized values\n\n    class Hash is Map { }\n\nA Hash is a mutable Map; it implements Associative through its inheritance\nof Map and as such provides support for looking up values using keys,\nproviding support for associative subscripting.\n\nAlthough the order of the hashes is guaranteed to be random in every single\ncall, still successive calls to .keys and .values are guaranteed to return\nthem in the same order:\n\n    my %orig = :1a, :2b; my %new = :5b, :6c;\n    %orig{ %new.keys } = %new.values;\n    say %orig.perl; # OUTPUT: «{:a(1), :b(5), :c(6)}␤»\n\nIn this case, b will always be associated to 5 and c to 6; even if two\nsuccessive calls to keys will return them in different order. Successive\ncalls to any of them separately and repeatedly will always return the same\norder in any program invocation.\n\nPlease see the section on hash literals for different ways to declare a\nhash. Additionally, they can be declared using curly braces as long as\nthese rules are followed:\n\n  * Empty curly braces will always declare an empty hash.\n\n  * A reference to $_ (even implicit) will instead declare a block.\n\n  * A Pair or variable with % as the first element will declare a hash.\n\n    given 3 { say WHAT {3 => 4, :b}  };     # OUTPUT: «(Hash)␤»\n    given 3 { say WHAT {3 => 4, :b($_)} };  # OUTPUT: «(Block)␤»\n    given 3 { say WHAT {3 => 4, :b(.Num)} };# OUTPUT: «(Block)␤»\n    say { 'a',:b(3), 'c' }.^name;           # OUTPUT: «Block␤»\n\n\nThe next-to-last two cases are examples of the generation of Blocks in the\npresence of the topic variable $_. The last case does not meet the third\ncriterium for generating a hash, and thus generates a Block.\n\nA % in front of parentheses or square brackets will generate a Hash as long\nas the elements can be paired.\n\n    say %( 'a', 3, :b(3), 'c', 3 ).^name; # OUTPUT: «Hash␤»\n\nElements in this hash can be paired both sides of the Pair :b(3).\n\n    say %(«a b c 1 2 3»).^name;           # OUTPUT: «Hash␤»\n\nAn empty hash can be initialized either with empty curly braces or, since\n6.d, %().\n\n    say %().^name; # OUTPUT: «Hash␤»\n    say {}.^name;  # OUTPUT: «Hash␤»\n\n","methods":["classify-list\n\nDefined as:\n\n    multi method classify-list(&mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(%mapper, *@list, :&as --> Hash:D)\n    multi method classify-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple classification\n\nIn simple classification mode, each mapper's value is any non-Iterable and\nrepresents a key to classify @list's item under:\n\n    say % .classify-list: { $_ %% 2 ?? 'even' !! 'odd' }, ^10;\n    # OUTPUT: «{even => [0 2 4 6 8], odd => [1 3 5 7 9]}␤»\n\n    my @mapper = <zero one two three four five>;\n    my %hash = foo => 'bar';\n    say %hash.classify-list: @mapper, 1, 2, 3, 4, 4;\n    # OUTPUT: «{foo => bar, four => [4 4], one => [1], three => [3], two => [2]}␤»\n\n\nThe mapper's value is used as the key of the Hash to which the @list's item\nwill be pushed. See .categorize-list if you wish to classify an item into\nmultiple categories at once.\n\n    Multi-level classification\n\nIn multi-level classification mode, each mapper's value is an Iterable that\nrepresents a tree of hash keys to classify @list's item under:\n\n    say % .classify-list: {\n        [\n            (.is-prime ?? 'prime' !! 'non-prime'),\n            ($_ %% 2   ?? 'even'  !! 'odd'      ),\n        ]\n    }, ^10;\n    # OUTPUT:\n    # {\n    #     non-prime => {\n    #         even => [0 4 6 8],\n    #         odd  => [1 9]\n    #     },\n    #     prime => {\n    #         even => [2],\n    #         odd  => [3 5 7]\n    #     }\n    # }\n\nNOTE: each of those Iterables must have the same number of elements, or the\nmethod will throw an exception. This restriction exists to avoid conflicts\nwhen the same key is a leaf of one value's classification but a node of\nanother value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .classify-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","categorize-list\n\nDefined as:\n\n    multi method categorize-list(&mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(%mapper, *@list, :&as --> Hash:D)\n    multi method categorize-list(@mapper, *@list, :&as --> Hash:D)\n\nPopulates a Hash by classifying the possibly-empty @list of values using\nthe given mapper, optionally altering the values using the :&as Callable.\nThe @list cannot be lazy.\n\nThe mapper can be a Callable that takes a single argument, an Associative,\nor an Iterable. With Associative and an Iterable mappers, the values in the\n@list represent the key and index of the mapper's value respectively. A\nCallable mapper will be executed once per each item in the @list, with that\nitem as the argument and its return value will be used as the mapper's\nvalue.\n\n    Simple categorization\n\nThe mapper's value is expected to be a possibly empty list of non-Iterables\nthat represent categories to place the value into:\n\n    say % .categorize-list: {\n        gather {\n            take 'prime'   if .is-prime;\n            take 'largish' if $_ > 5;\n            take $_ %% 2 ?? 'even' !! 'odd';\n        }\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     prime   => [2 3 5 7]\n    #     even    => [0 2 4 6 8],\n    #     odd     => [1 3 5 7 9],\n    #     largish => [6 7 8 9],\n    # }\n\nNotice how some items, e.g. 6 and 7, are present in several categories.\n\n    Multi-level categorization\n\nIn multi-level categorization, the categories produced by the mapper can\nare Iterables and categorization combines features of classify, by\nproducing nested hashes of classifications for each category.\n\n    say % .categorize-list: {\n        [\n            $_ > 5    ?? 'largish' !! 'smallish',\n            .is-prime ?? 'prime'   !! 'non-prime',\n        ],\n    }, ^10;\n\n    # OUTPUT:\n    # {\n    #     largish => {\n    #         non-prime => [6 8 9],\n    #         prime     => [7]\n    #     },\n    #     smallish => {\n    #         non-prime => [0 1 4],\n    #         prime     => [2 3 5]\n    #     }\n    # }\n\nThe mapper in above snippet produces single-item list (note the significant\ntrailing comma) with a two-item Array in it. The first item in that array\nindicates the first level of classification: the largish/smallish\ncategories the routine produces. The second item in that array indicates\nfurther levels of classification, in our case the classification into\nprime/non-prime inside of each category.\n\nNOTE: each of category Iterables must have the same number of elements, or\nthe method will throw an exception. This restriction exists to avoid\nconflicts when the same key is a leaf of one value's classification but a\nnode of another value's classification.\n\n    :&as value modifier\n\nIf :&as Callable argument is specified, it will be called once per each\nitem of @list, with the value as the argument, and its return value will be\nused instead of the original @list's item:\n\n    say % .categorize-list: :as{\"Value is $_\"}, { $_ %% 2 ?? 'even' !! 'odd' }, ^5;\n    # OUTPUT (slightly altered manually, for clarity):\n    # {\n    #     even => ['Value is 0', 'Value is 2', 'Value is 4'],\n    #     odd  => ['Value is 1', 'Value is 3']\n    # }","push\n\nDefined as:\n\n    multi method push(Hash:D: *@new)\n\nAdds the @new elements to the hash with the same semantics as hash\nassignment, but with three exceptions:\n\n  * The hash isn't emptied first, i.e. old pairs are not deleted.\n\n  * If a key already exists in the hash, and the corresponding value is an\n  Array, the new value is pushed onto the array (instead of replacing it).\n\n  * If a key already exists in the hash, and the corresponding value is not an\n  Array, old and new value are both placed into an array in the place of the\n  old value.\n\nExample:\n\n    my %h  = a => 1;\n    %h.push: (a => 1);              # a => [1,1]\n    %h.push: (a => 1) xx 3 ;        # a => [1,1,1,1,1]\n    %h.push: (b => 3);              # a => [1,1,1,1,1], b => 3\n    %h.push('c' => 4);              # a => [1,1,1,1,1], b => 3, c => 4\n    push %h, 'd' => 5;              # a => [1,1,1,1,1], b => 3, c => 4, d => 5\n\nPlease note that Pairs or colon pairs as arguments to push will be treated\nas extra named arguments and as such wont end up the Hash. The same applies\nto the sub push.\n\n    my %h .= push(e => 6);\n    push %h, f => 7;\n    say %h.perl;\n    # OUTPUT: «{}␤»\n\nAlso note that push can be used as a replacement for assignment during hash\ninitialization very useful ways. Take for instance the case of an inverted\nindex:\n\n    my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\n    (my %inv).push: %wc.invert;\n    say %inv;                     # OUTPUT: «{322 => pair, 323 => [pipe hash]}␤»\n\nNote that such an initialization could also be written as\n\n    my %wc = 'hash' => 323, 'pair' => 322, 'pipe' => 323;\n    my %inv .= push: %wc.invert;\n\nNote: Compared to append, push will add the given value as is, whereas\nappend will slip it in:\n\n    my %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\n    say %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»\n\n    my %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\n    say %hb; # OUTPUT: «{a => [42 a b c a]}␤»","append\n\nDefined as:\n\n    method append(+@values)\n\nAppend the provided Pairs or even sized list to the Hash. If a key already\nexists, turn the existing value into an Array and push new value onto that\nArray. Please note that you can't mix even sized lists and lists of Pairs.\nAlso, bare Pairs or colon pairs will be treated as named arguments to\n.append.\n\n    my %h = a => 1;\n    %h.append('b', 2, 'c', 3);\n    %h.append( %(d => 4) );\n    say %h;\n    # OUTPUT: «{a => 1, b => 2, c => 3, d => 4}␤»\n    %h.append('a', 2);\n    # OUTPUT: «{{a => [1 2], b => 2, c => 3, d => 4}␤»\n\nNote: Compared to push, append will slip in the given value, whereas push\nwill add it as is:\n\n    my %hb = :a[42, ]; %hb.append: \"a\" => <a b c a>;\n    say %hb; # OUTPUT: «{a => [42 a b c a]}␤»\n\n    my %ha = :a[42, ]; %ha.push: \"a\" => <a b c a>;\n    say %ha; # OUTPUT: «{a => [42 (a b c a)]}␤»","default\n\nDefined as:\n\n    method default()\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen a non existing key is used to access an element in the Hash. Unless\nthe Hash is declared as having a default value by using the is default\ntrait the method returns the type object (Any).\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;\n    say %h1.default;                                       # OUTPUT: «(Any)␤»\n    say %h1{'bananas'};                                    # OUTPUT: «(Any)␤»\n\n    my %h2 is default(1) = 'apples' => 3, 'oranges' => 7;\n    say %h2.default;                                       # OUTPUT: «1␤»\n    say %h2{'apples'} + %h2{'bananas'};                    # OUTPUT: «4␤»","keyof\n\nDefined as:\n\n    method keyof()\n\nReturns the type constraint for the keys of the invocant. For normal hashes\nthe method returns the coercion type (Str(Any)) while for non-string keys\nhashes the type used in the declaration of the Hash is returned.\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;  # (no key type specified)\n    say %h1.keyof;                           # OUTPUT: «(Str(Any))␤»\n\n    my %h2{Str} = 'oranges' => 7;            # (keys must be of type Str)\n    say %h2.keyof;                           # (Str)\n    %h2{3} = 'apples';                       # throws exception\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding: Type check failed in binding to key; expected Str but got Int (3)␤»\n\n    my %h3{Int};                             # (this time, keys must be of type Int)\n    %h3{42} = 4096;\n    say %h3.keyof;                           # (Int)","of\n\nDefined as:\n\n    method of()\n\nReturns the type constraint for the values of the invocant. By default,\ni.e., if no type constraint is given during declaration, the method returns\n(Mu).\n\n    my %h1 = 'apples' => 3, 'oranges' => 7;  # (no type constraint specified)\n    say %h1.of;                              # OUTPUT: «(Mu)␤»\n\n    my Int %h2 = 'oranges' => 7;             # (values must be of type Int)\n    say %h2.of;                              # OUTPUT: «(Int)␤»","dynamic\n\nDefined as:\n\n    method dynamic(--> Bool:D)\n\nReturns True if the invocant has been declared with the is dynamic trait.\n\n    my %a;\n    say %a.dynamic;                          # OUTPUT: «False␤»\n\n    my %b is dynamic;\n    say %b.dynamic;                          # OUTPUT: «True␤»\n\nIf you declare a variable with the * twigil is dynamic is implied.\n\n    my %*b;\n    say %*b.dynamic;                         # OUTPUT: «True␤»\n\nNote that in the Scalar case you have to use the VAR method in order to get\ncorrect information.\n\n    my $s is dynamic = %('apples' => 5);\n    say $s.dynamic;                   # OUTPUT: «False␤»  (wrong, don't do this)\n    say $s.VAR.dynamic;               # OUTPUT: «True␤»   (correct approach)\n\nSubscript Adverbs\n\nSome methods are implemented as adverbs on subscripts (consult the\noperators documentation for more information).\n\n  :exists\n\nThe adverb :exists returns Bool::True if a key exists in the Hash. If more\nthan one key is supplied it returns a List of Bool.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:exists;   # OUTPUT: «True␤»\n    say %h<a b>:exists; # OUTPUT: «(True True)␤»\n\n  :delete\n\nUse :delete to remove a Pair from the Hash.\n\n    my %h = a => 1;\n    say %h;         # OUTPUT: «{a => 1}␤»\n    say %h.elems;   # OUTPUT: «1␤»\n\n    %h<a>:delete;\n    say %h;         # OUTPUT: «{}␤»\n    say %h.elems;   # OUTPUT: «0␤»\n\n  :p\n\nThe adverb :p returns a Pair or a List of Pair instead of just the value.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:p;    # OUTPUT: «a => 1␤»\n    say %h<a b>:p;  # OUTPUT: «(a => 1 b=> 2)␤»\n\n  :v and :k\n\nThe adverbs :v and :k return the key or value or a list thereof.\n\n    my %h = a => 1, b => 2;\n    say %h<a>:k;    # OUTPUT: «a␤»\n    say %h<a b>:k;  # OUTPUT: «(a b)␤»\n\nThe adverb :kv returns a list of keys and values.\n\n    my %h = a => 1, b => 2, c => 3;\n    say %h<a c>:kv;  # OUTPUT: «(a 1 c 3)␤»\n\nYou can also use the adverbs without knowing anything about the hash by\nusing empty angle brackets in which case all the keys and values will be\nlisted:\n\n    my %h1 = a => 1;\n    my %h2 = a => 1, b => 2;\n    say %h1<>:k; # OUTPUT: «(a)␤»\n    say %h1<>:v; # OUTPUT: «(1)␤»\n    say %h2<>:k; # OUTPUT: «(a b)␤»\n    say %h2<>:v; # OUTPUT: «(1 2)␤»"]},{"desc":"TITLE\nclass Parameter\n\nSUBTITLE\nElement of a Signature\n\n    class Parameter { }\n\nRepresents a parameter, for purpose of introspection.\n\nThe usual way to obtain a Parameter object is to create a signature, and\ncall .params on it to obtain a list of the Parameters.\n\n    my $sig   = :(Str $x);\n    my $param = $sig.params[0];\n    say $param.type;              # OUTPUT: «Str()␤»\n\nSee Signature for more information, and also for an explanation on what\nmost of the concepts related to parameters mean.\n\n","methods":["name\n\nReturns the variable name, which includes all sigils and twigils. This name\nis used internally when applied to code, or in a declaration determines the\nname declared. This name is not necessarily usable by a caller – if it is,\nit will also appear as an alias. Often, the name will chosen descriptively\nas a form of self-documentation.\n\nIf the parameter is anonymous, Nil will be returned.","sigil\n\nDefined as:\n\n    method sigil(Parameter:D: --> Str:D)\n\nReturns a string containing the parameter's sigil, for a looser definition\nof \"sigil\" than what is considered part of the variable's name|method name.\nStill returns a sigil even if the parameter is anonymous.\n\nThis \"sigil\" is actually an introspection used to help determine the normal\nbinding style of a parameter, if it has not been altered through a trait.\n\n  Sigil  Will bind to            Default behavior\n  $      Scalar                  Generate new Scalar, use instead of Scalar in argument, if any\n  @      Positional              Bind directly to the argument\n  @      PositionalBindFailover  If binding failed, call argument's .cache method, bind to result\n  %      Associative             Bind directly to the argument\n  &      Callable                Bind directly to the argument\n  \\      (anything)              Bind directly to the argument, keep existing Scalar, if any\n\n\nAlso, | will bind to all remaining arguments and make new Capture if\nneeded.","type\n\nReturns the nominal type constraint of the parameter.","coerce_type\n\nReturns the coercion type of the parameter.","constraints\n\nReturns additional constraints on the parameter (usually as an\nall-Junction).","named\n\nDefined as:\n\n    method named(Parameter:D: --> Bool:D)\n\nReturns True if it's a named parameter.\n\n    my Signature $sig = :(Str $x, Bool :$is-named);\n    say $sig.params[0].named;                          # OUTPUT: «False␤»\n    say $sig.params[1].named;                          # OUTPUT: «True␤»","named_names\n\nDefined as:\n\n    method named_names(Parameter:D: --> List:D)\n\nReturns the list of externally usable names/aliases for a named parameter.","positional\n\nDefined as:\n\n    method positional(Parameter:D: --> Bool:D)\n\nReturns True if the parameter is positional.\n\n    my Signature $sig = :(Str $x, Bool :$is-named);\n    say $sig.params[0].positional;                     # OUTPUT: «True␤»\n    say $sig.params[1].positional;                     # OUTPUT: «False␤»","slurpy\n\nDefined as:\n\n    method slurpy(Parameter:D: --> Bool:D)\n\nReturns True for slurpy parameters.","twigil\n\nDefined as:\n\n    method twigil(Parameter:D: --> Str:D)\n\nReturns a string containing the twigil part of the parameter's name.","optional\n\nDefined as:\n\n    method optional(Parameter:D: --> Bool:D)\n\nReturns True for optional parameters.","raw\n\nDefined as:\n\n    method raw(Parameter:D: --> Bool:D)\n\nReturns True for raw parameters.\n\n    sub f($a, $b is raw, \\c) {\n        my $sig = &?ROUTINE.signature;\n        for ^$sig.params.elems {\n            say $sig.params[$_].raw;\n        }\n    }\n    f(17, \"4711\", 42); OUTPUT: «False␤True␤True␤»\n\nRaw parameters bind either a variable or a value passed to it, with no\ndecontainerization taking place. That means that if a variable was passed\nto it, you can assign to the parameter. This is different from rw-parameter\nwhich can only bind to variables, never to values.\n\nThis is the normal behavior for parameters declared with a sigil of '\\',\nwhich is not really a sigil insofar as it is only used on the parameter.\n\n    sub f(\\x) {\n        x = 5;\n    }\n    f(my $x);   # works\n    f(42);      # dies\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»\n\nOther parameters may become raw through use of the 'is raw' trait. These\nstill use their sigil in code.\n\n    sub f($x is raw) {\n        $x = 5;\n    }","capture\n\nDefined as:\n\n    method capture(Parameter:D: --> Bool:D)\n\nReturns True for parameters that capture the rest of the argument list into\na single Capture object.\n\n    sub how_many_extra_positionals($!, |capture) { capture.elems.say }\n    how_many_extra_positionals(0, 1, 2, 3);                        # RESULT: «3»\n    say &how_many_extra_positionals.signature.params[1].capture;   # OUTPUT: «True␤»\n\nLike raw parameters, Capture parameters do not force any context on the\nvalues bound to them, which is why their sigils are only used in\ndeclarations.","rw\n\nDefined as:\n\n    method rw(Parameter:D: --> Bool:D)\n\nReturns True for is rw parameters.\n\n    my Signature $sig = :(Str $x is rw, Bool :$is-named);\n    say $sig.params[0].rw;                             # OUTPUT: «True␤»\n    say $sig.params[1].rw;                             # OUTPUT: «False␤»","copy\n\nDefined as:\n\n    method copy(Parameter:D: --> Bool:D)\n\nReturns True for is copy parameters.\n\n    my Signature $sig = :(Str $x, Bool :$is-named is copy);\n    say $sig.params[0].copy;                           # OUTPUT: «False␤»\n    say $sig.params[1].copy;                           # OUTPUT: «True␤»","readonly\n\nDefined as:\n\n    method readonly(Parameter:D: --> Bool:D)\n\nReturns True for read-only parameters (the default).\n\n    my Signature $sig = :(Str $x is rw, Bool :$is-named);\n    say $sig.params[0].readonly;                       # OUTPUT: «False␤»\n    say $sig.params[1].readonly;                       # OUTPUT: «True␤»","invocant\n\nDefined as:\n\n    method invocant(Parameter:D: --> Bool:D)\n\nReturns True if the parameter is the invocant parameter.","default\n\nReturns a closure that upon invocation returns the default value for this\nparameter, or Any if no default was provided.","type_captures\n\nDefined as:\n\n    method type_captures(Parameter:D: --> List:D)\n\nReturns a list of variable names of type captures associated with this\nparameter. Type captures define a type name within the attached code, which\nis an alias to the type gleaned from the argument during a call.\n\n    sub a(::T ::U $x) { T.say }\n    a(8);                                       # OUTPUT: «(Int)␤»\n    say &a.signature.params[0].type_captures;   # OUTPUT: «(T U)␤»\n    sub b($x) { $x.^name.say }\n    a(8);                                       # OUTPUT: «Int␤»\n\nThe type used may change from call to call. Once they are defined, type\ncaptures can be used wherever you would use a type, even later in same the\nsignature:\n\n    sub c(::T $x, T $y, $z) { my T $zz = $z };\n    c(4, 5, 6);          # OK\n    c(4, 5, \"six\");      # Fails when assigning to $zz, wants Int not Str\n    c(\"four\", 5, \"six\"); # Fails when binding $y, wants Str, not Int\n\n\nType captures may be used at the same time as type constraints.\n\n    sub d(::T Numeric $x, T $y) {};\n    d(4, 5);            # OK\n    d(4e0, 5e0);        # OK\n    d(4e0, 5);          # Fails when binding $y\n    d(\"four\", \"five\");  # Fails when binding $x","sub_signature\n\nIf the parameter has a sub-signature, returns a Signature object for it.\nOtherwise returns Any.\n\nRuntime creation of Parameter objects (6.d, 2019.03 and later)\n\n    Parameter.new( ... )\n\nIn some situations, specifically when working with the MetaObject Protocol,\nit makes sense to create Parameter objects programmatically. For this\npurpose, you can call the new method with the following named parameters:\n\n  * name\n\nOptional. The name of the variable, if any. Can be specified in the same\nway as in a Signature. So it may contain specific additional information,\nsuch as a sigil ($, @, % or &), a : prefix to indicate a named parameter, a\ntwigil (. or !) to indicate public / private attribute binding, a postfix !\nor ? to indicate an optional / mandatory parameter, and the various\ncombinations of +, *, ** prefixes to indicate slurpiness types and | to\nindicate a Capture.\n\n  * type\n\nOptional. The type of the parameter. Assumes Any if not specified.\n\n  * default\n\nOptional. The value of the parameter if the parameter is optional and no\nargument has been given for that parameter. Assumes not initialization if\nno argument has been given, which would fall back to the (implicit) type of\nthe parameter.\n\n  * where\n\nOptional. Additional constraints to be applied to any argument to match\nwith this parameter. Does not set any additional constraints by default.\n\n  * is-copy\n\nOptional. Allows one to set the \"is copy\" flag on the parameter. Does not\nset the flag by default.\n\n  * is-raw\n\nOptional. Allows one to set the \"is raw\" flag on the parameter. Does not\nset the flag by default.\n\n  * is-rw\n\nOptional. Allows one to set the \"is rw\" flag on the parameter. Does not set\nthe flag by default.\n\n  * named\n\nOptional. Indicates whether the parameter is a named parameter or not.\nShould only be specified if the : prefix is not specified in the name and a\nnamed parameter is required.\n\n  * optional\n\nOptional. Indicates whether the parameter is optional or not. Should only\nbe specified if the ? postfix is not specified in the name and an optional\nparameter is required.\n\n  * mandatory\n\nOptional. Indicates whether the parameter is mandatory or not. Should only\nbe specified if the ! postfix is not specified in the name and a mandatory\nparameter is required.\n\n  * multi-invocant\n\nOptional. Indicates whether the parameter should be considered in\nmulti-dispatch or not. Defaults to True, so one would need to do\n:!multi-invocant to make the parameter not be considered in\nmulti-dispatch.\n\n  * sub-signature\n\nOptional. Specifies any Signature that should be applied to the parameter\nto deconstruct it. By default, no signature is to be applied."],"name":"Parameter"},{"name":"ForeignCode","methods":["."],"desc":"TITLE\nclass ForeignCode\n\nSUBTITLE\nRakudo-specific class that wraps around code in other languages (generally\nNQP)\n\n    class ForeignCode does Callable {}\n\nThis is a Rakudo specific class, and as such it is advisable not to use it\nin your own code, since its interface might change or even disappear in the\nfuture. This is provided here only as a reference\n\nForeignCode is a Raku wrapper around code that is not written originally in\nthat language; its intention is to use these blocks of code in Callable\ncontexts easily. For instance, subs have some anonymous functions that are\nactually ForeignCode.\n\n    sub does-nothing(){};\n    say $_.name ~ ' → ' ~ $_.^name for &does-nothing.^methods;\n    # OUTPUT: «<anon> → ForeignCode␤<anon> → ForeignCode␤soft → Method␤…»\n\n\nThis script will map method names to their class, and it shows that\nroutines, in particular, have several methods that are actually ForeignCode\ninstead of "},{"name":"Setty","methods":["new-from-pairs\n\nDefined as:\n\n    method new-from-pairs(*@pairs --> Setty:D)\n\nConstructs a Setty object from a list of Pair objects given as positional\narguments:\n\n    say Set.new-from-pairs: 'butter' => 0.22, 'salt' => 0, 'sugar' => 0.02;\n    # OUTPUT: «set(butter, sugar)␤»\n\nNote: be sure you aren't accidentally passing the Pairs as positional\narguments; the quotes around the keys in the above example are\nsignificant.","grab\n\n    method grab($count = 1)\n\nRemoves and returns $count elements chosen at random (without repetition)\nfrom the set.\n\nIf * is passed as $count, or $count is greater than or equal to the size of\nthe set, then all its elements are removed and returned in random order.\n\nOnly works on mutable sets; When used on an immutable set, it results in an\nexception.","grabpairs\n\n    method grabpairs($count = 1)\n\nRemoves $count elements chosen at random (without repetition) from the set,\nand returns a list of Pair objects whose keys are the grabbed elements and\nwhose values are True.\n\nIf * is passed as $count, or $count is greater than or equal to the size of\nthe set, then all its elements are removed and returned as Pairs in the\naforementioned way in random order.\n\nOnly works on mutable sets; When used on an immutable set, it results in an\nexception.","pick\n\n    multi method pick($count = 1)\n\nReturns $count elements chosen at random (without repetition) from the\nset.\n\nIf * is passed as $count, or $count is greater than or equal to the size of\nthe set, then all its elements are returned in random order (shuffled).","pickpairs\n\nDefined as:\n\n    multi method pickpairs(Setty:D: --> Pair:D)\n    multi method pickpairs(Setty:D: $count --> Seq:D)\n\nReturns a Pair or a Seq of Pairs depending on the candidate of the method\nbeing invoked. Each Pair returned has an element of the invocant as its key\nand True as its value. In contrast to grabpairs, the elements are 'picked'\nwithout replacement.\n\nIf * is passed as $count, or $count is greater than or equal to the number\nof elements of the invocant, then all element/True Pairs from the invocant\nare returned in a random sequence; i.e. they are returned shuffled;\n\nNote that each pickpairs invocation maintains its own private state and has\nno effect on subsequent pickpairs invocations.\n\n    my $numbers = set (4, 2, 3);\n    say $numbers.pickpairs;                           # OUTPUT: «4 => True␤»\n    say $numbers.pickpairs(1);                        # OUTPUT: «(3 => True)␤»\n    say $numbers.pickpairs(*);                        # OUTPUT: «(2 => True 4 => True 3 => True)␤»","roll\n\n    multi method roll($count = 1)\n\nReturns a lazy list of $count elements, each randomly selected from the\nset. Each random choice is made independently, like a separate die roll\nwhere each die face is a set element.\n\nIf * is passed as $count, the list is infinite.","antipairs\n\nDefined as:\n\n    multi method antipairs(Setty:D: --> Seq:D)\n\nReturns all elements in the set and True as a Seq of Pairs, where the\nelement itself is the value, i.e. the opposite of method pairs.\n\n    my $s = Set.new(1, 2, 3, 1);\n    say $s.antipairs.sort;                            # OUTPUT: «(True => 1 True => 2 True => 3)␤»","keys\n\nDefined as:\n\n    multi method keys(Setty:D: --> Seq:D)\n\nReturns a Seq of all elements of the set.\n\n    my $s = Set.new(1, 2, 3);\n    say $s.keys;                                      # OUTPUT: «(3 1 2)␤»","values\n\nDefined as:\n\n    multi method values(Setty:D: --> Seq:D)\n\nReturns a Seq containing as many True values as the set has elements.\n\n    my $s = Set.new(1, 2, 3);\n    say $s.values;                                    # OUTPUT: «(True True True)␤»","kv\n\nDefined as:\n\n    multi method kv(Setty:D: --> Seq:D)\n\nReturns a Seq of the set's elements and True values interleaved.\n\n    my $s = Set.new(1, 2, 3);\n    say $s.kv;                                        # OUTPUT: «(3 True 1 True 2 True)␤»","elems\n\n    method elems(--> Int)\n\nThe number of elements of the set.","total\n\n    method total(--> Int)\n\nThe total of all the values of the QuantHash object. For a Setty object,\nthis is just the number of elements.","minpairs\n\nDefined As:\n\n    multi method minpairs(Setty:D: --> Seq:D)\n\nReturns the value of self.pairs (as all Pairs have minimum values). See\nalso Any.minpairs","maxpairs\n\nDefined As:\n\n    multi method maxpairs(Setty:D: --> Seq:D)\n\nReturns the value of self.pairs (as all Pairs have maximum values). See\nalso Any.maxpairs","default\n\nDefined as:\n\n    method default(--> False)\n\nReturns the default value of the invocant, i.e. the value which is returned\nwhen trying to access an element in the Setty object which has not been\npreviously initialized or when accessing an element which has explicitly\nbeen set to Nil or False.\n\n    my $s1 = SetHash.new(1, 2, 3);\n    say $s1{2};                                           # OUTPUT: «True␤»\n    $s1{2} = Nil;\n    say $s1{2};                                           # OUTPUT: «False␤»\n    # access non initialized element\n    say $s1{4};                                           # OUTPUT: «False␤»","ACCEPTS\n\n    method ACCEPTS($other)\n\nReturns True if $other and self contain all the same elements, and no\nothers.","Bag\n\nDefined as:\n\n    method Bag(Setty:D: --> Bag:D)\n\nReturns a Bag containing the elements of the invocant.\n\n    my Bag $b = Set.new(1, 2, 3).Bag;\n    say $b;                                           # OUTPUT: «bag(3, 1, 2)␤»","BagHash\n\nDefined as:\n\n    method BagHash(Setty:D: --> BagHash:D)\n\nReturns a BagHash containing the elements of the invocant.\n\n    my BagHash $b = Set.new(1, 2, 3).BagHash;\n    say $b;                                           # OUTPUT: «BagHash.new(3, 1, 2)␤»","Bool\n\nDefined as:\n\n    multi method Bool(Setty:D: --> Bool:D)\n\nReturns True if the invocant contains at least one element.\n\n    my $s1 = Set.new(1, 2, 3);\n    say $s1.Bool;                                     # OUTPUT: «True␤»\n\n    my $s2 = $s1 ∩ Set.new(4, 5);                     # set intersection operator\n    say $s2.Bool;                                     # OUTPUT: «False␤»","Mix\n\nDefined as:\n\n    method Mix(Setty:D: --> Mix:D)\n\nReturns a Mix containing the elements of the invocant.\n\n    my Mix $b = Set.new(1, 2, 3).Mix;\n    say $b;                                           # OUTPUT: «mix(3, 1, 2)␤»","MixHash\n\nDefined as:\n\n    method MixHash(Setty:D: --> MixHash:D)\n\nReturns a MixHash containing the elements of the invocant.\n\n    my MixHash $b = Set.new(1, 2, 3).MixHash;\n    say $b;                                           # OUTPUT: «MixHash.new(3, 1, 2)␤»\n\nSee Also\n\nSets, Bags, and Mixes"],"desc":"TITLE\nrole Setty\n\nSUBTITLE\nCollection of distinct objects\n\n    role Setty does QuantHash { }\n\nA role for collections which make sure that each element can only appear\nonce. See Set and SetHash.\n\n"},{"methods":["Note From version 6.d, .perl can be called on CallFrame.","code\n\n    method code()\n\nReturn the callable code for the current block. When called on the object\nreturned by callframe(0), this will be the same value found in &?BLOCK.\n\n    my $frame;\n    for ^3 { FIRST $frame = callframe; say $_ * 3 };\n    say $frame.code()\n\n\nThe $frame variable will hold the Code for the block inside the loop in\nthis case.","file\n\n    method file()\n\nThis is a shortcut for looking up the file annotation. Therefore, the\nfollowing code prints True.\n\n    my $frame = callframe(0);\n    say $frame.file eq $frame.annotations<file>;","line\n\n    method line()\n\nThis is a shortcut for looking up the line annotation. For example, the\nfollowing two calls are identical.\n\n    say callframe(1).line;\n    say callframe(1).annotations<line>;","annotations\n\n    method annotations()\n\nReturns a Map containing the invocants annotations, i.e. line and file. An\neasier way to get hold of the annotation information is to use one of the\nconvenience methods instead.\n\n    say callframe.annotations.^name;                   # OUTPUT: «Map␤»\n    say callframe.annotations<file> eq callframe.file; # OUTPUT: «True␤»","my\n\n    method my()\n\nReturn a Hash that names all the variables and their values associated with\nthe lexical scope of the frame.\n\n    sub some-value {\n        my $the-answer = 42;\n        callframe(0);\n    }\n\n    my $frame = some-value();\n    say $frame.my<$the-answer>; # OUTPUT: «42␤»\n\nRoutines\n\n  sub callframe\n\n    sub callframe(Int:D $level = 0)\n\nReturns a CallFrame object for the given level. If no level is given, the\ndefault level is 0. Positive levels move up the frame stack and negative\nlevels move down (into the call to callframe and deeper).\n\nReturns Mu if there is no call information for the given level. Negative\nlevels may result in an exception."],"desc":"TITLE\nclass CallFrame\n\nSUBTITLE\nCaptures the current frame state\n\n    class CallFrame {}\n\nA CallFrame will be usually captured from the current state of a program\nusing the callframe subroutine.\n\n    my $frame = callframe;\n    say \"The above line of code ran at {$frame.file}:{$frame.line}.\";\n\nWith no arguments the callframe will give you frame information for the\nline calling callframe. The file and line annotations will be identical to\nthose in $?FILE and $?LINE.\n\nYou may, however, pass a number to callframe to specify a different frame\nlevel. A positive number will move upward through the levels of frame. A\nnegative number will move downward into the callframe method and class\nitself at the point at which they are running to construct this information\nfor you.\n\nThe frames themselves do not necessarily match only method or subroutine\ncalls. Perl constructs a frames for blocks and such as well, so if you need\na callframe for a particular method call, do not assume it is a fixed\nnumber of levels up.\n\nEach frame stores annotations, including the file and line annotations,\nwhich have convenience methods for accessing them directly. You can also\nretrieve a reference to the code block of the currently executing frame\nusing the code method. The frame also captures all lexical variables stored\nwith the frame, which are available by calling my on the frame object.\n\nHere's a short example that will find the calling routine and print the\npackage of the caller using the callframe interface.\n\n    sub calling-frame() {\n        for 1..* -> $level {\n            given callframe($level) -> $frame {\n                when $frame ~~ CallFrame {\n                        next unless $frame.code ~~ Routine;\n                        say $frame.code.package;\n                        last;\n                }\n                default {\n                        say \"no calling routine or method found\";\n                        last;\n                }\n            }\n        }\n    }\n\n    calling-frame;\n\nIf you just need to trace caller information, Backtrace may provide a\nbetter means of getting it. CallFrame contains more information about a\nspecific frame, but provides a tedious interface for enumerating a call\nstack.\n\n","name":"CallFrame"},{"desc":"TITLE\nclass WhateverCode\n\nSUBTITLE\nCode object constructed by Whatever-currying\n\n    class WhateverCode is Code { }\n\nWhateverCode objects are the result of Whatever-currying. See the Whatever\ndocumentation for details.\n\nWhen you wish to control how a method or function interprets any Whatever\nstar, you may use multi dispatch with Whatever and WhateverCode parameters\nto do so, as in the following example:\n\n    class Cycle {\n          has $.pos;\n          has @.vals;\n    }\n\n    multi sub get-val(Cycle $c, Int $idx) {\n          $c.vals[$idx % $c.vals.elems]\n    }\n\n    # Define what to do with a stand-alone * as the second argument\n    multi sub get-val(Cycle $c, Whatever $idx) {\n        get-val($c, $c.pos);\n    }\n\n    # Define what to do with a * WhateverCode in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx) {\n        get-val($c, $idx($c.pos));\n    }\n\n    my Cycle $c .= new(:pos(2), :vals(0..^10));\n\n    say get-val($c, 3);   # OUTPUT: «3␤»\n    say get-val($c, *);   # OUTPUT: «2␤»\n    say get-val($c, *-1); # OUTPUT: «1␤»\n\nThe WhateverCode does the Callable role, so it should be possible to\nintrospect the type of Callable it contains; for instance, continuing the\nprevious example, we can add a multi that handles a WhateverCode with two\narguments via checking the signature:\n\n    # Define what to do with two * in an expression\n    multi sub get-val(Cycle $c, WhateverCode $idx where { .arity == 2 }) {\n        get-val($c, $idx($c.pos, $c.vals.elems));\n    }\n\n    say get-val($c, * + * div 2); # 2 + 10/2 = 7\n\n\nNote, though, that subexpressions may impose their own Whatever star\nrules:\n\n    my @a = (0, 1, 2);\n    say get-val($c, @a[*-1]) # 2, because the star belongs to the Array class\n\n\nThis can make the ownership of Whatever stars become confusing rather\nquickly, so be careful not to overdo it.\n\nYou may instead type-constrain using Callable type in order to accept any\nCallable, including WhateverCode:\n\n    sub run-with-rand (Callable $code) { $code(rand) };\n    run-with-rand *.say;           # OUTPUT: «0.773672071688484␤»\n    run-with-rand {.say};          # OUTPUT: «0.38673179353983␤»\n    run-with-rand sub { $^v.say }; # OUTPUT: «0.0589543603685792␤»\n\nType-constraining with &-sigiled parameter works equally well and is\nshorter to type:\n\n    sub run-with-rand (&code) { code time };","methods":[],"name":"WhateverCode"},{"name":"Collation","desc":"TITLE\nclass Collation\n\nSUBTITLE\nEncapsulates how strings are sorted\n\n    class Collation { }\n\n\nCollation is the class that allows proper sorting, taking into account all\nUnicode characteristics. It's the class the object $*COLLATION is\ninstantiated to, and thus includes collation levels, that is, what kind of\nfeatures should be looked up when comparing two strings and in which\norder.\n\n","methods":["Method set\n\nDefined as:\n\n    method set (\n        Int :$primary    = 1,\n        Int :$secondary  = 1,\n        Int :$tertiary   = 1,\n        Int :$quaternary = 1)\n\n\nSets if the different levels should be used in ascending or descending\norder, or if they are going to be ignored (when set to 0).\n\n    my $*COLLATION = Collation.new;\n    say 'a' coll 'z'; # OUTPUT: «Less»\n    $*COLLATION.set(:primary(-1));\n    say 'a' coll 'z'; # OUTPUT: «More»","primary\n\nDefined as:\n\n    method primary\n\nReturns the state of the primary collation level.","secondary\n\nDefined as:\n\n    method secondary\n\nReturns the state of the secondary collation level.","tertiary\n\nDefined as:\n\n    method tertiary\n\nReturns the state of the tertiary collation level.","quaternary\n\nDefined as:\n\n    method quaternary\n\nReturns the state of the quaternary collation level."]},{"methods":["send\n\nDefined as:\n\n    method send(Channel:D: \\item)\n\nEnqueues an item into the Channel. Throws an exception of type\nX::Channel::SendOnClosed if the channel has been closed already. This call\nwill not block waiting for a consumer to take the object. There is no set\nlimit on the number of items that may be queued, so care should be taken to\nprevent runaway queueing.\n\n    my $c = Channel.new;\n    $c.send(1);\n    $c.send([2, 3, 4, 5]);\n    $c.close;\n    say $c.list; # OUTPUT: «(1 [2 3 4 5])␤»","receive\n\nDefined as:\n\n    method receive(Channel:D:)\n\nReceives and removes an item from the channel. It blocks if no item is\npresent, waiting for a send from another thread.\n\nThrows an exception of type X::Channel::ReceiveOnClosed if the channel has\nbeen closed, and the last item has been removed already, or if close is\ncalled while receive is waiting for an item to arrive.\n\nIf the channel has been marked as erratic with method fail, and the last\nitem has been removed, throws the argument that was given to fail as an\nexception.\n\nSee method poll for a non-blocking version that won't throw exceptions.\n\n    my $c = Channel.new;\n    $c.send(1);\n    say $c.receive; # OUTPUT: «1␤»","poll\n\nDefined as:\n\n    method poll(Channel:D:)\n\nReceives and removes an item from the channel. If no item is present,\nreturns Nil instead of waiting.\n\n    my $c = Channel.new;\n    Promise.in(2).then: { $c.close; }\n    ^10 .map({ $c.send($_); });\n    loop {\n        if $c.poll -> $item { $item.say };\n        if $c.closed  { last };\n        sleep 0.1;\n    }\n\nSee method receive for a blocking version that properly responds to channel\nclosing and failure.","close\n\nDefined as:\n\n    method close(Channel:D:)\n\nClose the Channel, normally. This makes subsequent send calls die with\nX::Channel::SendOnClosed. Subsequent calls of .receive may still drain any\nremaining items that were previously sent, but if the queue is empty, will\nthrow an X::Channel::ReceiveOnClosed exception. Since you can produce a Seq\nfrom a Channel by contextualizing to array with @() or by calling the .list\nmethod, these methods will not terminate until the channel has been closed.\nA whenever-block will also terminate properly on a closed channel.\n\n    my $c = Channel.new;\n    $c.close;\n    $c.send(1);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n\n\nPlease note that any exception thrown may prevent .close from being called,\nthis may hang the receiving thread. Use a LEAVE phaser to enforce the\n.close call in this case.","list\n\nDefined as:\n\n    method list(Channel:D: --> List:D)\n\nReturns a list based on the Seq which will iterate items in the queue and\nremove each item from it as it iterates. This can only terminate once the\nclose method has been called.\n\n    my $c = Channel.new; $c.send(1); $c.send(2);\n    $c.close;\n    say $c.list; # OUTPUT: «(1 2)␤»","closed\n\nDefined as:\n\n    method closed(Channel:D: --> Promise:D)\n\nReturns a promise that will be kept once the channel is closed by a call to\nmethod close.\n\n    my $c = Channel.new;\n    $c.closed.then({ say \"It's closed!\" });\n    $c.close;\n    sleep 1;","fail\n\nDefined as:\n\n    method fail(Channel:D: $error)\n\nCloses the Channel (that is, makes subsequent send calls die), and enqueues\nthe error to be thrown as the final element in the channel. Method receive\nwill throw that error as an exception. Does nothing if the channel has\nalready been closed or .fail has already been called on it.\n\n    my $c = Channel.new;\n    $c.fail(\"Bad error happens!\");\n    $c.receive;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::AdHoc: Bad error happens!␤»","Capture\n\nDefined as:\n\n    method Capture(Channel:D --> Capture:D)\n\nEquivalent to calling .List.Capture on the invocant.","Supply\n\nDefined as:\n\n    method Supply(Channel:D:)\n\nThis returns an on-demand Supply that emits a value for every value\nreceived on the Channel. done will be called on the Supply when the Channel\nis closed.\n\n    my $c = Channel.new;\n    my Supply $s1 = $c.Supply;\n    my Supply $s2 = $c.Supply;\n    $s1.tap(-> $v { say \"First $v\" });\n    $s2.tap(-> $v { say \"Second $v\" });\n    ^10 .map({ $c.send($_) });\n    sleep 1;\n\nMultiple calls to this method produce multiple instances of Supply, which\ncompete over the values from the Channel.\n\n  sub await\n\nDefined as:\n\n    multi sub await(Channel:D)\n    multi sub await(*@)\n\nWaits until all of one or more channels has a value available, and returns\nthose values (it calls .receive on the channel). Also works with promises.\n\n    my $c = Channel.new;\n    Promise.in(1).then({$c.send(1)});\n    say await $c;\n\nSince 6.d, it no longer blocks a thread while waiting."],"desc":"TITLE\nclass Channel\n\nSUBTITLE\nThread-safe queue for sending values from producers to consumers\n\n    class Channel {}\n\nA Channel is a thread-safe queue that helps you to send a series of objects\nfrom one or more producers to one or more consumers. Each object will\narrive at only one such consumer, selected by the scheduler. If there is\nonly one consumer and one producer, the order of objects is guaranteed to\nbe preserved. Sending on a Channel is non-blocking.\n\n    my $c = Channel.new;\n    await (^10).map: {\n        start {\n            my $r = rand;\n            sleep $r;\n            $c.send($r);\n        }\n    }\n    $c.close;\n    say $c.list;\n\nFurther examples can be found in the concurrency page\n\n","name":"Channel"},{"methods":[],"desc":"TITLE\nclass Block\n\nSUBTITLE\nCode object with its own lexical scope\n\n    class Block is Code { }\n\nA Block is a code object meant for small-scale code reuse. A block is\ncreated syntactically by a list of statements enclosed in curly braces.\n\nWithout an explicit signature or placeholder arguments, a block has $_ as a\npositional argument\n\n    my $block = { uc $_; };\n    say $block.^name;           # OUTPUT: «Block␤»\n    say $block('hello');        # OUTPUT: «HELLO␤»\n\nA block can have a Signature between ->  or <->  and the block:\n\n    my $add = -> $a, $b = 2 { $a + $b };\n    say $add(40);               # OUTPUT: «42␤»\n\nIf the signature is introduced with <-> , then the parameters are marked as\nrw by default: \n\n    my $swap = <-> $a, $b { ($a, $b) = ($b, $a) };\n    my ($a, $b) = (2, 4);\n    $swap($a, $b);\n    say $a;                     # OUTPUT: «4␤»\n\nBlocks that aren't of type Routine (which is a subclass of Block) are\ntransparent to return.\n\n    sub f() {\n        say <a b c>.map: { return 42 };\n                       #   ^^^^^^   exits &f, not just the block\n    }\n\nThe last statement is the implicit return value of the block.\n\n    say {1}.(); # OUTPUT: «1␤»\n\nBare blocks are automatically executed in the order they appear:\n\n    say 1;                # OUTPUT: «1␤»\n    {\n        say 2;            # OUTPUT: «2␤»; executed directly, not a Block object\n    }\n    say 3;                # OUTPUT: «3␤»","name":"Block"},{"desc":"TITLE\nclass NFC\n\nSUBTITLE\nCodepoint string in Normal Form C (composed)\n\n    class NFC is Uni {}\n\nA Codepoint string in Unicode Normalization Form C. It is created by\nCanonical Decomposition, followed by Canonical Composition. For more\ninformation on what this means, see Unicode TR15.","methods":[],"name":"NFC"},{"name":"MixHash","methods":["Bag\n\nDefined as:\n\n    method Bag (--> Bag:D)\n\nCoerces the MixHash to a Bag. The weights are converted to Int, which means\nthe number of keys in the resulting Bag can be fewer than in the original\nMixHash, if any of the weights are negative or truncate to zero.","BagHash\n\nDefined as:\n\n    method BagHash (--> BagHash:D)\n\nCoerces the MixHash to a BagHash. The weights are converted to Int, which\nmeans the number of keys in the resulting BagHash can be fewer than in the\noriginal MixHash, if any of the weights are negative or truncate to zero.\n\nNote on reverse and ordering\n\nThis method is inherited from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nSee Also\n\nSets, Bags, and Mixes"],"desc":"TITLE\nclass MixHash\n\nSUBTITLE\nMutable collection of distinct objects with Real weights\n\n    class MixHash does Mixy { }\n\nA MixHash is a mutable mix, meaning a collection of distinct elements in no\nparticular order that each have a real-number weight assigned to them. (For\nimmutable mixes, see Mix instead.)\n\nObjects/values of any type are allowed as mix elements. Within a MixHash,\nitems that would compare positively with the === operator are considered\nthe same element, with a combined weight.\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe.elems;      # OUTPUT: «3␤»\n    say $recipe.keys.sort;  # OUTPUT: «butter flour sugar␤»\n    say $recipe.pairs.sort; # OUTPUT: «\"butter\" => 0.22 \"flour\" => 0.275 \"sugar\" => 0.12␤»\n    say $recipe.total;      # OUTPUT: «0.615␤»\n\n\nMixHashes can be treated as object hashes using the { } postcircumfix\noperator, which returns the corresponding numeric weight for keys that are\nelements of the mix, and 0 for keys that aren't. It can also be used to\nmodify weights; Setting a weight to 0 automatically removes that element\nfrom the mix, and setting a weight to a non-zero number adds that element\nif it didn't already exist:\n\n    my $recipe = (butter => 0.22, sugar => 0.1,\n                  flour => 0.275, sugar => 0.02).MixHash;\n\n    say $recipe<butter>;     # OUTPUT: «0.22␤»\n    say $recipe<sugar>;      # OUTPUT: «0.12␤»\n    say $recipe<chocolate>;  # OUTPUT: «0␤»\n\n    $recipe<butter> = 0;\n    $recipe<chocolate> = 0.30;\n    say $recipe.pairs;       # OUTPUT: «\"sugar\" => 0.12 \"flour\" => 0.275 \"chocolate\" => 0.3␤»\n\n\nCreating MixHash objects\n\nMixHashes can be composed using MixHash.new. Any positional parameters,\nregardless of their type, become elements of the mix - with a weight of 1\nfor each time the parameter occurred:\n\n    my $n = MixHash.new: \"a\", \"a\", \"b\" => 0, \"c\" => 3.14;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Pair) (Pair))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 (c => 3.14) => 1 (b => 0) => 1)␤»\n\nAlternatively, the .MixHash coercer (or its functional form, MixHash()) can\nbe called on an existing object to coerce it to a MixHash. Its semantics\ndepend on the type and contents of the object. In general it evaluates the\nobject in list context and creates a mix with the resulting items as\nelements, although for Hash-like objects or Pair items, only the keys\nbecome elements of the mix, and the (cumulative) values become the\nassociated numeric weights:\n\n    my $n = (\"a\", \"a\", \"b\" => 0, \"c\" => 3.14).MixHash;\n    say $n.keys.map(&WHAT);  # OUTPUT: «((Str) (Str))␤»\n    say $n.pairs;            # OUTPUT: «(a => 2 c => 3.14)␤»\n\nSince 6.d (2019.03 and later) it is also possible to specify the type of\nvalues you would like to allow in a MixHash. This can either be done when\ncalling .new:\n\n    # only allow strings\n    my $n = MixHash[Str].new: <a b b c c c>;\n\nor using the masquerading syntax:\n\n    # only allow strings\n    my %mh is MixHash[Str] = <a b b c c c>;\n    say %mh<b>;  # 2\n    say %mh<d>;  # 0\n\n    # only allow whole numbers\n    my %mh is MixHash[Int] = <a b b c c c>;\n    # Type check failed in binding; expected Int but got Str (\"a\")\n\nOperators\n\n    my ($a, $b) = MixHash(2 => 2, 4), MixHash(2 => 1.5, 3 => 2, 4);\n\n    say $a (<) $b;   # OUTPUT: «False␤»\n    say $a (<+) $b;  # OUTPUT: «False␤»\n    say $a (^) $b;   # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a (+) $b;   # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n    # Unicode versions:\n    say $a ⊂ $b;  # OUTPUT: «False␤»\n    say $a ≼ $b;  # OUTPUT: «False␤»\n    say $a ⊖ $b;  # OUTPUT: «Mix(2(0.5), 3(2))␤»\n    say $a ⊎ $b;  # OUTPUT: «Mix(2(3.5), 4(2), 3(2))␤»\n\n\nSee Set/Bag Operators for a complete list of set and bag operators with\ndetailed explanations.\n\nNote on reverse and ordering.\n\nMixHash inherits reverse from Any, however, Mixes do not have an inherent\norder and you should not trust it returning a consistent output.\n\nIf you sort a MixHash, the result is a list of pairs, at which point\nreverse makes perfect sense:\n\n    my $a = MixHash.new(2, 2, 18, 3, 4);\n    say $a;  # OUTPUT: «MixHash(18, 2(2), 3, 4)␤»\n\n    say $a.sort;  # OUTPUT: «(2 => 2 3 => 1 4 => 1 18 => 1)␤»\n    say $a.sort.reverse;  # OUTPUT: «(18 => 1 4 => 1 3 => 1 2 => 2)␤»\n\n\n"},{"methods":["list\n\nDefined as:\n\n    method list(Capture:D:)\n\nReturns the positional part of the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.list;                                      # OUTPUT: «(2 3 5)␤»","hash\n\nDefined as:\n\n    method hash(Capture:D:)\n\nReturns the named/hash part of the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.hash; # OUTPUT: «Map.new((:apples(:red(2))))␤»","elems\n\nDefined as:\n\n    method elems(Capture:D: --> Int:D)\n\nReturns the number of positional elements in the Capture.\n\n    my Capture $c = \\(2, 3, 5, apples => (red => 2));\n    say $c.elems;                                  # OUTPUT: «3␤»","keys\n\nDefined as:\n\n    multi method keys(Capture:D: --> Seq:D)\n\nReturns a Seq containing all positional keys followed by all named keys.\nFor positional arguments the keys are the respective arguments ordinal\nposition starting from zero.\n\n    my $capture = \\(2, 3, 5, apples => (red => 2));\n    say $capture.keys;                             # OUTPUT: «(0 1 2 apples)␤»","values\n\nDefined as:\n\n    multi method values(Capture:D: --> Seq:D)\n\nReturns a Seq containing all positional values followed by all named\nargument values.\n\n    my $capture = \\(2, 3, 5, apples => (red => 2));\n    say $capture.values;                           # OUTPUT: «(2 3 5 red => 2)␤»","kv\n\nDefined as:\n\n    multi method kv(Capture:D: --> Seq:D)\n\nReturns a Seq of alternating keys and values. The positional keys and\nvalues, if any, comes first followed by the named keys and values.\n\n    my $capture = \\(2, 3, apples => (red => 2));\n    say $capture.kv;                                  # OUTPUT: «(0 2 1 3 apples red => 2)␤»","pairs\n\nDefined as:\n\n    multi method pairs(Capture:D: --> Seq:D)\n\nReturns all arguments, the positional followed by the named, as a Seq of\nPairs. Positional arguments have their respective ordinal value, starting\nat zero, as key while the named arguments have their names as key.\n\n    my Capture $c = \\(2, 3, apples => (red => 2));\n    say $c.pairs;                                     # OUTPUT: «(0 => 2 1 => 3 apples => red => 2)␤»","antipairs\n\nDefined as:\n\n    multi method antipairs(Capture:D: --> Seq:D)\n\nReturns all arguments, the positional followed by the named, as a Seq of\npairs where the keys and values have been swapped, i.e. the value becomes\nthe key and the key becomes the value. This behavior is the opposite of the\npairs method.\n\n    my $capture = \\(2, 3, apples => (red => 2));\n    say $capture.antipairs;                           # OUTPUT: «(2 => 0 3 => 1 (red => 2) => apples)␤»","Bool\n\nDefined as:\n\n    method Bool(Capture:D: --> Bool:D)\n\nReturns True if the Capture contains at least one named or one positional\nargument.\n\n    say \\(1,2,3, apples => 2).Bool;                   # OUTPUT: «True␤»\n    say \\().Bool;                                     # OUTPUT: «False␤»","Capture\n\nDefined as:\n\n    method Capture(Capture:D: --> Capture:D)\n\nReturns itself, i.e. the invocant.\n\n    say \\(1,2,3, apples => 2).Capture; # OUTPUT: «\\(1, 2, 3, :apples(2))␤»","Numeric\n\nDefined as:\n\n    method Numeric(Capture:D: --> Int:D)\n\nReturns the number of positional elements in the Capture.\n\n    say \\(1,2,3, apples => 2).Numeric;                # OUTPUT: «3␤»"],"desc":"TITLE\nclass Capture\n\nSUBTITLE\nArgument list suitable for passing to a Signature\n\n \n\n    class Capture { }\n\n\nA Capture is a container for passing arguments to a code object. Captures\nare the flip-side of Signatures – Captures are the caller defined\narguments, while Signatures are the callee defined parameters.\n\nWhen you call print $a, $b, the $a, $b part is a Capture.\n\nCaptures contain a list-like part for positional arguments and a hash-like\npart for named arguments, thus behaving as Positional and Associative,\nalthough it does not actually mixes in those roles. For the named\narguments, Captures use a slightly different syntax than a normal List.\nThere are two easy ways to make a named argument: 1) use an unquoted key\nnaming a parameter, followed by =>, followed by the argument and 2) use a\ncolon-pair literal named after the parameter:\n\n    say unique 1, -2, 2, 3, as => { abs $_ };   # OUTPUT: «(1 -2 3)␤»\n    # ... is the same thing as:\n    say unique 1, -2, 2, 3, :as({ abs $_ });    # OUTPUT: «(1 -2 3)␤»\n    # Be careful not to quote the name of a named parameter:\n    say unique 1, -2, 2, 3, 'as' => { abs $_ };\n    # OUTPUT: «(1 -2 2 3 as => -> ;; $_? is raw { #`(Block|78857320) ... })␤»\n\nA stand-alone Capture can also be made, stored, and used later. A literal\nCapture can be created by prefixing a term with a backslash \\. Commonly,\nthis term will be a List of terms, from which any Pair literal will be\nplaced in the named part, and all other terms will be placed in the\npositional part.\n\n    my $c = \\(42);          # Capture with one positional part\n    $c = \\(1, 2, a => 'b'); # Capture with two positional and one named parts\n\nTo use such a Capture, you may use '|' before it in a function call, and it\nwill be as if the values in the Capture were passed directly to the\nfunction as arguments – named arguments will be passed as named arguments\nand positional arguments will be passed as positional arguments. You may\nre-use the Capture as many times as you want, even with different\nfunctions.\n\n    my $c = \\(4, 2, 3);\n    reverse(|$c).say; # OUTPUT: «3 2 4␤»\n    sort(5,|$c).say;  # OUTPUT: «2 3 4 5␤»\n\nInside a Signature, a Capture may be created by prefixing a sigilless\nparameter with a vertical bar |. This packs the remainder of the argument\nlist into that parameter.\n\n    f(1, 2, 3, a => 4, b => 5);\n    sub f($a, |c) {\n        # c  is  \\(2, 3, a => 4, b => 5)\n    }\n\nNote that Captures are still Lists in that they may contain containers, not\njust values:\n\n    my $b = 1;\n    my $c = \\(4, 2, $b, 3);\n    sort(|$c).say;        # OUTPUT: «1 2 3 4␤»\n    $b = 6;\n    sort(|$c).say;        # OUTPUT: «2 3 4 6␤»\n\n","name":"Capture"},{"name":"Pair","desc":"TITLE\nclass Pair\n\nSUBTITLE\nKey/value pair\n\n    class Pair does Associative {}\n\nConsists of two parts, a key and a value. Pairs can be seen as the atomic\nunits in Hashes, and they are also used in conjunction with named arguments\nand parameters.\n\n     There are many syntaxes for creating Pairs:\n\n    Pair.new('key', 'value'); # The canonical way\n    'key' => 'value';         # this...\n    :key<value>;              # ...means the same as this\n    :key<value1 value2>;      # But this is  key => <value1 value2>\n    :foo(127);                # short for  foo => 127\n    :127foo;                  # the same   foo => 127\n\nNote that last form supports Non-ASCII numerics as well:\n\n    # use MATHEMATICAL DOUBLE-STRUCK DIGIT THREE\n    say (:\uD835\uDFDBmath-three);         # OUTPUT: «math-three => 3␤»\n\nYou can also use an identifier-like literal as key; this will not need the\nquotes as long as it follows the syntax of ordinary identifiers:\n\n    (foo => 127)              # the same   foo => 127\n\nVariants of this are\n\n    :key;                     # same as   key => True\n    :!key;                    # same as   key => False\n\nAnd this other variant, to be used in routine invocation\n\n    sub colon-pair( :$key-value ) {\n        say $key-value;\n    }\n    my $key-value = 'value';\n    colon-pair( :$key-value );               # OUTPUT: «value␤»\n    colon-pair( key-value => $key-value );   # OUTPUT: «value␤»\n\n\n Colon pairs can be chained without a comma to create a List of Pairs.\nDepending on context you may have to be explicit when assigning colon\nlists.\n\n    sub s(*%h){ say %h.perl };\n    s :a1:b2;\n    # OUTPUT: «{:a1, :b2}␤»\n\n    my $manna = :a1:b2:c3;\n    say $manna.^name;\n    # OUTPUT: «Pair␤»\n\n    $manna = (:a1:b2:c3);\n    say $manna.^name;\n    # OUTPUT: «List␤»\n\nAny variable can be turned into a Pair of its name and its value.\n\n    my $bar = 10;\n    my $p   = :$bar;\n    say $p; # OUTPUT: «bar => 10␤»\n\nIt is worth noting that when assigning a Scalar as value of a Pair the\nvalue holds the container of the value itself. This means that it is\npossible to change the value from outside of the Pair itself:\n\n    my $v = 'value A';\n    my $pair = a => $v;\n    $pair.say;  # OUTPUT: «a => value A␤»\n\n    $v = 'value B';\n    $pair.say;  # OUTPUT: «a => value B␤»\n\n\nPlease also note that this behavior is totally unrelated to the way used to\nbuild the Pair itself (i.e., explicit usage of new, use of colon, fat\narrow), as well as if the Pair is bound to a variable.\n\nIt is possible to change the above behavior forcing the Pair to remove the\nscalar container and to hold the effective value itself via the method\nfreeze:\n\n    my $v = 'value B';\n    my $pair = a => $v;\n    $pair.freeze;\n    $v = 'value C';\n    $pair.say; # OUTPUT: «a => value B␤»\n\n\nAs Pair implements Associative role, its value can be accessed using\nAssociative subscription operator, however, due to Pair's singular nature,\nthe pair's value will be only returned for the pair's key. Nil object will\nbe returned for any other key. Subscript adverbs such as :exists can be\nused on Pair.\n\n    my $pair = a => 5;\n    say $pair<a>;           # OUTPUT: «5␤»\n    say $pair<a>:exists;    # OUTPUT: «True␤»\n    say $pair<no-such-key>; # OUTPUT: «Nil␤»\n\n\n","methods":["new\n\nDefined as:\n\n    multi method new(Pair: Mu  $key, Mu  $value)\n    multi method new(Pair: Mu :$key, Mu :$value)\n\nConstructs a new Pair object.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(Pair:D $: %topic)\n    multi method ACCEPTS(Pair:D $: Pair:D $topic)\n    multi method ACCEPTS(Pair:D $: Mu $topic)\n\nIf %topic is an Associative, looks up the value using invocant's key in it\nand checks invocant's value .ACCEPTS that value:\n\n    say %(:42a) ~~ :42a; # OUTPUT: «True␤»\n    say %(:42a) ~~ :10a; # OUTPUT: «False␤»\n\nIf $topic is another Pair, checks the invocant's value .ACCEPTS the\n$topic's value. Note that the keys are not considered and can be\ndifferent:\n\n    say :42a ~~ :42a; # OUTPUT: «True␤»\n    say :42z ~~ :42a; # OUTPUT: «True␤»\n    say :10z ~~ :42a; # OUTPUT: «False␤»\n\nIf $topic is any other value, the invocant Pair's key is treated as a\nmethod name. This method is called on $topic, the boolean result of which\nis compared against the invocant Pair's boolean value. For example,\nprimality can be tested using smartmatch:\n\n    say 3 ~~ :is-prime;             # OUTPUT: «True␤»\n    say 3 ~~  is-prime => 'truthy'; # OUTPUT: «True␤»\n    say 4 ~~ :is-prime;             # OUTPUT: «False␤»\n\nThis form can also be used to check Bool values of multiple methods on the\nsame object, such as IO::Path, by using Junctions:\n\n    say \"foo\" .IO ~~ :f & :rw; # OUTPUT: «False␤»\n    say \"/tmp\".IO ~~ :!f;      # OUTPUT: «True␤»\n    say \".\"   .IO ~~ :f | :d;  # OUTPUT: «True␤»","antipair\n\nDefined as:\n\n    method antipair(--> Pair:D)\n\nReturns a new Pair object with key and value exchanged.\n\n    my $p = (6 => 'Perl').antipair;\n    say $p.key;         # OUTPUT: «Perl␤»\n    say $p.value;       # OUTPUT: «6␤»","key\n\nDefined as:\n\n    multi method key(Pair:D:)\n\nReturns the key part of the Pair.\n\n    my $p = (Perl => 6);\n    say $p.key; # OUTPUT: «Perl␤»","value\n\nDefined as:\n\n    multi method value(Pair:D:) is rw\n\nReturns the value part of the Pair.\n\n    my $p = (Perl => 6);\n    say $p.value; # OUTPUT: «6␤»\n\n  infix cmp\n\nDefined as:\n\n    multi sub infix:<cmp>(Pair:D, Pair:D)\n\nThe type-agnostic comparator; compares two Pairs. Compares first their key\nparts, and then compares the value parts if the keys are equal.\n\n    my $a = (Apple => 1);\n    my $b = (Apple => 2);\n    say $a cmp $b; # OUTPUT: «Less␤»","fmt\n\nDefined as:\n\n    multi method fmt(Pair:D: Str:D $format --> Str:D)\n\nTakes a format string, and returns a string the key and value parts of the\nPair formatted. Here's an example:\n\n    my $pair = :Earth(1);\n    say $pair.fmt(\"%s is %.3f AU away from the sun\")\n    # OUTPUT: «Earth is 1.000 AU away from the sun␤»\n\nFor more about format strings, see sprintf.","kv\n\nDefined as:\n\n    multi method kv(Pair:D: --> List:D)\n\nReturns a two-element List with the key and value parts of Pair, in that\norder. This method is a special case of the same-named method on Hash,\nwhich returns all its entries as a list of keys and values.\n\n    my $p = (Perl => 6);\n    say $p.kv[0]; # OUTPUT: «Perl␤»\n    say $p.kv[1]; # OUTPUT: «6␤»","pairs\n\nDefined as:\n\n    multi method pairs(Pair:D:)\n\nReturns a list of one Pair, namely this one.\n\n    my $p = (Perl => 6);\n    say $p.pairs.^name; # OUTPUT: «List␤»\n    say $p.pairs[0];    # OUTPUT: «Perl => 6␤»","antipairs\n\nDefined as:\n\n    multi method antipairs(Pair:D:)\n\nReturns a List containing the antipair of the invocant.\n\n    my $p = (6 => 'Perl').antipairs;\n    say $p.^name;                                     # OUTPUT: «List␤»\n    say $p.first;                                     # OUTPUT: «Perl => 6␤»\n    say $p.first.^name;                               # OUTPUT: «Pair␤»","invert\n\nDefined as:\n\n    method invert(Pair:D: --> Seq:D)\n\nReturns a Seq. If the .value of the invocant is NOT an Iterable, the Seq\nwill contain a single Pair whose .key is the .value of the invocant and\nwhose .value is the .key of the invocant:\n\n    :foo<bar>.invert.perl.say; # OUTPUT: «(:bar(\"foo\"),).Seq»\n\nIf invocant's .value is an Iterable, the returned Seq will contain the same\nnumber of Pairs as items in the .value, with each of those items a .key of\na pair and the .key of the invocant the .value of that pair:\n\n    :foo<Perl is great>.invert.perl.say;\n    # OUTPUT: «(:Perl(\"foo\"), :is(\"foo\"), :great(\"foo\")).Seq»\n\n    :foo{ :42a, :72b }.invert.perl.say;\n    # OUTPUT: «((:a(42)) => \"foo\", (:b(72)) => \"foo\").Seq»\n\nTo perform the exact .key and .value swap, use .antipair method.","keys\n\nDefined as:\n\n    multi method keys(Pair:D: --> List:D)\n\nReturns a List containing the key of the invocant.\n\n    say ('Perl' => 6).keys;                           # OUTPUT: «(Perl)␤»","values\n\nDefined as:\n\n    multi method values(Pair:D: --> List:D)\n\nReturns a List containing the value of the invocant.\n\n    say ('Perl' => 6).values;                         # OUTPUT: «(6)␤»","freeze\n\nDefined as:\n\n    method freeze(Pair:D:)\n\nMakes the value of the Pair read-only, by removing it from its Scalar\ncontainer, and returns it.\n\n    my $str = \"apple\";\n    my $p = Pair.new('key', $str);\n    $p.value = \"orange\";              # this works as expected\n    $p.say;                           # OUTPUT: «key => orange␤»\n    $p.freeze.say;                    # OUTPUT: «orange␤»\n    $p.value = \"a new apple\";         # Fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Str (apple)␤»\n\nNOTE: this method is deprecated as of 6.d language version. Instead, create\na new Pair, with a decontainerized key/value.\n\n    $p.=Map.=head.say;                                    # OUTPUT: «orange␤»","Str\n\nDefined as:\n\n    multi method Str(Pair:D: --> Str:D)\n\nReturns a string representation of the invocant formatted as key ~ \\t ~\nvalue.\n\n    my $b = eggs => 3;\n    say $b.Str;                                       # OUTPUT: «eggs  3␤»","Pair\n\nDefined as:\n\n    method Pair()\n\nReturns the invocant Pair object.\n\n    my $pair = eggs => 3;\n    say $pair.Pair === $pair;                         # OUTPUT: «True␤»"]},{"name":"Dateish","methods":["year\n\nDefined as:\n\n    method year(Date:D: --> Int:D)\n\nReturns the year of the date.\n\n    say Date.new('2015-12-31').year;                                  # OUTPUT: «2015␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).year; # OUTPUT: «2015␤»","month\n\nDefined as:\n\n    method month(Date:D: --> Int:D)\n\nReturns the month of the date (1..12).\n\n    say Date.new('2015-12-31').month;                                  # OUTPUT: «12␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).month; # OUTPUT: «12␤»","day\n\nDefined as:\n\n    method day(Date:D: --> Int:D)\n\nReturns the day of the month of the date (1..31).\n\n    say Date.new('2015-12-31').day;                                  # OUTPUT: «31␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).day; # OUTPUT: «24␤»","formatter\n\nDefined as:\n\n    method formatter(Dateish:D:)\n\nReturns the formatting function which is used for conversion to Str. If\nnone was provided at object construction, a default formatter is used. In\nthat case the method will return a Callable type object.\n\nThe formatting function is called by DateTime method Str with the invocant\nas its only argument.\n\n    my $dt = Date.new('2015-12-31');  # (no formatter specified)\n    say $dt.formatter.^name;          # OUTPUT: «Callable␤»\n    my $us-format = sub ($self) { sprintf \"%02d/%02d/%04d\", .month, .day, .year given $self; };\n    $dt = Date.new('2015-12-31', formatter => $us-format);\n    say $dt.formatter.^name;           # OUTPUT: «Sub␤»\n    say $dt;                          # OUTPUT: «12/31/2015␤»","is-leap-year\n\nDefined as:\n\n    method is-leap-year(--> Bool:D)\n\nReturns True if the year of the Dateish object is a leap year.\n\n    say DateTime.new(:year<2016>).is-leap-year; # OUTPUT: «True␤»\n    say Date.new(\"1900-01-01\").is-leap-year;    # OUTPUT: «False␤»","day-of-month\n\nDefined as:\n\n    method day-of-month(Date:D: --> Int:D)\n\nReturns the day of the month of the date (1..31). Synonymous to the day\nmethod.\n\n    say Date.new('2015-12-31').day-of-month;                                  # OUTPUT: «31␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-month; # OUTPUT: «24␤»","day-of-week\n\nDefined as:\n\n    method day-of-week(Date:D: --> Int:D)\n\nReturns the day of the week, where 1 is Monday, 2 is Tuesday and Sunday is\n7.\n\n    say Date.new('2015-12-31').day-of-week;                                  # OUTPUT: «4␤»\n    say DateTime.new(date => Date.new('2015-12-24'), hour => 1).day-of-week; # OUTPUT: «4␤»","day-of-year\n\nDefined as:\n\n    method day-of-year(Date:D: --> Int:D)\n\nReturns the day of the year (1..366).\n\n    say Date.new('2015-12-31').day-of-year;                                  # OUTPUT: «365␤»\n    say DateTime.new(date => Date.new('2015-03-24'), hour => 1).day-of-year; # OUTPUT: «83␤»","days-in-month\n\nDefined as:\n\n    method days-in-month(Dateish:D: --> Int:D)\n\nReturns the number of days in the month represented by the Dateish object:\n\n    say Date.new(\"2016-01-02\").days-in-month;                # OUTPUT: «31␤»\n    say DateTime.new(:year<10000>, :month<2>).days-in-month; # OUTPUT: «29␤»","week\n\nDefined as:\n\n    method week()\n\nReturns a list of two integers: the year, and the week number. This is\nbecause at the start or end of a year, the week may actually belong to the\nother year.\n\n    my ($year, $week) = Date.new(\"2014-12-31\").week;\n    say $year;                       # OUTPUT: «2015␤»\n    say $week;                       # OUTPUT: «1␤»\n    say Date.new('2015-01-31').week; # OUTPUT: «(2015 5)␤»","week-number\n\nDefined as:\n\n    method week-number(Date:D: --> Int:D)\n\nReturns the week number (1..53) of the date specified by the invocant. The\nfirst week of the year is defined by ISO as the one which contains the\nfourth day of January. Thus, dates early in January often end up in the\nlast week of the prior year, and similarly, the final few days of December\nmay be placed in the first week of the next year.\n\n    say Date.new(\"2014-12-31\").week-number;   # 1  (first week of 2015)\n    say Date.new(\"2016-01-02\").week-number;   # 53 (last week of 2015)","week-year\n\nDefined as:\n\n    method week-year(Date:D: --> Int:D)\n\nReturns the week year of the date specified by the invocant. Normally\nweek-year is equal to Date.year. Note however that dates early in January\noften end up in the last week of the prior year, and similarly, the final\nfew days of December may be placed in the first week of the next year.\n\n    say Date.new(\"2015-11-15\").week-year;   # 2015\n    say Date.new(\"2014-12-31\").week-year;   # 2015 (date belongs to the first week of 2015)\n    say Date.new(\"2016-01-02\").week-year;   # 2015 (date belongs to the last week of 2015)","weekday-of-month\n\nDefined as:\n\n    method weekday-of-month(Date:D: --> Int:D)\n\nReturns a number (1..5) indicating the number of times a particular\nday-of-week has occurred so far during that month, the day itself\nincluded.\n\n    say Date.new(\"2003-06-09\").weekday-of-month;  # 2  (second Monday of the month)","yyyy-mm-dd\n\nDefined as:\n\n    method yyyy-mm-dd(Date:D: --> Str:D)\n\n\nReturns the date in YYYY-MM-DD format (ISO 8601)\n\n    say Date.new(\"2015-11-15\").yyyy-mm-dd;   # OUTPUT: «2015-11-15␤»\n    say DateTime.new(1470853583).yyyy-mm-dd; # OUTPUT: «2016-08-10␤»","daycount\n\nDefined as:\n\n    method daycount(Dateish:D: --> Int:D)\n\nReturns the number of days from the epoch Nov. 17, 1858 to the day of the\ninvocant. The daycount returned by this method is the MJD, i.e. the\nModified Julian Day, which is used routinely by e.g. astronomers,\ngeodesists, scientists and others. The MJD convention is designed to\nfacilitate simplified chronological calculations.\n\n    say Date.new('1995-09-27').daycount;    # OUTPUT: «49987␤»","IO\n\nDefined as:\n\n    method IO(Dateish:D: --> IO::Path:D)\n\nReturns an IO::Path object representing the stringified value of the\nDateish object:\n\n    Date.today.IO.say;   # OUTPUT: «\"2016-10-03\".IO␤»\n    DateTime.now.IO.say; # OUTPUT: «\"2016-10-03T11:14:47.977994-04:00\".IO␤»\n\nPORTABILITY NOTE: some operating systems (e.g. Windows) do not permit\ncolons (:) in filenames, which would be present in IO::Path created from a\nDateTime object."],"desc":"TITLE\nrole Dateish\n\nSUBTITLE\nObject that can be treated as a date\n\n    role Dateish { ... }\n\nBoth Date and DateTime support accessing a year, month and day-of-month, as\nwell as related functionality such as calculating the day of the week.\n\n"},{"name":"FatRat","desc":"TITLE\nclass FatRat\n\nSUBTITLE\nRational number (arbitrary-precision)\n\n    class FatRat is Cool does Rational[Int, Int] {}\n\nA FatRat is a rational number stored with arbitrary size numerator and\ndenominator. Arithmetic operations involving a FatRat and optionally Int or\nRat objects return a FatRat, avoiding loss of precision.\n\nSince, unlike Rat, FatRat arithmetics do not fall back Num at some point,\nthere is a risk that repeated arithmetic operations generate pathologically\nlarge numerators and denominators.\n\nThere are two common ways to generate FatRat objects: through the\nFatRat.new(Int, Int) constructor, which generates them from numerator and\ndenominator, or by calling the .FatRat method on an Int or Rat object.\n\n","methods":["perl\n\n    multi method perl(FatRat:D: --> Str:D)\n\nReturns an implementation-specific string that produces an equivalent\nobject when given to EVAL.\n\n    say FatRat.new(1, 2).perl; # OUTPUT: «FatRat.new(1, 2)␤»"]},{"methods":[],"desc":"TITLE\nclass Scalar\n\nSUBTITLE\nA mostly transparent container used for indirections\n\n    class Scalar {}\n\nA Scalar is an internal indirection which is for most purposes invisible\nduring ordinary use of Raku. It is the default container type associated\nwith the $ sigil. A literal Scalar may be placed around a literal value by\nenclosing the value in $(…). This notation will appear in the output of a\n.perl method in certain places where it is important to note the presence\nof Scalars.\n\nWhen a value is assigned to a $-sigiled variable, the variable will\nactually bind to a Scalar, which in turn will bind to the value. When a\nScalar is assigned to a $-sigiled variable, the value bound to by that\nScalar will be bound to the Scalar which that variable was bound to (a new\none will be created if necessary.)\n\nIn addition, Scalars delegate all method calls to the value which they\ncontain. As such, Scalars are for the most part invisible. There is,\nhowever, one important place where Scalars have a visible impact: a Scalar\nwill shield its content from flattening by most Raku core list operations.\n\nA $-sigiled variable may be bound directly to a value with no intermediate\nScalar using the binding operator :=. You can tell if this has been done by\nexamining the output of the introspective pseudo-method .VAR:\n\n    my $a = 1;\n    $a.^name.say;     # OUTPUT: «Int␤»\n    $a.VAR.^name.say; # OUTPUT: «Scalar␤»\n    my $b := 1;\n    $b.^name.say;     # OUTPUT: «Int␤»\n    $b.VAR.^name.say; # OUTPUT: «Int␤»\n\nThis same thing happens when values are assigned to an element of an Array,\nhowever, Lists directly contain their values:\n\n    my @a = 1, 2, 3;\n    @a[0].^name.say;            # OUTPUT: «Int␤»\n    @a[0].VAR.^name.say;        # OUTPUT: «Scalar␤»\n    [1, 2, 3][0].^name.say;     # OUTPUT: «Int␤»\n    [1, 2, 3][0].VAR.^name.say; # OUTPUT: «Scalar␤»\n    (1, 2, 3)[0].^name.say;     # OUTPUT: «Int␤»\n    (1, 2, 3)[0].VAR.^name.say; # OUTPUT: «Int␤»\n\nArray elements may be bound directly to values using := as well; however,\nthis is discouraged as it may lead to confusion. Doing so will break exact\nround-tripping of .perl output – since Arrays are assumed to place Scalars\naround each element, Scalars are not denoted with $ in the output of\nArray.perl.\n\n    [1, $(2, 3)].perl.say;     # OUTPUT: «[1, (2, 3)]␤»\n    (1, $(2, 3)).perl.say;     # OUTPUT: «(1, $(2, 3))␤»\n\nBinding a Scalar to a $-sigiled variable replaces the existing Scalar in\nthat variable, if any, with the given Scalar. That means more than one\nvariable may refer to the same Scalar. Because the Scalar may be mutated,\nthis makes it possible to alter the value of both variables by altering\nonly one of them:\n\n    my $a = 1;\n    my $b := $a;\n    $b = 2;\n    $a.say;       # OUTPUT: «2␤»\n\n SSA-style constants bind directly to their value with no intervening\nScalar, even when assignment (=) is used. They may be forced to use a\nScalar by assigning a $-sigiled variable to them, at which point, they\nbehave entirely like $-sigiled variables.\n\n    my \\c = 1;\n    c.^name.say;             # OUTPUT: «Int␤»\n    c.VAR.^name.say;         # OUTPUT: «Int␤»\n    my $a = 1;\n    my \\d = $a;              # just \"my \\d = $ = 1\" works, too\n    d.^name.say;             # OUTPUT: «Int␤»\n    d.VAR.^name.say;         # OUTPUT: «Scalar␤»\n    d = 2;                   # ok\n    c = 2;                   # fails\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Int␤»\n\nAtomic operations on Scalar\n\nA Scalar can have its value changed using a hardware-supported atomic\ncompare and swap operation. This is useful when implementing lock free data\nstructures and algorithms. It may also be fetched and assigned to in an\n\"atomic\" fashion, which ensures appropriate memory barriering and prevents\nunwanted optimizations of memory accesses.\n\nA Scalar that will be used with an atomic operation should always be\nexplicitly initialized with a value before any atomic operations are\nperformed upon it. This is to avoid races with lazy allocation and\nauto-vivification. For example:\n\n    cas(@a[5], $expected, $value)\n\n\nWill work in principle since an Array consists of Scalar containers.\nHowever, the container is only bound into the array upon initial\nassignment. Therefore, there would be a race to do that binding. The Scalar\natomic operations will never check for or do any such auto-vivification, so\nas to make such bugs much more evident (rather than only observed under\nstress).\n\nIntrospection\n\n  method of\n\n    method of(Scalar:D: --> Mu)\n\nReturns the type constraint of the container.\n\nExample:\n\n    my Cool $x = 42;\n    say $x.VAR.of;                  # OUTPUT: «(Cool)»\n\n  method default\n\n    method default(Scalar:D: --> Str)\n\nReturns the default value associated with the container.\n\nExample:\n\n    my $x is default(666) = 42;\n    say $x.VAR.default;             # OUTPUT: «666»\n\n  method name\n\n    method name(Scalar:D: --> Str)\n\nReturns the name associated with the container.\n\nExample:\n\n    my $x = 42;\n    say $x.VAR.name;                # OUTPUT: «$x»\n\n  method dynamic\n\n    method dynamic(Scalar:D: --> Bool)\n\nReturns whether the variable is visible in dynamic variable lookups.\n\nExample:\n\n    my $*FOO = 42;\n    say $*FOO.VAR.dynamic;          # OUTPUT: «True»\n\nRoutines\n\n  sub atomic-assign\n\nDefined as:\n\n    multi sub atomic-assign($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The\natomic-assign routine ensures that any required barriers are performed such\nthat the changed value will be \"published\" to other threads.\n\n  sub atomic-fetch\n\n    multi sub atomic-fetch($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this routine instead of simply using the variable ensures\nthat the latest update to the variable from other threads will be seen,\nboth by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until atomic-fetch($started) { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { atomic-assign($started, True) }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate.\n\n  sub cas\n\nDefined as:\n\n    multi sub cas($target is rw, $expected, $value)\n    multi sub cas($target is rw, &operation)\n\nPerforms an atomic compare and swap of the value in the Scalar $target. The\nfirst form has semantics like:\n\n    my $seen = $target;\n    if $seen<> =:= $expected<> {\n        $target = $value;\n    }\n    return $seen;\n\n\nExcept it is performed as a single hardware-supported atomic instruction,\nas if all memory access to $target were blocked while it took place.\nTherefore it is safe to attempt the operation from multiple threads without\nany other synchronization. Since it is a reference comparison, this\noperation is usually not sensible on value types.\n\nFor example:\n\n    constant NOT_STARTED = Any.new;\n    constant STARTED = Any.new;\n    my $master = NOT_STARTED;\n    await start {\n        if cas($master, NOT_STARTED, STARTED) === NOT_STARTED {\n            say \"Master!\"\n        }\n    } xx 4\n\nWill reliably only ever print Master! one time, as only one of the threads\nwill be successful in changing the Scalar from NOT_STARTED to STARTED.\n\nThe second form, taking a code object, will first do an atomic fetch of the\ncurrent value and invoke the code object with it. It will then try to do an\natomic compare and swap of the target, using the value passed to the code\nobject as $expected and the result of the code object as $value. If this\nfails, it will read the latest value, and retry, until a CAS operation\nsucceeds.\n\nTherefore, an item could be added to the head of a linked list in a lock\nfree manner as follows:\n\n    class Node {\n        has $.value;\n        has Node $.next;\n    }\n    my Node $head = Node;\n    await start {\n        for ^1000 -> $value {\n            cas $head, -> $next { Node.new(:$value, :$next) }\n        }\n    } xx 4;\n\nThis will reliably build up a linked list of 4000 items, with 4 nodes with\neach value ranging from 0 up to 999.\n\nOperators\n\n  infix ⚛=\n\n    multi sub infix:<⚛=>($target is rw, $value)\n\nPerforms an atomic assignment of $value into the Scalar $target. The ⚛=\noperator ensures that any required barriers are performed such that the\nchanged value will be \"published\" to other threads.\n\n  prefix ⚛\n\n    multi sub prefix:<⚛>($target is rw)\n\nPerforms an atomic read of the value in the Scalar $target and returns the\nread value. Using this operator instead of simply using the variable\nensures that the latest update to the variable from other threads will be\nseen, both by doing any required hardware barriers and also preventing the\ncompiler from lifting reads. For example:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until ⚛$started { }\n\nIs certain to terminate, while in:\n\n    my $started = False;\n    start { $started ⚛= True }\n    until $started { }\n\nIt would be legal for a compiler to observe that $started is not updated in\nthe loop, and so lift the read out of the loop, thus causing the program to\nnever terminate.","name":"Scalar"},{"name":"Thread","methods":["new\n\n    method new(:&code!, Bool :$app_lifetime = False, Str :$name = '<anon>' --> Thread:D)\n\nCreates and returns a new Thread, without starting it yet. &code is the\ncode that will be run in a separate thread.\n\n$name is a user-specified string that identifies the thread.\n\nIf $app_lifetime is set to True, then the thread is killed when the main\nthread of the process terminates. If set to False, the process will only\nterminate when the thread has finished.","start\n\n    method start(Thread:U: &code, Bool :$app_lifetime = False, Str :$name = '<anon>' --> Thread:D)\n\nCreates, runs and returns a new Thread. Note that it can (and often does)\nreturn before the thread's code has finished running.","run\n\n    method run(Thread:D:)\n\nRuns the thread, and returns the invocant. It is an error to run a thread\nthat has already been started.","id\n\n    method id(Thread:D: --> Int:D)\n\nReturns a numeric, unique thread identifier.","finish\n\n    method finish(Thread:D)\n\nWaits for the thread to finish. This is called join in other programming\nsystems.","join\n\n    method join(Thread:D)\n\nWaits for the thread to finish.","yield\n\n    method yield(Thread:U)\n\nTells the scheduler to prefer another thread for now.\n\n    Thread.yield;","app_lifetime\n\n    method app_lifetime(Thread:D: --> Bool:D)\n\nReturns False unless the named parameter :app_lifetime is specifically set\nto True during object creation. If the method returns False it means that\nthe process will only terminate when the thread has finished while True\nmeans that the thread will be killed when the main thread of the process\nterminates.\n\n    my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\n    my $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, :app_lifetime);\n\n    say $t1.app_lifetime;                 # OUTPUT: «False␤»\n    say $t2.app_lifetime;                 # OUTPUT: «True␤»","name\n\n    method name(Thread:D: --> Str:D)\n\nReturns the user defined string, which can optionally be set during object\ncreation in order to identify the Thread, or '<anon>' if no such string was\nspecified.\n\n    my $t1 = Thread.new(code => { for 1..5 -> $v { say $v }});\n    my $t2 = Thread.new(code => { for 1..5 -> $v { say $v }}, name => 'my thread');\n\n    say $t1.name;                 # OUTPUT: «<anon>␤»\n    say $t2.name;                 # OUTPUT: «my thread␤»","Numeric\n\n    method Numeric(Thread:D: --> Int:D)\n\nReturns a numeric, unique thread identifier, i.e. the same as id.","Str\n\n    method Str(Thread:D: --> Str:D)\n\nReturns a string which contains the invocants thread id and name.\n\n    my $t = Thread.new(code => { for 1..5 -> $v { say $v }}, name => 'calc thread');\n    say $t.Str;                           # OUTPUT: «Thread<3>(calc thread)␤»","is-initial-thread\n\n    method is-initial-thread(--> Bool)\n\nReturns a Bool indicating whether the current thread (if called as a class\nmethod) or the Thread object on which it is called, is the initial thread\nthe program started on.\n\n    say Thread.is-initial-thread;    # True if this is the initial thread\n    say $*THREAD.is-initial-thread;  # True if $*THREAD is the initial thread\n\nPlease note there is no guarantee that this is actually the main thread\nfrom the OS's point of view. Also note that if you need this other than\nfrom a pure introspection / debugging point of view, that there are\nprobably better ways to achieve what you're trying to achieve.\n\nRoutines\n\n  sub full-barrier\n\n    sub full-barrier()\n\nPerforms a full memory barrier, preventing re-ordering of reads/writes.\nRequired for implementing some lock-free data structures and algorithms."],"desc":"TITLE\nclass Thread\n\nSUBTITLE\nConcurrent execution of code (low-level)\n\n    class Thread {}\n\nA thread is a sequence of instructions that can (potentially) run in\nparallel to others. Class Thread provides a bit of abstraction over threads\nprovided by the underlying virtual machines (which in turn might or might\nnot be operating system threads).\n\nSince threads are fairly low-level, most applications should use other\nprimitives, like start, which also runs in parallel and returns a Promise.\n\n    my @threads = (^10).map: {\n        Thread.start(\n            name => \"Sleepsorter $_\",\n            sub {\n                my $rand = (^10).pick;\n                sleep $rand;\n                say $rand;\n            },\n        );\n    }\n\n    .finish for @threads;\n\n\nThe current thread is available in the dynamic variable $*THREAD.\n\n"},{"methods":["type\n\n    method type(--> Mu)","meta\n\n    method meta(--> Positional)"],"desc":"TITLE\nclass Pod::FormattingCode\n\nSUBTITLE\nPod formatting code\n\n    class Pod::FormattingCode is Pod::Block { }\n\nClass for formatting codes in a Pod document.\n\n","name":"Pod::FormattingCode"},{"name":"Pod::Defn","methods":["term\n\n    method term(--> Mu)"],"desc":"TITLE\nclass Pod::Defn\n\nSUBTITLE\nPod definition list\n\n    class Pod::Defn is Pod::Block { }\n\nClass for definition lists in a Pod document.\n\n"},{"desc":"TITLE\nclass Pod::Item\n\nSUBTITLE\nItem in a Pod enumeration list\n\n    class Pod::Item is Pod::Block { }\n\nClass for items in Pod enumeration lists.\n\n","methods":["level\n\n    method level(--> Int)\n\nReturns the level of the enumeration list, starting at 1."],"name":"Pod::Item"},{"name":"Pod::Heading","desc":"TITLE\nclass Pod::Heading\n\nSUBTITLE\nHeading in a Pod document\n\n    class Pod::Heading is Pod::Block { }\n\nClass for headings in a Pod document.\n\n","methods":["level\n\n    method level(--> Int)\n\nReturns the level of the heading, starting at 1."]},{"name":"Pod::Block","methods":["contents\n\n    method contents(--> Positional:D)\n\nReturns a list of contents of this block.","config\n\n    method config(--> Map:D)\n\nReturns a hash of configs."],"desc":"TITLE\nclass Pod::Block\n\nSUBTITLE\nBlock in a Pod document\n\n    class Pod::Block { }\n\nClass for a Pod block, and base class for most other Pod classes.\n\nA Pod block has contents (more pod blocks or strings) and a config hash.\n\nUseful subclasses:\n\n  Class                   Used for\n  Pod::Block::Para        paragraphs\n  Pod::Block::Named       named blocks\n  Pod::Block::Declarator  declarator blocks\n  Pod::Block::Code        code blocks\n  Pod::Block::Comment     comments\n  Pod::Block::Table       =begin/end table\n                          tabular data\n  Pod::Heading            =head1 etc. headings\n  Pod::Item               list items\n  Pod::Defn               definition lists\n  Pod::FormattingCode     formatting codes\n\n\n"},{"desc":"TITLE\nclass Lock::Async\n\nSUBTITLE\nA non-blocking, non-re-entrant, mutual exclusion lock\n\n    class Lock::Async {}\n\nA Lock::Async instance provides a mutual exclusion mechanism: when the lock\nis held, any other code wishing to lock must wait until the holder calls\nunlock.\n\nUnlike Lock, which provides a traditional OS-backed mutual exclusion\nmechanism, Lock::Async works with the high-level concurrency features of\nRaku. The lock method returns a Promise, which will be kept when the lock\nis available. This Promise can be used with non-blocking await. This means\nthat a thread from the thread pool need not be consumed while waiting for\nthe Lock::Async to be available, and the code trying to obtain the lock\nwill be resumed once it is available.\n\nThe result is that it's quite possible to have many thousands of\noutstanding Lock::Async lock requests, but just a small number of threads\nin the pool. Attempting that with a traditional Lock would not go so well!\n\nThere is no requirement that a Lock::Async is locked and unlocked by the\nsame physical thread, meaning it is possible to do a non-blocking await\nwhile holding the lock. The flip side of this is Lock::Async is not\nre-entrant.\n\nWhile Lock::Async works in terms of higher-level Raku concurrency\nmechanisms, it should be considered a building block. Indeed, it lies at\nthe heart of the Supply concurrency model. Prefer to structure programs so\nthat they communicate results rather than mutate shared data structures,\nusing mechanisms like Promise, Channel and Supply.\n\n","methods":["lock\n\nDefined as:\n\n    method lock(Lock::Async:D: --> Promise:D)\n\nReturns a Promise that will be kept when the lock is available. In the case\nthat the lock is already available, an already kept Promise will be\nreturned. Use await to wait for the lock to be available in a non-blocking\nmanner.\n\n    my $l = Lock::Async.new;\n    await $l.lock;\n\nPrefer to use protect instead of explicit calls to lock and unlock.","unlock\n\nDefined as:\n\n    method unlock(Lock::Async:D: --> Nil)\n\nReleases the lock. If there are any outstanding lock Promises, the one at\nthe head of the queue will then be kept, and potentially code scheduled on\nthe thread pool (so the cost of calling unlock is limited to the work\nneeded to schedule another piece of code that wants to obtain the lock, but\nnot to execute that code).\n\n    my $l = Lock::Async.new;\n    await $l.lock;\n    $l.unlock;\n\nPrefer to use protect instead of explicit calls to lock and unlock.\nHowever, if wishing to use the methods separately, it is wise to use a\nLEAVE block to ensure that unlock is reliably called. Failing to unlock\nwill mean that nobody can ever lock this particular Lock::Async instance\nagain.\n\n    my $l = Lock::Async.new;\n    {\n        await $l.lock;\n        LEAVE $l.unlock;\n    }","protect\n\nDefined as:\n\n    method protect(Lock::Async:D: &code)\n\nCalls lock, does an await to wait for the lock to be available, and\nreliably calls unlock afterwards, even if the code throws an exception.\n\nNote that the Lock::Async itself needs to be created outside the portion of\nthe code that gets threaded and it needs to protect. In the first example\nbelow, Lock::Async is first created and assigned to $lock, which is then\nused inside the Promises to protect the sensitive code. In the second\nexample, a mistake is made, the Lock::Async is created right inside the\nPromise, so the code ends up with a bunch of separate locks, created in a\nbunch of threads, and thus they don't actually protect the code we want to\nprotect.\n\n    # Right: $lock is instantiated outside the portion of the\n    # code that will get threaded and be in need of protection\n    my $lock = Lock::Async.new;\n    await ^20 .map: {\n        start {\n            $lock.protect: {\n                print \"Foo\";\n                sleep rand;\n                say \"Bar\";\n            }\n        }\n    }\n\n    # !!! WRONG !!! Lock::Async is instantiated inside threaded area!\n    await ^20 .map: {\n        start {\n            my $lock = Lock::Async.new;\n            $lock.protect: {\n                print \"Foo\"; sleep rand; say \"Bar\";\n            }\n        }\n    }","protect-or-queue-on-recursion\n\nDefined as:\n\n    method protect-or-queue-on-recursion(Lock::Async:D: &code)\n\nWhen calling protect on a Lock::Async instance that is already locked, the\nmethod is forced to block until the lock gets unlocked.\nprotect-or-queue-on-recursion avoids this issue by either behaving the same\nas protect if the lock is unlocked or the lock was locked by something\noutside the caller chain, returning Nil, or queueing the call to &code and\nreturning a Promise if the lock had already been locked at another point in\nthe caller chain.\n\n    my Lock::Async $lock .= new;\n    my Int         $count = 0;\n\n    # The lock is unlocked, so the code runs instantly.\n    $lock.protect-or-queue-on-recursion({\n        $count++\n    });\n\n    # Here, we have caller recursion. The outer call only returns a Promise\n    # because the inner one does. If we try to await the inner call's Promise\n    # from the outer call, the two calls will block forever since the inner\n    # caller's Promise return value is just the outer's with a then block.\n    $lock.protect-or-queue-on-recursion({\n        $lock.protect-or-queue-on-recursion({\n            $count++\n        }).then({\n            $count++\n        })\n    });\n\n    # Here, the lock is locked, but not by anything else on the caller chain.\n    # This behaves just like calling protect would in this scenario.\n    for 0..^2 {\n        $lock.protect-or-queue-on-recursion({\n            $count++;\n        });\n    }\n\n    say $count; # OUTPUT: 5","with-lock-hidden-from-recursion-check\n\nDefined as:\n\n    method with-lock-hidden-from-recursion-check(&code)\n\nTemporarily resets the Lock::Async recursion list so that it no longer\nincludes the lock this method is called on and runs the given &code\nimmediately if the call to the method occurred in a caller chain where\nprotect-or-queue-on-recursion has already been called and the lock has been\nplaced on the recursion list.\n\n    my Lock::Async $lock .= new;\n    my Int         $count = 0;\n\n    $lock.protect-or-queue-on-recursion({\n        my Int $count = 0;\n\n        # Runs instantly.\n        $lock.with-lock-hidden-from-recursion-check({\n            $count++;\n        });\n\n        # Runs after the outer caller's protect-or-queue-on-recursion call has\n        # finished running.\n        $lock.protect-or-queue-on-recursion({\n            $count++;\n        }).then({\n            say $count; # OUTPUT: 2\n        });\n\n        say $count; # OUTPUT: 1\n    });"],"name":"Lock::Async"},{"desc":"TITLE\nclass Proc::Async\n\nSUBTITLE\nRunning process (asynchronous interface)\n\n    class Proc::Async {}\n\n\nProc::Async allows you to run external commands asynchronously, capturing\nstandard output and error handles, and optionally write to its standard\ninput.\n\n    my $file = ‘foo’.IO;\n    spurt $file, “and\\nCamelia\\n♡\\nme\\n”;\n\n    my $proc = Proc::Async.new: :w, ‘tac’, ‘--’, $file, ‘-’;\n    # my $proc = Proc::Async.new: :w, ‘sleep’, 15; # uncomment to try timeouts\n\n    react {\n        whenever $proc.stdout.lines { # split input on \\r\\n, \\n, and \\r\n            say ‘line: ’, $_\n        }\n        whenever $proc.stderr { # chunks\n            say ‘stderr: ’, $_\n        }\n        whenever $proc.ready {\n            say ‘PID: ’, $_ # Only in Rakudo 2018.04 and newer, otherwise Nil\n        }\n        whenever $proc.start {\n            say ‘Proc finished: exitcode=’, .exitcode, ‘ signal=’, .signal;\n            done # gracefully jump from the react block\n        }\n        whenever $proc.print: “I\\n♥\\nCamelia\\n” {\n            $proc.close-stdin\n        }\n        whenever signal(SIGTERM).merge: signal(SIGINT) {\n            once {\n                say ‘Signal received, asking the process to stop’;\n                $proc.kill; # sends SIGHUP, change appropriately\n                whenever signal($_).zip: Promise.in(2).Supply {\n                    say ‘Kill it!’;\n                    $proc.kill: SIGKILL\n                }\n            }\n        }\n        whenever Promise.in(5) {\n            say ‘Timeout. Asking the process to stop’;\n            $proc.kill; # sends SIGHUP, change appropriately\n            whenever Promise.in(2) {\n                say ‘Timeout. Forcing the process to stop’;\n                $proc.kill: SIGKILL\n            }\n        }\n    }\n\n    say ‘Program finished’;\n\n\nExample above produces the following output:\n\n    line: me\n    line: ♡\n    line: Camelia\n    line: and\n    line: Camelia\n    line: ♥\n    line: I\n    Proc finished. Exit code: 0\n    Program finished\n\n\nAlternatively, you can use Proc::Async without using a react block:\n\n    # command with arguments\n    my $proc = Proc::Async.new('echo', 'foo', 'bar');\n\n    # subscribe to new output from out and err handles:\n    $proc.stdout.tap(-> $v { print \"Output: $v\" }, quit => { say 'caught exception ' ~ .^name });\n    $proc.stderr.tap(-> $v { print \"Error:  $v\" });\n\n    say \"Starting...\";\n    my $promise = $proc.start;\n\n    # wait for the external program to terminate\n    await $promise;\n    say \"Done.\";\n\nThis produces the following output:\n\n    Starting...\n    Output: foo bar\n    Done.\n\n\nAn example that opens an external program for writing:\n\n    my $prog = Proc::Async.new(:w, 'hexdump', '-C');\n    my $promise = $prog.start;\n    await $prog.write(Buf.new(12, 42));\n    $prog.close-stdin;\n    await $promise;\n\nAn example of piping several commands like echo \"Hello, world\" | cat -n:\n\n    my $proc-echo = Proc::Async.new: 'echo', 'Hello, world';\n    my $proc-cat = Proc::Async.new: 'cat', '-n';\n    $proc-cat.bind-stdin: $proc-echo.stdout;\n    await $proc-echo.start, $proc-cat.start;\n\n","methods":["new\n\n    multi method new(*@ ($path, *@args), :$w, :$enc, :$translate-nl --> Proc::Async:D)\n    multi method new(   :$path, :@args,  :$w, :$enc, :$translate-nl --> Proc::Async:D)\n\nCreates a new Proc::Async object with external program name or path $path\nand the command line arguments @args.\n\nIf :w is passed to new, then a pipe to the external program's standard\ninput stream (stdin) is opened, to which you can write with write and say.\n\nThe :enc specifies the encoding for streams (can still be overridden in\nindividual methods) and defaults to utf8.\n\nIf :translate-nl is set to True (default value), OS-specific newline\nterminators (e.g. \\r\\n on Windows) will be automatically translated to \\n.","stdout\n\n    method stdout(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard output stream. If\n:bin is passed, the standard output is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stdout.tap( -> $str {\n        say \"Got output '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stdout before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stdout is not called, the external program's standard output is not\ncaptured at all.\n\nNote that you cannot call stdout both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR.","stderr\n\n    method stderr(Proc::Async:D: :$bin --> Supply:D)\n\nReturns the Supply for the external program's standard error stream. If\n:bin is passed, the standard error is passed along in binary as Blob,\notherwise it is interpreted as UTF-8, decoded, and passed along as Str.\n\n    my $proc = Proc::Async.new(:r, 'echo', 'Raku');\n    $proc.stderr.tap( -> $str {\n        say \"Got error '$str' from the external program\";\n    });\n    my $promise = $proc.start;\n    await $promise;\n\nYou must call stderr before you call #method start. Otherwise an exception\nof class X::Proc::Async::TapBeforeSpawn is thrown.\n\nIf stderr is not called, the external program's standard error stream is\nnot captured at all.\n\nNote that you cannot call stderr both with and without :bin on the same\nobject; it will throw an exception of type X::Proc::Async::CharsOrBytes if\nyou try.\n\nUse .Supply for merged STDOUT and STDERR.","bind-stdin\n\n    multi method bind-stdin(IO::Handle:D $handle)\n    multi method bind-stdin(Proc::Async::Pipe:D $pipe)\n\nSets a handle (which must be opened) or a Pipe as a source of STDIN. The\nSTDIN of the target process must be writable or X::Proc::Async::BindOrUse\nwill be thrown.\n\n    my $p = Proc::Async.new(\"cat\", :in);\n    my $h = \"/etc/profile\".IO.open;\n    $p.bind-stdin($h);\n    $p.start;\n\nThis is equivalent to\n\n    cat < /etc/profile\n\n\nand will print the content of /etc/profile to standard output.","bind-stdout\n\n    method bind-stdout(IO::Handle:D $handle)\n\nRedirects STDOUT of the target process to a handle (which must be opened).\nIf STDOUT is closed X::Proc::Async::BindOrUse will be thrown.\n\n    my $p = Proc::Async.new(\"ls\", :out);\n    my $h = \"ls.out\".IO.open(:w);\n    $p.bind-stdout($h);\n    $p.start;\n\nThis program will pipe the output of the ls shell command to a file called\nls.out, which we are opened for reading.","bind-stderr\n\n    method bind-stderr(IO::Handle:D $handle)\n\nRedirects STDERR of the target process to a handle (which must be opened).\nIf STDERR is closed X::Proc::Async::BindOrUse will be thrown.\n\n    my $p = Proc::Async.new(\"ls\", \"--foo\", :err);\n    my $h = \"ls.err\".IO.open(:w);\n    $p.bind-stderr($h);\n    $p.start;","w\n\n    method w(Proc::Async:D:)\n\nReturns a true value if :w was passed to the constructor, that is, if the\nexternal program is started with its input stream made available to output\nto the program through the .print, .say and .write methods.","start\n\n    method start(Proc::Async:D: :$scheduler = $*SCHEDULER, :$ENV, :$cwd = $*CWD)\n\nInitiates spawning of the external program. Returns a Promise that will be\nkept with a Proc object once the external program exits or broken if the\nprogram cannot be started. Optionally, you can use a scheduler instead of\nthe default $*SCHEDULER, or change the environment the process is going to\nrun in via the named argument :$ENV or the directory via the named argument\n:$cwd.\n\nIf start is called on a Proc::Async object on which it has already been\ncalled before, an exception of type X::Proc::Async::AlreadyStarted is\nthrown.\n\nNote: If you wish to await the Promise and discard its result, using\n\n    try await $p.start;\n\n\nwill throw if the program exited with non-zero status, as the Proc returned\nas the result of the Promise throws when sunk and in this case it will get\nsunk outside the try. To avoid that, sink it yourself inside the try:\n\n    try sink await $p.start;","started\n\n    method started(Proc::Async:D: --> Bool:D)\n\nReturns False before .start has been called, and True afterwards.","ready\n\n    method ready(Proc::Async:D: --> Promise:D)\n\nReturns a Promise that will be kept once the process has successfully\nstarted. Promise will be broken if the program fails to start.\n\nImplementation-specific note: Starting from Rakudo 2018.04, the returned\npromise will hold the process id (PID).","pid\n\n    method pid(Proc::Async:D: --> Promise:D)\n\nEquivalent to ready.\n\nReturns a Promise that will be kept once the process has successfully\nstarted. Promise will be broken if the program fails to start. Returned\npromise will hold the process id (PID).\n\nImplementation-specific note: Available starting from Rakudo 2018.04.","path\n\n    method path(Proc::Async:D:)\n\nDeprecated as of v6.d. Use command instead.\n\nReturns the name and/or path of the external program that was passed to the\nnew method as first argument.","args\n\n    method args(Proc::Async:D: --> Positional:D)\n\nDeprecated as of v6.d. Use command instead.\n\nReturns the command line arguments for the external programs, as passed to\nthe new method.","command\n\n    method command(Proc::Async:D: --> List:D)\n\nAvailable as of v6.d.\n\nReturns the command and arguments used for this Proc::Async object:\n\n    my $p := Proc::Async.new: 'cat', 'some', 'files';\n    $p.command.say; # OUTPUT: «(cat some files)␤»","write\n\n    method write(Proc::Async:D: Blob:D $b, :$scheduler = $*SCHEDULER --> Promise:D)\n\nWrite the binary data in $b to the standard input stream of the external\nprogram.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method write, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","print\n\n    method print(Proc::Async:D: Str(Any) $str, :$scheduler = $*SCHEDULER)\n\nWrite the text data in $str to the standard input stream of the external\nprogram, encoding it as UTF-8.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method print, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","say\n\n    method say(Proc::Async:D: $output, :$scheduler = $*SCHEDULER)\n\nCalls method gist on the $output, adds a newline, encodes it as UTF-8, and\nsends it to the standard input stream of the external program, encoding it\nas UTF-8.\n\nReturns a Promise that will be kept once the data has fully landed in the\ninput buffer of the external program.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method say, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","Supply\n\n    multi method Supply(Proc::Async:D: :$bin!)\n    multi method Supply(Proc::Async:D: :$enc, :$translate-nl)\n\nReturns a Supply of merged stdout and stderr streams. If :$bin named\nargument is provided, the Supply will be binary, producing Buf objects,\notherwise, it will be in character mode, producing Str objects and :$enc\nnamed argument can specify encoding to use. The :$translate-nl option\nspecifies whether new line endings should be translated for to match those\nused by the current operating system (e.g. \\r\\n on Windows).\n\n    react {\n        with Proc::Async.new: «\"$*EXECUTABLE\" -e 'say 42; note 100'» {\n            whenever .Supply { .print }  # OUTPUT: «42␤100␤»\n            whenever .start {}\n        }\n    }\n\n\nIt is an error to create both binary and non-binary .Supply. It is also an\nerror to use both .Supply and either stderr or stdout supplies.","close-stdin\n\n    method close-stdin(Proc::Async:D: --> True)\n\nCloses the standard input stream of the external program. Programs that\nread from STDIN often only terminate when their input stream is closed. So\nif waiting for the promise from #method start hangs (for a program opened\nfor writing), it might be a forgotten close-stdin.\n\nThe Proc::Async object must be created for writing (with\nProc::Async.new(:w, $path, @args)). Otherwise an\nX::Proc::Async::OpenForWriting exception will the thrown.\n\nstart must have been called before calling method close-stdin, otherwise an\nX::Proc::Async::MustBeStarted exception is thrown.","kill\n\n    method kill(Proc::Async:D: $signal = \"HUP\")\n\nSends a signal to the running program. The signal can be a signal name\n(\"KILL\" or \"SIGKILL\"), an integer (9) or an element of the Signal enum\n(Signal::SIGKILL)."],"name":"Proc::Async"},{"methods":["restore\n\n    method restore(--> Bool:D)\n\nUnwraps a wrapped routine and returns Bool::True on success."],"desc":"TITLE\nclass Routine::WrapHandle\n\nSUBTITLE\nHolds all information needed to unwrap a wrapped routine.\n\nclass WrapHandle { ... }\n\nWrapHandle is a Rakudo private class created and returned by wrap. Its only\nuse is to unwrap wrapped routines. Either call unwrap on a routine object\nor call the method restore on a Routine::WrapHandle object.\n\n    sub f() { say 'f was called' }\n    my $wrap-handle = &f.wrap({ say 'before'; callsame; say 'after' });\n    f;                    # OUTPUT: «before␤f was called␤after␤»\n    $wrap-handle.restore;\n    f;                    # OUTPUT: «f was called␤»\n\nAs such private class, it may suffer any kind of changes without prior\nnotice. It is only mentioned here since it is visible by the user who\nchecks the return type of the Routine.wrap method.\n\n","name":"Routine::WrapHandle"},{"desc":"TITLE\nrole CompUnit::Repository\n\nSUBTITLE\nCompUnit::Repository\n\nThe CompUnit::Repository role defines the interface of the implementation\nof CompUnit::Repositories such as CompUnit::Repository::Installation and\nCompUnit::Repository::FileSystem.\n\n","methods":["resolve\n\n    method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec.","need\n\nLoads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec.","load\n\n    method load(IO::Path:D $file --> CompUnit:D)\n\nLoad the $file and return a CompUnit object representing it.","loaded\n\n    method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded."],"name":"CompUnit::Repository"},{"name":"Encoding::Registry","methods":["name\n\n    method register(Encoding $enc --> Nil)\n\nRegister a new Encoding.","find\n\n    method find(Str() $name)\n\nFinds an encoding by its name. Returns an Encoding::Encoder or\nEncoding::Decoder, depending on what had been registered."],"desc":"TITLE\nclass Encoding::Registry\n\nSUBTITLE\nManagement of available encodings\n\n    class Encoding::Registry {}\n\nEncoding::Registry is initialized with a list of encoding that is available\nfor any Raku application, namely:\n\n  * utf8\n\n  * utf8-c8\n\n  * utf16\n\n  * utf16le\n\n  * utf16be\n\n  * utf32, utf-32\n\n  * ascii\n\n  * iso-8859-1, iso_8859-1:1987, iso_8859-1, iso-ir-100, latin1, latin-1,\n  csisolatin1, l1, ibm819, cp819\n\n  * windows-1251\n\n  * windows-1252\n\n  * windows-932\n\n"},{"desc":"TITLE\nclass IO::Handle\n\nSUBTITLE\nOpened file or stream\n\n    class IO::Handle { }\n\nInstances of IO::Handle encapsulate an handle to manipulate input/output\nresources. Usually there is no need to create directly an IO::Handle\ninstance, since it will be done by other roles and methods. For instance,\nan IO::Path object provides an open method that returns an IO::Handle:\n\n    my $fh = '/tmp/log.txt'.IO.open;\n    say $fh.^name; # OUTPUT: IO::Handle\n\nThe first line is pretty much equivalent to the following piece of code:\n\n    my $fh = IO::Handle.new( :path( '/tmp/log.txt'.IO.path ) ).open;\n\n","methods":["open\n\nDefined as:\n\n    method open(IO::Handle:D:\n        :$bin, :$enc, :$chomp, :$nl-in, Str:D :$nl-out,\n        Str :$mode,\n        :$r, :$w, :$a, :$x, :$update, :$rw, :$rx, :$ra,\n        :$create, :$append, :$truncate, :$exclusive,\n        :$out-buffer,\n        --> IO::Handle:D\n    )\n\n\nOpens the handle in one of the modes. Fails with appropriate exception if\nthe open fails.\n\nSee description of individual methods for the accepted values and behavior\nof :$chomp, :$nl-in, :$nl-out, and :$enc. The values for parameters default\nto the invocant's attributes and if any of them are provided, the\nattributes will be updated to the new values. Specify :$bin set to True\ninstead of :$enc to indicate the handle should be opened in binary mode.\nSpecifying undefined value as :$enc is equivalent to not specifying :$enc\nat all. Specifying both a defined encoding as :$enc and :$bin set to true\nwill cause X::IO::BinaryAndEncoding exception to be thrown.\n\nThe open mode defaults to non-exclusive, read only (same as specifying :r)\nand can be controlled by a mix of the following arguments:\n\n    :r      same as specifying   :mode<ro>  same as specifying nothing\n\n    :w      same as specifying   :mode<wo>, :create, :truncate\n    :a      same as specifying   :mode<wo>, :create, :append\n    :x      same as specifying   :mode<wo>, :create, :exclusive\n\n    :update same as specifying   :mode<rw>\n    :rw     same as specifying   :mode<rw>, :create\n    :ra     same as specifying   :mode<rw>, :create, :append\n    :rx     same as specifying   :mode<rw>, :create, :exclusive\n\n\nSupport for combinations of modes other than what is listed above is\nimplementation-dependent and should be assumed unsupported. That is,\nspecifying, for example, .open(:r :create) or .open(:mode<wo> :append\n:truncate) might work or might cause the Universe to implode, depending on\na particular implementation. This applies to reads/writes to a handle\nopened in such unsupported modes as well.\n\nThe mode details are:\n\n    :mode<ro>  means \"read only\"\n    :mode<wo>  means \"write only\"\n    :mode<rw>  means \"read and write\"\n\n    :create    means the file will be created, if it does not exist\n    :truncate  means the file will be emptied, if it exists\n    :exclusive means .open will fail if the file already exists\n    :append    means writes will be done at the end of file's current contents\n\n\nAttempts to open a directory, write to a handle opened in read-only mode or\nread from a handle opened in write-only mode, or using text-reading methods\non a handle opened in binary mode will fail or throw.\n\nIn 6.c language, it's possible to open path '-', which will cause open to\nopen (if closed) the $*IN handle if opening in read-only mode or to open\nthe $*OUT handle if opening in write-only mode. All other modes in this\ncase will result in exception being thrown.\n\nAs of 6.d language version, use path '-' is deprecated and it will be\nremoved in future language versions entirely.\n\nThe :out-buffer controls output buffering and by default behaves as if it\nwere Nil. See method out-buffer for details.\n\nNote (Rakudo versions before 2017.09): Filehandles are NOT flushed or\nclosed when they go out of scope. While they will get closed when garbage\ncollected, garbage collection isn't guaranteed to get run. This means you\nshould use an explicit close on handles opened for writing, to avoid data\nloss, and an explicit close is recommended on handles opened for reading as\nwell, so that your program does not open too many files at the same time,\ntriggering exceptions on further open calls.\n\nNote (Rakudo versions 2017.09 and after): Open filehandles are\nautomatically closed on program exit, but it is still highly recommended\nthat you close opened handles explicitly.","comb\n\nDefined as:\n\n    method comb(IO::Handle:D: Bool :$close, |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.comb does,\ntaking the same arguments, closing the handle when done if $close is set to\na true value. Implementations may slurp the file in its entirety when this\nmethod is called.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open;\n    say \"The file has {+$fh.comb: '♥', :close} ♥s in it\";","chomp\n\nDefined as:\n\n    has $.chomp is rw = True\n\nOne of the attributes that can be set via .new or open. Defaults to True.\nTakes a Bool specifying whether the line separators (as defined by .nl-in)\nshould be removed from content when using .get or .lines methods.","get\n\nDefined as:\n\n    method get(IO::Handle:D: --> Str:D)\n    multi sub get (IO::Handle $fh = $*ARGFILES --> Str:D)\n\nReads a single line of input from the handle, removing the trailing newline\ncharacters (as set by .nl-in) if the handle's .chomp attribute is set to\nTrue. Returns Nil, if no more input is available. The subroutine form\ndefaults to $*ARGFILES if no handle is given.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    $*IN.get.say;              # Read one line from the standard input\n\n    my $fh = open 'filename';\n    $fh.get.say;               # Read one line from a file\n    $fh.close;\n\n    say get;                   # Read one line from $*ARGFILES","getc\n\nDefined as:\n\n    method getc(IO::Handle:D: --> Str:D)\n    multi sub getc (IO::Handle $fh = $*ARGFILES --> Str:D)\n\nReads a single character from the input stream. Attempting to call this\nmethod when the handle is in binary mode will result in X::IO::BinaryMode\nexception being thrown. The subroutine form defaults to $*ARGFILES if no\nhandle is given. Returns Nil, if no more input is available, otherwise\noperation will block, waiting for at least one character to be available;\nthese caveats apply:\n\n    Buffering terminals\n\nUsing getc to get a single keypress from a terminal will only work properly\nif you've set the terminal to \"unbuffered\". Otherwise the terminal will\nwait for the return key to be struck or the buffer to be filled up before\nperl6 gets even a single byte of data.\n\n    Waiting for potential combiners\n\nIf your handle's encoding allows combining characters to be read, perl6\nwill wait for more data to be available before it provides a character.\nThis means that inputting an \"e\" followed by a combining acute will give\nyou an e with an acute rather than giving an \"e\" and letting the next\nreading function give you a dangling combiner. However, it also means that\nwhen the user inputs just an \"e\" and has no intention to also input a\ncombining acute, your program will be waiting for another keypress before\nthe initial \"e\" is returned.\n\n  submethod DESTROY\n\nDefined as:\n\n    submethod DESTROY(IO::Handle:D:)\n\nCloses the filehandle, unless its native-descriptor is 2 or lower. This\nensures the standard filehandles do not get inadvertently closed.\n\nNote that garbage collection is not guaranteed to happen, so you must NOT\nrely on DESTROY for closing the handles you write to and instead close them\nyourself. Programs that open a lot of files should close the handles\nexplicitly as well, regardless of whether they were open for writing, since\ntoo many files might get opened before garbage collection happens and the\nno longer used handles get closed.","gist\n\nDefined as:\n\n    method gist(IO::Handle:D: --> Str:D)\n\nReturns a string containing information which .path, if any, the handle is\ncreated for and whether it is .opened.\n\n    say IO::Handle.new; # IO::Handle<(Any)>(closed)\n    say \"foo\".IO.open;  # IO::Handle<\"foo\".IO>(opened)","eof\n\nDefined as:\n\n    method eof(IO::Handle:D: --> Bool:D)\n\nNon-blocking. Returns True if the read operations have exhausted the\ncontents of the handle. For seekable handles, this means current position\nis at or beyond the end of file and seeking an exhausted handle back into\nthe file's contents will result in eof returning False again.\n\nOn non-seekable handles and handles opened to zero-size files (including\nspecial files in /proc/), EOF won't be set until a read operation fails to\nread any bytes. For example, in this code, the first read consumes all of\nthe data, but it's only until the second read that reads nothing would the\nEOF on a TTY handle be set:\n\n    $ echo \"x\" | perl6 -e 'with $*IN { .read: 10000; .eof.say; .read: 10; .eof.say }'\n    False\n    True","encoding\n\nDefined as:\n\n    multi method encoding(IO::Handle:D: --> Str:D)\n    multi method encoding(IO::Handle:D: $enc --> Str:D)\n\nReturns a Str representing the encoding currently used by the handle,\ndefaulting to \"utf8\". Nil indicates the filehandle is currently in binary\nmode. Specifying an optional positional $enc argument switches the encoding\nused by the handle; specify Nil as encoding to put the handle into binary\nmode.\n\nThe accepted values for encoding are case-insensitive. The available\nencodings vary by implementation and backend. On Rakudo MoarVM the\nfollowing are supported:\n\n    utf8\n    utf16\n    utf16le\n    utf16be\n    utf8-c8\n    iso-8859-1\n    windows-1251\n    windows-1252\n    windows-932\n    ascii\n\n\nThe default encoding is utf8, which undergoes normalization into Unicode\nNFC (normalization form canonical). In some cases you may want to ensure no\nnormalization is done; for this you can use utf8-c8. Before using utf8-c8\nplease read Unicode: Filehandles and I/O for more information on utf8-c8\nand NFC.\n\nAs of Rakudo 2018.04 windows-932 is also supported which is a variant of\nShiftJIS.\n\nImplementation may choose to also provide support for aliases, e.g. Rakudo\nallows aliases latin-1 for iso-8859-1 encoding and dashed utf versions:\nutf-8 and utf-16.\n\n    utf16, utf16le and utf16be\n\nUnlike utf8, utf16 has an endianness — either big endian or little endian.\nThis relates to the ordering of bytes. Computer CPUs also have an\nendianness. Raku's utf16 format specifier will use the endianness of host\nsystem when encoding. When decoding it will look for a byte order mark and\nif it is there use that to set the endianness. If there is no byte order\nmark it will assume the file uses the same endianness as the host system. A\nbyte order mark is the codepoint U+FEFF which is ZERO WIDTH NO-BREAK SPACE.\nOn utf16 encoded files the standard states if it exists at the start of a\nfile it shall be interpreted as a byte order mark, not a U+FEFF codepoint.\n\nWhile writing will cause a different file to be written on different endian\nsystems, at the release of 2018.10 the byte order mark will be written out\nwhen writing a file and files created with the utf16 encoding will be able\nto be read on either big or little endian systems.\n\nWhen using utf16be or utf16le encodings a byte order mark is not used. The\nendianness used is not affected by the host cpu type and is either big\nendian for utf16be or little endian for utf16le.\n\nIn keeping with the standard, a 0xFEFF byte at the start of a file is\ninterpreted as a ZERO WIDTH NO-BREAK SPACE and not as a byte order mark. No\nbyte order mark is written to files that use the utf16be or utf16le\nencodings.\n\nAs of Rakudo 2018.09 on MoarVM, utf16, utf16le and utf16be are supported.\nIn 2018.10, writing to a file with utf16 will properly add a byte order\nmark (BOM).\n\n    Examples\n\n    with 'foo'.IO {\n        .spurt: \"First line is text, then:\\nBinary\";\n        my $fh will leave {.close} = .open;\n        $fh.get.say;         # OUTPUT: «First line is text, then:␤»\n        $fh.encoding: Nil;\n        $fh.slurp.say;       # OUTPUT: «Buf[uint8]:0x<42 69 6e 61 72 79>␤»\n    }","lines\n\nDefined as:\n\n    sub lines(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    method lines(IO::Handle:D:               $limit = Inf, :$close --> Seq:D)\n\nReturn a Seq each element of which is a line from the handle (that is\nchunks delineated by .nl-in). If the handle's .chomp attribute is set to\nTrue, then characters specified by .nl-in will be stripped from each line.\n\nReads up to $limit lines, where $limit can be a non-negative Int, Inf, or\nWhatever (which is interpreted to mean Inf). If :$close is set to True,\nwill close the handle when the file ends or $limit is reached. Subroutine\nform defaults to $*ARGFILES, if no handle is provided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\nNOTE: the lines are read lazily, so ensure the returned Seq is either fully\nreified or is no longer needed when you close the handle or attempt to use\nany other method that changes the file position.\n\n    say \"The file contains \",\n      '50GB-file'.IO.open.lines.grep(*.contains: 'Perl').elems,\n      \" lines that mention Perl\";\n    # OUTPUT: «The file contains 72 lines that mention Perl␤»","lock\n\nDefined as:\n\n    method lock(IO::Handle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)\n\nPlaces an advisory lock on the filehandle. If :$non-blocking is True will\nfail with X::IO::Lock if lock could not be obtained, otherwise will block\nuntil the lock can be placed. If :$shared is True will place a shared\n(read) lock, otherwise will place an exclusive (write) lock. On success,\nreturns True; fails with X::IO::Lock if lock cannot be placed (e.g. when\ntrying to place a shared lock on a filehandle opened in write mode or\ntrying to place an exclusive lock on a filehandle opened in read mode).\n\nYou can use lock again to replace an existing lock with another one. To\nremove a lock, close the filehandle or use unlock.\n\n    # One program writes, the other reads, and thanks to locks either\n    # will wait for the other to finish before proceeding to read/write\n\n    # Writer\n    given \"foo\".IO.open(:w) {\n        .lock;\n        .spurt: \"I ♥ Raku!\";\n        .close; # closing the handle unlocks it; we could also use `unlock` method for that\n    }\n\n    # Reader\n    given \"foo\".IO.open {\n        .lock: :shared;\n        .slurp.say; # OUTPUT: «I ♥ Raku!␤»\n        .close;\n    }","unlock\n\nDefined as:\n\n    method unlock(IO::Handle:D: --> True)\n\nRemoves a lock from the filehandle.","words\n\nDefined as:\n\n    multi sub words(IO::Handle:D $fh = $*ARGFILES, $limit = Inf, :$close --> Seq:D)\n    multi method words(IO::Handle:D: $limit = Inf, :$close --> Seq:D)\n\nSimilar to Str.words, separates the handle's stream on contiguous chunks of\nwhitespace (as defined by Unicode) and returns a Seq of the resultant\n\"words.\" Takes an optional $limit argument that can be a non-negative Int,\nInf, or Whatever (which is interpreted to mean Inf), to indicate only up-to\n$limit words must be returned. If Bool :$close named argument is set to\nTrue, will automatically close the handle when the returned Seq is\nexhausted. Subroutine form defaults to $*ARGFILES, if no handle is\nprovided.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my %dict := bag $*IN.words;\n    say \"Most common words: \", %dict.sort(-*.value).head: 5;\n\n\nNOTE: implementations may read more data than necessary when a call to\n.words is made. That is, $handle.words(2) may read more data than two\n\"words\" worth of data and subsequent calls to read methods might not read\nfrom the place right after the two fetched words. After a call to .words,\nthe file position should be treated as undefined.","split\n\nDefined as:\n\n    method split(IO::Handle:D: :$close, |c)\n\nSlurps the handle's content and calls Str.split on it, forwarding any of\nthe given arguments. If :$close named parameter is set to True, will close\nthe invocant after slurping.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open;\n    $fh.split: '♥', :close; # Returns file content split on ♥","spurt\n\nDefined as:\n\n    multi method spurt(IO::Handle:D: Blob $data, :$close = False)\n    multi method spurt(IO::Handle:D: Cool $data, :$close = False)\n\nWrites all of the $data into the filehandle, closing it when finished, if\n$close is True. For Cool $data, will use the encoding the handle is set to\nuse (IO::Handle.open or IO::Handle.encoding).\n\nBehavior for spurting a Cool when the handle is in binary mode or spurting\na Blob when the handle is NOT in binary mode is undefined.","print\n\nDefined as:\n\n    multi method print(**@text --> True)\n    multi method print(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them. Junction arguments autothread and the order\nof printed strings is not guaranteed. See write to write bytes.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.print: 'some text';\n    $fh.close;","print-nl\n\nDefined as:\n\n    method print-nl(IO::Handle:D: --> True)\n\nWrites the value of $.nl-out attribute into the handle. This attribute, by\ndefault, is ␤, but see the page on newline for the rules it follows in\ndifferent platforms and environments.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w, :nl-out(\"\\r\\n\");\n    $fh.print: \"some text\";\n    $fh.print-nl; # prints \\r\\n\n    $fh.close;","printf\n\nDefined as:\n\n    multi method printf(IO::Handle:D: Cool $format, *@args)\n\nFormats a string based on the given format and arguments and .prints the\nresult into the filehandle. See sub sprintf for details on acceptable\nformat directives.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = open 'path/to/file', :w;\n    $fh.printf: \"The value is %d\\n\", 32;\n    $fh.close;","out-buffer\n\nDefined as:\n\n    method out-buffer(--> Int:D) is rw\n\nControls output buffering and can be set via an argument to open. Takes an\nint as the size of the buffer to use (zero is acceptable). Can take a Bool:\nTrue means to use default, implementation-defined buffer size; False means\nto disable buffering (equivalent to using 0 as buffer size).\n\nLastly, can take a Nil to enable TTY-based buffering control: if the handle\nis a TTY, the buffering is disabled, otherwise, default,\nimplementation-defined buffer size is used.\n\nSee flush to write out data currently in the buffer. Changing buffer size\nflushes the filehandle.\n\n    given 'foo'.IO.open: :w, :1000out-buffer {\n        .say: 'Hello world!'; # buffered\n        .out-buffer = 42;       # buffer resized; previous print flushed\n        .say: 'And goodbye';\n        .close; # closing the handle flushes the buffer\n    }","put\n\nDefined as:\n\n    multi method put(**@text --> True)\n    multi method put(Junction:D --> True)\n\nWrites the given @text to the handle, coercing any non-Str objects to Str\nby calling .Str method on them, and appending the value of .nl-out at the\nend. Junction arguments autothread and the order of printed strings is not\nguaranteed.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = 'path/to/file'.IO.open: :w;\n    $fh.put: 'some text';\n    $fh.close;","say\n\nDefined as:\n\n    multi method say(IO::Handle:D: **@text --> True)\n\nThis method is identical to put except that it stringifies its arguments by\ncalling .gist instead of .Str.\n\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    my $fh = open 'path/to/file', :w;\n    $fh.say(Complex.new(3, 4));        # RESULT: «3+4i\\n»\n    $fh.close;","read\n\nDefined as:\n\n    method read(IO::Handle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)\n\nBinary reading; reads and returns up to $bytes bytes from the filehandle.\n$bytes defaults to an implementation-specific value (in Rakudo, the value\nof $*DEFAULT-READ-ELEMS, which by default is set to 65536). This method can\nbe called even when the handle is not in binary mode.\n\n    (my $file = 'foo'.IO).spurt: 'I ♥ Perl';\n    given $file.open {\n        say .read: 6; # OUTPUT: «Buf[uint8]:0x<49 20 e2 99 a5 20>␤»\n        .close;\n    }","readchars\n\nDefined as:\n\n    method readchars(IO::Handle:D: Int(Cool:D) $chars = 65536 --> Str:D)\n\nReading chars; reads and returns up to $chars chars (graphemes) from the\nfilehandle. $chars defaults to an implementation-specific value (in Rakudo,\nthe value of $*DEFAULT-READ-ELEMS, which by default is set to 65536).\nAttempting to call this method when the handle is in binary mode will\nresult in X::IO::BinaryMode exception being thrown.\n\n    (my $file = 'foo'.IO).spurt: 'I ♥ Perl';\n    given $file.open {\n        say .readchars: 5; # OUTPUT: «I ♥ P␤»\n        .close;\n    }","write\n\nDefined as:\n\n    method write(IO::Handle:D: Blob:D $buf --> True)\n\nWrites $buf to the filehandle. This method can be called even when the\nhandle is not in binary mode.","seek\n\nDefined as:\n\n    method seek(IO::Handle:D: Int:D $offset, SeekType:D $whence --> True)\n\nMove the file pointer (that is, the position at which any subsequent read\nor write operations will begin) to the byte position specified by $offset\nrelative to the location specified by $whence which may be one of:\n\n  * SeekFromBeginning: The beginning of the file.\n\n  * SeekFromCurrent: The current position in the file.\n\n  * SeekFromEnd: The end of the file. Please note that you need to specify a\n  negative offset if you want to position before the end of the file.","tell\n\nDefined as:\n\n    method tell(IO::Handle:D: --> Int:D)\n\nReturn the current position of the file pointer in bytes.","slurp-rest\n\nDefined as:\n\n    multi method slurp-rest(IO::Handle:D: :$bin! --> Buf)\n    multi method slurp-rest(IO::Handle:D: :$enc --> Str)\n\nDEPRECATION NOTICE: this method is deprecated in the 6.d version. Do not\nuse it for new code, use .slurp method instead.\n\nReturns the remaining content of the file from the current file position\n(which may have been set by previous reads or by seek.) If the adverb :bin\nis provided a Buf will be returned; otherwise the return will be a Str with\nthe optional encoding :enc.","slurp\n\nDefined as:\n\n    method slurp(IO::Handle:D: :$close, :$bin)\n\nReturns all the content from the current file pointer to the end. If the\ninvocant is in binary mode or if $bin is set to True, will return a Buf,\notherwise will decode the content using invocant's current .encoding and\nreturn a Str.\n\nIf :$close is set to True, will close the handle when finished reading.\n\nNote: On Rakudo this method was introduced with release 2017.04; $bin arg\nwas added in 2017.10.","Supply\n\nDefined as:\n\n    multi method Supply(IO::Handle:D: :$size = 65536)\n\nReturns a Supply that will emit the contents of the handle in chunks. The\nchunks will be Buf if the handle is in binary mode or, if it isn't, Str\ndecoded using same encoding as IO::Handle.encoding.\n\nThe size of the chunks is determined by the optional :size named parameter\nand 65536 bytes in binary mode or 65536 characters in non-binary mode.\n\n    \"foo\".IO.open(:bin).Supply(:size<10>).tap: *.perl.say;\n    # OUTPUT:\n    # Buf[uint8].new(73,32,226,153,165,32,80,101,114,108)\n    # Buf[uint8].new(32,54,33,10)\n\n    \"foo\".IO.open.Supply(:size<10>).tap: *.perl.say;\n    # OUTPUT:\n    # \"I ♥ Perl\"\n    # \" 6!\\n\"","path\n\nDefined as:\n\n    method path(IO::Handle:D:)\n\nFor a handle opened on a file this returns the IO::Path that represents the\nfile. For the standard I/O handles $*IN, $*OUT, and $*ERR it returns an\nIO::Special object.","IO\n\nDefined as:\n\n    method IO(IO::Handle:D:)\n\nAlias for .path","Str\n\nReturns the value of .path, coerced to Str.\n\n    say \"foo\".IO.open.path; # OUTPUT: «\"foo\".IO␤»","close\n\nDefined as:\n\n    method close(IO::Handle:D: --> Bool:D)\n    multi sub close(IO::Handle $fh)\n\nCloses an open filehandle. It's not an error to call close on an\nalready-closed filehandle. Returns True on success. If you close one of the\nstandard filehandles (by default: $*IN, $*OUT, or $*ERR), that is any\nhandle with native-descriptor 2 or lower, you won't be able to re-open such\na handle.\n\nIt's a common idiom to use LEAVE phaser for closing the handles, which\nensures the handle is closed regardless of how the block is left.\n\n    if $do-stuff-with-the-file {\n        my $fh = open \"path-to-file\";\n        LEAVE close $fh;\n        # ... do stuff with the file\n    }\n\n    sub do-stuff-with-the-file (IO $path-to-file)\n      my $fh = $path-to-file.open;\n\n      # stick a `try` on it, since this will get run even when the sub is\n      # called with wrong arguments, in which case the `$fh` will be an `Any`\n      LEAVE try close $fh;\n\n      # ... do stuff with the file\n    }\n\n    given \"foo/bar\".IO.open(:w) {\n        .spurt: \"I ♥ Raku!\";\n        .close;\n    }\n\n\nNote: unlike some other languages, Raku does not use reference counting,\nand so the filehandles are NOT closed when they go out of scope. While they\nwill get closed when garbage collected, garbage collection isn't guaranteed\nto get run. This means you must use an explicit close on handles opened for\nwriting, to avoid data loss, and an explicit close is recommended on\nhandles opened for reading as well, so that your program does not open too\nmany files at the same time, triggering exceptions on further open calls.\n\nNote several methods allow for providing :close argument, to close the\nhandle after the operation invoked by the method completes. As a simpler\nalternative, the IO::Path type provides many reading and writing methods\nthat let you work with files without dealing with filehandles directly.","flush\n\nDefined as:\n\n    method flush(IO::Handle:D: --> True)\n\nWill flush the handle, writing any of the buffered data. Returns True on\nsuccess; otherwise, fails with X::IO::Flush.\n\n    given \"foo\".IO.open: :w {\n        LEAVE .close;\n        .print: 'something';\n        'foo'.IO.slurp.say; # (if the data got buffered) OUTPUT: «␤»\n        .flush;             # flush the handle\n        'foo'.IO.slurp.say; # OUTPUT: «something␤»\n    }","native-descriptor\n\nDefined as:\n\n    method native-descriptor()\n\nThis returns a value that the operating system would understand as a \"file\ndescriptor\" and is suitable for passing to a native function that requires\na file descriptor as an argument such as fcntl or ioctl.","nl-in\n\nDefined as:\n\n    method nl-in(--> Str:D) is rw\n\nOne of the attributes that can be set via .new or open. Defaults to\n[\"\\x0A\", \"\\r\\n\"]. Takes either a Str or Array of Str specifying input line\nending(s) for this handle. If .chomp attribute is set to True, will strip\nthese endings in routines that chomp, such as get and lines.\n\n    with 'test'.IO {\n        .spurt: '1foo2bar3foo'; # write some data into our test file\n        my $fh will leave {.close} = .open; # can also set .nl-in via .open arg\n        $fh.nl-in = [<foo bar>]; # set two possible line endings to use;\n        $fh.lines.say; # OUTPUT: (\"1\", \"2\", \"3\").Seq\n    }","nl-out\n\nDefined as:\n\n    has Str:D $.nl-out is rw = \"\\n\";\n\nOne of the attributes that can be set via .new or open. Defaults to \"\\n\".\nTakes a Str specifying output line ending for this handle, to be used by\nmethods .put and .say.\n\n    with 'test'.IO {\n        given .open: :w {\n            .put: 42;\n            .nl-out = 'foo';\n            .put: 42;\n            .close;\n        }\n        .slurp.perl.say; # OUTPUT: «\"42\\n42foo\"»\n    }","opened\n\nDefined as:\n\n    method opened(IO::Handle:D: --> Bool:D)\n\nReturns True if the handle is open, False otherwise.","t \n\nDefined as:\n\n    method t(IO::Handle:D: --> Bool:D)\n\nReturns True if the handle is opened to a TTY, False otherwise.\n\nCreating Custom Handles\n\nAs of 6.d language (early implementation available in Rakudo compiler\nversion 2018.08), a few helper methods are available to simplify creation\nof custom IO::Handle objects. In your subclass you simply need to implement\nthose methods to affect all of the related features. If your handle wants\nto work with textual read/write methods and doesn't use the standard .open\nmethod, be sure to call .encoding method in your custom handle to get\ndecoder/encoder properly set up:\n\n    class IO::URL is IO::Handle {\n        has $.URL is required;\n        has Buf $!content;\n        submethod TWEAK {\n            use WWW; # ecosystem module that will let us `get` a web page\n            use DOM::Tiny; # ecosystem module that will parse out all text from HTML\n            $!content := Buf.new: DOM::Tiny.parse(get $!URL).all-text(:trim).encode;\n            self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method open(|)  { self }       # block out some IO::Handle methods\n        method close(|) { self }       # that work with normal low-level file\n        method opened   { ! self.EOF } # handles, since we don't. This isn't\n        method lock(| --> True) { }    # necessary, but will make our handle\n        method unlock( --> True) { }   # be more well-behaved if someone\n        # actually calls one of these methods. There are more of these you\n        # can handle, such as .tell, .seek, .flush, .native-descriptor, etc.\n\n        method WRITE(|) {\n            # For this handle we'll just die on write. If yours can handle writes.\n            # The data to write will be given as a Blob positional argument.\n            die \"Cannot write into IO::URL\";\n        }\n        method READ(\\bytes) {\n            # We splice off the requested number of bytes from the head of\n            # our content Buf. The handle's decoder will handle decoding them\n            # automatically, if textual read methods were called on the handle.\n            $!content.splice: 0, bytes\n        }\n        method EOF {\n            # For \"end of file\", we'll simply report whether we still have\n            # any bytes of the website we fetched on creation.\n            not $!content\n        }\n    }\n\n    my $fh := IO::URL.new: :URL<www.perl6.org>;\n\n    # .slurp and print all the content from the website. We can use all other\n    # read methods, such as .lines, or .get, or .readchars. All of them work\n    # correctly, even though we only defined .READ and .EOF\n    $fh.slurp.say;","WRITE\n\nDefined as:\n\n    method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D)\n\nCalled whenever a write operation is performed on the handle. Always\nreceives the data as a Blob, even if a textual writing method has been\ncalled.\n\n    class IO::Store is IO::Handle {\n        has @.lines = [];\n\n        submethod TWEAK {\n            self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n            @!lines.push: data.decode();\n            True;\n        }\n\n        method gist() {\n            return @!lines.join(\"\\n\" );\n        }\n    }\n    my $store = IO::Store.new();\n    my $output = $PROCESS::OUT;\n    $PROCESS::OUT = $store;\n    .say for <one two three>;\n    $PROCESS::OUT = $output;\n    say $store.lines(); # OUTPUT «[one␤ two␤ three␤]»\n\n\nIn this example we are creating a simple WRITE redirection which stores\nanything written to the filehandle to an array. Se need to save the\nstandard output first, which we do in $output, and then everything that is\nprinted or said (through say) gets stored in the defined IO::Store class.\nTwo things should be taken into account in this class. By default,\nIO::Handles are in binary mode, so we need to TWEAK the objects if we want\nthem to work with text. Second, a WRITE operation should return True if\nsuccessful. It will fail if it does not.","READ\n\nDefined as:\n\n    method READ(IO::Handle:D: Int:D \\bytes --> Buf:D)\n\nCalled whenever a read operation is performed on the handle. Receives the\nnumber of bytes requested to read. Returns a Buf with those bytes which can\nbe used to either fill the decoder buffer or returned from reading methods\ndirectly. The result is allowed to have fewer than the requested number of\nbytes, including no bytes at all.\n\nIf you provide your own .READ, you very likely need to provide your own\n.EOF as well, for all the features to behave correctly.\n\nThe compiler may call .EOF method any number of times during a read\noperation to ascertain whether a call to .READ should be made. More bytes\nthan necessary to satisfy a read operation may be requested from .READ, in\nwhich case the extra data may be buffered by the IO::Handle or the decoder\nit's using, to fulfill any subsequent reading operations, without\nnecessarily having to make another .READ call.\n\n    class IO::Store is IO::Handle {\n        has @.lines = [];\n\n        submethod TWEAK {\n          self.encoding: 'utf8'; # set up encoder/decoder\n        }\n\n        method WRITE(IO::Handle:D: Blob:D \\data --> Bool:D) {\n          @!lines.push: data;\n          True;\n        }\n\n        method whole() {\n          my Buf $everything = Buf.new();\n          for @!lines -> $b {\n            $everything ~= $b;\n          }\n          return $everything;\n        }\n\n        method READ(IO::Handle:D: Int:D \\bytes --> Buf:D) {\n          my Buf $everything := self.whole();\n          return $everything;\n        }\n\n        method EOF {\n          my $everything = self.whole();\n          !$everything;\n        }\n    }\n\n    my $store := IO::Store.new();\n\n    $store.print( $_ ) for <one two three>;\n    say $store.read(3).decode; # OUTPUT «one␤»\n    say $store.read(3).decode; # OUTPUT «two␤»\n\n\nIn this case, we have programmed the two READ and EOF methods, as well as\nWRITE, which stores every line in an element in an array. The read method\nactually calls READ, returning 3 bytes, which correspond to the three\ncharacters in the first two elements. Please note that it's the IO::Handle\nbase class the one that is taking care of cursor, since READ just provides\na handle into the whole content of the object; the base class will READ\n1024 * 1024 bytes at a time. If your object is planned to hold an amount of\nbytes bigger than that, you will have to handle an internal cursor\nyourself. That is why in this example we don't actually use the bytes\nargument.","EOF\n\nDefined as:\n\n    method EOF(IO::Handle:D: --> Bool:D)\n\nIndicates whether \"end of file\" has been reached for the data source of the\nhandle; i.e. no more data can be obtained by calling .READ method. Note\nthat this is not the same as eof method, which will return True only if\n.EOF returns True and all the decoder buffers, if any were used by the\nhandle, are also empty. See .READ for an example implementation.\n\nRelated roles and classes\n\nSee also the related role IO and the related class IO::Path."],"name":"IO::Handle"},{"name":"IO::Pipe","desc":"TITLE\nclass IO::Pipe\n\nSUBTITLE\nBuffered inter-process string or binary stream\n\n    class IO::Pipe is IO::Handle {}\n\nAn IO::Pipe object closely corresponds to a UNIX pipe. It has one end where\nit consumes string or binary data, and another where it reproduces the same\ndata. It is buffered, so that a write without a read doesn't immediately\nblock.\n\nPipes can be easily constructed with sub run and Proc::Async.new.\n\n","methods":["close\n\nDefined as:\n\n    method close(IO::Pipe: --> Proc:D)\n\nCloses the pipe and returns Proc object from which the pipe originates.","IO\n\nDefined as:\n\n    method IO(IO::Pipe: --> IO::Path:U)\n\nReturns an IO::Path type object.","path\n\nDefined as:\n\n    method path(IO::Pipe: --> IO::Path:U)\n\nReturns an IO::Path type object.","proc\n\nDefined as:\n\n    method proc(IO::Pipe: --> Proc:D)\n\nReturns the Proc object from which the pipe originates."]},{"methods":["watch-path\n\n    method watch-path(IO::Notification: Str() $path, :$scheduler = $*SCHEDULER)\n\n\nReturns a Supply that emits IO::Notification::Change objects.\n\nIf $path is a file, only modifications of that file are reported. If $path\nis a directory, both modifications to the directory itself (for example\npermission changes) and to files in the directory (including new files in\nthe directory) are reported.\n\n:$scheduler allows you to specify which thread scheduler is responsible for\nthe notification stream."],"desc":"TITLE\nclass IO::Notification\n\nSUBTITLE\nAsynchronous notification for file and directory changes    \n\n    enum FileChangeEvent (:FileChanged(1), :FileRenamed(2));\n\n\n    class IO::Notification  {\n        class Change {\n            has $.path;\n            has $.event;\n        }\n        ...\n    }\n\n\nIO::Notification.watch-path($path) produces a Supply of\nIO::Notification::Change events for a file or directory.\n\nHere is a small example that prints the first ten FileChanged-notifications\nfor the current working directory:\n\n    my $finish = Promise.new;\n    my $count = 0;\n    IO::Notification.watch-path($*CWD).act( -> $change {\n        $count++ if $change.event ~~ FileChanged;\n        say \"($count) $change.path(): $change.event()\";\n        $finish.keep if $count >= 10;\n    });\n    await $finish;\n\n\nThe type of the change is very much dependent both on the platform and on\nspecific system calls that were used initiate the change. At this point in\ntime you should not rely on the type of change in general, and test your\nparticular situation.\n\n","name":"IO::Notification"},{"name":"IO::Socket","desc":"TITLE\nrole IO::Socket\n\nSUBTITLE\nNetwork socket\n\n    role IO::Socket { ... }\n\nIO::Socket contains read and write methods for sockets. It is usually used\nthrough IO::Socket::INET.\n\n","methods":["recv\n\n    method recv(IO::Socket:D: Cool $elems = Inf, :$bin)\n\nReceive a packet and return it, either as a Blob if :bin was passed, or a\nStr if not. Receives up to $elems or 65535 (whichever is smaller) bytes or\ncharacters.\n\nFails if the socket is not connected.","read\n\n    method read(IO::Socket:D: Int(Cool) $bytes)\n\nReads $bytes bytes from the socket and returns them in a Blob.\n\nFails if the socket is not connected.","get\n\nDefined as:\n\n    method get(IO::Socket:D: --> Str:D)\n\nReads a single line of input from the socket, removing the trailing newline\ncharacters (as set by .nl-in). Returns Nil, if no more input is available.\n\nFails if the socket is not connected.","print\n\n    method print(IO::Socket:D: Str(Cool) $string)\n\nWrites the supplied string to the socket, thus sending it to other end of\nthe connection. The binary version is #method write.\n\nFails if the socket is not connected.","write\n\n    method write(IO::Socket:D: Blob:D $buf)\n\nWrites the supplied buffer to the socket, thus sending it to other end of\nthe connection. The string version is #method print.\n\nFails if the socket is not connected.","put\n\n    method put(IO::Socket:D: Str(Cool) $string)\n\nWrites the supplied string, with a \\n appended to it, to the socket, thus\nsending it to other end of the connection.\n\nFails if the socket is not connected.","close\n\n    method close(IO::Socket:D)\n\nCloses the socket.\n\nFails if the socket is not connected.","native-descriptor\n\n    method native-descriptor()\n\nThis returns a value that the operating system would understand as a\n\"socket descriptor\" and is suitable for passing to a native function that\nrequires a socket descriptor as an argument such as setsockopt."]},{"desc":"TITLE\nclass IO::Special\n\nSUBTITLE\nPath to special I/O device\n\n    class IO::Special does IO { }\n\n\nUsed as a $.path attribute in filehandles for special standard input $*IN\nand output $*OUT and $*ERR. Provides a bridged interface of IO::Handle,\nmostly file tests and stringification.\n\n","methods":["new\n\n    method new(:$!what!)\n\n\nTakes a single required attribute what. It is unlikely that you will ever\nneed to construct one of these objects yourself.","what\n\n    say $*IN.path.what;  # OUTPUT: «<STDIN>␤»\n    say $*OUT.path.what; # OUTPUT: «<STDOUT>␤»\n    say $*ERR.path.what; # OUTPUT: «<STDERR>␤»\n\nReturns one of the strings '<STDIN>', '<STDOUT>', or '<STDERR>', specifying\nthe type of the special IO device.","WHICH\n\n    method WHICH(IO::Special:D: --> Str)\n\nThis returns a string that identifies the object. The string is composed by\nthe type of the instance (IO::Special) and the what attribute:\n\n    $*IN.path.what;  # OUTPUT: «<STDIN>␤»\n    $*IN.path.WHICH; # OUTPUT: «IO::Special<STDIN>␤»","Str\n\n    method Str(IO::Special:D:)\n\nThis returns '<STDIN>', '<STDOUT>', or '<STDERR>' as appropriate.","IO\n\n    method IO(IO::Special:D: --> IO::Special)\n\nReturns the invocant.\n\n    say $*IN.path.IO.what;  # OUTPUT: «<STDIN>␤»\n    say $*IN.path.what;     # OUTPUT: «<STDIN>␤»","e\n\n    method e(IO::Special:D: --> True)\n\nThe 'exists' file test operator, always returns True.","d\n\n    method d(IO::Special:D: --> False)\n\nThe 'directory' file test operator, always returns False.","f\n\n    method f(IO::Special:D: --> False)\n\nThe 'file' file test operator, always returns False.","s\n\n    method s(IO::Special:D: --> 0)\n\nThe 'size' file test operator, always returns 0.","l\n\n    method l(IO::Special:D: --> False)\n\nThe 'symbolic links' file test operator, always returns False.","r\n\n    method r(IO::Special:D: --> Bool)\n\nThe 'read access' file test operator, returns True if and only if this\ninstance represents the standard input handle(<STDIN>).","w\n\n    method w(IO::Special:D: --> Bool)\n\nThe 'write access' file test operator, returns True only if this instance\nrepresents either the standard output (<STOUT>) or the standard error\n(<STDERR>) handle.","x\n\n    method x(IO::Special:D: --> False)\n\nThe 'execute access' file test operator, always returns False.","modified\n\n    method modified(IO::Special:D: --> Instant)\n\nThe last modified time for the filehandle. It always returns an Instant\ntype object.","accessed\n\n    method accessed(IO::Special:D: --> Instant)\n\nThe last accessed time for the filehandle. It always returns an Instant\ntype object.","changed\n\n    method changed(IO::Special:D: --> Instant)\n\nThe last changed time for the filehandle. It always returns an Instant type\nobject.","mode\n\n    method mode(IO::Special:D: --> Nil)\n\nThe mode for the filehandle, it always returns Nil"],"name":"IO::Special"},{"name":"IO::CatHandle","desc":"TITLE\nclass IO::CatHandle\n\nSUBTITLE\nUse multiple IO handles as if they were one\n\n    class IO::CatHandle is IO::Handle { }\n\nThis class has been available in Rakudo since version 2017.06.\n\nThe IO::CatHandle|/type/IO::CatHandle class provides a means to create an\nIO::Handle that seamlessly gathers input from multiple IO::Handle and\nIO::Pipe sources.\n\nAll of the IO::Handle's methods are implemented, and while attempt to use\nwrite methods will (currently) throw and exception, an IO::CatHandle is\nusable anywhere a read-only IO::Handle can be used.\n\n","methods":["new\n\nDefined as:\n\n    method new(*@handles, :&on-switch, :$chomp = True,\n               :$nl-in = [\"\\n\", \"\\r\\n\"], Str :$encoding, Bool :$bin)\n\n\nCreates a new IO::CatHandle object.\n\nThe @handles positional argument indicates a source of handles for the\nIO::CatHandle to read from and can deal with a mixed collection of Cool,\nIO::Path, and IO::Handle (including IO::Pipe) objects. As input from\nIO::CatHandle is processed (so operations won't happen during .new call,\nbut only when @handles' data is needed), it will walk through the @handles\nlist, processing each argument as follows:\n\n  * the Cool objects will be coerced to IO::Path;\n\n  * IO::Path objects will be opened for reading using the IO::CatHandle's\n  (invocant's) attributes for open calls;\n\n  * un-opened IO::Handle objects will be opened in the same fashion as IO::Path\n  objects;\n\n  * and already opened IO::Handle objects will have all of their attributes set\n  to the attributes of the invocant IO::CatHandle.\n\nIn short, all the @handles end up as IO::Handle objects opened in the same\nmode and with the same attributes as the invocant IO::CatHandle.\n\nSee .on-switch method for details on the :&on-switch named argument, which\nby default is not set.\n\nThe :$encoding named argument specifies the handle's encoding and accepts\nthe same values as IO::Handle.encoding. Set :$bin named argument to True if\nyou wish the handle to be in binary mode. Attempting to specify both a\ndefined :$encoding and a True :$bin is a fatal error resulting in\nX::IO::BinaryAndEncoding exception thrown. If neither :$encoding is set nor\n:$bin set to a true value, the handle will default to utf8 encoding.\n\nThe :$chomp and :$nl-in arguments have the same meaning as in IO::Handle\nand take and default to the same values.","chomp\n\nDefined as:\n\n    method chomp(IO::CatHandle:D:) is rw\n\nSets the invocant's $.chomp attribute to the assigned value. All source\nhandles, including the active one will use the provided $.chomp value.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\\n\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\\n\";\n    with IO::CatHandle.new: $f1, $f2 {\n        # .chomp is True by default:\n        (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n        .chomp = False;\n        (.get xx 3).perl.say; # OUTPUT: «(\"C\\n\", \"D\\n\", \"E\\n\").Seq␤»\n        .close\n    }","nl-in\n\nDefined as:\n\n    method nl-in(IO::CatHandle:D:) is rw\n\nSets the invocant's $.nl-in attribute to the assigned value, which can be a\nStr or a List of Str, where each Str object represents the end-of-line\nstring. All source handles, including the active one will use the provided\n$.nl-in value. Note that source handle boundary is always counted as a new\nline break.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"DxEx\";\n    with IO::CatHandle.new: $f1, $f2 {\n        # .nl-in is [\"\\n\", \"\\r\\n\"] by default:\n        (.get xx 2).perl.say; # OUTPUT: «(\"A\", \"B\").Seq␤»\n\n        .nl-in = 'x';\n        (.get xx 3).perl.say; # OUTPUT: «(\"C\", \"D\", \"E\").Seq␤»\n        .close\n    }","close\n\nDefined as:\n\n    method close(IO::CatHandle:D: --> True)\n\nCloses the currently active source handle, as well as any already-open\nsource handles, and empties the source handle queue. Unlike a regular\nIO::Handle, an explicit call to .close is often not necessary on a\nCatHandle, as merely exhausting all the input closes all the handles that\nneed to be closed.\n\n    with IO::CatHandle.new: @bunch-of-handles {\n        say .readchars: 42;\n        .close; # we are done; close all the open handles\n    }","comb\n\nDefined as:\n\n    method comb(IO::CatHandle:D: |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.comb does,\ntaking the same arguments. Implementations may slurp the contents of all\nthe source handles in their entirety when this method is called.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    IO::CatHandle.new($f1, $f2).comb(2).perl.say;\n    # OUTPUT: «(\"fo\", \"ob\", \"ar\").Seq␤»","DESTROY\n\nDefined as:\n\n    method DESTROY(IO::CatHandle:D:)\n\nCalls .close. This method isn't to be used directly, but is something\nthat's called during garbage collection.","encoding\n\nDefined as:\n\n    multi method encoding(IO::CatHandle:D:)\n    multi method encoding(IO::CatHandle:D: $new-encoding)\n\nSets the invocant's $.encoding attribute to the provided value. Valid\nvalues are the same as those accepted by IO::Handle.encoding (use value Nil\nto switch to binary mode). All source handles, including the active one\nwill use the provided $.encoding value.\n\n    (my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    with IO::CatHandle.new: $f1, $f2 {\n        # .encoding is 'utf8' by default:\n        .readchars(5).say; # OUTPUT: «I ♥ P␤»\n\n        .encoding: Nil; # switch to binary mode\n        .slurp.say; # OUTPUT: «Buf[uint8]:0x<72 6c 6d 65 6f 77>␤»\n    }","eof\n\nDefined as:\n\n    method eof(IO::CatHandle:D: --> Bool:D)\n\nReturns True if the read operations have exhausted the source handle queue,\nincluding the contents of the last handle. Note: calling this method may\ncause one or more .on-switch calls, while the source handle queue is\nexamined, and the source handle queue may get exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    with IO::CatHandle.new: :on-switch{ print 'SWITCH! ' }, $f1, $f2 {\n                       # OUTPUT: «SWITCH! »\n        .eof.say;      # OUTPUT: «False␤»\n        .readchars(3);\n        .eof.say;      # OUTPUT: «SWITCH! False␤»\n\n        .slurp;        # OUTPUT: «SWITCH! »\n        .eof.say;      # OUTPUT: «True␤»\n    }\n\n\nThe same caveats for non-seekable handles and empty files that apply to\nIO::Handle.eof apply here.","get\n\nDefined as:\n\n    method get(IO::CatHandle:D: --> Bool:D)\n\nReturns a single line of input from the handle, with the new line string\ndefined by the value(s) of $.nl-in attribute, which will be removed from\nthe line if $.chomp attribute is set to True. Returns Nil when there is no\nmore input. It is an error to call this method when the handle is in binary\nmode, resulting in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: \"a\\nb\\nc\";\n    (my $f2 = 'bar'.IO).spurt: \"d\\ne\";\n    my $cat = IO::CatHandle.new: $f1, $f2;\n    .say while $_ = $cat.get; # OUTPUT: «a␤b␤c␤d␤e␤»","getc\n\nDefined as:\n\n    method getc(IO::CatHandle:D: --> Bool:D)\n\nReturns a single character of input from the handle. All the caveats\ndescribed in IO::Handle.getc apply. Returns Nil when there is no more\ninput. It is an error to call this method when the handle is in binary\nmode, resulting in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: 'I ♥ Perl';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    my $cat = IO::CatHandle.new: $f1, $f2;\n    .say while $_ = $cat.getc; # OUTPUT: «I␤ ␤♥␤ ␤P␤e␤r␤l␤m␤e␤o␤w␤»","handles\n\nDefines as:\n\n    method handles(IO::CatHandle:D: --> Seq:D)\n\nReturns a Seq containing the currently-active handle, as well as all the\nremaining source handles produced by calling next-handle. If the invocant\nhas already been fully-consumed, returns an empty Seq.\n\nThis method is especially handy when working with IO::ArgFiles, where you\nwant to treat each filehandle separately:\n\n    # print at most the first 2 lines of each file in $*ARGFILES:\n    .say for flat $*ARGFILES.handles.map: *.lines: 2\n\nIt is acceptable to call this method multiple times; .handles.head is a\nvalid idiom for obtaining the currently-active handle. If, between\nreification of the elements of the returned Seq the handles get switched by\nsome other means, the next element produced by the Seq would be the next\nhandle of the invocant, not the handle that would've been produced if no\nswitching occurred:\n\n    (my $file1 := 'file1'.IO).spurt: \"1a\\n1b\\n1c\";\n    (my $file2 := 'file2'.IO).spurt: \"2a\\n2b\\n2c\";\n    (my $file3 := 'file3'.IO).spurt: \"3a\\n3b\\n3c\";\n    my $cat := IO::CatHandle.new: $file1, $file2, $file3;\n    for $cat.handles {\n        say .lines: 2;\n        $cat.next-handle;\n    }\n    # OUTPUT: «(1a 1b)␤(3a 3b)␤»\n\nLikewise, reifying the returned Seq consumes the invocant's source handles\nand once it is fully reified the invocant becomes fully-consumed.","IO\n\nDefined as:\n\n    method IO(IO::CatHandle:D:)\n\nAlias for .path","lines\n\nDefined as:\n\n    method lines(IO::CatHandle:D: $limit = Inf, :$close --> Seq:D)\n\nSame as IO::Handle.lines. Note that a boundary between source handles is\nconsidered to be a newline break.\n\n    (my $f1 = 'foo'.IO).spurt: \"foo\\nbar\";\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    IO::CatHandle.new($f1, $f2).lines.perl.say;\n    # OUTPUT: «(\"foo\", \"bar\", \"meow\").Seq␤»\n\n\nNote: if :$close is False, fully-consumed handles are still going to be\nclosed.","lock\n\nDefined as:\n\n    method lock(IO::CatHandle:D: Bool:D :$non-blocking = False, Bool:D :$shared = False --> True)\n\nSame as IO::Handle.lock. Returns Nil if the source handle queue has been\nexhausted.\n\nLocks only the currently active source handle. The .on-switch Callable can\nbe used to conveniently lock/unlock the handles as they're being processed\nby the CatHandle.","native-descriptor\n\nDefined as:\n\n    method native-descriptor(IO::CatHandle:D: --> Int:D)\n\nReturns the native-descriptor of the currently active source handle or Nil\nif the source handle queue has been exhausted.\n\nSince the CatHandle closes a source handle, once it's done with it, it's\npossible for successive source handles to have the same native descriptor,\nif they were passed to .new as Cool or IO::Path objects.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    with IO::CatHandle.new: $f1, $f2, $*IN {\n        repeat { .native-descriptor.say } while .next-handle;\n        # OUTPUT: «13␤13␤9␤»\n    }","next-handle\n\nDefined as:\n\n    method next-handle(IO::CatHandle:D: --> IO::Handle:D)\n\nSwitches the active source handle to the next handle in the source handle\nqueue, which is the sources given in @handles attribute to .new. The return\nvalue is the currently active source handle or Nil if the source handle\nqueue has been exhausted.\n\nCoerces Cool source \"handles\" to IO::Path; opens IO::Path and unopened\nIO::Handle source handles for reading using the invocant's $.nl-in,\n$.chomp, and $.encoding attributes; those same attributes of already-opened\nIO::Handle objects will be changed to the values of the invocant's\nattributes.\n\nThis method is called automatically whenever CatHandle's methods require a\nswitch to the next source handle, triggers .on-switch Callable to be\ncalled, and is called once during .new call. The .on-switch will continue\nto be triggered each time this method is called, even after the source\nhandle queue has been exhausted. Note that generally reaching the EOF of\nthe currently active source handle does not trigger the .next-handle call,\nbut rather further read operations that need more data do.\n\n    (my $f1 = 'foo'.IO).spurt: \"a\\nb\";\n    (my $f2 = 'bar'.IO).spurt: \"c\\nd\";\n    with IO::CatHandle.new: :on-switch{ say '▸ Switching' }, $f1, $f2 {\n        say 'one';\n        .next-handle.^name.say;\n        say 'two';\n        .next-handle.^name.say;\n        say 'three';\n        .next-handle.^name.say;\n        # OUTPUT:\n        # ▸ Switching\n        # one\n        # ▸ Switching\n        # IO::Handle\n        # two\n        # ▸ Switching\n        # Nil\n        # three\n        # ▸ Switching\n        # Nil\n    }","on-switch\n\nDefined as:\n\n    has &.on-switch is rw\n\nOne of the attributes that can be set during .new call and changed later by\nassigning to. By default is not specified. Takes a Callable with .count of\n0, 1, 2, or Inf. Gets called every time .next-handle is, which happens once\nduring .new call and then each time a source handle is switched to the next\none in the queue, or when the .next-handle method is called manually.\n\nIf the .count of &.on-switch is 0, it receives no arguments; if it's 1, it\nreceives the currently active handle, and if it's 2 or Inf, it receives the\ncurrently active handle, and the last active handle as positional arguments\n(in that order). On the very first &.on-switch execution, the \"last active\nhandle\" argument is Nil. Upon source handle queue exhaustion the \"currently\nactive handle\" argument is Nil, and all the executions made afterwards have\nboth arguments as Nil.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\n    my $line;\n    my $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\n    say \"{$cat.path}:{$line++} $_\" for $cat.lines;\n    # OUTPUT:\n    # foo:1 A\n    # foo:2 B\n    # foo:3 C\n    # bar:1 D\n    # bar:2 E\n\n\n    my @old-stuff;\n    sub on-switch ($new, $old) {\n        $new and $new.seek: 1, SeekFromBeginning;\n        $old and @old-stuff.push: $old.open.slurp: :close;\n    }\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n    my $cat = IO::CatHandle.new: :&on-switch, $f1, $f2;\n    $cat.lines.perl.say; # OUTPUT: «(\"\", \"B\", \"C\", \"\", \"E\").Seq␤»\n    @old-stuff.perl.say; # OUTPUT: «[\"A\\nB\\nC\", \"D\\nE\"]␤»","open\n\nDefined as:\n\n    method open(IO::CatHandle:D: --> IO::CatHandle:D)\n\nReturns the invocant. The intent of this method is to merely make CatHandle\nworkable with things that open IO::Handle. You never have to call this\nmethod intentionally.","opened\n\nDefined as:\n\n    method opened(IO::CatHandle:D: --> Bool:D)\n\nReturns True if the invocant has any source handles, False otherwise.\n\n    say IO::CatHandle.new      .opened; # OUTPUT: «False␤»\n    say IO::CatHandle.new($*IN).opened; # OUTPUT: «True␤»\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    with IO::CatHandle.new: $f1 {\n        .opened.say; # OUTPUT: «True␤»\n        .slurp;\n        .opened.say; # OUTPUT: «False␤»\n    }","path\n\nDefined as:\n\n    method path(IO::CatHandle:D:)\n\nReturns the value of .path attribute of the currently active source handle,\nor Nil if the source handle queue has been exhausted. Basically, if your\nCatHandle is based on files, this is the way to get the path of the file\nthe CatHandle is currently reading from.\n\n    (my $f1 = 'foo'.IO).spurt: \"A\\nB\\nC\";\n    (my $f2 = 'bar'.IO).spurt: \"D\\nE\";\n\n    my $line;\n    my $cat = IO::CatHandle.new: :on-switch{ $line = 1 }, $f1, $f2;\n    say \"{$cat.path}:{$line++} $_\" for $cat.lines;\n    # OUTPUT:\n    # foo:1 A\n    # foo:2 B\n    # foo:3 C\n    # bar:1 D\n    # bar:2 E","read\n\nDefined as:\n\n    method read(IO::CatHandle:D: Int(Cool:D) $bytes = 65536 --> Buf:D)\n\nReads up to $bytes bytes from the handle and returns them in a Buf. $bytes\ndefaults to an implementation-specific value (in Rakudo, the value of\n$*DEFAULT-READ-ELEMS, which by default is set to 65536). It is permitted to\ncall this method on handles that are not in binary mode.\n\n    (my $f1 = 'foo'.IO).spurt: 'meow';\n    (my $f2 = 'bar'.IO).spurt: Blob.new: 4, 5, 6;\n    with IO::CatHandle.new: :bin, $f1, $f2 {\n        say .read: 2;    # OUTPUT: «Buf[uint8]:0x<6d 65>␤»\n        say .read: 2000; # OUTPUT: «Buf[uint8]:0x<6f 77 04 05 06>␤»\n    }\n\n    # Non-binary mode is OK too:\n    with IO::CatHandle.new: $f1, $f2 {\n        say .get;        # OUTPUT: «meow␤»\n        say .read: 2000; # OUTPUT: «Buf[uint8]:0x<04 05 06>␤»\n    }","readchars\n\nDefined as:\n\n    method readchars(IO::CatHandle:D: Int(Cool:D) $chars = 65536 --> Str:D)\n\nReturns a Str of up to $chars characters read from the handle. $chars\ndefaults to an implementation-specific value (in Rakudo, the value of\n$*DEFAULT-READ-ELEMS, which by default is set to 65536). It is NOT\npermitted to call this method on handles opened in binary mode and doing so\nwill result in X::IO::BinaryMode exception being thrown.\n\n    (my $f1 = 'foo'.IO).spurt: 'Perl loves to';\n    (my $f2 = 'bar'.IO).spurt: ' meow';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        say .readchars: 11;   # OUTPUT: «Perl loves ␤»\n        say .readchars: 1000; # OUTPUT: «to meow␤»\n    }","seek\n\nDefined as:\n\n    method seek(IO::CatHandle:D: |c)\n\nCalls .seek on the currently active source handle, forwarding it all the\narguments, and returns the result. Returns Nil if the source handle queue\nhas been exhausted. NOTE: this method does NOT perform any source handle\nswitching, so seeking past the end of the current source handle will NOT\nseek to the next source handle in the queue and seeking past the beginning\nof the current source handle is a fatal error. Also see .next-handle, to\nlearn the details on when source handles are switched.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        .get.say;                     # OUTPUT: «foo␤»\n        .seek: -2, SeekFromCurrent;\n        .readchars(2).say;            # OUTPUT: «oo␤»\n        .seek: 1000, SeekFromCurrent; # this doesn't switch to second handle!\n        .readchars(3).say;            # OUTPUT: «bar␤»\n        try .seek: -4;                # this won't seek to previous handle!\n        say ~$!;                      # OUTPUT: «Failed to seek in filehandle: 22␤»\n    }","tell\n\nDefined as:\n\n    method tell(IO::CatHandle:D: --> Int:D)\n\nCalls .tell on the currently active source handle and returns the result.\nReturns Nil if the source handle queue has been exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    with IO::CatHandle.new: $f1, $f2 {\n        .get.say;                   # OUTPUT: «foo␤»\n        .tell.say;                  # OUTPUT: «3␤»\n        .seek: -2, SeekFromCurrent;\n        .tell.say;                  # OUTPUT: «1␤»\n        say .readchars: 3;          # OUTPUT: «oob␤»\n        .tell.say;                  # OUTPUT: «2␤»\n        }","slurp\n\nDefined as:\n\n    method slurp(IO::CatHandle:D:)\n\nReads all of the available input from all the source handles and returns it\nas a Buf if the handle is in binary mode or as a Str otherwise. Returns Nil\nif the source handle queue has been exhausted.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n\n    IO::CatHandle.new(      $f1, $f2).slurp.say; # OUTPUT: «foobar␤»\n    IO::CatHandle.new(:bin, $f1, $f2).slurp.say; # OUTPUT: «Buf[uint8]:0x<66 6f 6f 62 61 72>␤»\n    IO::CatHandle.new                .slurp.say; # OUTPUT: «Nil␤»","split\n\nDefined as:\n\n    method split(IO::CatHandle:D: |args --> Seq:D)\n\nRead the handle and processes its contents the same way Str.split does,\ntaking the same arguments. Implementations may slurp the contents of all\nthe source handles in their entirety when this method is called.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    IO::CatHandle.new($f1, $f2).split(/o+/).perl.say;\n    # OUTPUT: «(\"f\", \"bar\").Seq␤»","Str\n\nDefined as:\n\n    method Str(IO::CatHandle:D: --> Str:D)\n\nCalls .Str on the currently active source handle and returns the result. If\nthe source handle queue has been exhausted, returns an\nimplementation-defined string ('<closed IO::CatHandle>' in Rakudo).","Supply\n\nDefined as:\n\n    method Supply(IO::CatHandle:D: :$size = 65536 --> Supply:D)\n\nReturns a Supply fed with either .read, if the handle is in binary mode, or\nwith .readchars, if it isn't, with reads of :$size bytes or characters.\n:$size defaults to an implementation-specific value (in Rakudo, the value\nof $*DEFAULT-READ-ELEMS, which by default is set to 65536).\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    (my $f2 = 'bar'.IO).spurt: 'bar';\n    react whenever IO::CatHandle.new($f1, $f2).Supply: :2size {.say}\n    # OUTPUT: «fo␤ob␤ar␤»\n\n    react whenever IO::CatHandle.new(:bin, $f1, $f2).Supply: :2size {.say}\n    # OUTPUT: «Buf[uint8]:0x<66 6f>␤Buf[uint8]:0x<6f 62>␤Buf[uint8]:0x<61 72>␤»","t\n\nDefined as:\n\n    method t(IO::CatHandle:D: --> Bool:D)\n\nCalls .t, which tells if the handle is a TTY, on the currently active\nsource handle and returns the result. If the source handle queue has been\nexhausted, returns False.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo';\n    with IO::CatHandle.new: $f1, $*IN {\n        repeat { .t.say } while .next-handle; # OUTPUT: «False␤True␤»\n    }","unlock\n\nDefined as:\n\n    method unlock(IO::CatHandle:D:)\n\nSame as IO::Handle.unlock. Returns Nil if the source handle queue has been\nexhausted.\n\nUnlocks only the currently active source handle. The .on-switch Callable\ncan be used to conveniently lock/unlock the handles as they're being\nprocessed by the CatHandle.","words\n\nDefined as:\n\n    method words(IO::CatHandle:D: $limit = Inf, :$close --> Seq:D)\n\nSame as IO::Handle.words (including the caveat about more data read than\nneeded to make some number of words). Note that a boundary between source\nhandles is considered to be word boundary.\n\n    (my $f1 = 'foo'.IO).spurt: 'foo bar';\n    (my $f2 = 'bar'.IO).spurt: 'meow';\n    IO::CatHandle.new($f1, $f2).words.perl.say;\n    # OUTPUT: «(\"foo\", \"bar\", \"meow\").Seq␤»\n\n\nNote: if :$close is False, fully-consumed handles are still going to be\nclosed.\n\nNYI"]},{"name":"IO::ArgFiles","desc":"TITLE\nclass IO::ArgFiles\n\nSUBTITLE\nIterate over contents of files specified on command line\n\n    class IO::ArgFiles is IO::CatHandle { }\n\nThis class exists for backwards compatibility reasons and provides no\nadditional methods to IO::CatHandle, so it can be used in the same way as\nit, for instance, in this way:\n\n    my $argfiles = IO::ArgFiles.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nIf invoked with perl6 io-argfiles.p6 *.p6 it will print the contents of all\nthe files with that extension in the directory. However, that is totally\nequivalent to:\n\n    my $argfiles = IO::CatHandle.new(@*ARGS);\n    .say for $argfiles.lines;\n\n\nVariables\n\n  $*ARGFILES\n\nThis class is the magic behind the $*ARGFILES variable, which provides a\nway to iterate over files passed in to the program on the command line\n(i.e. elements of @*ARGS). Thus the examples above can be simplified like\nso:\n\n    .say for $*ARGFILES.lines;\n\n    # or\n    while ! $*ARGFILES.eof {\n        say $*ARGFILES.get;\n    }\n\n    # or\n    say $*ARGFILES.slurp;\n\nSave one of the variations above in a file, say argfiles.p6. Then create\nanother file (named, say sonnet18.txt with the contents:\n\n    Shall I compare thee to a summer's day?\n\n\nRunning the command\n\n    $ perl6 argfiles.p6 sonnet18.txt\n\n\nwill then give the output\n\n    Shall I compare thee to a summer's day?\n\n\nAs of 6.d language, $*ARGFILES inside sub MAIN is always set to $*IN, even\nwhen @*ARGS is not empty. That means that\n\n    sub MAIN () {\n        .say for $*ARGFILES.lines;\n    }\n\n\nwhich can be used as cat *.p6 | perl6 argfiles-main.p6, for instance, is\ntotally equivalent to:\n\n    sub MAIN () {\n        .say for $*IN.lines;\n    }\n\n\nand, in fact, can't be used to process the arguments in the command line,\nsince, in this case, it would result in an usage error.\n\nBear in mind that the object $*ARGFILES is going to contain a handle for\nevery argument in a command line, even if that argument is not a valid\nfile. You can retrieve them via the .handles method.\n\n    for $*ARGFILES.handles -> $fh {\n        say $fh;\n    }\n\n\nThat code will fail if any of the arguments is not the valid name of a\nfile. You will have to deal with that case at another level, checking that\n@*ARGS contains valid file names, for instance.","methods":[]},{"methods":["new\n\nDefined as:\n\n    multi method new(Str:D $path, IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD)\n    multi method new(\n        :$basename!, :$dirname = '.', :$volume = ''\n        IO::Spec :$SPEC = $*SPEC, Str() :$CWD = $*CWD\n    )\n\n\nCreates a new IO::Path object from a path string (which is being parsed for\nvolume, directory name and basename), or from volume, directory name and\nbasename passed as named arguments.\n\nThe path's operation will be performed using :$SPEC semantics (defaults to\ncurrent $*SPEC) and will use :$CWD as the directory the path is relative to\n(defaults to $*CWD).\n\n  attribute CWD\n\n    IO::Path.new(\"foo\", :CWD</home/camelia>)\n        .IO.CWD.say; # OUTPUT: «/home/camelia␤»\n\nRead-only. Contains implicit or explicit value of :$CWD argument to .new.\n\n  attribute SPEC\n\n    IO::Path.new(\"foo\", :SPEC(IO::Spec::Unix.new))\\\n        .IO.SPEC.^name.say; # OUTPUT: «IO::Spec::Unix␤»\n\nRead-only. Contains implicit or explicit value of :$SPEC argument to .new.\n\n  attribute path\n\n    IO::Path.new(\"foo\").path.say; # OUTPUT: «foo␤»\n\nRead-only. Returns the string the object was constructed from or the value\nof $SPEC.join($volume, $dirname, $basename) if multi-part version of .new\nwas used. NOTE: this does not include the $.CWD; see IO::Path.absolute and\nIO::Path.relative for stringification options that include $.CWD.\n\nNOTE: Implementations may cache operations done with this attribute, so\nmodifying its value (via cloning or Proxy) is NOT recommended and may\nresult in broken IO::Path objects. Create a new IO::Path object instead.","ACCEPTS\n\nDefined as:\n\n    multi method ACCEPTS(IO::Path:D: Cool:D $other --> Bool:D)\n\nCoerces the argument to IO::Path, if necessary. Returns True if .absolute\nmethod on both paths returns the same string. NOTE: it's possible for two\npaths that superficially point to the same resource to NOT smartmatch as\nTrue, if they were constructed differently and were never fully resolved:\n\n    say \"foo/../bar\".IO ~~ \"bar\".IO # False\n\nThe reason is the two paths above may point to different resources when\nfully resolved (e.g. if foo is a symlink). Resolve the paths before\nsmartmatching to check they point to same resource:\n\n    say \"foo/../bar\".IO.resolve(:completely) ~~ \"bar\".IO.resolve(:completely) # True","basename\n\nDefined as:\n\n    method basename(IO::Path:D:)\n\nReturns the basename part of the path object, which is the name of the\nfilesystem object itself that is referenced by the path.\n\n    \"docs/README.pod\".IO.basename.say; # OUTPUT: «README.pod␤»\n    \"/tmp/\".IO.basename.say;           # OUTPUT: «tmp␤»\n\nNote that in IO::Spec::Win32 semantics, the basename of a Windows share is\n\\, not the name of the share itself:\n\n    IO::Path::Win32.new('//server/share').basename.say; # OUTPUT: «\\␤»","add\n\nDefined as:\n\n    method add(IO::Path:D: Str() $what --> IO::Path:D)\n\nConcatenates a path fragment to the invocant and returns the resultant\nIO::Path. If adding ../ to paths that end with a file, you may need to call\nresolve for the resultant path to be accessible by other IO::Path methods\nlike dir or open. See also sibling and parent.\n\n    \"foo/bar\".IO.mkdir;\n    \"foo/bar\".IO.add(\"meow\")    .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n    \"foo/bar\".IO.add(\"/meow\")   .resolve.relative.say; # OUTPUT: «foo/bar/meow␤»\n    \"foo/bar\".IO.add(\"meow.txt\").resolve.relative.say; # OUTPUT: «foo/bar/meow.txt␤»\n    \"foo/bar\".IO.add(\"../meow\") .resolve.relative.say; # OUTPUT: «foo/meow␤»\n    \"foo/bar\".IO.add(\"../../\")  .resolve.relative.say; # OUTPUT: «.␤»","child\n\nDefined as:\n\n    method child(IO::Path:D: Str() $childname --> IO::Path:D)\n\nAlias for .add. NOTE: This method has been deprecated as of the 6.d\nversion, and will be removed in the future. For any new code, please use\n.add","cleanup\n\nDefined as:\n\n    method cleanup(IO::Path:D: --> IO::Path:D)\n\nReturns a new path that is a canonical representation of the invocant path,\ncleaning up any extraneous path parts:\n\n    \"foo/./././..////bar\".IO.cleanup.say;      # OUTPUT: «\"foo/../bar\".IO␤»\n    IO::Path::Win32.new(\"foo/./././..////bar\")\n        .cleanup.say; \"foo\\..\\bar\".IO;         # OUTPUT: «\"foo\\..\\bar\".IO␤»\n\nNote that no filesystem access is made. See also resolve.","comb\n\nDefined as:\n\n    method comb(IO::Path:D: |args --> Seq:D)\n\nOpens the file and processes its contents the same way Str.comb does,\ntaking the same arguments. Implementations may slurp the file in its\nentirety when this method is called.","split\n\nDefined as:\n\n    method split(IO::Path:D: |args --> Seq:D)\n\nOpens the file and processes its contents the same way Str.split does,\ntaking the same arguments. Implementations may slurp the file in its\nentirety when this method is called.","extension\n\nDefined as:\n\n    multi method extension(IO::Path:D:                                         --> Str:D)\n    multi method extension(IO::Path:D:               Int :$parts               --> Str:D)\n    multi method extension(IO::Path:D:             Range :$parts               --> Str:D)\n    multi method extension(IO::Path:D: Str $subst,   Int :$parts, Str :$joiner --> IO::Path:D)\n    multi method extension(IO::Path:D: Str $subst, Range :$parts, Str :$joiner --> IO::Path:D)\n\nReturns the extension consisting of $parts parts (defaults to 1), where a\n\"part\" is defined as a dot followed by possibly-empty string up to the end\nof the string, or previous part. That is \"foo.tar.gz\" has an extension of\ntwo parts: first part is \"gz\" and second part is \"tar\" and calling\n\"foo.tar.gz\".IO.extension: :2parts gives \"tar.gz\". If an extension with the\nspecified number of $parts is not found, returns an empty string.\n\n$parts can be a Range, specifying the minimum number of parts and maximum\nnumber of parts the extension should have. The routine will attempt to much\nthe most parts it can. If $parts range's endpoints that are smaller than 0\nthey'll be treated as 0; implementations may treat endpoints larger than\n2⁶³-1 as 2⁶³-1. Ranges with NaN or Str endpoints will cause an exception to\nbe thrown.\n\nIf $subst is provided, the extension will be instead replaced with $subst\nand a new IO::Path object will be returned. It will be joined to the file's\nname with $joiner, which defaults to an empty string when $subst is an\nempty string and to \".\" when $subst is not empty. Note: if as the result of\nreplacement the basename of the path ends up being empty, it will be\nassumed to be . (a single dot).\n\n    # Getting an extension:\n    say \"foo.tar.gz\".IO.extension;               # OUTPUT: «gz␤»\n    say \"foo.tar.gz\".IO.extension: :2parts;      # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(^5);   # OUTPUT: «tar.gz␤»\n    say \"foo.tar.gz\".IO.extension: :parts(0..1); # OUTPUT: «gz␤»\n\n    # Replacing an extension\n    say \"foo.tar.gz\".IO.extension: '';                # OUTPUT: «\"foo.tar\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP';             # OUTPUT: «\"foo.tar.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts;    # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :2parts;    # OUTPUT: «\"foo.ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :parts(^5); # OUTPUT: «\"foo.ZIP\".IO␤»\n\n    # Replacing an extension using non-standard joiner:\n    say \"foo.tar.gz\".IO.extension: '',    :joiner<_>;  # OUTPUT: «\"foo.tar_\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>;  # OUTPUT: «\"foo.tar_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :2parts;     # OUTPUT: «\"foo_ZIP\".IO␤»\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :joiner<_>,\n                                           :parts(^5);  # OUTPUT: «\"foo_ZIP\".IO␤»\n\n    # EDGE CASES:\n\n    # There is no 5-part extension, so returned value is an empty string\n    say \"foo.tar.gz\".IO.extension: :5parts; # OUTPUT: «␤»\n\n    # There is no 5-part extension, so we replaced nothing:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :5parts; # OUTPUT: «\"foo.tar.gz\".IO␤»\n\n    # Replacing a 0-part extension is just appending:\n    say \"foo.tar.gz\".IO.extension: 'ZIP', :0parts; # OUTPUT: «\"foo.tar.gz.ZIP\".IO␤»\n\n    # Replace 1-part of the extension, using '.' joiner\n    say \"...\".IO.extension: 'tar'; # OUTPUT: «\"...tar\".IO␤»\n\n    # Replace 1-part of the extension, using empty string joiner\n    say \"...\".IO.extension: 'tar', :joiner(''); # OUTPUT: «\"..tar\".IO␤»\n\n    # Remove 1-part extension; results in empty basename, so result is \".\".IO\n    say \".\".IO.extension: ''; # OUTPUT: «\".\".IO␤»","dirname\n\nDefined as:\n\n    method dirname(IO::Path:D:)\n\nReturns the directory name portion of the path object. That is, it returns\nthe path excluding the volume and the base name. Unless the dirname consist\nof only the directory separator (i.e. it's the top directory), the trailing\ndirectory separator will not be included in the return value.\n\n    say IO::Path.new(\"/home/camelia/myfile.p6\").dirname; # OUTPUT: «/home/camelia␤»\n    say IO::Path::Win32.new(\"C:/home/camelia\").dirname;  # OUTPUT: «/home␤»\n    say IO::Path.new(\"/home\").dirname;                   # OUTPUT: «/␤»","volume\n\nDefined as:\n\n    method volume(IO::Path:D:)\n\nReturns the volume portion of the path object. On Unix system, this is\nalways the empty string.\n\n    say IO::Path::Win32.new(\"C:\\\\Windows\\\\registry.ini\").volume;    # OUTPUT: «C:␤»","parts\n\nDefined as:\n\n    method parts(IO::Path:D: --> Map:D)\n\nReturns a Map with the keys volume, dirname, basename whose values are the\nsame as available via methods .volume, .dirname, and .basename\nrespectively.\n\n    say IO::Path::Win32.new(\"C:/rakudo/perl6.bat\").parts.perl;\n    # OUTPUT: «Map.new((:basename(\"perl6.bat\"),:dirname(\"/rakudo\"),:volume(\"C:\")))␤»","perl\n\nDefined as:\n\n    method perl(IO::Path:D: --> Str:D)\n\nReturns a string that, when given passed through EVAL gives the original\ninvocant back.\n\n    \"foo/bar\".IO.perl.say;\n    # OUTPUT: IO::Path.new(\"foo/bar\", :SPEC(IO::Spec::Unix), :CWD(\"/home/camelia\"))\n\nNote that this string includes the value of the .CWD attribute that is set\nto $*CWD when the path object was created, by default.","gist\n\nDefined as:\n\n    method gist(IO::Path:D: --> Str:D)\n\nReturns a string, part of which contains either the value of .absolute (if\npath is absolute) or .path. Note that no escaping of special characters is\nmade, so e.g. \"\\b\" means a path contains a backslash and letter \"b\", not a\nbackspace.\n\n    say \"foo/bar\".IO;                       # OUTPUT: «\"foo/bar\".IO␤»\n    say IO::Path::Win32.new: ｢C:\\foo/bar\\｣; # OUTPUT: «\"C:\\foo/bar\\\".IO␤»","Str\n\nDefined as:\n\n    method Str(IO::Path:D: --> Str)\n\nAlias for IO::Path.path. In particular, note that default stringification\nof an IO::Path does NOT use the value of $.CWD attribute. To stringify\nwhile retaining full path information use .absolute or .relative methods.","succ\n\nDefined as:\n\n    method succ(IO::Path:D: --> IO::Path:D)\n\nReturns a new IO::Path constructed from the invocant, with .basename\nchanged by calling Str.succ on it.\n\n    \"foo/file02.txt\".IO.succ.say; # OUTPUT: «\"foo/file03.txt\".IO␤»","open\n\nDefined as:\n\n    method open(IO::Path:D: *%opts)\n\nOpens the path as a file; the named options control the mode, and are the\nsame as the open function accepts.","pred\n\nDefined as:\n\n    method pred(IO::Path:D: --> IO::Path:D)\n\nReturns a new IO::Path constructed from the invocant, with .basename\nchanged by calling Str.pred on it.\n\n    \"foo/file02.txt\".IO.pred.say; # OUTPUT: «\"foo/file01.txt\".IO␤»","watch\n\nDefined as:\n\n    method watch(IO::Path:D: --> Supply:D)\n\nEquivalent to calling IO::Notification.watch-path with the invocant as the\nargument.","is-absolute\n\nDefined as:\n\n    method is-absolute(IO::Path:D: --> Bool)\n\nReturns True if the path is an absolute path, and False otherwise.\n\n    \"/foo\".IO.is-absolute.say; # OUTPUT: «True␤»\n    \"bars\".IO.is-absolute.say; # OUTPUT: «False␤»\n\nNote that on Windows a path that starts with a slash or backslash is still\nconsidered absolute even if no volume was given, as it is absolute for that\nparticular volume:\n\n    IO::Path::Win32.new(\"/foo\"  ).is-absolute.say; # OUTPUT: «True␤»\n    IO::Path::Win32.new(\"C:/foo\").is-absolute.say; # OUTPUT: «True␤»\n    IO::Path::Win32.new(\"C:foo\" ).is-absolute.say; # OUTPUT: «False␤»","is-relative\n\nDefined as:\n\n    method is-relative(IO::Path:D: --> Bool)\n\nReturns True if the path is a relative path, and False otherwise. Windows\ncaveats for .is-absolute apply.","absolute\n\nDefined as:\n\n    multi method absolute(IO::Path:D: --> Str)\n    multi method absolute(IO::Path:D: $base --> Str)\n\nReturns a new Str object that is an absolute path. If the invocant is not\nalready an absolute path, it is first made absolute using $base as base, if\nit is provided, or the .CWD attribute the object was created with if it is\nnot.","relative\n\nDefined as:\n\n    method relative(IO::Path:D: $base = $*CWD --> Str)\n\nReturns a new Str object with the path relative to the $base. If $base is\nnot provided, $*CWD is used in its place. If the invocant is not an\nabsolute path, it's first made to be absolute using the .CWD attribute the\nobject was created with, and then is made relative to $base.","parent\n\nDefined as:\n\n    multi method parent(IO::Path:D:)\n    multi method parent(IO::Path:D: UInt:D $level)\n\nReturns the parent path of the invocant. Note that no actual filesystem\naccess is made, so the returned parent is physical and not the logical\nparent of symlinked directories.\n\n    '/etc/foo'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/..' .IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    '/etc/../'.IO.parent.say; # OUTPUT: «\"/etc\".IO␤»\n    './'      .IO.parent.say; # OUTPUT: «\"..\".IO␤»\n    'foo'     .IO.parent.say; # OUTPUT: «\".\".IO␤»\n    '/'       .IO.parent.say; # OUTPUT: «\"/\".IO␤»\n    IO::Path::Win32.new('C:/').parent.say; # OUTPUT: «\"C:/\".IO␤»\n\nIf $level is specified, the call is equivalent to calling .parent() $level\ntimes:\n\n    say \"/etc/foo\".IO.parent(2) eqv \"/etc/foo\".IO.parent.parent; # OUTPUT: «True␤»","resolve\n\nDefined as:\n\n    method resolve(IO::Path:D: :$completely --> IO::Path)\n\nReturns a new IO::Path object with all symbolic links and references to the\nparent directory (..) resolved. This means that the filesystem is examined\nfor each directory in the path, and any symlinks found are followed.\n\n    # bar is a symlink pointing to \"/baz\"\n    my $io = \"foo/./bar/..\".IO.resolve;      # now \"/\" (the parent of \"/baz\")\n\nIf :$completely, which defaults to False, is set to a true value, the\nmethod will fail with X::IO::Resolve if it cannot completely resolve the\npath, otherwise, it will resolve as much as possible, and will merely\nperform cleanup of the rest of the path. The last part of the path does NOT\nhave to exist to :$completely resolve the path.\n\nNOTE: Currently (April 2017) this method doesn't work correctly on all\nplatforms, e.g. Windows, since it assumes POSIX semantics.","dir\n\nDefined as:\n\n    sub    dir(Cool $path = '.', Mu :$test = none('.', '..'))\n    method dir(IO::Path:D: Mu :$test = none('.', '..'))\n\nReturns the contents of a directory as a lazy list of IO::Path objects\nrepresenting relative paths, filtered by smartmatching their names (as\nstrings) against the :test parameter.\n\nSince the tests are performed against Str arguments, not IO, the tests are\nexecuted in the $*CWD, instead of the target directory. When testing\nagainst file test operators, this won't work:\n\n    dir('mydir', test => { .IO.d })\n\nwhile this will:\n\n    dir('mydir', test => { \"mydir/$_\".IO.d })\n\nNOTE: a dir call opens a directory for reading, which counts towards\nmaximum per-process open files for your program. Be sure to exhaust\nreturned Seq before doing something like recursively performing more dir\ncalls. You can exhaust it by assigning to a @-sigiled variable or simply\nlooping over it. Note how examples below push further dirs to look through\ninto an Array, rather than immediately calling dir on them. See also\nIO::Dir module that gives you finer control over closing dir handles.\n\nExamples:\n\n    # To iterate over the contents of the current directory:\n    for dir() -> $file {\n        say $file;\n    }\n\n    # As before, but include even '.' and '..' which are filtered out by\n    # the default :test matcher:\n    for dir(test => *) -> $file {\n        say $file;\n    }\n\n    # To get the names of all .jpg and .jpeg files in ~/Downloads:\n    my @jpegs = $*HOME.dir: test => /:i '.' jpe?g $/;\n\nAn example program that lists all files and directories recursively:\n\n    sub MAIN($dir = '.') {\n        my @todo = $dir.IO;\n        while @todo {\n            for @todo.pop.dir -> $path {\n                say $path.Str;\n                @todo.push: $path if $path.d;\n            }\n        }\n    }\n\nA lazy way to find the first three files ending in \".p6\" recursively\nstarting from the current directory:\n\n    my @stack = '.'.IO;\n    my $perl-files = gather while @stack {\n        with @stack.pop {\n            when :d { @stack.append: .dir }\n            .take when .extension.lc eq 'p6'\n        }\n    }\n    .put for $perl-files[^3];\n\n\n  File test operators\n\nFor most file tests, you can do a smartmatch ~~ or you can call a method.\nYou don't need to actually open a filehandle in the traditional way\n(although you can) to do a filetest. You can simply append .IO to the\nfilename. For instance, here is how to check whether a file is readable\nusing smartmatch:\n\n    '/path/to/file'.IO ~~ :r;\n\nFile tests include:\n\n  * :d (Directory)\n\n  * :e (Exists)\n\n  * :f (File)\n\n  * :l (Symbolic link)\n\n  * :r (Readable)\n\n  * :rw (Readable and writable)\n\n  * :rwx (Readable, writable and executable)\n\n  * :s (Size)\n\n  * :w (Writable)\n\n  * :x (Executable)\n\n  * :z (Zero size)\n\nSmartmatching on Pairs can be used to perform multiple tests at once:\n\n    say :d & :x;                # OUTPUT: «all(d => True, x => True)␤»\n    say '/tmp'.IO ~~ :d & :x;   # OUTPUT: «True␤»\n    say '/'.IO    ~~ :d & :rw;  # OUTPUT: «False␤»\n\nAll of the above tests can be used as methods (without the colon), though\nmethod tests may throw X::IO::DoesNotExist as documented below. Three tests\nonly exist as methods: accessed, changed and modified.\n\nYou can also perform file tests on an already opened filehandle by testing\nagainst its .path method. For example, given filehandle $fh:\n\n    $fh.path ~~ :r;\n    $fh.path.r;       # method form","e\n\nDefined as:\n\n    method e(--> Bool:D)\n\nReturns True if the invocant is a path that exists.","d\n\nDefined as:\n\n    method d(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a directory. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","f\n\nDefined as:\n\n    method f(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a file. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","s\n\nDefined as:\n\n    method s(--> Int:D)\n\nReturns the file size in bytes. May be called on paths that are\ndirectories, in which case the reported size is dependent on the operating\nsystem. The method will fail with X::IO::DoesNotExist if the path points to\na non-existent filesystem entity.\n\n    say $*EXECUTABLE.IO.s; # OUTPUT : «467␤»","l\n\nDefined as:\n\n    method l(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is a symlink. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","r\n\nDefined as:\n\n    method r(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is accessible. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","w\n\nDefined as:\n\n    method w(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is writable. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","rw\n\nDefined as:\n\n    method rw(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is readable and\nwritable. The method will fail with X::IO::DoesNotExist if the path points\nto a non-existent filesystem entity.","x\n\nDefined as:\n\n    method x(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is executable. The\nmethod will fail with X::IO::DoesNotExist if the path points to a\nnon-existent filesystem entity.","rwx\n\nDefined as:\n\n    method rwx(--> Bool:D)\n\nReturns True if the invocant is a path that exists and is executable,\nreadable, and writable. The method will fail with X::IO::DoesNotExist if\nthe path points to a non-existent filesystem entity.","z\n\nDefined as:\n\n    method z(--> Bool:D)\n\nReturns True if the invocant is a path that exists and has size of 0. May\nbe called on paths that are directories, in which case the reported file\nsize (and thus the result of this method) is dependent on the operating\nsystem. The method will fail with X::IO::DoesNotExist if the path points to\na non-existent filesystem entity.","sibling\n\nDefined as:\n\n    method sibling(IO::Path:D: Str() $sibling --> IO::Path:D)\n\nAllows to reference a sibling file or directory. Returns a new IO::Path\nbased on the invocant, with the .basename changed to $sibling. The $sibling\nis allowed to be a multi-part path fragment; see also .add.\n\n    say '.bashrc'.IO.sibling: '.bash_aliases'; # OUTPUT: «.bash_aliases\".IO␤»\n    say '/home/camelia/.bashrc'.IO.sibling: '.bash_aliases';\n    # OUTPUT: «/home/camelia/.bash_aliases\".IO␤»\n\n    say '/foo/' .IO.sibling: 'bar';  # OUTPUT: «/bar\".IO␤»\n    say '/foo/.'.IO.sibling: 'bar';  # OUTPUT: «/foo/bar\".IO␤»","words\n\nDefined as:\n\n    method words(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)\n\nOpens the invocant and returns its words.\n\nThe behavior is equivalent to opening the file specified by the invocant,\nforwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open,\nthen calling IO::Handle.words on that handle, forwarding any of the\nremaining arguments to that method, and returning the resultant Seq.\n\nNOTE: words are lazily read. The handle used under the hood is not closed\nuntil the returned Seq is fully reified, and this could lead to leaking\nopen filehandles. It is possible to avoid leaking open filehandles using\nthe $limit argument to cut down the Seq of words to be generated.\n\n    my %dict := bag 'my-file.txt'.IO.words;\n    say \"Most common words: \", %dict.sort(-*.value).head: 5;","lines\n\nDefined as:\n\n    method lines(IO::Path:D: :$chomp = True, :$enc = 'utf8', :$nl-in = [\"\\x0A\", \"\\r\\n\"], |c --> Seq:D)\n\nOpens the invocant and returns its lines.\n\nThe behavior is equivalent to opening the file specified by the invocant,\nforwarding the :$chomp, :$enc, and :$nl-in arguments to IO::Handle.open,\nthen calling IO::Handle.lines on that handle, forwarding any of the\nremaining arguments to that method, and returning the resultant Seq.\n\nNOTE: the lines are ready lazily and the handle used under the hood won't\nget closed until the returned Seq is fully reified, so ensure it is, or\nyou'll be leaking open filehandles. (TIP: use the $limit argument)\n\n    say \"The file contains \",\n      '50GB-file'.IO.lines.grep(*.contains: 'Perl').elems,\n      \" lines that mention Perl\";\n    # OUTPUT: «The file contains 72 lines that mention Perl␤»","slurp\n\nDefined as:\n\n    multi method slurp(IO::Path:D: :$bin, :$enc)\n\nRead all of the file's content and return it as either Buf, if :$bin is\nTrue, or if not, as Str decoded with :$enc encoding, which defaults to\nutf8. File will be closed afterwards. See &open for valid values for\n:$enc.","spurt\n\nDefined as:\n\n    method spurt(IO::Path:D: $data, :$enc, :$append, :$createonly)\n\nOpens the file path for writing, and writes all of the $data into it. File\nwill be closed, afterwards. Will fail if it cannot succeed for any reason.\nThe $data can be any Cool type or any Blob type. Arguments are as follows:\n\n  * :$enc — character encoding of the data. Takes same values as :$enc in\n  IO::Handle.open. Defaults to utf8. Ignored if $data is a Blob.\n\n  * :$append — open the file in append mode, preserving existing contents, and\n  appending data to the end of the file.\n\n  * :$createonly — fail if the file already exists.","chdir\n\nDefined as:\n\n    multi method chdir(IO::Path:D: Str() $path, :$d = True, :$r, :$w, :$x)\n\nDEPRECATION NOTICE: this method will be deprecated in 6.d language and\nremoved in 6.e. Do not use it for new code. Instead, create a new path or\nuse add method. For altering current working directory see &chdir and\n&*chdir subroutines.\n\nContrary to the name, the .chdir method does not change any directories,\nbut merely concatenates the given $path to the invocant and returns the\nresultant IO::Path. Optional file tests can be performed by providing :d,\n:r, :w, or :x Bool named arguments; when set to True, they'll perform .d,\n.r, .w, and .x tests respectively. By default, only :d is set to True.\n\n  sub mkdir\n\nDefined as:\n\n    method mkdir(IO::Path:D: Int() $mode = 0o777 --> IO::Path:D)\n\nCreates a new directory, including its parent directories, as needed\n(similar to *nix utility mkdir with -p option). That is, mkdir\n\"foo/bar/ber/meow\" will create foo, foo/bar, and foo/bar/ber directories as\nwell if they do not exist.\n\nReturns the IO::Path object pointing to the newly created directory on\nsuccess; fails with X::IO::Mkdir if directory cannot be created.\n\nSee also mode for explanation and valid values for $mode.","rmdir\n\nDefined as:\n\n    sub    rmdir(*@dirs --> List:D)\n    method rmdir(IO::Path:D: --> True)\n\nRemove the invocant, or in sub form, all of the provided directories in the\ngiven list, which can contain any Cool object. Only works on empty\ndirectories.\n\nMethod form returns True on success and throws an exception of type\nX::IO::Rmdir if the directory cannot be removed (e.g. the directory is not\nempty, or the path is not a directory). Subroutine form returns a list of\ndirectories that were successfully deleted.\n\nTo delete non-empty directory, see rmtree in File::Directory::Tree module.","chmod\n\nDefined as:\n\n    method chmod(IO::Path:D: Int() $mode --> Bool)\n\nChanges the POSIX permissions of a file or directory to $mode. Returns True\non success; on failure, fails with X::IO::Chmod.\n\nThe mode is expected as an integer following the standard numeric notation,\nand is best written as an octal number:\n\n    'myfile'.IO.chmod(0o444);          # make a file read-only\n    'somedir'.IO.chmod(0o777);         # set 0777 permissions on a directory\n\n\nMake sure you don't accidentally pass the intended octal digits as a\ndecimal number (or string containing a decimal number):\n\n    'myfile'.IO.chmod:  '0444';        # BAD!!! (interpreted as mode 0o674)\n    'myfile'.IO.chmod: '0o444';        # OK (an octal in a string)\n    'myfile'.IO.chmod:  0o444;         # Also OK (an octal literal)","rename\n\nDefined as:\n\n    method rename(IO::Path:D: IO() $to, :$createonly = False --> Bool:D)\n    sub    rename(IO() $from, IO() $to, :$createonly = False --> Bool:D)\n\nRenames a file or directory. Returns True on success; fails with\nX::IO::Rename if :$createonly is True and the $to path already exists or if\nthe operation failed for some other reason.\n\nNote: some renames will always fail, such as when the new name is on a\ndifferent storage device. See also: move.","copy\n\nDefined as:\n\n    method copy(IO::Path:D: IO() $to, :$createonly --> Bool:D)\n    sub    copy(IO() $from, IO() $to, :$createonly --> Bool:D)\n\nCopies a file. Returns True on success; fails with X::IO::Copy if\n:$createonly is True and the $to path already exists or if the operation\nfailed for some other reason, such as when $to and $from are the same\nfile.","move\n\nDefined as:\n\n    method move(IO::Path:D: IO() $to, :$createonly --> Bool:D)\n    sub    move(IO() $from, IO() $to, :$createonly --> Bool:D)\n\nCopies a file and then removes the original. If removal fails, it's\npossible to end up with two copies of the file. Returns True on success;\nfails with X::IO::Move if :$createonly is True and the $to path already\nexists or if the operation failed for some other reason, such as when $to\nand $from are the same file.\n\nTo avoid copying, you can use rename, if the files are on the same storage\ndevice. It also works with directories, while move does not.","Numeric\n\nDefined as:\n\n    method Numeric(IO::Path:D: --> Numeric:D)\n\nCoerces .basename to Numeric. Fails with X::Str::Numeric if base name is\nnot numerical.","Int\n\nDefined as:\n\n    method Int(IO::Path:D: --> Int:D)\n\nCoerces .basename to Int. Fails with X::Str::Numeric if base name is not\nnumerical.","symlink\n\nDefined as:\n\n    method symlink(IO::Path:D $target: IO() $link --> Bool:D)\n    sub    symlink(      IO() $target, IO() $link --> Bool:D)\n\nCreate a new symbolic link $link to existing $target. Returns True on\nsuccess; fails with X::IO::Symlink if the symbolic link could not be\ncreated. If $target does not exist, creates a dangling symbolic link. To\ncreate a hard link, see link.\n\nNote: on Windows, creation of symbolic links may require escalated\nprivileges.","link\n\nDefined as:\n\n    method link(IO::Path:D $target: IO() $link --> Bool:D)\n    sub    link(      IO() $target, IO() $link --> Bool:D)\n\nCreate a new hard link $link to existing $target. Returns True on success;\nfails with X::IO::Link if the hard link could not be created. To create a\nsymbolic link, see symlink.","unlink\n\nDefined as:\n\n    method unlink(IO::Path:D: --> True)\n    sub    unlink(*@filenames --> List:D)\n\nDelete all specified ordinary files, links, or symbolic links for which\nthere are privileges to do so. See rmdir to delete directories.\n\nThe subroutine form returns the names of all the files in the list,\nexcluding those for which the filesystem raised some error; since trying to\ndelete a file that does not exist does not raise any error at that level,\nthis list will include the names of the files in the list that do not\nexist.\n\nThe method form returns True on success, or fails with X::IO::Unlink if the\noperation could not be completed. If the file to be deleted does not exist,\nthe routine treats it as success.\n\n    'foo.txt'.IO.open(:w).close;\n    'bar'.IO.mkdir;\n    say unlink <foo.txt  bar  not-there.txt>; # OUTPUT: «[foo.txt not-there.txt]␤»\n    # `bar` is not in output because it failed to delete (it's a directory)\n    # `not-there.txt` is present. It never existed, so that's deemed a success.\n\n    # Method form `fail`s:\n    say .exception.message without 'bar'.IO.unlink;\n    # OUTPUT: «Failed to remove the file […] illegal operation on a directory␤»","IO\n\nDefined as:\n\n    method IO(IO::Path:D: --> IO::Path)\n\nReturns the invocant.","SPEC\n\nDefined as:\n\n    method SPEC(IO::Path:D: --> IO::Spec)\n\nReturns the IO::Spec object that was (implicitly) specified at object\ncreation time.\n\n    my $io = IO::Path.new(\"/bin/bash\");\n    say $io.SPEC;                            # OUTPUT: «(Unix)␤»\n    say $io.SPEC.dir-sep;                    # OUTPUT: «/␤»\n\nFile timestamp retrieval\n\nThere are also 3 methods for fetching the 3 timestamps of a file (inode),\non Operating Systems where these are available:","modified\n\nReturns an Instant object indicating when the content of the file was last\nmodified. Compare with changed.\n\n    say \"path/to/file\".IO.modified;          # Instant:1424089165\n    say \"path/to/file\".IO.modified.DateTime; # 2015-02-16T12:18:50Z","accessed\n\nReturn an Instant object representing the timestamp when the file was last\naccessed. Note: depending on how the filesystem was mounted, the last\naccessed time may not update on each access to the file, but only on the\nfirst access after modifications.\n\n    say \"path/to/file\".IO.accessed;          # Instant:1424353577\n    say \"path/to/file\".IO.accessed.DateTime; # 2015-02-19T13:45:42Z","changed\n\nReturns an Instant object indicating the metadata of the file or directory\nwas last changed (e.g. permissions, or files created/deleted in directory).\nCompare with modified.\n\n    say \"path/to/file\".IO.changed;           # Instant:1424089165\n    say \"path/to/file\".IO.changed.DateTime;  # 2015-02-16T12:18:50Z\n\n\nFile permissions retrieval","mode\n\nReturn an IntStr object representing the POSIX permissions of a file. The\nStr part of the result is the octal representation of the file permission,\nlike the form accepted by the chmod(1) utility.\n\n    say ~\"path/to/file\".IO.mode;  # e.g. '0644'\n    say +\"path/to/file\".IO.mode;  # e.g. 420, where sprintf('%04o', 420) eq '0644'\n\n\nThe result of this can be used in the other methods that take a mode as an\nargument.\n\n    \"path/to/file1\".IO.chmod(\"path/to/file2\".IO.mode);  # will change the\n                                                        # permissions of file1\n                                                        # to be the same as file2"],"desc":"TITLE\nclass IO::Path\n\nSUBTITLE\nFile or directory path\n\n    class IO::Path is Cool does IO { }\n\n\nIO::Path is the workhorse of IO operations.\n\nConceptually, an IO::Path object consists of a volume, a directory, and a\nbasename. It supports both purely textual operations, and operations that\naccess the filesystem, e.g. to resolve a path, or to read all content of a\nfile.\n\nAt creation, each IO::Path object is given information about the current\nworking directory the path might be relative to using the $.CWD attribute\n(defaults to $*CWD), as well as what operating system semantics should be\nused for path manipulation using the special IO::Spec type given in the\n$.SPEC attribute.\n\nThe $.SPEC defaults to the value of $*SPEC, which uses the object suitable\nfor the operating system the code is currently running on. This is the\ndefault most code will be comfortable with.\n\nIn certain situations, e.g. testing, you may wish to force $*SPEC to use\none of the specific SPEC modules: IO::Spec::Unix, IO::Spec::Win32,\nIO::Spec::Cygwin, and IO::Spec::QNX, or to create IO::Path objects via\nshortcut subclasses IO::Path::Unix, IO::Path::Win32, IO::Path::Cygwin, and\nIO::Path::QNX that pre-set the $.SPEC attribute for you.\n\nThe rest of this document silently assumes Unix semantics in its examples,\nunless stated otherwise.\n\n","name":"IO::Path"},{"desc":"TITLE\nclass IO::Spec\n\nSUBTITLE\nPlatform specific operations on file and directory paths\n\n    class IO::Spec { }\n\nObjects of this class are not used directly but as a sub-class specific to\nthe platform perl is running on via the $*SPEC variable which will contain\nan object of the appropriate type.\n\nThe sub-classes are documented separately, with the platform-specific\ndifferences documented in IO::Spec::Cygwin, IO::Spec::QNX, IO::Spec::Unix\nand IO::Spec::Win32.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n","methods":[],"name":"IO::Spec"},{"name":"Supplier::Preserving","desc":"TITLE\nclass Supplier::Preserving\n\nSUBTITLE\nCached live Supply factory\n\n    class Supplier::Preserving is Supplier { }\n\nThis is a factory for live Supply-type objects, and it provides the\nmechanism for emitting new values onto the supplies, whereby values are\nkept when no consumer has tapped into the Supply. Any tapping will consume\nthe already stored and future values.\n\nStarting a preserving Supply and consuming its values after it is done:\n\n    my $p = Supplier::Preserving.new;\n    start for ^3 {\n        $p.emit($_);\n        LAST {\n            say „done after { now - BEGIN now}s“;\n            $p.done;\n        }\n    }\n    sleep 2;\n    react {\n        whenever $p.Supply { $_.say; }\n        whenever Promise.in(2) { done }\n    }\n    say „also done after { now - BEGIN now }s“\n\nWill output:\n\n    done after 0.0638467s\n    0\n    1\n    2\n    also done after 4.0534119s\n\n\n","methods":["new\n\n    method new()\n\nThe Supplier constructor."]},{"desc":"TITLE\nrole CX::Warn\n\nSUBTITLE\nControl exception warning\n\n    role CX::Warn does X::Control { }\n\nA control exception triggered when warn is called to warn about any\nincidence.\n\n","methods":["new\n\nCX::Warn objects are created when a warning is thrown in any block."],"name":"CX::Warn"},{"methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<take control exception>\"."],"desc":"TITLE\nrole CX::Take\n\nSUBTITLE\nTake control exception\n\n    role CX::Take does X::Control { }\n\nA control exception triggered by take.\n\n","name":"CX::Take"},{"name":"CX::Return","methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<return control exception>\""],"desc":"TITLE\nrole CX::Return\n\nSUBTITLE\nReturn control exception\n\n    role CX::Next does X::Control { }\n\nA control exception to be used when return is called from within a sub.\n\n"},{"methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<emit control exception>\""],"desc":"TITLE\nrole CX::Emit\n\nSUBTITLE\nEmit control exception\n\n    role CX::Emit does X::Control { }\n\nA control exception to be used when emit is used inside a Supply block.\n\n","name":"CX::Emit"},{"desc":"TITLE\nrole CX::Last\n\nSUBTITLE\nLast control exception\n\n    role CX::Last does X::Control { }\n\nA control exception that is thrown when last is called.\n\n","methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<last control exception>\". Since this type of exception is to be\nconsumed by type and not really by the content of the message, this is a\ngeneric message, similar to all other CX::* exceptions."],"name":"CX::Last"},{"methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<done control exception>\""],"desc":"TITLE\nrole CX::Done\n\nSUBTITLE\nDone control exception\n\n    role CX::Done does X::Control { }\n\nA control exception to be used to indicate a supply block is finished by\ncalling done.\n\n","name":"CX::Done"},{"desc":"TITLE\nrole CX::Proceed\n\nSUBTITLE\nProceed control exception\n\n    role CX::Proceed does X::Control { }\n\nA control exception to be used when proceed is used within when or default\nblocks.\n\n","methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<proceed control exception>\""],"name":"CX::Proceed"},{"methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<next control exception>\""],"desc":"TITLE\nrole CX::Succeed\n\nSUBTITLE\nSucceed control exception\n\n    role CX::Succeed does X::Control { }\n\nA control exception thrown when succeed is called from a when or default\nblock.\n\n","name":"CX::Succeed"},{"desc":"TITLE\nrole CX::Redo\n\nSUBTITLE\nRedo control exception\n\n    role CX::Redo does X::Control { }\n\nA control exception thrown when redo is called.\n\n","methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<redo control exception>\"."],"name":"CX::Redo"},{"name":"CX::Next","methods":["message\n\nDefined as:\n\n    method message()\n\nReturns \"<next control exception>\""],"desc":"TITLE\nrole CX::Next\n\nSUBTITLE\nNext control exception\n\n    role CX::Next does X::Control { }\n\nA control exception that is triggered when next is called.\n\n    for ^10 {\n        CONTROL {\n          when CX::Next { say \"We're next\" };\n        }\n        next if $_ %% 2;\n        say \"We're in $_\";\n    }\n\n\nThis will print:\n\n    We're next\n    We're in 1\n    We're next\n    We're in 3\n    We're next\n    We're in 5\n    We're next\n    We're in 7\n    We're next\n    We're in 9\n\n\n"},{"desc":"TITLE\nclass Metamodel::PackageHOW\n\nSUBTITLE\nMetaobject representing a Raku package.\n\n    class Metamodel::PackageHOW\n      does Metamodel::Naming\n      does Metamodel::Documenting\n      does Metamodel::Stashing\n      does Metamodel::TypePretense\n      does Metamodel::MethodDelegation { }\n\nMetamodel::ClassHOW is the metaclass behind the package keyword.\n\n    package P {};\n    say P.HOW; # OUTPUT: «Perl6::Metamodel::PackageHOW.new␤»\n\nWarning: This class is part of the Rakudo implementation, not a part of the\nlanguage itself.\n\n","methods":["archetypes\n\nDefined as:\n\n    method archetypes()\n\nReturns the archetypes for this model, that is, the properties a metatype\ncan implement.","new\n\nDefined as:\n\n    method new(*%named)\n\nCreates a new PackageHOW.","new_type\n\nDefined as:\n\n    method new_type(:$name = '<anon>', :$repr, :$ver, :$auth)\n\nCreates a new package, with optional representation, version and auth\nfield.\n\n  compose\n\nDefined as:\n\n    method compose($obj, :$compiler_services)\n\nSets the metapackage as composed.\n\n  is_composed\n\nDefined as:\n\n    method is_composed($obj)\n\nReturns the composed status of the metapackage."],"name":"Metamodel::PackageHOW"},{"methods":[],"desc":"TITLE\nrole Metamodel::CurriedRoleHOW\n\nSUBTITLE\nSupport for parameterized roles that have not been instantiated\n\n    class Metamodel::CurriedRoleHOW\n        does Metamodel::Naming\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning {}\n\nSometimes, we see references to roles that provide parameters but do not\nfully resolve them. For example, in:\n\n    class C does R[Type] { }\n\n\nWe need to represent R[T], but we cannot yet fully specialize the role\nbecause we don't have the first parameter at hand. We may also run into the\nissue where we have things like:\n\n    sub foo(R[T] $x) { ... }\n    if $x ~~ R[T] { ... }\n\n\nWhere we clearly want to talk about a partial parameterization of a role\nand actually want to do so in a way distinct from a particular\ninstantiation of it. This metaobject represents those \"partial types\" as\nboth a way to curry on your way to a full specialization, but also as a way\nto do type-checking or punning.\n\nThis class will show up in parameterized roles. For instance:\n\n    role Zipi[::T] {\n        method zape { \"Uses \" ~ T.^name };\n    }\n    role Zipi[::T, ::Y] {\n        method zape { \"Uses \" ~ T.^name ~ \" and \" ~ Y.^name };\n    }\n    for Zipi[Int], Zipi[Int,Str] -> $role {\n        say $role.HOW;\n        say $role.new().zape;\n    }\n    # OUTPUT:\n    # Perl6::Metamodel::CurriedRoleHOW.new\n    # Uses Int\n    # Perl6::Metamodel::CurriedRoleHOW.new\n    # Uses Int and Str\n\n\nSince there are several variants of Zipi, providing a parameter curries it,\nbut it's still up to the compiler to find out the actual realization taking\ninto account the ParametricRoleGroup, so these (partially instantiated)\nroles show up as Metamodel::CurriedRoleHOW as shown in the example; even if\nthere's a single parameter an instantiated role will also be of the same\ntype:\n\n    role Zape[::T] {};\n    say Zape[Int].HOW; #: «Perl6::Metamodel::CurriedRoleHOW.new␤»\n\nNote: As most of the Metamodel classes, this class is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate.","name":"Metamodel::CurriedRoleHOW"},{"name":"Metamodel::C3MRO","desc":"TITLE\nrole Metamodel::C3MRO\n\nSUBTITLE\nMetaobject that supports the C3 method resolution order\n\n    role Metamodel::C3MRO { }\n\nMetamodel role for the C3 method resolution order (MRO). Note: this method,\nalong with almost the whole metamodel, is part of the Rakudo\nimplementation.\n\nThe method resolution order for a type is a flat list of types including\nthe type itself, and (recursively) all super classes. It determines in\nwhich order the types will be visited for determining which method to call\nwith a given name, or for finding the next method in a chain with nextsame,\ncallsame, nextwith or callwith.\n\n    class CommonAncestor { };   # implicitly inherits from Any\n    class Child1 is CommonAncestor { }\n    class Child2 is CommonAncestor { }\n    class GrandChild2 is Child2 { }\n    class Weird is Child1 is GrandChild2 { };\n\n    say Weird.^mro; # OUTPUT: «(Weird) (Child1) (GrandChild2) (Child2) (CommonAncestor) (Any) (Mu)␤»\n\n\nC3 is the default resolution order for classes and grammars in Raku. Note\nthat roles generally do not appear in the method resolution order (unless\nthey are punned into a class, from which another type inherits), because\nmethods are copied into classes at role application time.\n\n","methods":["compute_mro\n\n    method compute_mro($type)\n\nComputes the method resolution order.","mro\n\n    method mro($type)\n\nReturns a list of types in the method resolution order, even those that are\nmarked is hidden.\n\n    say Int.^mro;   # OUTPUT: «((Int) (Cool) (Any) (Mu))␤»","mro_unhidden\n\n    method mro_unhidden($type)\n\nReturns a list of types in method resolution order, excluding those that\nare marked with is hidden."]},{"methods":["add_attribute\n\n    method add_attribute(Metamodel::AttributeContainer: $obj, $attribute)\n\nAdds an attribute. $attribute must be an object that supports the methods\nname, type and package, which are called without arguments. It can for\nexample be of type Attribute.","attributes\n\n    method attributes(Metamodel::AttributeContainer: $obj)\n\nReturns a list of attributes. For most Raku types, these will be objects of\ntype Attribute.","set_rw\n\n    method set_rw(Metamodel::AttributeContainer: $obj)\n\nMarks a type whose attributes default to having a write accessor. For\nexample in\n\n    class Point is rw {\n        has $.x;\n        has $.y;\n    }\n\nThe is rw trait on the class calls the set_rw method on the metaclass,\nmaking all the attributes implicitly writable, so that you can write;\n\n    my $p = Point.new(x => 1, y => 2);\n    $p.x = 42;","rw\n\n    method rw(Metamodel::AttributeContainer: $obj)\n\nReturns a true value if method set_rw has been called on this object, that\nis, if new public attributes are writable by default."],"desc":"TITLE\nrole Metamodel::AttributeContainer\n\nSUBTITLE\nMetaobject that can hold attributes\n\n    role Metamodel::AttributeContainer {}\n\nClasses, roles and grammars can have attributes. Storage and introspection\nof attributes is implemented by this role.\n\n","name":"Metamodel::AttributeContainer"},{"name":"Metamodel::Versioning","methods":["ver\n\n    method ver($obj)\n\nReturns the version of the metaobject, if any, otherwise returns Mu.","auth\n\n    method auth($obj)\n\nReturns the author of the metaobject, if any, otherwise returns an empty\nstring.","api\n\n    method api($obj)\n\nReturns the API of the metaobject, if any, otherwise returns an empty\nstring.","set_ver\n\n    method set_ver($obj, $ver)\n\nSets the version of the metaobject.","set_auth\n\n    method set_auth($obj, $auth)\n\nSets the author of the metaobject.","set_api\n\n    method set_api($obj, $api)\n\nSets the API of the metaobject."],"desc":"TITLE\nrole Metamodel::Versioning\n\nSUBTITLE\nMetaobjects that support versioning\n\n    role Metamodel::Versioning { ... }\n\nMetamodel role for (optionally) versioning metaobjects.\n\nWhen you declare a type, you can pass it a version, author, and/or API and\nget them, like so:\n\n    class Versioned:ver<0.0.1>:auth<github:Kaiepi>:api<1> { }\n\n    say Versioned.^ver;  # OUTPUT: «v0.0.1␤»\n    say Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\n    say Versioned.^api;  # OUTPUT: «1␤»\n\n\nThis is roughly equivalent to the following, which also sets them\nexplicitly:\n\n    BEGIN {\n        class Versioned { }\n        Versioned.^set_ver:  v0.0.1;\n        Versioned.^set_auth: 'github:Kaiepi';\n        Versioned.^set_api:  <1>;\n    }\n\n    say Versioned.^ver;  # OUTPUT: «v0.0.1␤»\n    say Versioned.^auth; # OUTPUT: «github:Kaiepi␤»\n    say Versioned.^api;  # OUTPUT: «1␤»\n\n\n"},{"desc":"TITLE\nrole Metamodel::Trusting\n\nSUBTITLE\nMetaobject that supports trust relations between types\n\n    role Metamodel::Trusting is SuperClass { ... }\n\n\nNormally, code in a class or role can only access its own private methods.\nIf another type declares that it trusts that first class, then access to\nprivate methods of that second type is possible. Metamodel::Trusting\nimplements that aspect of the Raku object system.\n\n    class A {\n        my class B {\n            trusts A;   # that's where Metamodel::Trusting comes in\n            method !private_method() {\n                say \"Private method in B\";\n            }\n        }\n        method build-and-poke {\n            # call a private method from B\n            # disallowed if A doesn't trust B\n            B.new()!B::private_method();\n        }\n    };\n\n    A.build-and-poke;   # Private method in A\n\n","methods":["add_trustee\n\n    method add_trustee(Metamodel::Trusting:D: $type, Mu $trustee)\n\nTrust $trustee.\n\n    class A {\n        BEGIN A.^add_trustee(B);\n        # same as 'trusts B';\n    }","trusts\n\n    method trusts(Metamodel::Trusting:D: $type --> List)\n\nReturns a list of types that the invocant trusts.\n\n    class A { trusts Int; };\n    say .^name for A.^trusts;       # Int","is_trusted\n\n    method is_trusted(Metamodel::Trusting:D: $type, $claimant)\n\nReturns 1 if $type trusts $claimant, and 0 otherwise. Types always trust\nthemselves."],"name":"Metamodel::Trusting"},{"methods":[],"desc":"TITLE\nrole Metamodel::RolePunning\n\nSUBTITLE\nMetaobject that supports punning of roles.\n\n    role Perl6::Metamodel::RolePunning {}\n\nImplements the ability to create objects from Roles without the\nintermediate need to use a class. Not intended to be used directly (will in\nfact error if it's used), but via punning of roles, as below. This is also\nRakudo specific and not part of the spec.\n\n    role A {\n        method b {\n          return \"punned\"\n        }\n    };\n    my $a = A.new;\n    say $a.b; # OUTPUT: «punned␤»\n","name":"Metamodel::RolePunning"},{"desc":"TITLE\nclass Metamodel::ClassHOW\n\nSUBTITLE\nMetaobject representing a Raku class.\n\n    class Metamodel::ClassHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Versioning\n        does Metamodel::Stashing\n        does Metamodel::AttributeContainer\n        does Metamodel::MethodContainer\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::DefaultParent\n        does Metamodel::C3MRO\n        does Metamodel::MROBasedMethodDispatch\n        does Metamodel::MROBasedTypeChecking\n        does Metamodel::Trusting\n        does Metamodel::BUILDPLAN\n        does Metamodel::Mixins\n        does Metamodel::ArrayType\n        does Metamodel::BoolificationProtocol\n        does Metamodel::REPRComposeProtocol\n        does Metamodel::InvocationProtocol\n        does Metamodel::Finalization\n            { }\n\nMetamodel::ClassHOW is the metaclass behind the class keyword.\n\n    say so Int.HOW ~~ Metamodel::ClassHOW;    # OUTPUT: «True␤»\n    say Int.^methods(:all).pick.name;         # OUTPUT: «random Int method name␤»\n\nWarning: This class is part of the Rakudo implementation, not a part of the\nlanguage itself.\n\n","methods":["add_fallback\n\n    method add_fallback(Metamodel::ClassHOW:D: $obj, $condition, $calculator)\n\nInstalls a method fallback, that is, add a way to call methods that weren't\nstatically added.\n\nBoth $condition and $calculator must be callables that receive the invocant\nand the method name once a method is called that can't be found in the\nmethod cache.\n\nIf $condition returns a true value, $calculator is called with the same\narguments, and must return the code object to be invoked as the method, and\nis added to the method cache.\n\nIf $condition returns a false value, the next fallback (if any) is tried,\nand if none matches, an exception of type X::Method::NotFound is thrown.\n\nUser-facing code (that is, code not dabbling with metaclasses) should use\nmethod FALLBACK instead.","can\n\n    method can(Metamodel::ClassHOW:D: $obj, $method-name)\n\nGiven a method name, it returns a List of methods that are available with\nthis name.\n\n    class A      { method x($a) {} };\n    class B is A { method x()   {} };\n    say B.^can('x').elems;              # OUTPUT: «2␤»\n    for B.^can('x') {\n        say .arity;                     # OUTPUT: «1, 2␤»\n    }\n\nIn this example, class B has two possible methods available with name x\n(though a normal method call would only invoke the one installed in B\ndirectly). The one in B has arity 1 (i.e. it expects one argument, the\ninvocant (self)), and the one in A expects 2 arguments (self and $a).","lookup\n\n    method lookup(Metamodel::ClassHOW:D: $obj, $method-name --> Method:D)\n\nReturns the first matching Method with the provided name. If no method was\nfound, returns a VM-specific sentinel value (typically a low-level NULL\nvalue) that can be tested for with a test for definedness. It is\npotentially faster than .^can but does not provide a full list of all\ncandidates.\n\n    say Str.^lookup('Int').perl; # OUTPUT: «method Int (Str:D $: *%_) { #`(Method|39910024) ... }␤»\n\n    for <upper-case  uc> {\n        Str.^lookup: $^meth andthen .(\"foo\").say\n            orelse \"method `$meth` not found\".say\n    }\n    # OUTPUT:\n    # method `upper-case` not found\n    # FOO","compose\n\n    method compose(Metamodel::ClassHOW:D: $obj)\n\nA call to compose brings the metaobject and thus the class it represents\ninto a fully functional state, so if you construct or modify a class, you\nmust call the compose method before working with the class.\n\nIt updates the method cache, checks that all methods that are required by\nroles are implemented, does the actual role composition work, and sets up\nthe class to work well with language interoperability.","new_type\n\n    method (:$name, :$repr = 'P6opaque', :$ver, :$auth)\n\nCreates a new type from the metamodel, which we can proceed to build\n\n    my $type = Metamodel::ClassHOW.new_type(name => \"NewType\",\n                                            ver => v0.0.1,\n                                            auth => 'github:perl6' );\n    $type.HOW.add_method($type,\"hey\", method { say \"Hey\" });\n    $type.hey;     # OUTPUT: «Hey␤»\n    $type.HOW.compose($type);\n    my $instance = $type.new;\n    $instance.hey; # OUTPUT: «Hey␤»\n\nWe add a single method by using Higher Order Workings methods, and then we\ncan use that method directly as class method; we can then compose the type,\nfollowing which we can create already an instance, which will behave in the\nexact same way."],"name":"Metamodel::ClassHOW"},{"desc":"TITLE\nrole Metamodel::RoleContainer\n\nSUBTITLE\nMetaobject that supports holding/containing roles\n\n    role Metamodel::RoleContainer {}\n\nImplements the ability to hold roles to be held for composition.\n\n    class A does SomeRole {}\n\n\nroughly corresponds to\n\n    class A {\n        BEGIN A.^add_role(SomeRole);\n    }\n\n\n","methods":["add_role\n\n    method add_role(Metamodel::RoleContainer:D: $obj, Mu $role)\n\nAdds the $role to the list of roles to be composed.","roles_to_compose\n\n    method roles_to_compose(Metamodel::RoleContainer:D: $obj --> List:D)\n\nreturns a list of roles added with add_role, which are to be composed at\ntype composition time."],"name":"Metamodel::RoleContainer"},{"methods":["new_type\n\n    method new_type(:$name!, :$base_type?, :$repr = 'P6opaque', :$is_mixin)\n\nCreates a new type object for an enum. $name is the enum name, $base_type\nis the type given when the enum is declared using a scoped declaration (if\nany), and $repr is the type representation passed to the enum using the\nrepr trait. $is_mixin is unused.","add_parent\n\n    method add_parent($obj, $parent)\n\nSets the base type of an enum. This can only be used if no base type was\npassed to .new_type.","set_export_callback\n\n    method set_export_callback($obj, $callback)\n\nSets the enum's export callback, which is invoked when calling\n.compose_values. This is called when applying the export trait to an enum.\n$callback should be a routine of some sort, taking no arguments, that\nhandles exporting the enum's values.","export_callback\n\n    method export_callback($obj)\n\nReturns the export callback set by .set_export_callback.","compose\n\n    method compose($obj, :$compiler_services)\n\nCompletes a type object for an enum. This is when any roles done by the\nenum are mixed in. This needs to be called before any enum values can be\nadded using .add_enum_value.","is_composed\n\n    method is_composed($obj)\n\nReturns 1 if the enum is composed, otherwise returns 0.","compose_values\n\n    method compose_values($obj)\n\nCalls the export callback set by .set_export_callback and removes it from\nstate. This should be called after adding the enum's values using\n.add_enum_value.","set_composalizer\n\n    method set_composalizer($c)\n\nSets the composalizer for an enum, which produces a type that can be mixed\nin with another. $c should be a routine of some that has the following\nsignature:\n\n    :($type, $name, @enum_values)","composalizer\n\n    method composalizer($obj)\n\nReturns the composalizer set by .set_composalizer.","add_enum_value\n\n    method add_enum_value($obj, $value)\n\nAdds a value to this enum. $value should be an instance of the enum itself,\nas type Enumeration.","enum_values\n\n    method enum_values($obj)\n\nReturns the values for the enum.\n\n    enum Numbers <10 20>;\n    say Numbers.^enum_values;                   # OUTPUT: {10 => 0, 20 => 1}","elems\n\n    method elems($obj)\n\nReturns the number of values.\n\n    enum Numbers <10 20>;\n    say Numbers.^elems;                         # OUTPUT: 2","enum_from_value\n\n    method enum_from_value($obj, $value)\n\nGiven a value of the enum's base type, return the corresponding enum.\n\n    enum Numbers <10 20>;\n    say Numbers.^enum_from_value(0);            # OUTPUT: 10","enum_value_list\n\n    method enum_value_list($obj)\n\nReturns a list of the enum values.\n\n    enum Numbers <10 20>;\n    say Numbers.^enum_value_list;               # OUTPUT: (10 20)"],"desc":"TITLE\nclass Metamodel::EnumHOW\n\nSUBTITLE\nMetaobject representing a Raku enum.\n\n    class Metamodel::EnumHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Stashing\n        does Metamodel::AttributeContainer\n        does Metamodel::MethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::RoleContainer\n        does Metamodel::BaseType\n        does Metamodel::MROBasedMethodDispatch\n        does Metamodel::MROBasedTypeChecking\n        does Metamodel::BUILDPLAN\n        does Metamodel::BoolificationProtocol\n        does Metamodel::REPRComposeProtocol\n        does Metamodel::InvocationProtocol\n        does Metamodel::Mixins\n            { }\n\nMetamodel::EnumHOW is the metaclass behind the enum keyword.\n\n    enum Numbers <1 2>;\n    say Numbers.HOW ~~ Metamodel::EnumHOW; # OUTPUT: «True␤»\n\nThe following enum declaration:\n\n    our Int enum Error <Warning Failure Exception Sorrow Panic>;\n\nIs roughly equivalent to this code using Metamodel::EnumHOW's methods:\n\n    BEGIN {\n        my constant Error = Metamodel::EnumHOW.new_type: :name<Error>, :base_type(Int);\n        Error.^add_role: Enumeration;\n        Error.^add_role: NumericEnumeration;\n        Error.^compose;\n        for <Warning Failure Exception Sorrow Panic>.kv -> Int $v, Str $k {\n            # Note: Enumeration.pred and .succ will not work when adding enum\n            # values as pairs. They should be instances of the enum itself, but\n            # this isn't possible to do without nqp.\n            Error.^add_enum_value: $k => $v;\n            OUR::{$k} := Error.^enum_from_value: $v;\n        }\n        Error.^compose_values;\n        OUR::<Error> := Error;\n    }\n\nWarning: This class is part of the Rakudo implementation, and is not a part\nof the language specification.\n\n","name":"Metamodel::EnumHOW"},{"methods":["add_private_method\n\n    method add_private_method(Metamodel::PrivateMethodContainer: $obj, $name, $code)\n\nAdds a private method $code with name $name.","private_method_table\n\n    method private_method_table(Metamodel::PrivateMethodContainer: $obj)\n\nReturns a hash of name => &method_object"],"desc":"TITLE\nrole Metamodel::PrivateMethodContainer\n\nSUBTITLE\nMetaobject that supports private methods\n\n    role Metamodel::PrivateMethodContainer { ... }\n\nIn Raku, classes, roles and grammars can have private methods, that is,\nmethods that are only callable from within the class, and are not inherited\nby types derived by inheritance.\n\n    class A {\n        # the ! declares a private method\n        method !double($x) {\n            say 2 * $x;\n        }\n        method call-double($y) {\n            # call with ! instead of .\n            self!double($y);\n        }\n    }\n\nFor the purposes of dispatching and scoping, private methods are closer to\nsubroutines than to methods. However they share access to self and\nattributes with methods.\n\n","name":"Metamodel::PrivateMethodContainer"},{"desc":"TITLE\nrole Metamodel::MethodContainer\n\nSUBTITLE\nMetaobject that supports storing and introspecting methods\n\n    role Metamodel::MethodContainer {}\n\nroles, classes, grammars and enums can contain methods. This role\nimplements the API around storing and introspecting them.\n\n    say .name for Int.^methods(:all);\n\n    # don't do that, because it changes type Int globally.\n    # just for demonstration purposes.\n    Int.^add_method('double', method ($x:) { 2 * $x });\n    say 21.double; # OUTPUT: «42␤»\n\n","methods":["add_method\n\n    method add_method(Metamodel::MethodContainer: $obj, $name, $code)\n\nAdds a method to the metaclass, to be called with name $name. This should\nonly be done before a type is composed.","methods\n\n    method methods(Metamodel::MethodContainer: $obj, :$all, :$local)\n\nReturns a list of public methods available on the class (which includes\nmethods from superclasses and roles). By default this stops at the classes\nCool, Any or Mu; to really get all methods, use the :all adverb. If :local\nis set, only methods declared directly in the class are returned.\n\n    class A {\n        method x() { };\n    }\n\n    say A.^methods();                   # x\n    say A.^methods(:all);               # x infinite defined ...\n\nThe returned list contains objects of type Method, which you can use to\nintrospect their signatures and call them.\n\nSome introspection method-look-alikes like WHAT will not show up, although\nthey are present in any Raku object. They are handled at the grammar level\nand will likely remain so for bootstrap reasons.","method_table\n\n    method method_table(Metamodel::MethodContainer:D: $obj --> Hash:D)\n\nReturns a hash where the keys are method names, and the values are methods.\nNote that the keys are the names by which the methods can be called, not\nnecessarily the names by which the methods know themselves.","lookup\n\n    method lookup(Metamodel::MethodContainer: $obj, $name --> Method)\n\nReturns the first matching method object of the provided $name or (Mu) if\nno method object was found. The search for a matching method object is done\nby following the mro of $obj. Note that lookup is supposed to be used for\nintrospection, if you're after something which can be invoked you probably\nwant to use find_method instead.\n\n    say 2.5.^lookup(\"sqrt\").perl:      # OUTPUT: «method sqrt (Rat $: *%_) ...␤»\n    say Str.^lookup(\"BUILD\").perl;     # OUTPUT: «submethod BUILD (Str $: :$value = \"\", *%_ --> Nil) ...␤»\n    say Int.^lookup(\"does-not-exist\"); # OUTPUT: «(Mu)␤»\n\nThe difference between find_method and lookup are that find_method will use\na default candidate for parametric roles, whereas lookup throws an\nexception in this case, and that find_method honors FALLBACK methods, which\nlookup does not."],"name":"Metamodel::MethodContainer"},{"name":"Metamodel::Primitives","methods":["create_type\n\n    method create_type(Mu $how, $repr = 'P6opaque')\n\nCreates and returns a new type from a metaobject $how and a representation\nname.","set_package\n\n    method set_package(Mu $type, $package)\n\nSets the package associated with the type.","install_method_cache\n\n    method install_method_cache( Mu $type, %cache, :$authoritative = True)\n\nInstalls a method cache, that is, a mapping from method names to code\nobjects. If :authoritative is missing, or set to True, then calls of\nmethods that do not exist in the cache will throw an exception of type\nX::Method::NotFound. If :authoritative is set to False, the usual fallback\nmechanism are tried.","configure_type_checking\n\n    method configure_type_checking( Mu $type, @cache, :$authoritative = True,   :$call_accepts = False )\n\nConfigures the type checking for $type. @cache is a list of known types\nagainst which $type checks positively (so in a classical class-based\nsystem, the type itself and all recursive superclasses). If :authoritative\nis missing or True, this type will fail checks against all types not in\n@cache. If :call_accepts is True, the method ACCEPTS will be called for\ntype checks against this type.","configure_destroy\n\n    method configure_destroy(Mu $type, $destroy)\n\nConfigures whether DESTROY methods are called (if present) when the garbage\ncollector collects an object of this type (if $destroy is set to a true\nvalue). This comes with a performance overhead, so should only be set to a\ntrue value if necessary.","compose_type\n\n    method compose_type(Mu $type, $configuration)\n\nComposes $type (that is, finalizes it to be ready for instantiation). See\nhttps://github.com/perl6/nqp/blob/master/docs/6model/repr-compose-protocol.markdown\nfor what $configuration can contain (until we have better docs, sorry).","rebless\n\n    method rebless(Mu $object, Mu $type)\n\nChanges $obj to be of type $type. This only works if $type type-checks\nagainst the current type of $obj, and if the storage of $object is a subset\nof that of $type.","is_type\n\n    method is_type(Mu \\obj, Mu \\type --> Bool:D)\n\nType-checks obj against type"],"desc":"TITLE\nclass Metamodel::Primitives\n\nSUBTITLE\nMetaobject that supports low-level type operations\n\n    class Metamodel::Primitives {}\n\nMetamodel::Primitives provides low-level operations for working with types,\nwhich are otherwise only available as implementation-dependent directives.\nThese primitives are available as class methods.\n\nHere is an example that steals the metamodel instance from the Int class to\ncreate a custom type (usually you would create your own metaclass if you\nmess with something as low-level), which allows calling of just one method\ncalled why:\n\n    my Mu $type := Metamodel::Primitives.create_type(Int.HOW, 'P6opaque');\n    $type.^set_name('why oh why?');\n    my %methods =  why => sub ($) { say 42 };\n    Metamodel::Primitives.install_method_cache($type, %methods, :authoritative);\n    $type.why;      # 42\n    $type.list;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::NotFound: Method 'list' not found for invocant of class 'why oh why?'␤»\n\n"},{"methods":["setup_finalization\n\n    method setup_finalization(Metamodel::Finalization:D: $obj)\n\nCollects the DESTROY submethods from this class and all its superclasses,\nand marks the class as needing action on garbage collection.\n\nA metamodel for a kind that implements finalization semantics must call\nthis method at type composition time.","destroyers\n\n    method destroyers(Metamodel::Finalization:D: $obj --> List:D)\n\nReturns a list of all finalization methods."],"desc":"TITLE\nrole Metamodel::Finalization\n\nSUBTITLE\nMetaobject supporting object finalization\n\n    role Metamodel::Finalization { ... }\n\nThis role takes care that DESTROY submethods are called (if they exist)\nwhen an object is garbage-collected.\n\n","name":"Metamodel::Finalization"},{"name":"Metamodel::MultipleInheritance","methods":["add_parent\n\n    method add_parent(Metamodel::MultipleInheritance:D: $Obj, $parent, :$hides)\n\nAdds $parent as a parent type. If $hides is set to a true value, the parent\ntype is added as a hidden parent.\n\n$parent must be a fully composed typed. Otherwise an exception of type\nX::Inheritance::NotComposed is thrown.","parents\n\n    method parents(Metamodel::MultipleInheritance:D: $obj, :$all, :$tree)\n\nReturns the list of parent classes. By default it stops at Cool, Any or Mu,\nwhich you can suppress by supplying the :all adverb. With :tree, a nested\nlist is returned.\n\n    class D { };\n    class C1 is D { };\n    class C2 is D { };\n    class B is C1 is C2 { };\n    class A is B { };\n\n    say A.^parents(:all).perl;\n    # OUTPUT: «(B, C1, C2, D, Any, Mu)␤»\n    say A.^parents(:all, :tree).perl;\n    # OUTPUT: «[B, ([C1, [D, [Any, [Mu]]]], [C2, [D, [Any, [Mu]]]])]␤»","hides\n\n    method hides(Metamodel::MultipleInheritance:D: $obj)\n\nReturns a list of all hidden parent classes.","hidden\n\n    method hidden(Metamodel::MultipleInheritance:D: $obj)\n\nReturns a true value if (and only if) the class is marked with the trait is\nhidden.","set_hidden\n\n    method set_hidden(Metamodel::MultipleInheritance:D: $obj)\n\nMarks the type as hidden."],"desc":"TITLE\nrole Metamodel::MultipleInheritance\n\nSUBTITLE\nMetaobject that supports multiple inheritance\n\n    role Metamodel::MultipleInheritance {}\n\nClasses, roles and grammars can have parent classes, that is, classes to\nwhich method lookups fall back to, and to whose type the child class\nconforms to.\n\nThis role implements the capability of having zero, one or more parent (or\nsuper) classes.\n\nIn addition, it supports the notion of hidden classes, whose methods are\nexcluded from the normal dispatching chain, so that for example nextsame\nignores it.\n\nThis can come in two flavors: methods from a class marked as is hidden are\ngenerally excluded from dispatching chains, and class A hides B adds B as a\nparent class to A, but hides it from the method resolution order, so that\nmro_unhidden skips it.\n\n"},{"name":"Metamodel::ParametricRoleHOW","methods":[],"desc":"TITLE\nrole Metamodel::ParametricRoleHOW\n\nSUBTITLE\nRepresents a non-instantiated, parameterized, role.\n\n    class Metamodel::ParametricRoleHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Versioning\n        does Metamodel::MethodContainer\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::AttributeContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::Stashing\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning\n        does Metamodel::ArrayType {}\n\nA Metamodel::ParametricRoleHOW represents a non-instantiated, possibly\nparameterized, role:\n\n    (role Zape[::T] {}).HOW.say;# OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n    (role Zape {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nAs usual, .new_type will create a new object of this class.\n\n    my \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zape\", group => \"Zape\");\n    say zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nThe extra group argument will need to be used to integrate it in a\nparametric role group, which will need to be defined in advance.\n\nNote: As most of the Metamodel classes, this one is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate, unless their intention is really to create a parametric role\ngroup."},{"methods":[],"desc":"TITLE\nrole Metamodel::ParametricRoleGroupHOW\n\nSUBTITLE\nRepresents a group of roles with different parameterizations\n\n    class Metamodel::ParametricRoleGroupHOW\n        does Metamodel::Naming\n        does Metamodel::Documenting\n        does Metamodel::Stashing\n        does Metamodel::TypePretense\n        does Metamodel::RolePunning\n        does Metamodel::BoolificationProtocol {}\n\nA ParametricRoleGroupHOW groups a set of ParametricRoleHOW, every one of\nthem representing a single role declaration with their own parameter sets.\n\n    (role Zape[::T] {}).HOW.say; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n    Zape.HOW.say ; # OUTPUT: «Perl6::Metamodel::ParametricRoleGroupHOW.new␤»\n\n\nParametricRoleHOWs need to be added to this kind of group:\n\n    my \\zape := Metamodel::ParametricRoleGroupHOW.new_type( name => \"zape\");\n    my \\zipi := Metamodel::ParametricRoleHOW.new_type( name => \"zipi\", group => zape);\n    say zipi.HOW; # OUTPUT: «Perl6::Metamodel::ParametricRoleHOW.new␤»\n\n\nNote: As most of the Metamodel classes, this class is here mainly for\nillustration purposes and it's not intended for the final user to\ninstantiate.","name":"Metamodel::ParametricRoleGroupHOW"},{"methods":["find_method\n\n    method find_method($obj, $name, $no_fallback, *%adverbs)\n\nGiven a method name, it returns the method object of that name which is\nclosest in the method resolution order (MRO). If no method can be found, it\nreturns a VM-specific sentinel value (typically a low-level NULL value)\nthat can be tested for with a test for definedness:\n\n    for <upper-case  uc> {\n        Str.^find_method: $^meth andthen .(\"foo\").say\n            orelse \"method `$meth` not found\".say\n    }\n    # OUTPUT:\n    # method `upper-case` not found\n    # FOO\n\nIf :no_fallback is supplied, fallback methods are not considered.","find_method_qualified\n\n    method find_method_qualified($obj, $type, $name)\n\nGiven a method name and a type, returns the method from that type. This is\nused in calls like\n\n    self.SomeParentClass::the_method();","can\n\n    method can($obj, $name)\n\nReturns the list of methods of that name the object can do.","publish_method_cache\n\nDefined as:\n\n    method publish_method_cache($obj)\n\nWalk MRO and add methods to cache, unless another method lower in the class\nhierarchy \"shadowed\" it."],"desc":"TITLE\nrole Metamodel::MROBasedMethodDispatch\n\nSUBTITLE\nMetaobject that supports resolving inherited methods\n\n    role Metamodel::MROBasedMethodDispatch { }\n\nThis role implements locating methods based on the method resolution order\nof related (usually \"super\"/\"parent\") types.\n\n","name":"Metamodel::MROBasedMethodDispatch"},{"name":"Metamodel::ConcreteRoleHOW","methods":[],"desc":"TITLE\nrole Metamodel::ConcreteRoleHOW\n\nSUBTITLE\nProvides an implementation of a concrete instance of a role\n\n    class Metamodel::ConcreteRoleHOW\n        does Metamodel::Naming\n        does Metamodel::Versioning\n        does Metamodel::PrivateMethodContainer\n        does Metamodel::MethodContainer\n        does Metamodel::MultiMethodContainer\n        does Metamodel::AttributeContainer\n        does Metamodel::RoleContainer\n        does Metamodel::MultipleInheritance\n        does Metamodel::ArrayType\n        does Metamodel::Concretization {}\n\nYou can use this to build roles, in the same way that ClassHOW can be used\nto build classes:\n\n    my $a = Metamodel::ConcreteRoleHOW.new_type(name => \"Bar\");\n    $a.^compose;\n    say $a.^roles; # OUTPUT: «(Mu)␤»\n\n\nThe main difference with ClassHOW.new_type is that you can mix-in roles in\nthis newly created one.\n\nThis class is Rakudo specific, and provided only for completeness. Not\nreally intended to be used by the final user."},{"desc":"TITLE\nrole Metamodel::Naming\n\nSUBTITLE\nMetaobject that supports named types\n\n    role Metamodel::Naming { }\n\nMetamodel role for (optionally) named things, like classes, roles and\nenums.\n\n","methods":["name\n\n    method name($type)\n\nReturns the name of the metaobject, if any.\n\n    say 42.^name;       # OUTPUT: «Int␤»","set_name\n\n    method set_name($type, $new_name)\n\nSets the new name of the metaobject."],"name":"Metamodel::Naming"},{"name":"Telemetry::Period","desc":"TITLE\nclass Telemetry::Period\n\nSUBTITLE\nPerformance data over a period\n\n    class Telemetry::Period is Telemetry { }\n\n\nNote:  This class is a Rakudo-specific feature and not standard Raku.\n\n    # basic usage\n    use Telemetry;\n    my $t0 = Telemetry.new;\n    # execute some code\n    my $t1 = Telemetry.new;\n    my $period = $t1 - $t0;  # creates Telemetry::Period object\n    say \"Code took $period<wallclock> microseconds to execute\";\n\n\nA Telemetry::Period object contains the difference between two Telemetry\nobjects. It is generally not created by calling .new, but it can be if\nneeded. For all practical purposes, it is the same as the Telemetry object,\nbut the meaning of the values is different (and the values are generally\nmuch smaller, as they usually are the difference of two big values of the\nTelemetry objects from which it was created).","methods":[]},{"name":"Telemetry::Sampler","methods":[],"desc":"TITLE\nclass Telemetry::Sampler\n\nSUBTITLE\nTelemetry instrument pod\n\n    class Telemetry::Sampler { }\n\n\nNote:  This class is a Rakudo-specific feature and not standard Raku.\n\n    use Telemetry;\n    $*SAMPLER.set-instruments(<Usage ThreadPool>); # default setting\n\n\nOne usually does not create any Telemetry::Sampler objects: when the\nTelemetry module is loaded, a Telemetry::Sampler object is automatically\ncreated in the $*SAMPLER dynamic variable.\n\nAn object of the Telemetry::Sampler class knows about which instruments to\nuse when making a snapshot.\n\n  method new\n\n    method new(Telemetry::Sampler: @instruments --> Telemetry::Sampler:D)\n\n\nThe new method takes a list of instruments. If no instruments are\nspecified, then it will look at the RAKUDO_TELEMETRY_INSTRUMENTS\nenvironment variable to find specification of instruments. If that is not\navailable either, then Telemetry::Instrument::Usage and\nTelemetry::Instrument::ThreadPool will be assumed.\n\nInstruments can be specified by either the type object of the instrument\nclass (e.g. Telemetry::Instrument::Usage) or by a string, in which case it\nwill be automatically prefixed with \"Telemetry::Instrument::\", so \"Usage\"\nwould be the same as Telemetry::Instrument::Usage.\n\n  method set-instruments\n\n    method set-instruments(Telemetry::Sampler:D @instruments --> Nil)\n\n\nAllows one to change the instruments on an existing Instrument::Sampler\nobject. Generally only used by calling it on the $*SAMPLER dynamic\nvariable. Takes the same parameters as new, except that specifying no\ninstruments will actually remove all of the instruments, effectively\nblocking any snap taking."},{"name":"Distribution::Locally","desc":"TITLE\nclass Distribution::Locally\n\nSUBTITLE\nDistribution::Locally\n\n    role Distribution::Locally does Distribution { }\n\nProvides read access to specific files pointed at by a distributions\nmetadata, providing the Distribution#method_content method for\nDistribution::Path and Distribution::Hash.\n\n","methods":["prefix\n\nA prefix path to be used in conjuncture with the paths found in the\nmetadata.","content\n\nProvides Distribution#method_content\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt, and these paths will be prefixed with\nDistribution#method_prefix."]},{"name":"Distribution::Path","methods":["new\n\n    method new(IO::Path $prefix, IO::Path :$meta-file = IO::Path)\n\nCreates a new Distribution::Path instance from the META6.json file found at\nthe given $prefix, and from which all paths in the metadata will be\nprefixed with. :$meta-file may optionally be passed if a filename other\nthan META6.json needs to be used.","meta\n\n    method meta()\n\nReturns a Hash with the representation of the metadata.","content\n\nDistribution::Locally#method_content\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt."],"desc":"TITLE\nclass Distribution::Path\n\nSUBTITLE\nDistribution::Path\n\n        class Distribution::Path does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It requires a\nMETA6.json file at its root.\n\n"},{"name":"Distribution::Hash","desc":"TITLE\nclass Distribution::Hash\n\nSUBTITLE\nDistribution::Hash\n\n        class Distribution::Hash does Distribution::Locally { }\n\n\nA Distribution implementation backed by the filesystem. It does not require\na META6.json file, essentially providing a lower level Distribution::Path.\n\n","methods":["new\n\n    method new($hash, :$prefix)\n\nCreates a new Distribution::Hash instance from the metadata contained in\n$hash. All paths in the metadata will be prefixed with :$prefix.","meta\n\n    method meta()\n\nReturns a Hash with the representation of the metadata.","content\n\nPlease check the content method in Distribution::Locally.\n\nReturns an IO::Handle to the file represented by $name-path. $name-path is\na relative path as it would be found in the metadata such as lib/Foo.pm6 or\nresources/foo.txt."]},{"name":"X::NYI","methods":["new\n\n    method new( :$feature, :$did-you-mean, :$workaround)\n\nThis is the default constructor for X:NYI which can take three parameters\nwith obvious meanings.\n\n    class Nothing {\n        method ventured( $sub, **@args) {\n            X::NYI.new( feature => &?ROUTINE.name,\n                        did-you-mean => \"gained\",\n                        workaround => \"Implement it yourself\" ).throw;\n        }\n    }\n\n    my $nothing = Nothing.new;\n    $nothing.ventured(\"Nothing\", \"Gained\");\n\n\nIn this case, we are throwing an exception that indicates that the ventured\nroutine has not been implemented; we use the generic &?ROUTINE.name to not\ntie the exception to the method name in case it is changed later on. This\ncode effectively throws this exception\n\n    # OUTPUT:\n    # ventured not yet implemented. Sorry.\n    # Did you mean: gained?\n    # Workaround: Implement it yourself\n    #   in method ventured at NYI.p6 line 6\n    #   in block <unit> at NYI.p6 line 14\n\n\nUsing the exception properties, it composes the message that we see there.","feature\n\nReturns a Str describing the missing feature.","did-you-mean\n\nReturns a Str indicating the optional feature that is already implemented.","workaround\n\nIt helpfully shows a possible workaround for the missing feature, if it's\nbeen declared.","message\n\nReturns the message including the above properties."],"desc":"TITLE\nclass X::NYI\n\nSUBTITLE\nError due to use of an unimplemented feature\n\n    class X::NYI is Exception { }\n\nError class for unimplemented features. NYI stands for Not Yet\nImplemented.\n\nIf a Raku compiler is not yet feature complete, it may throw an X::NYI\nexception when a program uses a feature that it can detect and is somehow\nspecified is not yet implemented.\n\nA full-featured Raku compiler must not throw such exceptions, but still\nprovide the X::NYI class for compatibility reasons.\n\nA typical error message is\n\n    HyperWhatever is not yet implemented. Sorry.\n\n\n"},{"methods":[],"desc":"TITLE\nclass X::Bind\n\nSUBTITLE\nError due to binding to something that is not a variable or container\n\n    class X::Bind is Exception {}\n\nIf you write code like this:\n\n    floor(1.1) := 42;\n\n\nit dies with an X::Bind exception:\n\n    Cannot use bind operator with this left-hand side\n","name":"X::Bind"},{"name":"X::IO","desc":"TITLE\nrole X::IO\n\nSUBTITLE\nIO related error\n\n    role X::IO does X::OS {}\n\nCommon role for IO related errors.\n\nThis role does not provide any additional methods.","methods":[]},{"methods":[],"desc":"TITLE\nrole X::Syntax\n\nSUBTITLE\nSyntax error thrown by the compiler\n\n    role X::Syntax does X::Comp { }\n\nCommon role for syntax errors thrown by the compiler.","name":"X::Syntax"},{"name":"X::Temporal","desc":"TITLE\nrole X::Temporal\n\nSUBTITLE\nError related to DateTime or Date\n\n    role X::Temporal is Exception { }\n\nA common exception type for all errors related to DateTime or Date.","methods":[]},{"name":"X::AdHoc","desc":"TITLE\nclass X::AdHoc\n\nSUBTITLE\nError with a custom message\n\n    class X::AdHoc is Exception { }\n\n\nX::AdHoc is the type into which objects are wrapped if they are thrown as\nexceptions, but don't inherit from Exception.\n\nIts benefit over returning non-Exception objects is that it gives access to\nall the methods from class Exception, like backtrace and rethrow.\n\nYou can obtain the original object with the payload method.\n\n    try {\n        die [404, 'File not found']; # throw non-exception object\n    }\n    print \"Got HTTP code \",\n        $!.payload[0],          # 404\n        \" and backtrace \",\n        $!.backtrace.Str;\n\nNote that young code will often be prototyped using X::AdHoc and then later\nbe revised to use more specific subtypes of Exception. As such it is\nusually best not to explicitly rely on receiving an X::AdHoc – in many\ncases using the string returned by the .message method, which all\nExceptions must have, is preferable. Please note that we need to explicitly\ncall .Str to stringify the backtrace correctly.\n\n","methods":["payload\n\nReturns the original object which was passed to die.","Numeric\n\nDefined as\n\n    method Numeric()\n\nConverts the payload to Numeric and returns it","from-slurpy\n\nDefined as\n\n    method from-slurpy (|cap)\n\n Creates a new exception from a capture and returns it. The capture will\nhave the SlurpySentry role mixed in, so that the .message method behaves in\na different when printing the message.\n\n    try {\n        X::AdHoc.from-slurpy( 3, False, \"Not here\" ).throw\n    };\n    print $!.payload.^name; # OUTPUT: «Capture+{X::AdHoc::SlurpySentry}»\n    print $!.message;       # OUTPUT: «3FalseNot here»\n\n\nThe SlurpySentry role joins the elements of the payload, instead of\ndirectly converting them to a string."]},{"desc":"TITLE\nrole X::Comp\n\nSUBTITLE\nCommon role for compile-time errors\n\n    role X::Comp is Exception { }\n\nCommon role for compile-time errors.\n\nNote that since the backtrace of a compile time error generally shows\nroutines from the compiler, not from user-space programs, the Backtrace\nreturned from the backtrace method is not very informative. Instead the\nexception carries its own filename, line and column attributes and public\naccessors.\n\nIf an error occurs while creating an object (like a class or routine) at\ncompile time, generally the exception associated with it does not hold a\nreference to the object (for example a class would not be fully composed,\nand thus not usable). In those cases the name of the would-be-created\nobject is included in the error message instead.\n\n","methods":["filename\n\nThe filename in which the compilation error occurred","line\n\nThe line number in which the compilation error occurred.","column\n\nThe column number of location where the compilation error occurred. (Rakudo\ndoes not implement that yet)."],"name":"X::Comp"},{"desc":"TITLE\nrole X::Pod\n\nSUBTITLE\nPod related error\n\n    role X::Pod { }\n\nCommon role for Pod related errors.","methods":[],"name":"X::Pod"},{"methods":["what\n\n    method what(--> Str:D)\n\nVerbal description of the thing that was out of range (e.g. \"array index\",\n\"month\").","got\n\n    method got()\n\nReturns the object that was considered out of range (often an integer)","range\n\n    method range(--> Range:D)\n\nReturns a Range object describing the permissible range for the object\nreturned from .got.","comment\n\n    method comment(--> Str)\n\nReturns an additional comment that is included in the error message."],"desc":"TITLE\nclass X::OutOfRange\n\nSUBTITLE\nError due to indexing outside of an allowed range\n\n    class X::OutOfRange is Exception { }\n\nGeneral error when something (for example an array index) is out of an\nallowed range.\n\nFor example\n\n    say 42[2];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::OutOfRange: Index out of range. Is: 2, should be in 0..0␤»\n\nsince scalars generally act as a one-element list.\n\n","name":"X::OutOfRange"},{"name":"X::OS","desc":"TITLE\nrole X::OS\n\nSUBTITLE\nError reported by the operating system\n\n    role X::OS { has $.os-error }\n\nCommon role for all exceptions that are triggered by some error reported by\nthe operating system (failed IO, system calls, fork, memory allocation).\n\n","methods":["os-error\n\n    method os-error(--> Str:D)\n\nReturns the error as reported by the operating system."]},{"methods":[],"desc":"TITLE\nrole X::Control\n\nSUBTITLE\nRole for control exceptions\n\n    role X::Control is Exception { }\n\nThis role turns an exception into a control exception, such as CX::Next or\nCX::Take. It has got no code other than the definition.\n\nSince Rakudo 2019.03, throwing an object that mixes in this role X::Control\ncan raise a control exception which is caught by the CONTROL phaser instead\nof CATCH. This allows to define custom control exceptions.\n\nFor example, the custom CX::Oops control exception we define below:\n\n    class CX::Vaya does X::Control {\n        has $.message\n    }\n\n    sub ea {\n        CONTROL {\n            default {\n                say \"Controlled { .^name }: { .message }\"\n            }\n        }\n        CX::Vaya.new( message => \"I messed up!\" ).throw;\n\n    }\n    ea;\n    # OUTPUT: «Controlled CX::Vaya: I messed up!␤»\n","name":"X::Control"},{"desc":"TITLE\nclass X::TypeCheck\n\nSUBTITLE\nError due to a failed type check\n\n    class X::TypeCheck is Exception { }\n\nError class thrown when a type check fails.\n\n","methods":["operation\n\n    method operation(--> Str:D)\n\nReturns a string description of the operation that failed, for example\n\"assignment\", \"binding\", \"return\".","got\n\n    method got()\n\nReturns the object that failed to type check","expected\n\n    method expected()\n\nReturns the type object against which the check failed."],"name":"X::TypeCheck"},{"desc":"TITLE\nclass X::ControlFlow\n\nSUBTITLE\nError due to calling a loop control command in an ineligible scope\n\n    class X::ControlFlow is Exception { }\n\nThrown when a control flow construct (such as next or redo) is called\noutside the dynamic scope of an enclosing construct that is supposed to\ncatch them.\n\nFor example\n\n    last;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow: last without loop construct␤»\n\n","methods":["illegal\n\n    method illegal returns Str:D\n\nReturns the name of the control flow command that was called.","enclosing\n\n    method enclosing returns Str:D\n\nReturns the name of the missing enclosing construct."],"name":"X::ControlFlow"},{"name":"X::Undeclared","methods":["symbol\n\nReturns the name of the undeclared symbol","what\n\nReturns the kind of symbol that was not declared (for example variable,\ntype, routine).\n\nSince The symbol wasn't declared, the compiler sometimes has to guess (or\nrather disambiguate) what kind of symbol it encounter that wasn't declared.\nFor example if you write\n\n    say a;\n\n\nThen the disambiguation defaults to reporting a missing subroutine, even\nthough declaring a constant a = 'a' would also make the error go away."],"desc":"TITLE\nclass X::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared symbol\n\n    class X::Undeclared does X::Comp {}\n\nThrown when the compiler encounters a symbol that has not been declared,\nbut needs to be.\n\nExample\n\n    $x;\n\n\nresults in\n\n    ===SORRY!===\n    Variable $x is not declared\n\n\n"},{"name":"X::StubCode","methods":["message\n\nReturns the custom message provided to !!!, or a reasonable default if none\nwas provided."],"desc":"TITLE\nclass X::StubCode\n\nSUBTITLE\nRuntime error due to execution of stub code\n\n    class X::StubCode is Exception { }\n\nThrown when a piece of stub code (created via !!! or ...) is executed.\n\n"},{"desc":"TITLE\nclass X::NoDispatcher\n\nSUBTITLE\nError due to calling a dispatch command in an ineligible scope\n\n    class X::NoDispatcher is Exception { }\n\nWhen a redispatcher like nextsame is called without being in the dynamic\nscope of a call where a redispatch is possible, an X::NoDispatcher is\nthrown.\n\nFor example\n\n    nextsame; # In the mainline\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::NoDispatcher: nextsame is not in the dynamic scope of a dispatcher␤»\n\n","methods":["redispatcher\n\n    method redispatcher(--> Str:D)\n\nReturns the name of the redispatcher function that did not succeed."],"name":"X::NoDispatcher"},{"desc":"TITLE\nclass X::Redeclaration\n\nSUBTITLE\nCompilation error due to declaring an already declared symbol\n\n    class X::Redeclaration does X::Comp { }\n\nThrown when a symbol (variable, routine, type, parameter, ...) is\nredeclared. Note that redeclarations are generally fine in an inner scope,\nbut if the redeclaration appears in the same scope as the original\ndeclaration, it usually indicates an error and is treated as one.\n\nExamples\n\n    my $x; my $x;\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of symbol $x\n\n\nIt works with routines too:\n\n    sub f() { }\n    sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Redeclaration of routine f\n\n\nBut those are fine\n\n    my $x;\n    sub f() {\n        my $x;          # not a redeclaration,\n                        # because it's in an inner scope\n        sub f() { };    # same\n    }\n\n\n","methods":["symbol\n\nReturns the name of the symbol that was redeclared.","what\n\nReturns the kind of symbol that was redeclared. Usually symbol, but can\nalso be routine, type etc.","postfix\n\nReturns a string that is attached to the end of the error message. It\nusually explains the particular problem in more detail, or suggests way to\nfix the problem."],"name":"X::Redeclaration"},{"name":"X::Obsolete","methods":["old\n\n    method old(--> Str:D)\n\nReturns a textual description of the obsolete syntax construct","replacement\n\n    method replacement(--> Str:D)\n\nDescribes what to use instead of the obsolete syntax.","when\n\n    method when(--> Str:D)\n\nReturns a string describing the state of the language (usually \" in\nRaku\")."],"desc":"TITLE\nclass X::Obsolete\n\nSUBTITLE\nCompilation error due to use of obsolete syntax\n\n    class X::Obsolete does X::Comp { }\n\nSyntax error thrown when the user is attempting to use constructs from\nother languages.\n\nFor example\n\n    m/abc/i\n\n\ndies with\n\n    ===SORRY!===\n    Unsupported use of /i; in Raku please use :i\n\n\n"},{"methods":["file\n\nDefined as:\n\n    method file(Backtrace::Frame:D --> Str)\n\nReturns the file name.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.file;","line\n\nDefined as:\n\n    method line(Backtrace::Frame:D --> Int)\n\nReturns the line number (line numbers start counting from 1).\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.line;","code\n\nDefined as:\n\n    method code(Backtrace::Frame:D)\n\nReturns the code object into which .file and .line point, if available.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.code;","subname\n\nDefined as:\n\n    method subname(Backtrace::Frame:D --> Str)\n\nReturns the name of the enclosing subroutine.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.subname;","is-hidden\n\nDefined as:\n\n    method is-hidden(Backtrace::Frame:D --> Bool:D)\n\nReturns True if the frame is marked as hidden with the is\nhidden-from-backtrace trait.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-hidden;","is-routine\n\nDefined as:\n\n    method is-routine(Backtrace::Frame:D --> Bool:D)\n\nReturn True if the frame points into a routine (and not into a mere\nBlock).\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-routine;","is-setting\n\nDefined as:\n\n    method is-setting(Backtrace::Frame:D --> Bool:D)\n\nReturns True if the frame is part of a setting.\n\n    my $bt = Backtrace.new;\n    my $btf = $bt[0];\n    say $btf.is-setting; # OUTPUT: «True␤»"],"desc":"TITLE\nclass Backtrace::Frame\n\nSUBTITLE\nSingle frame of a Backtrace\n\n    class Backtrace::Frame { }\n\nA single backtrace frame. It identifies a location in the source code.\n\n","name":"Backtrace::Frame"},{"name":"Pod::Block::Declarator","desc":"TITLE\nclass Pod::Block::Declarator\n\nSUBTITLE\nDeclarator block in a Pod document\n\n    class Pod::Block::Declarator is Pod::Block { }\n\nClass for a declarator Pod block\n\n","methods":["leading\n\n    method leading(--> Str)\n\nReturns the leading Pod comment attached to the declarator","trailing\n\n    method trailing(--> Str)\n\nReturns the trailing Pod comment attached to the declarator","WHEREFORE\n\n    method WHEREFORE(--> Mu)\n\nReturns the code object or metaobject to which the Pod block is attached\nto"]},{"name":"Pod::Block::Code","methods":["allowed\n\n    method allowed(--> Positional:D)\n\nReturns a list of formatting codes that are allowed inside the code block."],"desc":"TITLE\nclass Pod::Block::Code\n\nSUBTITLE\nVerbatim code block in a Pod document\n\n    class Pod::Block::Code is Pod::Block { }\n\nClass for a code (verbatim) Pod block.\n\n"},{"methods":["caption\n\n    method caption(--> Str:D)\n\nReturns the associated caption of the table.","headers\n\n    method headers(--> Positional:D)\n\nReturns a list of table headers. If no headers have been defined the list\nis empty."],"desc":"TITLE\nclass Pod::Block::Table\n\nSUBTITLE\nTable in a Pod document\n\n    class Pod::Block::Table is Pod::Block { }\n\nClass for a table in a Pod document.\n\n","name":"Pod::Block::Table"},{"name":"Pod::Block::Named","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the block."],"desc":"TITLE\nclass Pod::Block::Named\n\nSUBTITLE\nNamed block in a Pod document\n\n    class Pod::Block::Named is Pod::Block { }\n\nClass for a named Pod block. For example\n\n    =begin MySection\n    ...\n    =end MySection\n\n\ncreates a Pod::Block::Named with name MySection.\n\n"},{"name":"Pod::Block::Para","methods":[],"desc":"TITLE\nclass Pod::Block::Para\n\nSUBTITLE\nParagraph in a Pod document\n\n    class Pod::Block::Para is Pod::Block { }\n\nClass for a Pod paragraph."},{"name":"Pod::Block::Comment","desc":"TITLE\nclass Pod::Block::Comment\n\nSUBTITLE\nComment in a Pod document\n\n    class Pod::Block::Comment is Pod::Block { }\n\nClass for a Pod comment.","methods":[]},{"desc":"TITLE\nclass CompUnit::Repository::Installation\n\nSUBTITLE\nCompUnit::Repository::Installation\n\n    class CompUnit::Repository::Installation\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository::Installable\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem, but uses an\ninternal storage format to:\n\n  * Handle case sensitivity issues on filesystems that may conflict as a\n  CompUnit::Repository::FileSystem.\n\n  * Handle allowable filename issues (e.g. unicode) on filesystems that don't\n  support them.\n\n  * Allow multiple distributions with the same name, but with different ver\n  and/or auth and/or api values, to be installed and separately accessible in\n  a single repository.\n\n  * Enable faster module loading by providing module precompilation.\n\nBecause of the internal storage format the usual way to add a distribution\nis not by copying files but by calling\nCompUnit::Repository::Installation#method_install.\n\n","methods":["install\n\n    method install(Distribution $distribution, Bool :$force)\n\nCopies modules into a special location so that they can be loaded\nafterwards.\n\n:$force will allow installing over an existing distribution that has the\nsame name, auth, api, and ver. Otherwise such a situation will result in\nFailure.\n\n    my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n    my $dist = Distribution::Path.new(...);\n    $inst-repo.install($dist);","uninstall\n\n    method uninstall(Distribution $distribution)\n\nRemoves the $distribution from the repository. $distribution should be\nobtained from the repository it is being removed from:\n\n    my $inst-repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n    my $dist = $inst-repo.candidates(\"Acme::Unused\").head;\n    $inst-repo.uninstall($dist);","candidates\n\n    multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    my $inst-repo-path = CompUnit::RepositoryRegistry.repository-for-name(\"perl\").prefix;\n    my $inst-repo = CompUnit::Repository::Installation.new(prefix => $inst-repo-path);\n    my $dist = $inst-repo.candidates(\"Test\").head;\n    say \"Test version: \" ~ $dist.meta<ver>; # OUTPUT: «6.d␤»","files\n\n    multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming Zef is installed to the default location...\n    my $repo = CompUnit::RepositoryRegistry.repository-for-name(\"site\");\n\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","resolve\n\n    method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec.","need\n\n    method need(\n        CompUnit::DependencySpecification $spec,\n        CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n        CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n        --> CompUnit:D)\n\n\nLoads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec.","load\n\n    method load(IO::Path:D $file --> CompUnit:D)\n\nLoad the $file and return a CompUnit object representing it.","loaded\n\n    method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded.","short-id\n\n    method short-id()\n\nReturns the repo short-id, which for this repository is inst."],"name":"CompUnit::Repository::Installation"},{"name":"CompUnit::Repository::FileSystem","desc":"TITLE\nclass CompUnit::Repository::FileSystem\n\nSUBTITLE\nCompUnit::Repository::FileSystem\n\n    class CompUnit::Repository::FileSystem\n        does CompUnit::Repository::Locally\n        does CompUnit::Repository\n        { }\n\n\nA CompUnit::Repository implementation backed by the filesystem typically\nused in development situations. This is what is used by -I . / -I lib\n(which are actually -I file#. and -I file#lib) or use lib \".\" / use lib\n\"lib\". Unlike CompUnit::Repository::Installation, this represents a single\ndistribution.\n\n","methods":["candidates\n\n    multi method candidates(Str:D $name, :$auth, :$ver, :$api)\n    multi method candidates(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that contain a module matching the specified\n$name, auth, ver, and api.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    with $repo.candidates(\"Zef\").head -> $dist {\n        say \"Zef version: \" ~ $dist.meta<version>;\n    }\n    else {\n        say \"No candidates for 'Zef' found\";\n    }","files\n\n    multi method files(Str:D $name, :$auth, :$ver, :$api)\n    multi method files(CompUnit::DependencySpecification $spec)\n\nReturn all distributions that match the specified auth ver and api, and\ncontains a non-module file matching the specified $name.\n\n    # assuming one is cloned into the zef git repository...\n    my $repo = CompUnit::Repository::FileSystem.new(prefix => $*CWD);\n    say $repo.files('bin/zef', :ver<419.0+>).head.<name>              // \"Nada\"; # OUTPUT: «Nada␤»\n    say $repo.files('resources/config.txt', :ver<419.0+>).head.<name> // \"Nada\"; # OUTPUT: «Nada␤»\n\n    say $repo.files('bin/zef', :ver<0.4.0+>).head.<name>;                        # OUTPUT: «zef␤»\n    say $repo.files('resources/config.txt', :ver<0.4.0+>).head.<name>;           # OUTPUT: «zef␤»","resolve\n\n    method resolve(CompUnit::DependencySpecification $spec --> CompUnit:D)\n\nReturns a CompUnit mapped to the highest version distribution matching\n$spec from the first repository in the repository chain that contains any\nversion of a distribution matching $spec.","need\n\n        method need(\n            CompUnit::DependencySpecification $spec,\n            CompUnit::PrecompilationRepository $precomp = self.precomp-repository(),\n            CompUnit::PrecompilationStore :@precomp-stores = self!precomp-stores(),\n            --> CompUnit:D)\n\n\nLoads and returns a CompUnit which is mapped to the highest version\ndistribution matching $spec from the first repository in the repository\nchain that contains any version of a distribution matching $spec.","load\n\n    method load(IO::Path:D $file --> CompUnit:D)\n\nLoad the $file and return a CompUnit object representing it.","loaded\n\n    method loaded(--> Iterable:D)\n\nReturns all CompUnits this repository has loaded.","short-id\n\n    method short-id()\n\nReturns the repo short-id, which for this repository is file."]},{"desc":"TITLE\nclass IO::Socket::INET\n\nSUBTITLE\nTCP Socket\n\n    class IO::Socket::INET does IO::Socket {}\n\n\nIO::Socket::INET provides TCP sockets, both the server and the client\nside.\n\nFor UDP support, please see IO::Socket::Async.\n\nHere is an example of a very simplistic \"echo\" server that listens on\nlocalhost, port 3333:\n\n    my $listen = IO::Socket::INET.new( :listen,\n                                       :localhost<localhost>,\n                                       :localport(3333) );\n    loop {\n        my $conn = $listen.accept;\n        try {\n            while my $buf = $conn.recv(:bin) {\n                $conn.write: $buf;\n            }\n        }\n        $conn.close;\n\n        CATCH {\n              default { .payload.say;      }\n        }\n\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    my $conn = IO::Socket::INET.new( :host<localhost>,\n                                     :port(3333) );\n    $conn.print: 'Hello, Raku';\n    say $conn.recv;\n    $conn.close;\n\n\nPlease bear in mind that this is a synchronous connection; an attempt by\nany of the nodes to write without the other reading will produce an Could\nnot receive data from socket: Connection reset by peer error.\n\n","methods":["new\n\n    multi method new(\n            :$host,\n            :$port,\n            :$family = PF_INET,\n            :$encoding = 'utf-8',\n            :$nl-in = \"\\r\\n\",\n        --> IO::Socket::INET:D)\n    multi method new(\n            :$localhost,\n            :$localport,\n            :$family = PF_INET,\n            :$listen,\n            :$encoding = 'utf-8',\n            :$nl-in = \"\\r\\n\",\n        --> IO::Socket::INET:D)\n\n\nCreates a new socket.\n\nIf :$listen is True, creates a new socket that listen on :$localhost (which\ncan be an IP address or a domain name) on port :$localport; in other words\nthe :$listen flag determines the server mode of the socket. Otherwise\n(i.e., :$listen is False), the new socket opens immediately a connection to\n:$host on port :$port.\n\n:$family defaults to PF_INET constant for IPv4, and can be set to PF_INET6\nconstant for IPv6.\n\nFor text operations (such as #method lines and #method get), :$encoding\nspecifies the encoding, and :$nl-in determines the character(s) that\nseparate lines."],"name":"IO::Socket::INET"},{"name":"IO::Socket::Async","methods":["The IO::Socket::Async cannot be constructed directly, either connect or\nlisten (for TCP connections) or udp or bind-udp (for UDP data) should be\nused to create a client or a server respectively.","connect\n\n    method connect(Str $host, Int $port --> Promise)\n\nAttempts to connect to the TCP server specified by $host and $port,\nreturning a Promise that will either be kept with a connected\nIO::Socket::Async or broken if the connection cannot be made.","listen\n\n    method listen(Str $host, Int $port --> Supply)\n\nCreates a listening socket on the specified $host and $port, returning a\nSupply to which the accepted client IO::Socket::Asyncs will be emitted.\nThis Supply should be tapped start listening for client connections. You\ncan use $port = 0 if you want the operating system to find one for you.\n\nTo close the underlying listening socket, the Tap returned by tapping the\nlistener should be closed.\n\nFor example, when using tap:\n\n    my $listener = IO::Socket::Async.listen('127.0.0.1', 8080);\n    my $tap = $listener.tap({ ... });\n\n    # When you want to close the listener\n    $tap.close;\n\n\nOr when using whenever:\n\n    my $listener = IO::Socket::Async.listen('127.0.0.1', 5000);\n    my $tap;\n    react {\n        $tap = do whenever $listener -> $conn { ... }\n    }\n\n    # When you want to close the listener, you can still use:\n    $tap.close;","udp\n\n    method udp(IO::Socket::Async:U: :$broadcast --> IO::Socket::Async)\n\nReturns an initialized IO::Socket::Async client object that is configured\nto send UDP messages using print-to or write-to. The :broadcast adverb will\nset the SO_BROADCAST option which will allow the socket to send packets to\na broadcast address.","bind-udp\n\n    method bind-udp(IO::Socket::Async:U: Str() $host, Int() $port, :$broadcast --> IO::Socket::Async)\n\nThis returns an initialized IO::Socket::Async server object that is\nconfigured to receive UDP messages sent to the specified $host and $port\nand is equivalent to listen for a TCP socket. The :broadcast adverb can be\nspecified to allow the receipt of messages sent to the broadcast address.","print\n\n    method print(Str $str --> Promise)\n\nAttempt to send $str on the IO::Socket::Async that will have been obtained\nindirectly via connect or listen, returning a Promise that will be kept\nwith the number of bytes sent or broken if there was an error sending.","print-to\n\n    method print-to(IO::Socket::Async:D: Str() $host, Int() $port, Str() $str --> Promise)\n\nThis is the equivalent of print for UDP sockets that have been created with\nthe udp method, it will try send a UDP message of $str to the specified\n$host and $port returning a Promise that will be kept when the data is\nsuccessfully sent or broken if it was unable to send the data. In order to\nsend to a broadcast address the :broadcast flag must have been specified\nwhen the socket was created.","write\n\n    method write(Blob $b --> Promise)\n\nThis method will attempt to send the bytes in $b on the IO::Socket::Async\nthat will have been obtained indirectly via connect or listen, returning a\nPromise that will be kept with the number of bytes sent or broken if there\nwas an error sending.","write-to\n\n    method write-to(IO::Socket::Async:D: Str() $host, Int() $port, Blob $b --> Promise)\n\nThis is the equivalent of write for UDP sockets that have been created with\nthe udp method. It will try send a UDP message comprised of the bytes in\nthe Blob $b to the specified $host and $port returning a Promise that will\nbe kept when the data is successfully sent or broken if it was unable to\nsend the data. In order to send to a broadcast address the :broadcast flag\nmust have been specified when the socket was created.","Supply\n\n    method Supply(:$bin, :$buf = buf8.new --> Supply)\n\nReturns a Supply which can be tapped to obtain the data read from the\nconnected IO::Socket::Async as it arrives. By default the data will be\nemitted as characters, but if the :bin adverb is provided a Buf of bytes\nwill be emitted instead, optionally in this case you can provide your own\nBuf with the :buf named parameter.\n\nA UDP socket in character mode will treat each packet as a complete message\nand decode it. In the event of a decoding error, the Supply will quit.\n\nOn the other hand, a TCP socket treats the incoming packets as part of a\nstream, and feeds the incoming bytes into a streaming decoder. It then\nemits whatever characters the decoder considers ready. Since strings work\nat grapheme level in Raku, this means that only known complete graphemes\nwill be emitted. For example, if the UTF-8 encoding were being used and the\nlast byte in the packet decoded to a, this would not be emitted since the\nnext packet may include a combining character that should form a single\ngrapheme together with the a. Control characters (such as \\n) always serve\nas grapheme boundaries, so any text-based protocols that use newlines or\nnull bytes as terminators will not need special consideration. A TCP socket\nwill also quit upon a decoding error.","close\n\n    method close()\n\nClose the connected client IO::Socket::Async which will have been obtained\nfrom the listen Supply or the connect Promise.\n\nIn order to close the underlying listening socket created by listen you can\nclose the Tap. See listen for examples.","socket-host\n\n    method socket-host(--> Str)\n\nReturns the IP address of the local end of this socket.","peer-host\n\n    method peer-host(--> Str)\n\nReturns the IP address of the remote end of this socket.","socket-port\n\n    method socket-port(--> Int)\n\nReturns the port of the local end of this socket.","peer-port\n\n    method peer-port(--> Int)\n\nReturns the port of the remote end of this socket.","native-descriptor\n\n    method native-descriptor(--> Int)\n\nReturns the file descriptor of this socket."],"desc":"TITLE\nclass IO::Socket::Async\n\nSUBTITLE\nAsynchronous socket in TCP or UDP\n\n    class IO::Socket::Async {}\n\nIO::Socket::Async|/type/IO::Socket::Async provides asynchronous sockets,\nfor both the server and the client side.\n\nHere is a simple example of a simple \"hello world\" HTTP server that listens\non port 3333:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3333) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n        }\n        CATCH {\n            default {\n                say .^name, ': ', .Str;\n                say \"handled in $?LINE\";\n            }\n        }\n    }\n\n\nAnd a client that connects to it, and prints out what the server answers:\n\n    await IO::Socket::Async.connect('127.0.0.1', 3333).then( -> $promise {\n        given $promise.result {\n            .print(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\n\");\n            react {\n                whenever .Supply() -> $v {\n                    $v.print;\n                    done;\n                }\n            }\n            .close;\n        }\n    });\n\n\nIO::Socket::Async can also send and receive UDP messages An example server\nthat outputs all the data it receives would be:\n\n    my $socket = IO::Socket::Async.bind-udp('localhost', 3333);\n\n    react {\n        whenever $socket.Supply -> $v {\n            if $v.chars > 0 {\n                say $v;\n            }\n        }\n    }\n\n\nAnd an associated client might be:\n\n    my $socket = IO::Socket::Async.udp();\n    await $socket.print-to('localhost', 3333, \"Hello, Raku!\");\n\n\nThe CATCH phaser can be included to deal specifically with problems that\nmight occur in this kind of sockets, such as a port being already taken:\n\n    react {\n        whenever IO::Socket::Async.listen('0.0.0.0', 3000) -> $conn {\n            whenever $conn.Supply.lines -> $line {\n                $conn.print: qq:heredoc/END/;\n                    HTTP/1.1 200 OK\n                    Content-Type: text/html; charset=UTF-8\n                    Content-Encoding: UTF-8\n\n                    <html>\n                    <body>\n                        <h1>Hello World!</h1>\n                        <p>{ $line }</p>\n                    </body>\n                    </html>\n                    END\n                $conn.close;\n            }\n            QUIT {\n                default {\n                    say .^name, '→ ', .Str;\n                    say \"handled in line $?LINE\";\n                }\n            }\n        }\n\n    }\n    # Will print this, if address 3000 is already in use:\n    # X::AdHoc→ address already in use\n    # handled in 23\n\n\nMain difference with using other phasers such as CATCH is that this kind of\nexception will be caught within the whenever block and will put exiting the\nprogram, or not, under your control.\n\n"},{"name":"IO::Spec::Cygwin","methods":["abs2rel\n\nDefined as:\n\n    method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)\n\nReturns a string that represents $path, but relative to $base path. Both\n$path and $base may be relative paths. $base defaults to $*CWD. Uses\nIO::Spec::Win32's semantics.","canonpath\n\nDefined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem.\n\n    IO::Spec::Cygwin.canonpath(｢C:\\foo\\\\..\\bar\\..\\ber｣).say;\n    # OUTPUT: «C:/foo/../bar/../ber␤»\n\n    IO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Cygwin.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»","catdir\n\nDefined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Cygwin.catdir(<foo/bar ber perl>).say;\n    # OUTPUT: «foo/bar/ber/perl␤»","catpath\n\nDefined as:\n\n    method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nSame as IO::Spec::Win32.catpath, except will also change all backslashes to\nslashes at the end:\n\n    IO::Spec::Cygwin.catpath('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir/foo.txt␤»\n\n    IO::Spec::Cygwin.catpath('C:', '/some/dir', '').say;\n    # OUTPUT: «C:/some/dir␤»\n\n    IO::Spec::Cygwin.catpath('', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «/some/dir/foo.txt␤»\n\n    IO::Spec::Cygwin.catpath('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","is-absolute\n\nDefined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\") or backslash (\"\\\"),\neven if they have combining character on them, optionally preceded by a\nvolume:\n\n    say IO::Spec::Cygwin.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\n    say IO::Spec::Cygwin.is-absolute: \"bar\";         # OUTPUT: «False␤»","join\n\nDefined as:\n\n    method join(|c)\n\nSame as IO::Spec::Win32.join, except replaces backslashes with slashes in\nthe final result.","rel2abs\n\nDefined as:\n\n    method rel2abs(|c --> List:D)\n\nSame as IO::Spec::Win32.rel2abs, except replaces backslashes with slashes\nin the final result.","split\n\nDefined as:\n\n    method split(|c --> List:D)\n\nSame as IO::Spec::Win32.split, except replaces backslashes with slashes in\nall the values of the final result.","splitpath\n\nDefined as:\n\n    method splitpath(|c --> List:D)\n\nSame as IO::Spec::Win32.splitpath, except replaces backslashes with slashes\nin all the values of the final result.","tmpdir\n\nDefined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found."],"desc":"TITLE\nclass IO::Spec::Cygwin\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Cygwin\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec will be available from the $*SPEC variable for a\nperl running on Cygwin .\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n"},{"methods":["canonpath\n\nDefined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem, so no symlinks are followed.\n\n    IO::Spec::QNX.canonpath(\"foo//../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::QNX.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::QNX.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»"],"desc":"TITLE\nclass IO::Spec::QNX\n\nSUBTITLE\nPlatform specific operations on file and directory paths QNX\n\n    class IO::Spec::QNX is IO::Spec { }\n\nThis sub-class of IO::Spec specific to QNX will be available via $*SPEC if\nthe perl is running on QNX.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n","name":"IO::Spec::QNX"},{"name":"IO::Spec::Unix","methods":["abs2rel\n\nDefined as:\n\n    method abs2rel(IO::Path:D $path, IO::Path:D $base = $*CWD --> Str:D)\n\nReturns a string that represents $path, but relative to $base path. Both\n$path and $base may be relative paths. $base defaults to $*CWD.","basename\n\nDefined as:\n\n    method basename(Str:D $path --> Str:D)\n\nTakes a path as a string and returns a possibly-empty portion after the\nlast slash:\n\n    IO::Spec::Unix.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Unix.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\n    IO::Spec::Unix.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»","canonpath\n\nDefined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem, so no symlinks are followed.\n\n    IO::Spec::Unix.canonpath(\"foo//../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Unix.canonpath(\"foo///./../bar/../ber\").say;\n    # OUTPUT: «foo/../bar/../ber␤»\n\n    IO::Spec::Unix.canonpath(\"foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «ber␤»","catdir\n\nDefined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Unix.catdir(<foo/bar ber perl>).say; # OUTPUT: «foo/bar/ber/perl␤»","catfile\n\nAlias for catdir.","catpath\n\nDefined as:\n\n    method catpath ($, Str:D $part1, Str:D $part2 --> Str:D)\n\nTakes two path fragments and concatenates them, adding or removing a path\nseparator, if necessary. The first argument is ignored (it exists to\nmaintain consistent interface with other IO::Spec|/type/IO::Spec types for\nsystems that have volumes).\n\n    IO::Spec::Unix.catpath($, 'some/dir', 'and/more').say;\n    # OUTPUT: «some/dir/and/more␤»","curdir\n\nDefined as:\n\n    method curdir()\n\nReturns a string representing the current directory:\n\n    say '.' eq $*SPEC.curdir; # OUTPUT: «True␤»","curupdir\n\nDefined as:\n\n    method curupdir()\n\nReturns a none Junction of strings representing the current directory and\nthe \"one directory up\":\n\n    say $*SPEC.curupdir;                  # OUTPUT: «none(., ..)␤»\n    my @dirs = <. foo .. bar>;\n    say @dirs.grep(* eq $*SPEC.curupdir); # OUTPUT: «(foo bar)␤»\n\n\nNeither foo nor bar are equal to the representation of the current or\nparent directory, that is why they are returned by grep.","devnull\n\nDefined as:\n\n    method devnull(--> Str:D)\n\nReturns the string \"/dev/null\" representing the \"Null device\":\n\n    $*SPEC.devnull.IO.spurt: \"foo bar baz\";","dir-sep\n\nDefined as:\n\n    method dir-sep(--> Str:D)\n\nReturns the string \"/\" representing canonical directory separator\ncharacter.\n\n    IO::Spec::Unix.dir-sep.say; # OUTPUT: «/␤»","extension\n\nNOTE: Most users would want to use the higher-level routine\nIO::Path.extension instead of this lower-level version.\n\nDefined as:\n\n    method extension(Str:D $path --> Str:D)\n\nTakes a string representing a base name and returns the characters after\nthe last dot (\".\"), or empty string if no dots are present. The routine\nmakes no attempt to detect path separators and will return everything after\nthe last dot.\n\n    $*SPEC.extension('foo.'      ).perl.say;  # OUTPUT: «\"\"␤»\n    $*SPEC.extension('foo.txt'   ).perl.say;  # OUTPUT: «\"txt\"␤»\n    $*SPEC.extension('foo.tar.gz').perl.say;  # OUTPUT: «\"gz\"␤»\n    $*SPEC.extension('foo'       ).perl.say;  # OUTPUT: «\"\"␤»\n    $*SPEC.extension('bar.foo/foo').perl.say; # OUTPUT: «\"foo/foo\"␤»","is-absolute\n\nDefined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\"), even if it has\ncombining character on it:\n\n    say IO::Spec::Unix.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Unix.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Unix.is-absolute: \"bar\";         # OUTPUT: «False␤»","join\n\nDefined as:\n\n    method join ($, Str:D $dir, Str:D $file --> Str:D)\n\nSimilar to catpath, takes two path fragments and concatenates them, adding\nor removing a path separator, if necessary, except it will return just\n$file if both $dir and $file are string '/' or if $dir is the string '.'.\nThe first argument is ignored (it exists to maintain consistent interface\nwith other IO::Spec types for systems that have volumes).\n\n    IO::Spec::Unix.join($, 'foo', 'bar').say; # OUTPUT: «foo/bar␤»\n    IO::Spec::Unix.join($, '/', '/').say;     # OUTPUT: «/␤»\n    IO::Spec::Unix.join($, '.', 'foo').say;   # OUTPUT: «foo␤»\n    say $*SPEC.join(True,\".\",\"/foo\");         # OUTPUT: «/foo␤»","path\n\nDefined as:\n\n    method path(--> Seq:D)\n\nSplits the value of %*ENV<PATH> on colons (\":\"), replaces empty parts with\n\".\", and returns a Seq with each of the resultant parts. Returns an empty\nSeq if %*ENV<PATH> is not set or is an empty string.\n\n    %*ENV<PATH> = 'foo:bar/ber::foo:';\n    IO::Spec::Unix.path.perl.say;\n    # OUTPUT: «(\"foo\", \"bar/ber\", \".\", \"foo\", \".\").Seq␤»","rel2abs\n\nDefined as:\n\n    method rel2abs(Str() $path, $base = $*CWD --> Str:D)\n\nReturns a string representing $path converted to absolute path, based at\n$base, which defaults to $*CWD. If $base is not an absolute path, it will\nbe made absolute relative to $*CWD, unless $*CWD and $base are the same.\n\n    say $*CWD;                                  # OUTPUT: «\"/home/camelia\".IO␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo';          # OUTPUT: «/home/camelia/foo␤»\n    say IO::Spec::Unix.rel2abs: './';           # OUTPUT: «/home/camelia␤»\n    say IO::Spec::Unix.rel2abs: 'foo/../../';   # OUTPUT: «/home/camelia/foo/../..␤»\n    say IO::Spec::Unix.rel2abs: '/foo/';        # OUTPUT: «/foo␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo', 'bar';   # OUTPUT: «/home/camelia/bar/foo␤»\n    say IO::Spec::Unix.rel2abs: './', '/bar';   # OUTPUT: «/bar␤»\n    say IO::Spec::Unix.rel2abs: '/foo/', 'bar'; # OUTPUT: «/foo␤»\n\n    say IO::Spec::Unix.rel2abs: 'foo/../../', 'bar';\n    # OUTPUT: «/home/camelia/bar/foo/../..␤»","rootdir\n\nDefined as:\n\n    method rootdir(--> Str:D)\n\nReturns string '/', representing root directory.","split\n\nDefined as:\n\n    method split(Cool:D $path --> List:D)\n\nSplits the given $path into \"volume\", \"dirname\", and \"basename\" and returns\nthe result as a List of three Pairs, in that order. The \"volume\" is always\nan empty string and exists for consistency with other IO::Spec classes.\n\n    IO::Spec::Unix.split('C:/foo/bar.txt').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"C:/foo\"), :basename(\"bar.txt\"))␤»\n\n    IO::Spec::Unix.split('/foo/').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\n    IO::Spec::Unix.split('///').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"/\"))␤»\n\n    IO::Spec::Unix.split('./').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Unix.split('.').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Unix.split('').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»","splitdir\n\nDefined as:\n\n    method splitdir(Cool:D $path --> List:D)\n\nSplits the given $path on slashes.\n\n    IO::Spec::Unix.splitdir('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\\\\foo\", \"bar.txt\")␤»\n\n    IO::Spec::Unix.splitdir('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"foo\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('///').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('./').perl.say;\n    # OUTPUT: «(\".\", \"\")␤»\n\n    IO::Spec::Unix.splitdir('.').perl.say;\n    # OUTPUT: «(\".\",)␤»\n\n    IO::Spec::Unix.splitdir('').perl.say;\n    # OUTPUT: «(\"\",)␤»","splitpath\n\nDefined as:\n\n    method splitpath(Cool:D $path, :$nofile --> List:D)\n\nSplits the given $path into a list of 3 strings: volume, dirname, and file.\nThe volume is always an empty string, returned for API compatibility with\nother IO::Spec types. If :$nofile named argument is set to True, the\ncontent of the file string is undefined and should be ignored; this is a\nmeans to get a performance boost, as implementations may use faster code\npath when file is not needed.\n\n    IO::Spec::Unix.splitpath('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"\", \"C:\\\\foo/\", \"bar.txt\")␤»\n\n    IO::Spec::Unix.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"C:\\\\foo/bar.txt\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('/foo/', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('///').perl.say;\n    # OUTPUT: «(\"\", \"///\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('./').perl.say;\n    # OUTPUT: «(\"\", \"./\", \"\")␤»\n\n    IO::Spec::Unix.splitpath('.').perl.say;\n    # OUTPUT: «(\"\", \"\", \".\")␤»\n\n    IO::Spec::Unix.splitpath('').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\")␤»","tmpdir\n\nDefined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found.","updir\n\nDefined as:\n\n    method updir()\n\nReturns a string representing the directory one up from current:\n\n    say '..' eq $*SPEC.updir; # OUTPUT: «True␤»"],"desc":"TITLE\nclass IO::Spec::Unix\n\nSUBTITLE\nPlatform specific operations on file and directory paths for POSIX\n\n    class IO::Spec::Unix is IO::Spec  { }\n\nOn object of this type is available via the variable $*SPEC if the Raku\ninterpreter is running on a Unix-like platform.\n\nThe IO::Spec::* classes provide low-level path operations. Unless you're\ncreating your own high-level path manipulation routines, you don't need to\nuse IO::Spec::*. Use IO::Path instead.\n\nBeware that no special validation is done by these classes (e.g. check\nwhether path contains a null character). It is the job of higher-level\nclasses, like IO::Path, to do that.\n\n"},{"name":"IO::Spec::Win32","desc":"TITLE\nclass IO::Spec::Win32\n\nSUBTITLE\nPlatform specific operations on file and directory paths for Windows\n\n    class IO::Spec::Win32 is IO::Spec { }\n\nObjects of this class are used not directly but as a sub-class specific to\nthe platform Raku is running on via the $*SPEC variable, which will contain\nan object of the appropriate type.\n\nNOTE: the IO::Spec::* classes provide low-level path operations. Unless\nyou're creating your own high-level path manipulation routines, you don't\nneed to use IO::Spec::*. Use IO::Path instead.\n\nNOTE2: no special validation is done by these classes (e.g. check whether\npath contains a null character). It is the job of higher-level classes,\nlike IO::Path, to do that.\n\n","methods":["basename\n\nDefined as:\n\n    method basename(Str:D $path --> Str:D)\n\nTakes a path as a string and returns a possibly-empty portion after the\nlast slash or backslash:\n\n    IO::Spec::Win32.basename(\"foo/bar/\") .perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Win32.basename(\"foo/bar\\\\\").perl.say; # OUTPUT: «\"\"␤»\n    IO::Spec::Win32.basename(\"foo/bar/.\").perl.say; # OUTPUT: «\".\"␤»\n    IO::Spec::Win32.basename(\"foo/bar\")  .perl.say; # OUTPUT: «\"bar\"␤»","canonpath\n\nDefined as:\n\n    method canonpath(Str() $path, :$parent --> Str:D)\n\nReturns a string that is a canonical representation of $path. If :$parent\nis set to true, will also clean up references to parent directories. NOTE:\nthe routine does not access the filesystem.\n\n    IO::Spec::Win32.canonpath(\"C:/foo//../bar/../ber\").say;\n    # OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\n    IO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\").say;\n    # OUTPUT: «C:\\foo\\..\\bar\\..\\ber␤»\n\n    IO::Spec::Win32.canonpath(\"C:/foo///./../bar/../ber\", :parent).say;\n    # OUTPUT: «C:\\ber␤»","catdir\n\nDefined as:\n\n    method catdir (*@parts --> Str:D)\n\nConcatenates multiple path fragments and returns the canonical\nrepresentation of the resultant path as a string. The @parts are Str\nobjects and are allowed to contain path separators.\n\n    IO::Spec::Win32.catdir(<foo/bar ber perl>).say;\n    # OUTPUT: «foo\\bar\\ber\\perl␤»","catfile\n\nAlias for catdir.","catpath\n\nDefined as:\n\n    method catpath (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nConcatenates a path from given volume, a chain of directories, and file. An\nempty string can be given for any of the three arguments. No attempt to\nmake the path canonical is made. Use canonpath for that purpose.\n\n    IO::Spec::Win32.catpath('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir\\foo.txt␤»\n\n    IO::Spec::Win32.catpath('C:', '/some/dir', '').say;\n    # OUTPUT: «C:/some/dir␤»\n\n    IO::Spec::Win32.catpath('', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «/some/dir\\foo.txt␤»\n\n    IO::Spec::Win32.catpath('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","devnull\n\nDefined as:\n\n    method devnull(--> Str:D)\n\nReturns the string \"nul\" representing the \"Null device\":\n\n    $*SPEC.devnull.IO.spurt: \"foo bar baz\";","dir-sep\n\nDefined as:\n\n    method dir-sep(--> Str:D)\n\nReturns the string ｢\\｣ representing canonical directory separator\ncharacter.\n\n    IO::Spec::Win32.dir-sep.say; # OUTPUT: «\\␤»","is-absolute\n\nDefined as:\n\n    method is-absolute(Str:D $path --> Bool:D)\n\nReturns True if the $path starts with a slash (\"/\") or backslash (\"\\\"),\neven if they have combining character on them, optionally preceded by a\nvolume:\n\n    say IO::Spec::Win32.is-absolute: \"/foo\";        # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: \"/\\x[308]foo\"; # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: ｢C:\\foo｣;      # OUTPUT: «True␤»\n    say IO::Spec::Win32.is-absolute: \"bar\";         # OUTPUT: «False␤»","join\n\nDefined as:\n\n    method join (Str:D $volume, Str:D $dir, Str:D $file --> Str:D)\n\nSimilar to catpath, takes two path fragments and concatenates them, adding\nor removing a path separator, if necessary, except it will return just\n$file if both $dir and $file are string '/' or if $dir is the string '.'.\nThe first argument is ignored (it exists to maintain consistent interface\nwith other IO::Spec types for systems that have volumes).\n\n    IO::Spec::Win32.join('C:', '/some/dir', 'foo.txt').say;\n    # OUTPUT: «C:/some/dir\\and/more␤»\n\n    IO::Spec::Win32.join('C:', '.', 'foo.txt').say;\n    # OUTPUT: «C:foo.txt␤»\n\n    IO::Spec::Win32.join('C:', ｢\\｣, '/').say;\n    # OUTPUT: «C:\\␤»\n\n    IO::Spec::Win32.join('//server/share', ｢\\｣, '/').say;\n    # OUTPUT: «//server/share␤»\n\n    IO::Spec::Win32.join('E:', '', 'foo.txt').say;\n    # OUTPUT: «E:foo.txt␤»","path\n\nDefined as:\n\n    method path(--> Seq:D)\n\nSplits the value of %*ENV<PATH> (or %*ENV<Path> if the former is not set)\non semicolons (\";\") and returns a Seq with each of the resultant parts,\nalways adding element \".\" to the head. Removes all double quotes (\") it\nfinds.\n\n    %*ENV<PATH> = 'foo;\"bar\"/\"ber\"';\n    IO::Spec::Win32.path.perl.say; # OUTPUT: «(\".\", \"foo\", \"bar/ber\").Seq␤»","rel2abs\n\nDefined as:\n\n    method rel2abs(Str() $path, $base = $*CWD --> Str:D)\n\nReturns a string representing $path converted to absolute path, based at\n$base, which defaults to $*CWD. If $base is not an absolute path, it will\nbe made absolute relative to $*CWD, unless $*CWD and $base are the same.\n\n    say $*CWD;                                   # OUTPUT: «\"C:\\Users\\camelia\".IO␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo';          # OUTPUT: «C:\\Users\\camelia\\foo␤»\n    say IO::Spec::Win32.rel2abs: './';           # OUTPUT: «C:\\Users\\camelia␤»\n    say IO::Spec::Win32.rel2abs: 'foo/../../';   # OUTPUT: «C:\\Users\\camelia\\foo\\..\\..␤»\n    say IO::Spec::Win32.rel2abs: '/foo/';        # OUTPUT: «C:\\foo␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo', 'bar';   # OUTPUT: «C:\\Users\\camelia\\bar\\foo␤»\n    say IO::Spec::Win32.rel2abs: './', '/bar';   # OUTPUT: «\\bar␤»\n    say IO::Spec::Win32.rel2abs: '/foo/', 'bar'; # OUTPUT: «C:\\foo␤»\n\n    say IO::Spec::Win32.rel2abs: 'foo/../../', 'bar';\n    # OUTPUT: «C:\\Users\\camelia\\bar\\foo\\..\\..␤»","rootdir\n\nDefined as:\n\n    method rootdir(--> Str:D)\n\nReturns string ｢\\｣, representing root directory.","split\n\nDefined as:\n\n    method split(Cool:D $path --> List:D)\n\nSplits the given $path into \"volume\", \"dirname\", and \"basename\" and returns\nthe result as a List of three Pairs, in that order. The \"volume\" is always\nan empty string and exists for consistency with other IO::Spec classes.\n\n    IO::Spec::Win32.split('C:/foo/bar.txt').perl.say;\n    # OUTPUT: «(:volume(\"C:\"), :dirname(\"/foo\"), :basename(\"bar.txt\"))␤»\n\n    IO::Spec::Win32.split('/foo/').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"foo\"))␤»\n\n    IO::Spec::Win32.split('///').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"/\"), :basename(\"\\\\\"))␤»\n\n    IO::Spec::Win32.split('./').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Win32.split('.').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\".\"), :basename(\".\"))␤»\n\n    IO::Spec::Win32.split('').perl.say;\n    # OUTPUT: «(:volume(\"\"), :dirname(\"\"), :basename(\"\"))␤»","splitdir\n\nDefined as:\n\n    method splitdir(Cool:D $path --> List:D)\n\nSplits the given $path on slashes and backslashes.\n\n    IO::Spec::Win32.splitdir('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\", \"foo\", \"bar.txt\")␤»\n\n    IO::Spec::Win32.splitdir('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"foo\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('///').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('./').perl.say;\n    # OUTPUT: «(\".\", \"\")␤»\n\n    IO::Spec::Win32.splitdir('.').perl.say;\n    # OUTPUT: «(\".\",)␤»\n\n    IO::Spec::Win32.splitdir('').perl.say;\n    # OUTPUT: «(\"\",)␤»","splitpath\n\nDefined as:\n\n    method splitpath(Cool:D $path, :$nofile --> List:D)\n\nSplits the given $path into a list of 3 strings: volume, dirname, and file.\nThe volume is always an empty string, returned for API compatibility with\nother IO::Spec types. If :$nofile named argument is set to True, the\ncontent of the file string is undefined and should be ignored; this is a\nmeans to get a performance boost, as implementations may use faster code\npath when file is not needed.\n\n    IO::Spec::Win32.splitpath('C:\\foo/bar.txt').perl.say;\n    # OUTPUT: «(\"C:\", \"\\\\foo/\", \"bar.txt\")␤»\n\n    IO::Spec::Win32.splitpath('C:\\foo/bar.txt', :nofile).perl.say;\n    # OUTPUT: «(\"C:\", \"\\\\foo/bar.txt\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('/foo/').perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('/foo/', :nofile).perl.say;\n    # OUTPUT: «(\"\", \"/foo/\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('///').perl.say;\n    # OUTPUT: «(\"\", \"///\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('./').perl.say;\n    # OUTPUT: «(\"\", \"./\", \"\")␤»\n\n    IO::Spec::Win32.splitpath('.').perl.say;\n    # OUTPUT: «(\"\", \"\", \".\")␤»\n\n    IO::Spec::Win32.splitpath('').perl.say;\n    # OUTPUT: «(\"\", \"\", \"\")␤»","tmpdir\n\nDefined as:\n\n    method tmpdir(--> IO::Path:D)\n\nAttempts to locate a system's temporary directory by checking several\ntypical directories and environmental variables. Uses current directory if\nno suitable directories are found."]},{"name":"IO::Path::Cygwin","methods":["new\n\nSame as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Cygwin, regardless of the operating system the code is being run\non.","perl\n\nDefined as:\n\n    method perl(IO::Path::Cygwin:D: --> Str:D)\n\nReturns a string that, when given passed through EVAL gives the original\ninvocant back.\n\n    IO::Path::Cygwin.new(\"foo/bar\").perl.say;\n    # OUTPUT: IO::Path::Cygwin.new(\"foo/bar\", :CWD(\"/home/camelia\"))\n\nNote that this string includes the value of the .CWD attribute that is set\nto $*CWD when the path object was created, by default."],"desc":"TITLE\nclass IO::Path::Cygwin\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Cygwin\n\n    class IO::Path::Cygwin is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Cygwin in the $.SPEC\nattribute.\n\n"},{"name":"IO::Path::QNX","methods":["new\n\nSame as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::QNX, regardless of the operating system the code is being run\non.","perl\n\nDefined as:\n\n    method perl(IO::Path::QNX:D: --> Str:D)\n\nReturns a string that, when given passed through EVAL gives the original\ninvocant back.\n\n    IO::Path::QNX.new(\"foo/bar\").perl.say;\n    # OUTPUT: IO::Path::QNX.new(\"foo/bar\", :CWD(\"/home/camelia\"))\n\nNote that this string includes the value of the .CWD attribute that is set\nto $*CWD when the path object was created, by default."],"desc":"TITLE\nclass IO::Path::QNX\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::QNX\n\n    class IO::Path::QNX is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::QNX in the $.SPEC\nattribute.\n\n"},{"name":"IO::Path::Unix","desc":"TITLE\nclass IO::Path::Unix\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Unix\n\n    class IO::Path::Unix is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Unix in the $.SPEC\nattribute.\n\n","methods":["new\n\nSame as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Unix, regardless of the operating system the code is being run\non.","perl\n\nDefined as:\n\n    method perl(IO::Path::Unix:D: --> Str:D)\n\nReturns a string that, when given passed through EVAL gives the original\ninvocant back.\n\n    IO::Path::Unix.new(\"foo/bar\").perl.say;\n    # OUTPUT: IO::Path::Unix.new(\"foo/bar\", :CWD(\"/home/camelia\"))\n\nNote that this string includes the value of the .CWD attribute that is set\nto $*CWD when the path object was created, by default."]},{"methods":["new\n\nSame as IO::Path.new, except :$SPEC cannot be set and defaults to\nIO::Spec::Win32, regardless of the operating system the code is being run\non.","perl\n\nDefined as:\n\n    method perl(IO::Path::Win32:D: --> Str:D)\n\nReturns a string that, when given passed through EVAL gives the original\ninvocant back.\n\n    IO::Path::Win32.new(\"foo/bar\").perl.say;\n    # OUTPUT: IO::Path::Win32.new(\"foo/bar\", :CWD(\"C:\\\\Users\\\\camelia\"))\n\nNote that this string includes the value of the .CWD attribute that is set\nto $*CWD when the path object was created, by default."],"desc":"TITLE\nclass IO::Path::Win32\n\nSUBTITLE\nIO::Path pre-loaded with IO::Spec::Win32\n\n    class IO::Path::Win32 is IO::Path { }\n\nThis sub-class of IO::Path, pre-loaded with IO::Spec::Win32 in the $.SPEC\nattribute.\n\n","name":"IO::Path::Win32"},{"name":"Telemetry::Instrument::Usage","methods":[],"desc":"TITLE\nclass Telemetry::Instrument::Usage\n\nSUBTITLE\nInstrument for collecting getrusage data\n\n    class Telemetry::Instrument::Usage { }\n\nNote:  This class is a Rakudo-specific feature and not standard Raku.\n\nObjects of this class are generally not created by themselves, but rather\nthrough making a snapshot.\n\n  Useful readings\n\nThis class provides the following generally usable readings (in\nalphabetical order):\n\n  * cpu\n\nThe total amount of CPU time (in microseconds), essentially the sum of\ncpu-user and cpu-sys.\n\n  * cpu-sys\n\nThe number of microseconds of CPU used by the system.\n\n  * cpu-user\n\nThe number of microseconds of CPU used by the user program.\n\n  * cpus\n\nThe number of CPU's active, essentially cpu divided by wallclock.\n\n  * max-rss\n\nThe maximum resident set size (in KiB).\n\n  * util%\n\nPercentage of CPU utilization, essentially 100 * cpus / number of CPU\ncores.\n\n  * wallclock\n\nThe time the program has been executing (in microseconds).\n\nhead\nLess useful readings\n\nThe following readings may or may not contain sensible information, mostly\ndepending on hardware and OS being used. Please check your local getrusage\ndocumentation for their exact meaning:\n\n    name        getrusage struct name\n    ====        =====================\n    max-rss     ru_maxrss\n    ix-rss      ru_ixress\n    id-rss      ru_idrss\n    is-rss      ru_isrss\n    minf        ru_minflt\n    majf        ru_majflt\n    nswp        ru_nswap\n    inb         ru_inblock\n    outb        ru_oublock\n    msnd        ru_msgsnd\n    mrcv        ru_msgrcv\n    nsig        ru_nsignals\n    volcsw      ru_nvcsw\n    invcsw      ru_nivcsw\n"},{"name":"Telemetry::Instrument::ThreadPool","methods":[],"desc":"TITLE\nclass Telemetry::Instrument::ThreadPool\n\nSUBTITLE\nInstrument for collecting ThreadPoolScheduler data\n\n    class Telemetry::Instrument::ThreadPool { }\n\nNote: This class is a Rakudo-specific feature and not standard Raku.\n\nObjects of this class are generally not created directly, but rather\nthrough making a snapshot. They provide the following attributes (in\nalphabetical order):\n\n  * atc\n\nThe number of tasks completed by affinity thread workers\n(affinity-tasks-completed).\n\n  * atq\n\nThe number of tasks queued for execution for affinity thread workers\n(affinity-tasks-queued).\n\n  * aw\n\nThe number of affinity thread workers (affinity-workers).\n\n  * gtc\n\nThe number of tasks completed by general workers\n(general-tasks-completed).\n\n  * gtq\n\nThe number of tasks queued for execution by general worker\n(general-tasks-queued).\n\n  * gw\n\nThe number of general workers (general-workers).\n\n  * s\n\nThe number of supervisor threads running, usually 0 or 1 (supervisor).\n\n  * ttc\n\nThe number of tasks completed by timer workers (timer-tasks-completed).\n\n  * ttq\n\nThe number of tasks queued for execution by timer workers\n(timer-tasks-queued).\n\n  * tw\n\nThe number of timer workers (timer-workers)."},{"desc":"TITLE\nclass Telemetry::Instrument::Thread\n\nSUBTITLE\nInstrument for collecting Thread data\n\n    class Telemetry::Instrument::Thread { }\n\nNote:  This class is a Rakudo-specific feature and not standard Raku.\n\nObjects of this class are generally not created by themselves, but rather\nthrough making a snapshot.\n\nThis class provides the following data points (in alphabetical order):\n\n  * tad\n\nThe number of threads that ended with an exception (threads-aborted).\n\n  * tcd\n\nThe number of threads that completed without any problem\n(threads-completed).\n\n  * thid\n\nHighest OS thread ID seen (thread-highest-id).\n\n  * tjd\n\nThe number of threads that were joined (threads-joined).\n\n  * tsd\n\nThe number of threads that were started (threads-started).\n\n  * tyd\n\nThe number of times a thread was yielded (threads-yielded).","methods":[],"name":"Telemetry::Instrument::Thread"},{"desc":"TITLE\nclass X::Mixin::NotComposable\n\nSUBTITLE\nError due to using an ineligible type as a mixin\n\n    class X::Mixin::NotComposable is Exception { }\n\nThrown when a mixin with infix does or but is done with a composer that\ncannot be used for mixin.\n\nFor example\n\n    class A { };\n    1 but A;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Mixin::NotComposable: Cannot mix in non-composable type A into object of type Int␤»\n\nThe compile-time equivalent of this error is X::Composition::NotComposable\n\n","methods":["target\n\n    method target()\n\nReturns the target of the failed mixin operation.","rolish\n\n    method rolish()\n\nReturns the thing that could not act as a role for mixing it in"],"name":"X::Mixin::NotComposable"},{"methods":["invalid-str\n\nReturns the invalid format string (12/25/2015 in the example above)","target\n\nReturns the target type (Date in the example above)","format\n\nReturns valid format strings for the target type in question, (yyyy-mm-dd\nin the example above)"],"desc":"TITLE\nclass X::Temporal::InvalidFormat\n\nSUBTITLE\nError due to using an invalid format when creating a DateTime or Date\n\n    class X::Temporal::InvalidFormat does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime or Date\nobject using an invalid format.\n\n    my $dt = Date.new(\"12/25/2015\");\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Temporal::InvalidFormat: Invalid Date string '12/25/2015'; use yyyy-mm-dd instead␤»\n\n\n","name":"X::Temporal::InvalidFormat"},{"desc":"TITLE\nclass X::Eval::NoSuchLang\n\nSUBTITLE\nError due to specifying an unknown language for EVAL\n\n    class X::Eval::NoSuchLang is Exception { }\n\nError thrown when EVAL($str, :$lang) specifies a language that the compiler\ndoes not know how to handle.\n\nFor example\n\n    EVAL 'boo', lang => \"bar\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Eval::NoSuchLang: No compiler available for language 'bar'␤»\n\n","methods":["lang\n\n    method lang()\n\nReturns the language that EVAL did not know how to handle."],"name":"X::Eval::NoSuchLang"},{"name":"X::Inheritance::Unsupported","desc":"TITLE\nclass X::Inheritance::Unsupported\n\nSUBTITLE\nCompilation error due to inheriting from an ineligible type\n\n    class X::Inheritance::Unsupported does X::Comp { }\n\nCompile time error thrown when trying to inherit from a type that does not\nsupport inheritance (like a package or an enum).\n\nFor example\n\n    enum A <Ax Ay>;\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    A does not support inheritance, so B cannot inherit from it\n\n\n","methods":["child-typename\n\nThe name of the type that tries to inherit.","parent\n\nThe type object that the child tried to inherit from."]},{"desc":"TITLE\nclass X::Inheritance::NotComposed\n\nSUBTITLE\nError due to inheriting from a type that's not composed yet\n\n    class X::Inheritance::NotComposed is Exception {}\n\nWhen you try to inherit from a class that hasn't been composed, an\nexception of type X::Inheritance::NotComposed is thrown.\n\nUsually this happens because it's not yet fully parsed, or that is\nstubbed:\n\nFor example\n\n    class A { ... };    # literal ... for stubbing\n    class B is A { };\n\n\ndies with\n\n    ===SORRY!===\n    'B' cannot inherit from 'A' because 'A' isn't composed yet (maybe it is stubbed)\n\n\nThe second common way to trigger this error is by trying to inherit from a\nclass from within the class body.\n\nFor example\n\n    class Outer {\n        class Inner is Outer {\n        }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    'Outer::Inner' cannot inherit from 'Outer' because 'Outer' isn't composed yet (maybe it is stubbed)\n\n\n","methods":["child-name\n\n    method child-name(X::Inheritance::NotComposed:D: --> Str:D)\n\nReturns the name of the type that tries to inherit.","parent-name\n\n    method parent-name(X::Inheritance::NotComposed:D: --> Str:D)\n\nReturns the name of the parent type that the type tries to inherit from"],"name":"X::Inheritance::NotComposed"},{"name":"X::Signature::NameClash","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name that was used for more than one parameter."],"desc":"TITLE\nclass X::Signature::NameClash\n\nSUBTITLE\nCompilation error due to two named parameters with the same name\n\n    my class X::Signature::NameClash does X::Comp { }\n\nCompile time error thrown when two named parameters have the same name,\npotentially through aliases.\n\nFor example\n\n    sub f(:$a, :a(:@b)) { }\n\n\ndies with\n\n    ===SORRY!===\n    Name a used for more than one named parameter\n\n\n"},{"methods":["placeholder\n\n    method placeholder(--> Str:D)\n\nReturns the name of a placeholder that was used in a block that already had\na signature."],"desc":"TITLE\nclass X::Signature::Placeholder\n\nSUBTITLE\nCompilation error due to placeholders in a block with a signature\n\n    class X::Signature::Placeholder does X::Comp { }\n\n\nCompile time error thrown when a block has both an explicit signature and\nplaceholder parameters.\n\nFor example\n\n    sub f() { $^x }\n\n\ndies with\n\n    ===SORRY!===\n    Placeholder variable '$^x' cannot override existing signature\n\n\n","name":"X::Signature::Placeholder"},{"desc":"TITLE\nclass X::Export::NameClash\n\nSUBTITLE\nCompilation error due to exporting the same symbol twice\n\n    class X::Export::NameClash does X::Comp { }\n\nCompile time error thrown when a symbol is exported twice.\n\nFor example\n\n    sub f() is export { };\n    {\n        sub f() is export { }\n    }\n\n\ndies with\n\n    ===SORRY!===\n    A symbol '&f' has already been exported\n\n\n","methods":["symbol\n\nReturns the symbol that is exported twice."],"name":"X::Export::NameClash"},{"name":"X::Method::InvalidQualifier","desc":"TITLE\nclass X::Method::InvalidQualifier\n\nSUBTITLE\nError due to calling a qualified method from an ineligible class\n\n    class X::Method::InvalidQualifier is Exception { }\n\nThrown when a method is call in the form $invocant.TheClass::method if\n<$invocant> does not conform to TheClass.\n\nFor example\n\n    1.Str::split(/a/);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Method::InvalidQualifier: Cannot dispatch to method split on Str because it is not inherited or done by Int␤»\n\n","methods":["method\n\n    method method(--> Str:D)\n\nReturns the name of the (unqualified) method.","invocant\n\nReturns the invocant of the failed, qualified method call","qualifier-type\n\nReturns the type by which the method call was qualified."]},{"methods":["method\n\n    method method(--> Str:D)\n\nReturns the method name that was invoked.","typename\n\n    method typename(--> Str:D)\n\nReturns the name of the invocant type.","private\n\n    method private(--> Bool:D)\n\nReturns True for private methods, and False for public methods.","addendum\n\n    method addendum(--> Str:D)\n\nReturns additional explanations or hints.\n\nNote: addendum was introduced in Rakudo 2019.03."],"desc":"TITLE\nclass X::Method::NotFound\n\nSUBTITLE\nError due to calling a method that isn't there\n\n    class X::Method::NotFound is Exception {}\n\nThrown when the user tries to call a method that isn't there.\n\nFor example\n\n    1.no-such\n\n\nthrows\n\n    No such method 'no-such' for invocant of type 'Int'\n\n\n","name":"X::Method::NotFound"},{"methods":["proc\n\n    method proc(X::Proc::Unsuccessful:D --> Proc)\n\nReturns the object that threw the exception."],"desc":"TITLE\nclass X::Proc::Unsuccessful\n\nSUBTITLE\nException thrown if a Proc object is sunk after the process it ran exited\nunsuccessfully\n\n    class X::Proc::Unsuccessful is Exception {}\n\n","name":"X::Proc::Unsuccessful"},{"name":"X::Proc::Async","methods":["proc\n\n    method proc(X::Proc::Async:D --> Proc::Async)\n\nReturns the object that threw the exception."],"desc":"TITLE\nrole X::Proc::Async\n\nSUBTITLE\nException thrown by Proc::Async\n\n    role X::Proc::Async is Exception { ... }\n\nAll exceptions thrown by Proc::Async do this common role.\n\n"},{"name":"X::DateTime::TimezoneClash","desc":"TITLE\nclass X::DateTime::TimezoneClash\n\nSUBTITLE\nError due to using both time zone offset and :timezone\n\n    class X::DateTime::TimezoneClash does X::Temporal is Exception { }\n\n\nThis exception is thrown when code tries to create a DateTime object\nspecifying both a time zone offset and the named argument :timezone.\n\n    say DateTime.new('2015-12-24T12:23:00+0200');                   # works\n    say DateTime.new('2015-12-24T12:23:00', timezone => 7200);      # works\n    say DateTime.new('2015-12-24T12:23:00+0200', timezone => 7200); # exception\n\n\n","methods":["sub message Defined as:\n\n    method message()\n\nReturns 'DateTime.new(Str): :timezone argument not allowed with a timestamp\noffset'"]},{"desc":"TITLE\nclass X::Scheduler::CueInNaNSeconds\n\nSUBTITLE\nError caused by passing NaN to Scheduler.cue as :at, :in, or :every\n\n    class X::Scheduler::CueInNaNSeconds is Exception { }\n\nWhen calling ThreadPoolScheduler.cue or CurrentThreadScheduler.cue with\n:at, :in, or :every as NaN, this exception gets thrown. For example, the\nfollowing code:\n\n    my Cancellation $c = $*SCHEDULER.cue({\n        say 'This will never output :(';\n    }, at => NaN);\n\n\nThrows with:\n\n    Cannot pass NaN as a number of seconds to Scheduler.cue\n\n\nThis class only exists in releases 2019.05 and later.","methods":[],"name":"X::Scheduler::CueInNaNSeconds"},{"name":"X::Bind::Slice","methods":["type\n\n    method type(X::Bind::Slice:D:)\n\nreturns the type object of the thing that you tried to slice-bind, for\nexample Array, List or Hash."],"desc":"TITLE\nclass X::Bind::Slice\n\nSUBTITLE\nError due to binding to a slice\n\n    class X::Bind::Slice is Exception {}\n\nWhen you try to bind to an array or hash slice:\n\n    my @a; @a[0, 1] := [42];\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Array slice␤»\n\nand\n\n    my %h; %h<a b> := {};\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Bind::Slice: Cannot bind to Hash slice␤»\n\nyou get an exception of type ::Bind::Slice\n\n"},{"name":"X::Bind::NativeType","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the variable."],"desc":"TITLE\nclass X::Bind::NativeType\n\nSUBTITLE\nCompilation error due to binding to a natively typed variable\n\n    class X::Bind::NativeType does X::Comp { }\n\nCompile-time error thrown when trying to bind to a natively typed\nvariable.\n\nSince native variables explicitly don't have the concept of a container at\nruntime, it does not make sense to support both binding and assignment;\nRaku supports only assignment (which makes more sense, because native types\nare value types).\n\nFor example the code\n\n    my int $x := 3;\n\n\ndies with\n\n    Cannot bind to natively typed variable '$x'; use assignment instead\n\n\nand can be fixed by writing it as\n\n    my int $x = 3;\n\n"},{"methods":[],"desc":"TITLE\nclass X::Sequence::Deduction\n\nSUBTITLE\nError due to constructing a sequence from ineligible input\n\n    class X::Sequence::Deduction is Exception { }\n\nException type thrown when the ... sequence operator is being called\nwithout an explicit closure, and the sequence cannot be deduced.","name":"X::Sequence::Deduction"},{"methods":["what\n\n    method what(X::Syntax::Malformed:D: --> Str)\n\nReturns a description of the thing that was being parsed."],"desc":"TITLE\nclass X::Syntax::Malformed\n\nSUBTITLE\nCompilation error due to a malformed construct (usually a declarator)\n\n    class X::Syntax::Malformed does X::Syntax {}\n\nThe Raku compiler throws errors of type X::Syntax::Malformed when it knows\nwhat kind of declaration it is parsing, and encounters a syntax error, but\ncan't give a more specific error message.\n\n    my Int a;   # throws an X::Syntax::Malformed\n\n\nproduces\n\n    ===SORRY!===\n    Malformed my\n    at -e:1\n    ------> my Int ⏏a\n\n\n","name":"X::Syntax::Malformed"},{"methods":["what\n\n    method what(--> Str:D)\n\nReturns a string description of the missing syntax element."],"desc":"TITLE\nclass X::Syntax::Missing\n\nSUBTITLE\nCompilation error due to a missing piece of syntax\n\n    class X::Syntax::Missing does X::Syntax { }\n\nSyntax error thrown when the previous piece of syntax requires the\nexistence of another piece of syntax, and that second piece is missing.\n\nFor example\n\n    for 1, 2, 3;\n\n\ndies with\n\n    ===SORRY!===\n    Missing block\n\n\nbecause a for that is not a statement modifier must be followed by a\nblock.\n\n","name":"X::Syntax::Missing"},{"desc":"TITLE\nclass X::Syntax::NoSelf\n\nSUBTITLE\nCompilation error due to implicitly using a self that is not there\n\n    class X::Syntax::NoSelf does X::Syntax { }\n\nCompile time error thrown when $.foo style calls are used where no invocant\nis available.\n\nFor example the code\n\n    $.meth;\n\n\nin the program body throws the error\n\n    ===SORRY!===\n    Variable $.meth used where no 'self' is available\n\n\nbecause $.meth is short for $(self.meth), and there is no self available in\nmainline.\n\n","methods":["variable\n\nReturns the variable/method call that caused the error."],"name":"X::Syntax::NoSelf"},{"name":"X::Syntax::UnlessElse","methods":[],"desc":"TITLE\nclass X::Syntax::UnlessElse\n\nSUBTITLE\nCompilation error due to an unless clause followed by else\n\n    class X::Syntax::UnlessElse does X::Syntax { }\n\nSyntax error thrown when an unless clause is followed by an else clause.\n\nFor example\n\n    unless 1 { } else { };\n\n\ndies with\n\n    ===SORRY!===\n    \"unless\" does not take \"else\", please rewrite using \"if\"\n"},{"desc":"TITLE\nclass X::Syntax::NegatedPair\n\nSUBTITLE\nCompilation error due to passing an argument to a negated colonpair\n\n    class X::Syntax::NegatedPair does X::Syntax { }\n\nThrown if a colonpair illegally has a value, for example :!a(1). This is an\nerror because the ! negation implies that the value is False.\n\nA typical error message from this class is Argument not allowed on negated\npair with key 'a'.\n\n","methods":["key\n\nReturns the key of the pair that caused the error."],"name":"X::Syntax::NegatedPair"},{"methods":["infix\n\n    method infix(--> Str:D)\n\nReturns the symbol of the infix that was found in term position."],"desc":"TITLE\nclass X::Syntax::InfixInTermPosition\n\nSUBTITLE\nCompilation error due to an infix in term position\n\n    class X::Syntax::InfixInTermPosition does X::Syntax { }\n\nSyntax error thrown when the parser expects a term, but finds an infix\noperator instead.\n\nFor example\n\n    1, => 2;\n\n\ndies with\n\n    ===SORRY!===\n    Preceding context expects a term, but found infix => instead\n\n\n","name":"X::Syntax::InfixInTermPosition"},{"name":"X::Syntax::P5","desc":"TITLE\nclass X::Syntax::P5\n\nSUBTITLE\nCompilation error due to use of Perl 5-only syntax\n\n    class X::Syntax::P5 does X::Syntax { }\n\nSyntax error thrown when some piece of code is clearly Perl 5, not Raku.\n\nFor example\n\n    for my $a (1, 2) { };\n\n\ndies with\n\n    ===SORRY!===\n    This appears to be Perl 5 code\n","methods":[]},{"methods":["reserved\n\n    method reserved(--> Str:D)\n\nReturns a text description of the reserved syntax.","instead\n\n    method instead(--> Str)\n\nDescribes what to use instead of the reserved syntax (if anything)."],"desc":"TITLE\nclass X::Syntax::Reserved\n\nSUBTITLE\nCompilation error due to use of syntax reserved for future use\n\n    class X::Syntax::Reserved does X::Syntax { }\n\nSyntax error thrown when a syntax is used which is reserved for future\nexpansion.\n\nFor example\n\n    my @a();\n\n\ndies with\n\n    ===SORRY!===\n    The () shape syntax in array declarations is reserved\n\n\n","name":"X::Syntax::Reserved"},{"methods":[],"desc":"TITLE\nclass X::Syntax::Confused\n\nSUBTITLE\nCompilation error due to unrecognized syntax\n\n    class X::Syntax::Confused does X::Syntax { }\n\n\nThe most general syntax error, if no more specific error message can be\ngiven.\n\nFor example\n\n    1∞\n\n\ndies with\n\n    ===SORRY!===\n    Confused\n","name":"X::Syntax::Confused"},{"name":"X::Syntax::Perl5Var","desc":"TITLE\nclass X::Syntax::Perl5Var\n\nSUBTITLE\nCompilation error due to use of Perl 5-only default variables\n\n    class X::Syntax::Perl5Var does X::Syntax { }\n\nSyntax error thrown when some piece of code tries to use one of the old\nPerl 5 variables (and it does not error for some other reason).\n\n    say $];\n\n\ndies with\n\n    Unsupported use of $] variable; in Raku please use $*PERL.version or $*PERL.compiler.version\n\n\nFor every unsupported variable (which include most $^'letter' constructs,\nas well as others like $\", the error message will mention that the variable\nis unsupported and the equivalent commands you could use.","methods":[]},{"methods":[],"desc":"TITLE\nclass X::ControlFlow::Return\n\nSUBTITLE\nError due to calling return outside a routine\n\n    class X::ControlFlow::Return is X::ControlFlow { }\n\nThrown when a return is called from outside a routine.\n\n    return;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::ControlFlow::Return: Attempt to return outside of any Routine␤»","name":"X::ControlFlow::Return"},{"methods":[],"desc":"TITLE\nclass X::TypeCheck::Return\n\nSUBTITLE\nError due to a failed typecheck during return\n\n    class X::TypeCheck::Return is X::TypeCheck { }\n\nThrown when a return type check fails.\n\nFor example\n\n    sub f(--> Int) { \"foo\" }\n    f();\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Return: Type check failed for return value; expected Int but got Str (\"foo\")␤»","name":"X::TypeCheck::Return"},{"desc":"TITLE\nclass X::TypeCheck::Assignment\n\nSUBTITLE\nError due to a failed type check during assignment\n\n    class X::TypeCheck::Assignment is X::TypeCheck { }\n\nError class thrown when the type check of an assignment fails.\n\nFor example, this will die\n\n    my Int $x = \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Assignment: Type check failed in assignment to $x; expected Int but got Str (\"foo\")␤»\n\nthough compilers are allowed to detect obvious cases like this example and\ncomplain at compile time with a different error.","methods":[],"name":"X::TypeCheck::Assignment"},{"name":"X::TypeCheck::Binding","methods":[],"desc":"TITLE\nclass X::TypeCheck::Binding\n\nSUBTITLE\nError due to a failed type check during binding\n\n    class X::TypeCheck::Binding is X::TypeCheck { }\n\nThrown when the type check of a binding operation fails.\n\nFor example:\n\n    my Int $x := \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::TypeCheck::Binding: Type check failed in binding; expected Int but got Str (\"foo\")␤»\n\nNote that the compiler is free to detect obvious errors at compile time,\nand complain with a different error at compile time."},{"name":"X::TypeCheck::Splice","desc":"TITLE\nclass X::TypeCheck::Splice\n\nSUBTITLE\nCompilation error due to a macro trying to splice a non-AST value\n\n    class X::TypeCheck::Splice is X::TypeCheck does X::Comp { }\n\nCompile time error thrown when a Macro or an unquote/hole in a quasi quote\ndoes not return an AST.\n\nFor example\n\n    use experimental :macros;\n    macro quasi-ast { quasi { {{{'not AST'}}} };};\n    say quasi-ast;\n\n\ndies with\n\n    ===SORRY!===\n    Type check failed in macro application; expected AST but got Str(\"not AST\")\n\n\nThis is because you are purposefully creating something that does not\nevaluate to an abstract syntax tree. To fix, instead write\n\n    use experimental :macros;\n    macro an-ast {\n        quasi { 'yes AST' }\n    }\n    say an-ast;              # OUTPUT: «yes AST␤»\n\n\n","methods":["action\n\n    method action(--> Str:D)\n\nReturns a verbal description of the action that triggered the error, \"macro\napplication\" or \"unquote evaluation\"."]},{"name":"X::Channel::SendOnClosed","methods":["channel\n\n    method Channel(X::Channel::SendOnClosed:D: --> Channel:D)\n\nReturns the Channel object on which the send method was called."],"desc":"TITLE\nclass X::Channel::SendOnClosed\n\nSUBTITLE\nError due to calling send on a closed channel\n\n    class X::Channel::SendOnClosed {}\n\nThis exception is thrown when a calling send on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.send(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::SendOnClosed: Cannot send a message on a closed channel␤»\n\n"},{"name":"X::Channel::ReceiveOnClosed","methods":["channel\n\n    method Channel(X::Channel::ReceiveOnClosed:D: --> Channel:D)\n\nReturns the Channel object on which the receive method was called."],"desc":"TITLE\nclass X::Channel::ReceiveOnClosed\n\nSUBTITLE\nError due to calling receive on a closed channel\n\n    class X::Channel::ReceiveOnClosed {}\n\nThis exception is thrown when a calling receive on a Channel that has been\nclosed:\n\n    my $s = Channel.new;\n    $s.close;\n    $s.receive;     # Cannot receive a message on a closed channel\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Channel::ReceiveOnClosed: Cannot receive a message on a closed channel␤»\n\n"},{"name":"X::Dynamic::NotFound","desc":"TITLE\nclass X::Dynamic::NotFound\n\nSUBTITLE\nRuntime error thrown when a dynamic variable does not exist\n\n    class X::Dynamic::NotFound is Exception {}\n\nThis exception is raised when a dynamic variable that has not been declared\nis used.\n\n    $*dynamic-not-found = 33;\n    # OUTPUT: «Dynamic variable $*dynamic-not-found not found␤»\n\n\n","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the variable that has not been found."]},{"methods":["from\n\nReturns the source of the failed move operation","to\n\nReturns the destination of the failed move operation"],"desc":"TITLE\nclass X::IO::Move\n\nSUBTITLE\nError while trying to move a file\n\n    class X::IO::Move does X::IO is Exception { }\n\n\nError class for a failed file move operation. A typical error message is\n\n    Failed to move '/tmp/alpha.p6' to 'test.p6': :createonly specified and destination exists\n\n\n","name":"X::IO::Move"},{"desc":"TITLE\nclass X::IO::Dir\n\nSUBTITLE\nError while trying to get a directory's contents\n\n    class X::IO::Dir does X::IO is Exception { }\n\n\nError class that is thrown when a dir call fails.\n\nA typical error message is\n\n    Failed to get the directory contents of '/tmp/': No such file or directory\n\n\n","methods":["path\n\nReturns the path that dir failed to read."],"name":"X::IO::Dir"},{"name":"X::IO::Link","methods":["target\n\nReturns the name of the link target, i.e. the existing file.","name\n\nReturns the name of the link that could not be created."],"desc":"TITLE\nclass X::IO::Link\n\nSUBTITLE\nError while trying to create a link\n\n    class X::IO::Link does X::IO is Exception { }\n\n\nError class for failed link operation.\n\nA typical error message is\n\n    Failed to create link called 'my-link' on target 'does-not exist': Failed to link file\n\n\n"},{"methods":["path\n\nReturns the path rmdir failed to remove"],"desc":"TITLE\nclass X::IO::Rmdir\n\nSUBTITLE\nError while trying to remove a directory\n\n    my class X::IO::Rmdir does X::IO is Exception { }\n\n\nError class for failed rmdir operations.\n\nA typical error message is\n\n    Failed to remove the directory 'lib': Directory not empty\n\n\n","name":"X::IO::Rmdir"},{"name":"X::IO::Copy","desc":"TITLE\nclass X::IO::Copy\n\nSUBTITLE\nError while trying to copy a file\n\n    class X::IO::Copy does X::IO is Exception { }\n\n\nError class for failed file copy operations. A typical error message is\n\n    Failed to copy 'source' to 'destination': permission denied\n\n\n","methods":["from\n\nReturns the source of the failed copy operation","to\n\nReturns the destination of the failed copy operation"]},{"name":"X::IO::DoesNotExist","desc":"TITLE\nclass X::IO::DoesNotExist\n\nSUBTITLE\nError while doing file tests on a non existing path\n\n    class X::IO::DoesNotExist does X::IO is Exception { }\n\n\nThrown when doing file test operations on a non existing path.\n\nA typical error message is\n\n    Failed to find 'euler-5.p6' while trying to do '.f'\n\n\n","methods":["path\n\nReturns the path that was passed to the failed call.","trying\n\nReturns a string describing the failed operation."]},{"name":"X::IO::Symlink","desc":"TITLE\nclass X::IO::Symlink\n\nSUBTITLE\nError while trying to create a symbolic link\n\n    class X::IO::Symlink does X::IO is Exception { }\n\n\nError class for failed symlink creation.\n\nA typical error message is\n\n    Failed to create symlink called 'euler' on target '/home/myhome/euler-1.p6': Failed to symlink file: file already exist\n\n\n","methods":["name\n\nReturns the path that symlink failed to create.","target\n\nReturns the path that symlink failed to create a link to."]},{"methods":[],"desc":"TITLE\nclass X::IO::Cwd\n\nSUBTITLE\nError while trying to determine the current working directory\n\n    class X::IO::Cwd does X::IO is Exception { }\n\n\nError class when the runtime fails to determine the current directory.\n\nA typical error message is\n\n    Failed to get the working directory: permission denied\n","name":"X::IO::Cwd"},{"methods":["path\n\nReturns the path that unlink failed to delete."],"desc":"TITLE\nclass X::IO::Unlink\n\nSUBTITLE\nError while trying to remove a file\n\n    class X::IO::Unlink does X::IO is Exception { }\n\n\nError class for failed unlink operation.\n\nA typical error message is\n\n    Failed to remove the file 'secret': Permission defined\n\n\n","name":"X::IO::Unlink"},{"methods":["path\n\nReturns the path that was passed to the failed chdir call."],"desc":"TITLE\nclass X::IO::Chdir\n\nSUBTITLE\nError while trying to change the working directory\n\n    class X::IO::Chdir does X::IO is Exception { }\n\n\nError class when a chdir call failed.\n\nFor example\n\n    chdir '/home/other'\n\n\nthrows\n\n    Failed to change the working directory to '/home/other': permission denied\n\n\n","name":"X::IO::Chdir"},{"desc":"TITLE\nclass X::IO::Rename\n\nSUBTITLE\nError while trying to rename a file or directory\n\n    class X::IO::Rename does X::IO is Exception { }\n\n\nError class for failed file or directory rename operations. A typical error\nmessage is\n\n    Failed to rename 'source' to 'destination': is a directory\n\n\n","methods":["from\n\nReturns the source of the failed rename operation","to\n\nReturns the destination of the failed rename operation"],"name":"X::IO::Rename"},{"name":"X::IO::Chmod","methods":[],"desc":"TITLE\nclass X::IO::Chmod\n\nSUBTITLE\nError while trying to change file permissions\n\n    class X::IO::Chmod does X::IO is Exception { }\n\n\nError class for failed chmod calls.\n\nA typical error message is\n\n    Failed to set the mode of '/home/other' to '0o777': Permission denied\n"},{"name":"X::IO::Mkdir","desc":"TITLE\nclass X::IO::Mkdir\n\nSUBTITLE\nError while trying to create a directory\n\n    class X::IO::Mkdir does X::IO is Exception { }\n\n\nError class for failed mkdir operations.\n\nA typical error message is\n\n    Failed to create directory 'destination' with mode '0o755': File exists\n\n\n","methods":["path\n\nReturns the path that the mkdir operation failed to create.","mode\n\nReturns the permissions mask of the failed mkdir operation as an Int."]},{"methods":["role\n\n    method role()\n\nReturns the role that caused the error."],"desc":"TITLE\nclass X::Role::Initialization\n\nSUBTITLE\nError due to passing an initialization value to an ineligible role\n\n    class X::Role::Initialization is Exception { }\n\nThrown when the SomeRole($init) syntax is used, but SomeRole does not have\nexactly one public attribute.\n\nFor example:\n\n    role R { }; \"D2\" but R(2)\n    CATCH { default { put .^name, ': ', .Str } }\n    # OUTPUT: «X::Role::Initialization: Can only supply an initialization value for a role if it has a single public attribute, but this is not the case for 'R'␤»\n\n\n","name":"X::Role::Initialization"},{"desc":"TITLE\nclass X::Package::Stubbed\n\nSUBTITLE\nCompilation error due to a stubbed package that is never defined\n\n    class X::Package::Stubbed does X::Comp { }\n\nThrown at CHECK time when there are packages stubbed but not later\ndefined.\n\nFor example\n\n    class A { ... }     # literal ...\n    class B { ... }     # literal ...\n\n\ndies with\n\n    ===SORRY!===\n    The following packages were stubbed but not defined:\n        A\n        B\n\n\n","methods":["packages\n\n    method packages(--> Positional:D)\n\nReturns a list of packages that were stubbed but not defined."],"name":"X::Package::Stubbed"},{"methods":[],"desc":"TITLE\nclass X::Seq::Consumed\n\nSUBTITLE\nError due to trying to reuse a consumed sequence\n\n    class X::Seq::Consumed is Exception { }\n\nThis exception is thrown when a piece of code tries to reuse a Seq which\nhas already been iterated.","name":"X::Seq::Consumed"},{"methods":["typename\n\n    method typename(X::Assignment::RO:D: --> Str)\n\nReturns the type name of the value on the left-hand side"],"desc":"TITLE\nclass X::Assignment::RO\n\nSUBTITLE\nException thrown when trying to assign to something read-only\n\n    class X::Assignment::RO is Exception {}\n\nCode like\n\n    sub f() { 42 };\n    f() = 'new value';  # throws an X::Assignment::RO\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Assignment::RO: Cannot modify an immutable Any␤»\n\nthrows an exception of type X::Assignment::RO.\n\n","name":"X::Assignment::RO"},{"methods":["promise\n\n    method promise()\n\nReturns the Promise that was asked about.","status\n\n    method status()\n\nReturns the status the Promise had at that time."],"desc":"TITLE\nclass X::Promise::CauseOnlyValidOnBroken\n\nSUBTITLE\nError due to asking why an unbroken promise has been broken.\n\n    class X::Promise::CauseOnlyValidOnBroken is Exception { }\n\nThis exception is thrown when code expects a Promise to be broken, and asks\nwhy it has been broken, but the Promise has in fact, not yet been broken.\n\n","name":"X::Promise::CauseOnlyValidOnBroken"},{"name":"X::Promise::Vowed","methods":["promise\n\n    method promise()\n\nReturns the vowed Promise."],"desc":"TITLE\nclass X::Promise::Vowed\n\nSUBTITLE\nError due to directly trying to keep/break a vowed promise.\n\n    class X::Promise::Vowed is Exception { }\n\nThis exception is thrown when code tries to keep/break an already vowed\npromise without going through the corresponding Vow object.\n\n"},{"desc":"TITLE\nclass X::Phaser::Multiple\n\nSUBTITLE\nCompilation error due to multiple phasers of the same type\n\n    class X::Phaser::Multiple does X::Comp { }\n\nThrown when multiple phasers of the same type occur in a block, but only\none is allowed (for example CATCH or CONTROL).\n\nFor example\n\n    CATCH { }; CATCH { }\n\n\ndies with\n\n    ===SORRY!===\n    Only one CATCH block is allowed\n\n\n","methods":["block\n\nReturns the name of the phaser that occurred more than once."],"name":"X::Phaser::Multiple"},{"name":"X::Phaser::PrePost","methods":["phaser\n\n    method phaser(--> Str:D)\n\nReturns the name of the failed phaser, \"PRE\" or \"POST\".","condition\n\n    method condition(--> Str:D)\n\nReturns the part of the source code that describes the phaser condition."],"desc":"TITLE\nclass X::Phaser::PrePost\n\nSUBTITLE\nError due to a false return value of a PRE/POST phaser\n\n    class X::Phaser::PrePost is Exception { }\n\n\nThrown when the condition inside a PRE or POST phaser evaluate to a false\nvalue.\n\nFor example\n\n    sub f($x) { PRE { $x ~~ Int } };\n    f \"foo\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: X::Phaser::PrePost: Precondition '{ $x ~~ Int }' failed«␤»\n\n"},{"name":"X::Declaration::Scope","methods":["scope\n\n    method scope(--> Str:D)\n\nReturns a string representation of the scope, usually the same keyword that\nis used for the declaration (\"my\", \"our\", \"has\", ...);","declaration\n\n    method declaration(--> Str:D)\n\nDescribes the symbol that has been declared in a wrong scope."],"desc":"TITLE\nclass X::Declaration::Scope\n\nSUBTITLE\nCompilation error due to a declaration with an ineligible scope\n\n    class X::Declaration::Scope does X::Comp { }\n\n\nCompile time error thrown when a declaration does not harmonize with the\ndeclared scope.\n\nFor example\n\n    has sub f() { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use 'has' with sub declaration\n\n\n"},{"methods":["type\n\n    method type(X::Does::TypeObject:D: --> Mu:U)\n\nReturns the type object into which the code tried to mix in a role."],"desc":"TITLE\nclass X::Does::TypeObject\n\nSUBTITLE\nError due to mixing into a type object\n\n    class X::Does::TypeObject is Exception {}\n\nWhen you try to add one or more roles to a type object with does after it\nhas been composed, an error of type X::Does::TypeObject is thrown:\n\n    Mu does Numeric;    # Cannot use 'does' operator with a type object.\n\n\nThe correct way to apply roles to a type is at declaration time:\n\n    class GrassmannNumber does Numeric { ... };\n    role AlgebraDebugger does IO { ... };\n    grammar IntegralParser does AlgebraParser { ... };\n\n\nRoles may only be runtime-mixed into defined object instances:\n\n    GrassmannNumber.new does AlgebraDebugger;\n\n\n(This restriction may be worked around by using augment or supersede, or\nwith dark Metamodel magics, but this will likely result in a significant\nperformance penalty.)\n\n","name":"X::Does::TypeObject"},{"name":"X::Attribute::Required","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the attribute.","why\n\n    method why(--> Str:D)\n\nReturns the reason why that attribute is required, and it will be included\nin the message if provided. That reason is taken directly from the is\nrequired trait.\n\n    my class Uses-required {\n        has $.req is required(\"because yes\")\n    };\n    my $object = Uses-required.new();                                  │\n    # OUTPUT:\n    # «(exit code 1) The attribute '$!req' is required because because yes,␤\n    # but you did not provide a value for it.␤»"],"desc":"TITLE\nclass X::Attribute::Required\n\nSUBTITLE\nCompilation error due to not declaring an attribute with the is required\ntrait\n\n    class X::Attribute::NoPackage does X::MOP { }\n\nCompile time error thrown when a required attribute is not assigned when\ncreating an object.\n\nFor example\n\n    my class Uses-required {\n        has $.req is required\n    };\n    my $object = Uses-required.new()\n\n\nDies with\n\n    OUTPUT: «(exit code 1) The attribute '$!req' is required, but you did not provide a value for it.␤»\n\n\n"},{"methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the attribute that triggered this error.","package-kind\n\n    method package-kind(--> Str:D)\n\nReturns the kind of package (package, module) that doesn't support\nattributes."],"desc":"TITLE\nclass X::Attribute::Package\n\nSUBTITLE\nCompilation error due to declaring an attribute in an ineligible package\n\n    class X::Attribute::Package does X::Comp { }\n\nCompile time error, thrown when the compiler encounters an attribute\ndeclaration inside a package that does not support attributes.\n\nFor example\n\n    module A { has $.x }\n\n\ndies with\n\n    A module cannot have attributes, but you tried to declare '$.x'\n\n\n","name":"X::Attribute::Package"},{"name":"X::Attribute::NoPackage","methods":["name\n\n    method name(--> Str:D)\n\nReturns the name of the attribute"],"desc":"TITLE\nclass X::Attribute::NoPackage\n\nSUBTITLE\nCompilation error due to declaring an attribute outside of a package\n\n    class X::Attribute::NoPackage does X::Comp { }\n\nCompile time error thrown when an attribute is declared where it does not\nmake sense (for example in the mainline).\n\nFor example\n\n    has $.x;\n\n\nDies with\n\n    You cannot declare attribute '$.x' here; maybe you'd like a class or a role?\n\n\n"},{"name":"X::Attribute::Undeclared","desc":"TITLE\nclass X::Attribute::Undeclared\n\nSUBTITLE\nCompilation error due to an undeclared attribute\n\n    class X::Attribute::Undeclared is X::Undeclared { }\n\nThrown when code refers to an attribute that has not been declared.\n\nFor example the code\n\n    class A { method m { $!notthere } }\n\n\nProduces the error\n\n    Attribute $!notthere not declared in class A\n\n\n","methods":["package-kind\n\nReturns the kind of package the attribute was used in (for example class,\ngrammar)","package-name\n\nReturns the name of the package in which the offensive attribute reference\nwas performed."]},{"name":"X::Augment::NoSuchType","methods":["package-kind\n\n    method package-kind(--> Str:D)\n\nReturns the kind of package (class, grammar) that is being tried to\naugment","package\n\nReturns the name that was tried to augment, but which doesn't exist."],"desc":"TITLE\nclass X::Augment::NoSuchType\n\nSUBTITLE\nCompilation error due to augmenting a non-existing type\n\n    class X::Augment::NoSuchType does X::Comp { }\n\nThrown when trying to augment a type which doesn't exist.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class NoSuch { }\n\n\ndies with\n\n    You tried to augment class NoSuch, but it does not exist\n\n\n"},{"name":"X::Caller::NotDynamic","methods":["symbol\n\nReturns the name of the symbol that was passed to CALLER."],"desc":"TITLE\nclass X::Caller::NotDynamic\n\nSUBTITLE\nError while trying to access a non dynamic variable through CALLER\n\n    class X::Caller::NotDynamic is Exception { }\n\nThrown when trying to access a non dynamic variable through CALLER\n\nA typical error message is\n\n    Cannot access '$x' through CALLER, because it is not declared as dynamic\n\n\n"},{"name":"X::Parameter::Placeholder","desc":"TITLE\nclass X::Parameter::Placeholder\n\nSUBTITLE\nCompilation error due to an unallowed placeholder in a signature\n\n    class X::Parameter::Placeholder does X::Comp { }\n\nThrown when a placeholder parameter is used inside a signature where a\nnormal parameter is expected. The reason is often that a named parameter\n:$param was misspelled as $:param.\n\nFor example\n\n    sub f($:param) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter, placeholder variables like $:param are illegal\n    you probably meant a named parameter: ':$param'\n\n\n","methods":["parameter\n\nThe text of the offensive parameter declaration ($:param in the example\nabove).","right\n\nSuggestion on how to write the parameter declaration instead (:$param in\nthe example above)."]},{"desc":"TITLE\nclass X::Parameter::WrongOrder\n\nSUBTITLE\nCompilation error due to passing parameters in the wrong order\n\n    class X::Parameter::WrongOrder does X::Comp { }\n\nCompile time error that is thrown when parameters in a signature in the\nwrong order (for example if an optional parameter comes before a mandatory\nparameter).\n\nFor example\n\n    sub f($a?, $b) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put required parameter $b after optional parameters\n\n\n","methods":["misplaced\n\nReturns the kind of misplaced parameter (for example \"mandatory\",\n\"positional\").","parameter\n\nReturns the name of the (first) misplaced parameter","after\n\nReturns a string describing other parameters after which the current\nparameter was illegally placed (for example \"variadic\", \"positional\" or\n\"optional\")."],"name":"X::Parameter::WrongOrder"},{"name":"X::Parameter::Twigil","methods":["parameter\n\nThe name of the offensive parameter ($=foo in the example above)","twigil\n\nThe illegally used twigil."],"desc":"TITLE\nclass X::Parameter::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a signature\n\n    class X::Parameter::Twigil does X::Comp { }\n\nThrown when a parameter in a signature has a twigil that it may not have.\nOnly !, . and * as twigils are allowed.\n\nExample:\n\n    sub f($=foo) { }\n\n\ndies with\n\n    ===SORRY!===\n    In signature parameter $=foo, it is illegal to use the = twigil\n\n\n"},{"name":"X::Parameter::MultipleTypeConstraints","methods":["parameter\n\nReturns the name of the offensive parameter."],"desc":"TITLE\nclass X::Parameter::MultipleTypeConstraints\n\nSUBTITLE\nCompilation error due to a parameter with multiple type constraints\n\n    class X::Parameter::MultipleTypeConstraints does X::Comp { }\n\nCompile time error thrown when a parameter has multiple type constraints.\nThis is not allowed in Raku.0.\n\nExample:\n\n    sub f(Cool Real $x) { }\n\n\ndies with\n\n    Parameter $x may only have one prefix type constraint\n\n\n"},{"name":"X::Parameter::Default","desc":"TITLE\nclass X::Parameter::Default\n\nSUBTITLE\nCompilation error due to an unallowed default value in a signature\n\n    class X::Parameter::Default does X::Comp { }\n\nCompile-time error thrown when a parameter in a signature has default\nvalue, but isn't allowed to have one. That is the case with slurpy\nparameters (because a slurpy always binds successfully, even to zero\narguments) and with mandatory parameters.\n\nExample:\n\n    sub f($x! = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on required parameter $x\n\n\nAnd\n\n    sub f(*@ = 3) { }\n\n\ndies with\n\n    ===SORRY!===\n    Cannot put default on anonymous slurpy parameter\n\n\n","methods":["how\n\nReturns a string describing how the parameter is qualified that makes it\ndisallow default values, for example \"slurpy\" or \"mandatory\".","parameter\n\nReturns the parameter name"]},{"name":"X::Numeric::Real","methods":["source\n\n    method source(--> Numeric:D)\n\nReturns the number that failed to coerce to Real.","target\n\n    method target()\n\nReturns the type to which the coercion was attempted.","reason\n\n    method reason(--> Str:D)\n\nReturns the reason that the conversion failed."],"desc":"TITLE\nclass X::Numeric::Real\n\nSUBTITLE\nError while trying to coerce a number to a Real type\n\n    class X::Numeric::Real is Exception { }\n\nOccurs when an attempt to coerce a Numeric to a Real, Num, Int or Rat fails\n(due to a number with a nonzero imaginary part, for instance).\n\nFor example\n\n    say (1+2i).Int;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Numeric::Real: Can not convert 1+2i to Int: imaginary part not zero␤»\n\n"},{"desc":"TITLE\nclass X::Anon::Multi\n\nSUBTITLE\nCompilation error due to declaring an anonymous multi\n\n    class X::Anon::Multi does X::Comp { }\n\nCompile time error thrown when an anonymous multi is being declared.\n\nFor example\n\n    multi method () { }\n\n\ndies with\n\n    Cannot put multi on anonymous method\n\n\n","methods":["multiness\n\n    method multiness(--> Str:D)\n\nReturns a string describing the multiness that the original code used, for\nexample \"multi\" or \"proto\".","routine-type\n\n    method routine-type(--> Str:D)\n\nReturns a string describing the type of routine that was declared, for\nexample \"sub\" or \"method\"."],"name":"X::Anon::Multi"},{"desc":"TITLE\nclass X::Anon::Augment\n\nSUBTITLE\nCompilation error due to augmenting an anonymous package\n\n    class X::Anon::Augment does X::Comp { }\n\nCompile time error thrown when trying to augment an anonymous package.\n\nFor example\n\n    use MONKEY-TYPING;\n    augment class { }\n\n\nDies with\n\n    Cannot augment anonymous class\n\n\n","methods":["package-kind\n\n    method package-kind returns Str:D\n\nReturns the kind of package (module, class, grammar, ...) that the code\ntried to augment."],"name":"X::Anon::Augment"},{"methods":[],"desc":"TITLE\nclass X::Constructor::Positional\n\nSUBTITLE\nError due to passing positional arguments to a default constructor\n\n    class X::Constructor::Positional is Exception { }\n\nThrown from Mu.new when positional arguments are passed to it.\n\nFor example\n\n    class A { };\n    A.new(2, 3);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Constructor::Positional: Default constructor for 'A' only takes named arguments␤»","name":"X::Constructor::Positional"},{"name":"X::Str::Numeric","desc":"TITLE\nclass X::Str::Numeric\n\nSUBTITLE\nError while trying to coerce a string to a number\n\n    class X::Str::Numeric is Exception { }\n\nError thrown (or wrapped in a Failure) when a conversion from string to a\nnumber fails.\n\nFor example\n\n    say +\"42 answers\";\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Str::Numeric: Cannot convert string to number: trailing characters after number in '42⏏ answers' (indicated by ⏏)␤»\n\n","methods":["source\n\n    method source(--> Str:D)\n\nReturns the string that was attempted to convert to a number","pos\n\n    method pos(--> Int:D)\n\nGives the position into the string where the parsing failed.","reason\n\n    method reason(--> Int:D)\n\nVerbal description of the reason why the conversion failed."]},{"name":"X::Placeholder::Block","methods":["placeholder\n\nReturns the name of the (first) illegally used placeholder."],"desc":"TITLE\nclass X::Placeholder::Block\n\nSUBTITLE\nCompilation error due to a placeholder in an ineligible block\n\n    class X::Placeholder::Block does X::Comp {}\n\nThrown when a placeholder variable is used in a block that does not allow a\nsignature.\n\nFor example\n\n    class A { $^foo }\n\n\ndies with\n\n    Placeholder variable $^foo may not be used here because the surrounding block takes no signature\n\n\n"},{"desc":"TITLE\nclass X::Placeholder::Mainline\n\nSUBTITLE\nCompilation error due to a placeholder in the mainline\n\n    class X::Placeholder::Mainline is X::Placeholder::Block { }\n\nThrown when a placeholder variable is used in the mainline, i.e. outside of\nany explicit block.\n\nFor example\n\n    $^x;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use placeholder parameter $^x outside of a sub or block\n\n\nNote that this error can also occur when you think something is a block,\nbut it really is a postcircumfix:<{ }>, for example\n\n    my %h;\n    say %h{ $^x };\n    #     ^^^^^^^  not a block, so $^x is part of the mainline\n","methods":[],"name":"X::Placeholder::Mainline"},{"desc":"TITLE\nclass X::Composition::NotComposable\n\nSUBTITLE\nCompilation error due to composing an ineligible type\n\n    class X::Composition::NotComposable is Exception { }\n\nThrown when trying to compose a type into a target type, but the composer\ntype cannot be used for composition (roles and enums are generally OK).\n\nFor example\n\n    class A { }\n    class B does A { }\n\n\ndies with\n\n    ===SORRY!===\n    ␤A is not composable, so B cannot compose it\n\n\nbecause does is reserved for role composition, and A is not a role, nor\nsomething that knows how to turn into a role.\n\nThe fix is to either make A a role, or use inheritance (class B is A { })\ninstead.\n\n","methods":["target-name\n\n    method target-name(--> Str:D)\n\nReturns the name of the type that should be composed, but failed.","composer\n\n    method composer(--> Mu)\n\nReturns the type that should be composed into the target, but which isn't a\nrole."],"name":"X::Composition::NotComposable"},{"methods":["method\n\n    method method(--> Str:D)\n\nReturns the name of the private method that triggered the error."],"desc":"TITLE\nclass X::Method::Private::Unqualified\n\nSUBTITLE\nCompilation error due to an unqualified private method call\n\n    class X::Method::Private::Unqualified does X::Comp { }\n\nCompile time error thrown when a private method call on anything but self\nis not fully qualified.\n\nFor example\n\n    1!priv\n\n\ndies with\n\n    ===SORRY!===\n    Private method call to priv must be fully qualified with the package containing the method\n\n\n","name":"X::Method::Private::Unqualified"},{"name":"X::Method::Private::Permission","desc":"TITLE\nclass X::Method::Private::Permission\n\nSUBTITLE\nCompilation error due to calling a private method without permission\n\n    class X::Method::Private::Permission does X::Comp { }\n\nCompile time error thrown when the code contains a call to a private method\nthat isn't defined in the current class, and when no appropriate trusts\nrelation is defined that permits the private method call.\n\nFor example\n\n    1!Int::foo\n\n\ndies with\n\n    ===SORRY!===\n    Cannot call private method 'foo' on package Int because it does not trust GLOBAL\n\n\n","methods":["method\n\n    method method(--> Str:D)\n\nThe name of the private method","source-package\n\n    method source-package(--> Mu:D)\n\nReturns the type object that (supposedly) contains the private method.","calling-package\n\n    method calling-package(--> Mu:D)\n\nReturns the package in which the calling code is, and which the source\npackage does not trust."]},{"methods":["method\n\n    method method(X::Proc::Async::MustBeStarted:D --> Str:D)\n\nReturns the name of the method that was illegally called before starting\nthe external program."],"desc":"TITLE\nclass X::Proc::Async::MustBeStarted\n\nSUBTITLE\nError due to interacting with a Proc::Async stream before spawning its\nprocess\n\n    class X::Proc::Async::MustBeStarted is Exception {}\n\nSeveral methods from Proc::Async expect that the external program has been\nspawned (by calling .start on it), including say, write, print and\nclose-stdin. If one of those methods is called before .start was called,\nthey throw an exception of type X::Proc::Async::MustBeStarted.\n\n    Proc::Async.new('echo', :w).say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::MustBeStarted: Process must be started first before calling 'say'␤»\n\n","name":"X::Proc::Async::MustBeStarted"},{"desc":"TITLE\nclass X::Proc::Async::BindOrUse\n\nSUBTITLE\nError due to trying to bind a handle that is also used\n\n        class X::Proc::Async::BindOrUse does X::Proc::Async {}\n\n\nIn general, it occurs when there's some mistake in the direction the stream\nflows, for instance:\n\n    my $p = Proc::Async.new(\"ls\", :w);\n    my $h = \"ls.out\".IO.open(:w);\n    $p.bind-stdin($h);\n    # Fails with OUTPUT: «Cannot both bind stdin to a handle and also use :w␤»\n\n\nIn this case, stdin is already bound and cannot be used again; one of them\nshould flow :out and the other one :w to work correctly.","methods":[],"name":"X::Proc::Async::BindOrUse"},{"name":"X::Proc::Async::TapBeforeSpawn","methods":["handle\n\n    method handle(X::Proc::Async::TapBeforeSpawn:D: --> Str:D)\n\nReturns the name of the handle (stdout or stderr) that was accessed after\nthe program started."],"desc":"TITLE\nclass X::Proc::Async::TapBeforeSpawn\n\nSUBTITLE\nError due to tapping a Proc::Async stream after spawning its process\n\n    class X::Proc::Async::TapBeforeSpawn is Exception {}\n\nIf the stdout or stderr methods of Proc::Async are called after the program\nhas been started, an exception of type X::Proc::Async::TapBeforeSpawn is\nthrown.\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.start;\n    $proc.stdout.tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::TapBeforeSpawn: To avoid data races, you must tap stdout before running the process␤»\n\nThe right way is the reverse order\n\n    my $proc = Proc::Async.new(\"echo\", \"foo\");\n    $proc.stdout.tap(&print);\n    await $proc.start;\n\n"},{"name":"X::Proc::Async::AlreadyStarted","methods":[],"desc":"TITLE\nclass X::Proc::Async::AlreadyStarted\n\nSUBTITLE\nError due to calling start on an already started Proc::Async object\n\n    class X::Proc::Async::AlreadyStarted is Exception {}\n\nWhen you call start twice on the same Proc::Async object, the second\ninvocation will die with an X::Proc::Async::AlreadyStarted exception.\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.start;\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::AlreadyStarted: Process has already been started␤»"},{"methods":["method\n\n    method method(X::Proc::Async::OpenForWriting:D:)\n\nReturns the method name that was called and which caused the exception."],"desc":"TITLE\nclass X::Proc::Async::OpenForWriting\n\nSUBTITLE\nError due to writing to a read-only Proc::Async object\n\n    class X::Proc::Async::OpenForWriting is Exception {}\n\nWhen a Proc::Async object is opened only for reading from the external\nprogram (no :w passed to open), and a write operation such as write, print\nand say is performed, an exception of type X::Proc::Async::OpenForWriting\nis thrown:\n\n    my $proc = Proc::Async.new(\"echo\");\n    $proc.start;\n    $proc.say(42);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::OpenForWriting: Process must be opened for writing with :w to call 'say'␤»\n\nTo fix that you can use writable commands with :w flag:\n\n    my $prog = Proc::Async.new(:w, 'cat');\n    $prog.stdout.tap( -> $str {\n        print $str;\n    });\n    my $promise = $prog.start;\n    await $prog.say('foo');\n    $prog.close-stdin;\n    await $promise;\n\n","name":"X::Proc::Async::OpenForWriting"},{"name":"X::Proc::Async::CharsOrBytes","methods":["handle\n\n    method handle(X::Proc::Async::CharsOrBytes:D: --> Str:D)\n\nReturns the name of the handle that was accessed both for text and for\nbinary data, stdout or stderr."],"desc":"TITLE\nclass X::Proc::Async::CharsOrBytes\n\nSUBTITLE\nError due to tapping the same Proc::Async stream for both text and binary\nreading\n\n    class X::Proc::Async::CharsOrBytes is Exception {}\n\nA Proc::Async object allows subscription to the output or error stream\neither for bytes (Blob) or for text data (Str), but not for both. If you do\ntry both, it throws an exception of type X::Proc::Async::CharsOrBytes.\n\n    my $proc = Proc::Async.new('echo');\n    $proc.stdout.tap(&print);\n    $proc.stdout(:bin).tap(&print);\n    CATCH { default { put .^name, ': ', .Str } };\n    # OUTPUT: «X::Proc::Async::CharsOrBytes: Can only tap one of chars or bytes supply for stdout␤»\n\n"},{"methods":[],"desc":"TITLE\nclass X::Syntax::Signature::InvocantMarker\n\nSUBTITLE\nCompilation error due to a misplaced invocant marker in a signature\n\n    class X::Syntax::Signature::InvocantMarker does X::Syntax { }\n\nSyntax error when the invocant in a signature is anywhere else than after\nthe first parameter.\n\nFor example\n\n    :($a, $b: $c);\n\n\ndies with\n\n    ===SORRY!===\n    Can only use : as invocant marker in a signature after the first parameter\n\n\nSee also: Signature.","name":"X::Syntax::Signature::InvocantMarker"},{"methods":[],"desc":"TITLE\nclass X::Syntax::Term::MissingInitializer\n\nSUBTITLE\nCompilation error due to declaring a term without initialization\n\n    class X::Syntax::Term::MissingInitializer does X::Syntax { }\n\nSyntax error when a term (a backslash variable) is declared without\ninitialization assignment.\n\nFor example\n\n    my \\foo;\n\n\ndies with\n\n    ===SORRY!===\n    Term definition requires an initializer\n\n\nValid code would be\n\n    my \\foo = 42;\n","name":"X::Syntax::Term::MissingInitializer"},{"desc":"TITLE\nclass X::Syntax::Variable::Numeric\n\nSUBTITLE\nCompilation error due to declaring a numeric symbol\n\n    class X::Syntax::Variable::Numeric does X::Syntax { }\n\nSyntax error thrown when trying to declare numeric symbols.\n\nFor example\n\n    my @101;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a numeric variable\n\n\n","methods":["what\n\n    method what returns Str:D\n\nReturns a verbal description of the kind of symbol that was declared\n(variable, parameter, attribute)."],"name":"X::Syntax::Variable::Numeric"},{"name":"X::Syntax::Variable::Match","methods":[],"desc":"TITLE\nclass X::Syntax::Variable::Match\n\nSUBTITLE\nCompilation error due to declaring a match variable\n\n    class X::Syntax::Variable::Match does X::Syntax { }\n\nSyntax error thrown when a match variable like $<thing>  was declared.\n\nFor example\n\n    my $<thing>;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot declare a match variable\n"},{"methods":["twigil\n\n    method twigil(--> Str:D)\n\nReturns the twigil that was illegally used","scope\n\n    method scope(--> Str:D)\n\nReturns the scope that did not harmonize with the twigil."],"desc":"TITLE\nclass X::Syntax::Variable::Twigil\n\nSUBTITLE\nCompilation error due to an unallowed twigil in a declaration\n\n    class X::Syntax::Variable::Twigil does X::Syntax { }\n\nSyntax error thrown when a variable with a twigil is used in an\nincompatible declaration.\n\nFor example\n\n    my $!foo;\n\n\ndies with\n\n    ===SORRY!===\n    Cannot use ! twigil on my variable\n\n\n","name":"X::Syntax::Variable::Twigil"},{"name":"X::Syntax::Regex::SolitaryQuantifier","desc":"TITLE\nclass X::Syntax::Regex::SolitaryQuantifier\n\nSUBTITLE\nCompilation error due to a regex quantifier without preceding atom\n\n    class X::Syntax::Regex::SolitaryQuantifier does X::Syntax { }\n\nSyntax error when a stand alone quantifier (without a preceding atom to\nquantify) is encountered in a regular expression.\n\nFor example\n\n    / * /;\n\n\ndies with\n\n    ===SORRY!===\n    Quantifier quantifies nothing\n","methods":[]},{"methods":["adverb\n\n    method adverb(--> Str:D)\n\nReturns the illegally used adverb","construct\n\n    method construct(--> Str:D)\n\nReturns the name of the construct that adverb was used on (m, ms, rx, s,\nss)."],"desc":"TITLE\nclass X::Syntax::Regex::Adverb\n\nSUBTITLE\nCompilation error due to an unrecognized regex adverb\n\n    class X::Syntax::Regex::Adverb does X::Syntax { }\n\nSyntax error thrown when an unrecognized or illegal regex adverb is\nencountered.\n\nFor example\n\n    rx:g/a/\n\n\ndies with\n\n    ===SORRY!===\n    Adverb g not allowed on rx\n\n\nbecause :g belongs to a match operation, not a regex itself.\n\n","name":"X::Syntax::Regex::Adverb"},{"name":"X::Syntax::Augment::WithoutMonkeyTyping","methods":[],"desc":"TITLE\nclass X::Syntax::Augment::WithoutMonkeyTyping\n\nSUBTITLE\nCompilation error due to augmenting a type without the MONKEY-TYPING\npragma\n\n    class X::Syntax::Augment::WithoutMonkeyTyping does X::Syntax { }\n\nCompile time error thrown when augment is used without use MONKEY-TYPING.\n\nSince augment is considered a rather unsafe and impolite action, you have\nto pre-declare your intent with the use MONKEY-TYPING; pragma.\n\nIf you don't do that, like here\n\n    augment class Int { };\n\n\nyou get the error\n\n    ===SORRY!===\n    augment not allowed without 'use MONKEY-TYPING'\n"},{"name":"X::Syntax::Comment::Embedded","desc":"TITLE\nclass X::Syntax::Comment::Embedded\n\nSUBTITLE\nCompilation error due to a malformed inline comment\n\n    class X::Syntax::Comment::Embedded does X::Syntax { }\n\nSyntax error thrown when #` is encountered and it is not followed by an\nopening curly brace.\n\nFor example\n\n    #`\n\n\ndies with\n\n    ===SORRY!===\n    Opening bracket is required for #` comment\n","methods":[]},{"name":"X::Syntax::Number::RadixOutOfRange","desc":"TITLE\nclass X::Syntax::Number::RadixOutOfRange\n\nSUBTITLE\nCompilation error due to an unallowed radix in a number literal\n\n    class X::Syntax::Number::RadixOutOfRange does X::Syntax { }\n\nSyntax error that is thrown when the radix of a radix number is not\nallowed, like :1<1>  or :42<ouch> .\n\n","methods":["radix\n\n    method radix(--> Int:D)\n\nThe offensive radix."]},{"methods":[],"desc":"TITLE\nclass X::Syntax::Self::WithoutObject\n\nSUBTITLE\nCompilation error due to invoking self in an ineligible scope\n\n    class X::Syntax::Self::WithoutObject does X::Syntax { }\n\nSyntax error thrown when self is referenced in a place where no invocant is\navailable.\n\nFor example\n\n    self;\n\n\noutside a class or role declaration dies with\n\n    ===SORRY!===\n    'self' used where no object is available\n","name":"X::Syntax::Self::WithoutObject"},{"methods":[],"desc":"TITLE\nclass X::Declaration::Scope::Multi\n\nSUBTITLE\nCompilation error due to declaring a multi with an ineligible scope\n\n    class X::Declaration::Scope::Multi is X::Declaration::Scope { }\n\nThrown when a multi is declared with an incompatible scope.\n\nFor example our multi sub foo() { } dies with\n\n    ===SORRY!===\n    Cannot use 'our' with individual multi candidates. Please declare an our-scoped proto instead\n","name":"X::Declaration::Scope::Multi"}]